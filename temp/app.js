/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}

/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}

/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}


/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}

/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "cb004ffc5784eff69288"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars

/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}

/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}

/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}

/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],

/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},

/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},

/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}

/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";

/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}

/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;

/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;

/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}

/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}

/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;

/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}

/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}

/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}

/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}

/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}

/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};

/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}

/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}

/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}

/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}

/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}

/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;

/******/ 			var data = {};

/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;

/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;

/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];

/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}

/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}

/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");

/******/ 		hotCurrentHash = hotUpdateNewHash;

/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}

/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}

/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}

/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}

/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };

/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(49);
	module.exports = __webpack_require__(106);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.config = undefined;
	exports.destroyConfig = destroyConfig;
	exports.initPathAddress = initPathAddress;
	exports.initConfig = initConfig;

	var _native = __webpack_require__(93);

	var _native2 = _interopRequireDefault(_native);

	var _iframe = __webpack_require__(92);

	var _iframe2 = _interopRequireDefault(_iframe);

	var _get = __webpack_require__(19);

	var _get2 = __webpack_require__(91);

	var _view = __webpack_require__(174);

	var _view2 = _interopRequireDefault(_view);

	var _proportion = __webpack_require__(173);

	var _global = __webpack_require__(105);

	var _global2 = _interopRequireDefault(_global);

	var _default = __webpack_require__(90);

	var _default2 = _interopRequireDefault(_default);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 默认配置与模式
	 */
	/**
	 * 配置文件
	 * @return {[type]}         [description]
	 */
	var plat = Xut.plat;
	var isIphone = Xut.plat.isIphone;
	var isBrowser = Xut.plat.isBrowser;
	var GLOBALIFRAME = window.GLOBALIFRAME;
	var CLIENTCONFIGT = window.CLIENTCONFIGT;
	var MMXCONFIG = window.MMXCONFIG;

	var config = Object.create(null);
	var layoutMode = void 0;
	var proportion = void 0;

	/**
	 * 层级关系
	 * @return {[type]} [description]
	 */
	Xut.zIndexlevel = function () {
	    return ++config.zIndexlevel;
	};

	//通过新学堂加载
	//用于处理iframe窗口去全屏
	if (/xinxuetang/.test(window.location.href)) {
	    config.iframeFullScreen = true;
	}

	/**
	 * 是否启动缓存机制
	 * 第一次默认是关闭
	 * 必须读取一次后，缓存启动
	 * 为了支持window.DYNAMICCONFIGT模式
	 * @type {Boolean}
	 */
	var isCacheVideoPath = false;
	var isCacheAudioPath = false;
	var isCacheSvgPath = false;
	var isCacheJsWidgetPath = false;

	var cacheVideoPath = void 0;
	var cacheAudioPath = void 0;
	var cacheSvgPath = void 0;
	var cacheJsWidgetPath = void 0;

	/**
	 * pc端模式
	 * 而且是客户端模式
	 * @return {[type]} [description]
	 */
	var desktopPlat = function desktopPlat() {

	    //2016.9.13
	    //新增动态模式
	    if (window.DYNAMICCONFIGT) {
	        return (0, _get.getSourcePath)();
	    }

	    //如果是iframe加载
	    //而且是客户端模式
	    if (GLOBALIFRAME && CLIENTCONFIGT) {
	        return CLIENTCONFIGT.path;
	    }

	    if (typeof initGalleryUrl != 'undefined') {
	        return (0, _get.getSourcePath)();
	    } else {
	        //资源存放位置
	        // * storageMode 存放的位置
	        // * 0 APK应用本身
	        // 1 外置SD卡
	        if (Number(config.storageMode)) {
	            return "sdcard/" + config.appId + "/" + (0, _get.getSourcePath)();
	        } else {
	            return (0, _get.getSourcePath)();
	        }
	    }
	};

	/**
	 * 平台加载用于
	 * 视频.音频妙妙学处理
	 * 1 桌面
	 * 2 移动端
	 * 3 安卓打包后通过网页访问=>妙妙学
	 * @return {[type]} [description]
	 */
	var runMode = function () {
	    if (MMXCONFIG) {
	        return false;
	    }
	    return isBrowser;
	}();

	/**
	 * 图片资源配置路径
	 * [resourcesPath description]
	 * @return {[type]} [description]
	 */
	var _rsourcesPath = function _rsourcesPath() {
	    return isBrowser ? desktopPlat() : GLOBALIFRAME ? _iframe2.default.resources(config) : _native2.default.resources(config);
	};

	/**
	 * mp3 mp4 音频文件路径
	 * 1 音频加载就会自动拷贝到SD卡上
	 * 2 或者asset上的资源
	 * @return {[type]} [description]
	 */
	var _videoPath = function _videoPath() {
	    return runMode ? desktopPlat() : GLOBALIFRAME ? _iframe2.default.video() : _native2.default.video();
	};

	/**
	 * 音频路径
	 * @return {[type]} [description]
	 */
	var _audioPath = function _audioPath() {
	    return runMode ? desktopPlat() : GLOBALIFRAME ? _iframe2.default.audio() : _native2.default.audio();
	};

	/**
	 * SVG文件路径
	 * @return {[type]} [description]
	 */
	var _svgPath = function _svgPath() {
	    return isBrowser ? desktopPlat() : GLOBALIFRAME ? _iframe2.default.svg() : _native2.default.svg();
	};

	/**
	 * js零件
	 * 2016.8.3 妙妙学新增
	 * 只提供相对路径
	 * @return {[type]} [description]
	 */
	var _jsWidgetPath = function _jsWidgetPath() {
	    return isBrowser ? (0, _get.getWidgetPath)() : GLOBALIFRAME ? _iframe2.default.jsWidget() : _native2.default.jsWidget();
	};

	/**
	 * 全局配置文件
	 * @type {Boolean}
	 */
	_.extend(config, {

	    /**
	     * 视频文件路径
	     * @return {[type]} [description]
	     */
	    getVideoPath: function getVideoPath() {
	        if (isCacheVideoPath && cacheVideoPath) {
	            return cacheVideoPath;
	        }
	        isCacheVideoPath = true;
	        return cacheVideoPath = _videoPath();
	    },


	    /**
	     * 音频文件路径
	     * @return {[type]} [description]
	     */
	    getAudioPath: function getAudioPath() {
	        if (isCacheAudioPath && cacheAudioPath) {
	            return cacheAudioPath;
	        }
	        isCacheAudioPath = true;
	        return cacheAudioPath = _audioPath();
	    },


	    /**
	     * 配置SVG文件路径
	     * @return {[type]} [description]
	     */
	    getSvgPath: function getSvgPath() {
	        if (isCacheSvgPath && cacheSvgPath) {
	            return cacheSvgPath;
	        }
	        isCacheSvgPath = true;
	        return cacheSvgPath = _svgPath();
	    },


	    /**
	     * 配置js零件文件路径
	     * 2016.8.3增加
	     * @return {[type]} [description]
	     */
	    getWidgetPath: function getWidgetPath() {
	        if (isCacheJsWidgetPath && cacheJsWidgetPath) {
	            return cacheJsWidgetPath;
	        }
	        isCacheJsWidgetPath = true;
	        return cacheJsWidgetPath = _jsWidgetPath();
	    },


	    /**
	     * 排版模式
	     * @type {[type]}
	     */
	    layoutMode: layoutMode,

	    /**
	     * 缩放比例
	     * @type {[type]}
	     */
	    proportion: proportion,

	    /**
	     * 是浏览器
	     * @type {Boolean}
	     */
	    isBrowser: isBrowser,

	    /**
	     * 全局层级初始值
	     * @type {Number}
	     */
	    zIndexlevel: 1000,

	    /**
	     * 默认图标高度
	     * @type {[type]}
	     */
	    iconHeight: isIphone ? 32 : 44,

	    /**
	     * 数据库尺寸
	     * @type {Number}
	     */
	    dbSize: 1

	}, _global2.default, _default2.default);

	Xut.config = config;

	exports.config = config;

	/**
	 * 销毁配置
	 * @return {[type]} [description]
	 */

	function destroyConfig() {
	    cacheVideoPath = null;
	    cacheAudioPath = null;
	    cacheSvgPath = null;
	    cacheJsWidgetPath = null;
	}

	/**
	 * 初始化资源路径
	 * 配置图片路径地址
	 * @return {[type]} [description]
	 */
	function initPathAddress() {
	    //设置资源缓存关闭
	    isCacheVideoPath = false;
	    isCacheAudioPath = false;
	    isCacheSvgPath = false;
	    isCacheJsWidgetPath = false;
	    config.pathAddress = _rsourcesPath();
	}

	/**
	 * 重写默认设置
	 * 通过数据库中的设置的模板尺寸与实际尺寸修复
	 * @type {[type]}
	 */
	var setProportion = function setProportion(pptWidth, pptHeight) {

	    //数据ppt排版设计
	    if (pptWidth && pptHeight) {
	        config.pptHorizontal = pptWidth > pptHeight ? true : false;
	        config.pptVertical = !config.pptHorizontal;
	    }

	    /**
	     * 获取全屏比值，用来设定view的尺寸
	     * @type {[type]}
	     */
	    var fullProportion = (0, _proportion.getFullProportion)(config, pptWidth, pptHeight);

	    /**
	     * 可视区域尺寸
	     * @type {Object}
	     */
	    var viewSize = config.viewSize = (0, _view2.default)(config, fullProportion);

	    /**
	     * 判断是否溢出与是否填充
	     * @return {[type]} [description]
	     */
	    viewSize.overflowWidth = false;
	    viewSize.notFillWidth = false;
	    if (viewSize.left < 0) {
	        //溢出宽度
	        viewSize.overflowWidth = true;
	    } else if (viewSize.left > 0) {
	        //没有填满宽度
	        viewSize.notFillWidth = true;
	    }

	    /**
	     * 溢出高度
	     * @param  {[type]}
	     * @return {[type]}
	     * */
	    viewSize.overflowHeight = false;
	    viewSize.notFillHeight = false;
	    if (viewSize.top < 0) {
	        //溢出宽度
	        viewSize.overflowHeight = true;
	    } else if (viewSize.top > 0) {
	        //没有填满宽度
	        viewSize.notFillHeight = true;
	    }

	    /**
	     * 获取全局缩放比
	     * @type {[type]}
	     */
	    proportion = config.proportion = (0, _proportion.getRealProportion)(config, viewSize, fullProportion);
	};

	/**
	 * 默认设置
	 * viewSize,screenSize,layoutMode,proportion
	 * @return {[type]} [description]
	 */
	function initConfig(pptWidth, pptHeight) {

	    /**
	     * 获取分辨率
	     * @type {[type]}
	     */
	    config.screenSize = (0, _get2.getSize)();

	    /**
	     * 根据设备判断设备的横竖屏
	     * @type {[type]}
	     */
	    config.screenHorizontal = config.screenSize.width > config.screenSize.height ? true : false;
	    config.screenVertical = !config.screenHorizontal;

	    layoutMode = config.layoutMode = (0, _get2.getLayerMode)(config.screenSize);

	    /**
	     * 设置缩放比
	     */
	    setProportion(pptWidth, pptHeight);
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lang = __webpack_require__(3);

	Object.keys(_lang).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _lang[key];
	    }
	  });
	});

	var _dom = __webpack_require__(5);

	Object.keys(_dom).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _dom[key];
	    }
	  });
	});

	var _loader = __webpack_require__(10);

	Object.keys(_loader).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _loader[key];
	    }
	  });
	});

	var _stroage = __webpack_require__(17);

	Object.keys(_stroage).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _stroage[key];
	    }
	  });
	});

	var _option = __webpack_require__(11);

	Object.keys(_option).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _option[key];
	    }
	  });
	});

	var _buffer = __webpack_require__(167);

	Object.keys(_buffer).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _buffer[key];
	    }
	  });
	});

	var _debug = __webpack_require__(168);

	Object.keys(_debug).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _debug[key];
	    }
	  });
	});

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.defProtected = defProtected;
	exports.defAccess = defAccess;
	exports.toNumber = toNumber;
	exports.hash = hash;
	exports.hasValue = hasValue;
	exports.$$extend = $$extend;
	exports.parseJSON = parseJSON;
	exports.enterReplace = enterReplace;
	exports.makeJsonPack = makeJsonPack;
	exports.arrayUnique = arrayUnique;
	exports.joinPaths = joinPaths;
	//定义属性
	var def = Object.defineProperty;

	/**
	 * 定义一个新的对象
	 * 重写属性
	 */
	function defProtected(obj, key, val, enumerable, writable) {
	    def(obj, key, {
	        value: val,
	        enumerable: enumerable,
	        writable: writable,
	        configurable: true
	    });
	}

	/**
	 * 定义访问控制器
	 * @return {[type]} [description]
	 */
	function defAccess(obj, key, access) {
	    def(obj, key, {
	        get: access.get,
	        set: access.set
	    });
	}

	/**
	 * 转化数组
	 * @param  {[type]} o [description]
	 * @return {[type]}   [description]
	 */
	function toNumber(o) {
	    return Number(o) || null;
	};

	/**
	 * 创建一个纯存的hash对象
	 */
	function hash() {
	    return Object.create(null);
	}

	/**
	 * 存在值
	 * 只有值不为undefined
	 */
	function hasValue(value) {
	    return value != undefined;
	}

	function $$extend(object, config) {
	    for (var i in config) {
	        if (i) {
	            if (object[i]) {
	                console.log('接口方法重复', 'Key->' + i, 'Value->' + object[i]);
	            } else {
	                object[i] = config[i];
	            }
	        }
	    }
	}

	/**
	 * /解析json字符串
	 * @param  {[type]} itemArray [description]
	 * @return {[type]}           [description]
	 */
	function parseJSON(parameter) {
	    if (!parameter) return;
	    var json = void 0;
	    try {
	        json = JSON.parse(parameter);
	    } catch (error) {
	        console.log('parseJSON\u5931\u8D25:' + parameter);
	        return false;
	    }
	    return json;
	}

	/**
	 * 回车符处理
	 */
	function enterReplace(str) {
	    return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
	}

	/**
	 * 解析json代码
	 * 包装脚本
	 * @param  {[type]} itemArray [description]
	 * @return {[type]}           [description]
	 * execJson("(function(){" + enterReplace(data.postCode) + "})");
	 */
	function makeJsonPack(code) {
	    try {
	        var post = "(function(){" + enterReplace(code) + "})";
	        return new Function("return " + post)();
	    } catch (error) {
	        console.log('解析json出错' + code);
	    }
	}

	/**
	 * 修正判断是否存在处理
	 * @param  {[type]} arr [description]
	 * @return {[type]}     [description]
	 */
	function arrayUnique(arr) {
	    //去重
	    if (arr && arr.length) {
	        var length = arr.length;
	        while (--length) {
	            //如果在前面已经出现，则将该位置的元素删除
	            if (arr.lastIndexOf(arr[length], length - 1) > -1) {
	                arr.splice(length, 1);
	            }
	        }
	        return arr;
	    } else {
	        return arr;
	    }
	}

	/**
	 * 标准化文件路径，主要解决 '.'和'..'相对路径问题。
	 * @param  {[type]} path [description]
	 * @return {[type]}      [description]
	 */
	function normalize(path) {
	    // 利用帮助函数获取文件路径的信息
	    var result = statPath(path),

	    // 盘符
	    device = result.device,

	    // 是否为windows的UNC路径
	    isUnc = result.isUnc,

	    // 是否为绝对路径
	    isAbsolute = result.isAbsolute,

	    // 文件路径结尾
	    tail = result.tail,

	    // 尾部是否为'\' 或者 '/' 结尾。
	    trailingSlash = /[\\\/]$/.test(tail);

	    // Normalize the tail path
	    //标准化tail路径，处理掉'.' '..' 以 '\' 连接 
	    tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join('\\');
	    // 处理tail为空的情况
	    if (!tail && !isAbsolute) {
	        tail = '.';
	    }
	    // 当原始路径中有slash时候，需要加上
	    if (tail && trailingSlash) {
	        tail += '\\';
	    }

	    // Convert slashes to backslashes when `device` points to an UNC root.
	    // Also squash multiple slashes into a single one where appropriate.
	    // 处理windows UNC的情况。
	    if (isUnc) {
	        // 获取具体的路径，如果是UNC的情况
	        device = normalizeUNCRoot(device);
	    }
	    // 返回具体的路径
	    return device + (isAbsolute ? '\\' : '') + tail;
	}

	/**
	 * 获取文件路径详细信息
	 * @param  {[type]} path [description]
	 * @return {[type]}      [description]
	 */
	function statPath(path) {
	    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	    // 和上述的函数一样，解析路径中的信息。
	    var result = splitDeviceRe.exec(path),
	        device = result[1] || '',

	    // 判断是否 为UNC path
	    isUnc = !!device && device[1] !== ':';
	    // 返回具体的对象，盘符，是否为统一路径，绝对路径， 以及结尾
	    return {
	        device: device,
	        isUnc: isUnc,
	        isAbsolute: isUnc || !!result[2], // UNC paths are always absolute
	        tail: result[3]
	    };
	}

	/**
	 * 解决文件目录中的相对路径
	 * @param  {[type]} parts          文件目录数组，从0- 高位分别代表一级目录
	 * @param  {[type]} allowAboveRoot 布尔值，代表是否可以超过根目录
	 * @return {[type]}                解决掉相对路径后的数组，比如说数组 
	                                   ['/test'， '/re'， '..']将会返回 ['/test']
	 */
	function normalizeArray(parts, allowAboveRoot) {
	    // 返回值
	    var res = [];
	    // 遍历数组，处理数组中的相对路径字符 '.' 或者'..'
	    for (var i = 0; i < parts.length; i++) {
	        // 取得当前的数组的字符
	        var p = parts[i];

	        // ignore empty parts
	        // 对空或者'.'不处理
	        if (!p || p === '.') continue;
	        // 处理相对路径中的'..'
	        if (p === '..') {
	            if (res.length && res[res.length - 1] !== '..') {
	                // 直接弹出返回队列，当没有到达根目录时
	                res.pop();
	            } else if (allowAboveRoot) {
	                //allowAboveRoot 为真时，插入'..'
	                res.push('..');
	            }
	        } else {
	            // 非 '.' 和'..'直接插入返回队列。 
	            res.push(p);
	        }
	    }
	    // 返回路径数组
	    return res;
	}

	/**
	 *帮助函数，将路径UNC路径标准化成\\pathname\\
	 * @param  {[type]} device [description]
	 * @return {[type]}        [description]
	 */
	function normalizeUNCRoot(device) {
	    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
	}

	/**
	 *  文件路径拼接
	 * @return {[type]} [description]
	 */
	function joinPaths() {
	    var paths = [];
	    for (var i = 0; i < arguments.length; i++) {
	        var arg = arguments[i];
	        // 确保函数参数为字符串
	        try {
	            if (Object.prototype.toString.call(arg) != "[object String]") {
	                throw new Error('Arguments to path.join must be strings');
	            }
	            if (arg) {
	                // 放入参数数组
	                paths.push(arg);
	            }
	        } catch (e) {
	            console.log(e);
	        }
	    }

	    var joined = paths.join("/");

	    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
	        joined = joined.replace(/^[\\\/]{2,}/, '\\');
	    }
	    // 利用标准化接口 获取具体的文件路径
	    return normalize(joined);
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.hasVideoObj = hasVideoObj;
	exports.autoVideo = autoVideo;
	exports.triggerVideo = triggerVideo;
	exports.removeVideo = removeVideo;
	exports.clearVideo = clearVideo;
	exports.hangUpVideo = hangUpVideo;

	var _video = __webpack_require__(27);

	var _index = __webpack_require__(1);

	/*
	    视频和远程网页管理模块
	*/
	var pageBox = void 0;
	var playBox = void 0;

	var initBox = function initBox() {
	    pageBox = {}; //当前页面包含的视频数据
	    playBox = {}; //播放过的视频数据 （播放集合)
	};

	initBox();

	/**
	 * 配置视频结构
	 * @param  {[type]} data       [description]
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @return {[type]}            [description]
	 */
	var deployVideo = function deployVideo(data, pageId, activityId) {

	    var proportion = _index.config.proportion;

	    var videoInfo = {
	        'pageId': pageId,
	        'videoId': activityId,
	        'url': data.md5,
	        'pageUrl': data.url,
	        'left': data.left * proportion.left || 0,
	        'top': data.top * proportion.top || 0,
	        'width': data.width * proportion.width || _index.config.viewSize.width,
	        'height': data.height * proportion.height || _index.config.viewSize.height,
	        'padding': data.padding * proportion.left || 0,
	        'zIndex': data.zIndex || 2147483647,
	        'background': data.background,
	        'category': data.category,
	        'hyperlink': data.hyperlink
	    };

	    if (!_.isObject(pageBox[pageId])) {
	        pageBox[pageId] = {};
	    }

	    pageBox[pageId][activityId] = videoInfo;
	};

	/**
	 * 检测数据是否存在
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @return {[type]}            [description]
	 */
	var checkRepeat = function checkRepeat(pageId, activityId) {
	    var chapterData = pageBox[pageId];
	    //如果能在pageBox找到对应的数据
	    if (chapterData && chapterData[activityId]) {
	        return true;
	    }
	    return false;
	};

	//处理重复数据
	// 1:pageBox能找到对应的 videoId
	// 2:重新查询数据
	var parseVideo = function parseVideo(pageId, activityId) {
	    //复重
	    if (checkRepeat(pageId, activityId)) {
	        return;
	    }
	    //新的查询
	    var data = Xut.data.query('Video', activityId);
	    deployVideo(data, pageId, activityId);
	};

	/**
	 * 加载视频
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	var loadVideo = function loadVideo(pageId, activityId, container) {
	    var data = pageBox[pageId][activityId];

	    //search video cache
	    if (playBox[pageId] && playBox[pageId][activityId]) {
	        //console.log('*********cache*********');
	        playBox[pageId][activityId].play();
	    } else {
	        //console.log('=========new=============');
	        if (!_.isObject(playBox[pageId])) {
	            playBox[pageId] = {};
	        }
	        //cache video object
	        playBox[pageId][activityId] = new _video.VideoClass(data, container);
	    }
	};

	/**
	 * 触发视频
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	var initVideo = function initVideo(pageId, activityId, container) {
	    //解析数据
	    parseVideo(pageId, activityId);
	    //调用播放
	    loadVideo(pageId, activityId, container);
	};

	/**
	 * 是否有视频对象
	 * @return {Boolean} [description]
	 */
	function hasVideoObj(pageId, activityId) {
	    if (playBox[pageId]) {
	        return playBox[pageId][activityId];
	    }
	}

	/**
	 * 自动播放
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	function autoVideo(pageId, activityId, container) {
	    initVideo(pageId, activityId, container);
	}

	/**
	 * 手动播放
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	function triggerVideo(pageId, activityId, container) {
	    initVideo(pageId, activityId, container);
	}

	/**
	 * 清理移除页的视频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function removeVideo(pageId) {
	    //清理视频
	    if (playBox && playBox[pageId]) {
	        for (var activityId in playBox[pageId]) {
	            playBox[pageId][activityId].close();
	        }
	        delete playBox[pageId];
	    }
	    //清理数据
	    if (pageBox && pageBox[pageId]) {
	        delete pageBox[pageId];
	    }
	}

	/**
	 * 清理全部视频
	 * @return {[type]} [description]
	 */
	function clearVideo() {
	    var flag = false; //记录是否处理过销毁状态
	    for (var pageId in playBox) {
	        for (var activityId in playBox[pageId]) {
	            playBox[pageId][activityId].close();
	            flag = true;
	        }
	    }
	    initBox();
	    return flag;
	}

	/**
	 * 挂起视频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function hangUpVideo(pageId) {
	    for (var _pageId in playBox) {
	        for (var activityId in playBox[_pageId]) {
	            playBox[_pageId][activityId].stop();
	        }
	    }
	}

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.$$on = $$on;
	exports.$$off = $$off;
	exports.$$handle = $$handle;
	exports.$$target = $$target;
	/**
	 * 2015.3.24
	 * 1 isBrowser
	 * 2 isMobile
	 * 3 isSurface
	 */
	var transitionEnd = Xut.style.transitionEnd;

	//2015.3.23
	//可以点击与触摸
	var isSurface = Xut.plat.isSurface;
	var hasTouch = Xut.plat.hasTouch;

	//触发事件名
	var touchList = ['touchstart', 'touchmove', 'touchend', 'touchcancel', transitionEnd];
	var mouseList = ['mousedown', 'mousemove', 'mouseup', 'mousecancel', transitionEnd, 'mouseout'];

	//绑定事件名排序
	var orderName = {
	    start: 0,
	    move: 1,
	    end: 2,
	    cancel: 3,
	    transitionend: 4,
	    out: 5
	};

	var eventNames = function () {
	    if (isSurface) {
	        return {
	            touch: touchList,
	            mouse: mouseList
	        };
	    }
	    return hasTouch ? touchList : mouseList;
	}();

	var eachApply = function eachApply(events, callbacks, processor) {
	    _.each(callbacks, function (hooks, key) {
	        return hooks && processor(events[orderName[key]], hooks);
	    });
	};

	/**
	 * 合并事件绑定处理
	 * 因为isSurface设备上
	 * 要同时支持2种方式
	 * @return {[type]} [description]
	 */
	var addEvent = function addEvent(context, events, callbacks) {
	    eachApply(events, callbacks, function (eventName, hook) {
	        return context.addEventListener(eventName, hook, false);
	    });
	};

	/**
	 * 销毁事件绑定处理
	 * 因为isSurface设备上
	 * 要同时支持2种方式
	 * @return {[type]} [description]
	 */
	var removeEvent = function removeEvent(context, events, callbacks) {
	    eachApply(events, callbacks, function (eventName, hook) {
	        return context.removeEventListener(eventName, hook, false);
	    });
	};

	/**
	 * 多设备绑定
	 * @param  {[type]}   processor    [处理器]
	 * @param  {[type]}   eventContext [上下文]
	 * @param  {Function} callback     [回调函数]
	 * @return {[type]}                [description]
	 */
	var adaptive = function adaptive(process, element, callbacks) {
	    //如果两者都支持
	    //鼠标与触摸
	    if (isSurface) {
	        _.each(eventNames, function (events) {
	            process(element, events, callbacks);
	        });
	    } else {
	        process(element, eventNames, callbacks);
	    }
	};

	/**
	 * 合并事件绑定处理
	 * 因为isSurface设备上
	 * 要同时支持2种方式
	 * bindTap(eventContext,{
	 *     start   : start,
	 *     move    : move,
	 *     end     : end
	 * })
	 * @return {[type]} [description]
	 */
	function $$on(element, callbacks) {
	    adaptive(addEvent, element, callbacks);
	}

	/**
	 * 移除tap事件
	 * @param  {[type]} context [description]
	 * @param  {[type]} opts    [description]
	 * @return {[type]}         [description]
	 */
	function $$off(element, callbacks) {
	    adaptive(removeEvent, element, callbacks);
	}

	/**
	 * 如果是$$on绑定的，那么获取事件就可能是多点的
	 * 所以需要$$hanle方法
	 * @param  {[type]} callbacks [description]
	 * @param  {[type]} context   [description]
	 * @param  {[type]} event     [description]
	 * @return {[type]}           [description]
	 */
	function $$handle(callbacks, context, event) {
	    switch (event.type) {
	        case 'touchstart':
	        case 'mousedown':
	            callbacks.start && callbacks.start.call(context, event);
	            break;
	        case 'touchmove':
	        case 'mousemove':
	            callbacks.move && callbacks.move.call(context, event);
	            break;
	        case 'touchend':
	        case 'mouseup':
	        case 'mousecancel':
	        case 'touchcancel':
	        case 'mouseout':
	            callbacks.end && callbacks.end.call(context, event);
	            break;
	        case transitionEnd:
	            callbacks.transitionend && callbacks.transitionend.call(context, event);
	            break;
	    }
	}

	function $$target(event, original) {
	    var currTouches = null;
	    if (hasTouch) {
	        currTouches = event.touches;
	        if (currTouches && currTouches.length > 0) {
	            event = currTouches[0];
	        }
	    }
	    return original ? event : event.target;
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.autoAudio = autoAudio;
	exports.triggerAudio = triggerAudio;
	exports.seasonAudio = seasonAudio;
	exports.hangUpAudio = hangUpAudio;
	exports.createContentAudio = createContentAudio;
	exports.clearContentAudio = clearContentAudio;
	exports.clearAudio = clearAudio;

	var _index = __webpack_require__(2);

	var _audio = __webpack_require__(26);

	var _manager = __webpack_require__(4);

	//动作标示
	var ACTIVIT = 'hot'; //热点音频
	/**
	 * 音频说明：
	 *  一个音频播放有2种情况：
	 *       1、自动播放该音频（autoPlay == true）
	 *       2、手动播放该音频（点击触发点）
	 *
	 *   一个音频被停止有3种情况：
	 *       1、手动暂停（点击触发点）
	 *       2、同轨道的其他音频开始播放
	 *       3、0轨道的音频开始播放
	 *   特殊情况：
	 *       0轨道的音频播放时，可以停止所有其他轨道的音频
	 *       其他轨道的音频播放时，可以停止0轨道的音频
	 *
	 *   基于上面的条件，补充提示：
	 *       同轨道只允许有一个自动播放的音频
	 *       如果0轨道音频为自动播放，则其他轨道不允许有自动播放音频
	 *       反之亦然，其他轨道有自动播放音频，则0轨道不允许有自动播放音频
	 *
	 *    ===================================================================================================
	 *   该版本说明：
	 *   一个音频被打断之后，就被销毁，不会在后续恢复播放，而只会重头开始播放
	 *
	 *  2014.12.1 版本升级
	 *  原来只有热点音频，现在多了动画音频和节音频，所以音频管理需要调整,
	 *  有两个要注意的地方：
	 *  1. 由于在IOS上,new Audio操作会产生新的进程，且不释放，所以同一个音轨只新建一个音频实例
	 *     为了防止交互点击时音频播放混乱，要先清除同音轨的上一个音频
	 *  2. 节音频可以跨节共用，如,1,2,3节共用一个音频，那么在这些节之间跳转时不打断
	 *
	 */

	var ANIMATE = 'content'; //动画音频
	var SEASON = 'season'; //节音频

	/**
	 * 容器合集
	 * 1 pageBox 当前待播放的热点音频
	 * 2 playBox 播放中的热点音频集合
	 */
	//[type][pageId][queryId]
	var pageBox, playBox;

	var initBox = function initBox() {
	    pageBox = (0, _index.hash)();

	    //[type][pageId][queryId]
	    playBox = (0, _index.hash)();
	};

	initBox();

	/**
	 * 解析数据
	 * @param  {[type]} type    [description]
	 * @param  {[type]} queryId [description]
	 * @return {[type]}         [description]
	 */
	var parseData = function parseData(type, queryId) {
	    var data;
	    switch (type) {
	        case ANIMATE:
	            data = Xut.data.query('Video', queryId, true);
	            break;
	        case SEASON:
	            data = Xut.data.query('Video', queryId, true);
	            break;
	        default:
	            data = Xut.data.query('Video', queryId);
	            break;
	    }
	    return data;
	};

	/**
	 * 获取父容器
	 * @return {[type]} [description]
	 */
	var getParentDom = function getParentDom(subtitles, pageId, queryId) {
	    //字幕数据
	    var parentDoms = (0, _index.hash)();
	    var ancestorDoms = (0, _index.hash)();
	    var contentsFragment;
	    var dom;
	    var pageIndex = pageId - 1;
	    if (subtitles) {
	        //获取文档节点
	        contentsFragment = Xut.Contents.contentsFragment[pageId];

	        //如果maskId大于9000默认为处理
	        var isMask = pageId > 9000;
	        if (isMask) {
	            //指定页码编号
	            pageIndex = Xut.Presentation.GetPageIndex();
	        }

	        //找到对应的节点
	        _.each(subtitles, function (data) {
	            //'Content_0_1' 规则 类型_页码（0开始）_id
	            if (!parentDoms[data.id]) {
	                dom = contentsFragment['Content_' + pageIndex + '_' + data.id];
	                ancestorDoms[data.id] = dom;
	                var $dom = $(dom);
	                if ($dom.length) {
	                    var _div = $dom.find('div').last();
	                    if (_div.length) {
	                        parentDoms[data.id] = _div[0];
	                    }
	                }
	            }
	        });
	    }

	    return {
	        parents: parentDoms,
	        ancestors: ancestorDoms
	    };
	};

	/**
	 * 检测数据是否存在
	 * @return {[type]}         [description]
	 */
	var checkRepeat = function checkRepeat(pageId, queryId, type) {
	    var pBox = pageBox[type];
	    if (pBox && pBox[pageId] && pBox[pageId][queryId]) {
	        return true;
	    }
	    return false;
	};

	/**
	 * 组合热点音频数据结构
	 * data, pageId, queryId, type
	 * 数据，页码编号，videoId, 查询的类型
	 * @return {[type]}         [description]
	 */
	var combination = function combination(data, pageId, queryId, type, eleName) {
	    var tempDoms;
	    if (!pageBox[type]) {
	        pageBox[type] = (0, _index.hash)();
	    }
	    if (!pageBox[type][pageId]) {
	        pageBox[type][pageId] = (0, _index.hash)();
	    }
	    //有字幕处理
	    if (data.theTitle) {
	        var subtitles = (0, _index.parseJSON)(data.theTitle);
	    }
	    //配置音频结构
	    return pageBox[type][pageId][queryId] = {
	        'trackId': data.track, //音轨
	        'url': data.md5, //音频名字
	        'subtitles': subtitles,
	        'audioId': queryId,
	        'data': data
	    };
	};

	/**
	 * 装配音频数据
	 * @param  {int} pageId    页面id或节的分组id
	 * @param  {int} queryId   查询id,支持activityId,audioId
	 * @param  {string} type   音频来源类型[动画音频,节音频,热点音频]
	 */
	var deployAudio = function deployAudio(pageId, queryId, type, actionData) {
	    //避免复重查询
	    if (checkRepeat(pageId, queryId, type)) {
	        return false;
	    }
	    //解析合集数据
	    var data = parseData(type, queryId);
	    //存在音频文件
	    if (data && data.md5) {
	        //新的查询
	        var ret = combination(data, pageId, queryId, type, actionData);
	        //混入新的动作数据
	        //2015.9.24
	        //音频替换图片
	        //触发动画
	        if (actionData) {
	            _.extend(ret, actionData, {
	                action: true //快速判断存在动作数据
	            });
	        }
	    }
	};

	/**
	 * 检查要打断的音频
	 * @param  {[type]} type    音频类型
	 * @param  {[type]} pageId  [description]
	 * @param  {[type]} queryId [description]
	 * @param  {[type]} pageBox [description]
	 * @return {boolen}         不打断返回true,否则返回false
	 */
	var checkBreakAudio = function checkBreakAudio(type, pageId, queryId, pageBox) {
	    var playObj = playBox[type][pageId][queryId],
	        trackId = pageBox.trackId,
	        _trackId = playObj.trackId;

	    //如果是节音频，且地址相同，则不打断
	    if (type == SEASON && playObj.url == pageBox.url) {
	        return true;
	    }

	    //如果要用零音轨||零音轨有音乐在播||两音轨相同
	    //则打断
	    if (trackId == 0 || _trackId == 0 || trackId == _trackId) {
	        playObj.end();
	        delete playBox[type][pageId][queryId];
	    }
	    return false;
	};

	/**
	 * 播放音频之前检查
	 * @param  {int} pageId    [description]
	 * @param  {int} queryId    查询id
	 * @param  {string} type    决定video表按哪个字段查询
	 * @return {object}         音频对象/不存在为null
	 */
	var preCheck = function preCheck(pageId, queryId, type) {
	    var t,
	        p,
	        q,
	        playObj = pageBox[type][pageId][queryId],
	        seasonAudio = null;
	    for (t in playBox) {
	        for (p in playBox[t]) {
	            for (q in playBox[t][p]) {
	                if (checkBreakAudio(t, p, q, playObj)) {
	                    seasonAudio = playBox[t][p][q];
	                }
	            }
	        }
	    }
	    return seasonAudio;
	};

	/**
	 * 加载音频对象
	 * @return {[type]}         [description]
	 */
	var loadAudio = function loadAudio(pageId, queryId, type) {

	    //找到页面对应的音频
	    //类型=》页面=》指定音频Id
	    var pageObj = pageBox[type][pageId][queryId];
	    //检测
	    var seAudio = preCheck(pageId, queryId, type);

	    //播放音频时关掉视频
	    (0, _manager.clearVideo)();

	    //构建播放列表
	    if (!playBox[type]) {
	        playBox[type] = (0, _index.hash)();
	    }
	    if (!playBox[type][pageId]) {
	        playBox[type][pageId] = (0, _index.hash)();
	    }
	    //假如有字幕信息
	    //找到对应的文档对象
	    if (pageObj.subtitles) {
	        var tempDoms = getParentDom(pageObj.subtitles, pageId, queryId);
	    }

	    //播放完成处理
	    pageObj.innerCallback = function (audio) {
	        if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
	            audio.end();
	            delete playBox[type][pageId][queryId];
	        }
	    };

	    //存入播放对象池
	    playBox[type][pageId][queryId] = seAudio || new _audio.audioPlayer(pageObj, tempDoms);
	};

	/**
	 * 交互点击
	 * @param  {int} pageId     [description]
	 * @param  {int} queryId    [description]
	 * @param  {string} type    ACTIVIT
	 * @return {[type]}         [description]
	 */
	var loadTiggerAudio = function loadTiggerAudio(pageId, queryId, type) {
	    var playObj, status;
	    if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
	        playObj = playBox[type][pageId][queryId];
	        status = playObj.audio ? playObj.status : null;
	    }
	    switch (status) {
	        case 'playing':
	            playObj.pause();
	            break;
	        case 'paused':
	            playObj.play();
	            break;
	        default:
	            loadAudio(pageId, queryId, type);
	            break;
	    }
	};

	/**
	 * 清理全部音频
	 * @return {[type]} [description]
	 */
	var removeAudio = function removeAudio() {
	    var t, p, a;
	    for (t in playBox) {
	        for (p in playBox[t]) {
	            for (a in playBox[t][p]) {
	                playBox[t][p][a].end();
	            }
	        }
	    }
	    initBox();
	};

	///////////////////
	//1 独立音频处理, 音轨/跨页面 //
	//2 动画音频,跟动画一起播放与销毁
	///////////////////

	/**
	 * 自动播放触发接口
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} actionData [description]
	 * @return {[type]}            [description]
	 */
	function autoAudio(pageId, activityId, actionData) {
	    deployAudio(pageId, activityId, ACTIVIT, actionData);
	    loadAudio(pageId, activityId, ACTIVIT);
	}

	/**
	 * 手动触发
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} actionData [description]
	 * @return {[type]}            [description]
	 */
	function triggerAudio(pageId, activityId, actionData) {
	    deployAudio(pageId, activityId, ACTIVIT, actionData);
	    loadTiggerAudio(pageId, activityId, ACTIVIT);
	}

	/**
	 * 节音频触发接口
	 * @param  {[type]} seasonAudioId [description]
	 * @param  {[type]} audioId       [description]
	 * @return {[type]}               [description]
	 */
	function seasonAudio(seasonAudioId, audioId) {
	    deployAudio(seasonAudioId, audioId, SEASON);
	    loadAudio(seasonAudioId, audioId, SEASON);
	}

	/**
	 * 挂起音频
	 * @return {[type]} [description]
	 */
	function hangUpAudio() {
	    var t, p, a;
	    for (t in playBox) {
	        for (p in playBox[t]) {
	            for (a in playBox[t][p]) {
	                playBox[t][p][a].pause();
	            }
	        }
	    }
	}

	/**
	 * 动画音频触发接口
	 * @param  {[type]} pageId  [description]
	 * @param  {[type]} audioId [description]
	 * @return {[type]}         [description]
	 */
	function createContentAudio(pageId, audioId) {
	    deployAudio(pageId, audioId, ANIMATE);
	    loadAudio(pageId, audioId, ANIMATE);
	}

	/**
	 * 销毁动画音频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function clearContentAudio(pageId) {
	    if (!playBox[ANIMATE] || !playBox[ANIMATE][pageId]) {
	        return false;
	    }
	    var playObj = playBox[ANIMATE][pageId];
	    if (playObj) {
	        for (var i in playObj) {
	            playObj[i].end();
	            delete playBox[ANIMATE][pageId][i];
	        }
	    }
	}

	/**
	 * 清理音频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function clearAudio(pageId) {
	    if (pageId) {
	        //如果只跳槽关闭动画音频
	        clearContentAudio(pageId);
	    } else {
	        removeAudio(); //多场景模式,不处理跨页面
	    }
	}

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.set = set;
	exports.hasFlow = hasFlow;
	exports.getCurrentBeforeCount = getCurrentBeforeCount;
	exports.getBeforeCount = getBeforeCount;
	exports.getFlowChpaterCount = getFlowChpaterCount;
	exports.getFlowCount = getFlowCount;
	exports.isFlowPage = isFlowPage;
	var cacheCounts = void 0;

	/**
	 * 设置流式布局排版信息
	 */
	function set(flowCounts) {
	    cacheCounts = flowCounts;
	}

	/**
	 * 是否有流式排版
	 * 加快计算
	 * @return {Boolean} [description]
	 */
	function hasFlow() {
	    return cacheCounts;
	}

	/**
	 * 获取当前当前到前置的总和
	 * @return {[type]} [description]
	 */
	function getCurrentBeforeCount(seasonId, chapterId) {
	    if (!cacheCounts) return;
	    if (!seasonId && !chapterId) return;
	    var seasonIds = cacheCounts[seasonId];
	    var count = 0;
	    for (var key in seasonIds) {
	        if (key <= chapterId) {
	            count += seasonIds[key];
	            --count;
	        }
	    }
	    return count > 0 ? count : 0;
	}

	/**
	 * 获取当前chapterId之前的总页数
	 * @return {[type]} [description]
	 */
	function getBeforeCount(seasonId, chapterId) {
	    if (!cacheCounts) return;
	    if (!seasonId && !chapterId) return;
	    var seasonIds = cacheCounts[seasonId];
	    var count = 0;
	    for (var key in seasonIds) {
	        if (key < chapterId) {
	            count += seasonIds[key];
	            --count;
	        }
	    }
	    return count > 0 ? count : 0;
	}

	/**
	 * 获取chpater总数
	 * @param  {[type]} seasonId [description]
	 * @return {[type]}          [description]
	 */
	function getFlowChpaterCount(seasonId) {
	    if (!cacheCounts) return;
	    return Object.keys(cacheCounts[seasonId]).length;
	}

	/**
	 * reutrn seasonIds
	 * return chpaterIds
	 * @param  {[type]} seasonId  [description]
	 * @param  {[type]} chpaterId [description]
	 * @return {[type]}           [description]
	 */
	function getFlowCount(seasonId, chapterId) {
	    if (!cacheCounts) return;
	    if (seasonId) {
	        if (chapterId) {
	            return cacheCounts[seasonId] && cacheCounts[seasonId][chapterId];
	        } else {
	            var seasonIds = cacheCounts[seasonId];
	            var count = 0;
	            for (var key in seasonIds) {
	                count += seasonIds[key];
	            }
	            return count;
	        }
	    } else {
	        console.log('getCounts失败');
	    }
	}

	/**
	 * 判断是否为流式布局页面
	 * @param  {[type]} seasonId  [description]
	 * @param  {[type]} chpaterId [description]
	 * @return {[type]}           [description]
	 */
	function isFlowPage(seasonId, chapterId) {
	    return getFlowCount(seasonId, chapterId) ? true : false;
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _auto = __webpack_require__(51);

	Object.keys(_auto).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _auto[key];
	    }
	  });
	});

	var _trigger = __webpack_require__(55);

	Object.keys(_trigger).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _trigger[key];
	    }
	  });
	});

	var _suspend = __webpack_require__(54);

	Object.keys(_suspend).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _suspend[key];
	    }
	  });
	});

	var _original = __webpack_require__(52);

	Object.keys(_original).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _original[key];
	    }
	  });
	});

	var _stop = __webpack_require__(53);

	Object.keys(_stop).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _stop[key];
	    }
	  });
	});

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * 场景控制器
	 * 场景对象之间的顺序处理
	 * @return {[type]} [description]
	 */

	//场景层级控制
	var zIndex = 999999;

	//去重复标记，可以复用场景
	var toRepeat = 0;

	//场景合集
	//主场景
	//副场景
	var sceneCollection = {
	    //场景顺序
	    scenarioStack: [],
	    //场景链表
	    scenarioChain: []
	};

	var sceneController = {

	    /**
	     * 场景层级控制
	     * @return {[type]} [description]
	     */
	    createIndex: function createIndex() {
	        return --zIndex;
	    },


	    /**
	     * 设置一个新场景
	     * @param {[type]} scenarioId [description]
	     * @param {[type]} relevant   [description]
	     * @param {[type]} sceneObj   [description]
	     */
	    add: function add(scenarioId, relevant, sceneObj) {
	        sceneCollection.scenarioStack.push(scenarioId);
	        sceneCollection['scenarioId->' + scenarioId] = sceneObj;
	        //场景链表,拥挤记录场景的加载上一页
	        sceneCollection.scenarioChain.push({
	            'scenarioId': scenarioId,
	            'chapterId': relevant
	        });
	        return sceneObj;
	    },


	    /**
	     * 取出上一个场景链
	     * @return {[type]} [description]
	     */
	    takeOutPrevChainId: function takeOutPrevChainId() {
	        var pre = sceneCollection.scenarioChain.pop();
	        if (sceneCollection.scenarioChain.length > 1) {
	            return sceneCollection.scenarioChain.pop();
	        } else {
	            return sceneCollection.scenarioChain[0];
	        }
	    },


	    /**
	     * 检测重复
	     * @param  {[type]} seasonId [description]
	     * @return {[type]}          [description]
	     */
	    checkToRepeat: function checkToRepeat(seasonId) {
	        var last,
	            len = sceneCollection.scenarioChain.length;
	        if (len > 1) {
	            last = sceneCollection.scenarioChain[len - 2];
	        } else {
	            last = sceneCollection.scenarioChain[len - 1];
	        }

	        //往回跳一级
	        if (last['scenarioId'] == seasonId) {
	            this.takeOutPrevChainId();
	        }

	        //直接会跳到主场景
	        if (sceneCollection.scenarioStack[0] == seasonId) {
	            var scenarioChain = sceneCollection.scenarioChain.shift();
	            sceneCollection.scenarioChain.length = 0;
	            sceneCollection.scenarioChain.push(scenarioChain);
	        }
	    },


	    /**
	     * 返回活动对象
	     * @return {[type]} [description]
	     */
	    containerObj: function containerObj(scenarioId) {
	        if (scenarioId === 'current') {
	            var scenarioStack = sceneCollection.scenarioStack;
	            scenarioId = scenarioStack[scenarioStack.length - 1];
	        }
	        return sceneCollection['scenarioId->' + scenarioId];
	    },


	    /**
	     * 找到索引位置的Id
	     * @param  {[type]} scenarioId [description]
	     * @return {[type]}            [description]
	     */
	    findIndexOfId: function findIndexOfId(scenarioId) {
	        return sceneCollection.scenarioStack.lastIndexOf(scenarioId);
	    },


	    /**
	     * 删除指定场景引用
	     * @param  {[type]} scenarioId [description]
	     * @return {[type]}            [description]
	     */
	    remove: function remove(scenarioId) {
	        var indexOf = this.findIndexOfId(scenarioId);

	        //删除索引
	        sceneCollection.scenarioStack.splice(indexOf, 1);

	        //删除场景对象区域
	        delete sceneCollection['scenarioId->' + scenarioId];
	    },


	    /**
	     * 销毁所有场景
	     * @return {[type]} [description]
	     */
	    destroyAllScene: function destroyAllScene() {
	        var cache = _.clone(sceneCollection.scenarioStack);
	        _.each(cache, function (scenarioId) {
	            sceneCollection['scenarioId->' + scenarioId].destroy();
	        });
	        sceneCollection.scenarioChain = [];
	    },


	    /**
	     * 重写场景的顺序编号
	     * 用于记录最后一次跳转的问题
	     * @return {[type]} [description]
	     */
	    rewrite: function rewrite(scenarioId, chapterId) {
	        _.each(sceneCollection.scenarioChain, function (scenarioChain) {
	            if (scenarioChain.scenarioId == scenarioId) {
	                scenarioChain.chapterId = chapterId;
	            }
	        });
	    },


	    /**
	     * 暴露接口
	     * @return {[type]} [description]
	     */
	    expose: function expose() {
	        return sceneCollection;
	    },


	    /**
	     * 解析序列
	     * @param  {[type]} scenarioId    [description]
	     * @param  {[type]} currPageIndex [description]
	     * @return {[type]}               [description]
	     */
	    sequence: function sequence(scenarioId, currPageIndex) {
	        var chains = sceneCollection.scenarioChain;
	        //有多个场景关系,需要记录
	        if (chains.length > 1) {
	            var history = [];
	            //只刷新当前场景的页面
	            _.each(chains, function (chain) {
	                if (chain.scenarioId == scenarioId) {
	                    history.push(chain.scenarioId + '-' + chain.chapterId + '-' + currPageIndex);
	                } else {
	                    history.push(chain.scenarioId + '-' + chain.chapterId);
	                }
	            });
	            return history;
	        }
	    },


	    /**
	     * 反解析
	     * @param  {[type]} chains [description]
	     * @return {[type]}        [description]
	     */
	    seqReverse: function seqReverse(chains) {
	        var chains = chains.split(",");
	        var chainsNum = chains.length;

	        if (chainsNum === 1) {
	            return false;
	        }

	        //如果只有2层
	        if (chainsNum === 2) {
	            return chains[1];
	        }

	        //拼接作用域链
	        //排除首页(已存在)
	        //尾页(新创建)
	        _.each(chains, function (chain, index) {
	            if (index >= 1 && index < chainsNum - 1) {
	                //从1开始吸入,排除最后一个
	                var chain = chain.split('-');
	                sceneCollection.scenarioChain.push({
	                    'scenarioId': chain[0],
	                    'chapterId': chain[1],
	                    'pageIndex': chain[2]
	                });
	            }
	        });
	        return chains[chainsNum - 1];
	    }
	};

	Xut.sceneController = sceneController;

	exports.sceneController = sceneController;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * 资源加载
	 * @return {[type]} [description]
	 */
	var loader = function () {
	    return {
	        /**入口函数,动态脚本加载
	         * @param fileList:           需要动态加载的资源列表
	         * @param callback:           所有资源都加载完后调用的回调函数,通常是页面上需要onload就执行的函数
	         * @param scope:              作用范围
	         * @param preserveOrder:      是否保持脚本顺序
	         */
	        load: function load(fileList, callback, scope, preserveOrder) {
	            //过来数组元素
	            if (fileList.length && preserveOrder) {
	                var temp = [];
	                fileList.forEach(function (val, index) {
	                    if (val) {
	                        temp.push(val);
	                    }
	                });
	                fileList = temp.reverse();
	                temp = null;
	            }

	            var scope = scope || this,

	            //var scope =this,//默认作用范围是当前页面
	            head = document.getElementsByTagName("head")[0],
	                fragment = document.createDocumentFragment(),
	                numFiles = fileList.length,
	                loadedFiles = 0;

	            //加载一个特定的文件从fileList通过索引
	            var loadFileIndex = function loadFileIndex(index) {
	                head.appendChild(scope.buildScriptTag(fileList[index], onFileLoaded));
	            };

	            /**
	             * 调用回调函数,当所有文件都加载完后调用
	             */
	            var onFileLoaded = function onFileLoaded() {
	                loadedFiles++;
	                //如果当前文件是最后一个要加载的文件，则调用回调函数，否则加载下一个文件
	                if (numFiles == loadedFiles && typeof callback == 'function') {
	                    callback.call(scope);
	                } else {
	                    if (preserveOrder === true) {
	                        loadFileIndex(loadedFiles);
	                    }
	                }
	            };

	            if (preserveOrder === true) {
	                loadFileIndex.call(this, 0);
	            } else {
	                for (var i = 0, len = fileList.length; i < len; i++) {
	                    fragment.appendChild(this.buildScriptTag(fileList[i], onFileLoaded));
	                }
	                head.appendChild(fragment);
	            }
	        },

	        //构造javascript和link 标签
	        buildScriptTag: function buildScriptTag(filename, callback) {
	            var exten = filename.substr(filename.lastIndexOf('.') + 1);
	            if (exten == 'js') {
	                var script = document.createElement('script');
	                script.type = "text/javascript";
	                script.src = filename;
	                script.onload = callback;
	                return script;
	            }
	            if (exten == 'css') {
	                var style = document.createElement('link');
	                style.rel = 'stylesheet';
	                style.type = 'text/css';
	                style.href = filename;
	                callback();
	                return style;
	            }
	        }
	    };
	}();

	function pollCss(node, callback) {
	    var sheet = node.sheet,
	        isLoaded;
	    var isOldWebKit = +navigator.userAgent.replace(/.*AppleWebKit\/(\d+)\..*/, "$1") < 536;
	    // for WebKit < 536
	    if (isOldWebKit) {
	        if (sheet) {
	            isLoaded = true;
	        }
	    }
	    // for Firefox < 9.0
	    else if (sheet) {
	            try {
	                if (sheet.cssRules) {
	                    isLoaded = true;
	                }
	            } catch (ex) {
	                // The value of `ex.name` is changed from "NS_ERROR_DOM_SECURITY_ERR"
	                // to "SecurityError" since Firefox 13.0. But Firefox is less than 9.0
	                // in here, So it is ok to just rely on "NS_ERROR_DOM_SECURITY_ERR"
	                if (ex.name === "NS_ERROR_DOM_SECURITY_ERR") {
	                    isLoaded = true;
	                }
	            }
	        }

	    setTimeout(function () {
	        if (isLoaded) {
	            // Place callback here to give time for style rendering
	            callback();
	        } else {
	            pollCss(node, callback);
	        }
	    }, 20);
	}

	function addOnload(node, callback, isCSS, url) {
	    var supportOnload = "onload" in node;
	    var isOldWebKit = +navigator.userAgent.replace(/.*AppleWebKit\/(\d+)\..*/, "$1") < 536;
	    // for Old WebKit and Old Firefox
	    if (isCSS) {
	        setTimeout(function () {
	            pollCss(node, callback);
	        }, 1); // Begin after node insertion
	        return;
	    }

	    if (supportOnload) {
	        node.onload = onload;
	        node.onerror = function () {
	            onload();
	        };
	    } else {
	        node.onreadystatechange = function () {
	            if (/loaded|complete/.test(node.readyState)) {
	                onload();
	            }
	        };
	    }

	    function onload() {
	        // Ensure only run once and handle memory leak in IE
	        node.onload = node.onerror = node.onreadystatechange = null;
	        // Remove the script to reduce memory leak
	        if (!isCSS) {
	            var head = document.getElementsByTagName("head")[0] || document.documentElement;
	            head.removeChild(node);
	        }
	        // Dereference the node
	        node = null;
	        callback();
	    }
	}

	function request(url, callback, charset) {
	    var IS_CSS_RE = /\.css(?:\?|$)/i,
	        isCSS = IS_CSS_RE.test(url),
	        node = document.createElement(isCSS ? "link" : "script");

	    if (charset) {
	        var cs = $.isFunction(charset) ? charset(url) : charset;
	        if (cs) {
	            node.charset = cs;
	        }
	    }
	    addOnload(node, callback, isCSS, url);
	    if (isCSS) {
	        node.rel = "stylesheet";
	        node.href = url;
	    } else {
	        node.async = true;
	        node.src = url;
	    }
	    // For some cache cases in IE 6-8, the script executes IMMEDIATELY after
	    // the end of the insert execution, so use `currentlyAddingScript` to
	    // hold current node, for deriving url in `define` call
	    //currentlyAddingScript = node
	    var head = document.getElementsByTagName("head")[0] || document.documentElement;
	    var baseElement = head.getElementsByTagName("base")[0];
	    // ref: #185 & http://dev.jquery.com/ticket/2709
	    baseElement ? head.insertBefore(node, baseElement) : head.appendChild(node);
	    //currentlyAddingScript = null
	}

	var imgReady = function () {

	    var list = [],
	        intervalId = null,


	    // 用来执行队列
	    tick = function tick() {
	        var i = 0;
	        for (; i < list.length; i++) {
	            list[i].end ? list.splice(i--, 1) : list[i]();
	        };
	        !list.length && stop();
	    },


	    // 停止所有定时器队列
	    stop = function stop() {
	        clearInterval(intervalId);
	        intervalId = null;
	    };

	    return function (url, ready, load, error) {
	        var _onready,
	            width,
	            height,
	            newWidth,
	            newHeight,
	            img = new Image();

	        img.src = url;

	        // 如果图片被缓存，则直接返回缓存数据
	        if (img.complete) {
	            ready && ready.call(img);
	            load && load.call(img);
	            return;
	        };

	        width = img.width;
	        height = img.height;

	        // 加载错误后的事件
	        img.onerror = function () {
	            error && error.call(img);
	            _onready.end = true;
	            img = img.onload = img.onerror = null;
	        };

	        // 图片尺寸就绪
	        _onready = function onready() {
	            newWidth = img.width;
	            newHeight = img.height;
	            if (newWidth !== width || newHeight !== height ||
	            // 如果图片已经在其他地方加载可使用面积检测
	            newWidth * newHeight > 1024) {
	                ready && ready.call(img);
	                _onready.end = true;
	            };
	        };
	        _onready();
	        // 完全加载完毕的事件
	        img.onload = function () {
	            // onload在定时器时间差范围内可能比onready快
	            // 这里进行检查并保证onready优先执行
	            !_onready.end && _onready();
	            load && load.call(img);
	            // IE gif动画会循环执行onload，置空onload即可
	            img = img.onload = img.onerror = null;
	        };

	        // 加入队列中定期执行
	        if (!_onready.end) {
	            list.push(_onready);
	            // 无论何时只允许出现一个定时器，减少浏览器性能损耗
	            if (intervalId === null) intervalId = setInterval(tick, 40);
	        };
	    };
	}();

	var loadfile = request;

	exports.loader = loader;
	exports.request = request;
	exports.loadfile = loadfile;
	exports.imgReady = imgReady;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getResources = getResources;
	exports.execScript = execScript;
	exports.replacePath = replacePath;
	exports.setProportion = setProportion;
	exports.reviseSize = reviseSize;
	exports.readFile = readFile;

	var _loader = __webpack_require__(10);

	var _lang = __webpack_require__(3);

	var _index = __webpack_require__(1);

	var CEIL = Math.ceil;
	var FLOOR = Math.floor;

	/**
	 * 获取资源
	 * @param  {[type]} url [description]
	 * @return {[type]}     [description]
	 */
	function getResources(url) {
	    var option;
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, false);
	    xhr.send(null);
	    option = (0, _lang.parseJSON)(xhr.responseText);
	    return option;
	}

	/**
	 * 执行脚本注入
	 */
	function execScript(code, type) {
	    //过滤回车符号
	    var enterReplace = function enterReplace(str) {
	        return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
	    };
	    try {
	        new Function("return " + enterReplace(code))();
	    } catch (e) {
	        console.log('加载脚本错误', type);
	    }
	}

	/**
	 * 路径替换
	 * svg html文件的路径是原始处理的
	 * 如果动态切换就需要替换
	 * @return {[type]} [description]
	 */
	function replacePath(svgstr) {
	    if (window.DYNAMICCONFIGT) {
	        //如果能找到对应的默认路径，则替换
	        if (-1 !== svgstr.indexOf('content/gallery/')) {
	            svgstr = svgstr.replace(/content\/gallery/ig, Xut.config.pathAddress);
	        }
	    }
	    return svgstr;
	}

	/**
	 * 转化缩放比
	 * @param  {[type]} width  [description]
	 * @param  {[type]} height [description]
	 * @param  {[type]} left   [description]
	 * @param  {[type]} top    [description]
	 * @return {[type]}        [description]
	 */
	var transformProportion = function transformProportion(width, height, left, top) {
	    var proportion = _index.config.proportion;
	    return {
	        width: width * proportion.width,
	        height: height * proportion.height,
	        left: left * proportion.left,
	        top: top * proportion.top
	    };
	};

	function setProportion(width, height, left, top) {
	    return transformProportion(width, height, left, top);
	}

	/*
	 * 修复元素的尺寸
	 * @type {[type]}
	 */
	function reviseSize(results) {

	    //不同设备下缩放比计算
	    var layerSize = transformProportion(results.width, results.height, results.left, results.top);
	    //新的背景图尺寸
	    var backSize = transformProportion(results.backwidth, results.backheight, results.backleft, results.backtop);

	    //赋值新的坐标
	    results.scaleWidth = CEIL(layerSize.width);
	    results.scaleHeight = CEIL(layerSize.height);
	    results.scaleLeft = CEIL(layerSize.left);
	    results.scaleTop = CEIL(layerSize.top);

	    //背景坐标
	    results.scaleBackWidth = CEIL(backSize.width);
	    results.scaleBackHeight = CEIL(backSize.height);
	    results.scaleBackLeft = CEIL(backSize.left);
	    results.scaleBackTop = CEIL(backSize.top);

	    return results;
	}

	/**
	 *  读取SVG内容
	 *  @return {[type]} [string]
	 */
	function readFile(path, callback, type) {

	    var paths, name, data;

	    /**
	     * ibooks模式 单独处理svg转化策划给你js,加载js文件
	     * @param  {[type]} window.IBOOKSCONFIG [description]
	     * @return {[type]}              [description]
	     */
	    if (Xut.IBooks.CONFIG) {

	        //如果是.svg结尾
	        //把svg替换成js
	        if (/.svg$/.test(path)) {
	            path = path.replace(".svg", '.js');
	        }

	        //全路径
	        paths = _index.config.getSvgPath().replace("svg", 'js') + path;
	        //文件名
	        name = path.replace(".js", '');

	        //加载脚本
	        (0, _loader.request)(paths, function () {
	            data = window.HTMLCONFIG[name] || window.IBOOKSCONFIG[name];
	            if (data) {
	                callback(data);
	                delete window.HTMLCONFIG[name];
	                delete window.IBOOKSCONFIG[name];
	            } else {
	                callback('编译:脚本加载失败,文件名:' + name);
	            }
	        });

	        return;
	    }

	    //con str
	    //externalFile使用
	    //如果是js动态文件
	    //content的html结构
	    if (type === "js") {
	        paths = _index.config.getSvgPath() + path;
	        name = path.replace(".js", '');
	        (0, _loader.request)(paths, function () {
	            data = window.window.HTMLCONFIG[name];
	            if (data) {
	                callback(data);
	                delete window.window.HTMLCONFIG[name];
	            } else {
	                callback('运行：脚本加载失败,文件名:' + path);
	            }
	        });
	        return;
	    }

	    //svg文件
	    //游览器模式 && 非强制插件模式
	    if (Xut.plat.isBrowser && !_index.config.isPlugin) {
	        $.ajax({
	            type: 'get',
	            dataType: 'html',
	            url: _index.config.getSvgPath().replace("www/", "") + path,
	            success: function success(svgContent) {
	                callback(svgContent);
	            },
	            error: function error(xhr, type) {
	                callback('ReadFile数据加载失败');
	                console.log('SVG' + path + '解析出错!');
	            }
	        });
	    } else {
	        Xut.Plugin.ReadAssetsFile.readAssetsFileAction(_index.config.getSvgPath() + path, function (svgContent) {
	            callback(svgContent);
	        }, function (err) {
	            callback('数据加载失败');
	        });
	    }
	}

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getFlowView = getFlowView;
	exports.setFlowTranslate = setFlowTranslate;
	exports.getFlowDistance = getFlowDistance;
	exports.adapterDestory = adapterDestory;

	var _flow = __webpack_require__(171);

	var _flow2 = _interopRequireDefault(_flow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 结果缓存
	 * @type {Object}
	 */
	var _cache = {};

	/**
	 * flow类型标记
	 * @type {String}
	 */
	var FLOWTYPE = 'flow';

	/**
	 * 获取flow页面布局数据
	 * @param  {[type]} config         [description]
	 * @param  {[type]} fullProportion [description]
	 * @return {[type]}                [description]
	 */
	function getFlowView() {
	    return _cache[FLOWTYPE] ? _cache[FLOWTYPE] : _cache[FLOWTYPE] = _flow2.default.view();
	}

	function setFlowTranslate() {
	    return _flow2.default.translate.apply(_flow2.default, arguments);
	}

	function getFlowDistance() {
	    return _flow2.default.distance.apply(_flow2.default, arguments);
	}

	function adapterDestory() {
	    _cache = {};
	}

/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = access;
	/**
	 * 获取访问对象参数
	 * 如果pageObj 不存在，则取当前页面的
	 * @return {[type]} [description]
	 */
	function access(pageObj, callback) {
	    var flag = void 0,
	        contents = void 0,
	        components = void 0,
	        pageType = void 0;

	    //如果只提供回调函数
	    if (arguments.length === 1 && _.isFunction(pageObj)) {
	        callback = pageObj;
	        pageObj = Xut.Presentation.GetPageObj();
	    } else {
	        pageObj = pageObj || Xut.Presentation.GetPageObj();
	    }

	    if (pageObj) {
	        contents = pageObj.baseGetContent();
	        components = pageObj.baseGetComponent();
	        pageType = pageObj.pageType || 'page';
	        flag = callback(pageObj, contents.length && contents, components.length && components, pageType);
	    }
	    return flag;
	}

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.conversionEventType = conversionEventType;
	exports.defaultBehavior = defaultBehavior;
	exports.bindContentEvent = bindContentEvent;
	exports.destroyContentEvent = destroyContentEvent;

	var _drag = __webpack_require__(67);

	var _drag2 = _interopRequireDefault(_drag);

	var _simple = __webpack_require__(68);

	var _complex = __webpack_require__(66);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 事件类型
	 * @type {Array}
	 * 0 null
	 * 1 auto
	 * 2 tap
	 * 3 drag
	 * 4 dragTag
	 * .........
	 */
	var eventName = ['null', 'auto', 'tap', 'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown', 'doubletap', 'press', 'pinchout', 'pinchin', 'rotate', 'assist'];

	/**
	 * 重写默认事件
	 *
	 * Content对象默认具有左右翻页的特性
	 * 根据过滤来选择是否覆盖重写这个特性
	 * 比如 用户如果遇到 swipeLeft，swipeRight 这种本身与翻页行为冲突的
	 * 将要覆盖这个行为
	 * 过滤事件
	 * 如果用户指定了如下操作行为,将覆盖默认的翻页行为
	 **/
	/**
	 * ppt事件接口
	 *
	 * 允许用户自定义其行为
	 *     1 支持14种操作行为
	 *     2 默认对象都具有滑动翻页的特性
	 *     3 翻页的特性在遇到特性的情况可以被覆盖
	 *     比如
	 *         行为1：用户定义该名字可以支持  click 点击行为， 那么该元素左右滑动能过翻页
	 *         行为2：用户如果定义swipeLeft 行为，该元素左右滑动将不会翻页，因为默认翻页已经被覆盖
	 *
	 * 此接口函数有作用域隔离
	 */
	var filterEvent = ['drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'];

	/**
	 * 是否过滤
	 * @param  {[type]} evtName [description]
	 * @return {[type]}         [description]
	 */
	var isfilter = function isfilter(eventName) {
	    return filterEvent.indexOf(eventName) === -1 ? true : false;
	};

	/**
	 * 特性摘除
	 * 1 ：无事件，默认可以翻页，还可以切换工具栏
	 * 2 ：静态事件，默认可以翻页
	 * 3 : 冲突事件，默认删除
	 * 去除默认元素具有的翻页特性
	 * @param  {[type]} evtName [事件名]
	 * @return {[type]}         [description]
	 */
	var setDefaultBehavior = function setDefaultBehavior(supportSwipe, $contentNode) {
	    if (supportSwipe) {
	        //静态事件，默认可以翻页，还可以切换工具栏
	        $contentNode.attr('data-behavior', 'swipe');
	    } else {
	        //如果事件存在
	        $contentNode.attr('data-behavior', 'disable');
	    }
	};

	/**
	 * 针对软件培训的操作行为下光标状态需求
	 */
	var addCursor = function addCursor(eventName, $contentNode) {
	    if ($contentNode) {
	        if (!$contentNode.prop('setCursor')) {
	            //只设置一次
	            if (eventName === ('drag' || 'dragTag')) {
	                $contentNode.css('cursor', 'Move');
	            } else {
	                $contentNode.css('cursor', 'Pointer');
	            }
	            $contentNode.prop('setCursor', 'true');
	        }
	    }
	};

	/**
	 *  绑定事件
	 * @param  {[type]} eventDrop [description]
	 * @param  {[type]} data      [description]
	 * @return {[type]}           [description]
	 */
	var bind = function bind(eventDrop, data) {
	    var dragObj = void 0;
	    var handler = void 0;
	    var reference = void 0;
	    var eventContext = data.eventContext;
	    var eventName = data.eventName;
	    var supportSwipe = data.supportSwipe;

	    if (eventName === 'drag') {
	        //拖动
	        dragObj = new _drag2.default(eventContext, null, data.parameter, eventDrop.startRun, eventDrop.stopRun);
	    } else if (eventName === 'dragTag') {
	        //拖拽
	        dragObj = new _drag2.default(eventContext, data.target, 1, eventDrop.startRun, eventDrop.stopRun);
	    } else {
	        handler = function handler() {
	            data.eventRun.call(eventContext);
	        };
	        if (eventName === 'tap') {
	            //单机bind
	            reference = (0, _simple.simpleEvent)(eventContext, handler, supportSwipe);
	        } else {
	            //复杂用hammer
	            reference = (0, _complex.complexEvent)(eventContext, eventName, handler, supportSwipe);
	        }
	    }

	    return {
	        dragObj: dragObj,
	        reference: reference,
	        handler: handler
	    };
	};

	/**
	 * /匹配事件
	 * parameter 参数
	 * 1：对于自由拖动drag，para参数为0，表示松手后，停留在松手的地方
	 *                    para参数为1，表示松手后，返回原来的位置
	 * 2: 对于拖拽dragTag， para表示目标对象的target
	 */
	function distribute(data) {
	    //针对软件培训的操作行为下光标状态需求
	    Xut.plat.isBrowser && data.domMode && addCursor(data.eventName, data.eventContext);

	    //绑定事件
	    var eventDrop = data.eventDrop;

	    //拖动,引用,回调
	    var eventObj = bind(eventDrop, data);

	    //拖动,拖拽对象处理
	    if (eventObj.dragObj && eventDrop.init) {
	        eventDrop.init(eventObj.dragObj);
	        return;
	    }
	    //其余事件
	    data.eventHandler(eventObj.reference, eventObj.handler);
	}

	//数据库预定义14个事件接口
	//提供给content文件
	//用于过滤数据库字段指定的行为
	//https://github.com/EightMedia/hammer.js/wiki/Getting-Started
	//2014.3.18 新增assist 辅助对象事件
	function conversionEventType(eventType) {
	    return eventName[Number(eventType) - 1] || null;
	}

	/**
	 * 增加默认行为
	 */
	function defaultBehavior($contentNode) {
	    $contentNode && $contentNode.attr('data-behavior', 'disable');
	}

	/**
	 * 注册自定义事件
	 * this还是引用的当前实例的上下文
	 *
	 *   '$contentNode'   : 事件对象
	 *   'target'    : 目标对象
	 *   'parameter' : 拖动参数
	 *   'evtName'   : 事件名,
	 *
	 *   callbackHook 回调函数 ,处理具体的事情
	 */
	function bindContentEvent(data) {
	    //是否支持翻页
	    var supportSwipe = data.supportSwipe = isfilter(data.eventName);
	    //检测是否移除元素的默认行为,因为元素都具有翻页的特性
	    if (data.domMode) {
	        setDefaultBehavior(supportSwipe, data.eventContext);
	    }
	    distribute(data);
	}

	/**
	 * 销毁对象事件
	 */
	function destroyContentEvent(eventData, eventName) {
	    if (eventData.eventReference) {
	        eventData.eventReference.off(eventName || eventData.eventName, eventData.eventHandler);
	        eventData.eventReference = null;
	        eventData.eventHandler = null;
	    }
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.fixAudio = fixAudio;
	exports.destroyFixAudio = destroyFixAudio;
	exports.hasAudioes = hasAudioes;
	exports.getAudio = getAudio;

	var _dom = __webpack_require__(5);

	/**
	 * audio对象下标
	 * @type {Number}
	 */
	var index = 0;
	var loop = 5;
	var audioes = [];

	/**
	 * 修复audio
	 * @param  {[type]} obj    [description]
	 * @param  {[type]} key    [description]
	 * @param  {[type]} access [description]
	 * @return {[type]}        [description]
	 */
	function fixAudio(obj, key, access) {
	    var start = function start() {
	        var audio = void 0,
	            i = void 0;
	        for (i = 0; i < loop; i++) {
	            audio = new Audio();
	            audio.play();
	            audioes.push(audio);
	        }
	        (0, _dom.$$off)(document, { start: start });
	    };
	    (0, _dom.$$on)(document, { start: start });
	}

	/**
	 * 销毁创建的video对象
	 * @return {[type]} [description]
	 */
	function destroyFixAudio() {
	    for (var i = 0; i < audioes.length; i++) {
	        audioes[i] = null;
	    }
	    audioes = null;
	}

	function hasAudioes() {
	    return audioes.length;
	}

	function getAudio() {
	    var audio = audioes[index++];
	    if (!audio) {
	        index = 0;
	        return getAudio();
	    }
	    return audio;
	}

/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 *
	 * 基本事件管理
	 * 1 异步
	 * 2 同步
	 *
	 */

	var ArrayProto = Array.prototype;
	var nativeIndexOf = ArrayProto.indexOf;
	var slice = ArrayProto.slice;
	var _indexOf = function _indexOf(array, needle) {
	    var i, l;
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) {
	        return array.indexOf(needle);
	    }
	    for (i = 0, l = array.length; i < l; i++) {
	        if (array[i] === needle) {
	            return i;
	        }
	    }
	    return -1;
	};

	var Observer = function () {
	    function Observer() {
	        _classCallCheck(this, Observer);

	        this.$watch = this.bind;
	        this.$off = this.unbind;
	        this.$emit = this.trigger;
	        this.$once = this.one;

	        //触发列表名称
	        //防止同步触发
	        this._handleName = {};
	    }

	    _createClass(Observer, [{
	        key: "bind",
	        value: function bind(event, fn) {
	            var i, part;
	            var events = this.events = this.events || {};
	            var parts = event.split(/\s+/);
	            var num = parts.length;

	            for (i = 0; i < num; i++) {
	                events[part = parts[i]] = events[part] || [];
	                if (_indexOf(events[part], fn) === -1) {
	                    events[part].push(fn);
	                }
	            }

	            //假如存在同步句柄
	            //执行
	            var data;
	            if (data = this._handleName[event]) {
	                this.$emit(event, data[0]);
	            }

	            return this;
	        }
	    }, {
	        key: "one",
	        value: function one(event, fn) {
	            // [notice] The value of fn and fn1 is not equivalent in the case of the following MSIE.
	            // var fn = function fn1 () { alert(fn === fn1) } ie.<9 false
	            var fnc = function fnc() {
	                this.unbind(event, fnc);
	                fn.apply(this, slice.call(arguments));
	            };
	            this.bind(event, fnc);
	            return this;
	        }
	    }, {
	        key: "unbind",
	        value: function unbind(event, fn) {
	            var eventName, i, index, num, parts;
	            var events = this.events;

	            if (!events) return this;

	            //指定
	            if (arguments.length) {
	                parts = event.split(/\s+/);
	                for (i = 0, num = parts.length; i < num; i++) {
	                    if ((eventName = parts[i]) in events !== false) {
	                        index = fn ? _indexOf(events[eventName], fn) : -1;
	                        if (index !== -1) {
	                            events[eventName].splice(index, 1);
	                        }
	                    }
	                }
	            } else {
	                this.events = null;
	            }

	            return this;
	        }
	    }, {
	        key: "trigger",
	        value: function trigger(event) {
	            var args, i;
	            var events = this.events,
	                handlers;

	            //参数
	            args = slice.call(arguments, 1);

	            if (!events || event in events === false) {
	                // console.log(event)
	                //同步的情况
	                //如果除非了事件，可能事件句柄还没有加载
	                this._handleName[event] = args;
	                return this;
	            }

	            handlers = events[event];
	            for (i = 0; i < handlers.length; i++) {
	                handlers[i].apply(this, args);
	            }
	            return this;
	        }
	    }]);

	    return Observer;
	}();

	exports.default = Observer;

/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports._key = _key;
	exports.$$remove = $$remove;
	exports.$$resetUUID = $$resetUUID;
	exports.$$fetch = $$fetch;
	exports.$$save = $$save;
	var onlyId = void 0;

	var TAG = 'aaron';
	var storage = window.localStorage;

	//如果数据库为写入appid ,则创建
	var createAppid = function createAppid() {
	    //添加UUID
	    var appId = 'aaron-' + new Date().getDate();
	    //写入数据库
	    Xut.config.db && Xut.config.db.transaction(function (tx) {
	        tx.executeSql("UPDATE Setting SET 'value' = " + appId + " WHERE [name] = 'appId'", function () {}, function () {});
	    }, function () {
	        //  callback && callback();
	    }, function () {
	        //  callback && callback();
	    });
	    return appId;
	};

	//过滤
	var filter = function filter(key) {
	    //添加头部标示
	    if (onlyId) {
	        return key + onlyId;
	    } else {
	        if (!Xut.config.appUUID) {
	            Xut.config.appUUID = createAppid();
	        }
	        //子文档标记
	        if (window.SUbCONFIGT && window.SUbCONFIGT.dbId) {
	            onlyId = "-" + Xut.config.appUUID + "-" + window.SUbCONFIGT.dbId;
	        } else {
	            onlyId = "-" + Xut.config.appUUID;
	        }
	    }
	    return key + onlyId;
	};

	var set = function name(key, val) {
	    var setkey;

	    //ipad ios8.3setItem出问题
	    function setItem(key, val) {
	        try {
	            storage.setItem(key, val);
	        } catch (e) {
	            console.log('storage.setItem(setkey, key[i]);');
	        }
	    }

	    if (_.isObject(key)) {
	        for (var i in key) {
	            if (key.hasOwnProperty(i)) {
	                setkey = filter(i);
	                setItem(setkey, key[i]);
	            }
	        }
	    } else {
	        key = filter(key);
	        setItem(key, val);
	    }
	};

	var get = function get(key) {
	    key = filter(key);
	    return storage.getItem(key) || undefined;
	};

	/**
	 * *按索引值获取存储项的key
	 * @param  {[type]} index [description]
	 * @return {[type]}       [description]
	 */
	function _key(index) {
	    //本地方法
	    return storage.key(index);
	}

	/**
	 * 设置localStorage
	 * @param {[type]} key [description]
	 * @param {[type]} val [description]
	 */
	exports.$$set = set;

	/**
	 * 获取localstorage中的值
	 * @param  {[type]} key [description]
	 * @return {[type]}     [description]
	 */

	exports.$$get = get;

	/**
	 * 删除localStorage中指定项
	 * @param  {[type]} key [description]
	 * @return {[type]}     [description]
	 */

	function $$remove(key) {
	    key = filter(key);
	    storage.removeItem(key);
	}

	/**
	 * 重设缓存的UUID
	 * 为了只计算一次
	 * @return {[type]} [description]
	 */
	function $$resetUUID() {
	    onlyId = null;
	}

	/**
	 * 序列化
	 * @return {[type]} [description]
	 */
	function $$fetch() {
	    return JSON.parse(get(name || TAG) || '[]');
	}

	function $$save(name, val) {
	    set(name || TAG, JSON.stringify(val));
	}

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.setStyle = setStyle;
	exports.converValue = converValue;
	exports.flipMove = flipMove;
	exports.flipOver = flipOver;
	exports.flipRebound = flipRebound;
	exports.overMemory = overMemory;

	var _index = __webpack_require__(1);

	var transitionDuration = Xut.style.transitionDuration;
	var transform = Xut.style.transform;
	var translateZ = Xut.style.translateZ;
	var setTranslateZ = Xut.style.setTranslateZ;
	var round = Math.round;

	/**
	 * 获取视觉差parallax配置
	 * @return {[type]} [description]
	 */
	function setStyle(_ref) {
	    var $contentNode = _ref.$contentNode,
	        action = _ref.action,
	        property = _ref.property,
	        _ref$speed = _ref.speed,
	        speed = _ref$speed === undefined ? 0 : _ref$speed,
	        _ref$pageOffset = _ref.pageOffset,
	        pageOffset = _ref$pageOffset === undefined ? 0 : _ref$pageOffset,
	        _ref$opacityStart = _ref.opacityStart,
	        opacityStart = _ref$opacityStart === undefined ? 0 : _ref$opacityStart;

	    var style = {};
	    var effect = '';
	    var x = 0;
	    var y = 0;
	    var z = 0;

	    //视觉差对象初始化偏移量
	    var parallaxOffset = pageOffset;

	    //平移
	    if (property.translateX !== undefined || property.translateY !== undefined || property.translateZ !== undefined) {
	        x = round(property.translateX) || 0;
	        y = round(property.translateY) || 0;
	        z = round(property.translateZ) || 0;
	        parallaxOffset += x;
	        var _translateZ = setTranslateZ(z);
	        effect += 'translate(' + parallaxOffset + 'px,' + y + 'px) ' + _translateZ;
	    }

	    //旋转
	    if (property.rotateX !== undefined || property.rotateY !== undefined || property.rotateZ !== undefined) {
	        x = round(property.rotateX);
	        y = round(property.rotateY);
	        z = round(property.rotateZ);
	        effect += x ? 'rotateX(' + x + 'deg) ' : '';
	        effect += y ? 'rotateY(' + y + 'deg) ' : '';
	        effect += z ? 'rotateZ(' + z + 'deg) ' : '';
	    }

	    //缩放
	    if (property.scaleX !== undefined || property.scaleY !== undefined || property.scaleZ !== undefined) {
	        x = round(property.scaleX * 100) / 100 || 1;
	        y = round(property.scaleY * 100) / 100 || 1;
	        z = round(property.scaleZ * 100) / 100 || 1;
	        effect += String.format('scale3d({0},{1},{2}) ', x, y, z);
	    }

	    //透明度
	    if (property.opacity !== undefined) {
	        if (action === 'init') {
	            style.opacity = round((property.opacityStart + property.opacity) * 100) / 100;
	        }
	        if (action === 'master') {
	            style.opacity = round(property.opacity * 100) / 100 + opacityStart;
	        }
	        effect += ';';
	    }

	    if (effect) {
	        style[transitionDuration] = speed + 'ms';
	        style[transform] = effect;
	        $contentNode && $contentNode.css(style);
	    }

	    return parallaxOffset;
	}

	/**
	 * transform转化成相对应的偏移量
	 */
	function converValue(property, distance, nodes) {
	    var temp = {},
	        i;

	    for (i in property) {
	        switch (i) {
	            case 'translateX':
	            case 'translateZ':
	                temp[i] = distance * nodes * property[i];
	                break;
	            case 'translateY':
	                temp[i] = distance * (_index.config.viewSize.height / _index.config.viewSize.width) * nodes * property[i];
	                break;
	            case 'opacityStart':
	                temp[i] = property.opacityStart;
	                break;
	            default:
	                //乘以-1是为了向右翻页时取值为正,位移不需这样做
	                temp[i] = -1 * distance / _index.config.viewSize.width * property[i] * nodes;
	        }
	    }
	    return temp;
	}

	/**
	 * 移动叠加值
	 */
	function flipMove(property, repairProperty) {
	    var temp = {};
	    var start = property.opacityStart;
	    for (var i in property) {
	        temp[i] = property[i] + repairProperty[i];
	    }
	    if (start > -1) {
	        temp.opacityStart = start;
	    }
	    return temp;
	}

	/**
	 * 翻页结束
	 */
	function flipOver(property, repairProperty) {
	    return flipMove(property, repairProperty);
	}

	/**
	 * 反弹
	 */
	function flipRebound(property, repairProperty) {
	    var temp = {};
	    for (var i in property) {
	        temp[i] = repairProperty[i] || property[i];
	    }
	    return temp;
	}

	/**
	 * 结束后缓存上一个记录
	 */
	function overMemory(property, repairProperty) {
	    for (var i in property) {
	        repairProperty[i] = property[i];
	    }
	}

/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * 资源路径
	 * resource 就是图片音频数据文件
	 * widget 是零件资源文件
	 * @type {String}
	 */

	var defaultSourcePath = "content/gallery/";
	var defaultWidgetPath = "content/widget/";

	/**
	 * 资源根路径
	 * @type {String}
	 */
	var getSourcePath = exports.getSourcePath = function getSourcePath() {
	    if (window.DYNAMICCONFIGT) {
	        return window.DYNAMICCONFIGT.resource + '/gallery/';
	    } else {
	        return defaultSourcePath;
	    }
	};

	/**
	 * 零件
	 * @param  {[type]} 'source' [description]
	 * @return {[type]}          [description]
	 */
	var getWidgetPath = exports.getWidgetPath = function getWidgetPath() {
	    if (window.DYNAMICCONFIGT) {
	        return window.DYNAMICCONFIGT.resource + '/widget/';
	    } else {
	        return defaultWidgetPath;
	    }
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.errorTable = errorTable;
	exports.saveCache = saveCache;
	exports.removeCache = removeCache;
	exports.convertCache = convertCache;
	exports.setApi = setApi;

	var _transform = __webpack_require__(97);

	var _sql = __webpack_require__(30);

	/**
	 * 数据缓存
	 */
	var dataCache = void 0;

	/**
	 * 带有场景信息存数
	 */
	var sectionRelated = void 0;

	/**
	 * 音频的ActivityId信息
	 */
	var videoActivityIdCache = void 0;

	/**
	 * 错误表
	 */
	var errortables = void 0;

	/**
	 * 错误表
	 * @return {[type]} [description]
	 */
	function errorTable() {
	    return errortables;
	}

	/**
	 * 保存缓存
	 * @param {[type]} results [description]
	 */
	function saveCache(results, collectError) {
	    //错表
	    errortables = collectError || [];

	    //数据结果集
	    Xut.data = dataCache = results;
	}

	/**
	 * 销毁数据
	 * @return {[type]} [description]
	 */
	function removeCache() {
	    dataCache = null;
	    sectionRelated = null;
	    videoActivityIdCache = null;
	    Xut.data = null;
	}

	/**
	 * 转化缓存
	 */
	function convertCache() {

	    /**
	     * 计算数据偏移量
	     */
	    (0, _transform.dataOffset)(dataCache);

	    /**
	     * vidoe特殊处理，需要记录chapterId范围
	     */
	    if (dataCache.Video) {
	        videoActivityIdCache = (0, _transform.transformVideoActivity)(dataCache);
	    }

	    /**
	     * 带有场景处理
	     * @type {[type]}
	     */
	    sectionRelated = (0, _transform.transformSectionRelated)(dataCache);
	}

	/**
	 *  查询数据接口
	 *  1 video表传递是activityId关联
	 *  2 其余表都是传递当前表的id
	 *  type 查询ID的类型, 数据的id或者activityId
	 *  callback 提供给chapterId使用
	 * @return {[type]} [description]
	 */
	function setApi(novelId) {

	    /**
	     * 标记应用ID
	     * @type {[type]}
	     */
	    dataCache.novelId = novelId;

	    /**
	     * 针对数据库content为空的处理
	     * @return {[type]} [description]
	     */
	    dataCache.preventContent = function () {
	        return dataCache.Content.length ? false : true;
	    }();

	    /**
	     * 通过ID查询方式
	     * @param  {[type]}  tableName [description]
	     */
	    dataCache.query = function (tableName, id, type, callback) {
	        /**
	         * 特殊的字段关联
	         * 1 activityId
	         * 2 chpaterId
	         */
	        switch (type) {
	            /**
	             * 通过activityId查询的方式
	             *
	             * 表名,ID,类型
	             * Xut.data.query('Action', id, 'activityId');
	             *
	             * @type {[type]}
	             */
	            case 'activityId':
	                var item;
	                var activityId = id;
	                var data = dataCache[tableName];
	                for (var i = 0, len = data.length; i < len; i++) {
	                    item = data.item(i);
	                    if (item) {
	                        if (item[type] == activityId) {
	                            return item;
	                        }
	                    }
	                }
	                return;

	            /**
	             * 通过chpaterId查询方式
	             * parser中的scanActivity过滤处理
	             */
	            case 'chapterId':
	            case 'seasonId':
	                var chapterId = id;
	                var data = dataCache[tableName];
	                if (data) {
	                    var item;
	                    for (var i = 0, len = data.length; i < len; i++) {
	                        item = data.item(i);
	                        if (item) {
	                            if (item[type] == chapterId) {
	                                callback && callback(item);
	                            }
	                        }
	                    }
	                }
	                return;
	        }

	        /**
	         * 数据信息
	         * @return {[type]} [description]
	         */
	        var Query = function Query() {
	            var data = dataCache[tableName];
	            if (id) {
	                var index = id - data.start;
	                return data.item(index);
	            } else {
	                return data.length ? data.item(0) : null;
	            }
	        };

	        /**
	         * 通过id查询的方式
	         */
	        switch (tableName) {
	            //获取整个一个用的chapter数据
	            case 'appPage':
	                return dataCache.Chapter;
	            ///获取整个一个用的Section数据 
	            case 'appSection':
	                return dataCache.Season;
	            //如果是是section信息
	            case 'sectionRelated':
	                return sectionRelated['seasonId->' + id];
	            //如果是音频
	            case 'Video':
	                if (type) {
	                    return Query();
	                } else {
	                    //传递的id是activityId
	                    var id = videoActivityIdCache[id];
	                    return dataCache.query('Video', id, true);
	                }

	            default:
	                //默认其余所有表
	                return Query();
	        }
	    };

	    /**
	     * 针对动态表查询
	     * 每次需要重新取数据
	     * Xut.data.oneQuery('Image',function(){});
	     * @return {[type]} [description]
	     */
	    dataCache.oneQuery = function (tableName, callback) {
	        (0, _sql.oneQuery)(tableName, function (data) {
	            callback && callback(data);
	        });
	    };

	    /**
	     * 删除数据
	     * 表名,表ID
	     * @return {[type]} [description]
	     */
	    dataCache.remove = function (tableName, id, success, failure) {
	        (0, _sql.dataRemove)(tableName, id, success, failure);
	    };
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.importDatabase = importDatabase;
	exports.getResults = getResults;
	exports.removeResults = removeResults;

	var _loader = __webpack_require__(10);

	/**
	 * 数据库缓存结果集
	 */
	var result = void 0;

	/**
	 * 设置数据缓存
	 * 1 去掉全局挂着
	 * 2 缓存
	 */
	function importDatabase(callback) {
	    //如果外联指定路径json数据
	    var path = window.DYNAMICCONFIGT && window.DYNAMICCONFIGT.database;
	    if (path) {
	        //add window.SQLResult database
	        (0, _loader.request)(path, function () {
	            result = window.SQLResult;
	            window.SQLResult = null;
	            callback();
	        });
	    }
	    //如果外联index.html路径json数据
	    else if (window.SQLResult) {
	            result = window.SQLResult;
	            window.SQLResult = null;
	            callback();
	        } else {
	            callback();
	        }
	}

	/**
	 * 获取数据缓存
	 * @return {[type]} [description]
	 */
	function getResults() {
	    return result;
	}

	/**
	 * 移除缓存数据
	 * @return {[type]} [description]
	 */
	function removeResults() {
	    result = null;
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _action = __webpack_require__(98);

	var _action2 = _interopRequireDefault(_action);

	var _media = __webpack_require__(99);

	var _media2 = _interopRequireDefault(_media);

	var _widget = __webpack_require__(101);

	var _widget2 = _interopRequireDefault(_widget);

	var _shownote = __webpack_require__(100);

	var _shownote2 = _interopRequireDefault(_shownote);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	    'Video': _media2.default,
	    'Audio': _media2.default,
	    'Webpage': _media2.default,
	    Action: _action2.default,
	    Widget: _widget2.default,
	    ShowNote: _shownote2.default
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.disable = exports.setDelay = exports.ShowTextBusy = exports.HideBusy = exports.ShowBusy = undefined;
	exports.createCursor = createCursor;

	var _index = __webpack_require__(1);

	/**
	 * 用css3实现的忙碌光标
	 * @return {[type]} [description]
	 */
	var transform = Xut.style.transform;
	var animationDelay = Xut.style.animationDelay;

	/**
	 * 延时加载
	 * @type {Number}
	 */
	var delay = 500;

	/**
	 * 光标对象
	 * @type {[type]}
	 */
	var node = null;

	/**
	 * 是否禁用忙了光标
	 * @type {Boolean}
	 */
	var isDisable = false;

	/**
	 * 光标状态
	 * 调用隐藏
	 * @type {Boolean}
	 */
	var isCallHide = false;

	/**
	 * setTimouet
	 * @type {[type]}
	 */
	var timer = null;

	/**
	 * create
	 * @return {[type]} [description]
	 */
	function createCursor() {
	    if (isDisable) return;
	    var sWidth = _index.config.viewSize.width;
	    var sHeight = _index.config.viewSize.height;
	    var width = Math.min(sWidth, sHeight) / 4;
	    var space = Math.round((sHeight - width) / 2);
	    var delay = [0, 0.9167, 0.833, 0.75, 0.667, 0.5833, 0.5, 0.41667, 0.333, 0.25, 0.1667, 0.0833];
	    var deg = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];

	    var count = 12;
	    var html = '';
	    var container = '';

	    //忙碌光标自定义
	    if (_index.config.cursor && _index.config.cursor.url) {
	        container += '<div class="xut-busy-middle fullscreen-background"\n                           style="background-image: url(' + _index.config.cursor.url + ');">\n                      </div>';
	    } else {
	        while (count--) {
	            container += '<div class="xut-busy-spinner"\n                      style="' + transform + ':rotate(' + deg[count] + 'deg) translate(0,-142%);' + animationDelay + ':-' + delay[count] + 's">\n                 </div>';
	        }
	        container = '<div class="xut-busy-middle">' + container + '</div>';
	    }

	    html = '<div style="width:' + width + 'px;height:' + width + 'px;margin:' + space + 'px auto;margin-top:' + (_index.config.viewSize.top + space) + 'px;">\n            <div style="height:30%;"></div>\n            ' + container + '\n            <div class="xut-busy-text"></div>\n        </div>';

	    node = $('.xut-busy-icon').html(String.styleFormat(html));
	}

	var clear = function clear() {
	    clearTimeout(timer);
	    timer = null;
	};

	/**
	 * 显示光标
	 */
	var ShowBusy = exports.ShowBusy = function ShowBusy() {
	    if (isDisable || Xut.IBooks.Enabled || timer) return;
	    timer = setTimeout(function () {
	        node.show();
	        clear();
	        if (isCallHide) {
	            HideBusy();
	            isCallHide = false;
	        }
	    }, delay);
	};

	/**
	 * 隐藏光标
	 */
	var HideBusy = exports.HideBusy = function HideBusy() {
	    //显示忙碌加锁，用于不处理hideBusy
	    if (isDisable || Xut.IBooks.Enabled || ShowBusy.lock) return;
	    if (!timer) {
	        node.hide();
	    } else {
	        isCallHide = true;
	    }
	};

	/**
	 * 显示光标
	 * @param {[type]} txt [description]
	 */
	var ShowTextBusy = exports.ShowTextBusy = function ShowTextBusy(txt) {
	    if (isDisable || Xut.IBooks.Enabled) return;
	    node.css('pointer-events', 'none').find('.xut-busy-text').html(txt);
	    ShowBusy();
	};

	/**
	 * 设置时间
	 * @param  {[type]} time [description]
	 * @return {[type]}      [description]
	 */
	var setDelay = exports.setDelay = function setDelay(time) {
	    delay = time;
	};

	/**
	 * 禁用光标
	 * isDisable 是否禁用
	 * @return {[type]} [description]
	 */
	var disable = exports.disable = function disable(state) {
	    isDisable = state;
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.translation = undefined;
	exports.fix = fix;

	var _index = __webpack_require__(1);

	var reqAnimationFrame = Xut.style.reqAnimationFrame; /**
	                                                      * 页面切换效果
	                                                      * 平移
	                                                      * @return {[type]} [description]
	                                                      */

	var transitionDuration = Xut.style.transitionDuration;
	var transform = Xut.style.transform;
	var translateZ = Xut.style.translateZ;

	/**
	 * 切换坐标
	 * 保证只是pageType === page才捕获动作
	 */
	var toTranslate3d = function toTranslate3d(node, distance, speed, callback) {
	    node && Xut.nextTick(function () {
	        node.style[transform] = 'translate(' + distance + 'px,0px) ' + translateZ;
	        node.style[transitionDuration] = speed + 'ms';
	        callback && callback();
	    });
	};

	/**
	 * 设置
	 * @param  {[type]} node [description]
	 * @return {[type]}      [description]
	 */
	var set = function set(node, x) {
	    if (node) {
	        node.style[transform] = 'translate(' + x + 'px,0px) ' + translateZ;
	    }
	};

	/**
	 * 复位
	 * @return {[type]} [description]
	 */
	var reset = function reset(node) {
	    if (node) {
	        node.style[transform] = 'translate(0px,0px) ' + translateZ;
	        node.style[transitionDuration] = '';
	    }
	};

	/**
	 * 移动
	 * @return {[type]} [description]
	 */
	var flipMove = function flipMove() {
	    toTranslate3d.apply(undefined, arguments);
	};

	/**
	 * 移动反弹
	 * @return {[type]} [description]
	 */
	var flipRebound = function flipRebound() {
	    toTranslate3d.apply(undefined, arguments);
	};

	/**
	 * 移动结束
	 * @return {[type]} [description]
	 */
	var flipOver = function flipOver() {
	    toTranslate3d.apply(undefined, arguments);
	};

	/**
	 * translation滑动接口
	 * @type {Object}
	 */
	var translation = exports.translation = {
	    set: set,
	    reset: reset,
	    flipMove: flipMove,
	    flipRebound: flipRebound,
	    flipOver: flipOver
	};

	/**
	 * 创建translate初始值
	 * @param  {[type]} offset [description]
	 * @return {[type]}        [description]
	 */
	var createTranslate = function createTranslate(offset) {
	    return 'translate(' + offset + 'px,0px)' + translateZ;
	};

	/**
	 * 修正坐标
	 * @return {[type]} [description]
	 */
	function fix($node, action) {
	    var viewWidth = _index.config.viewSize.width;
	    var translate = action === 'prevEffect' ? createTranslate(-viewWidth) : createTranslate(viewWidth);
	    $node.css(transform, translate);
	}

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(1);

	var _index2 = __webpack_require__(2);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var isIOS = Xut.plat.isIOS;
	var isBrowser = Xut.plat.isBrowser;

	/**
	 * 获取翻页按钮位置
	 * @return {[type]} [description]
	 */
	var getArrowStyle = function getArrowStyle() {
	    var height = _index.config.iconHeight;
	    var settings = _index.config.settings;
	    var styleText = 'height:' + height + 'px;width:' + height + 'px';
	    switch (settings.NavbarPos) {
	        case 0:
	            styleText += ';top:0';
	            break; //顶部
	        case 1:
	            styleText += ';margin-top:' + -height / 2 + 'px';
	            break; //中间
	        case 2:
	            styleText += ';top:auto;bottom:0';
	            break; //底部
	        default:
	            break;
	    }
	    return styleText;
	};

	var gotoPrevSlide = function gotoPrevSlide() {
	    Xut.View.GotoPrevSlide();
	};

	var gotoNextSlide = function gotoNextSlide() {
	    Xut.View.GotoNextSlide();
	};

	/**
	 * 工具栏超类
	 */

	var Bar = function () {
	    function Bar() {
	        _classCallCheck(this, Bar);

	        /**
	         * 系统状态栏高度
	         * 在ios浏览器中状态栏高度为0
	         * @type {[type]}
	         */
	        this.super_barHeight = isIOS && !isBrowser ? 20 : 0;

	        var prop = _index.config.proportion;
	        var iconHeight = _index.config.iconHeight;

	        //获取高度缩放比
	        //自动选择缩放比例
	        this.super_propHeight = _index.config.layoutMode == "horizontal" ? prop.width : prop.height;

	        //获取图标高度
	        //工具栏图标高度
	        this.super_iconHeight = isIOS ? iconHeight : Math.round(this.super_propHeight * iconHeight);

	        //应用标题
	        this.appName = _index.config.shortName;

	        //应用默认配置
	        this.settings = _index.config.settings;
	    }

	    /**
	     * 创建翻页按钮
	     * @return {[type]} [description]
	     */


	    _createClass(Bar, [{
	        key: 'super_createArrows',
	        value: function super_createArrows() {

	            /**
	             * 存放左右翻页按钮
	             * @type {[type]}
	             */
	            this.arrows = (0, _index2.hash)();

	            //是否使用自定义的翻页按钮: true /false
	            //图标名称是客户端指定的：pageforward_'+appId+'.svg
	            var isCustom = this.settings.customButton;

	            var $str = void 0;

	            //动态图标，数据库定义的翻页图标
	            //font字体画翻页图标
	            if (isCustom) {
	                $str = $(this._createIcon());
	            } else {
	                $str = $(this._createArrow());
	            }
	            var $left = $str.eq(0);
	            var $right = $str.eq($str.length - 1); //存在文本节点

	            this.arrows = {
	                prev: {
	                    off: this._onArrow($left, gotoPrevSlide),
	                    el: $left,
	                    able: true
	                },
	                next: {
	                    off: this._onArrow($right, gotoNextSlide),
	                    el: $right,
	                    able: true
	                }
	            };

	            this.$sceneNode.append($str);
	        }
	    }, {
	        key: '_onArrow',
	        value: function _onArrow(el, callback) {
	            el.on("mouseup touchend", function (e) {
	                callback();
	                return false;
	            });
	            return function () {
	                el.off();
	                el = null;
	            };
	        }
	    }, {
	        key: '_getArrowOption',
	        value: function _getArrowOption() {
	            var style = getArrowStyle();
	            var state = this.barStatus ? '' : 'hide';
	            var height = _index.config.iconHeight;
	            return {
	                style: style,
	                state: state,
	                height: height
	            };
	        }

	        /**
	         * font字体版本：箭头翻页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createArrow',
	        value: function _createArrow() {
	            var option = this._getArrowOption();
	            return '<div class="si-icon xut-flip-control xut-flip-control-left icomoon icon-angle-left ' + option.state + '"\n                     style="' + option.style + ';text-align:center;line-height:' + option.height + 'px;font-size:4vh;">\n                </div>\n                <div class="si-icon xut-flip-control xut-flip-control-right icomoon icon-angle-right ' + option.state + '"\n                     style="' + option.style + ';text-align:center;line-height:' + option.height + 'px;">\n                </div>';
	        }

	        /**
	         * 客户端指定：自定义翻页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createIcon',
	        value: function _createIcon() {
	            var style = getArrowStyle();
	            var state = this.toolBarStatus ? '' : 'hide';

	            //默认图标路径
	            var leftStyle = style + ';background-image:url(images/icons/pageforward_' + _index.config.appId + '.svg);background-size:cover';
	            var rightStyle = style + ';background-image:url(images/icons/pageback_' + _index.config.appId + '.svg);background-size:cover';

	            return '<div name="prevArrow"\n                     class="xut-flip-control xut-flip-control-left ' + state + '"\n                     style="' + leftStyle + '">\n               </div>\n                <div name="nextArrow"\n                     class="xut-flip-control xut-flip-control-right ' + state + '"\n                     style="' + rightStyle + '">\n                </div>';
	        }

	        /**
	         * 针对单个按钮的显示隐藏处理
	         * @param  {[type]} dir [next,prev]
	         * @param  {[type]} status  [true/false]
	         * @return {[type]}       [description]
	         */

	    }, {
	        key: '_toggleArrow',
	        value: function _toggleArrow(dir, status) {
	            if (!this.arrows) return;
	            var arrow = this.arrows[dir];
	            //如果没有创建翻页按钮,则不处理
	            if (!arrow) return;
	            arrow.able = status;
	            //如果人为隐藏了工具栏,则不显示翻页按钮
	            if (this.hasTopBar && !this.toolBarStatus && status) {
	                return;
	            }
	            arrow.el[status ? 'show' : 'hide']();
	        }

	        /**
	         * 显示翻页按钮
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_showArrow',
	        value: function _showArrow() {
	            var arrows = this.arrows;
	            for (var dir in arrows) {
	                var arrow = arrows[dir];
	                arrow.able && arrow.el.show();
	            }
	        }

	        /**
	         * 隐藏翻页按钮
	         * @param  {[type]} unlock [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_hideArrow',
	        value: function _hideArrow() {
	            var arrows = this.arrows;
	            for (var dir in arrows) {
	                arrows[dir].el.hide();
	            }
	        }

	        /**
	         * 显示IOS系统工具栏
	         *  iOS状态栏0=show,1=hide
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'super_showSystemBar',
	        value: function super_showSystemBar() {
	            isIOS && Xut.plat.hasPlugin && Xut.Plugin.statusbarPlugin.setStatus(null, null, 0);
	        }

	        /**
	         * 隐藏IOS系统工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'super_hideSystemBar',
	        value: function super_hideSystemBar() {
	            isIOS && Xut.plat.hasPlugin && Xut.Plugin.statusbarPlugin.setStatus(null, null, 1);
	        }

	        /**
	         * 超类销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'super_destory',
	        value: function super_destory() {
	            if (this.arrows) {
	                this.arrows.prev.off();
	                this.arrows.next.off();
	                this.arrows = null;
	            }
	        }

	        /**
	         * 隐藏下一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideNext',
	        value: function hideNext() {
	            this._toggleArrow('next', false);
	        }

	        /**
	         * 显示下一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showNext',
	        value: function showNext() {
	            this._toggleArrow('next', true);
	        }

	        /**
	         * 隐藏上一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hidePrev',
	        value: function hidePrev() {
	            this._toggleArrow('prev', false);
	        }

	        /**
	         * 显示上一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showPrev',
	        value: function showPrev() {
	            this._toggleArrow('prev', true);
	        }

	        /**
	         * [ 显示工具栏]
	         * @param  {[type]} pointer [description]
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: '_showToolBar',
	        value: function _showToolBar(pointer) {
	            switch (pointer) {
	                case 'controlBar':
	                    this.showTopBar();
	                    break;
	                case 'button':
	                    this._showArrow();
	                    this.Lock = false;
	                    break;
	                default:
	                    this.showTopBar();
	                    this._showArrow();
	            }
	        }

	        /**
	         * [ 隐藏工具栏]
	         * @param  {[type]} pointer [description]
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: '_hideToolBar',
	        value: function _hideToolBar(pointer) {
	            switch (pointer) {
	                case 'controlBar':
	                    this.hideTopBar();
	                    break;
	                case 'button':
	                    this._hideArrow();
	                    this.Lock = false;
	                    break;
	                default:
	                    this.hideTopBar();
	                    this._hideArrow();
	            }
	        }

	        /**
	         * 切换状态
	         * @param  {[type]} state   [description]
	         * @param  {[type]} pointer [description]
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: 'toggle',
	        value: function toggle(state, pointer) {
	            if (this.Lock) return;
	            this.Lock = true;
	            switch (state) {
	                case 'show':
	                    this._showToolBar(pointer);
	                    break;
	                case 'hide':
	                    this._hideToolBar(pointer);
	                    break;
	                default:
	                    //默认：工具栏显示隐藏互斥处理
	                    this.toolBarStatus ? this._hideToolBar(pointer) : this._showToolBar(pointer);
	                    break;
	            }
	        }

	        /**
	         * 重置翻页按钮,状态以工具栏为标准
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'resetArrow',
	        value: function resetArrow() {
	            this.toolBarStatus ? this._showArrow() : this._hideArrow();
	        }
	    }]);

	    return Bar;
	}();

	exports.default = Bar;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.audioPlayer = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(1);

	var _base = __webpack_require__(77);

	var _base2 = _interopRequireDefault(_base);

	var _fix = __webpack_require__(15);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 音频播放
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @param  {[type]} global [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @return {[type]}        [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


	var Player = null;
	var noop = function noop() {};
	var instance = {}; //存放不同音轨的一个实例
	var audioPlayer = void 0;
	var plat = Xut.plat;

	var UUIDcreatePart = function UUIDcreatePart(length) {
	    var uuidpart = "";
	    var uuidchar = void 0;
	    for (var i = 0; i < length; i++) {
	        uuidchar = parseInt(Math.random() * 256, 10).toString(16);
	        if (uuidchar.length == 1) {
	            uuidchar = "0" + uuidchar;
	        }
	        uuidpart += uuidchar;
	    }
	    return uuidpart;
	};

	var createUUID = function createUUID() {
	    return [4, 2, 2, 2, 6].map(UUIDcreatePart).join('-');
	};

	/**
	 * 使用PhoneGap的Media播放
	 * @param  {string} url 路径
	 * @return {[type]}      [description]
	 */

	var _Media = function (_BaseAudio) {
	    _inherits(_Media, _BaseAudio);

	    function _Media(options, controlDoms) {
	        _classCallCheck(this, _Media);

	        var _this = _possibleConstructorReturn(this, (_Media.__proto__ || Object.getPrototypeOf(_Media)).call(this));

	        var url = _index.config.getAudioPath() + options.url,
	            trackId = options.trackId,
	            self = _this,
	            audio;

	        //构建之前处理
	        _this.preRelated(trackId, options);

	        //音频成功与失败调用
	        audio = new window.GLOBALCONTEXT.Media(url, function () {
	            self.callbackProcess(true);
	        }, function () {
	            self.callbackProcess(true);
	        });

	        //autoplay
	        _this.audio = audio;
	        _this.trackId = trackId;
	        _this.options = options;

	        //相关数据
	        _this.afterRelated(options, controlDoms);

	        _this.play();
	        return _this;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    _createClass(_Media, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            var _this2 = this;

	            this.audio.getCurrentPosition(function (position) {
	                var audioTime = void 0;
	                position = position * 1000;
	                if (!_this2.changeValue) {
	                    _this2.changeValue = position;
	                }
	                position -= _this2.changeValue;
	                if (position > -1) {
	                    audioTime = Math.round(position);
	                }
	                callback(audioTime);
	            }, function (e) {
	                console.log("error:" + e);
	                //出错继续检测
	                callback();
	            });
	        }

	        /**
	         * 取反
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.release();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);

	    return _Media;
	}(_base2.default);

	/**
	 * 采用Falsh播放
	 * @type {[type]}
	 */


	var _Flash = function (_BaseAudio2) {
	    _inherits(_Flash, _BaseAudio2);

	    function _Flash(options, controlDoms) {
	        _classCallCheck(this, _Flash);

	        var _this3 = _possibleConstructorReturn(this, (_Flash.__proto__ || Object.getPrototypeOf(_Flash)).call(this));

	        var trackId = options.trackId,
	            url = _index.config.getAudioPath() + options.url,
	            self = _this3,
	            audio;

	        //构建之前处理
	        _this3.preRelated(trackId, options);

	        audio = new Audio5js({
	            swf_path: './lib/data/audio5js.swf',
	            throw_errors: true,
	            format_time: true,
	            ready: function ready(player) {
	                this.load(url);
	                //如果调用了播放
	                this.play();
	                self.status = "playing";
	            }
	        });

	        _this3.audio = audio;
	        _this3.trackId = trackId;
	        _this3.status = 'playing';
	        _this3.options = options;

	        _this3.isFlash = true;

	        //相关数据
	        _this3.afterRelated(options, controlDoms);
	        return _this3;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    _createClass(_Flash, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.audio.audio.currentTime * 1000));
	        }
	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.destroy();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);

	    return _Flash;
	}(_base2.default);

	/**
	 * 使用PhoneGap的 js直接调用 cordova Media播放
	 * @param  {string} url 路径
	 * @return {[type]}      [description]
	 */


	var _cordovaMedia = function (_BaseAudio3) {
	    _inherits(_cordovaMedia, _BaseAudio3);

	    function _cordovaMedia(options, controlDoms) {
	        _classCallCheck(this, _cordovaMedia);

	        var _this4 = _possibleConstructorReturn(this, (_cordovaMedia.__proto__ || Object.getPrototypeOf(_cordovaMedia)).call(this));

	        var url = _index.config.getAudioPath() + options.url,
	            trackId = options.trackId,
	            self = _this4,
	            audio;

	        _this4.id = createUUID();

	        //构建之前处理
	        _this4.preRelated(trackId, options);

	        var audio = {
	            startPlayingAudio: function startPlayingAudio() {
	                window.audioHandler.startPlayingAudio(self.id, url);
	            },
	            pausePlayingAudio: function pausePlayingAudio() {
	                window.audioHandler.pausePlayingAudio(self.id);
	            },
	            release: function release() {
	                window.audioHandler.release(self.id);
	            },
	            /**
	             * 扩充，获取位置
	             * @return {[type]} [description]
	             */
	            expansionCurrentPosition: function expansionCurrentPosition() {
	                return window.getCurrentPosition(self.id);
	            }
	        };

	        //autoplay
	        _this4.audio = audio;
	        _this4.trackId = trackId;
	        _this4.options = options;

	        //相关数据
	        _this4.afterRelated(options, controlDoms);

	        _this4.play();
	        return _this4;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    _createClass(_cordovaMedia, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.expansionCurrentPosition() * 1000));
	        }

	        //播放

	    }, {
	        key: 'play',
	        value: function play() {
	            if (this.audio) {
	                this.status = 'playing';
	                this.audio.startPlayingAudio();
	            }
	            this.acitonObj && this.acitonObj.play();
	        }

	        //停止

	    }, {
	        key: 'pause',
	        value: function pause() {
	            this.status = 'paused';
	            this.audio && this.audio.pausePlayingAudio();
	            this.acitonObj && this.acitonObj.pause();
	        }

	        //结束

	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.release();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);

	    return _cordovaMedia;
	}(_base2.default);

	/**
	 * 采用_Audio5js播放
	 * @type {[type]}
	 */


	var _Audio5js = function (_BaseAudio4) {
	    _inherits(_Audio5js, _BaseAudio4);

	    function _Audio5js(options, controlDoms) {
	        _classCallCheck(this, _Audio5js);

	        var _this5 = _possibleConstructorReturn(this, (_Audio5js.__proto__ || Object.getPrototypeOf(_Audio5js)).call(this));

	        var trackId = options.trackId,
	            url = _index.config.getAudioPath() + options.url,
	            self = _this5,
	            audio;

	        //构建之前处理
	        _this5.preRelated(trackId, options);

	        audio = new Audio5js({
	            ready: function ready(player) {
	                this.load(url);
	                //如果调用了播放
	                this.play();
	                self.status = "playing";
	            }
	        });

	        _this5.audio = audio;
	        _this5.trackId = trackId;
	        _this5.status = 'playing';
	        _this5.options = options;

	        //相关数据
	        _this5.afterRelated(options, controlDoms);
	        return _this5;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    _createClass(_Audio5js, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.audio.audio.currentTime * 1000));
	        }
	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.destroy();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);

	    return _Audio5js;
	}(_base2.default);

	/**
	 * 使用html5的audio播放
	 * @param  {string} url    音频路径
	 * @param  {object} options 可选参数
	 * @return {object}         [description]
	 */


	var _Audio = function (_BaseAudio5) {
	    _inherits(_Audio, _BaseAudio5);

	    function _Audio(options, controlDoms) {
	        _classCallCheck(this, _Audio);

	        var _this6 = _possibleConstructorReturn(this, (_Audio.__proto__ || Object.getPrototypeOf(_Audio)).call(this));

	        var trackId = options.trackId;
	        var url = _index.config.getAudioPath() + options.url;
	        var audio = void 0;
	        var self = _this6;

	        var hasAudio = (0, _fix.hasAudioes)();

	        //构建之前处理
	        _this6.preRelated(trackId, options);

	        if (instance[trackId]) {
	            audio = hasAudio ? (0, _fix.getAudio)() : instance[trackId];
	            audio.src = url;
	        } else {
	            if (hasAudio) {
	                audio = (0, _fix.getAudio)();
	                audio.src = url;
	            } else {
	                audio = new Audio(url);
	                //更新音轨
	                //妙妙学方式不要音轨处理
	                instance[trackId] = audio;
	            }
	        }

	        _this6._callback = function () {
	            self.callbackProcess();
	        };

	        _this6._throughCallback = function () {
	            self.play();
	        };

	        /**
	         * safari 自动播放
	         * 手机浏览器需要加
	         * 2016.8.26
	         * @type {Boolean}
	         */
	        audio.autoplay = true;

	        audio.addEventListener('canplaythrough', _this6._throughCallback, false);
	        audio.addEventListener('ended', _this6._callback, false);
	        audio.addEventListener('error', _this6._callback, false);

	        _this6.audio = audio;
	        _this6.trackId = trackId;
	        _this6.status = 'playing';
	        _this6.options = options;

	        //相关数据
	        _this6.afterRelated(options, controlDoms);
	        return _this6;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    _createClass(_Audio, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.currentTime * 1000));
	        }
	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.pause();
	                this.audio.removeEventListener('canplaythrough', this._throughCallback, false);
	                this.audio.removeEventListener('ended', this._callback, false);
	                this.audio.removeEventListener('error', this._callback, false);
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);

	    return _Audio;
	}(_base2.default);

	//安卓客户端apk的情况下


	if (plat.isAndroid && !plat.isBrowser) {
	    exports.audioPlayer = audioPlayer = _Media;
	} else {
	    //妙妙学的 客户端浏览器模式
	    if (window.MMXCONFIG && window.audioHandler) {
	        exports.audioPlayer = audioPlayer = _cordovaMedia;
	    } else {
	        exports.audioPlayer = audioPlayer = _Audio;
	    }
	}

	exports.audioPlayer = audioPlayer;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.VideoClass = exports.Video5 = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 视频和网页模块（统一整合到VideoClass里面了）
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 这里有四种播放器:
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    1：基于html5原生实现的video标签 for ios
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    2：基于phoneGap插件实现的media  for android
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    3: 基于videoJS用flash实现的播放 for pc
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    4: 用于插入一个网页的webview
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _index = __webpack_require__(1);

	var _manager = __webpack_require__(4);

	var _support = __webpack_require__(83);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var pixelRatio = window.devicePixelRatio;
	var resolution = window.screen;

	var VideoPlayer = null;

	/**
	 * 网页
	 * @param {[type]} options [description]
	 */
	var _WebPage = function _WebPage(options) {

	    var pageUrl = options.pageUrl;

	    //跳转app市场
	    //普通网页是1
	    //跳转app市场就是2
	    if (options.hyperlink == 2) {
	        //跳转到app市场
	        window.open(pageUrl);
	        //数据统计
	        $.get('http://www.appcarrier.cn/index.php/adplugin/recordads?aid=16&esbId=ios');
	    } else {

	        var padding = options.padding || 0,
	            width = options.width,
	            height = options.height,
	            videoId = options.videoId,
	            left = options.left,
	            top = options.top,
	            $videoNode,
	            eleWidth,
	            eleHeight;

	        if (padding) {
	            eleWidth = width - 2 * padding;
	            eleHeight = height - 2 * padding;
	        } else {
	            eleWidth = width;
	            eleHeight = height;
	        }

	        $videoNode = $('<div id="videoWrap_' + videoId + '" style="position:absolute;left:' + left + 'px;top:' + top + 'px;width:' + width + 'px;height:' + height + 'px;z-index:' + Xut.zIndexlevel() + '">' + '<div style="position:absolute;left:' + padding + 'px;top:' + padding + 'px;width:' + eleWidth + 'px;height:' + eleHeight + 'px;">' + '<iframe src="' + pageUrl + '" style="position:absolute;left:0;top:0;width:100%;height:100%;"></iframe>' + '</div>' + '</div>');

	        options.container.append($videoNode);
	    }

	    function play() {
	        $videoNode && $videoNode.show();
	    }

	    function stop() {
	        $videoNode && $videoNode.hide();
	    }

	    function close() {
	        if ($videoNode) {
	            $videoNode.remove();
	            $videoNode = null;
	        }
	    }

	    play();

	    return {
	        play: play,
	        stop: stop,
	        close: close
	    };
	};

	/**
	 * webView弹出框
	 * @param  {[type]} options [description]
	 * @return {[type]}         [description]
	 */
	var webView = function webView(options) {
	    var width = options.width,
	        height = options.height,
	        pageUrl = options.pageUrl,
	        left = options.left,
	        top = options.top;

	    function play() {
	        //打开一个网页的时候，需要关闭其他已经打开过的网页
	        Xut.Plugin.WebView.close();
	        Xut.openWebView = false;
	        setTimeout(function () {
	            Xut.Plugin.WebView.open(pageUrl, left, top, height, width, 1);
	            Xut.openWebView = true;
	        }, 500);
	    }

	    function close() {
	        Xut.Plugin.WebView.close();
	        Xut.openWebView = false;
	    }

	    play();

	    return {
	        play: play,
	        stop: close,
	        close: close
	    };
	};

	/**
	 * 安卓phonegap播放器
	 * @param  {[type]} options [description]
	 * @return {[type]}         [description]
	 */
	var _Media = function _Media(options) {

	    var width = void 0;
	    var height = void 0;
	    var left = void 0;
	    var top = void 0;
	    var url = void 0;

	    //如果是读库或者妙妙学
	    url = window.MMXCONFIG || window.DUKUCONFIG ? options.url
	    //如果是纯apk模式
	    : options.url.substring(0, options.url.lastIndexOf('.'));

	    //如果是安卓平台，视频插件去的分辨率
	    //所以这里要把 可以区尺寸，转成分辨率
	    //读库强制全屏
	    if (window.DUKUCONFIG) {
	        width = resolution.width;
	        height = resolution.height;
	        top = 0;
	        left = 0;
	    } else {
	        //正常的是按照屏幕尺寸的
	        //这是安卓插件问题,按照分辨率计算
	        width = options.width * pixelRatio;
	        height = options.height * pixelRatio;
	        left = options.left * pixelRatio || 0;
	        top = options.top * pixelRatio || 0;
	    }

	    var play = function play() {
	        Xut.Plugin.VideoPlayer.play(function () {
	            //成功回调
	        }, function () {
	            //失败回调
	        }, _index.config.getVideoPath() + url, 1, left, top, height, width);
	    };

	    var close = function close() {
	        Xut.Plugin.VideoPlayer.close();
	    };

	    play();

	    return {
	        play: play,
	        stop: close,
	        close: close
	    };
	};

	/**
	 *   html5的video播放器
	 *   API :
	 *   play();播放
	 *   stop();    //停止播放并隐藏界面
	 *   destroy(); //清除元素节点及事件绑定
	 *  demo :
	 *  var video = new Video({url:'1.mp4',width:'320',...});
	 *  video.play();
	 */
	var _Video5 = function _Video5(options) {

	    var container = options.container || $('body');
	    var url = _index.config.getVideoPath() + options.url;
	    var width = options.width;
	    var height = options.height;
	    var top = options.top;
	    var left = options.left;
	    var zIndex = options.zIndex;
	    var videoWrap = '<div style="width:' + width + ';\n                     height:' + height + ';\n                     position:absolute;\n                     visibility:hidden;\n                     z-index:' + zIndex + ';\n                     top:' + top + ';\n                     left:' + left + ';">\n         </div>';

	    var $videoWrap = $(String.styleFormat(videoWrap));
	    var video = document.createElement('video');
	    var $videoNode = $(video).css({
	        width: width,
	        height: height
	    }).attr({
	        'src': url,
	        'controls': 'controls',
	        'autoplay': 'autoplay'
	    });

	    //父容器
	    $videoWrap.append($videoNode);

	    /**
	     * 播放视频
	     * @return {[type]} [description]
	     */
	    function play() {
	        //iphone手机上，系统接管后，点击完成
	        //必须这样处理后，才能再次显示
	        $videoWrap.show();
	        video.play();
	    }

	    function start() {
	        play();
	        //防止播放错误时播放界面闪现
	        $videoWrap.css('visibility', 'visible');
	    }

	    /**
	     * 停止
	     * @return {[type]} [description]
	     */
	    function stop() {
	        video.pause();
	        //妙妙学只需要停止
	        if (!window.MMXCONFIG) {
	            //复位视频
	            if (video.duration) {
	                video.currentTime = 0.01;
	            }
	            $videoWrap.hide();
	            //用于启动视频
	            if (options.startBoot) {
	                options.startBoot();
	                destroy();
	            }
	        }
	    }

	    /**
	     * 错误
	     * @return {[type]} [description]
	     */
	    function error() {
	        if (options.startBoot) {
	            options.startBoot();
	        }
	        (0, _manager.removeVideo)(options.pageId);
	    }

	    function clear() {
	        stop();
	        (0, _manager.removeVideo)(options.pageId);
	    }

	    /**
	     * 销毁
	     */
	    function destroy() {
	        video.removeEventListener('ended', clear, false);
	        video.removeEventListener('error', error, false);
	        video.removeEventListener('canplay', start, false);
	        video.removeEventListener('webkitendfullscreen', stop, false);
	        $videoWrap.remove();
	        $videoNode = null;
	        $videoWrap = null;
	    }

	    video.addEventListener('ended', clear, false);
	    video.addEventListener('error', error, false);
	    video.addEventListener('canplay', start, false);
	    video.addEventListener('webkitendfullscreen', stop, false);

	    //////////////////////////
	    ///2016.6.23
	    //安卓ios需要直接调用play开始
	    //移动端必须触发2次play
	    ////////////////////////
	    if (Xut.plat.isIOS || Xut.plat.isAndroid) {
	        play();
	    }

	    container.append($videoWrap);

	    return {
	        play: play,
	        stop: stop,
	        close: destroy
	    };
	};

	var _FlareVideo = function _FlareVideo(options) {
	    var container = options.container || $('body');
	    var url = _index.config.getVideoPath() + options.url;
	    var width = options.width;
	    var height = options.height;
	    var top = options.top;
	    var left = options.left;
	    var zIndex = options.zIndex;
	    var fv = $('#Video_' + options.videoId).flareVideo({
	        width: width,
	        height: height,
	        autoplay: true,
	        flashSrc: 'lib/data/FlareVideo.swf'
	    });
	    fv.load([{
	        src: url,
	        type: 'video/mp4'
	    }]);

	    return {
	        play: function play() {
	            fv.play();
	        },
	        stop: function stop() {
	            fv.pause();
	        },
	        close: function close() {
	            fv.remove();
	            fv = null;
	        }
	    };
	};

	//浏览器平台
	if (Xut.plat.isBrowser) {
	    // 安卓妙妙学强制走h5
	    // 由于原生H5控制条不显示的问题
	    // 这里用插件播放
	    if (Xut.plat.isAndroid) {
	        VideoPlayer = _FlareVideo;
	    } else {
	        //pc ios 浏览器打开方式
	        VideoPlayer = _Video5;
	    }
	} else {
	    //apk ipa
	    if (Xut.plat.isIOS || top.EduStoreClient) {
	        //如果是ibooks模式
	        if (Xut.IBooks.Enabled) {
	            VideoPlayer = _FlareVideo;
	        } else {
	            //如果是ios或读酷pc版则使用html5播放
	            VideoPlayer = _Video5;
	        }
	    } else if (Xut.plat.isAndroid) {
	        if (window.MMXCONFIG) {
	            // 安卓妙妙学强制走h5
	            // 由于原生H5控制条不显示的问题
	            // 这里用插件播放
	            VideoPlayer = _FlareVideo;
	        } else {
	            //android平台
	            VideoPlayer = _Media;
	        }
	    }
	}

	var VideoClass = function () {
	    function VideoClass(options, container) {
	        _classCallCheck(this, VideoClass);

	        options.container = container;
	        if ('video' == options.category) {
	            this.video = VideoPlayer(options);
	        } else if ('webpage' == options.category) {
	            this.video = _WebPage(options);
	        } else {
	            console.log('options.category must be video or webPage ');
	        }
	        Xut.View.Toolbar("hide");
	    }

	    _createClass(VideoClass, [{
	        key: 'play',
	        value: function play() {
	            //隐藏工具栏
	            Xut.View.Toolbar("hide");
	            this.video.play();
	        }
	    }, {
	        key: 'stop',
	        value: function stop() {
	            //显示工具栏
	            Xut.View.Toolbar("show");
	            this.video.stop();
	        }
	    }, {
	        key: 'close',
	        value: function close() {
	            this.video.close();
	        }
	    }]);

	    return VideoClass;
	}();

	exports.Video5 = _Video5;
	exports.VideoClass = VideoClass;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.updateAction = updateAction;

	exports.default = function (inputPara, contents) {
	    var option = getData(inputPara, contents);
	    var ResourcePath = _index.config.getWidgetPath() + "gallery/" + inputPara.id + "/";
	    var contentPrefix = inputPara.contentPrefix;
	    var ids = [];
	    var options = {};
	    options.contentPrefix = contentPrefix;
	    options.resourcePath = ResourcePath;
	    options.type = 'seniorSprite';

	    for (var i = 0; i < option.spiritList.length; i++) {
	        var spiritList = option.spiritList[i];
	        var id = getId(spiritList, contentPrefix);
	        var framId = spiritList.framId;
	        var parentId = spiritList.parentId;
	        if (_.isObject(inputPara)) {
	            if (parentId != "0") {
	                moveContent(contentPrefix, framId, parentId);
	            }
	            spiritObjs[id] = new _advance2.default(spiritList, options);
	            ids.push(id);
	        } else {
	            console.log("inputPara undefine Spirit");
	        }
	    }

	    return {
	        stop: function stop() {
	            ids.forEach(function (key) {
	                spiritObjs[key].stop();
	            });
	        },
	        destroy: function destroy() {
	            ids.forEach(function (key) {
	                spiritObjs[key].destroy();
	                spiritObjs[key] = null;
	                delete spiritObjs[key];
	            });
	        }
	    };
	};

	var _advance = __webpack_require__(41);

	var _advance2 = _interopRequireDefault(_advance);

	var _lang = __webpack_require__(3);

	var _index = __webpack_require__(1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var spiritObjs = {};

	// $("body").on("dblclick",function(){
	//   console.log(spiritObjs)
	// })

	/**
	 * get data
	 * @param  {[type]} inputPara [description]
	 * @param  {[type]} contents  [description]
	 * @return {[type]}           [description]
	 */
	var getData = function getData(inputPara, contents) {
	    var option = void 0;
	    var resourcePath = _index.config.getWidgetPath() + "gallery/" + inputPara.id + "/";
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', resourcePath + 'app.json', false);
	    xhr.send(null);
	    try {
	        option = (0, _lang.parseJSON)(xhr.responseText);
	    } catch (e) {
	        console.log("app.json get error:" + e);
	    }
	    return option;
	};

	var moveContent = function moveContent(contentPrefix, id, parentId) {
	    var obj = $("#" + contentPrefix + id);
	    var parentObj = $("#" + contentPrefix + parentId);
	    var $parent = $("#spirit_parent_" + parentId);
	    if ($parent.length == 0) {
	        parentObj.append("<div style='position:absolute; width:100%; height:100%'  id='spirit_parent_" + parentId + "'></div>");
	    }
	    $parent.append(obj);
	};

	var getId = function getId(inputPara, contentPrefix) {
	    var id = '';
	    if (_.isObject(inputPara)) {
	        id = contentPrefix + inputPara.framId;
	    } else {
	        id = inputPara;
	    }
	    return id;
	};

	function updateAction(id, params) {

	    var loop = 1;
	    var obj = void 0;
	    if (params.playerType == "loop") {
	        loop = 0;
	    }

	    if (obj = spiritObjs[id]) {
	        obj.play(params.actList, loop);
	    } else {
	        console.log('error');
	    }
	}

/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.query = query;
	/**
	 * 根据指定的chpaterId解析
	 * @return {[type]} [description]
	 */
	var scenarioChapter = function scenarioChapter(chapterId) {
	    var chapterSection = Xut.data.chapterSection;
	    var rang = chapterSection['seasonId->' + chapterId];
	    return rang;
	};

	/**
	 * 递归分解
	 * chpater直接对应页面的ID编码，直接去下标即可
	 * waitCreatePointer     需要分解的页面
	 */
	var parseChapter = function parseChapter(waitCreatePointer) {
	    var chapters = [],
	        chapter,
	        dataChpater = Xut.data.Chapter,
	        points = waitCreatePointer.length,
	        key;

	    while (points--) {
	        key = waitCreatePointer[points];
	        if (chapter = dataChpater.item(key)) {
	            chapters.unshift(chapter);
	        }
	    }

	    return chapters;
	};

	/**
	 * 解析视觉差的数据
	 * @param  {[type]}   data     [description]
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var getMasterData = function getMasterData(data, callback) {
	    var pptMaster = data['pptMaster'];
	    var masterData = Xut.data.query('Master', pptMaster);
	    makeActivitys(masterData, function (activitys, autoData) {
	        callback(masterData, activitys, autoData);
	    });
	};

	/**
	 * 解析出页面自动运行的数据
	 * autoplay && !Content
	 * @param  {[type]} activitys [description]
	 * @return {[type]}           [description]
	 */
	var makeAuto = function makeAuto(activityData) {

	    if (!activityData || !activityData.length) return;

	    var sub = void 0;
	    //自动热点
	    var collectAutoBuffers = [];

	    activityData.forEach(function (target, b) {
	        //如果是自动播放,并且满足自定义条件
	        //并且不是content类型
	        if (target.autoPlay && target.actType !== 'Content') {
	            //增加note提示信息数据
	            // id = target._id
	            // key = target.actType ? target.actType + "_" + id : 'showNote_' + id
	            sub = {
	                'id': target._id,
	                'actType': target.actType,
	                'category': target.category,
	                'autoPlay': target.autoPlay
	            };
	            collectAutoBuffers.push(sub);
	        }
	    });

	    return collectAutoBuffers.length && collectAutoBuffers;
	};

	/**
	 * 混入shownote
	 * 组合showNote数据,弹出信息框,也看作一个热点
	 * shownote是chater的信息，混入到activity列表中当作每页的对象处理
	 * @return {[type]} [description]
	 */
	var mixShowNote = function mixShowNote(oneChapter, activityData) {
	    if (oneChapter.note) {
	        activityData.push(oneChapter);
	    }
	};

	/**
	 * 制作activity表的数据
	 * chpaters = {
	 *     pageIndex-12: Object
	 *     pageIndex-13: Object
	 *     pageIndex-14: Object
	 *  }
	 **/
	var makeActivitys = function makeActivitys(chapterData, callback) {
	    if (!chapterData) callback();

	    var activitys = [];
	    var chapterId = chapterData._id;

	    Xut.data.query('Activity', chapterId, 'chapterId', function (item) {
	        activitys.push(item);
	    });

	    //混入文本提示框
	    mixShowNote(chapterData, activitys);

	    //自动运行的数据
	    //解析出每一页自动运行的 Widget,Action,Video数据
	    var autoData = makeAuto(activitys);

	    callback(activitys, autoData);
	};

	/**
	 * 解析关联的Activity表数据
	 * @param  {[type]}   pageData [description]
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var getActivitys = function getActivitys(chapterData, callback) {
	    makeActivitys(chapterData, function (activitys, autoData) {
	        callback(chapterData, activitys, autoData);
	    });
	};

	/**
	 * 1 解析chapter页面数据
	 * 2 解析对应的Activity数据
	 * 3 解析出自动widget数据结构
	 * @param  {[type]}   data     [description]
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var getPageData = function getPageData(data, callback) {
	    var parsePointer = data.pageIndex;
	    var chapterData = data.pageData;
	    if (chapterData) {
	        getActivitys(chapterData, callback);
	    } else {
	        //解析章节数据
	        parseChapter(parsePointer, function (chapter) {
	            //生成chapter数据
	            getActivitys(chapter.length ? chapter[0] : chapter, callback);
	        });
	    }
	};

	/**
	 * 查询接口
	 * @param  {[type]}   tableName [description]
	 * @param  {[type]}   options   [description]
	 * @param  {Function} callback  [description]
	 * @return {[type]}             [description]
	 */
	function query(tableName, options, callback) {
	    switch (tableName) {
	        case 'page':
	            //得到页面关联的数据
	            return getPageData(options, callback);
	        case 'master':
	            //得到母版关联的数据
	            return getMasterData(options, callback);
	        case 'chapter':
	            //得到chapter表数据
	            return parseChapter(options);
	        case 'scenarioChapter':
	            return scenarioChapter(options);
	    }
	}

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.oneQuery = oneQuery;
	exports.dataQuery = dataQuery;
	exports.dataRemove = dataRemove;

	var _execute = __webpack_require__(95);

	var _execute2 = _interopRequireDefault(_execute);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var statement = {};

	'Setting,Parallax,Master,Activity,Content,Video,Image,Action,Animation,Widget,Novel,Season,Chapter'.replace(/[^, ]+/g, function (name) {
	    statement[name] = 'select * FROM ' + name + ' order by _id ASC';
	});

	/**
	 * 查询单一的数据
	 * @return {[type]} [description]
	 */
	function oneQuery(tableName, callback) {
	    (0, _execute2.default)('select * FROM ' + tableName + ' order by _id ASC', function (successRet, collectError) {
	        callback(successRet, collectError);
	    });
	}

	/**
	 * 查询总数据
	 */
	function dataQuery(callback) {
	    //ibook模式，数据库外部注入的
	    if (Xut.IBooks.CONFIG) {
	        callback(Xut.IBooks.CONFIG.data);
	    } else {
	        //查询所有数据
	        (0, _execute2.default)(statement, function (successRet, collectError) {
	            callback(successRet, collectError);
	        });
	    }
	}

	/**
	 * 删除数据
	 * @type {[type]}
	 */
	function dataRemove(tableName, id, success, fail) {
	    var sql = 'delete from ' + tableName + ' where _id = ' + id;
	    //查询所有数据
	    (0, _execute2.default)(sql, function (success, failure) {
	        if (success) {
	            //成功回调
	            success();
	        } else if (failure) {
	            //失败回调
	            fail();
	        }
	    });
	}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.bindAndroid = bindAndroid;
	exports.offAndroid = offAndroid;

	var _app = __webpack_require__(32);

	/**
	 * 回退按钮状态控制器
	 * @param  {[type]} state [description]
	 * @return {[type]}       [description]
	 */
	var controller = function controller(state) {
	    //如果是子文档处理
	    if (Xut.isRunSubDoc) {
	        //通过Action动作激活的,需要到Action类中处理
	        Xut.publish('subdoc:dropApp');
	        return;
	    }

	    //home
	    if (state === 'pause') {
	        Xut.Application.Original();
	    }

	    //恢复
	    if (state === 'resume') {
	        Xut.Application.Activate();
	    }

	    //退出
	    if (state === 'back') {
	        window.GLOBALCONTEXT.navigator.notification.confirm('您确认要退出吗？', function (button) {
	            if (1 == button) {
	                Xut.Application.Suspend({
	                    processed: function processed() {
	                        window.GLOBALCONTEXT.navigator.app.exitApp();
	                    }
	                });
	            }
	        }, '退出', '确定,取消');
	    }
	};

	/**
	 * 绑定安卓按钮
	 * 回退键
	 * @return {[type]} [description]
	 */
	function bindAndroidBack() {
	    //如果是预加载视频
	    if ((0, _app.getPlugVideoState)()) {
	        (0, _app.closePlugVideo)();
	    } else {
	        controller('back');
	    }
	}

	/**
	 * 绑定安卓按钮
	 * 暂停键
	 * @return {[type]} [description]
	 */
	function bindAndroidPause() {
	    controller('pause');
	}

	/**
	 * 前台恢复
	 * @return {[type]} [description]
	 */
	function bindAndroidResume() {
	    controller('resume');
	}

	/**
	 * 绑定安卓按钮
	 * @return {[type]} [description]
	 */
	function bindAndroid() {
	    if (Xut.plat.hasPlugin) {
	        document.addEventListener("backbutton", bindAndroidBack, false);
	        document.addEventListener("pause", bindAndroidPause, false);
	        document.addEventListener("resume", bindAndroidResume, false);
	    }
	}

	/**
	 * 销毁安卓按钮
	 * @return {[type]} [description]
	 */
	function offAndroid() {
	    if (Xut.plat.hasPlugin) {
	        document.removeEventListener("backbutton", bindAndroidBack, false);
	        document.removeEventListener("pause", bindAndroidPause, false);
	        document.removeEventListener("resume", bindAndroidResume, false);
	    }
	}

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getPlugVideoState = getPlugVideoState;
	exports.closePlugVideo = closePlugVideo;
	exports.plugVideo = plugVideo;
	exports.html5Video = html5Video;

	var _video = __webpack_require__(27);

	var preloadVideo = {

	    //播放状态
	    state: false,

	    //地址
	    path: window.DUKUCONFIG ? window.DUKUCONFIG.path + "duku.mp4" : 'android.resource://#packagename#/raw/duku',

	    //加载视频
	    load: function load() {
	        // if (window.localStorage.getItem("videoPlayer") == 'error') {
	        //       alert("error")
	        //     return preloadVideo.launchApp();
	        // }
	        this.play();
	        this.state = true;
	    },


	    //播放视频
	    play: function play() {
	        //延时应用加载
	        Xut.Application.delayAppRun();
	        Xut.Plugin.VideoPlayer.play(function () {
	            preloadVideo.launchApp();
	        }, function () {
	            //捕获出错,下次不进入了,,暂无ID号
	            // window.localStorage.setItem("videoPlayer", "error")
	            preloadVideo.launchApp();
	        }, preloadVideo.path, 1, 0, 0, window.innerHeight, window.innerWidth);
	    },


	    //清理视频
	    closeVideo: function closeVideo() {
	        Xut.Plugin.VideoPlayer.close(function () {
	            preloadVideo.launchApp();
	        });
	    },


	    //加载应用
	    launchApp: function launchApp() {
	        this.state = false;
	        Xut.Application.LaunchApp();
	    }
	};

	/**
	 * 获取插件视频状态
	 */
	function getPlugVideoState() {
	    return preloadVideo.state;
	}

	/**
	 * 关闭插件视频
	 */
	function closePlugVideo() {
	    preloadVideo.closeVideo();
	}

	/**
	 * 播放视频插件
	 */
	function plugVideo() {
	    preloadVideo.load();
	}

	/**
	 *  创建播放器
	 *  IOS，PC端执行
	 */
	function html5Video() {
	    //延时应用开始
	    Xut.Application.delayAppRun();
	    (0, _video.Video5)({
	        url: 'duku.mp4',
	        startBoot: function startBoot() {
	            Xut.Application.LaunchApp();
	        }
	    });
	}

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _index = __webpack_require__(8);

	//委托事件处理钩子
	exports.default = {

	    /**
	     * 超连接,跳转
	     * svg内嵌跳转标记处理
	     */
	    'data-xxtlink': function dataXxtlink(target, attribute, rootNode, pageIndex) {
	        try {
	            var para = attribute.split('-');
	            if (para.length > 1) {
	                //如果有多个就是多场景的组合
	                Xut.View.GotoSlide(para[0], para[1]);
	            } else {
	                Xut.View.GotoSlide(para[0]);
	            }
	        } catch (err) {
	            console.log('跳转错误');
	        }
	    },


	    /**
	     * Action', 'Widget', 'Video', 'ShowNote', 'SubDoc'委托
	     * arg
	     *   target, attribute, rootNode, pageIndex
	     */
	    'data-delegate': function dataDelegate(target, attribute, rootNode, pageIndex) {
	        _index.$$trigger.apply(null, arguments);
	    },


	    /**
	     * 有效,可滑动
	     */
	    'data-flow': function dataFlow() {},


	    /**
	     * 如果是canvas节点
	     */
	    'data-canvas': function dataCanvas(cur) {
	        // alert(1)
	    }
	}; //调度器

/***/ },
/* 34 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 抽象管理接口
	 * @return {[type]} [description]
	 */

	var Abstract = exports.Abstract = function () {
	    function Abstract() {
	        _classCallCheck(this, Abstract);
	    }

	    _createClass(Abstract, [{
	        key: 'abstractCreateCollection',


	        /**
	         * 创建页面合集
	         * @return {[type]} [description]
	         */
	        value: function abstractCreateCollection() {
	            this.Collections = {};
	        }

	        /**
	         * 增加合集管理
	         */

	    }, {
	        key: 'abstractAddCollection',
	        value: function abstractAddCollection(pageIndex, pageObj) {
	            this.Collections[pageIndex] = pageObj;
	        }

	        /**
	         * 得到页面合集
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractGetCollection',
	        value: function abstractGetCollection() {
	            return this.Collections;
	        }

	        /**
	         * 删除合集管理
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractRemoveCollection',
	        value: function abstractRemoveCollection(pageIndex) {
	            delete this.Collections[pageIndex];
	        }

	        /**
	         * 销毁合集
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractDestroyCollection',
	        value: function abstractDestroyCollection() {
	            var k,
	                Collections = this.Collections;
	            for (k in Collections) {
	                Collections[k].baseDestroy();
	            }
	            this.Collections = null;
	        }

	        /**
	         * 找到页面对象
	         * 1.页面直接pageIndex索引
	         * 2.母版通过母版Id索引
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractGetPageObj',
	        value: function abstractGetPageObj(pageIndex, pageType) {
	            pageType = pageType || this.pageType;
	            //模板传递的可能不是页码
	            if (pageType === 'master') {
	                //如果不是母版ID，只是页码
	                if (!/-/.test(pageIndex)) {
	                    //转化成母版id
	                    pageIndex = this.converMasterId(pageIndex);
	                }
	            }
	            return this.Collections && this.Collections[pageIndex];
	        }

	        /**
	         * 合并处理
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractAssistPocess',
	        value: function abstractAssistPocess(pageIndex, callback) {
	            var pageObj;
	            if (pageObj = this.abstractGetPageObj(pageIndex, this.pageType)) {
	                if (callback) {
	                    callback(pageObj);
	                } else {
	                    return pageObj;
	                }
	            }
	        }

	        /**
	         * 获取页面容器ID
	         * chpaterID
	         * masterID
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractGetPageId',
	        value: function abstractGetPageId(pageIndex, pageType) {
	            var key = pageType === 'page' ? '_id' : 'pptMaster';
	            return this.abstractGetPageData(pageIndex, key, pageType);
	        }

	        /**
	         * 获取页面数据
	         */

	    }, {
	        key: 'abstractGetPageData',
	        value: function abstractGetPageData(pageIndex, key, pageType) {
	            var pageObj;
	            //如果传递key是 pageType
	            if (!pageType && key == 'page' || key == 'master') {
	                pageType = key;
	                key = null;
	            }
	            if (pageObj = this.abstractGetPageObj(pageIndex, pageType)) {
	                return key ? pageObj.chapterData[key] : pageObj.chapterData;
	            }
	        }

	        /**
	         * 得到页面的nodes数据
	         * @param  {[type]} pageIndex [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: 'abstractGetPageNode',
	        value: function abstractGetPageNode(pageIndex, pageType) {
	            return this.abstractGetPageData(pageIndex, 'nodes', pageType);
	        }

	        /**
	         * 执行辅助对象事件
	         * @param  {[type]} activityId  [description]
	         * @param  {[type]} currIndex   [description]
	         * @param  {[type]} outCallBack [description]
	         * @param  {[type]} actionName  [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: 'abstractAssistAppoint',
	        value: function abstractAssistAppoint(activityId, currIndex, outCallBack, actionName) {
	            var pageObj;
	            if (pageObj = this.abstractGetPageObj(currIndex)) {
	                return pageObj.baseAssistRun(activityId, outCallBack, actionName);
	            }
	        }
	    }]);

	    return Abstract;
	}();

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.create = create;
	exports.destroy = destroy;

	var _event = __webpack_require__(14);

	/**
	 * 获取对应的activity对象
	 * @param  {[type]}   activityId [description]
	 * @param  {Function} callback   [description]
	 * @return {[type]}              [description]
	 */
	var getActivity = function getActivity(activityId, callback) {
	    var activity;
	    if (activity = this._abActivitys) {
	        _.each(activity.get(), function (contentObj, index) {
	            if (activityId == contentObj.activityId) {
	                callback(contentObj);
	                return;
	            }
	        }, this);
	    }
	};

	/**
	 * 制作一个处理绑定函数
	 * @param  {[type]} pagebase [description]
	 * @return {[type]}          [description]
	 */
	/**
	 * 多事件模块
	 */
	var makeRunBinding = function makeRunBinding(pagebase) {
	    var registers = this.registers;
	    var shift;
	    return function () {
	        var activityId = registers[0];
	        getActivity.call(pagebase, activityId, function (activityObj) {
	            activityObj.runAnimation(function () {
	                shift = registers.shift();
	                registers.push(shift);
	            });
	        });
	    };
	};

	/**
	 * 多事件处理
	 * 每次通过同一个热点,触发不同的对象操作
	 * @return {[type]} [description]
	 */
	var combineEvents = function combineEvents(pagebase, eventRelated) {
	    var contentObj, eventName;
	    //多条activty数据,一个对象上多事件
	    _.each(eventRelated, function (edata) {
	        _.each(edata, function (scope) {
	            contentObj = pagebase.baseGetContentObject(scope.eventContentId);
	            if (!contentObj) {
	                // console.log('error', 'pagebase.js第' + pagebase.pageIndex + '页多事件处理出错!!!!')
	                return;
	            }
	            eventName = (0, _event.conversionEventType)(scope.eventType);
	            //制动运行动作
	            scope.runAnimation = makeRunBinding.call(scope, pagebase);
	            //销毁方法
	            scope.destroy = function () {
	                (0, _event.destroyContentEvent)(scope, eventName);
	                scope.registers = null;
	                scope.runAnimation = null;
	            };

	            //事件绑定
	            (0, _event.bindContentEvent)({
	                'eventRun': function eventRun() {
	                    scope.runAnimation();
	                },
	                'eventHandler': function eventHandler(eventReference, _eventHandler) {
	                    scope.eventReference = eventReference;
	                    scope.eventHandler = _eventHandler;
	                },
	                'eventContext': contentObj.$contentNode,
	                'eventName': eventName,
	                'parameter': scope.dragdropPara,
	                'target': null,
	                'domMode': true
	            });
	        });

	        //暴露引用
	        pagebase.listenerHooks.registerEvents = eventRelated;
	    });
	};

	function create(pagebase, eventRelated) {
	    combineEvents(pagebase, eventRelated);
	}

	function destroy(pagebase) {
	    var registerEvents;
	    if (registerEvents = pagebase.listenerHooks.registerEvents) {
	        _.each(registerEvents, function (edata) {
	            _.each(edata, function (obj) {
	                obj.destroy && obj.destroy();
	            });
	        });
	    }
	    pagebase.listenerHooks.registerEvents = null;
	}

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Pagebase = undefined;

	var _initstate = __webpack_require__(122);

	var _initstate2 = _interopRequireDefault(_initstate);

	var _thread = __webpack_require__(123);

	var _thread2 = _interopRequireDefault(_thread);

	var _data = __webpack_require__(120);

	var _data2 = _interopRequireDefault(_data);

	var _destroy = __webpack_require__(121);

	var _destroy2 = _interopRequireDefault(_destroy);

	var _container = __webpack_require__(124);

	var _container2 = _interopRequireDefault(_container);

	var _parallax = __webpack_require__(125);

	var _parallax2 = _interopRequireDefault(_parallax);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*********************************************************************
	                                                                                                                                                           *                 构建页面对象
	                                                                                                                                                           *             实现目标：
	                                                                                                                                                           *                快速翻页
	                                                                                                                                                           *                最快中断任务
	                                                                                                                                                           *                提高优先级
	                                                                                                                                                           *
	                                                                                                                                                           *             1 构建四个大任务，每个大人物附属一堆小任务
	                                                                                                                                                           *             2 每次触发一个新的任务，都会去检测是否允许创建的条件
	                                                                                                                                                           *
	                                                                                                                                                           *  2014.11.18
	                                                                                                                                                           *  新增canvan模式
	                                                                                                                                                           *    contentMode 分为  0 或者 1
	                                                                                                                                                           *    0 是dom模式
	                                                                                                                                                           *    1 是canvas模式
	                                                                                                                                                           *    以后如果其余的在增加
	                                                                                                                                                           *    针对页面chapter中的parameter写入 contentMode   值为 1
	                                                                                                                                                           *    如果是canvas模式的时候，同时也是能够存在dom模式是
	                                                                                                                                                           *
	                                                                                                                                                           *                                                         *
	                                                                                                                                                           **********************************************************************/

	var Pagebase = exports.Pagebase = function Pagebase(options) {
	    _classCallCheck(this, Pagebase);

	    this.initState(options);
	};

	var baseProto = Pagebase.prototype;

	(0, _initstate2.default)(baseProto);
	(0, _thread2.default)(baseProto);
	(0, _data2.default)(baseProto);
	(0, _container2.default)(baseProto);
	(0, _parallax2.default)(baseProto);
	(0, _destroy2.default)(baseProto);

/***/ },
/* 37 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.parseContentDas = parseContentDas;
	/**
	 * 解析序列中需要的数据
	 * @param  {[type]}   contentIds [description]
	 * @param  {Function} callback   [description]
	 * @return {[type]}              [description]
	 */
	function parseContentDas(contentIds, callback) {
	    var data,
	        temp = [];
	    contentIds.forEach(function (contentId, index) {
	        data = Xut.data.query('Content', contentId);
	        temp.unshift(data);
	        callback && callback(data, contentId);
	    });
	    return temp;
	}

/***/ },
/* 38 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = pinchButton;
	/**
	 * 关闭按钮
	 * @param  {[type]} right [description]
	 * @param  {[type]} top   [description]
	 * @return {[type]}       [description]
	 */
	var createCloseIcon = function createCloseIcon(right, top) {
	    var html = void 0;
	    var screenSize = Xut.config.screenSize;
	    var width = screenSize.width;
	    var height = screenSize.height;
	    if (width > height) {
	        html = "<div class=\"page-pinch-close\" style=\"position: absolute;right:" + right + "px;top:" + top + "px;\">\n           <div class=\"si-icon icomoon icon-close\" style=\"font-size:5vw;background-color:white;width:5vw;height:5vw;border-radius:50%;right:0\"></div>\n        </div>";
	    } else {
	        html = "<div class=\"page-pinch-close\" style=\"position: absolute;right:" + right + "px;top:" + top + "px;\">\n           <div class=\"si-icon icomoon icon-close\" style=\"font-size:5vh;background-color:white;width:5vh;height:5vh;border-radius:50%;right:0\"></div>\n        </div>";
	    }
	    return $(String.styleFormat(html));
	};

	/**
	 * 创建关闭按钮
	 * @return {[type]} [description]
	 */
	function pinchButton(callback) {
	    var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    var $closeNode = createCloseIcon(right, top);
	    $closeNode.on("touchend mouseup", function () {
	        callback();
	    });
	    return $closeNode;
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _close = __webpack_require__(38);

	var _close2 = _interopRequireDefault(_close);

	var _index = __webpack_require__(1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var transform = Xut.style.transform;
	var transitionDuration = Xut.style.transitionDuration;
	var translateZ = Xut.style.translateZ;

	var START_X = 0;
	var START_Y = 0;

	/**
	 * 缩放、平移操作
	 */

	var PinchPan = function () {
	    function PinchPan(_ref) {
	        var $pagePinch = _ref.$pagePinch,
	            _ref$hasButton = _ref.hasButton,
	            hasButton = _ref$hasButton === undefined ? true : _ref$hasButton,
	            update = _ref.update,
	            doubletap = _ref.doubletap;

	        _classCallCheck(this, PinchPan);

	        this.update = update;
	        this.doubletap = doubletap;

	        //是否配置关闭按钮
	        this.hasButton = hasButton;

	        //缩放根节点
	        this.$pinchNode = $pagePinch;
	        this.pinchNode = $pagePinch[0];

	        this._offsetWidth = this.pinchNode.offsetWidth;
	        this._offsetHeight = this.pinchNode.offsetHeight;

	        //初始化状态
	        this._initState();

	        //初始化事件
	        this._initEvent();
	    }

	    _createClass(PinchPan, [{
	        key: '_initState',
	        value: function _initState() {

	            /**
	             * 最大缩放值
	             * @type {Number}
	             */
	            this.maxScale = _index.config.saleMultiples || 4;

	            /**
	             * 允许溢出值
	             * @type {Number}
	             */
	            this.overflowValue = 0.3;

	            /**
	             * 缩放中
	             * @type {Boolean}
	             */
	            this.scaleing = false;

	            /**
	             * 最后一个缩放值
	             * @type {Number}
	             */
	            this.lastScale = 1;

	            /**
	             * 是否更新中
	             * @type {Boolean}
	             */
	            this.ticking = false;

	            this.currentX = START_X;
	            this.currentY = START_Y;

	            /**
	             * 需要更新的数据
	             * @type {Object}
	             */
	            this.data = {
	                translate: {
	                    x: START_X,
	                    y: START_Y
	                },
	                scale: 1
	            };

	            this._buttonHide();
	        }

	        /**
	         * 初始化事件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initEvent',
	        value: function _initEvent() {
	            var _this = this;

	            this.hammer = new Hammer.Manager(this.pinchNode);
	            this.hammer.add(new Hammer.Pan({ threshold: 0, pointers: 0, enable: false }));
	            this.hammer.add(new Hammer.Pinch({ threshold: 0 })).recognizeWith(this.hammer.get('pan'));
	            this.hammer.add(new Hammer.Tap({ event: 'doubletap', taps: 2, posThreshold: 30 }));
	            this.hammer.add(new Hammer.Tap());

	            _.each({
	                'doubletap': '_onDoubletap',
	                'pinchstart': '_onPinchStart',
	                'pinchmove': '_onPinchMove',
	                'pinchend': '_onPinchEnd',
	                'panstart panmove': '_onPan',
	                'panend': '_onPanEnd',
	                'pinchcancel': '_onPinchEnd'
	            }, function (value, key) {
	                _this.hammer.on(key, function (e) {
	                    e.preventDefault();
	                    e.srcEvent.stopPropagation();
	                    _this[value](e);
	                });
	            });
	        }
	    }, {
	        key: '_onDoubletap',
	        value: function _onDoubletap() {
	            if (this.doubletap) {
	                this.doubletap();
	            } else {
	                this._reset();
	            }
	        }
	    }, {
	        key: '_onPinchStart',
	        value: function _onPinchStart(ev) {
	            this.lastScale = this.data.scale || 1;
	        }

	        /**
	         * 缩放移动
	         * @param  {[type]} ev [description]
	         * @return {[type]}    [description]
	         */

	    }, {
	        key: '_onPinchMove',
	        value: function _onPinchMove(ev) {

	            //允许溢出值
	            if (!this.scaleing) {
	                if (ev.scale < this.overflowValue + 1) {
	                    return;
	                }
	                this.scaleing = true;
	            }

	            var scale = ev.scale - this.overflowValue;
	            scale = this.lastScale * scale;

	            //限定缩放的倍数
	            if (scale > this.maxScale) {
	                return;
	            }

	            //新的缩放值
	            this.data.scale = scale;

	            this._buttonShow();
	            this._isBoundry();
	            this._updateNodeStyle();
	        }

	        /**
	         * 缩放松手
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_onPinchEnd',
	        value: function _onPinchEnd(ev) {
	            var _this2 = this;

	            if (this.data.scale <= 1) {
	                Xut.nextTick(function () {
	                    _this2._initState();
	                    _this2._updateNodeStyle(500);
	                });
	            } else {
	                this.overflowValue = 0;
	            }
	        }

	        /**
	         * 平移
	         * @param  {[type]} ev [description]
	         * @return {[type]}    [description]
	         */

	    }, {
	        key: '_onPan',
	        value: function _onPan(ev) {
	            if (this._isRunning) {
	                if (this.currentX != START_X || this.currentY != START_Y) {
	                    this.data.translate = {
	                        x: this.currentX + ev.deltaX,
	                        y: this.currentY + ev.deltaY
	                    };
	                } else {
	                    this.data.translate = {
	                        x: START_X + ev.deltaX,
	                        y: START_Y + ev.deltaY
	                    };
	                }
	                this._isBoundry();
	                this._updateNodeStyle();
	            }
	        }

	        /**
	         * 平移松手
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_onPanEnd',
	        value: function _onPanEnd() {
	            this.currentX = this.data.translate.x;
	            this.currentY = this.data.translate.y;
	        }

	        /**
	         * 边界反弹
	         * @return {Boolean} [description]
	         */

	    }, {
	        key: '_isBoundry',
	        value: function _isBoundry() {
	            if (this._isRunning) {
	                var horizontalBoundry = (this.data.scale - 1) / 2 * this._offsetWidth;
	                var verticalBoundry = (this.data.scale - 1) / 2 * this._offsetHeight;

	                //左边界
	                if (this.data.translate.x >= horizontalBoundry) {
	                    this.data.translate.x = horizontalBoundry;
	                }
	                //右边界
	                if (this.data.translate.x <= -horizontalBoundry) {
	                    this.data.translate.x = -horizontalBoundry;
	                }
	                //上边界
	                if (this.data.translate.y >= verticalBoundry) {
	                    this.data.translate.y = verticalBoundry;
	                }
	                //下边界
	                if (this.data.translate.y <= -verticalBoundry) {
	                    this.data.translate.y = -verticalBoundry;
	                }
	            } else {
	                this.data.scale = 1;
	                this.data.translate.x = START_X;
	                this.data.translate.y = START_Y;
	            }
	        }

	        /**
	         * 更新节点样式
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_updateNodeStyle',
	        value: function _updateNodeStyle() {
	            var _this3 = this;

	            var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	            if (!this.ticking) {
	                Xut.nextTick(function () {
	                    var data = _this3.data;
	                    var styleText = 'translate(' + data.translate.x + 'px,' + data.translate.y + 'px) ' + translateZ + '\n            scale(' + data.scale + ',' + data.scale + ')';

	                    _this3.pinchNode.style[transform] = styleText;
	                    _this3.pinchNode.style[transitionDuration] = speed + 'ms';
	                    _this3.update && _this3.update(styleText, speed);
	                    _this3.ticking = false;
	                });
	                this.ticking = true;
	            }
	        }

	        /**
	         * 还原
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_reset',
	        value: function _reset() {
	            this._initState();
	            this._updateNodeStyle(500);
	        }

	        /**
	         * 创建按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createPinchButton',
	        value: function _createPinchButton() {
	            var _this4 = this;

	            var viewSize = _index.config.viewSize;
	            var left = viewSize.overflowWidth && Math.abs(viewSize.left) || 0;
	            var top = viewSize.overflowHeight && Math.abs(viewSize.top) || 0;
	            var $node = (0, _close2.default)(function () {
	                _this4._reset();
	            }, left, top);
	            this.$pinchNode.after($node);
	            return $node;
	        }

	        /**
	         * 按钮显示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_buttonShow',
	        value: function _buttonShow() {
	            var _this5 = this;

	            //to heavy
	            if (this._isRunning) return;
	            if (this.data.scale > 1) {
	                //必须启动配置
	                if (this.hasButton) {
	                    if (this.$buttonNode) {
	                        Xut.nextTick(function () {
	                            _this5.$buttonNode.show();
	                        });
	                    } else {
	                        this.$buttonNode = this._createPinchButton();
	                    }
	                }
	                Xut.Application.Bansliding(); //禁止全局滑动
	                this._isRunning = true;
	                this.hammer.get('pan').set({ enable: true });
	            }
	        }

	        /**
	         * 按钮隐藏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_buttonHide',
	        value: function _buttonHide() {
	            if (!this._isRunning) return;
	            this.hasButton && this.$buttonNode.hide();
	            this._isRunning = false;
	            Xut.Application.Allowliding(); //全局滑动
	            this.hammer.get('pan').set({ enable: false });
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this.$buttonNode) {
	                this.$buttonNode.off();
	                this.$buttonNode = null;
	            }
	            this.hammer.destroy();
	            //关闭按钮
	            this.$buttonNode && this.$buttonNode.off();
	        }
	    }]);

	    return PinchPan;
	}();

	exports.default = PinchPan;

/***/ },
/* 40 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.calculateDistance = calculateDistance;
	exports.calculateDirection = calculateDirection;
	exports.colorHexToRGB = colorHexToRGB;
	exports.colorRGBToHex = colorRGBToHex;

	var ceil = Math.ceil;
	var pow = Math.pow;
	var regexpRGB = /^(rgb|RGB)\([0-9]{1,3},\s?[0-9]{1,3},\s?[0-9]{1,3}\)$/; //RGB
	var regexpHex = /^#[0-9a-fA-F]{3,6}$/; //Hex

	/**
	 * 计算两点直线距离
	 */
	function calculateDistance(currentPoint, historyPoint) {
	    var xdiff = currentPoint.x - historyPoint.x;
	    var ydiff = currentPoint.y - historyPoint.y;
	    return ceil(pow(xdiff * xdiff + ydiff * ydiff, 0.5));
	}

	/**
	 * 区间计算
	 */
	function calculateDirection(currentPoint, historyPoint) {
	    var quadrant = ""; //象限
	    if (currentPoint.y == historyPoint.y && currentPoint.x > historyPoint.x) quadrant = "+x"; //水平正方向
	    else if (currentPoint.y == historyPoint.y && currentPoint.x < historyPoint.x) quadrant = "-x"; //水平负方向
	        else if (currentPoint.x == historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "+y"; //垂直正方向
	            else if (currentPoint.x == historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "-y"; //垂直负方向
	                else if (currentPoint.x > historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "1"; //第一象限
	                    else if (currentPoint.x > historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "2"; //第二象限
	                        else if (currentPoint.x < historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "3"; //第三象限
	                            else if (currentPoint.x < historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "4"; //第四象限
	    return quadrant;
	}

	/**
	 * 十六进制颜色转换为RGB颜色
	 * @param color 要转换的十六进制颜色
	 * @return RGB颜色
	 */
	function colorHexToRGB(color, opacity) {
	    color = color.toUpperCase();
	    if (regexpHex.test(color)) {
	        var hexArray = new Array();
	        var count = 1;
	        for (var i = 1; i <= 3; i++) {
	            if (color.length - 2 * i > 3 - i) {
	                hexArray.push(Number("0x" + color.substring(count, count + 2)));
	                count += 2;
	            } else {
	                hexArray.push(Number("0x" + color.charAt(count) + color.charAt(count)));
	                count += 1;
	            }
	        }
	        if (opacity && opacity > 0) return "RGBA(" + hexArray.join(",") + "," + opacity + ")";else return "RGB(" + hexArray.join(",") + ")";
	    } else {
	        console.error("Hex Color string(" + color + ") format conversion error.");
	        return color;
	    }
	}

	/**
	 * RGB颜色转换为十六进制颜色
	 * @param color 要转换的RGB颜色
	 * @return 十六进制颜色
	 */
	function colorRGBToHex(color) {
	    if (regexpRGB.test(color)) {
	        color = color.replace(/(\(|\)|rgb|RGB)*/g, "").split(",");
	        var colorHex = "#";
	        for (var i = 0; i < color.length; i++) {
	            var hex = Number(color[i]).toString(16);
	            if (hex.length == 1) hex = "0" + hex;
	            colorHex += hex;
	        }
	        return colorHex;
	    } else {
	        console.error("RGB Color string(" + color + ") format conversion error.");
	        return color;
	    }
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 2017.7.25
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 1.高级精灵动画
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   提供给widget使用
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 2.复杂精灵动画
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   提供给普通转化高级使用
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	var _loader = __webpack_require__(10);

	var _index = __webpack_require__(1);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _class = function () {
	    function _class(data, options) {
	        _classCallCheck(this, _class);

	        this.data = data;

	        //精灵动画类型 默认为高级精灵动画true 简单转复杂为false
	        this.animationType = true;

	        //高级精灵动画
	        if (options.type == 'seniorSprite') {
	            this.contentPrefix = options.contentPrefix;
	            this.obj = $("#" + this.contentPrefix + this.data.framId);
	            this.resourcePath = options.resourcePath;
	        }
	        //简单精灵强制转换复杂精灵动画
	        else {
	                this.animationType = false;
	                this.contentId = options.contentId;
	                this.obj = $(options.ele);
	                this.resourcePath = _index.config.pathAddress + options.resourcePath + "/";
	            }

	        //是否有蒙版图
	        //resType:1没有蒙版 0：有蒙版
	        this.isMask = false;

	        this.curFPS = 0;
	        this.loop = 1;
	        this.resetCount = 0;

	        var params = this.data.params;
	        var action = this.action = params["actList"].split(",")[0];
	        var pa = params[action];
	        this.FPS = parseInt(pa.fps);
	        this.playerType = pa.playerType;

	        //isSports:0非运动状态 isSports:1运动状态
	        this.isSports = parseInt(pa.isSports);
	        this.originalImageList = pa.ImageList;

	        this.totalFPS = this.originalImageList.length;
	        this._imgArray = [];
	        this.sprObj = null;

	        if (this.playerType == "loop") {
	            this.loop = 0;
	        }

	        this._init();
	    }

	    /**
	     * 初始化
	     * @return {[type]} [description]
	     */


	    _createClass(_class, [{
	        key: '_init',
	        value: function _init() {
	            this._initImage();

	            //判断是否运动状态
	            if (this.isSports) {
	                //初始化位置信息
	                this._initPosition();
	            }
	            //初始化结构
	            this._initStructure();
	        }

	        /**
	         * 检查是否可以运行
	         * 第一次预加载必须先结束
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_checkNextAction',
	        value: function _checkNextAction(task) {
	            if (this._initImageState) {
	                task();
	            } else {
	                this._waitTask = [];
	                this._waitTask.push(task);
	            }
	        }

	        /**
	         * 初始化qualified张图片
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initImage',
	        value: function _initImage() {
	            var _this = this;

	            var i = 0;
	            var qualified = 10;
	            var count = this.qualified = this.totalFPS >= qualified ? qualified : this.totalFPS;
	            var collect = function () {
	                return function () {
	                    if (count == 1) {
	                        _this._initImageState = true;
	                        if (_this._waitTask && _this._waitTask.length) {
	                            _this._waitTask.pop()();
	                        }
	                    } else {
	                        count--;
	                    }
	                };
	            }();

	            for (i; i < this.qualified; i++) {
	                this._preloadImage(i, collect);
	            }
	        }

	        /**
	         * 初始化位置信息
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initPosition',
	        value: function _initPosition() {
	            var obj = this.obj;
	            var params = this.data.params;
	            var action = this.action;
	            this.startPoint = {
	                x: this.originalImageList[0].X,
	                y: this.originalImageList[0].Y,
	                w: parseInt(params[action].width),
	                h: parseInt(params[action].height)
	            };
	            this.xRote = parseInt(obj.css("width")) / this.startPoint.w;
	            this.yRote = parseInt(obj.css("height")) / this.startPoint.h;
	            this.startLeft = parseInt(obj.css("left"));
	            this.startTop = parseInt(obj.css("top"));
	        }

	        /**
	         * 初始化结构
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initStructure',
	        value: function _initStructure() {
	            var obj = this.obj;
	            var framId = void 0;
	            var resourcePath = this.resourcePath;
	            var html = '';

	            // if (this.animationType) {
	            //     framId = this.data.framId
	            // } else {
	            //     let contentId = this.contentId;
	            //     framId = contentId + '_' + this.data.framId
	            // }

	            if (this.isMask) {
	                var filename = this._getFilename(this.originalImageList[0].name);
	                var maskUrl = resourcePath + filename;
	                html = '<div style="width:100%;height:100%;\n                             background: url(' + maskUrl + '.jpg) no-repeat;\n                             background-size: 100% 100%;\n                             -webkit-mask: url(' + maskUrl + '.png) no-repeat;\n                             -webkit-mask-size: 100% 100%;\'>\n                </div>';
	                this.sprObj = $(String.styleFormat(html));
	                obj.append(this.sprObj);
	            } else {
	                var src = resourcePath + this.originalImageList[0].name;
	                html = '<img src="' + src + '" style="width:100%;height:100%;"/>';

	                this.sprObj = $(String.styleFormat(html));
	                obj.html(this.sprObj);
	            }
	        }

	        /**
	         * 获取文件名
	         * @param  {[type]} name [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: '_getFilename',
	        value: function _getFilename(name) {
	            return name.substr(0, name.indexOf('.'));
	        }

	        /**
	         * 图片预加载
	         * 1 png
	         * 2 jpg mask
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_preloadImage',
	        value: function _preloadImage(index, callback) {
	            if (index >= this.totalFPS) {
	                return;
	            }
	            var self = this;
	            var collect = function collect() {
	                self._imgArray && self._imgArray.push(this);
	                callback && callback();
	            };

	            var imageList = this.originalImageList;
	            var resourcePath = this.resourcePath;
	            if (this.isMask) {
	                var filename = this._getFilename(imageList[index].name);
	                (0, _loader.imgReady)(resourcePath + filename + ".png", collect);
	                (0, _loader.imgReady)(resourcePath + filename + ".jpg", collect);
	            } else {
	                (0, _loader.imgReady)(resourcePath + imageList[index].name, collect);
	            }
	        }

	        /**
	         * 改变图片url
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_changeImageUrl',
	        value: function _changeImageUrl() {
	            var imageList = this.originalImageList;
	            var curFPS = imageList[this.curFPS];
	            var resourcePath = this.resourcePath;

	            //第一次循环才加载图片
	            if (this.resetCount === 0) {
	                this._preloadImage(this.curFPS + this.qualified);
	            }

	            if (this.isMask) {
	                var filename = this._getFilename(curFPS.name);
	                this.sprObj.css("background-image", "url(" + resourcePath + filename + ".jpg)");
	                this.sprObj.css("-webkit-mask-image", "url(" + resourcePath + filename + ".png)");
	            } else {
	                var str = resourcePath + curFPS.name;
	                this.sprObj.attr("src", str);
	            }
	        }

	        /**
	         * 改变图片位置
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_changePosition',
	        value: function _changePosition() {
	            var imageList = this.originalImageList;
	            var curFPS = imageList[this.curFPS];
	            var x = curFPS.X - this.startPoint.x;
	            var y = curFPS.Y - this.startPoint.y;
	            this.obj.css({
	                left: this.startLeft + x * this.xRote,
	                top: this.startTop + y * this.yRote
	            });
	        }

	        /**
	         * 运行动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_change',
	        value: function _change() {
	            this._changeImageUrl();
	            if (this.isSports) {
	                this._changePosition();
	            }
	        }
	    }, {
	        key: '_time',
	        value: function _time() {
	            var _this2 = this;

	            this.timer = setTimeout(function () {
	                clearTimeout(_this2.timer);
	                _this2.timer = null;
	                _this2._change();
	                _this2.curFPS++;
	                _this2._set();
	            }, 1000 / this.FPS);
	        }

	        /**
	         * 设置动画运行状态
	         * look 0  循环
	         * lokk 1~n 指定次数
	         */

	    }, {
	        key: '_set',
	        value: function _set() {
	            var _this3 = this;

	            //循环复位
	            if (this.curFPS >= this.totalFPS - 1) {
	                this.curFPS = 0;
	                this.resetCount++;
	            }

	            //指定次数
	            if (this.loop && this.loop == this.resetCount) {
	                this._stop();
	                return;
	            }
	            this._checkNextAction(function () {
	                _this3._time();
	            });
	        }
	    }, {
	        key: '_stop',
	        value: function _stop() {
	            if (this.timer) {
	                clearTimeout(this.timer);
	                this.timer = null;
	            }
	            this.curFPS = 0;
	            this.resetCount = 0;
	        }

	        /**
	         * 开始运行动画
	         * @param  {[type]} action [description]
	         * @param  {[type]} loop   [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: 'play',
	        value: function play(action, loop) {
	            this.action = action;
	            if (!this.data.params[action]) {
	                console.log(" Function changeSwitchAni  parameters " + action + " error");
	                return;
	            }
	            this.loop = loop;
	            this._stop();
	            this._set();
	        }

	        /**
	         * 停止
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            this._stop();
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this._stop();
	            this.obj = null;
	            this.sprObj = null;
	            this.data.params = null;
	            this.data = null;
	            this._imgArray.forEach(function (img) {
	                img = null;
	            });
	            this.originalImageList = null;
	            this._imgArray = null;
	        }
	    }]);

	    return _class;
	}();

	exports.default = _class;

/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	//转换页码索引
	//direction 方向
	//pointer 当前页码标示
	//[17 18 19]  pagePointer
	//[18 19 20]  转换后
	// 17 销毁
	// 20 创建
	var getActionPointer = exports.getActionPointer = function getActionPointer(direction, leftIndex, rightIndex) {
	    var createPointer = void 0; //创建的页
	    var destroyPointer = void 0; //销毁的页
	    switch (direction) {
	        case 'prev':
	            //前处理
	            createPointer = leftIndex - 1;
	            destroyPointer = rightIndex;
	            break;
	        case 'next':
	            //后处理
	            createPointer = rightIndex + 1;
	            destroyPointer = leftIndex;
	            break;
	    }
	    return {
	        createPointer: createPointer,
	        destroyPointer: destroyPointer
	    };
	};

	/**
	 * 初始化首次范围
	 * @return {[type]} [description]
	 */
	var initPointer = exports.initPointer = function initPointer(init, pagetotal) {
	    var leftscope = 0,
	        pagePointer = {};

	    if (init === leftscope) {
	        //首页
	        pagePointer['currIndex'] = init;
	        pagePointer['rightIndex'] = init + 1;
	    } else if (init === pagetotal - 1) {
	        //首页
	        pagePointer['currIndex'] = init;
	        pagePointer['leftIndex'] = init - 1;
	    } else {
	        //中间页
	        pagePointer['leftIndex'] = init - 1;
	        pagePointer['currIndex'] = init;
	        pagePointer['rightIndex'] = init + 1;
	    }
	    return pagePointer;
	};

	/**
	 * 兼容事件对象
	 * @return {[type]}   [description]
	 */
	var compatibilityEvent = exports.compatibilityEvent = function compatibilityEvent(e) {
	    var point;
	    if (e.touches && e.touches[0]) {
	        point = e.touches[0];
	    } else {
	        point = e;
	    }
	    return point;
	};

	/**
	 * 计算当前已经创建的页面索引
	 */
	var calculationIndex = exports.calculationIndex = function calculationIndex(currIndex, targetIndex, pagetotal) {
	    var i = 0,
	        existpage,
	        createpage,
	        pageIndex,
	        ruleOut = [],
	        create = [],
	        destroy,
	        viewFlip;

	    //存在的页面
	    if (currIndex === 0) {
	        existpage = [currIndex, currIndex + 1];
	    } else if (currIndex === pagetotal - 1) {
	        existpage = [currIndex - 1, currIndex];
	    } else {
	        existpage = [currIndex - 1, currIndex, currIndex + 1];
	    }

	    //需要创建的新页面
	    if (targetIndex === 0) {
	        createpage = [targetIndex, targetIndex + 1];
	    } else if (targetIndex === pagetotal - 1) {
	        createpage = [targetIndex - 1, targetIndex];
	    } else {
	        createpage = [targetIndex - 1, targetIndex, targetIndex + 1];
	    }

	    for (; i < createpage.length; i++) {
	        pageIndex = createpage[i];
	        //跳过存在的页面
	        if (-1 === existpage.indexOf(pageIndex)) {
	            //创建目标的页面
	            create.push(pageIndex);
	        } else {
	            //排除已存在的页面
	            ruleOut.push(pageIndex);
	        }
	    }

	    _.each(ruleOut, function (ruleOutIndex) {
	        existpage.splice(existpage.indexOf(ruleOutIndex), 1);
	    });

	    destroy = existpage;

	    viewFlip = [].concat(create).concat(ruleOut).sort(function (a, b) {
	        return a - b;
	    });

	    return {
	        'create': create,
	        'ruleOut': ruleOut,
	        'destroy': destroy,
	        'viewFlip': viewFlip,
	        'targetIndex': targetIndex,
	        'currIndex': currIndex
	    };
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(16);

	var _index2 = _interopRequireDefault(_index);

	var _index3 = __webpack_require__(1);

	var _api = __webpack_require__(157);

	var _api2 = _interopRequireDefault(_api);

	var _dom = __webpack_require__(5);

	var _depend = __webpack_require__(42);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * 翻页速率
	 * @type {Number}
	 */
	var SPEED = 600;

	/**
	 * 默认翻页时间
	 * @type {Object}
	 */
	var DEFAULTTIME = {
	    min: 0,
	    mix: 500
	};

	var getDate = function getDate() {
	    return +new Date();
	};
	var transitionDuration = Xut.style.transitionDuration;
	var LINEARTAG = 'data-viewlinear';

	/**
	 * 自定义事件类型
	 * onSwipeDown 触屏点击
	 * onSwipeMove 触屏移动
	 * onSwipeUp   触屏松手
	 * onSwipeUpSlider触屏松手 滑动处理
	 * onFlipSliding 松手动画（反弹）
	 * onFlipRebound 执行反弹
	 * _onAnimComplete 动画完成
	 * onDropApp 退出应用
	 */

	var Swipe = function (_Observer) {
	    _inherits(Swipe, _Observer);

	    function Swipe(_ref) {
	        var flipWidth = _ref.flipWidth,
	            initIndex = _ref.initIndex,
	            container = _ref.container,
	            flipMode = _ref.flipMode,
	            pagetotal = _ref.pagetotal,
	            multiplePages = _ref.multiplePages,
	            _ref$stopPropagation = _ref.stopPropagation,
	            stopPropagation = _ref$stopPropagation === undefined ? false : _ref$stopPropagation,
	            preventDefault = _ref.preventDefault,
	            _ref$linear = _ref.linear,
	            linear = _ref$linear === undefined ? false : _ref$linear,
	            _ref$borderBounce = _ref.borderBounce,
	            borderBounce = _ref$borderBounce === undefined ? true : _ref$borderBounce,
	            _ref$extraGap = _ref.extraGap,
	            extraGap = _ref$extraGap === undefined ? 0 : _ref$extraGap,
	            sectionRang = _ref.sectionRang;

	        _classCallCheck(this, Swipe);

	        var _this = _possibleConstructorReturn(this, (Swipe.__proto__ || Object.getPrototypeOf(Swipe)).call(this));

	        _this.options = {

	            stopPropagation: stopPropagation,

	            /**
	             * 默认阻止所有行为
	             * @type {[type]}
	             */
	            preventDefault: preventDefault ? preventDefault : true,

	            /**
	             * 是否分段处理
	             * 默认是
	             * @type {[type]}
	             */
	            linear: linear,

	            /**
	             * 启动边界反弹
	             * @type {[type]}
	             */
	            borderBounce: borderBounce,

	            /**
	             * flipMode
	             * 1 翻页没有直接效果，速度改为0
	             * 2 翻页后没有动画回调
	             * @type {[type]}
	             */
	            flipMode: flipMode,

	            /**
	             * 是否有多页面
	             */
	            multiplePages: multiplePages,

	            /**
	             * section分段拼接
	             * @type {[type]}
	             */
	            sectionRang: sectionRang
	        };

	        _this._hindex = initIndex;
	        _this.pagetotal = pagetotal;
	        _this.container = container;

	        /**
	         * 视图宽度
	         * @type {[type]}
	         */
	        _this._viewWidth = flipWidth || _index3.config.viewSize.width;

	        /**
	         * 翻页时间
	         * @type {[type]}
	         */
	        _this._pageTime = _this.options.flipMode ? DEFAULTTIME.min : DEFAULTTIME.mix;

	        /**
	         * 翻页速率
	         * @type {[type]}
	         */
	        _this._speedRate = _this._originalRate = _this._pageTime / _this._viewWidth;

	        /**
	         * 是否移动中
	         * @type {Boolean}
	         */
	        _this._isMoving = false;

	        /**
	         * 计算初始化页码
	         * @type {[type]}
	         */
	        _this.pagePointer = (0, _depend.initPointer)(initIndex, pagetotal);

	        //初始化线性翻页
	        //全局只创建一个翻页容器
	        if (linear) {
	            container.setAttribute(LINEARTAG, true);

	            //this._initDistance 提供给flow调用
	            _this._initDistance = -_this._hindex * (_this._viewWidth + extraGap);
	            container.style[Xut.style.transform] = 'translate(' + _this._initDistance + 'px,0px)' + Xut.style.translateZ;
	            container.style.width = _this._viewWidth * _this.pagetotal + 'px';
	        } else {
	            //用于查找跟元素
	            //ul => page
	            //ul => master
	            var ul = container.querySelectorAll('ul');
	            _this._bubbleNode = {
	                page: ul[0],
	                master: ul[1]
	            };
	        }

	        //绑定行为
	        _this._initEvents();
	        return _this;
	    }

	    /**
	     * 绑定事件
	     * @return {[type]} [description]
	     */


	    _createClass(Swipe, [{
	        key: '_initEvents',
	        value: function _initEvents() {

	            var callback = {
	                start: this,
	                end: this,
	                cancel: this
	            };

	            //flipMode启动，没有滑动处理
	            if (this.options.flipMode) {
	                //不需要绑定transitionend，会设置手动会触发
	            } else if (this.options.multiplePages) {
	                callback.move = this;
	                callback.transitionend = this;
	            }

	            (0, _dom.$$on)(this.container, callback);
	        }

	        /**
	         * 事件处理
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {

	            this.options.preventDefault && e.preventDefault();
	            this.options.stopPropagation && e.stopPropagation();

	            //接受多事件的句柄
	            (0, _dom.$$handle)({
	                start: function start(e) {
	                    this._onStart(e);
	                },
	                move: function move(e) {
	                    this._onMove(e);
	                },
	                end: function end(e) {
	                    this._onEnd(e);
	                },
	                transitionend: function transitionend(e) {
	                    this._onAnimComplete(e);
	                }
	            }, this, e);
	        }

	        /**
	         * 是否多点触发
	         * @return {Boolean} [description]
	         */

	    }, {
	        key: '_hasMultipleTouches',
	        value: function _hasMultipleTouches(e) {
	            return e.touches && e.touches.length > 1;
	        }

	        /**
	         * 触发
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onStart',
	        value: function _onStart(e) {

	            //如果停止滑动
	            //或者多点触发
	            if (this._fliplock || this._hasMultipleTouches(e)) {
	                return;
	            }

	            //判断双击速度
	            //必须要大于350
	            var currtTime = getDate();
	            if (this._clickTime) {
	                if (currtTime - this._clickTime < 350) {
	                    return;
	                }
	            }
	            this._clickTime = currtTime;

	            var interrupt = void 0;
	            var point = (0, _depend.compatibilityEvent)(e);

	            if (!point) {
	                return interrupt = this._preventSwipe = true;
	            }

	            /**
	             * 获取观察对象
	             * 钩子函数
	             * point 事件对象
	             * @return {[type]} [description]
	             */
	            this.$emit('onFilter', function () {
	                interrupt = true;
	            }, point, e);

	            //打断动作
	            if (interrupt) return;

	            this._deltaX = 0;
	            this._deltaY = 0;

	            this._preventSwipe = false; //是否滑动事件受限
	            this._isBounce = false; //是否反弹
	            this._isRollX = false; //是否为X轴滑动
	            this._isRollY = false; //是否为Y轴滑动
	            this._isTap = true; //点击了屏幕
	            this._isInvalid = false; //无效的触发

	            this._start = {
	                pageX: point.pageX,
	                pageY: point.pageY,
	                time: getDate()
	            };
	        }

	        /**
	         * 移动
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onMove',
	        value: function _onMove(e) {
	            var _this2 = this;

	            //如果停止翻页
	            //或者没有点击
	            //或是Y轴滑动
	            //或者是阻止滑动
	            if (this._fliplock || !this._isTap || this._isRollY || this._preventSwipe) return;

	            this._isMoving = true;

	            var point = (0, _depend.compatibilityEvent)(e);
	            var deltaX = point.pageX - this._start.pageX;
	            var deltaY = point.pageY - this._start.pageY;
	            var absDeltaX = Math.abs(deltaX);
	            var absDeltaY = Math.abs(deltaY);

	            //=========Y轴滑动=========
	            if (!this._isRollY) {
	                //Y>X => 为Y轴滑动
	                if (absDeltaY > absDeltaX) {
	                    this._isRollY = true;
	                    return;
	                }
	            }

	            //=========X轴滑动=========

	            //前尾是否允许反弹
	            if (!this.options.borderBounce) {
	                if (this._isBounce = this._borderBounce(deltaX)) return;
	            }

	            //滑动方向
	            //left => 负
	            //rigth => 正
	            this._deltaX = deltaX / (!this._hindex && deltaX > 0 // 在首页
	            || this._hindex == this.pagetotal - 1 // 尾页
	            && deltaX < 0 // 中间
	            ? absDeltaX / this._viewWidth + 1 : 1);

	            if (!this._isRollX && this._deltaX) {
	                this._isRollX = true;
	            }

	            this.direction = this._deltaX > 0 ? 'prev' : 'next';

	            //减少抖动
	            //算一次有效的滑动
	            //移动距离必须20px才开始移动
	            var xWait = 20;
	            if (absDeltaX <= xWait) return;

	            //需要叠加排除值
	            if (this._deltaX > 0) {
	                xWait = -xWait;
	            }

	            //是否无效函数
	            //如果无效，end方法抛弃掉
	            //必须是同步方法：
	            //动画不能在回调中更改状态，因为翻页动作可能在动画没有结束之前，所以会导致翻页卡住
	            var setSwipeInvalid = function setSwipeInvalid() {
	                _this2._isInvalid = true;
	            };

	            this._distributeMove({
	                pageIndex: this._hindex,
	                distance: this._deltaX + xWait,
	                speed: 0,
	                direction: this.direction,
	                action: 'flipMove',
	                setSwipeInvalid: setSwipeInvalid
	            });
	        }

	        /**
	         * 松手
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onEnd',
	        value: function _onEnd(e) {

	            //停止滑动
	            //或者多点触发
	            //或者是边界
	            //或者是停止翻页
	            if (this._fliplock || this._isBounce || this._preventSwipe || this._hasMultipleTouches(e)) {
	                return;
	            }

	            this._isTap = this._isMoving = false;

	            //点击
	            if (!this._isRollX && !this._isRollY) {
	                var isReturn = false;
	                this.$emit('onTap', this._hindex, function () {
	                    return isReturn = true;
	                }, e);
	                if (isReturn) return;
	            }

	            //如果是左右滑动
	            if (this._isRollX) {

	                var duration = getDate() - this._start.time;
	                var deltaX = Math.abs(this._deltaX);

	                //如果是首尾
	                //如果是liner模式排除
	                var isPastBounds = this.options.linear ? false : !this._hindex && this._deltaX > 0 || this._hindex == this.pagetotal - 1 && this._deltaX < 0;

	                //_slideTo的最低值要求
	                //1 fast: time < 200 && x >30
	                //2 common: x > veiwWidth/6
	                var isValidSlide = duration < 200 && deltaX > 30 || deltaX > this._viewWidth / 6;

	                //如果是无效的动作，则不相应
	                //还原默认设置
	                //move的情况会引起
	                //mini功能，合并翻页时事件
	                if (this._isInvalid) {
	                    var hasSwipe = duration < 200 && deltaX > this._viewWidth / 10;
	                    if (hasSwipe) {
	                        this._distributeMove({
	                            pageIndex: this._hindex,
	                            direction: this._deltaX > 0 ? 'prev' : 'next',
	                            action: 'swipe'
	                        });
	                    }
	                    this._restore();
	                    return;
	                } else {
	                    //跟随移动
	                    if (isValidSlide && !isPastBounds) {
	                        //true:right, false:left
	                        this._slideTo(this._deltaX < 0 ? 'next' : 'prev');
	                    } else {
	                        //反弹
	                        this._setRebound(this._hindex, this._deltaX > 0 ? 'prev' : 'next');
	                    }
	                }
	            }
	        }

	        /**
	         * 前尾边界反弹判断
	         * @param  {[type]} deltaX [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_borderBounce',
	        value: function _borderBounce(deltaX) {
	            //首页,并且是左滑动
	            if (this._hindex === 0 && deltaX > 0) {
	                return true;
	                //尾页
	            } else if (this._hindex === this.pagetotal - 1 && deltaX < 0) {
	                return true;
	            }
	        }

	        /**
	         * 设置反弹
	         */

	    }, {
	        key: '_setRebound',
	        value: function _setRebound(pageIndex, direction) {
	            this._distributeMove({
	                'pageIndex': pageIndex,
	                'direction': direction,
	                'distance': 0,
	                'speed': 300,
	                'action': 'flipRebound'
	            });
	        }

	        /**
	         * 处理松手后滑动
	         * pageIndex 页面
	         * distance  移动距离
	         * speed     时间
	         * viewTag   可使区标记
	         * follow    是否为跟随滑动
	         * @return {[type]} [description]
	         * pageIndex: 0, distance: -2, speed: 0, direction: "next", action: "flipMove"
	         */

	    }, {
	        key: '_distributeMove',
	        value: function _distributeMove(data) {
	            var pointer = this.pagePointer;
	            data.leftIndex = pointer.leftIndex;
	            data.rightIndex = pointer.rightIndex;
	            this.$emit('onMove', data);
	        }

	        /**
	         * 边界控制
	         * @param  {[type]} direction [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_isBorder',
	        value: function _isBorder(direction) {
	            var overflow = void 0;
	            var pointer = this.pagePointer;
	            var fillength = Object.keys(pointer).length;

	            switch (direction) {
	                case 'prev':
	                    //前翻页
	                    overflow = pointer.currIndex === 0 && fillength === 2 ? true : false;
	                    break;
	                case 'next':
	                    //后翻页
	                    overflow = pointer.currIndex === this.pagetotal - 1 && fillength === 2 ? true : false;
	                    break;
	            }

	            return overflow;
	        }

	        /**
	         * 复位速率
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_resetRate',
	        value: function _resetRate() {
	            this._speedRate = this._originalRate;
	            this._isQuickTurn = false;
	        }

	        /**
	         * 快速翻页时间计算
	         */

	    }, {
	        key: '_setRate',
	        value: function _setRate() {
	            this._speedRate = 50 / this._viewWidth;
	            this._isQuickTurn = true;
	        }

	        /**
	         * 判断是否快速翻页
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_quickTurn',
	        value: function _quickTurn() {
	            var startDate = getDate();
	            if (this._preTapTime) {
	                if (startDate - this._preTapTime < SPEED) {
	                    this._setRate();
	                }
	            }
	            this._preTapTime = getDate();
	        }

	        /**
	         * 翻页加锁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_lockSwipe',
	        value: function _lockSwipe() {
	            this._fliplock = true;
	        }

	        /**
	         * 修正页面索引
	         */

	    }, {
	        key: '_fixHindex',
	        value: function _fixHindex(currIndex) {
	            this._hindex = currIndex; //翻页索引
	        }

	        /**
	         * 更新页码标示
	         */

	    }, {
	        key: '_updataPointer',
	        value: function _updataPointer(leftIndex, currIndex, rightIndex) {
	            if (arguments.length === 3) {
	                this.pagePointer = {
	                    'leftIndex': leftIndex,
	                    'currIndex': currIndex,
	                    'rightIndex': rightIndex
	                };
	                return;
	            }
	            if (arguments.length === 1) {
	                var data = leftIndex;
	                var viewFlip = data.viewFlip;
	                this._fixHindex(data.targetIndex);
	                if (viewFlip.length === 3) {
	                    this._updataPointer(viewFlip[0], viewFlip[1], viewFlip[2]);
	                }
	                if (viewFlip.length === 2) {
	                    if (viewFlip[0] === 0) {
	                        //首页
	                        this.pagePointer.rightIndex = viewFlip[1];
	                        this.pagePointer.currIndex = viewFlip[0];
	                        delete this.pagePointer.leftIndex;
	                    } else {
	                        //尾页
	                        this.pagePointer.leftIndex = viewFlip[0];
	                        this.pagePointer.currIndex = viewFlip[1];
	                        delete this.pagePointer.rightIndex;
	                    }
	                }
	                return;
	            }
	        }

	        /**
	         * 增加索引的动作
	         * 修正页码指示
	         */

	    }, {
	        key: '_updateActionPointer',
	        value: function _updateActionPointer(pointer) {

	            //获取动作索引
	            // createPointer
	            // destroyPointer
	            var actionPointer = (0, _depend.getActionPointer)(this.direction, pointer.leftIndex, pointer.rightIndex);

	            //需要创建的页面
	            var createPointer = actionPointer.createPointer;

	            //需要停止动作的页面索引
	            var stopPointer = pointer.currIndex;

	            switch (this.direction) {
	                case 'prev':
	                    if (-1 < createPointer) {
	                        //首页情况
	                        this._updataPointer(createPointer, pointer.leftIndex, pointer.currIndex);
	                    }
	                    if (-1 === createPointer) {
	                        this.pagePointer.rightIndex = pointer.currIndex;
	                        this.pagePointer.currIndex = pointer.leftIndex;
	                        delete this.pagePointer.leftIndex;
	                    }
	                    break;
	                case 'next':
	                    if (this.pagetotal > createPointer) {
	                        this._updataPointer(pointer.currIndex, pointer.rightIndex, createPointer);
	                    }
	                    if (this.pagetotal === createPointer) {
	                        //如果是尾页
	                        this.pagePointer.leftIndex = pointer.currIndex;
	                        this.pagePointer.currIndex = pointer.rightIndex;
	                        delete this.pagePointer.rightIndex;
	                    }
	                    break;
	            }

	            //更新页面索引标识
	            this.pagePointer.createPointer = createPointer;
	            this.pagePointer.destroyPointer = actionPointer.destroyPointer;
	            this.pagePointer.stopPointer = stopPointer;
	        }

	        /**
	         * 滑动到上下页面
	         * direction
	         *     "perv" / "next"
	         * @param  {[type]} direction [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_slideTo',
	        value: function _slideTo(direction) {
	            var _this3 = this;

	            //如果在忙碌状态,如果翻页还没完毕
	            if (this._fliplock) {
	                return;
	            }

	            //前后边界
	            if (!this.options.linear) {
	                if (this._isBorder(direction)) return;
	            }

	            this._lockSwipe();
	            this.direction = direction;
	            this._quickTurn();

	            /**
	             * 计算滑动速度
	             * @return {[type]} [description]
	             */
	            var calculatespeed = function calculatespeed() {
	                return (_this3._viewWidth - Math.abs(_this3._deltaX)) * _this3._speedRate || _this3._pageTime;
	            };

	            this._distributeMove({
	                'pageIndex': this._hindex,
	                'speed': calculatespeed(),
	                'distance': 0,
	                'direction': this.direction,
	                'action': 'flipOver'
	            });

	            setTimeout(function () {
	                //更新this.pagePointer索引
	                //增加处理标记
	                _this3._updateActionPointer(_this3.pagePointer);
	                _this3.$emit('onUpSlider', _this3.pagePointer);
	                _this3._fixHindex(_this3.pagePointer.currIndex);
	            });
	        }

	        /**
	         * 动画结束后处理
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onAnimComplete',
	        value: function _onAnimComplete(e) {
	            var node = e.target;
	            var pageType = node.getAttribute('data-pageType');
	            var view = node.getAttribute('data-view'); //操作的可视窗口
	            var linearView = node.getAttribute(LINEARTAG); //流式布局

	            //去掉动画时间
	            if (node) {
	                node.style[transitionDuration] = '';
	            }

	            //流式布局处理
	            if (linearView && !view) {
	                this._distributed(node, view);
	                return;
	            }

	            //反弹效果,未翻页
	            if (!view) {
	                if (!pageType) {
	                    //只针对母板处理
	                    this.$emit('onMasterMove', this._hindex, node);
	                }
	                return;
	            }

	            this._distributed(node, view);
	        }
	    }, {
	        key: '_distributed',
	        value: function _distributed() {
	            var _this4 = this;

	            this._restore.apply(this, arguments);

	            //延长获取更pagePointer的更新值
	            setTimeout(function () {
	                _this4.$emit('onComplete', _this4.direction, _this4.pagePointer, _this4._unlockSwipe.bind(_this4), _this4._isQuickTurn);
	            }, 50);
	        }

	        /**
	         * 还原设置
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_restore',
	        value: function _restore(node, view) {

	            this._isMoving = false;

	            //针对拖拽翻页阻止
	            this._preventSwipe = true;
	            this._isTap = false;
	            //恢复速率
	            this._resetRate();
	            view && node.removeAttribute('data-view', 'false');
	        }

	        /**
	         * 解锁翻页
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_unlockSwipe',
	        value: function _unlockSwipe() {
	            this._fliplock = false;
	        }

	        /**
	         * 销毁事件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_off',
	        value: function _off() {
	            (0, _dom.$$off)(this.container, {
	                start: this,
	                move: this,
	                end: this,
	                cancel: this,
	                transitionend: this,
	                out: this
	            });
	        }
	    }]);

	    return Swipe;
	}(_index2.default);

	exports.default = Swipe;


	(0, _api2.default)(Swipe);

/***/ },
/* 44 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * 当监听的节点内容发生变化时,触发指定的回调
	 * @param opts {
	 *   container:父容器,dom对象或jQuery对象
	 *   content  :要加入父容器的内容,字符串或jQuery对象
	 *   position :内容插入父容器的位置,'first' 表示在前加入,默认在末尾
	 *   delay    :延时,默认0
	 *   }
	 * @version  1.02
	 * @author [author] bjtqti
	 * @return {[type]} [description]
	 */

	var DOC = document;
	var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

	var implementation = DOC.implementation.hasFeature("MutationEvents", "2.0");

	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	var _nextTick = function () {
	    var callbacks = [];
	    var pending = false;
	    var timerFunc;

	    function nextTickHandler() {
	        pending = false;
	        var copies = callbacks.slice(0);
	        callbacks = [];
	        for (var i = 0; i < copies.length; i++) {
	            copies[i]();
	        }
	    }

	    if (typeof MutationObserver !== 'undefined' && !Xut.plat.hasMutationObserverBug) {
	        var counter = 1;
	        var observer = new MutationObserver(nextTickHandler);
	        var textNode = document.createTextNode(counter);
	        observer.observe(textNode, {
	            characterData: true
	        });
	        timerFunc = function timerFunc() {
	            counter = (counter + 1) % 2;
	            textNode.data = counter;
	        };
	    } else {
	        // webpack attempts to inject a shim for setImmediate
	        // if it is used as a global, so we have to work around that to
	        // avoid bundling unnecessary code.
	        var context = Xut.plat.isBrowser ? window : typeof global !== 'undefined' ? global : {};
	        timerFunc = context.setImmediate || setTimeout;
	    }
	    return function (cb, ctx) {
	        var func = ctx ? function () {
	            cb.call(ctx);
	        } : cb;
	        callbacks.push(func);
	        if (pending) return;
	        pending = true;
	        timerFunc(nextTickHandler, 0);
	    };
	}();

	var nextTick = function nextTick() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        container = _ref.container,
	        content = _ref.content,
	        position = _ref.position,
	        _ref$delay = _ref.delay,
	        delay = _ref$delay === undefined ? 0 : _ref$delay;

	    var callback = arguments[1];
	    var context = arguments[2];


	    //如果只提供一个回到函数
	    if (arguments.length === 1 && typeof arguments[0] === 'function') {
	        callback = arguments[0];
	        if (typeof callback === 'function') {
	            return _nextTick(callback);
	        }
	        console.log('nextTick: 参数提供错误');
	        return;
	    }

	    if (!container || !content) {
	        return;
	    }

	    //检查容器---$(container) 转为dom对象
	    if (container instanceof $) {
	        container = container[0];
	    }

	    if (container.nodeType !== 1) {
	        console.log('nextTick: container must be HTMLLIElement ');
	        return;
	    }

	    var animatId = 'T' + (Math.random() * 10000 << 1);
	    var tick = DOC.createElement('input');

	    //标记任务
	    tick.setAttribute('value', animatId);

	    //检查内容
	    if (typeof content === 'string') {
	        var temp = $(content);
	        if (!temp[0]) {
	            //纯文本内容
	            temp = DOC.createTextNode(content);
	            temp = $(temp);
	        }
	        content = temp;
	        temp = null;
	    }

	    /**
	     * 完成任务后处理&Observer
	     * @return {[type]} [description]
	     */
	    var _completeTask = function _completeTask() {
	        container.removeChild(tick);
	        callback.call(context);
	        container = null;
	        tick = null;
	        context = null;
	    };

	    /**
	     * 将内容加入父容器
	     * @return {[type]} [description]
	     */
	    var _appendChild = function _appendChild() {
	        //拼接内容
	        var frag = DOC.createDocumentFragment();
	        var len = content.length;
	        for (var i = 0; i < len; i++) {
	            frag.appendChild(content[i]);
	        }
	        frag.appendChild(tick);

	        //判断插入的位置
	        if (position === 'first') {
	            container.insertBefore(frag, container.firstChild);
	        } else {
	            container.appendChild(frag);
	        }

	        frag = null;

	        //触发变动事件
	        tick.setAttribute('value', animatId);
	    };

	    if (MutationObserver) {
	        var observer = new MutationObserver(function (mutations) {
	            mutations.forEach(function (record) {
	                if (record.oldValue === animatId) {
	                    _completeTask();
	                    observer = null;
	                }
	            });
	        });

	        //设置要监听的属性
	        observer.observe(tick, {
	            attributes: true,
	            //childList: true,
	            attributeOldValue: true,
	            attributeFilter: ["value"] //只监听value属性,提高性能
	        });

	        _appendChild();
	    } else {

	        //检测是否支持DOM变动事件
	        if (implementation) {
	            (function () {

	                /**
	                 * 完成任务后处理&Event
	                 * @param  {[type]} event [description]
	                 * @return {[type]}       [description]
	                 */
	                var _finishTask = function _finishTask(event) {
	                    if (event.target.value === animatId) {
	                        //container.removeEventListener('DOMNodeRemoved',_finishTask,false);
	                        container.removeEventListener('DOMNodeInserted', _finishTask, false);
	                        callback.call(context);
	                    }
	                };

	                //container.addEventListener('DOMNodeRemoved',_finishTask,false);
	                container.addEventListener('DOMNodeInserted', _finishTask, false);
	                _appendChild();
	                container.removeChild(tick);
	            })();
	        } else {
	            //歉容Android2.xx处理
	            _appendChild();
	            setTimeout(function () {
	                _completeTask();
	            }, delay);
	        }
	    }
	};

	Xut.nextTick = nextTick;

	exports.default = nextTick;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 45 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 加入数组处理
	 */
	var Stack = function () {
	    function Stack() {
	        _classCallCheck(this, Stack);

	        this._cache = [];
	    }

	    /**
	     * 加入首部
	     * @return {[type]} [description]
	     */


	    _createClass(Stack, [{
	        key: "shift",
	        value: function shift(fn) {
	            this._cache.unshift(fn);
	        }

	        /**
	         * 加入尾部
	         * @param  {Function} fn [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: "push",
	        value: function push(fn) {
	            this._cache.push(fn);
	        }

	        /**
	         * 从头部取出全部执行
	         * @return {[type]} [description]
	         */

	    }, {
	        key: "shiftAll",
	        value: function shiftAll() {
	            if (this._cache.length) {
	                var fn = void 0;
	                while (fn = this._cache.shift()) {
	                    fn.apply(null, arguments);
	                }
	            }
	            return this;
	        }

	        /**
	         * 尾部取出执行
	         * @return {[type]} [description]
	         */

	    }, {
	        key: "popAll",
	        value: function popAll() {
	            if (this._cache.length) {
	                var fn = void 0;
	                while (fn = this._cache.pop()) {
	                    fn.apply(null, arguments);
	                }
	            }
	            return this;
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            this._cache = null;
	        }
	    }]);

	    return Stack;
	}();

	exports.default = Stack;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = getFlipDistance;

	var _index = __webpack_require__(1);

	var _lang = __webpack_require__(3);

	/**
	 * 下一页是否为flow页面
	 * 要根据这个判断来处理翻页的距离
	 * @return {[type]} [description]
	 */
	var checkFlows = function checkFlows(pageIndex) {
	    var pageObj = Xut.Presentation.GetPageObj(pageIndex);
	    return pageObj && pageObj.isFlows;
	};

	/**
	 * 制作钩子收集器
	 * @return {[type]} [description]
	 */
	var makeGather = function makeGather() {
	    var _gather = (0, _lang.hash)();
	    _gather.$$checkFlows = checkFlows;
	    return _gather;
	};

	/**
	 * 动态计算翻页距离
	 * @return {[type]} [description]
	 */
	function getFlipDistance() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        action = _ref.action,
	        distance = _ref.distance,
	        direction = _ref.direction,
	        leftIndex = _ref.leftIndex,
	        pageIndex = _ref.pageIndex,
	        rightIndex = _ref.rightIndex;

	    var hooks = arguments[1];


	    //区域尺寸
	    var veiwWidth = _index.config.viewSize.width;

	    var offset = {
	        left: undefined,
	        middle: undefined,
	        right: undefined,
	        //当前视图页面
	        //用来处理页面回调
	        view: undefined
	    };

	    /**
	     * 混入钩子
	     * @return {[type]} [description]
	     */
	    var mixHooks = function mixHooks(hook) {
	        if (hook) {
	            var _receiver = makeGather();
	            _receiver.$$leftIndex = leftIndex;
	            _receiver.$$middleIndex = pageIndex;
	            _receiver.$$rightIndex = rightIndex;
	            _receiver.$$right = offset.right;
	            _receiver.$$left = offset.left;
	            hook(_receiver);
	            _.each(_receiver, function (value, key) {
	                offset[key] = value;
	            });
	        }
	    };

	    /**
	     * 滑动
	     * @param  {[type]} action [description]
	     * @return {[type]}        [description]
	     */
	    if (action === 'flipMove') {
	        offset.left = distance - veiwWidth;
	        offset.middle = distance;
	        offset.right = distance + veiwWidth;
	        var flipMove = hooks && hooks.flipMove;
	        if (flipMove) {
	            if (direction === 'prev') {
	                mixHooks(flipMove.left);
	            }
	            if (direction === 'next') {
	                mixHooks(flipMove.right);
	            }
	        }
	    }

	    /**
	     * 反弹
	     * @param  {[type]} action [description]
	     * @return {[type]}        [description]
	     */
	    if (action === 'flipRebound') {
	        offset.left = -veiwWidth;
	        offset.middle = distance;
	        offset.right = veiwWidth;
	        var flipRebound = hooks && hooks.flipRebound;
	        if (flipRebound) {
	            if (direction === 'prev') {
	                mixHooks(flipRebound.left);
	            }
	            if (direction === 'next') {
	                mixHooks(flipRebound.right);
	            }
	        }
	    }

	    /**
	     * 翻页
	     * @param  {[type]} action [description]
	     * @return {[type]}        [description]
	     */
	    if (action === 'flipOver') {

	        var flipOver = hooks && hooks.flipOver;

	        /**
	         * 前翻
	         */
	        if (direction === 'prev') {
	            offset.left = 0;
	            offset.middle = veiwWidth;
	            offset.right = 2 * veiwWidth;
	            flipOver && mixHooks(flipOver.left);
	            offset.view = offset.left;
	        }

	        /**
	         * 后翻
	         */
	        if (direction === 'next') {
	            offset.left = -2 * veiwWidth;
	            offset.middle = -veiwWidth;
	            offset.right = distance;
	            flipOver && mixHooks(flipOver.right);
	            offset.view = offset.right;
	        }
	    }

	    return [offset.left, offset.middle, offset.right, offset.view];
	}

/***/ },
/* 47 */
/***/ function(module, exports) {

	var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['CloseCurlyDoubleQuote', [8221]], ['CloseCurlyQuote', [8217]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

	var alphaIndex = {};
	var charIndex = {};

	createIndexes(alphaIndex, charIndex);

	/**
	 * @constructor
	 */
	function Html5Entities() {}

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.decode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
	        var chr;
	        if (entity.charAt(0) === "#") {
	            var code = entity.charAt(1) === 'x' ?
	                parseInt(entity.substr(2).toLowerCase(), 16) :
	                parseInt(entity.substr(1));

	            if (!(isNaN(code) || code < -32768 || code > 65535)) {
	                chr = String.fromCharCode(code);
	            }
	        } else {
	            chr = alphaIndex[entity];
	        }
	        return chr || s;
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.decode = function(str) {
	    return new Html5Entities().decode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encode = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var charInfo = charIndex[str.charCodeAt(i)];
	        if (charInfo) {
	            var alpha = charInfo[str.charCodeAt(i + 1)];
	            if (alpha) {
	                i++;
	            } else {
	                alpha = charInfo[''];
	            }
	            if (alpha) {
	                result += "&" + alpha + ";";
	                i++;
	                continue;
	            }
	        }
	        result += str.charAt(i);
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encode = function(str) {
	    return new Html5Entities().encode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encodeNonUTF = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        var charInfo = charIndex[c];
	        if (charInfo) {
	            var alpha = charInfo[str.charCodeAt(i + 1)];
	            if (alpha) {
	                i++;
	            } else {
	                alpha = charInfo[''];
	            }
	            if (alpha) {
	                result += "&" + alpha + ";";
	                i++;
	                continue;
	            }
	        }
	        if (c < 32 || c > 126) {
	            result += '&#' + c + ';';
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encodeNonUTF = function(str) {
	    return new Html5Entities().encodeNonUTF(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encodeNonASCII = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encodeNonASCII = function(str) {
	    return new Html5Entities().encodeNonASCII(str);
	 };

	/**
	 * @param {Object} alphaIndex Passed by reference.
	 * @param {Object} charIndex Passed by reference.
	 */
	function createIndexes(alphaIndex, charIndex) {
	    var i = ENTITIES.length;
	    var _results = [];
	    while (i--) {
	        var e = ENTITIES[i];
	        var alpha = e[0];
	        var chars = e[1];
	        var chr = chars[0];
	        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
	        var charInfo;
	        if (addChar) {
	            charInfo = charIndex[chr] = charIndex[chr] || {};
	        }
	        if (chars[1]) {
	            var chr2 = chars[1];
	            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
	            _results.push(addChar && (charInfo[chr2] = alpha));
	        } else {
	            alphaIndex[alpha] = String.fromCharCode(chr);
	            _results.push(addChar && (charInfo[''] = alpha));
	        }
	    }
	}

	module.exports = Html5Entities;


/***/ },
/* 48 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(175);
	var hotClient = __webpack_require__(178);

	hotClient.subscribe(function (event) {
	    if (event.action === 'reload') {
	        window.location.reload();
	    }
	});

/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * by 2016.6.30
	 * judgment is backstage run
	 * Take the opposite judgment
	 * @return {[type]} [description]
	 */
	var allowNext = function allowNext() {
	    if (window.MMXCONFIG) {
	        return function () {
	            return !(window.MMXCONFIG.back || Xut.Application.IsBackStage());
	        };
	    } else {
	        return function () {
	            return !false;
	        };
	    }
	};

	exports.default = allowNext();

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.$$autoRun = $$autoRun;

	var _access = __webpack_require__(13);

	var _access2 = _interopRequireDefault(_access);

	var _allow = __webpack_require__(50);

	var _allow2 = _interopRequireDefault(_allow);

	var _index = __webpack_require__(22);

	var _index2 = _interopRequireDefault(_index);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var noop = function noop() {};

	/**
	 * 运行自动的content对象
	 * 延时500毫秒执行
	 * @return {[type]} [description]
	 */
	/**
	 * 自动触发控制
	 * @return {[type]} [description]
	 */

	var autoContents = function autoContents(contentObjs, taskAnimCallback) {

	    var markComplete = function () {
	        var completeStatistics = contentObjs.length; //动画完成统计
	        return function () {
	            if (completeStatistics === 1) {
	                taskAnimCallback && taskAnimCallback();
	                markComplete = null;
	            }
	            completeStatistics--;
	        };
	    }();

	    _.each(contentObjs, function (obj, index) {
	        if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
	            //同一个对象类型
	            //直接调用对象接口
	            obj.autoPlay(markComplete);
	        } else {
	            markComplete();
	        }
	    });
	};

	/**
	 * 运行自动的静态类型
	 * @return {[type]} [description]
	 */
	var autoComponents = function autoComponents(pageObj, pageIndex, autoData, pageType) {

	    var chapterId = pageObj.baseGetPageId(pageIndex);
	    var dir = void 0;

	    if (pageIndex === undefined) {
	        pageIndex = Xut.Presentation.GetPageIndex();
	    }

	    _.each(autoData, function (data, index) {
	        dir = _index2.default[data.actType];
	        //零件类型的接口调用不一致
	        //这里需要转接口处理
	        if (dir && dir.autoPlay) {
	            dir.autoPlay({
	                'id': data.id,
	                'pageType': pageType,
	                'rootNode': pageObj.getContainsNode(),
	                'chapterId': chapterId,
	                'category': data.category,
	                'autoPlay': data.autoPlay,
	                'pageIndex': pageIndex
	            });
	        }
	    });
	};

	/**
	 * 自动动作
	 * @param  {[type]} pageObj          [description]
	 * @param  {[type]} pageIndex        [description]
	 * @param  {[type]} taskAnimCallback [description]
	 * @return {[type]}                  [description]
	 */
	function $$autoRun(pageObj, pageIndex, taskAnimCallback) {

	    /**
	     * 编译IBOOKSCONFIG的时候过滤自动运行的调用
	     * @return {[type]}              [description]
	     */
	    if (Xut.IBooks.compileMode()) {
	        return;
	    }

	    //When the home button by invoking
	    //Does not perform automatic animation
	    //fix 2016.6.29
	    // originalApp
	    // window.miaomiaoxue.back = 1;
	    // activateApp
	    // window.miaomiaoxue.back = 0;
	    if (!(0, _allow2.default)()) {
	        taskAnimCallback();
	        return;
	    }

	    //pageType
	    //用于区别触发类型
	    //页面还是母版
	    (0, _access2.default)(pageObj, function (pageObj, contentObjs, componentObjs, pageType) {

	        //如果是母版对象，一次生命周期种只激活一次
	        if (pageObj.pageType === 'master') {
	            if (pageObj.onceMaster) {
	                return;
	            }
	            pageObj.onceMaster = true;
	        }

	        taskAnimCallback = taskAnimCallback || noop;

	        var autoData = pageObj.baseAutoRun();
	        if (autoData) {
	            autoComponents(pageObj, pageIndex, autoData, pageType);
	        }

	        if (contentObjs) {
	            autoContents(contentObjs, taskAnimCallback);
	        } else {
	            taskAnimCallback(); //无动画
	        }

	        // console.log('debug', pageType + '层，第' + (pageIndex + 1) + '页开始,本页面Id为' + pageObj.chapterId)
	    });
	}

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.$$original = $$original;

	var _access = __webpack_require__(13);

	var _access2 = _interopRequireDefault(_access);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 优化检测
	 * @param  {Function} fn [description]
	 * @return {[type]}      [description]
	 */
	var hasOptimize = function hasOptimize(fn) {
	    if (!Xut.config.visualMode !== 1) {
	        fn && fn();
	    }
	};

	/**
	 * 翻一页处理： 翻页完毕触发
	 * 大量操作DOM结构，所以先隐藏根节点
	 * 1 删除所有widget节点
	 * 2 复位所有content节点
	 * @param  {[type]} pageObj [description]
	 * @return {[type]}         [description]
	 */
	/**
	 * 复位到初始化的状态
	 * @return {[type]} [description]
	 */

	function $$original(pageObj) {

	    (0, _access2.default)(pageObj, function (pageObj, contentObjs, componentObjs) {

	        //母版对象不还原
	        if (pageObj.pageType === 'master') return;

	        var $containsNode;

	        if ($containsNode = pageObj.getContainsNode()) {

	            //隐藏根节点
	            //display:none下刷新
	            hasOptimize(function () {
	                $containsNode.hide();
	            });

	            //content类型复位
	            contentObjs && _.each(contentObjs, function (obj) {
	                if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
	                    obj.reset && obj.reset();
	                }
	            });

	            //销毁所有widget类型的节点
	            if (componentObjs) {
	                _.each(componentObjs, function (obj) {
	                    obj && obj.destroy();
	                });
	                //销毁widget对象管理
	                pageObj.baseRemoveComponent();
	            }

	            hasOptimize(function () {
	                setTimeout(function () {
	                    $containsNode.show();
	                    $containsNode = null;
	                }, 0);
	            });
	        }
	    });
	}

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.$$stop = $$stop;

	var _access = __webpack_require__(13);

	var _access2 = _interopRequireDefault(_access);

	var _manager = __webpack_require__(6);

	var _manager2 = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 停止所有热点动作,并返回状态
	 * 1 content
	 * 2 widget
	 * 动画,视频,音频...........................
	 * 增加场景模式判断
	 *
	 *  skipAudio 是否跳过音频，不处理
	 *    true 跳过
	 *    false 不跳过
	 */

	/**
	 * 复位状态/状态控制
	 * 如果返回false证明有热点
	 * 第一次只能关闭热点不能退出页面
	 * @param  {[type]} pageObj [description]
	 * @return {[type]}         [description]
	 */
	function $$stop() {

	    //清理音频
	    (0, _manager.clearAudio)();

	    //清理视频
	    (0, _manager2.clearVideo)();

	    //停止热点
	    return (0, _access2.default)(function (pageObj, contentObjs, componentObjs) {

	        //如果返回值是false,则是算热点处理行为
	        var falg = false;

	        //content类型
	        contentObjs && _.each(contentObjs, function (obj) {
	            if (obj.stop && obj.stop()) {
	                falg = true;
	            }
	        });

	        //零件类型
	        componentObjs && _.each(componentObjs, function (obj) {
	            if (obj.stop && obj.stop()) {
	                falg = true;
	            }
	        });

	        return falg;
	    });
	} /**
	   * 停止动作
	   * 给全局stop接口使用
	   * 与suspend的区别就是，这个全除了suspend的处理，还包括零件的暂停
	   * @return {[type]} [description]
	   */

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.$$suspend = $$suspend;

	var _access = __webpack_require__(13);

	var _access2 = _interopRequireDefault(_access);

	var _manager = __webpack_require__(6);

	var _manager2 = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 翻页停止content动作
	 * 翻页时,暂停滑动页面的所有热点动作
	 *
	 * 如果传递了allHandle 停止所有的视频
	 * allHandle 给接口Xut.Application.Original() 使用
	 *
	 * @param  {[type]} pageObj [description]
	 * @param  {[type]} pageId  [description]
	 * @param  {[type]} all     [description]
	 * @return {[type]}         [description]
	 */
	function $$suspend(pageObj, pageId, allHandle) {

	    //零件对象翻页就直接销毁了
	    //无需暂时
	    //这里只处理音频 + content类型
	    (0, _access2.default)(pageObj, function (pageObj, contentObjs) {

	        //多媒体处理
	        if (pageId !== undefined) {
	            //离开页面销毁视频
	            (0, _manager2.removeVideo)(pageId);
	            //翻页停止母板音频
	            if (pageObj.pageType === 'master') {
	                (0, _manager.hangUpAudio)();
	            }
	        }

	        //content类型
	        contentObjs && _.each(contentObjs, function (obj) {
	            obj.stop && obj.stop();
	        });

	        //如果是外部调用接口
	        //销毁视频
	        //销毁所有的音频
	        if (allHandle) {
	            (0, _manager2.hangUpVideo)();
	            (0, _manager.hangUpAudio)();
	        }
	    });
	} /**
	   * 暂停控制
	   * @return {[type]} [description]
	   */

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.$$trigger = $$trigger;

	var _index = __webpack_require__(22);

	var _index2 = _interopRequireDefault(_index);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function $$trigger(target, attribute, rootNode, pageIndex) {

	    var key = target.id;

	    if (key) {
	        var tag = key.split('_');
	        var type = tag[0];
	        var id = tag[1];
	        var dir = _index2.default[type];

	        if (dir && dir.trigger) {

	            //获取页面类型
	            var pageType = function () {
	                if (rootNode && rootNode.id) {
	                    return (/page/.test(rootNode.id) ? 'page' : 'master'
	                    );
	                } else {
	                    return 'page';
	                }
	            }();

	            var data = {
	                "id": id,
	                "activityId": id,
	                "key": key,
	                "type": type,
	                "rootNode": rootNode,
	                "target": target,
	                "pageIndex": pageIndex,
	                'pageType': pageType
	            };

	            //如果是重复点击
	            //比如widget零件
	            var instance = void 0;
	            if (instance = Xut.Application.GetSpecifiedObject(pageType, data)) {
	                if (instance.toggle) {
	                    //如果有对应的处理方法
	                    return instance.toggle();
	                }
	            }

	            //委派新的任务
	            dir.trigger(data);
	        }
	    }
	} /**
	   * 手动触发控制
	   * @return {[type]} [description]
	   */

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Action;

	var _subdoc = __webpack_require__(57);

	var _subdoc2 = _interopRequireDefault(_subdoc);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 废弃子文档
	 * @param  {[type]} results [description]
	 * @return {[type]}         [description]
	 */
	var _init = function _init(results) {

	    var para1 = results.para1; //跳转参数
	    var dbId = results._id;
	    var actionType = parseInt(results.actionType);

	    //跳转或打开本地程序
	    switch (actionType) {
	        case 0:
	            this.toPage(para1);
	            break;
	        case 1:
	            if (Xut.plat.isBrowser) return;
	            //打开插件
	            Xut.Plugin.OpenApp.openAppAction(para1, function () {}, function () {});
	            break;
	        case 2:
	            //子文档处理
	            this._loadSubdoc(para1, dbId);
	            break;
	    }
	    this.state = true;
	};

	/**
	 * 跳转页面
	 * @param  {[type]} para1 [description]
	 * @return {[type]}       [description]
	 */
	/**
	 *
	 *  动作对象
	 *      1 跳转页面
	 *      2 打开系统程序
	 *      3 加载子文档
	 *
	 */

	var toPage = function toPage(para1) {
	    para1 = JSON.parse(para1);
	    if (para1.seasonId) {
	        Xut.View.GotoSlide(para1.seasonId, para1.chapterId);
	    } else {
	        //向下兼容
	        Xut.View.GotoSlide(para1);
	    }
	};

	function Action(data) {
	    var id = parseInt(data.id);
	    var results = Xut.data.query('Action', id, 'activityId');
	    var para1 = results.para1; //跳转参数
	    var actionType = parseInt(results.actionType);
	    if (actionType == 0) {
	        toPage(para1);
	    }
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (Action) {

	    /**
	     * 加载子文档
	     * @param  {[type]} path [description]
	     * @param  {[type]} dbId [description]
	     * @return {[type]}      [description]
	     */
	    Action.prototype._loadSubdoc = function (path, dbId) {
	        var self = this,
	            wapper;

	        //配置子文档加载路径
	        window.XXTSUbDOC = {
	            'path': path,
	            'dbId': dbId
	        };

	        this.subPath = path;

	        //构建子文档的容器
	        wapper = this.$wapper = this._createWapper();

	        Xut.nextTick({
	            'container': $(this.rootNode),
	            'content': wapper
	        }, function () {
	            self._destroyCache();
	        });
	    };

	    /**
	     * iframe加载完毕
	     * @return {[type]} [description]
	     */
	    Action.prototype.iframeComplete = function () {
	        var self = this;
	        //关闭事件
	        Xut.one('subdoc:dropApp', function () {
	            self._destroyCache('iframe', self.iframe[0].contentWindow);
	        });
	        //隐藏全局工具栏
	        Xut.View.HideToolBar();
	        Xut.isRunSubDoc = true;
	        self.$wapper.css({
	            'opacity': '1'
	        });
	    };

	    /**
	     * 获取iframe颞部window上下文
	     * @param  {[type]} contentWindow [description]
	     * @return {[type]}               [description]
	     */
	    Action.prototype._destroyCache = function (contentWindow) {
	        var self = this,
	            iframe;
	        if (contentWindow) {
	            iframe = true;
	        } else {
	            contentWindow = window;
	        }

	        function clear() {
	            Xut.View.ShowToolBar();
	            self.$wapper.remove();
	            self.$wapper = null;
	            self.iframe = null;
	            self.rootNode = null;
	            Xut.isRunSubDoc = false;
	        }

	        try {

	            if (iframe) {
	                //子文档操作
	                if ((0, _index.$$stop)()) {} else {
	                    clear();
	                }
	            } else {
	                //父级操作
	                (0, _index.$$stop)();
	            }
	        } catch (err) {
	            clear();
	        }
	    };

	    Action.prototype._createWapper = function () {
	        var zIndex, str, dom, ifr;
	        //层级设定
	        if (this.zIndex === 0) {
	            zIndex = this.zIndex;
	        } else {
	            zIndex = this.zIndex || Xut.zIndexlevel();
	        }
	        this.zIndex = zIndex;
	        str = '<div id="Subdoc_{0}" style="z-index:{1};width:{2}px;height:{3}px;top:{4}px;left:{5}px;position:absolute;opacity:0" >' + '</div>';
	        dom = String.format(str, this.id, zIndex, _index2.config.viewSize.width, _index2.config.viewSize.height, 0, 0);
	        ifr = this.iframe = this._createIframe();
	        return $(dom).append(ifr);
	    };

	    /**
	     * 加载iframe
	     * @return {[type]} [description]
	     */
	    Action.prototype._createIframe = function () {
	        var me = this,
	            path = 'content/subdoc/' + this.subPath + '/index.html?xxtParaIn=' + this.key,
	            ifr = document.createElement('iframe');
	        ifr.id = 'iframe_' + this.id;
	        ifr.src = path;
	        ifr.style.width = '100%';
	        ifr.style.height = '100%';
	        ifr.sandbox = "allow-scripts allow-same-origin";
	        ifr.frameborder = 0;
	        if (ifr.attachEvent) {
	            ifr.attachEvent('onload', function () {
	                me.iframeComplete();
	            });
	        } else {
	            ifr.onload = function () {
	                me.iframeComplete();
	            };
	        }
	        return $(ifr);
	    };
	};

	var _index = __webpack_require__(8);

	var _index2 = __webpack_require__(1);

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.BookMark = undefined;

	var _dom = __webpack_require__(5);

	var _stroage = __webpack_require__(17);

	/**
	 * 书签栏
	 * 加入这个书签功能后，可以让用户自由选择哪页是需要保存记录的
	 * @param options object
	 * @example {parent:页面容器,pageId:chapterId,seasonId:seasionId}
	 */

	var icons = {
	    hide: 'images/icons/arrowDown.svg'
	},
	    sLineHeiht = parseInt($('body').css('font-size')) || 16,
	    //行高
	BOOKCACHE; //书签缓存

	function BookMark(options) {
	    this.parent = options.parent;
	    this.pageId = options.pageId;
	    this.seasonId = options.seasonId;
	    //是否已存储
	    this.isStored = false;
	    this.init();
	}

	/**
	 * 初始化
	 * @return {[type]} [description]
	 */
	BookMark.prototype.init = function () {
	    var $bookMark = this.createBookMark(),
	        dom = this.parent[0],
	        that = this;

	    this.parent.append($bookMark);
	    this.bookMarkMenu = $bookMark.eq(0);
	    //显示书签
	    setTimeout(function () {
	        that.restore();
	    }, 20);
	    //获取历史记录
	    BOOKCACHE = this.getHistory();

	    //邦定用户事件
	    (0, _dom.$$on)(dom, {
	        end: this
	    });
	};

	/**
	 * 创建书签
	 * @return {[object]} [jquery生成的dom对象]
	 */
	BookMark.prototype.createBookMark = function () {

	    var sHeight = Xut.config.viewSize.height;

	    var height = sLineHeiht * 3,
	        // menu的高为3em
	    box = '<div class="xut-bookmark-menu" style="width:100%;height:{0}px;left:0;top:{1}px;">' + '<div class="xut-bookmark-wrap">' + '<div class="xut-bookmark-add">加入书签</div>' + '<div class="xut-bookmark-off" style="background-image:url({2})"></div>' + '<div class="xut-bookmark-view">书签记录</div>' + '</div>' + '</div>' + '<div class="xut-bookmark-list" style="display:none;width:100%;height:{3}px;">' + '<ul class="xut-bookmark-head">' + '<li class="xut-bookmark-back">返回</li>' + '<li>书签</li>' + '</ul>' + '<ul class="xut-bookmark-body"></ul>' + '</div>';
	    box = String.format(box, height, sHeight, icons.hide, sHeight);
	    this.markHeight = height;
	    return $(box);
	};

	/**
	 * 生成书签列表
	 * @return {[type]} [description]
	 */
	BookMark.prototype.createMarkList = function () {
	    var tmp,
	        seasonId,
	        pageId,
	        list = '',
	        self = this;

	    //取历史记录
	    _.each(BOOKCACHE, function (mark) {
	        tmp = mark.split('-');
	        seasonId = tmp[0];
	        pageId = tmp[1];
	        mark = self.getMarkId(seasonId, pageId);
	        list += '<li><a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">第' + pageId + '页</a><a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a></li>';
	    });

	    return list;
	};

	/**
	 * 创建存储标签
	 * 存储格式 seasonId-pageId
	 * @return {string} [description]
	 */
	BookMark.prototype.getMarkId = function (seasonId, pageId) {
	    return seasonId + '-' + pageId;
	};

	/**
	 * 获取历史记录
	 * @return {[type]} [description]
	 */
	BookMark.prototype.getHistory = function () {
	    var mark = (0, _stroage.$$get)('bookMark');
	    if (mark) {
	        return mark.split(',');
	    }
	    return [];
	};

	/**
	 * 添加书签
	 * @return {[type]} [description]
	 */
	BookMark.prototype.addBookMark = function () {
	    var key;

	    this.updatePageInfo();
	    key = this.getMarkId(this.seasonId, this.pageId);

	    //避免重复缓存
	    if (BOOKCACHE.indexOf(key) > -1) {
	        return;
	    }
	    BOOKCACHE.push(key);
	    (0, _stroage.$$set)('bookMark', BOOKCACHE);
	};

	/**
	 * 更新页信息
	 *  针对母板层上的书签
	 */
	BookMark.prototype.updatePageInfo = function () {
	    var pageData = Xut.Presentation.GetPageData();
	    this.pageId = pageData._id;
	    this.seasonId = pageData.seasonId;
	};

	/**
	 * 删除书签
	 * @param {object} [key] [事件目标对象]
	 * @return {[type]} [description]
	 */
	BookMark.prototype.delBookMark = function (target) {
	    if (!target || !target.dataset) return;

	    var key = target.dataset.mark,
	        index = BOOKCACHE.indexOf(key);

	    BOOKCACHE.splice(index, 1);
	    (0, _stroage.$$set)('bookMark', BOOKCACHE);

	    if (BOOKCACHE.length == 0) {
	        (0, _stroage.$$remove)('bookMark');
	    }

	    //移除该行
	    $(target).parent().remove();
	};

	/**
	 * 显示书签
	 * @param {object} [target] [事件目标对象]
	 * @return {[type]} [description]
	 */
	BookMark.prototype.viewBookMark = function (target) {
	    var $bookMarkList,
	        list = this.createMarkList();

	    if (this.bookMarkList) {
	        $bookMarkList = this.bookMarkList;
	    } else {
	        $bookMarkList = $(target).parent().parent().next();
	    }
	    //更新书签内容
	    $bookMarkList.find('.xut-bookmark-body').html(list);
	    this.bookMarkList = $bookMarkList;
	    $bookMarkList.fadeIn();
	};

	/**
	 * 点击放大效果
	 * @param  {[object]} target [事件目标对象]
	 * @return {[type]}      [description]
	 */
	BookMark.prototype.iconManager = function (target) {
	    var $icon = this.bookMarkIcon = $(target),
	        restore = this.iconRestore;
	    console.log(Xut.style);
	    $icon.css({
	        'transform': 'scale(1.2)',
	        'transition-duration': '500ms'
	    })[0].addEventListener(Xut.style.transitionEnd, restore.bind(this), false);
	};

	/**
	 * 复原按钮
	 * @return {[type]} [description]
	 */
	BookMark.prototype.iconRestore = function () {
	    this.bookMarkIcon.css('transform', '');
	};

	/**
	 * 跳转到书签页
	 * @param  {[type]} target [description]
	 * @return {[type]}        [description]
	 */
	BookMark.prototype.goBookMark = function (target) {
	    if (!target || !target.dataset) return;

	    var key = target.dataset.mark.split('-'),
	        seasonId = Number(key[0]),
	        pageId = Number(key[1]);

	    this.updatePageInfo();
	    //关闭书签列表
	    this.backBookMark();

	    //忽略当前页的跳转
	    if (this.pageId == pageId && this.seasonId == seasonId) {
	        return;
	    }

	    Xut.View.LoadScenario({
	        'scenarioId': seasonId,
	        'chapterId': pageId
	    });
	};

	/**
	 * 书签回退键
	 * @return {[type]} [description]
	 */
	BookMark.prototype.backBookMark = function () {
	    this.bookMarkList.fadeOut();
	};

	/**
	 * 邦定事件
	 * @param  {[type]} evt [事件]
	 * @return {[type]}     [description]
	 */
	BookMark.prototype.handleEvent = function (evt) {
	    var target = evt.target;
	    switch (target.className) {
	        //加入书签
	        case 'xut-bookmark-add':
	            this.addBookMark();
	            this.iconManager(target);
	            break;
	        //显示书签记录
	        case 'xut-bookmark-view':
	            this.viewBookMark(target);
	            this.iconManager(target);
	            break;
	        //关闭书签
	        case 'xut-bookmark-off':
	            this.closeBookMark(target);
	            break;
	        //返回书签主菜单
	        case 'xut-bookmark-back':
	            this.backBookMark();
	            break;
	        //删除书签记录
	        case 'xut-bookmark-del':
	            this.delBookMark(target);
	            break;
	        //跳转到书签页
	        case 'xut-bookmark-id':
	            this.goBookMark(target);
	            break;
	        default:
	            //console.log(target.className)
	            break;
	    }
	};

	/**
	 * 关闭书签菜单
	 * @return {[type]} [description]
	 */
	BookMark.prototype.closeBookMark = function () {
	    this.bookMarkMenu.css({
	        transform: 'translate3d(0,0,0)',
	        'transition-duration': '1s'
	    });
	};

	/**
	 * 恢复书签菜单
	 */
	BookMark.prototype.restore = function () {
	    this.bookMarkMenu.css({
	        transform: 'translate3d(0,-' + this.markHeight + 'px,0)',
	        'transition-duration': '1s'
	    });
	};

	/**
	 * 销毁书签
	 * @return {[type]} [description]
	 */
	BookMark.prototype.destroy = function () {
	    var dom = this.parent[0];

	    dom.removeEventListener('touchend', this, false);
	    dom.removeEventListener('mouseup', this, false);

	    //菜单部分
	    if (this.bookMarkMenu) {
	        this.bookMarkMenu.remove();
	        this.bookMarkMenu = null;
	    }

	    //列表部分
	    if (this.bookMarkList) {
	        this.bookMarkList.remove();
	        this.bookMarkList = null;
	    }

	    //按钮效果
	    if (this.bookMarkIcon) {
	        this.bookMarkIcon[0].removeEventListener(Xut.plat.transitionEnd, this.iconRestore, false);
	        this.bookMarkIcon = null;
	    }

	    this.parent = null;
	};

	exports.BookMark = BookMark;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (activitProto) {

	    activitProto.createBookMark = function () {
	        var node, seasonId, pageId, pageData;
	        if (this.pageType === 'master') {
	            //模板取对应的页面上的数据
	            pageData = Xut.Presentation.GetPageData();
	            node = this.relatedData.floatMaters.container;
	            pageId = pageData._id;
	            seasonId = pageData.seasonId;
	        } else {
	            node = this.$containsNode;
	            seasonId = this.relatedData.seasonId;
	            pageId = this.pageId;
	        }
	        var options = {
	            parent: node,
	            seasonId: seasonId,
	            pageId: pageId
	        };

	        if (this.bookMark) {
	            //如果上次只是隐藏则可以恢复
	            this.bookMark.restore();
	        } else {
	            this.bookMark = new _bookmark.BookMark(options);
	        }
	    };
	};

	var _bookmark = __webpack_require__(58);

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*********************************************************************
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * content的动画类对象
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 1 ppt 动画
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 2 精灵动画
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 3 show/hide接口
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 4 canvas动画
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @return {[type]} [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ********************************************************************/


	var _index = __webpack_require__(150);

	var _index2 = _interopRequireDefault(_index);

	var _com = __webpack_require__(65);

	var _com2 = _interopRequireDefault(_com);

	var _auto = __webpack_require__(64);

	var _auto2 = _interopRequireDefault(_auto);

	var _manager = __webpack_require__(6);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	//2016.7.15废弃
	//pixi暂时不使用
	var pixiSpirit = {};
	var pixiSpecial = {};

	// import { Sprite as pixiSpirit } from '../pixi/sprite/index'
	// import { specialSprite as pixiSpecial } from '../pixi/special/index'


	/**
	 * 销毁动画音频
	 * @param  {[type]} videoIds  [description]
	 * @param  {[type]} chapterId [description]
	 * @return {[type]}           [description]
	 */
	var destroyAudio = function destroyAudio(videoIds, chapterId) {
	    var isExist = false;
	    //如果有音频存在
	    videoIds && _.each(videoIds, function (data) {
	        //如果存在对象音频
	        if (data.videoId) {
	            isExist = true;
	            return 'breaker';
	        }
	    });
	    if (isExist) {
	        (0, _manager.clearContentAudio)(chapterId);
	    }
	};

	/**
	 * 4种扩展对象
	 * @type {Array}
	 */
	var OBJNAME = ['pptObj', 'pixiObj', 'comSpriteObj', 'autoSpriteObj'];

	/**
	 * Traverse each value of OBJNAME
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var access = function access(callback) {
	    OBJNAME.forEach(function (key) {
	        callback(key);
	    });
	};

	/**
	 * 动画效果
	 * @param {[type]} options [description]
	 */

	var Animation = function () {
	    function Animation(options) {
	        _classCallCheck(this, Animation);

	        _.extend(this, options);
	    }

	    /**
	     * Build the canvas of animation
	     * 比较复杂
	     * 1 普通与ppt组合
	     * 2 高级与ppt组合
	     * 3 ppt独立
	     * 4 普通精灵动画
	     * 8  其中 高级精灵动画是widget创建，需要等待
	     * @return {[type]} [description]
	     */


	    _createClass(Animation, [{
	        key: '_createCanvas',
	        value: function _createCanvas(id, parameter, category, callback) {
	            var _this = this;

	            var initstate = void 0;

	            //动作类型
	            //可能是组合动画
	            var actionTypes = this.contentDas.actionTypes;
	            var makeOpts = {
	                data: this.contentDas,
	                renderer: this.$contentNode,
	                pageIndex: this.pageIndex
	            };

	            //创建pixi上下文的ppt对象
	            var createPixiPPT = function createPixiPPT() {
	                //parameter存在就是ppt动画
	                if ((parameter || actionTypes.pptId) && _this.$contentNode.view) {
	                    _this.pptObj = callback(_index2.default, $(_this.$contentNode.view));
	                    _this.pptObj.contentId = id;
	                }
	            };

	            var $veiw = this.$contentNode.view;
	            if ($veiw) {
	                initstate = $veiw.getAttribute('data-init');
	            }

	            var setState = function setState() {
	                $veiw.setAttribute('data-init', true);
	            };

	            //多个canvas对应多个ppt
	            //容器不需要重复创建
	            //精灵动画
	            if (actionTypes.spiritId) {
	                if (initstate) {
	                    createPixiPPT();
	                } else {
	                    //加入任务队列
	                    this.nextTask.context.add(id);
	                    this.pixiObj = new pixiSpirit(makeOpts);
	                    //防止多条一样的数据绑多个动画
	                    //构建精灵动画完毕后
	                    //构建ppt对象
	                    this.pixiObj.$once('load', function () {
	                        //ppt动画
	                        createPixiPPT();

	                        //任务完成
	                        _this.nextTask.context.remove(id);
	                    });
	                    setState();
	                }
	            }

	            //特殊高级动画
	            //必须是ppt与pixi绑定的
	            if (actionTypes.compSpriteId) {
	                // console.log(this,this.id,this.contentDas.initpixi)
	                //这个dom已经创建了pixi了
	                if (initstate) {
	                    createPixiPPT();
	                } else {
	                    this.pixiObj = new pixiSpecial(makeOpts);
	                    setState();

	                    //ppt动画
	                    createPixiPPT();
	                }
	            }
	        }

	        /**
	         * Build the dom of animation
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createDom',
	        value: function _createDom(category, callback) {

	            if (category) {
	                var data = {
	                    id: this.id,
	                    data: this.contentDas,
	                    $contentNode: this.$contentNode
	                };
	                switch (category) {
	                    //普通精灵动画
	                    case "Sprite":
	                        this.comSpriteObj = (0, _com2.default)(data);
	                        break;
	                    //普通转复杂精灵动画
	                    case "AutoCompSprite":
	                        this.autoSpriteObj = new _auto2.default(data);
	                        break;
	                }
	            }

	            //ppt动画
	            this.pptObj = callback(_index2.default);
	        }

	        /**
	         * 绑定动画
	         * 为了向上兼容API
	         *  1 dom动画
	         *  2 canvas动画
	         */

	    }, {
	        key: 'init',
	        value: function init(id, context, $containsNode, chapterId, parameter, pageType) {

	            var pageIndex = void 0,
	                create = void 0,
	                category = void 0;

	            category = this.contentDas.category;
	            pageIndex = this.pageIndex;
	            create = function create(constr, newContext) {
	                var element = newContext || context;
	                if (element.length) {
	                    return new constr(pageIndex, pageType, chapterId, element, parameter, $containsNode);
	                } else {
	                    console.log('\u521B\u5EFA:' + constr + '\u5931\u8D25');
	                }
	            };

	            //build
	            //dom mode
	            //canvas mode
	            this.domMode ? this._createDom(category, create) : this._createCanvas(id, parameter, category, create);
	        }

	        /**
	         * 运行动画
	         * @param  {[type]} scopeComplete   [动画回调]
	         * @param  {[type]} canvasContainer [description]
	         * @return {[type]}                 [description]
	         */

	    }, {
	        key: 'play',
	        value: function play(playComplete) {
	            var _this2 = this;

	            var $contentNode = this.$contentNode;

	            //canvas
	            if ($contentNode && $contentNode.view) {
	                $contentNode = this.$contentNode.view;
	            }

	            access(function (key) {
	                if (_this2[key]) {
	                    if (key === 'pptObj') {
	                        //优化处理,只针对互斥的情况下
	                        //处理层级关系
	                        if ($contentNode.prop && $contentNode.prop("mutex")) {
	                            $contentNode.css({ //强制提升层级
	                                'display': 'block'
	                            });
	                        }
	                    }
	                    _this2[key].play && _this2[key].play(playComplete);
	                }
	            });
	        }

	        /**
	         * 停止动画
	         * @param  {[type]} chapterId [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop(chapterId) {
	            var _this3 = this;

	            access(function (key) {
	                if (_this3[key]) {
	                    if (key === 'pptObj') {
	                        //销毁ppt音频
	                        destroyAudio(_this3[key].options, chapterId);
	                    }
	                    _this3[key].stop && _this3[key].stop();
	                }
	            });
	        }

	        /**
	         * 翻页结束，复位上一页动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            var _this4 = this;

	            access(function (key) {
	                _this4[key] && _this4[key].reset && _this4[key].reset();
	            });
	        }

	        /**
	         * 销毁动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var _this5 = this;

	            access(function (key) {
	                _this5[key] && _this5[key].destroy && _this5[key].destroy();
	            });

	            //销毁renderer = new PIXI.WebGLRenderer
	            if (this.canvasMode) {
	                //rederer.destroy()
	                this.$contentNode.view && this.$contentNode.destroy();
	            }

	            //销毁每一个数据上的canvas上下文引用
	            if (this.contentDas.$contentNode) {
	                this.contentDas.$contentNode = null;
	            }

	            access(function (key) {
	                _this5[key] = null;
	            });

	            this.getParameter = null;
	        }
	    }]);

	    return Animation;
	}();

	exports.default = Animation;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.contentFilter = contentFilter;

	var _index = __webpack_require__(2);

	/**
	 * content对象的创建过滤器
	 * 用于阻断对象的创建
	 */
	function contentFilter(filterName) {

	    //过滤的节点
	    var listFilters = function () {
	        var values = getCache();
	        var h = (0, _index.hash)();
	        if (values) {
	            //keep the listFilters has no property
	            _.each(values, function (v, i) {
	                h[i] = v;
	            });
	        }
	        return h;
	    }();

	    function setCache(listFilters) {
	        (0, _index.$$save)(filterName, listFilters);
	    }

	    function getCache() {
	        var jsonStr = (0, _index.$$get)(filterName);
	        return (0, _index.parseJSON)(jsonStr);
	    }

	    function access(callback, pageId, contentId) {
	        //如果是transformFilter,不需要pageIndex处理
	        if (filterName === 'transformFilter' && contentId === undefined) {
	            contentId = pageId;
	            pageId = 'transformFilter';
	        }
	        return callback(pageId, Number(contentId));
	    }

	    return {
	        add: function add(pageId, contentId) {
	            access(function (pageId, contentId) {
	                if (!listFilters[pageId]) {
	                    listFilters[pageId] = [];
	                }
	                //去重
	                if (-1 === listFilters[pageId].indexOf(contentId)) {
	                    listFilters[pageId].push(contentId);
	                    setCache(listFilters);
	                }
	            }, pageId, contentId);
	        },
	        remove: function remove(pageId, contentId) {
	            access(function (pageId, contentId) {
	                var target = listFilters[pageId] || [],
	                    index = target.indexOf(contentId);
	                if (-1 !== index) {
	                    target.splice(index, 1);
	                    setCache(listFilters);
	                }
	            }, pageId, contentId);
	        },
	        has: function has(pageId, contentId) {
	            return access(function (pageId, contentId) {
	                var target = listFilters[pageId];
	                return target ? -1 !== target.indexOf(contentId) ? true : false : false;
	            }, pageId, contentId);
	        },


	        /**
	         * 创建过滤器
	         * @param  {[type]} pageId [description]
	         * @return {[type]}        [description]
	         */
	        each: function each(pageId) {
	            return access(function (pageId, contentId) {
	                var target, indexOf;
	                if (target = listFilters[pageId]) {
	                    return function (contentIds, callback) {
	                        _.each(target, function (ids) {
	                            var indexOf = contentIds.indexOf(ids);
	                            if (-1 !== indexOf) {
	                                callback(indexOf); //如果找到的过滤项目
	                            }
	                        });
	                    };
	                }
	            }, pageId);
	        },


	        //过滤器数量
	        size: function size() {
	            return _.keys(listFilters).length;
	        },
	        empty: function empty() {
	            (0, _index.$$remove)(filterName);
	            listFilters = {};
	        }
	    };
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (base) {
	    var animation = base.seed.animation,
	        parallax = base.seed.parallax,

	    //抽出content对象
	    abstractContents = [],

	    //创建引用
	    batcheCreate = fnCreate(base);

	    switch (base.pageType) {
	        case 'page':
	            batcheCreate(animation, function (handlers) {
	                abstractContents.push(handlers);
	            });
	            break;
	        case 'master':
	            //母版层的处理
	            var tempParallaxScope = {},
	                tempAnimationScope = {},
	                tempAssistContents = [];
	            //视觉差处理
	            batcheCreate(parallax, function (handlers) {
	                tempParallaxScope[handlers.id] = handlers;
	            });

	            batcheCreate(animation, function (handlers) {
	                tempAnimationScope[handlers.id] = handlers;
	            });

	            var hasParallax = _.keys(tempParallaxScope).length,
	                hasAnimation = _.keys(tempAnimationScope).length;

	            //动画为主
	            //合并，同一个对象可能具有动画+视觉差行为
	            if (hasParallax && hasAnimation) {
	                _.each(tempAnimationScope, function (target) {
	                    var id = target.id;
	                    var source = tempParallaxScope[id];
	                    if (source) {
	                        //如果能找到就需要合并
	                        innerExtend(target, source); //复制方法
	                        target.processType = 'both'; //标记新组合
	                        delete tempParallaxScope[id]; //删除引用
	                    }
	                });
	                //剩余的处理
	                if (_.keys(tempParallaxScope).length) {
	                    _.extend(tempAnimationScope, tempParallaxScope);
	                }
	                tempParallaxScope = null;
	            }
	            //转化成数组
	            _.each(hasAnimation ? tempAnimationScope : tempParallaxScope, function (target) {
	                tempAssistContents.push(target);
	            });
	            abstractContents = tempAssistContents;
	            break;
	    }

	    batcheCreate = null;

	    return abstractContents;
	};

	var _animation = __webpack_require__(60);

	var _animation2 = _interopRequireDefault(_animation);

	var _init = __webpack_require__(63);

	var _init2 = _interopRequireDefault(_init);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//2016.7.15废弃
	//pixi暂时不使用
	// import { Context } from '../pixi/context'

	/**
	 * 预运行动作
	 * 自动 && 出现 && 无时间 && 无音乐
	 *  && 不是精灵动画 && 没有脚本代码 && 并且不能是收费
	 * @return {[type]}         [description]
	 */
	/**
	 * 创建执行对象
	 * 1 动画作用域
	 * 2 视觉差作用域
	 * @type {Array}
	 */
	var preRunAction = function preRunAction(data, eventName) {
	    var para, state, category, parameter;
	    parameter = data.getParameter();

	    //过滤预生成动画
	    if (parameter.length === 1) {
	        category = data.contentDas.category;
	        para = parameter[0];
	        if (para.animationName === 'EffectAppear' && data.domMode //并且只有dom模式才可以，canvas排除
	        && eventName === 'auto' && !para.videoId && !para.delay && category !== 'Sprite' && category !== 'AutoCompSprite' && !para.preCode //动画前脚本
	        && !para.postCode //动画后脚本
	        && !/"inapp"/i.test(para.parameter)) {
	            //并且不能是收费处理

	            /**
	             *针对预处理动作,并且没有卷滚的不注册
	             *满足是静态动画
	             *true是显示,false隐藏å
	             */
	            var state = data.isRreRun = /"exit":"False"/i.test(para.parameter) === true ? 'visible' : 'hidden';

	            return state;
	        }
	    }
	};

	/**
	 * 构建动画
	 * @return {[type]} [description]
	 */
	var createScope = function createScope(base, contentId, pid, actName, parameter, hasParallax) {

	    //默认启动dom模式
	    var data = {
	        type: 'dom',
	        canvasMode: false,
	        domMode: true
	    };
	    var $contentNode;
	    var pageType = base.pageType;
	    var contentName;
	    var canvasDom;
	    var contentDas = base.relatedData.contentDas[contentId];

	    //如果启动了canvas模式
	    //改成作用域的一些数据
	    if (base.canvasRelated.enable) {
	        //如果找到对应的canvas对象
	        if (-1 !== base.canvasRelated.cid.indexOf(contentId)) {
	            contentName = "canvas_" + pid + "_" + contentId;
	            canvasDom = base.getContextNode(contentName)[0];

	            //创建上下文pixi
	            if (contentDas.$contentNode) {
	                $contentNode = contentDas.$contentNode;
	            } else {
	                // $contentNode = Context(contentDas, canvasDom, base.pageIndex)
	                //保存canvas pixi的上下文引用
	                // base.relatedData.contentDas[contentId].$contentNode = $contentNode
	            }
	            data.type = 'canvas';
	            data.canvasMode = true;
	            data.domMode = false;
	        }
	    }

	    //如果是dom模式
	    if (!$contentNode) {
	        /**
	         * 确保节点存在
	         * @type {[type]}
	         */
	        if (!($contentNode = base.getContextNode(actName))) {
	            return;
	        }
	    }

	    /**
	     * 制作公共数据
	     * @type {Object}
	     */
	    _.extend(data, {
	        base: base,
	        id: contentId,
	        pid: pid,
	        actName: actName,
	        contentDas: contentDas,
	        $contentNode: $contentNode,
	        pageType: pageType,
	        pageIndex: base.pageIndex,
	        canvasRelated: base.canvasRelated,
	        nextTask: base.nextTask,
	        canvasDom: canvasDom
	    });

	    /**
	     * 如果是母版层理,视觉差处理
	     * processType 三种情况
	     *          parallax
	     *          animation
	     *          both(parallax,animation)
	     * @type {[type]}
	     */
	    if (hasParallax && pageType === 'master') {
	        data.processType = 'parallax';
	    } else {
	        data.processType = 'animation';
	    }

	    /**
	     * 生成查询方法
	     * @return {[type]} [description]
	     */
	    data.getParameter = function () {
	        //分区母版与页面的数据结构
	        //parameter-master-parallax
	        //parameter-master-animation
	        //parameter-page-animation
	        var fix = 'parameter-' + pageType + '-' + data.processType;
	        data[fix] = parameter;
	        return function () {
	            return data[fix];
	        };
	    }();

	    /**
	     * 生成视觉差对象
	     * @type {[type]}
	     */
	    if (data.processType === 'parallax') {
	        return (0, _init2.default)(data, base.relatedData);
	    }

	    /**
	     *  优化机制,预生成处理
	     *  过滤自动热点并且是出现动作，没有时间，用于提升体验
	     */
	    preRunAction(data, base.eventData.eventName);

	    /**
	     * 生成子作用域对象，用于抽象处理动画,行为
	     */
	    return new _animation2.default(data);
	};

	/**
	 * 分解每个子作用域
	 * 1 生成临时占位作用域,用于分段动画
	 * 2 生成所有动画子作用域
	 * @param  {[type]} parameter [description]
	 * @return {[type]}           [description]
	 */
	var createHandlers = function createHandlers(base, parameter) {

	    //dom对象
	    var para = parameter[0],
	        contentId = para['contentId'],
	        //可能有多个动画数据 [Object,Object,Object]
	    pid = base.pid,
	        actName = base.makePrefix('Content', pid, contentId);

	    /**
	     * 构建子作用域
	     */
	    return createScope(base, contentId, pid, actName, parameter, para.masterId);
	};

	/**
	 * 构建作用域
	 * @return {[type]} [description]
	 */
	var fnCreate = function fnCreate(base) {
	    return function (data, callback) {
	        var para, handlers;
	        if (data && data.length) {
	            //生成动画作用域对象
	            while (para = data.shift()) {
	                if (handlers = createHandlers(base, para)) {
	                    callback(handlers);
	                }
	            }
	        }
	    };
	};

	/**
	 * 源对象复制到目标对象
	 */
	var innerExtend = function innerExtend(target, source) {
	    var property;
	    for (property in source) {
	        if (target[property] === undefined) {
	            target[property] = source[property];
	        }
	    }
	};

	//处理itemArray绑定的动画对象
	//注入动画
	//绑定用户事件

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Parallax;

	var _index = __webpack_require__(1);

	var _lang = __webpack_require__(3);

	var _util = __webpack_require__(18);

	var _get = __webpack_require__(7);

	/**
	 * 变化节点的css3transform属性
	 * @param  {[type]} $contentNode   [description]
	 * @param  {[type]} property   [description]
	 * @param  {[type]} pageOffset [description]
	 * @return {[type]}            [description]
	 */
	/**
	 * 视觉差对象初始化操作
	 */

	var setTransformNodes = function setTransformNodes($contentNode, property, pageOffset) {
	    return (0, _util.setStyle)({ //return parallaxOffset
	        $contentNode: $contentNode,
	        action: 'init',
	        property: property,
	        pageOffset: pageOffset
	    });
	};

	/**
	 * 转换成比例值
	 * @param  {[type]} parameters [description]
	 * @return {[type]}            [description]
	 */
	var converParameters = function converParameters(parameters) {
	    if (parameters.opacityStart > -1) {
	        parameters.opacity = (parameters.opacityEnd || 1) - parameters.opacityStart;
	        delete parameters.opacityEnd;
	    }
	    return parameters;
	};

	/**
	 * 转化成实际值
	 * @param  {[type]} parameters     [description]
	 * @param  {[type]} nodeProportion [description]
	 * @return {[type]}                [description]
	 */
	var converValue = function converValue(parameters, nodeOffsetProportion) {
	    var results = {},
	        width = -_index.config.viewSize.width,
	        height = -_index.config.viewSize.height;

	    for (var i in parameters) {
	        switch (i) {
	            case 'translateX':
	            case 'translateZ':
	                results[i] = parameters[i] * nodeOffsetProportion * width;
	                break;
	            case 'translateY':
	                results[i] = parameters[i] * nodeOffsetProportion * height;
	                break;
	            case 'opacityStart':
	                results[i] = parameters[i];
	                break;
	            default:
	                results[i] = parameters[i] * nodeOffsetProportion;
	        }
	    }

	    return results;
	};

	/**
	 * 如果母版依赖的页面是flow页面
	 * 需要获取到具体的页面长度
	 * @return {[type]} [description]
	 */
	var getFlowFange = function getFlowFange(pageIndex) {
	    var relyPageObj = Xut.Presentation.GetPageObj('page', pageIndex);
	    if (relyPageObj && relyPageObj.chapterData.note === 'flow') {
	        var seasonId = relyPageObj.chapterData.seasonId;
	        var chapterId = relyPageObj.chapterId;
	        var range = (0, _get.getFlowCount)(seasonId, chapterId); //分页总数
	        return range;
	    }
	};

	function Parallax(data, relatedData) {

	    //转化所有css特效的参数的比例
	    var parameters = (0, _lang.parseJSON)(data.getParameter()[0]['parameter']);
	    if (!parameters) {
	        return;
	    }

	    parameters = converParameters(parameters);

	    var pid = data.pid;

	    //首位分割点
	    var currPageOffset = void 0;

	    //如果是flow页面，拿到分页数
	    var pageRange = (0, _get.hasFlow)() && getFlowFange(data.pageIndex);

	    if (pageRange) {
	        var visualIndex = Xut.Presentation.GetPageIndex();
	        if (data.pageIndex == visualIndex || data.pageIndex > visualIndex) {
	            currPageOffset = 1;
	        } else {
	            currPageOffset = pageRange;
	        }
	    } else {
	        //页面偏移量
	        //["3", "6", "4"]
	        //表示第4次采用了这个母板，中间有其他模板间隔开了的情况
	        var pageOffset = relatedData.pageOffset && relatedData.pageOffset.split("-");
	        //开始的nodes值
	        currPageOffset = parseInt(pageOffset[0]);
	        //范围区域
	        pageRange = parseInt(pageOffset[1]);
	    }

	    //页面偏移比例
	    var nodeOffsetProportion = (currPageOffset - 1) / (pageRange - 1) || 0;

	    //计算出新的新的值
	    var property = converValue(parameters, nodeOffsetProportion);

	    //页面分割比
	    var nodeProportion = 1 / (pageRange - 1);

	    //初始化视觉差对象的坐标偏移量
	    var transformOffset = relatedData.getTransformOffset(data.id);
	    var parallaxOffset = setTransformNodes(data.$contentNode, property, transformOffset);

	    /**
	     * 为了兼容动画，把视觉差当作一种行为处理
	     * 合并data数据
	     * @type {Object}
	     */
	    data.parallax = {
	        $contentNode: data.$contentNode,
	        /**
	         * 计算页码结束边界值,用于跳转过滤
	         */
	        calculateRangePage: function calculateRangePage() {
	            return {
	                'start': pid - currPageOffset + 1,
	                'end': pageRange - currPageOffset + pid
	            };
	        },

	        parameters: parameters,
	        initProperty: property,
	        nodeProportion: nodeProportion,
	        /**
	         * 经过视觉差修正后的偏移量
	         */
	        parallaxOffset: parallaxOffset
	    };

	    return data;
	}

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 2016.7.10
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * if comsprites is too large，
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The client will comsprite become the advsprite  by default
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _advance = __webpack_require__(41);

	var _advance2 = _interopRequireDefault(_advance);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var moveContent = function moveContent(contentPrefix, id, parentId) {
	    var obj = $("#" + contentPrefix + id);
	    var parentObj = $("#" + contentPrefix + parentId);
	    var $parent = $("#spirit_parent_" + parentId);
	    if ($parent.length == 0) {
	        parentObj.append("<div style='position:absolute; width:100%; height:100%'  id='spirit_parent_" + parentId + "'></div>");
	    }
	    $parent.append(obj);
	};

	var _class = function () {
	    function _class(options) {
	        _classCallCheck(this, _class);

	        this.options = options;
	        this.ids = [];
	    }

	    _createClass(_class, [{
	        key: "play",
	        value: function play() {

	            var id = void 0,
	                action = void 0,
	                ids = void 0,
	                data = void 0,
	                resource = void 0,
	                loop = void 0,
	                spiritList = void 0,
	                framId = void 0,
	                parentId = void 0,
	                params = void 0,
	                options = void 0;

	            options = this.options;
	            data = options.data;
	            resource = data.resource;
	            loop = data.loop;
	            this.spiritObjs = {};
	            var option = {};
	            option.contentId = options.id;
	            option.ele = options.$contentNode;
	            option.resourcePath = data.md5;
	            option.type = "advSprite";
	            for (var i = 0; i < resource.spiritList.length; i++) {
	                spiritList = resource.spiritList[i];
	                id = data.containerName;
	                framId = spiritList.framId;
	                parentId = spiritList.parentId;
	                this.ids.push(id);
	                if (parentId != "0") {
	                    var tempArray = id.split('_');
	                    var contentPrefix = tempArray[0] + '_' + tempArray[1];
	                    moveContent(contentPrefix, framId, parentId);
	                }
	                this.spiritObjs[id] = new _advance2.default(spiritList, option);
	                params = spiritList.params;

	                action = params["actList"].split(",")[0];
	                //0 循环播放 1播放一次
	                this.spiritObjs[id].play(action, loop);
	            }
	        }
	    }, {
	        key: "stop",
	        value: function stop() {
	            var _this = this;

	            this.ids.forEach(function (key) {
	                _this.spiritObjs[key].stop();
	            });
	        }
	    }, {
	        key: "reset",
	        value: function reset() {
	            this.stop();
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            var _this2 = this;

	            this.ids.forEach(function (key) {
	                if (_this2.spiritObjs[key]) {
	                    _this2.spiritObjs[key].destroy();
	                    _this2.spiritObjs[key] = null;
	                    delete _this2.spiritObjs[key];
	                }
	            });
	            this.options.data = null;
	            this.options.$contentNode = null;
	            this.options = null;
	            this.ids = null;
	        }
	    }]);

	    return _class;
	}();

	exports.default = _class;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (options) {
	  //timer,css
	  var mode = options.mode || 'css';
	  return mode === 'css' && animationPlayState ? (0, _css2.default)(options) : (0, _frame2.default)(options);
	};

	var _css = __webpack_require__(152);

	var _css2 = _interopRequireDefault(_css);

	var _frame = __webpack_require__(153);

	var _frame2 = _interopRequireDefault(_frame);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//判断是否支持css3属性
	var animationPlayState = Xut.style.animationPlayState;

	/**
	 * css3动画
	 * 1 帧动画
	 * 2 定时器动画
	 * @param {[type]} options [description]
	 */

/***/ },
/* 66 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.complexEvent = complexEvent;

	/**
	 * 优化hammer创建,生成必要配置文件
	 * @return {[type]} [description]
	 */
	function createRecognizers(eventName) {
	    var recognizers = [];
	    switch (eventName) {
	        //如果是swipe处理
	        case 'swipeleft':
	        case 'swiperight':
	        case 'swipeup':
	        case 'swipedown':
	            var direction = Hammer.DIRECTION_HORIZONTAL;
	            if (eventName === 'swipeup' || eventName === "swipedown") {
	                direction = Hammer.DIRECTION_VERTICAL;
	            }
	            recognizers.push([Hammer.Swipe, { 'direction': direction, 'velocity': 0.01 }]);
	            break;
	        case 'doubletap':
	            //双击
	            recognizers.push([Hammer.Tap]);
	            recognizers.push([Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]);
	            break;
	        case 'press':
	            //长按
	            recognizers.push([Hammer.Press]);
	            return;
	    }
	    return recognizers;
	}

	/**
	 * 创建hammer引用
	 * @return {[type]}         [description]
	 */
	function createHammer(eventContext, eventName, supportSwipe) {
	    var eventReference;
	    var context = eventContext[0];
	    var recognizer = createRecognizers(eventName);
	    if (recognizer && recognizer.length) {
	        eventReference = Hammer(context, {
	            'recognizers': recognizer
	        });
	    } else {
	        eventReference = Hammer(context);
	    }
	    return eventReference;
	}

	/**
	 * 复杂的事件
	 * @return {[type]} [description]
	 */
	function complexEvent(eventContext, eventName, eventHandler, supportSwipe) {
	    var eventReference = createHammer(eventContext, eventName, supportSwipe);
	    eventReference.on(eventName, function () {
	        eventHandler();
	    });
	    return eventReference;
	}

/***/ },
/* 67 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 拖拽类
	 */
	var _class = function () {
	    function _class(dragElement, dropElement, autoReturn, dragCallback, dropCallback, container, throwProps) {
	        _classCallCheck(this, _class);

	        this.dragElement = dragElement;
	        this.defaultPoint = null;
	        this.dropElement = dropElement;
	        this.autoReturn = autoReturn >= 1 ? true : false; //1:自动返回(true) 0:留在原地(false)
	        this.dragCallback = typeof dragCallback == "function" ? dragCallback : null;
	        this.dropCallback = typeof dropCallback == "function" ? dropCallback : null;
	        this.throwProps = throwProps == false || this.autoReturn ? false : true;
	        this.container = container;
	        this.dragElement.attr("data-defaultindex", this.dragElement.css("z-index"));
	        //this.dragObject = null; //创建的拖拽对象实例
	        var isInit = this.dragElement.attr("data-DragDrop");
	        if (isInit == null) {
	            this.init();
	            this.dragElement.attr("data-DragDrop", true);
	        } else {
	            console.log("This element has binding DragDropClass.");
	        }
	    }

	    /**
	     * 初始化拖拽
	     * @return {[type]} [description]
	     */


	    _createClass(_class, [{
	        key: "init",
	        value: function init() {
	            if (this.dragObject != null) return;

	            var self = this;

	            //now make both boxes draggable.
	            var dragObject = this.dragObject = Draggable.create(this.dragElement, {
	                bounds: this.container,
	                dragResistance: 0,
	                edgeResistance: 0.8,
	                type: "left,top", //rotation、scroll(x+y模式与PPT动画冲突)
	                force3D: false, //是否启用硬件加速(left+top模式无需启用，启用后存在闪现问题)
	                throwProps: this.throwProps,
	                snap: {
	                    left: function left(endValue) {
	                        return endValue;
	                    },
	                    top: function top(endValue) {
	                        return endValue;
	                    }
	                },
	                onDragStart: function onDragStart(e) {
	                    //获取拖拽对象原始参数
	                    var defaultOffset = self.dragElement.offset();
	                    self.defaultPoint = {
	                        x: defaultOffset.left,
	                        y: defaultOffset.top,
	                        left: Number(self.dragElement.css("left").replace("px", "")),
	                        top: Number(self.dragElement.css("top").replace("px", ""))
	                    };
	                    if (self.dragCallback) self.dragCallback();
	                },
	                onDragEnd: function onDragEnd(e) {
	                    var dropElement = self.dropElement,
	                        isEnter = false; //是否进入目标

	                    if (dropElement) {
	                        //获取拖拽对象当前参数
	                        var fromOffset = self.dragElement.offset();
	                        var fromPoint = {
	                            x: fromOffset.left,
	                            y: fromOffset.top,
	                            w: self.dragElement.width(),
	                            h: self.dragElement.height()
	                        };
	                        //获取目标对象参数
	                        var toOffset = dropElement.offset();
	                        var toPoint = {
	                            x: toOffset.left,
	                            y: toOffset.top,
	                            w: dropElement.width(),
	                            h: dropElement.height()
	                        };
	                        //目标对象中心点
	                        var targetCenter = {
	                            pointerX: toPoint.x + toPoint.w / 2,
	                            pointerY: toPoint.y + toPoint.h / 2
	                        };
	                        //拖拽点位于目标框中或目标中心点位于拖拽框中视为拖拽成功
	                        if (dragObject.pointerX > toPoint.x && dragObject.pointerX < toPoint.x + toPoint.w && dragObject.pointerY > toPoint.y && dragObject.pointerY < toPoint.y + toPoint.h) {
	                            isEnter = true;
	                            dragObject.disable();
	                        } else if (targetCenter.pointerX > fromPoint.x && targetCenter.pointerX < fromPoint.x + fromPoint.w && targetCenter.pointerY > fromPoint.y && targetCenter.pointerY < fromPoint.y + fromPoint.h) {
	                            isEnter = true;
	                            dragObject.disable();
	                        }
	                        self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));
	                        //拖拽成功
	                        if (isEnter == true) {
	                            //结束后恢复层级关系
	                            // self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));

	                            //拖拽对象与目标对象中心点差
	                            var moveX = targetCenter.pointerX - (self.defaultPoint.x + fromPoint.w / 2);
	                            var moveY = targetCenter.pointerY - (self.defaultPoint.y + fromPoint.h / 2);
	                            //拖拽对象最终停放位置
	                            var newLeft = self.defaultPoint.left + moveX;
	                            var newTop = self.defaultPoint.top + moveY;
	                            //自动拖拽到位
	                            TweenLite.to(self.dragElement, 0.30, {
	                                css: {
	                                    left: newLeft,
	                                    top: newTop
	                                },
	                                ease: Expo.easeOut
	                            });
	                        } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
	                            css: {
	                                left: self.defaultPoint.left,
	                                top: self.defaultPoint.top
	                            }
	                        });
	                    } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
	                        css: {
	                            left: self.defaultPoint.left,
	                            top: self.defaultPoint.top
	                        }
	                    });
	                    //调用结束事件
	                    if (self.dropCallback) self.dropCallback(isEnter);
	                }
	            })[0];
	        }

	        /**
	         * 复位动画与状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: "reset",
	        value: function reset() {
	            var self = this;
	            var dragObject;
	            if (dragObject = this.dragObject) {
	                dragObject.enable();
	                if (self.defaultPoint) {
	                    self.dragElement.css("left", self.defaultPoint.left);
	                    self.dragElement.css("top", self.defaultPoint.top);
	                }
	                /*TweenLite.to(self.dragElement, 0, {
	                    css: {
	                        x: 0,
	                        y: 0
	                    }
	                });*/
	            }
	        }
	    }, {
	        key: "disable",
	        value: function disable() {
	            var dragObject;
	            if (dragObject = this.dragObject) {
	                dragObject.disable();
	            }
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            this.dragObject && this.dragObject.kill();
	            this.dropElement = null;
	            this.dragElement = null;
	            this.dragObject = null;
	        }
	    }]);

	    return _class;
	}();

	exports.default = _class;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.simpleEvent = simpleEvent;

	var _dom = __webpack_require__(5);

	/**
	 * ie10下面mouse事件怪异
	 * @return {Boolean} [description]
	 */
	var isIE10 = document.documentMode === 10;

	/**
	 * 针对canvas模式
	 * 特殊的hack
	 * 当前点击的元素是滑动元素
	 * 处理元素的全局事件
	 */
	function setCanvasStart(supportSwipe) {
	    Xut.Contents.Canvas.Reset();
	    Xut.Contents.Canvas.SupportSwipe = supportSwipe;
	    Xut.Contents.Canvas.isTap = true;
	}

	function setCanvasMove() {
	    Xut.Contents.Canvas.isSwipe = true;
	}

	/**
	 * 兼容事件对象
	 * @return {[type]}   [description]
	 */
	function compatibilityEvent(e) {
	    var point;
	    if (e.touches && e.touches[0]) {
	        point = e.touches[0];
	    } else {
	        point = e;
	    }
	    return point;
	}

	/**
	 * 如果是简单的点击事件
	 */
	function simpleEvent(eventContext, eventHandle, supportSwipe) {

	    eventContext.isTap = false;

	    //这里单独绑定事件有个问题,单击move被触发
	    //如果停止e.stopPropagation，那么默认行为就不会被触发
	    //你绑定单击的情况下可以翻页
	    //这里通过坐标的位置来判断
	    var start = function start(e) {
	        var point = compatibilityEvent(e);
	        //记录开始坐标
	        eventContext.pageX = point.pageX;
	        //是否是tap事件
	        eventContext.isTap = true;
	        setCanvasStart(supportSwipe);
	    };

	    var move = function move(e) {
	        if (!eventContext.isTap) {
	            return;
	        }
	        var point = compatibilityEvent(e),
	            deltaX = point.pageX - eventContext.pageX;
	        //如果有move事件，则取消tap事件
	        if (Math.abs(deltaX)) {
	            eventContext.isTap = false;
	            setCanvasMove(supportSwipe);
	        }
	    };

	    var end = function end() {
	        //触发tap事件
	        eventContext.isTap && eventHandle();
	    };

	    eventContext = eventContext[0];

	    //IE10是不支持touch事件，直接绑定click事件
	    if (isIE10) {
	        eventContext.isTap = true;
	        eventContext.addEventListener('click', end, false);
	    } else {

	        (0, _dom.$$on)(eventContext, {
	            start: start,
	            move: move,
	            end: end
	        });
	    }

	    return {
	        off: function off() {
	            if (eventContext) {
	                if (isIE10) {
	                    eventContext.removeEventListener('click', end, false);
	                } else {
	                    (0, _dom.$$off)(eventContext, {
	                        start: start,
	                        move: move,
	                        end: end
	                    });
	                }
	                eventContext = null;
	            }
	        }
	    };
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (activitProto) {

	    /**
	     * 构建事件体系
	     * @return {[type]} [description]
	     */
	    activitProto._fillEventData = function () {

	        //配置事件节点
	        var eventId,
	            pid,
	            contentName,

	        //事件上下文对象
	        eventContext,
	            eventData = this.eventData;

	        pid = this.pid;

	        //如果存在imageIds才处理,单独绑定事件处理
	        if (eventId = eventData.eventContentId) {

	            //dom
	            //找到对应绑定事件的元素
	            var domEvent = function domEvent() {
	                contentName = this.makePrefix('Content', pid, this.id);
	                eventData.type = 'dom';
	                eventData.canvasMode = false;
	                eventData.domMode = true;
	            };

	            //canvas模式非常特别
	            //canvas容器+内部pixi对象
	            //所以事件绑定在最外面
	            var canvasEvent = function canvasEvent() {
	                contentName = this.makePrefix('canvas', pid, this.id);
	                eventData.type = 'canvas';
	                eventData.canvasMode = true;
	                eventData.domMode = false;
	            };

	            //canvas事件
	            if (-1 !== this.canvasRelated.cid.indexOf(eventId)) {
	                canvasEvent.call(this);
	            } else {
	                //dom事件
	                domEvent.call(this);
	            }

	            eventContext = this.getContextNode(contentName);
	            eventData.eventContext = eventContext;

	            if (eventContext) {
	                /**
	                 * 绑定事件加入到content钩子
	                 */
	                this.relatedCallback.contentsHooks(pid, eventId, {
	                    $contentNode: eventContext,
	                    //增加外部判断
	                    isBindEventHooks: true,
	                    type: eventData.type
	                });
	            } else {
	                /**
	                 * 针对动态事件处理
	                 * 快捷方式引用到父对象
	                 * @type {[type]}
	                 */
	                eventData.parent = this;
	            }
	        }

	        /**
	         * 解析出事件类型
	         */
	        eventData.eventName = (0, _event.conversionEventType)(eventData.eventType);
	    };

	    /**
	     * 绑定事件行为
	     * @return {[type]} [description]
	     */
	    activitProto._bindEventBehavior = function (callback) {
	        var self = this;
	        var eventData = this.eventData;
	        var eventName = eventData.eventName;
	        var eventContext = eventData.eventContext;

	        /**
	         * 运行动画
	         * @return {[type]} [description]
	         */
	        var startRunAnim = function startRunAnim() {
	            //当前事件对象没有动画的时候才能触发关联动作
	            var animOffset,
	                boundary = 5; //边界值

	            if (eventData.domMode && (animOffset = eventContext.prop('animOffset'))) {
	                var originalLeft = animOffset.left;
	                var originalTop = animOffset.top;
	                var newOffset = eventContext.offset();
	                var newLeft = newOffset.left;
	                var newTop = newOffset.top;
	                //在合理的动画范围是允许点击的
	                //比如对象只是一个小范围的内的改变
	                //正负10px的移动是允许接受的
	                if (originalLeft > newLeft - boundary && originalLeft < newLeft + boundary || originalTop > newTop - boundary && originalTop < newTop + boundary) {
	                    self.runAnimation();
	                }
	            } else {
	                self.runAnimation();
	            }
	        };

	        /**
	         * 设置按钮的行为
	         * 音频
	         * 反弹
	         */
	        var setBehavior = function setBehavior(feedbackBehavior) {

	            var behaviorSound = void 0;

	            //音频地址
	            if (behaviorSound = feedbackBehavior.behaviorSound) {
	                //妙妙学客户端强制删除
	                if (window.MMXCONFIG && window.audioHandler) {
	                    self._fixAudio.push(new _audio.audioPlayer({
	                        url: behaviorSound,
	                        trackId: 9999,
	                        complete: function complete() {
	                            this.play();
	                        }
	                    }));
	                } else {
	                    //其余平台,如果存在点击过的
	                    //这里主要是防止重复点击创建
	                    var audio = self._cacheBehaviorAudio[behaviorSound];
	                    if (audio) {
	                        audio.play();
	                    } else {
	                        //相同对象创建一次
	                        //以后取缓存
	                        audio = new _audio.audioPlayer({
	                            url: behaviorSound
	                        });
	                        audio.play();
	                        self._cacheBehaviorAudio[behaviorSound] = audio;
	                    }
	                }
	            }

	            //反弹效果
	            if (feedbackBehavior.isButton) {
	                //div通过css实现反弹
	                if (eventData.domMode) {
	                    eventContext.addClass('xut-behavior');
	                    setTimeout(function () {
	                        eventContext.removeClass('xut-behavior');
	                        startRunAnim();
	                    }, 500);
	                } else {
	                    console.log('feedbackBehavior');
	                }
	            } else {
	                startRunAnim();
	            }
	        };

	        /**
	         * 事件引用钩子
	         * 用户注册与执行
	         * @type {Object}
	         */
	        var eventDrop = {
	            //保存引用,方便直接销毁
	            init: function init(drag) {
	                eventData.dragDrop = drag;
	            },
	            //拖拽开始的处理
	            startRun: function startRun() {},
	            //拖拽结束的处理
	            stopRun: function stopRun(isEnter) {
	                if (isEnter) {
	                    //为true表示拖拽进入目标对象区域
	                    self.runAnimation();
	                }
	            }
	        };

	        /**
	         * 正常动画执行
	         * 除去拖动拖住外的所有事件
	         * 点击,双击,滑动等等....
	         * @return {[type]} [description]
	         */
	        var eventRun = function eventRun() {
	            //如果存在反馈动作
	            //优先于动画执行
	            var feedbackBehavior;
	            if (feedbackBehavior = eventData.feedbackBehavior[eventData.eventContentId]) {
	                setBehavior(feedbackBehavior);
	            } else {
	                startRunAnim();
	            }
	        };

	        /**
	         * 事件对象引用
	         * @return {[type]} [description]
	         */
	        var eventHandler = function eventHandler(eventReference, _eventHandler) {
	            eventData.eventReference = eventReference;
	            eventData.eventHandler = _eventHandler;
	        };

	        //绑定用户自定义事件
	        if (eventContext && eventName) {

	            //如果是翻页委托启动了
	            //这里处理swiperight与swipeleft
	            if (_index.config.swipeDelegate && (eventName === 'swiperight' || eventName === 'swipeleft')) {
	                self.relatedCallback.swipeDelegateContents(eventName, function (callback) {
	                    self.runAnimation(callback);
	                });
	            }
	            //给独立对象绑定事件
	            else {

	                    var domName = void 0;
	                    var target = void 0;
	                    var dragdropPara = void 0;

	                    dragdropPara = eventData.dragdropPara;

	                    //获取拖拽目标对象
	                    if (eventName === 'dragTag') {
	                        domName = this.makePrefix('Content', this.pid, dragdropPara);
	                        target = this.getContextNode(domName);
	                    }

	                    //增加事件绑定标示
	                    //针对动态加载节点事件的行为过滤
	                    eventData.isBind = true;

	                    (0, _event.bindContentEvent)({
	                        'eventDrop': eventDrop,
	                        'eventRun': eventRun,
	                        'eventHandler': eventHandler,
	                        'eventContext': eventContext,
	                        'eventName': eventName,
	                        'parameter': dragdropPara,
	                        'target': target,
	                        'domMode': eventData.domMode
	                    });
	                }
	        }
	    };
	};

	var _index = __webpack_require__(1);

	var _audio = __webpack_require__(26);

	var _event = __webpack_require__(14);

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*******************************************
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   文本类
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     处理:
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *       1 异步转同步deferred处理
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *       2 dom结循环创建
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *       创建的四种行为
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *          1 默认创建结构绑定事件
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *          2 用于预先创建activityMode模式,分发动画与事件
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *          3 递归创建,关联子热点
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *          4 ppt文字动画,不创建主体结构,递归子热点
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  A 递归处理PPT动画
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  B 处理同步音频
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ******************************************/

	var _index = __webpack_require__(75);

	var _index2 = _interopRequireDefault(_index);

	var _index3 = __webpack_require__(59);

	var _index4 = _interopRequireDefault(_index3);

	var _index5 = __webpack_require__(71);

	var _index6 = _interopRequireDefault(_index5);

	var _index7 = __webpack_require__(69);

	var _index8 = _interopRequireDefault(_index7);

	var _fix = __webpack_require__(15);

	var _event = __webpack_require__(14);

	var _index9 = __webpack_require__(62);

	var _index10 = _interopRequireDefault(_index9);

	var _task = __webpack_require__(73);

	var _task2 = _interopRequireDefault(_task);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 处理拖动对象
	 * @return {[type]} [description]
	 */
	function accessDrop(eventData, callback) {
	    if (eventData && eventData.dragDrop) {
	        callback(eventData.dragDrop);
	    }
	}

	var Activity = function () {

	    /**
	     * activity触发器类
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    function Activity(data) {
	        _classCallCheck(this, Activity);

	        _.extend(this, data);

	        /**
	         * 2016.4.11
	         * 检测是所有的子任务必须完成
	         * 因为canvas模式导致
	         * 任务必须等待context上下创建
	         * context就是pixi的直接对象，精灵..都是异步的
	         */
	        this.nextTask = (0, _task2.default)(this.noticeComplete);

	        /**
	         * 填充事件数据
	         */
	        this._fillEventData();

	        /**
	         * 保存子对象content
	         * @type {Array}
	         */
	        this.abstractContents = (0, _index10.default)(this);

	        /**
	         * 处理html文本框
	         * 2016.1.6
	         */
	        this._htmlTextBox();

	        /**
	         * 绑定事件
	         */
	        this._bindEventBehavior();

	        /**
	         * 初始化content行为
	         */
	        this._initContents();

	        /**
	         * 2016.2.26
	         * 修复妙妙学
	         * 妙妙客户端处理
	         * 点击效果的音频处理
	         * @type {Array}
	         */
	        this._fixAudio = [];

	        /**
	         * 2016.11.2
	         * 缓存点击的音频对象
	         * 这样用于优化重复点击按钮的时候触发音频
	         * @type {Array}
	         */
	        this._cacheBehaviorAudio = {};

	        /**
	         * 如果存在content
	         * 等待创建执行
	         * @param  {[type]} this.nextTask.context.length()
	         * @return {[type]}
	         */
	        if (this.nextTask.context.length()) {
	            this.nextTask.context.wait = true;
	            return this;
	        }

	        /**
	         * 如果没有pixi的异步创建
	         * 同步代码直接完成
	         */
	        this.noticeComplete();
	    }

	    /**
	     * 初始化content行为
	     * @return {[type]} [description]
	     */


	    _createClass(Activity, [{
	        key: '_initContents',
	        value: function _initContents() {

	            var pageId = this.relatedData.pageId;
	            var $containsNode = this.$containsNode;
	            var collectorHooks = this.relatedCallback.contentsHooks;
	            var pageType = this.pageType;

	            this.eachAssistContents(function (scope) {

	                var context, id, isRreRun, parameter;

	                //针对必须创建
	                if (!(context = scope.$contentNode)) {
	                    console.log('$contentNode不存在');
	                    return;
	                }

	                //如果是视觉差对象，也需要实现收集器
	                if (scope.processType === 'parallax') {
	                    collectorHooks(scope.pid, scope.id, scope);
	                    return;
	                }

	                //如果是动画才处理
	                id = scope.id;
	                isRreRun = scope.isRreRun;
	                parameter = scope.getParameter();

	                //如果不是预生成,注册动画事件
	                if (isRreRun === undefined) {
	                    //初始化动画
	                    scope.init(id, context, $containsNode, pageId, parameter, pageType);
	                }

	                //绑定DOM一些属性
	                this._toRepeatBind(id, context, isRreRun, scope, collectorHooks);
	            });
	        }

	        /**
	         * dom节点去重绑定
	         * 在每一次构建activity对象中，不重复处理content一些特性
	         * 1 翻页特性
	         * 2 注册钩子
	         * 3 预显示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_toRepeatBind',
	        value: function _toRepeatBind(id, context, isRreRun, scope, collectorHooks) {
	            var indexOf, relatedData;

	            relatedData = this.relatedData;

	            //过滤重复关系
	            //每个元素只绑定一次
	            if (-1 !== (indexOf = relatedData.createContentIds.indexOf(id))) {
	                //删除,去重
	                relatedData.createContentIds.splice(indexOf, 1);
	                //收集每一个content注册
	                collectorHooks(scope.pid, id, scope);
	                //增加翻页特性
	                this._addIScroll(scope, context);
	                //直接复位状态,针对出现动画 show/hide
	                if (isRreRun) {
	                    //直接改变元素状态
	                    context.css({
	                        'visibility': isRreRun
	                    });
	                }
	            }
	        }

	        /**
	         * 增加翻页特性
	         * 可能有多个引用关系
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: '_addIScroll',
	        value: function _addIScroll(scope, $contentNode) {
	            var _this = this;

	            var self = this,
	                contentDas = scope.contentDas;

	            /**
	             * 给外部调用处理
	             * @param  {[type]} contentNode [description]
	             * @return {[type]}             [description]
	             */
	            var makeBindLinkFunction = function makeBindLinkFunction(scrollNode) {

	                //滚动文本的互斥不显示做一个补丁处理
	                //如果是隐藏的,需要强制显示,待邦定滚动之后再还原
	                //如果是显示的,则不需要处理,
	                var $parentNode = self.getContextNode(self.makePrefix('Content', scope.pid, scope.id));
	                var visible = $parentNode.css('visibility');
	                var resetStyle = function resetStyle() {};
	                var opacity = void 0;

	                if (visible == 'hidden') {
	                    opacity = $parentNode.css('opacity');
	                    //如果设置了不透明,则简单设为可见的
	                    //否则先设为不透明,再设为可见
	                    if (opacity == 0) {
	                        $parentNode.css({
	                            'visibility': 'visible'
	                        });
	                        resetStyle = function resetStyle() {
	                            $parentNode.css({
	                                'visibility': visible
	                            });
	                        };
	                    } else {
	                        $parentNode.css({
	                            'opacity': 0
	                        }).css({
	                            'visibility': 'visible'
	                        });
	                        resetStyle = function resetStyle() {
	                            $parentNode.css({
	                                'opacity': opacity
	                            }).css({
	                                'visibility': visible
	                            });
	                        };
	                    }
	                }

	                return function () {
	                    self.iscroll = new iScroll(scrollNode, {
	                        scrollbars: true,
	                        fadeScrollbars: true
	                    });
	                    resetStyle();
	                    resetStyle = null;
	                    $parentNode = null;
	                    scrollNode = null;
	                };
	            };

	            var bindIscroll = function bindIscroll() {
	                $contentNode.css('overflow', 'hidden'); //增加元素溢出隐藏处理
	                $contentNode.children().css('height', ''); //去掉子元素高度，因为有滚动文本框
	                _this.relatedCallback.iscrollHooks.push(makeBindLinkFunction($contentNode[0]));
	            };

	            //增加卷滚条标记
	            //但是svg如果没有内容除外
	            if (contentDas.isScroll) {
	                var hasSVG = $contentNode.find('svg');
	                if (hasSVG) {
	                    //必须保证svg有数据
	                    if (hasSVG.text()) {
	                        bindIscroll();
	                    }
	                }
	                //如果不是svg数据，直接绑定
	                else {
	                        bindIscroll();
	                    }
	            }

	            //如果是图片则补尝允许范围内的高度
	            if (!contentDas.mask || !contentDas.isGif) {
	                $contentNode.find && $contentNode.find('img').css({
	                    'height': contentDas.scaleHeight
	                });
	            }
	        }

	        /**
	         * 制作一个查找标示
	         * @return {[type]}
	         */

	    }, {
	        key: 'makePrefix',
	        value: function makePrefix(name, pid, id) {
	            return name + "_" + pid + "_" + id;
	        }

	        /**
	         * 从文档碎片中找到对应的dom节点
	         * 查找的范围
	         * 1 文档根节点
	         * 2 文档容器节点
	         * @param  {[type]} prefix [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: 'getContextNode',
	        value: function getContextNode(prefix, type) {
	            var node = void 0,
	                $node = void 0,
	                containerPrefix = void 0,
	                contentsFragment = void 0;

	            //dom模式
	            contentsFragment = this.relatedData.contentsFragment;
	            if (node = contentsFragment[prefix]) {
	                $node = $(node);
	            } else {
	                //容器处理
	                if (containerPrefix = this.relatedData.containerPrefix) {
	                    _.each(containerPrefix, function (containerName) {
	                        node = contentsFragment[containerName];
	                        $node = $(node).find('#' + prefix);
	                        if ($node.length) {
	                            return;
	                        }
	                    });
	                }
	            }
	            return $node;
	        }

	        /**
	         * 复位独立动画
	         * 提供快速翻页复用
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_resetAloneAnim',
	        value: function _resetAloneAnim() {
	            //复位拖动对象
	            accessDrop(this.eventData, function (drop) {
	                drop.reset();
	            });
	        }

	        /**
	         * 动画运行之后
	         * 1 创建一个新场景
	         * 2 执行跳转到收费提示页面
	         * 3 触发搜索工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_relevantOperation',
	        value: function _relevantOperation() {

	            var scenarioInfo, eventContentId;

	            //触发事件的content id
	            if (this.eventData) {
	                eventContentId = this.eventData.eventContentId;
	            }

	            if (eventContentId) {

	                //查找出当前节的所有信息
	                if (scenarioInfo = this.relatedData.seasonRelated[eventContentId]) {

	                    //如果存在搜索栏触发
	                    if (scenarioInfo.SearchBar) {
	                        this.createSearchBar();
	                        return;
	                    }

	                    //如果存在书签
	                    if (scenarioInfo.BookMarks) {
	                        this.createBookMark();
	                        return;
	                    }

	                    //处理新的场景
	                    if (scenarioInfo.seasonId || scenarioInfo.chapterId) {
	                        setTimeout(function () {
	                            Xut.View.LoadScenario({
	                                'scenarioId': scenarioInfo.seasonId,
	                                'chapterId': scenarioInfo.chapterId
	                            });
	                        }, (0, _fix.hasAudioes)() ? 1000 : 0);
	                        return;
	                    }

	                    // console.log('content跳转信息出错',scenarioInfo)
	                }
	            }
	        }

	        /**
	         * 保证正确遍历
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'eachAssistContents',
	        value: function eachAssistContents(callback) {
	            _.each(this.abstractContents, function (scope) {
	                callback.call(this, scope);
	            }, this);
	        }

	        /**
	         * 运行动画
	         * @param  {[type]} outComplete [动画回调]
	         * @return {[type]}             [description]
	         * evenyClick 每次都算有效点击
	         */

	    }, {
	        key: 'runAnimation',
	        value: function runAnimation(outComplete, evenyClick) {

	            var self = this;
	            var pageId = this.relatedData.pageId;

	            if (evenyClick) {
	                this.preventRepeat = false;
	            }

	            //防止重复点击
	            if (this.preventRepeat) {
	                return false;
	            }

	            this.preventRepeat = true;

	            //如果没有运行动画
	            if (!this.seed.animation) {
	                this.preventRepeat = false;
	                this._relevantOperation();
	                return;
	            }

	            //创建的无行为content
	            var partContentRelated = this.relatedData.partContentRelated;

	            //制作作用于内动画完成
	            //等待动画完毕后执行动作or场景切换
	            var captureAnimComplete = this.captureAnimComplete = function (counts) {
	                return function (scope) {
	                    //动画结束,删除这个hack
	                    scope && scope.$contentNode && scope.$contentNode.removeProp && scope.$contentNode.removeProp('animOffset');

	                    //如果快速翻页
	                    //运行动画的时候，发现不是可视页面
	                    //需要关闭这些动画
	                    var closeAnim = pageId != Xut.Presentation.GetPageId();

	                    if (closeAnim && scope) {
	                        scope.stop && scope.stop(pageId);
	                        scope.reset && scope.reset();
	                    }

	                    //捕获动画状态
	                    if (counts === 1) {
	                        if (closeAnim) {
	                            //复位动画
	                            self._resetAloneAnim();
	                        }
	                        self.preventRepeat = false;
	                        self._relevantOperation();
	                        outComplete && outComplete();
	                        self.captureAnimComplete = null;
	                    } else {
	                        --counts;
	                    }
	                };
	            }(this.abstractContents.length);

	            /**
	             * 如果是preRun处理
	             * @return {Boolean} [description]
	             */
	            var isRreRunPocess = function isRreRunPocess(scope) {
	                //针对空跳过处理
	                if (partContentRelated && partContentRelated.length && -1 !== partContentRelated.indexOf(scope.id)) {
	                    captureAnimComplete();
	                } else {
	                    //必须要修改
	                    if (scope.$contentNode) {
	                        if (scope.canvasMode) {
	                            console.log('canvsa isRreRunPocess');
	                            //直接改变元素状态
	                            //scope.$contentNode.view.style.visible = scope.isRreRun === 'visible' ? true : false;
	                        } else {
	                            //因为执行的顺序问题，动画与页面零件
	                            //isscroll标记控制
	                            if (!scope.$contentNode.attr('isscroll')) {
	                                scope.$contentNode.css({
	                                    'visibility': scope.isRreRun
	                                });
	                            }
	                        }
	                    }
	                    captureAnimComplete();
	                }
	            };

	            //执行动画
	            this.eachAssistContents(function (scope) {
	                if (scope.isRreRun) {
	                    isRreRunPocess(scope);
	                } else {

	                    //标记动画正在运行
	                    scope.$contentNode && scope.$contentNode.prop && scope.$contentNode.prop({
	                        'animOffset': scope.$contentNode.offset()
	                    });

	                    //ppt动画
	                    //ppt音频
	                    scope.play(function () {
	                        captureAnimComplete(scope);
	                    });
	                }
	            });

	            this.runState = true;
	        }

	        /**
	         * 停止动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stopAnimation',
	        value: function stopAnimation() {
	            var pageId = this.relatedData.pageId;
	            this.runState = false;
	            this.eachAssistContents(function (scope) {
	                !scope.isRreRun && scope.stop && scope.stop(pageId);
	            });
	        }

	        /**
	         * 销毁动画
	         * @param  {[type]} elementCallback [description]
	         * @return {[type]}                 [description]
	         */

	    }, {
	        key: '_destroyAnimation',
	        value: function _destroyAnimation(elementCallback) {
	            //销毁拖动对象
	            accessDrop(this.eventData, function (drop) {
	                drop.destroy();
	            });
	            this.eachAssistContents(function (scope) {
	                if (scope.destroy) {
	                    scope.destroy();
	                }
	                elementCallback && elementCallback(scope);
	            });
	        }

	        /**
	         * 自动运行
	         * @param  {[type]} outComplete [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: 'autoPlay',
	        value: function autoPlay(outComplete) {
	            var eventData = this.eventData;
	            if (eventData && eventData.eventName === 'auto') {
	                this.runAnimation(outComplete);
	            } else {
	                outComplete();
	            }
	        }

	        /**
	         * 复位状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            this.eachAssistContents(function (scope) {
	                !scope.isRreRun && scope.reset && scope.reset(); //ppt动画
	            });

	            this._resetAloneAnim();
	        }

	        /**
	         * 停止动作
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            if (this.runState) {
	                this.stopAnimation();
	            }
	            this.preventRepeat = false;

	            //复位盒子
	            if (this.htmlBoxInstance.length) {
	                _.each(this.htmlBoxInstance, function (instance) {
	                    instance.removeBox();
	                });
	            }

	            //修复妙妙客户端
	            //没有点击音频结束的回调
	            //最多允许播放5秒
	            if (this._fixAudio.length) {
	                _.each(this._fixAudio, function (instance) {
	                    setTimeout(function () {
	                        instance.end();
	                    }, 5000);
	                });
	                this._fixAudio = [];
	            }
	        }

	        //销毁
	        //提供一个删除回调
	        //用于处理浮动对象的销毁

	    }, {
	        key: 'destroy',
	        value: function destroy(elementCallback) {

	            //销毁绑定事件
	            if (this.eventData.eventContext) {
	                (0, _event.destroyContentEvent)(this.eventData);
	                this.eventData.eventContext = null;
	            }

	            //2016.1.7
	            //如果有文本框事件
	            //一个activity允许有多个文本框
	            //所以是数组索引
	            if (this.htmlBoxInstance.length) {
	                _.each(this.htmlBoxInstance, function (instance) {
	                    instance.destroy();
	                });
	                this.htmlBoxInstance = null;
	            }

	            //销毁动画
	            this._destroyAnimation(elementCallback);
	            this.abstractContents = null;

	            //iscroll销毁
	            if (this.iscroll) {
	                this.iscroll.destroy();
	                this.iscroll = null;
	            }

	            //销毁搜索框
	            if (this.searchBar) {
	                this.searchBar.destroy();
	                this.searchBar = null;
	            }

	            //销毁书签
	            if (this.bookMark) {
	                this.bookMark.destroy();
	                this.bookMark = null;
	            }

	            //如果有点击音频
	            if (Object.keys(this._cacheBehaviorAudio).length) {
	                for (var key in this._cacheBehaviorAudio) {
	                    var audio = this._cacheBehaviorAudio[key];
	                    if (audio) {
	                        audio.end();
	                        this._cacheBehaviorAudio[key] = null;
	                    }
	                }
	            }

	            this.$containsNode = null;
	        }
	    }]);

	    return Activity;
	}();

	exports.default = Activity;


	var activitProto = Activity.prototype;

	(0, _index2.default)(activitProto);
	(0, _index4.default)(activitProto);
	(0, _index6.default)(activitProto);
	(0, _index8.default)(activitProto);

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (activitProto) {

	    activitProto.createSearchBar = function () {
	        var options = {
	            parent: this.$containsNode
	        };
	        if (this.searchBar) {
	            //如果上次只是隐藏则可以恢复
	            this.searchBar.restore();
	        } else {
	            this.searchBar = new _searchbar.SearchBar(options);
	        }
	    };
	};

	var _searchbar = __webpack_require__(72);

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.SearchBar = SearchBar;

	var _dom = __webpack_require__(5);

	//图标
	var icons = {
	    search: 'images/icons/search.svg',
	    clear: 'images/icons/clear.svg',
	    exit: 'images/icons/exit.svg'
	}; /**
	    * 搜索栏
	    * 方便用户更加便捷的找到所需要的信息
	    *
	    */

	function SearchBar(options) {
	    //父容器
	    this.parent = options.parent;
	    //提示信息
	    this.tips = options.tips;
	    this.init();
	}

	/**
	 * 初始化
	 * @return {[type]} [description]
	 */
	SearchBar.prototype.init = function () {
	    var $box = this.searchForm(),
	        dom = this.parent[0];

	    this.parent.append($box);
	    this.searchBox = $box;
	    this.resultBox = $box.find('.xut-search-result');
	    this.input = $box.find('.xut-search-input');
	    this.searchBtn = $box.find('.xut-search-btn');

	    //用户操作事件邦定
	    (0, _dom.$$on)(dom, {
	        end: this
	    });

	    //即时搜索
	    dom.addEventListener('keyup', this, false);
	};

	/**
	 * 创建搜索框
	 * @return {[object]} [jquery生成的dom对象]
	 */
	SearchBar.prototype.searchForm = function () {
	    var W = window.innerWidth * 0.3,
	        H = window.innerHeight;
	    var text = this.tips || '请在搜索框中输入要搜索的关键字';

	    var box = '<div class="xut-form-search">' + '<div class="xut-form-search-wrap">' + '<div style="height:17%;">' + '<div style="height:20%"></div>' + '<div class="xut-search-row">' + '<input type="text" class="xut-search-input">' + '<div class="xut-search-btn" style="background-image: url(' + icons.search + ')"></div>' + '</div>' + '<p class="xut-search-tips" style="line-height:' + Math.round(H * 0.06) + 'px">' + text + '</p>' + '</div>' + '<div style="height:76%">' + '<ul class="xut-search-result"></ul>' + '</div>' + '<div style="height:7%">' + '<div class="xut-search-exit" style="background-image: url(' + icons.exit + ')"></div>' + '</div>' + '</div></div>';

	    var $box = $(box);

	    $box.css('width', W < 200 ? 200 : W);

	    return $box;
	};

	/**
	 * 搜索
	 * @param {string} [keyword] [搜索关键字]
	 */
	SearchBar.prototype.search = function (keyword) {
	    var data = Xut.data.Chapter,
	        ln = data.length,
	        list = '',
	        rs,
	        pageId,
	        seasonId;

	    if (!keyword) {
	        this.resultBox.html('');
	        return;
	    }

	    for (var i = 0; i < ln; i++) {
	        rs = data.item(i);
	        if (rs.chapterTitle.indexOf(keyword) > -1) {
	            pageId = rs._id;
	            seasonId = rs.seasonId;
	            list += '<li><a class="xut-search-link" data-mark="' + seasonId + '-' + pageId + '" href="javascript:0">' + rs.chapterTitle + '</a></li>';
	        }
	    }

	    this.resultBox.html(list);
	};

	/**
	 * 切换搜索按钮图标
	 * @param  {[type]} icon [图标路径]
	 * @return {[type]}      [description]
	 */
	SearchBar.prototype.iconManager = function (icon) {
	    if (this.isChange) {
	        this.searchBtn.css('background-image', 'url(' + icon + ')');
	    }
	};

	/**
	 * 跳转到搜索结果页
	 * @param  {[type]} target [description]
	 * @return {[type]}        [description]
	 */
	SearchBar.prototype.searchLink = function (target) {
	    if (!target || !target.dataset) return;
	    var mark = target.dataset.mark.split('-'),
	        seasonId = mark[0],
	        pageId = mark[1];

	    Xut.View.LoadScenario({
	        'scenarioId': seasonId,
	        'chapterId': pageId
	    });
	};

	/**
	 * 邦定事件
	 * @param  {[type]} evt [事件]
	 * @return {[type]}     [description]
	 */
	SearchBar.prototype.handleEvent = function (evt) {
	    var target = evt.target;
	    switch (target.className) {
	        case 'xut-search-btn':
	            //点击搜索
	            this.search(this.input.val());
	            this.isChange = true;
	            this.iconManager(icons.clear);
	            break;
	        case 'xut-search-input':
	            //实时搜索
	            this.search(target.value);
	            //还原按钮图标
	            this.iconManager(icons.search);
	            this.isChange = false;
	            break;
	        case 'xut-search-exit':
	            //关闭搜索框
	            this.exit();
	            break;
	        case 'xut-search-link':
	            //跳转
	            this.searchLink(target);
	            break;
	        default:
	            break;
	    }
	};

	/**
	 * 关闭搜索框
	 * @return {[type]} [description]
	 */
	SearchBar.prototype.exit = function () {
	    this.input.val('');
	    this.resultBox.empty();
	    this.searchBox.hide();
	};

	/**
	 * 恢复搜索框
	 */
	SearchBar.prototype.restore = function () {
	    var searchBox = this.searchBox;
	    searchBox && searchBox.show();
	};

	/**
	 * 销毁搜索框
	 * @return {[type]} [description]
	 */
	SearchBar.prototype.destroy = function () {
	    var dom = this.parent[0];
	    dom.removeEventListener('keyup', this, false);
	    dom.removeEventListener('touchend', this, false);
	    dom.removeEventListener('mouseup', this, false);

	    this.searchBox.remove();
	    this.searchBox = null;
	    this.resultBox = null;
	    this.searchBtn = null;
	    this.input = null;
	    this.parent = null;
	};

/***/ },
/* 73 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (callback) {
	    return {
	        context: {
	            /**
	             * 状态表示
	             */

	            /**
	             * 是否等待创建
	             * @type {Boolean}
	             */
	            wait: false,

	            /**
	             * 是否完成创建
	             * @type {Boolean}
	             */
	            statas: false,

	            /**
	             * id合集
	             * @type {Array}
	             */
	            _ids: [],

	            /**
	             * 事件
	             * @type {Array}
	             */
	            event: [],

	            /**
	             * 预执行
	             * @type {Object}
	             */
	            pre: {}, //预执行


	            /**
	             * 检测是否完成
	             * @return {[type]} [description]
	             */
	            check: function check() {
	                var total = this.length();
	                if (!total.length) {
	                    //完成创建
	                    this.statas = true;
	                }
	                //如果已经等待
	                if (this.wait) {
	                    callback && callback();
	                    return;
	                }
	                // //创建比流程先执行完毕
	                // //一般几乎不存在
	                // //但是不排除
	                // if (!this.wait && this.statas) {
	                //     this.wait = true;
	                //     return;
	                // }
	            },
	            add: function add(id) {
	                if (-1 === this._ids.indexOf(id)) {
	                    this._ids.push(id);
	                }
	            },
	            remove: function remove(id) {
	                if (!id) {
	                    return;
	                }
	                var index = this._ids.indexOf(id);
	                var val = this._ids.splice(index, 1);
	                this.check(val);
	                return val;
	            },
	            length: function length() {
	                return this._ids.length;
	            }
	        }
	    };
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * html文本框
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param  {[type]} ){} [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @return {[type]}       [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	var _index = __webpack_require__(1);

	var _event = __webpack_require__(14);

	var _dom = __webpack_require__(5);

	var _stroage = __webpack_require__(17);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var docElement = document.documentElement;

	//默认字体
	var defaultFontSize = void 0;

	try {
	    defaultFontSize = parseInt(getComputedStyle(docElement).fontSize);
	} catch (er) {
	    defaultFontSize = 16;
	}

	//新的字体大小
	var newFontSize = void 0;

	var whiteObject = {
	    "rgb(255, 255, 255)": true,
	    "#ffffff": true,
	    "#FFFFFF": true,
	    "#fff": true,
	    "#FFF": true
	};

	/**
	 * 字体大小
	 * @type {Array}
	 */
	var sizeArray = ["1", "1.5", "2.0"];

	var getFontSize = function getFontSize() {
	    newFontSize = defaultFontSize * _index.config.proportion.width;
	    return [Math.floor(newFontSize * 1.5), Math.floor(newFontSize * 2.0), Math.floor(newFontSize * 2.5)];
	};

	/**
	 * 工具栏布局
	 * @return {[type]} [description]
	 */
	function toolBar(fontSize) {
	    var baseValue1 = fontSize[0];
	    var baseValue2 = fontSize[1];
	    var baseValue3 = fontSize[2];
	    var boxHTML = '<div class="htmlbox_close_container">\n            <a class="htmlbox_close"></a>\n        </div>\n        <ul class="htmlbox_fontsizeUl">\n            <li>\n                <a class="htmlbox_small"\n                   style="width:' + baseValue1 + 'px;height:' + baseValue1 + 'px;margin-top:-' + baseValue1 / 2 + 'px"></a>\n            </li>\n            <li>\n                <a class="htmlbox_middle"\n                   style="width:' + baseValue2 + 'px;height:' + baseValue2 + 'px;margin-top:-' + baseValue2 / 2 + 'px"></a></li>\n            <li>\n                <a class="htmlbox_big"\n                   style="width:' + baseValue3 + 'px;height:' + baseValue3 + 'px;margin-top:-' + baseValue3 / 2 + 'px"></a>\n            </li>\n        </ul>';

	    return String.styleFormat(boxHTML);
	}

	/**
	 * 创建盒子容器
	 * @return {[type]} [description]
	 */
	function createWapper(boxHeight, context, iscrollName, textContent) {
	    var wapper = '<div class="htmlbox-container">\n            <div class="htmlbox-toolbar" style="height:' + boxHeight + 'px;line-height:' + boxHeight + 'px;">' + context + '</div>\n            <div class="' + iscrollName + '" style="overflow:hidden;position:absolute;width:100%;height:92%;">\n                <ul>' + textContent + '</ul>\n            </div>\n        </div>';
	    return String.styleFormat(wapper);
	}

	var HtmlBox = function () {
	    function HtmlBox(contentId, $contentNode) {
	        _classCallCheck(this, HtmlBox);

	        this.contentId = contentId;
	        this.$contentNode = $contentNode;

	        var self = this;

	        //事件对象引用
	        var eventHandler = function eventHandler(eventReference, _eventHandler) {
	            self.eventReference = eventReference;
	            self.eventHandler = _eventHandler;
	        };

	        //绑定点击事件
	        (0, _event.bindContentEvent)({
	            'eventRun': function eventRun() {
	                Xut.View.HideToolBar('pageNumber');
	                self._init(contentId, $contentNode);
	            },
	            'eventHandler': eventHandler,
	            'eventContext': $contentNode,
	            'eventName': "tap",
	            'domMode': true
	        });
	    }

	    _createClass(HtmlBox, [{
	        key: '_init',
	        value: function _init(contentId, $contentNode) {
	            var self = this;

	            self._adjustColor();

	            //移除偏移量 存在偏移量造成文字被覆盖
	            var textContent = $contentNode.find(">").html();
	            textContent = textContent.replace(/translate\(0px, -\d+px\)/g, 'translate(0px,0px)');

	            var iscrollName = "htmlbox-iscroll-" + contentId;

	            //缓存名
	            this.storageName = iscrollName + _index.config.appId;

	            var fontSize = getFontSize();

	            //工具栏的高度必须大于最大的字体大小
	            var boxHeight = fontSize[2] + 2;
	            //关闭按钮的top值
	            var closeTop = Math.floor(boxHeight / 2);

	            //获取保存的字体值
	            var initValue = (0, _stroage.$$get)(this.storageName);
	            if (initValue) {
	                this._adjustSize(initValue);
	            } else {
	                //默认
	                this._adjustSize(newFontSize);
	            }

	            /**
	             * 创建容器
	             * @type {[type]}
	             */
	            this.$htmlbox = $(createWapper(boxHeight, toolBar(fontSize), iscrollName, textContent));

	            $contentNode.after(this.$htmlbox);

	            //修改::before ::after伪元素top值 确保关闭按钮垂直居中
	            document.styleSheets[0].addRule('.htmlbox_close::before', 'top:' + closeTop + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::before { top:' + closeTop + 'px }', 0);
	            document.styleSheets[0].addRule('.htmlbox_close::after', 'top:' + closeTop + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::after { top:' + closeTop + 'px }', 0);

	            //修正htmlbox位置
	            this._relocateToolbar(iscrollName);
	            //卷滚
	            this._createIscroll(this.$htmlbox, iscrollName);

	            /**
	             * 绑定事件上下文呢
	             * @type {[type]}
	             */
	            this.eventContext = this.$htmlbox.find('.htmlbox-toolbar')[0];

	            /**
	             * 改变字体与刷新卷滚
	             * @param  {[type]} fontsize [description]
	             * @return {[type]}          [description]
	             */
	            var change = function change(fontsize) {
	                self._adjustSize(fontsize * newFontSize, true);
	                self.iscroll && self.iscroll.refresh();
	            };

	            /**
	             * 关闭
	             * @return {[type]} [description]
	             */
	            var colse = function colse() {
	                self._restoreColor();
	                //还原跟字体大小
	                self._adjustSize(defaultFontSize);
	                self.removeBox();
	                Xut.View.ShowToolBar('pageNumber');
	            };

	            //处理器
	            var process = {
	                htmlbox_close_container: colse,
	                htmlbox_close: colse,
	                htmlbox_small: function htmlbox_small() {
	                    change(sizeArray[0]);
	                },
	                htmlbox_middle: function htmlbox_middle() {
	                    change(sizeArray[1]);
	                },
	                htmlbox_big: function htmlbox_big() {
	                    change(sizeArray[2]);
	                }
	            };

	            //冒泡匹配按钮点击
	            this.start = function (e) {
	                var className = e.target.className;
	                process[className] && process[className]();
	            };

	            (0, _dom.$$on)(this.eventContext, {
	                start: this.start
	            });
	        }

	        /**
	         * 遍历p span文字标签 调整字体颜色
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_adjustColor',
	        value: function _adjustColor() {
	            this.textLabelArray = ['p', 'span'];
	            var self = this;
	            _.each(self.textLabelArray, function (text) {
	                _.each(self.$contentNode.find(text), function (el) {
	                    var formerColor = getComputedStyle(el).color;
	                    //若字体颜色为白色 调整为黑色
	                    if (whiteObject.hasOwnProperty(formerColor)) {
	                        el.hasFormerColor = true;
	                        el.style.color = "black";
	                    }
	                });
	            });
	        }

	        /**
	         * 调整字体大小
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_adjustSize',
	        value: function _adjustSize(value, save) {
	            value = parseInt(value);
	            docElement.style.fontSize = value + 'px';
	            save && (0, _stroage.$$set)(this.storageName, value);
	        }

	        /**
	         * 恢复放大过的字体颜色
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_restoreColor',
	        value: function _restoreColor() {
	            var self = this;
	            _.each(self.textLabelArray, function (text) {
	                _.each(self.$contentNode.find(text), function (el) {
	                    //将字体由黑色恢复为白色
	                    if (el.hasFormerColor) {
	                        el.style.color = "white";
	                        el.hasFormerColor = false;
	                    }
	                });
	            });
	        }

	        /**
	         * 修正htmlbox位置
	         * @param  {[type]} iscrollName [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_relocateToolbar',
	        value: function _relocateToolbar(iscrollName) {
	            //修正模式2下屏幕溢出高度  
	            var viewSize = _index.config.viewSize;
	            var left = viewSize.overflowWidth && Math.abs(viewSize.left) || 0;
	            var top = viewSize.overflowHeight && Math.abs(viewSize.top) || 0;
	            this.$htmlbox[0].style.cssText += "margin-top:" + top + "px";

	            //修正模式3下屏幕溢出宽度
	            //1.修正关闭按钮::before ::after伪元素left值 确保关闭按钮水平居中
	            //首先恢复到最开始的left:2%状态
	            document.styleSheets[0].addRule('.htmlbox_close::before', 'left:2%');
	            document.styleSheets[0].insertRule('.htmlbox_close::before { left:2% }', 0);
	            document.styleSheets[0].addRule('.htmlbox_close::after', 'left:2%');
	            document.styleSheets[0].insertRule('.htmlbox_close::after { left:2% }', 0);
	            var formerLeft = window.getComputedStyle(this.$htmlbox.find('.htmlbox_close')[0], '::before').getPropertyValue('left');
	            var currentLeft = parseInt(formerLeft) + left;

	            //开始修正
	            document.styleSheets[0].addRule('.htmlbox_close::before', 'left:' + currentLeft + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::before { left:' + currentLeft + 'px }', 0);
	            document.styleSheets[0].addRule('.htmlbox_close::after', 'left:' + currentLeft + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::after { left:' + currentLeft + 'px }', 0);
	            //2.修正字体放大ul按钮
	            this.$htmlbox.find(".htmlbox_fontsizeUl")[0].style.cssText += "margin-right:" + left + "px";
	            //3.修正文本框
	            this.$htmlbox.find("." + iscrollName)[0].style.cssText += "margin-left:" + left + "px;";
	            var formerScrollWidth = window.getComputedStyle(this.$htmlbox.find("." + iscrollName)[0]).getPropertyValue('width');

	            var currentScrollWidth = parseInt(formerScrollWidth) - 2 * left;

	            this.$htmlbox.find("." + iscrollName).width(currentScrollWidth);
	        }

	        /**
	         * 卷滚
	         * @param  {[type]} iscrollName [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_createIscroll',
	        value: function _createIscroll($htmlbox, iscrollName) {
	            var ulHeight = $htmlbox.find('.' + iscrollName + ' >ul').css('height');
	            var htmlboxHeight = $htmlbox.find('.' + iscrollName).css('height');

	            //溢出，增加卷滚
	            if (parseInt(ulHeight) > parseInt(htmlboxHeight)) {
	                this.iscroll = new iScroll("." + iscrollName, {
	                    scrollbars: true,
	                    fadeScrollbars: true
	                });
	            }
	        }

	        /**
	         * 移除盒子
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'removeBox',
	        value: function removeBox() {
	            (0, _dom.$$off)(this.eventContext, {
	                start: this.start
	            });
	            this.$htmlbox && this.$htmlbox.remove();

	            if (this.iscroll) {
	                this.iscroll.destroy();
	                this.iscroll = null;
	            }
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            _.each(this.eventReference, function (off) {
	                off("tap");
	            });
	            this.removeBox();
	        }
	    }]);

	    return HtmlBox;
	}();

	exports.default = HtmlBox;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (activitProto) {

	    /**
	     * 检测是HTML文本框处理
	     * @return {[type]} [description]
	    */
	    activitProto._htmlTextBox = function () {
	        var self = this;
	        var relatedData = this.relatedData;
	        var contentHtmlBoxIds = relatedData.contentHtmlBoxIds;
	        var contentId;
	        var contentName;
	        var $contentNode;
	        //文本框实例对象
	        //允许一个activity有多个
	        this.htmlBoxInstance = [];

	        //创建文本框对象
	        if (contentHtmlBoxIds.length && relatedData.contentDas) {
	            _.each(relatedData.contentDas, function (cds) {
	                if (~contentHtmlBoxIds.indexOf(cds._id)) {
	                    contentId = cds._id;
	                    contentName = self.makePrefix('Content', self.pid, contentId);
	                    //找到对应绑定事件的元素
	                    $contentNode = self.getContextNode(contentName);
	                    if (!$contentNode.attr("data-htmlbox")) {
	                        //构建html文本框对象
	                        self.htmlBoxInstance.push(new _htmlbox2.default(contentId, $contentNode));
	                        //增加htmlbox标志去重
	                        //多个actictiy共享问题
	                        $contentNode.attr("data-htmlbox", "true");
	                    }
	                }
	            });
	        }
	    };
	};

	var _htmlbox = __webpack_require__(74);

	var _htmlbox2 = _interopRequireDefault(_htmlbox);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Action = Action;
	/**
	 * 音频动作
	 * @param  {[type]} global [description]
	 * @return {[type]}        [description]
	 */

	//音频动作
	//替换背景图
	//指定动画
	function Action(options) {

	    var audioNode = document.querySelector('#Audio_' + options.audioId);

	    //页面从属
	    var pageType = audioNode.getAttribute('data-belong');

	    //切换背景
	    function toggle(linker) {
	        audioNode.style.backgroundImage = 'url(' + Xut.config.pathAddress + linker + ')';
	    }

	    function run(ids) {
	        ids = ids.split(',');
	        Xut.Assist.Run(pageType, ids);
	    }

	    function stop(ids) {
	        ids = ids.split(',');
	        Xut.Assist.Stop(pageType, ids);
	    }
	    return {
	        play: function play() {
	            options.startImg && toggle(options.startImg);
	            options.startScript && run(options.startScript);
	        },
	        pause: function pause() {
	            options.stopImg && toggle(options.stopImg);
	            options.stopScript && stop(options.startScript);
	        },
	        destroy: function destroy() {
	            audioNode = null;
	        }
	    };
	}

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _action = __webpack_require__(76);

	var _subtitle = __webpack_require__(78);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 音频工厂类
	 * @param {[type]} options [description]
	 */
	var Base = function () {
	    function Base() {
	        _classCallCheck(this, Base);
	    }

	    /**
	     * 构建之前关数据
	     * @param  {[type]} trackId [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}         [description]
	     */


	    _createClass(Base, [{
	        key: 'preRelated',
	        value: function preRelated(trackId, options) {
	            //完成end后 外部回调删除这个对象
	            //单独调用引用对象
	            //传递一个 options.complete
	            this.innerCallback = options.innerCallback;
	            //仅运行一次
	            //外部调用
	            this.outerCallback = trackId == 9999 ? options.complete : null;
	        }

	        /**
	         * 构建之后关数据
	         * @param  {[type]} options     [description]
	         * @param  {[type]} controlDoms [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: 'afterRelated',
	        value: function afterRelated(options, controlDoms) {
	            var _this = this;

	            //音频重复播放次数
	            if (options.data && options.data.repeat) {
	                this.repeat = Number(options.data.repeat); //需要重复
	            }
	            //音频动作
	            if (options.action) {
	                this.acitonObj = (0, _action.Action)(options);
	            }
	            //字幕对象
	            if (options.subtitles && options.subtitles.length > 0) {
	                //创建字幕对象
	                this.subtitleObject = new _subtitle.Subtitle(options, controlDoms, function (cb) {
	                    return _this.getAudioTime(cb);
	                });
	            }

	            //如果有外部回调处理
	            if (this.outerCallback) {
	                this.outerCallback.call(this);
	            }
	        }

	        /**
	         * 运行成功失败后处理方法
	         * phoengap会调用callbackProcess
	         * @param  {[type]} sysCommand [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: 'callbackProcess',
	        value: function callbackProcess(sysCommand) {
	            if (this.outerCallback) {
	                //外部调用结束
	                this.end();
	            } else {
	                //安卓没有重复播放
	                //phonegap未处理
	                if (!Xut.plat.isAndroid && this.repeat) {
	                    //如果需要重复
	                    this.repeatProcess();
	                } else {
	                    //外部清理对象
	                    //audioManager中直接删当前对象
	                    this.innerCallback && this.innerCallback(this);
	                }
	            }
	        }

	        /**
	         * 重复处理
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'repeatProcess',
	        value: function repeatProcess() {
	            --this.repeat;
	            this.play();
	        }

	        /**
	         * 播放
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'play',
	        value: function play() {
	            //flash模式不执行
	            if (this.audio && !this.isFlash) {
	                this.status = 'playing';
	                this.audio.play();
	            }
	            this.acitonObj && this.acitonObj.play();
	        }

	        /**
	         * 停止
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'pause',
	        value: function pause() {
	            this.status = 'paused';
	            this.audio.pause();
	            this.acitonObj && this.acitonObj.pause();
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'end',
	        value: function end() {
	            this.status = 'ended';
	            this.audio.end();
	            this.audio = null;
	            this.acitonObj && this.acitonObj.destroy();
	        }

	        /**
	         * 相关
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroyRelated',
	        value: function destroyRelated() {
	            //销毁字幕
	            if (this.subtitleObject) {
	                this.subtitleObject.destroy();
	                this.subtitleObject = null;
	            }
	            //动作
	            if (this.acitonObj) {
	                this.acitonObj.destroy();
	                this.acitonObj = null;
	            }
	        }
	    }]);

	    return Base;
	}();

	exports.default = Base;

/***/ },
/* 78 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 音频字幕
	 * @param  {[type]} global [description]
	 * @return {[type]}        [description]
	 */
	//字幕检测时间
	var Interval = 50;

	var getStyles = function getStyles(elem, name) {
	    var styles = elem.ownerDocument.defaultView.getComputedStyle(elem, null);
	    return styles.getPropertyValue(name);
	};

	/**
	 * 字幕类
	 *   音频实例
	 * options 参数
	 */

	var Subtitle = function () {
	    function Subtitle(options, controlDoms, getAudioTime) {
	        _classCallCheck(this, Subtitle);

	        var visibility = void 0;
	        var orgAncestorVisibility = void 0;

	        //快速处理匹配数据
	        var checkData = {};

	        this.getAudioTime = getAudioTime;
	        this.options = options;
	        this.parents = controlDoms.parents;
	        this.ancestors = controlDoms.ancestors;

	        this.timer = 0;

	        //缓存创建的div节点
	        this.cacheCreateDivs = {};

	        //保存原始的属性
	        orgAncestorVisibility = this.orgAncestorVisibility = {};
	        _.each(this.ancestors, function (node, cid) {
	            visibility = getStyles(node, 'visibility');
	            if (visibility) {
	                orgAncestorVisibility[cid] = visibility;
	            }
	        });

	        //去重记录
	        this.recordRepart = {};

	        //phonegap getCurrentPosition得到的音频播放位置不从0开始 记录起始位置
	        this.changeValue = 0;

	        _.each(options.subtitles, function (data) {
	            checkData[data.start + '-start'] = data;
	            checkData[data.end + '-end'] = data;
	        });

	        this.createSubtitle(checkData);
	    }

	    /**
	     * 运行字幕
	     * @return {[type]}
	     */


	    _createClass(Subtitle, [{
	        key: 'createSubtitle',
	        value: function createSubtitle(checkData) {
	            var _this = this;

	            var getAudioTime = this.getAudioTime;
	            var options = this.options;

	            /**
	             * 准备创建字幕
	             * @param  {[type]} audioTime [description]
	             * @return {[type]}           [description]
	             */
	            var createAction = function createAction(audioTime) {
	                var match = void 0;
	                _.each(checkData, function (data, key) {
	                    match = key.split('-');
	                    //创建动作
	                    _this.action(match[0], audioTime, match[1], data);
	                });
	                _this.createSubtitle(checkData);
	            };

	            /**
	             * 判断不同的播放平台
	             * @return {[type]} [description]
	             */
	            var JudgePlat = function JudgePlat() {
	                getAudioTime(function (audioTime) {
	                    createAction(audioTime);
	                });
	            };

	            this.timer = setTimeout(function () {
	                JudgePlat();
	            }, Interval);
	        }

	        //执行动作
	        //创建文本框
	        //显示/隐藏

	    }, {
	        key: 'action',
	        value: function action(currentTime, audioTime, _action, data) {
	            if (audioTime > currentTime - Interval && audioTime < currentTime + Interval) {
	                //创建
	                if (!this.recordRepart[data.start] && _action === 'start') {
	                    this.recordRepart[data.start] = true;
	                    //创建字幕dom
	                    this.createDom(data);

	                    //如果是一段字幕结束处理
	                } else if (!this.recordRepart[data.end] && _action === 'end') {
	                    this.recordRepart[data.end] = true;
	                    // //隐藏
	                    var ancestorNode = this.ancestors[data.id];
	                    if (ancestorNode) {
	                        ancestorNode.style.visibility = "hidden";
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'createDom',
	        value: function createDom(data) {

	            var config = Xut.config;

	            //屏幕分辨率
	            var proportion = config.proportion;
	            var proportionWidth = proportion.width;
	            var proportionHeight = proportion.height;

	            var cid = data.id;
	            var parentNode = this.parents[cid];
	            var ancestorNode = this.ancestors[cid];
	            var preDiv = this.cacheCreateDivs[cid];
	            var preP = preDiv && preDiv.children[0];

	            //缩放
	            var sTop = data.top * proportion.top;
	            var sLeft = data.left * proportion.left;
	            var sHeight = data.height * proportion.height;
	            var sWidth = data.width * proportion.width;

	            //转换行高
	            var sLineHeight = data.lineHeight ? data.lineHeight : '100%';

	            //公用同一个contengid,已经存在
	            if (preDiv) {
	                createContent(preDiv, preP, data);
	            } else {
	                //创建父元素与子元素
	                var createDiv = document.createElement('div');
	                var createP = document.createElement('p');
	                //设置样式
	                createContent(createDiv, createP, data);
	                createDiv.appendChild(createP); //添加到指定的父元素  

	                parentNode.appendChild(createDiv);

	                //保存引用
	                this.cacheCreateDivs[cid] = createDiv;
	            }

	            //创建内容
	            function createContent(parent, p, data) {
	                createDivStyle(parent, data); //设置div
	                createPStyle(p, data);
	            }

	            //设置父容器div 字体颜色，大小，类型，位置，文本水平、垂直居中
	            function createDivStyle(parent, data) {
	                var cssText = 'position       :absolute; ' + 'display        :table;' + 'vertical-align :center;' + 'top            :{0}px;' + 'left           :{1}px;' + 'height         :{2}px;' + 'width          :{3}px;';

	                parent.style.cssText = String.format(cssText, sTop, sLeft, sHeight, sWidth);
	            }

	            //内容元素的样式
	            function createPStyle(p, data) {

	                var cssText = ' text-align     :center;' + ' display        :table-cell;' + ' vertical-align :middle;' + ' color          :{0};' + ' font-family    :{1};' + ' font-bold      :{2};' + ' font-size      :{3}px;' + ' line-height    :{4}%';

	                //设置字体间距
	                p.style.cssText = String.format(cssText, data.fontColor, data.fontName, data.fontBold, data.fontSize * proportionWidth, sLineHeight);
	                //设置文字内容
	                p.innerHTML = data.title;
	            }

	            //操作最外层的content节点
	            if (ancestorNode) {
	                var ancestorNodeValue = getStyles(ancestorNode, 'visibility');
	                if (ancestorNodeValue != 'visible') {
	                    ancestorNode.style.visibility = 'visible';
	                }
	            }
	        }

	        /**
	         * 清理音频
	         * @return {[type]}
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var self = this;
	            _.each(this.cacheCreateDivs, function (node) {
	                node.parentNode.removeChild(node);
	            });
	            //恢复初始状态
	            _.each(this.ancestors, function (node, id) {
	                var orgValue = self.orgAncestorVisibility[id];
	                var currValue = getStyles(node, 'visibility');
	                if (currValue != orgValue) {
	                    node.style.visibility = orgValue;
	                }
	            });

	            this.ancestors = null;
	            this.cacheCreateDivs = null;
	            this.changeValue = 0;
	            this.parents = null;
	            if (this.timer) {
	                clearTimeout(this.timer);
	                this.timer = 0;
	            }
	        }
	    }]);

	    return Subtitle;
	}();

	exports.Subtitle = Subtitle;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(1);

	var _translation = __webpack_require__(24);

	var _get = __webpack_require__(7);

	var _index2 = __webpack_require__(43);

	var _index3 = _interopRequireDefault(_index2);

	var _render = __webpack_require__(81);

	var _render2 = _interopRequireDefault(_render);

	var _distance = __webpack_require__(46);

	var _distance2 = _interopRequireDefault(_distance);

	var _adapter = __webpack_require__(12);

	var _pinch = __webpack_require__(39);

	var _pinch2 = _interopRequireDefault(_pinch);

	var _close = __webpack_require__(38);

	var _close2 = _interopRequireDefault(_close);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 2017.9.7
	 * 流式排版
	 */
	var Flow = function () {
	    function Flow() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            pptMaster = _ref.pptMaster,
	            pageIndex = _ref.pageIndex,
	            $pinchNode = _ref.$pinchNode,
	            seasonId = _ref.seasonId,
	            chapterId = _ref.chapterId,
	            successCallback = _ref.successCallback;

	        _classCallCheck(this, Flow);

	        var self = this;
	        this.initIndex = pageIndex;
	        this.$pinchNode = $pinchNode;
	        this.pptMaster = pptMaster;
	        (0, _render2.default)({
	            $pinchNode: $pinchNode,
	            dataNode: $('#chapter-flow-' + chapterId),
	            chapterId: chapterId,
	            callback: function callback($container) {
	                self._init($container, seasonId, chapterId);
	                successCallback();
	            }
	        });
	    }

	    /**
	     * 获取母版对象
	     * @return {[type]} [description]
	     */


	    _createClass(Flow, [{
	        key: '_getMasterObj',
	        value: function _getMasterObj() {
	            if (this._masterObj) {
	                return this._masterObj;
	            }
	            if (this.pptMaster) {
	                this._masterObj = Xut.Presentation.GetPageObj('master', this.initIndex);
	            }
	        }
	    }, {
	        key: '_setImage',
	        value: function _setImage(node, img, width, height, src) {
	            var _this = this;

	            //是竖版图片
	            var isVerticalFigure = width < height;
	            var screenWidth = _index.config.screenSize.width;
	            var screenHeight = _index.config.screenSize.height;

	            var prop = void 0;
	            var top = 0;
	            var left = 0;

	            //宽度100%适应宽度
	            var widthFullAdaptiveHeight = function widthFullAdaptiveHeight() {
	                prop = screenWidth / width;
	                width = screenWidth;
	                height = height * prop;
	                top = (screenHeight - height) / 2;
	            };

	            //高度100% 自适应宽度
	            var heightFullAdaptiveWidth = function heightFullAdaptiveWidth() {
	                prop = screenHeight / height;
	                height = screenHeight;
	                width = width * prop;
	                left = (screenWidth - width) / 2;
	            };

	            //竖图
	            if (isVerticalFigure) {
	                //竖屏显示
	                if (_index.config.screenVertical) {
	                    widthFullAdaptiveHeight();
	                }
	                //横版显示
	                else {
	                        heightFullAdaptiveWidth();
	                    }
	            }
	            //横图
	            else {
	                    widthFullAdaptiveHeight();
	                }

	            var pageImageHTML = '<div class="page-pinch-image">\n                    <div style="width:' + width + 'px;\n                                height:' + height + 'px;\n                                top:' + top + 'px;\n                                left:' + left + 'px;\n                                background-image:url(' + src + ');">\n                    </div>\n             </div>';

	            var $pageImage = $(String.styleFormat(pageImageHTML));
	            this.$pinchNode.after($pageImage);

	            this.swipe.bansliding(); //flow滑动
	            Xut.Application.Bansliding(); //全局滑动
	            Xut.View.HideToolBar('pageNumber'); //工具栏

	            //按钮
	            var $buttonNode = (0, _close2.default)(function () {
	                return destory();
	            });

	            //缩放
	            var slide = void 0;

	            //销毁
	            var destory = function destory() {
	                if ($buttonNode) {
	                    $buttonNode.off();
	                    $buttonNode = null;
	                }

	                img = null;
	                slide && slide.destroy();
	                $pageImage.remove();
	                node.style.visibility = '';
	                _this._destroyZoomImage = null;
	                _this.swipe.allowliding();
	                Xut.Application.Allowliding();
	                Xut.View.ShowToolBar('pageNumber');
	            };

	            if (Xut.plat.hasTouch && _index.config.saleMode) {
	                slide = new _pinch2.default({
	                    hasButton: false,
	                    $pagePinch: $pageImage.children(),
	                    doubletap: destory
	                });
	            }

	            node.style.visibility = 'hidden';
	            $pageImage.append($buttonNode);
	        }

	        /**
	         * 缩放图片
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_zoomImage',
	        value: function _zoomImage(node) {
	            var _this2 = this;

	            //图片地址
	            var src = Xut.config.pathAddress + node.src.match(/\w+.(jpg|png)/gi);
	            var img = new Image();
	            img.src = src;
	            img.onload = function () {
	                //防止图片为加载完毕
	                _this2._setImage(node, img, img.width, img.height, src);
	            };
	            img.onerror = function () {
	                //失败
	                img = null;
	            };
	        }

	        //pagesCount = 5
	        // =>
	        //   0.25
	        //   0.5
	        //   0.75
	        //   1
	        //   0

	    }, {
	        key: '_makeNodes',
	        value: function _makeNodes(count) {
	            var nodes = [];
	            var nodeProportion = 1 / (count - 1); //比值
	            for (var i = 1; i < count; i++) {
	                nodes.push(i * nodeProportion);
	            }
	            nodes.push(0);
	            return nodes;
	        }

	        /**
	         * 初始化
	         * @param  {[type]} $container [description]
	         * @param  {[type]} $content   [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_init',
	        value: function _init($container, seasonId, chapterId) {
	            var _this3 = this;

	            var flowObject = this;
	            var pagesCount = (0, _get.getFlowCount)(seasonId, chapterId);
	            var flowView = (0, _adapter.getFlowView)();

	            var MIN = 0;
	            var MAX = pagesCount - 1;
	            var flipWidth = flowView.viewWidth;
	            var flipLeft = flowView.viewLeft;
	            var viewLeft = _index.config.viewSize.left;
	            var View = Xut.View;
	            var initIndex = this.initIndex;
	            var container = $container[0];

	            var nodes = void 0;
	            if (this.pptMaster) {
	                nodes = this._makeNodes(pagesCount);
	            }

	            /**
	             * 分栏整体控制
	             * @type {[type]}
	             */
	            var swipe = this.swipe = new _index3.default({
	                flipWidth: flipWidth,
	                borderBounce: true,
	                linear: true,
	                initIndex: Xut.Presentation.GetPageIndex() > initIndex ? MAX : MIN,
	                container: container,
	                flipMode: 0,
	                multiplePages: 1,
	                stopPropagation: true,
	                pagetotal: pagesCount
	            });

	            var moveDistance = 0;
	            var lastDistance = swipe.getInitDistance();

	            swipe.$watch('onTap', function (pageIndex, hookCallback, ev) {
	                //图片缩放
	                var node = ev.target;
	                if (node && node.nodeName.toLowerCase() === "img") {
	                    _this3._zoomImage(node);
	                }
	                if (!Xut.Contents.Canvas.getIsTap()) {
	                    View.Toolbar();
	                }
	            });

	            swipe.$watch('onMove', function () {
	                var _this4 = this;

	                var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	                    action = _ref2.action,
	                    speed = _ref2.speed,
	                    distance = _ref2.distance,
	                    leftIndex = _ref2.leftIndex,
	                    pageIndex = _ref2.pageIndex,
	                    rightIndex = _ref2.rightIndex,
	                    direction = _ref2.direction;

	                /**
	                 * 首页边界
	                 * @param  {[type]} this._hindex [description]
	                 * @return {[type]}              [description]
	                 */
	                if (this._hindex === MIN && this.direction === 'prev') {
	                    if (action === 'flipOver') {
	                        View.GotoPrevSlide();
	                        this.simulationComplete();
	                    } else {
	                        if (_index.config.viewSize.overflowWidth) {
	                            //内部页面边间翻页
	                            //要除去被溢出的值
	                            distance -= viewLeft;
	                        }
	                        //前边界前移反弹
	                        View.MovePage(distance, speed, this.direction, action);
	                    }
	                }
	                /**
	                 * 尾页边界
	                 * @param  {[type]} this._hindex [description]
	                 * @return {[type]}              [description]
	                 */
	                else if (this._hindex === MAX && this.direction === 'next') {
	                        if (action === 'flipOver') {
	                            View.GotoNextSlide();
	                            this.simulationComplete();
	                        } else {
	                            //内部页面边间翻页
	                            //要除去被溢出的值
	                            if (_index.config.viewSize.overflowWidth) {
	                                distance -= viewLeft;
	                            }
	                            //后边界前移反弹
	                            View.MovePage(distance, speed, this.direction, action);
	                        }
	                    }
	                    /**
	                     * 中间页面
	                     */
	                    else {
	                            (function () {

	                                /**
	                                 * 修正内部翻页的翻页算法
	                                 * @type {Object}
	                                 */
	                                var hooks = void 0;
	                                if (_index.config.viewSize.overflowWidth) {
	                                    hooks = {
	                                        flipOver: {
	                                            left: function left(data) {
	                                                data.middle = flipWidth;
	                                            },
	                                            right: function right(data) {
	                                                data.middle = -flipWidth;
	                                            }
	                                        }
	                                    };
	                                }

	                                var viewBeHideDistance = (0, _distance2.default)({
	                                    action: action,
	                                    distance: distance,
	                                    direction: direction
	                                }, hooks)[1];

	                                moveDistance = viewBeHideDistance;

	                                switch (direction) {
	                                    case 'next':
	                                        moveDistance = moveDistance + lastDistance;
	                                        break;
	                                    case 'prev':
	                                        moveDistance = moveDistance + lastDistance;
	                                        break;
	                                }

	                                //反弹
	                                if (action === 'flipRebound') {
	                                    moveDistance = direction === 'next' ? -flipWidth * _this4._hindex - _this4._hindex : -(flipWidth * _this4._hindex + _this4._hindex);
	                                }

	                                //更新页码
	                                if (action === 'flipOver') {
	                                    Xut.View.PageUpdate({
	                                        parentIndex: initIndex,
	                                        sonIndex: swipe.getHindex() + 1,
	                                        hasSon: true,
	                                        direction: direction
	                                    });
	                                }

	                                //移动视觉差
	                                var moveParallaxObject = function moveParallaxObject() {
	                                    var masterObj = flowObject._getMasterObj();
	                                    if (masterObj) {
	                                        // console.log(distance,action)
	                                        //处理当前页面内的视觉差对象效果
	                                        masterObj.moveParallax({
	                                            action: action,
	                                            direction: direction,
	                                            moveDist: viewBeHideDistance,
	                                            speed: speed,
	                                            nodes: nodes[_this4._hindex]
	                                            // parallaxProcessedContetns: this.parallaxProcessedContetns
	                                        });
	                                    }
	                                };

	                                _translation.translation[action](container, moveDistance, speed);
	                                moveParallaxObject();
	                            })();
	                        }
	            });

	            swipe.$watch('onComplete', function (direction, pagePointer, unfliplock, isQuickTurn) {
	                lastDistance = moveDistance;
	                unfliplock();
	            });
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.swipe && this.swipe.destroy();
	        }
	    }]);

	    return Flow;
	}();

	exports.default = Flow;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = initFlows;

	var _index = __webpack_require__(1);

	var _get = __webpack_require__(7);

	var _adapter = __webpack_require__(12);

	var COLUMNWIDTH = Xut.style.columnWidth;
	var COLUMNTAP = Xut.style.columnGap;

	/**
	 * 高度marginTop - marginBottom处理了
	 * 不一定等于设备高度
	 * @type {Number}
	 */
	var newViewHight = 0;

	/**
	 * create dom...
	 */
	var createStr = function createStr(chapterId, data, viewWidth, viewHeight, margin) {

	    var percentageTop = Number(margin[0]);
	    var percentageLeft = Number(margin[1]);
	    var percentageBottom = Number(margin[2]);
	    var percentageRight = Number(margin[3]);

	    //减去的宽度值
	    var negativeWidth = viewWidth / 100 * (percentageLeft + percentageRight);
	    //减去的高度值
	    var negativeHeight = viewHeight / 100 * (percentageTop + percentageBottom);

	    //容器宽度 = 宽度 - 左右距离比值
	    var containerWidth = viewWidth - negativeWidth;
	    //容器高度值 = 宽度 - 上下距离比值
	    var containerHeight = viewHeight - negativeHeight;
	    //容器左边偏移量
	    var containerLeft = negativeWidth / 2;
	    //容器上偏移量
	    var containerTop = viewHeight / 100 * percentageTop;

	    //重复加载杂志
	    //不刷新的情况处理
	    if (/fix-transform/.test(data)) {
	        data = $(data).find("#columns-content").html();
	    }

	    var columnGap = COLUMNTAP + ':' + negativeWidth + 'px';
	    var columnWidth = COLUMNWIDTH + ':' + containerWidth + 'px';
	    var container = '\n            <section class="fix-transform" data-flow="true">\n                <div class="page-flow-pinch" data-role="margin" style="width:' + containerWidth + 'px;height:' + containerHeight + 'px;margin-top:' + containerTop + 'px;margin-left:' + containerLeft + 'px;">\n                    <div data-role="column" id="columns-content" style="' + columnWidth + ';height:100%;' + columnGap + '">\n                        ' + data + '\n                    </div>\n                </div>\n            </section>';

	    newViewHight = containerHeight;

	    return String.styleFormat(container);
	};

	var resolveCount = function resolveCount($content) {
	    var theChildren = $content.find('#columns-content').children();
	    var paraHeight = 0;
	    for (var i = 0; i < theChildren.length; i++) {
	        paraHeight += $(theChildren[i]).height();
	    }
	    return Math.ceil(paraHeight / newViewHight);
	};

	var insertColumn = function insertColumn(seasonNode, seasonsId, vWidth, vHeight, flowCounts) {
	    for (var i = 0; i < seasonNode.childNodes.length; i++) {
	        var chapterNode = seasonNode.childNodes[i];
	        if (chapterNode.nodeType == 1) {
	            var tag = chapterNode.id;
	            var id = tag.match(/\d/)[0];

	            //传递的数据
	            var margin = chapterNode.getAttribute('data-margin');
	            if (margin) {
	                margin = margin.split(",");
	            } else {
	                margin = [0, 0, 0, 0];
	            }
	            chapterNode.innerHTML = createStr(id, chapterNode.innerHTML, vWidth, vHeight, margin);
	            flowCounts[seasonsId][id] = 0;
	        }
	    }
	};

	/**
	 * 构建flow页面代码结构
	 * @return {[type]} [description]
	 */
	function initFlows() {

	    var $container = $("#xut-stream-flow");
	    if (!$container.length) return;
	    var $seasons = $container.children();
	    if (!$seasons.length) return;

	    /**
	     * seasonId:{
	     *    chpaterID:count
	     * }
	     * @type {[type]}
	     */
	    var flowCounts = Object.create(null);

	    /**
	     * 容器尺寸设置
	     * @type {[type]}
	     */
	    var flowView = (0, _adapter.getFlowView)();

	    var vWidth = flowView.viewWidth;
	    var vHeight = newViewHight = flowView.viewHeight;

	    $seasons.each(function (index, node) {
	        var tag = node.id;
	        var seasonsId = tag.match(/\d/)[0];
	        var $chapters = $seasons.children();
	        flowCounts[seasonsId] = Object.create(null);
	        insertColumn(node, seasonsId, vWidth, vHeight, flowCounts);
	    });

	    $container.css({
	        width: vWidth,
	        height: vHeight,
	        overflow: 'hidden'
	    }).show();

	    $seasons.each(function (index, node) {
	        var tag = node.id;
	        var seasonsId = tag.match(/\d/)[0];
	        var $chapters = $seasons.children();

	        $chapters.each(function (index, node) {
	            var tag = node.id;
	            var chpaterId = tag.match(/\d/)[0];
	            var count = resolveCount($(node));
	            flowCounts[seasonsId][chpaterId] = Number(count);
	        });
	    });

	    $container.hide();

	    (0, _get.set)(flowCounts);

	    //存在
	    if (Object.keys(flowCounts).length) {
	        return true;
	    }
	}

/***/ },
/* 81 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = render;

	/**
	 * dom...
	 */
	function render() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        $pinchNode = _ref.$pinchNode,
	        dataNode = _ref.dataNode,
	        chapterId = _ref.chapterId,
	        callback = _ref.callback;

	    var $container = $(dataNode.html());
	    Xut.nextTick({
	        container: $pinchNode,
	        content: $container
	    }, function () {
	        return callback($container);
	    });
	}

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ShowNote = exports.ShowNote = function () {
	    function ShowNote(data) {
	        _classCallCheck(this, ShowNote);

	        data.id = parseInt(data.id);
	        data.actType = data.type;
	        _.extend(this, data);
	        this.setup();
	    }

	    _createClass(ShowNote, [{
	        key: 'setup',
	        value: function setup() {
	            var that = this,
	                note = this.data.note,
	                prop = Xut.config.proportion,
	                width = Math.round((prop.width + prop.height) / 2 * Xut.config.iconHeight),
	                space = Math.round(width / 2);
	            var retStr = '<div class="xut-shownote-box" style="z-index:' + Xut.zIndexlevel() + '">' + '<div class="close" style="width:' + width + 'px;height:' + width + 'px;top:-' + space + 'px;right:-' + space + 'px"></div>' + '<div class="content">' + note + '</div>' + '</div>';

	            this._dom = $(retStr);
	            this._dom.find('.close').on("touchend mouseup", function () {
	                that.toggle();
	            });
	            $(this.rootNode).append(this._dom);

	            this.show();

	            this.iscroll = new iScroll(this._dom.find('.content')[0], {
	                scrollbars: true,
	                fadeScrollbars: true
	            });
	            return true;
	        }

	        //外部调用接口

	    }, {
	        key: 'toggle',
	        value: function toggle() {
	            //自动热点 取消关闭
	            if (this.isAutoPlay) return;
	            //当前对象状态
	            this.state ? this.hide() : this.show();
	        }
	    }, {
	        key: 'stop',
	        value: function stop() {
	            if (this.state) {
	                this.toggle();
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'hide',
	        value: function hide() {
	            this.state = false;
	            $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/hideNote.png)');
	            this._dom.hide();
	        }
	    }, {
	        key: 'show',
	        value: function show() {
	            this.state = true;
	            $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/showNote.png)');
	            this._dom.show();
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this._dom) {
	                this._dom.find('.close').off();
	                this._dom && this._dom.hide().remove();
	            }

	            //iscroll销毁
	            if (this.iscroll) {
	                this.iscroll.destroy();
	                this.iscroll = null;
	            }
	        }
	    }]);

	    return ShowNote;
	}();

/***/ },
/* 83 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	//检测是否支持HTML5的video播放
	var supportVideo = function () {
	    var video = document.createElement('video');
	    var type = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
	    return !!video.canPlayType && "probably" == video.canPlayType(type);
	}();

	//检测是否安装了flash插件
	var supportFlash = function () {
	    var i_flash = false;
	    if (navigator.plugins) {
	        for (var i = 0; i < navigator.plugins.length; i++) {
	            if (navigator.plugins[i].name.toLowerCase().indexOf("shockwave flash") != -1) {
	                i_flash = true;
	            }
	        }
	    }
	    return i_flash;
	}();

	exports.supportVideo = supportVideo;
	exports.supportFlash = supportFlash;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Adapter = Adapter;

	var _controller = __webpack_require__(9);

	var _lang = __webpack_require__(3);

	var _index = __webpack_require__(1);

	var _index2 = __webpack_require__(88);

	var _index3 = _interopRequireDefault(_index2);

	var _index4 = __webpack_require__(85);

	var _index5 = _interopRequireDefault(_index4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var FLOOR = Math.floor; /********************************************************************
	                         *
	                         *                   零件适配器
	                         *
	                         *              1 数据过滤
	                         *              构件5种类型
	                         *
	                         * *******************************************************************/

	var CEIL = Math.ceil;

	/**
	 * 注册所有组件对象
	 * 2 widget 包括 视频 音频 Action 子文档 弹出口 类型
	 * 这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
	 * @param  {[type]} regData [description]
	 * @return {[type]}         [description]
	 */
	var injectionComponent = function injectionComponent(regData) {
	    var sceneObj = _controller.sceneController.containerObj('current');
	    sceneObj.vm.$injectionComponent = regData;
	};

	var load = function load(type, data, constructor) {
	    injectionComponent({
	        'pageType': data.pageType, //标记类型区分
	        'pageIndex': data.pageIndex,
	        'widget': new constructor(data)
	    });
	};

	/**
	 * 构建5中零件类型
	 *  1、iframe零件
	 *  2、页面零件
	 *  3、SVG零件
	 *  4、canvas零件
	 *  5、webGL零件
	 * @type {Object}
	 */
	var adapterType = {

	    /**
	     * iframe零件类型
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    'iframe': function iframe(data) {
	        load('widget', data, _index5.default);
	    },
	    'widget': function widget(data) {
	        load('widget', data, _index5.default);
	    },


	    /**
	     * js零件类型处理
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    'js': function js(data) {
	        load('js', data, _index3.default);
	    },
	    'page': function page(data) {
	        load('page', data, _index3.default);
	    },
	    'svg': function svg(data) {
	        load('svg', data, _index3.default);
	    },
	    'canvas': function canvas(data) {
	        load('canvas', data, _index3.default);
	    },
	    'webgL': function webgL(data) {
	        load('webgL', data, _index3.default);
	    }
	};

	/**
	 * 过滤出数据
	 * @return {[type]} [description]
	 */
	var filterData = function filterData(data) {
	    //直接通过id查询数据
	    if (data.widgetId) {
	        _.extend(data, Xut.data.query('Widget', data.widgetId));
	    } else {
	        //直接通过activityId查询数据
	        _.extend(data, Xut.data.query('Widget', data.activityId, 'activityId'));
	    }
	    return data;
	};

	/**
	 * 计算元素的缩放比
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	var calculateElement = function calculateElement(data) {
	    var data = _.extend({}, data);
	    var proportion = _index.config.proportion;
	    data.width = CEIL(data.width * proportion.width);
	    data.height = CEIL(data.height * proportion.height);
	    data.top = FLOOR(data.top * proportion.top);
	    data.left = FLOOR(data.left * proportion.left);
	    return data;
	};

	/**
	 * 获取widget数据
	 * @return {[type]} [description]
	 */
	var filtrateDas = function filtrateDas(data) {
	    data = filterData(data);
	    return calculateElement(data);
	};

	/**
	 * ifarme内部，请求返回数据
	 * @return {[type]} [description]
	 */
	var parsePara = function parsePara(data) {
	    var inputPara, //输入数据
	    outputPara; //输出数据
	    if (inputPara = data.inputPara) {
	        outputPara = (0, _lang.parseJSON)(inputPara);
	    }
	    return outputPara;
	};

	function Adapter(para) {

	    //获取数据
	    var data = filtrateDas(para);

	    data.id = data.activityId;

	    //解析数据
	    data.inputPara = parsePara(data);

	    if (!data.inputPara) {
	        data.inputPara = {};
	    }

	    //增加属性参数
	    if (data.widgetType === 'page') {
	        data.inputPara.container = data.rootNode;
	    }

	    data.inputPara.uuid = _index.config.appId + '-' + data.activityId; //唯一ID标示
	    data.inputPara.id = data.activityId;
	    data.inputPara.screenSize = _index.config.viewSize;
	    //content的命名前缀
	    data.inputPara.contentPrefix = Xut.Presentation.MakeContentPrefix(data.pageIndex, data.pageType);

	    //画轴模式
	    data.scrollPaintingMode = _index.config.visualMode === 1;
	    data.calculate = _index.config.viewSize;

	    //执行类构建
	    adapterType[(data.widgetType || 'widget').toLowerCase()](data);
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _manager = __webpack_require__(4);

	var _index = __webpack_require__(1);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 创建iframe零件包装器
	 */
	var iframeWidget = function () {
	    function iframeWidget(data) {
	        var _this = this;

	        _classCallCheck(this, iframeWidget);

	        _.extend(this, data);
	        this._$wapper = this._createWapper();
	        Xut.nextTick({
	            'container': this.rootNode,
	            'content': this._$wapper
	        }, function () {
	            _this.rootNode = null;
	            _this._bindPMS();
	        });
	        return this;
	    }

	    /**
	     * 创建包含容器
	     * @return {[type]} [description]
	     */


	    _createClass(iframeWidget, [{
	        key: '_createWapper',
	        value: function _createWapper() {
	            if (this.zIndex !== 0) {
	                this.zIndex = this.zIndex || Xut.zIndexlevel();
	            }

	            var html = String.styleFormat('<div id="widget_iframe_' + this.id + '"\n                  style="z-index:' + this.zIndex + ';\n                         width:' + this.width + 'px;\n                         height:' + this.height + 'px;\n                         top:' + this.top + 'px;\n                         left:' + this.left + 'px;\n                         position:absolute;">\n             </div>');

	            this._$iframe = this._createIframe();

	            return $(html).append(this._$iframe);
	        }

	        /**
	         * 加载iframe
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createIframe',
	        value: function _createIframe() {
	            var _this2 = this;

	            var ifr = document.createElement('iframe');
	            var rootPath = _index.config.pathAddress.replace('gallery/', '');
	            var path = rootPath + 'widget/' + this.widgetId + '/index.html?xxtParaIn=' + this.key;

	            ifr.id = 'iframe_' + this.id;
	            ifr.src = path;
	            ifr.style.width = '100%';
	            ifr.style.height = '100%';
	            ifr.sandbox = "allow-scripts allow-same-origin";
	            ifr.frameborder = 0;

	            if (ifr.attachEvent) {
	                ifr.attachEvent('onload', function () {
	                    _this2._iframeComplete();
	                });
	            } else {
	                ifr.onload = function () {
	                    _this2._iframeComplete();
	                };
	            }
	            return ifr;
	        }

	        /**
	         * iframe加载完毕回调
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_iframeComplete',
	        value: function _iframeComplete() {

	            var dataSource = this._loadData();
	            var width = this._$iframe.offsetWidth;
	            var height = this._$iframe.offsetHeight;

	            if (dataSource.screenSize.width * 0.98 <= width && dataSource.screenSize.height * 0.98 <= height) {
	                Xut.View.Toolbar({
	                    show: 'button',
	                    hide: 'controlBar'
	                });
	            } else if (dataSource.screenSize.width * 0.7 <= width && dataSource.screenSize.height * 0.7 <= height) {
	                Xut.View.Toolbar({
	                    show: 'button'
	                });
	            }

	            PMS.send({
	                target: this._$iframe.contentWindow,
	                origin: '*',
	                type: 'loadData',
	                data: dataSource,
	                //消息传递完毕后的回调
	                success: function success() {},
	                error: function error() {}
	            });

	            //iframe加载的状态
	            this.state = true;
	        }

	        /**
	         * ifarme内部，请求返回数据
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_loadData',
	        value: function _loadData() {
	            var item,
	                field,
	                source_export = [],
	                images = Xut.data['Image'],
	                token = null,
	                outputPara = this.inputPara,
	                items = outputPara.source;

	            for (item in items) {
	                if (items.hasOwnProperty(item)) {
	                    field = {};
	                    token = images.item((parseInt(items[item]) || 1) - 1);
	                    field['img'] = '../gallery/' + token.md5;
	                    field['thumb'] = '';
	                    field['title'] = token.imageTitle;
	                    source_export.push(field);
	                }
	            }

	            outputPara.source = source_export;

	            return outputPara;
	        }

	        /**
	         * 与iframe通讯接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_bindPMS',
	        value: function _bindPMS() {
	            var _this3 = this;

	            var markId = this.id;
	            var $wapper = this._$wapper;
	            var $iframe = $(this._$iframe);

	            //隐藏widget
	            PMS.bind("onHideWapper" + markId, function () {
	                $wapper.hide();
	                _this3.state = false;
	            }, '*');

	            //全屏操作
	            PMS.bind("onFullscreen" + markId, function (e) {

	                if (!$iframe.length) return;

	                //关闭视频
	                (0, _manager.clearVideo)();

	                $wapper.css({
	                    width: '100%',
	                    height: '100%',
	                    zIndex: Xut.zIndexlevel(),
	                    top: 0,
	                    left: 0
	                });

	                //Widget全屏尺寸自动调整
	                if (e.full == false) {
	                    var body = document.body,
	                        width = parseInt(body.clientWidth),
	                        height = parseInt(body.clientHeight),
	                        rote = _this3.width / _this3.height,
	                        getRote = function getRote(width, height, rote) {
	                        var w = width,
	                            h = width / rote;
	                        if (h > height) {
	                            h = height;
	                            w = h * rote;
	                        }
	                        return {
	                            w: parseInt(w),
	                            h: parseInt(h)
	                        };
	                    },
	                        size = getRote(width, height, rote),
	                        left = (width - size.w) / 2,
	                        top = (height - size.h) / 2;

	                    $iframe.css({
	                        width: size.w,
	                        height: size.h,
	                        position: 'absolute',
	                        top: top,
	                        left: left
	                    });
	                }
	                //隐藏工作条
	                Xut.View.Toolbar("hide");
	            }, '*');

	            //还原初始窗口操作
	            PMS.bind("onReset" + markId, function () {

	                if (!$iframe.length) return;

	                $wapper.css({
	                    zIndex: _this3.zIndex,
	                    width: _this3.width + 'px',
	                    height: _this3.height + 'px',
	                    top: _this3.top + 'px',
	                    left: _this3.left + 'px'
	                });

	                //还原iframe样式
	                $iframe.css({
	                    width: '100%',
	                    height: '100%',
	                    position: '',
	                    top: '0',
	                    left: '0'
	                });

	                Xut.View.Toolbar("show");
	            }, '*');

	            //显示工作条
	            PMS.bind("onShowToolbar" + markId, function () {
	                // Xut.View.ShowToolBar();
	            }, '*');

	            //隐藏工作条
	            PMS.bind("onHideToolbar" + markId, function () {
	                Xut.View.HideToolBar();
	            }, '*');

	            //跳转页面
	            PMS.bind('scrollToPage' + markId, function (data) {
	                Xut.View.GotoSlide(data['ppts'], data['pageIndex']);
	            }, '*');
	        }

	        /**
	         * 开始
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_start',
	        value: function _start() {
	            var _this4 = this;

	            this._domWapper();
	            PMS.send({
	                target: this._$iframe.contentWindow,
	                url: this._$iframe.src,
	                origin: '*',
	                type: 'onShow',
	                success: function success() {
	                    // alert(123)
	                }
	            });
	            setTimeout(function () {
	                _this4.state = true;
	            }, 0);
	        }

	        /**
	         * 暂停
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_stop',
	        value: function _stop() {
	            var _this5 = this;

	            this._domWapper();
	            PMS.send({
	                target: this._$iframe.contentWindow,
	                url: this._$iframe.src,
	                origin: '*',
	                type: 'onHide',
	                success: function success() {}
	            });
	            setTimeout(function () {
	                _this5.state = false;
	            }, 0);
	        }

	        /**
	         * 处理包装容器的状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_domWapper',
	        value: function _domWapper() {
	            if (this.state) {
	                this._$wapper.hide();
	            } else {
	                this._$wapper.show();
	            }
	        }

	        /**
	         * 停止
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            this._stop();
	        }

	        /**
	         * 外部调用接口
	         * 显示隐藏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'toggle',
	        value: function toggle() {
	            if (this.state) {
	                this._stop();
	            } else {
	                this._start();
	            }
	        }

	        /**
	         * 销毁接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var _this6 = this;

	            //销毁内部事件
	            PMS.send({
	                target: this._$iframe.contentWindow,
	                url: this._$iframe.src,
	                origin: '*',
	                type: 'onDestory',
	                success: function success() {}
	            });

	            //销毁事件绑定
	            PMS.unbind();

	            //销魂节点
	            setTimeout(function () {
	                _this6._$iframe = null;
	                _this6._$wapper.remove();
	                _this6._$wapper = null;
	            }, 0);
	        }
	    }]);

	    return iframeWidget;
	}();

	exports.default = iframeWidget;

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.createData = createData;
	/**
	 * 创建数据
	 * @return {[type]} [description]
	 */
	function createData(outputPara, scrollPaintingMode, calculate) {
	    var item,
	        field,
	        source = [],
	        images = Xut.data['Image'],
	        token = null,
	        items = outputPara.source;

	    for (item in items) {
	        if (items.hasOwnProperty(item)) {
	            field = {};
	            token = images.item((parseInt(items[item]) || 1) - 1);
	            field['img'] = token.md5;
	            field['thumb'] = '';
	            field['title'] = token.imageTitle;
	            source.push(field);
	        }
	    }

	    outputPara.source = source;
	    outputPara.scrollPaintingMode = scrollPaintingMode;
	    outputPara.calculate = calculate;

	    /**
	     * 2016.8.3
	     * 给妙妙学的js零件增加前缀
	     * @type {[type]}
	     */
	    outputPara.rootPath = Xut.config.getWidgetPath();

	    return outputPara;
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _lang = __webpack_require__(3);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 眷顾区域扩展
	 * @type {Boolean}
	 */
	var ScrollArea = function () {
	    function ScrollArea(data, options) {
	        _classCallCheck(this, ScrollArea);

	        this.data = data;
	        this.options = options;
	        this.scrolls = [];
	        this._init();
	    }

	    _createClass(ScrollArea, [{
	        key: "_init",
	        value: function _init() {
	            var content = this.options;
	            var prefix = this.data.contentPrefix;
	            //创建多个眷滚区域
	            for (var i = 0; i < content.length; i++) {
	                var obj = this._create(content[i], prefix);
	                if (obj) {
	                    this.scrolls.push(obj);
	                }
	            }
	        }
	    }, {
	        key: "_createWrapper",
	        value: function _createWrapper() {
	            return String.styleFormat("<div data-type=\"area-wrapper\"\n                  style=\"position:absolute;width:100%; height:100%;overflow:hidden;\">\n                <ul data-type=\"area-scroller\"\n                     data-behavior=\"disable\"\n                     style=\"position:absolute; width:100%; height:100%;overflow:hidden;\">\n                </ul>\n             </div>");
	        }
	    }, {
	        key: "_create",
	        value: function _create(content, prefix) {

	            var cid = content.id;
	            var contentName = prefix + cid;

	            var theTitle = (0, _lang.parseJSON)(content.theTitle);

	            //data-widgetscrollareaList
	            //data-widgetscrollareascrolltype
	            var obj = theTitle["data-widgetscrollareaList"].split(",");
	            if (obj.length == 0) {
	                return;
	            }

	            var contentPanle = $("#" + contentName);
	            if (contentPanle.length == 0) {
	                console.log(cid + "not find obj");
	                return;
	            }

	            var scrolltype = theTitle["data-widgetscrollareascrolltype"] ? theTitle["data-widgetscrollareascrolltype"] : "xy";

	            //滚动的方向
	            //x / y /xy
	            scrolltype = scrolltype.toLowerCase();
	            var scrollX = scrolltype.indexOf("x") > -1;
	            var scrollY = scrolltype.indexOf("y") > -1;

	            var $wrapper = void 0;

	            //如果来回翻页
	            //因为子节点的排列关系已经被改变
	            //所以这里直接处理事件
	            var hasIscroll = contentPanle.attr("data-iscroll");
	            if (hasIscroll) {
	                //需要滚动条
	                if (hasIscroll === 'visible') {
	                    $wrapper = contentPanle.children('div[data-type="area-wrapper"]');
	                    return this._bindIscroll($wrapper[0], scrollX, scrollY, cid);
	                }
	                //hidden
	                return;
	            }

	            //去掉默认行为
	            Xut.Contents.ResetDefaultControl("page", contentName, "");

	            var contentSize = {
	                x: parseInt(contentPanle.css("left")),
	                y: parseInt(contentPanle.css("top")),
	                w: parseInt(contentPanle.css("width")),
	                h: parseInt(contentPanle.css("height"))
	            };

	            var size = this._getSize(obj, prefix);
	            var min = size.min;
	            var max = size.max;

	            //创建容器
	            $wrapper = $(this._createWrapper());

	            //滚动容器
	            var $scroller = $wrapper.children();
	            contentPanle.append($wrapper);

	            //设置滚动容器宽高
	            this._setScrollerStyle(max, min, contentSize, scrollX, scrollY, $scroller);

	            //重置各个content的left top值 并得到
	            //x轴方向卷滚：snap容器的宽度 个数以及每个snap容器包含的content个数
	            //y轴方向卷滚：snap容器的高度 个数以及每个snap容器包含的content个数
	            var colsObj = this._resetContents(obj, prefix, contentSize, scrollX, scrollY, min);

	            //创建snap容器
	            var snapContainer = this._createSnapContainer(colsObj, $scroller, cid, scrollX, scrollY);

	            //将content添加到snap容器中
	            if (scrollX) {
	                for (var j = 0; j < obj.length; j++) {
	                    var childId = prefix + obj[j];
	                    var childObj = $("#" + childId);
	                    childObj.appendTo(snapContainer[Math.floor(j / colsObj.contentsPerSnapX)]);
	                }
	            }
	            if (scrollY) {
	                for (var j = 0; j < obj.length; j++) {
	                    var childId = prefix + obj[j];
	                    var childObj = $("#" + childId);
	                    childObj.appendTo(snapContainer[Math.floor(j / colsObj.contentsPerSnapY)]);
	                }
	            }

	            //如果不满足溢出条件
	            var $areaScroller = snapContainer.parent();
	            if (scrollX) {
	                var snapContainerWidth = parseInt($areaScroller.css('width'));
	                if (snapContainerWidth < contentSize.w) {
	                    scrollX = false;
	                }
	            }
	            if (scrollY) {
	                var snapContainerHeight = parseInt($areaScroller.css('height'));
	                if (snapContainerHeight < contentSize.h) {
	                    scrollY = false;
	                }
	            }

	            if (scrollY || scrollX) {
	                contentPanle.attr("data-iscroll", "visible");
	                //只存在一屏 需要卷滚时 不要要snap
	                if (snapContainer.length == 1) {
	                    return this._bindIscroll($wrapper[0], scrollX, scrollY);
	                }
	                return this._bindIscroll($wrapper[0], scrollX, scrollY, cid);
	            } else {
	                contentPanle.attr("data-iscroll", "hidden");
	            }
	        }
	    }, {
	        key: "_bindIscroll",
	        value: function _bindIscroll(wrapper, hasScrollX, hasScrollY, cid) {
	            if (cid) {
	                return new iScroll(wrapper, {
	                    scrollX: hasScrollX ? true : false,
	                    scrollY: hasScrollY ? true : false,
	                    snap: ".contentsContainer" + cid
	                });
	            } else {
	                return new iScroll(wrapper, {
	                    scrollX: hasScrollX ? true : false,
	                    scrollY: hasScrollY ? true : false
	                });
	            }
	        }
	    }, {
	        key: "_getSize",
	        value: function _getSize(objIds, prefix) {
	            //最大区间
	            var max = {
	                l: null,
	                t: null
	            };

	            //最小区间
	            var min = {
	                l: null,
	                t: null
	            };

	            var obj = void 0;
	            for (var i = 0; i < objIds.length; i++) {
	                obj = $("#" + prefix + objIds[i]);
	                if (obj.length == 0) {
	                    console.log(objIds[i] + " not find");
	                    continue;
	                }
	                var width = parseInt(obj.css("width"));
	                var left = parseInt(obj.css("left"));
	                var height = parseInt(obj.css("height"));
	                var top = parseInt(obj.css("top"));

	                //获取最小区间
	                var xMin = left;
	                var yMin = top;
	                if (min.l == null || min.l > xMin) {
	                    min.l = xMin;
	                }
	                if (min.t == null || min.t > yMin) {
	                    min.t = yMin;
	                }

	                //获取最大元素的值
	                var xMax = width + left;
	                var yMax = height + top;
	                if (max.l == null || max.l < xMax) {
	                    max.l = xMax;
	                }
	                if (max.t == null || max.t < yMax) {
	                    max.t = yMax;
	                }
	            }

	            return {
	                min: min,
	                max: max
	            };
	        }

	        /**
	         * 设置scroller标签的宽高
	         * @param {[type]} max         [description]
	         * @param {[type]} min         [description]
	         * @param {[type]} contentSize [description]
	         * @param {[type]} scrollX     [description]
	         * @param {[type]} scrollY     [description]
	         * @param {[type]} $scroller   [description]
	         */

	    }, {
	        key: "_setScrollerStyle",
	        value: function _setScrollerStyle(max, min, contentSize, scrollX, scrollY, $scroller) {
	            var width = 0;
	            var height = 0;
	            var start = { x: 0, y: 0 };
	            var end = { x: 0, y: 0 };

	            if (min.l < contentSize.x) {
	                start.x = min.l;
	            } else {
	                start.x = contentSize.x;
	            }

	            if (min.t < contentSize.y) {
	                start.y = min.t;
	            } else {
	                start.y = contentSize.y;
	            }

	            if (max.l > contentSize.x + contentSize.w) {
	                end.x = max.l;
	            } else {
	                end.x = contentSize.x + contentSize.w;
	            }

	            if (max.t > contentSize.y + contentSize.h) {
	                end.y = max.t;
	            } else {
	                end.y = contentSize.y + contentSize.h;
	            }

	            if (!scrollX && end.x - start.x > contentSize.w) {
	                width = contentSize.w;
	            } else {
	                width = end.x - start.x;
	            }

	            if (!scrollY && end.y - start.y > contentSize.h) {
	                height = contentSize.h;
	            } else {
	                height = end.y - start.y;
	            }

	            $scroller.css({
	                width: width + "px",
	                height: height + "px"
	            });
	        }

	        /**
	         * 重设各个子content的left top值 以包裹他们的父容器为基准
	         * 并且得到snapContainer的个数 宽度 以及每个snapContainer中可以放的content个数
	         * @param  {[type]} obj         [description]
	         * @param  {[type]} prefix      [description]
	         * @param  {[type]} contentSize [description]
	         * @param  {[type]} scrollX     [description]
	         * @param  {[type]} scrollY     [description]
	         * @param  {[type]} min         [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: "_resetContents",
	        value: function _resetContents(obj, prefix, contentSize, scrollX, scrollY, min) {
	            var contentsPerSnapX = void 0,
	                contentsPerSnapY = void 0,
	                snapXCount = void 0,
	                snapYCount = void 0,
	                snapContainerWidth = void 0,
	                snapContainerHeight = void 0;
	            var contentsXTemp = 0;
	            var contentsYTemp = 0;
	            var contentsLength = obj.length;

	            for (var j = 0; j < contentsLength; j++) {
	                var childId = prefix + obj[j];
	                var childObj = $("#" + childId);
	                Xut.Contents.ResetDefaultControl("page", childId, "");
	                if (childObj.attr("data-iscroll") == "true") {
	                    continue;
	                }
	                var childLeft = parseInt(childObj.css("left"));
	                var childTop = parseInt(childObj.css("top"));
	                var childWidth = parseInt(childObj.css("width"));

	                if (min.l < contentSize.x && scrollX) {
	                    childLeft = childLeft - min.l;
	                } else {
	                    childLeft = childLeft - contentSize.x;
	                }

	                if (min.t < contentSize.y && scrollY) {
	                    childTop = childTop - min.t;
	                } else {
	                    childTop = childTop - contentSize.y;
	                }

	                childObj.css("left", childLeft);
	                childObj.css("top", childTop);

	                //x轴卷滚
	                if (scrollX) {
	                    if (childLeft < contentSize.w) {
	                        contentsXTemp++;
	                    } else {
	                        if (!contentsPerSnapX) {
	                            contentsPerSnapX = contentsXTemp;
	                            snapContainerWidth = childLeft;
	                        }
	                    }
	                }
	                //y轴卷滚
	                if (scrollY) {
	                    if (childTop < contentSize.h) {
	                        contentsYTemp++;
	                    } else {
	                        if (!contentsPerSnapY) {
	                            contentsPerSnapY = contentsYTemp;
	                            snapContainerHeight = childTop;
	                        }
	                    }
	                }

	                childObj.css("visibility", "inherit");
	                childObj.attr("data-iscroll", "true");
	            }

	            if (scrollX) {
	                //无需创建卷滚
	                if (!contentsPerSnapX) {
	                    contentsPerSnapX = obj.length;
	                    snapXCount = 1;
	                    snapContainerWidth = contentSize.w;
	                } else {
	                    snapXCount = Math.ceil(obj.length / contentsPerSnapX);
	                }
	            }

	            if (scrollY) {
	                //得到卷滚区域一行可以放多少列
	                var colsPerRow = 1;
	                for (var k = 0; k < contentsLength; k++) {
	                    var childId = prefix + obj[k];
	                    var childObj = $("#" + childId);
	                    var childTop = parseInt(childObj.css("top"));
	                    if (k > 0) {
	                        var prevChildId = prefix + obj[k - 1];
	                        var prevChildObj = $("#" + prevChildId);
	                        var prevChildTop = parseInt(prevChildObj.css("top"));
	                        if (childTop < prevChildTop + 10) {
	                            colsPerRow++;
	                        } else {
	                            break;
	                        }
	                    }
	                }

	                //无需创建卷滚
	                if (!contentsPerSnapY) {
	                    contentsPerSnapY = Math.floor(obj.length / colsPerRow) + 1; ////在不需要卷滚的条件下 只会存在一个snap snap中的行数由content的总数/每行的个数 +1
	                    snapYCount = 1;
	                    snapContainerHeight = contentSize.h;
	                } else {
	                    snapYCount = Math.ceil(obj.length / contentsPerSnapY);
	                }
	            }

	            return {
	                contentsPerSnapX: contentsPerSnapX,
	                snapXCount: snapXCount,
	                snapContainerWidth: snapContainerWidth,
	                contentsPerSnapY: contentsPerSnapY,
	                snapYCount: snapYCount,
	                snapContainerHeight: snapContainerHeight
	            };
	        }

	        /**
	         * 创建snapContainer并添加到scroller中
	         * @param  {[type]} colsObj   [description]
	         * @param  {[type]} $scroller [description]
	         * @param  {[type]} cid       [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: "_createSnapContainer",
	        value: function _createSnapContainer(colsObj, $scroller, cid, scrollX, scrollY) {
	            var snapContainer = '';

	            if (scrollX) {
	                var scrollerWidth = parseInt($scroller.css("width"));
	                var snapXCount = colsObj.snapXCount;
	                var snapContainerWidth = colsObj.snapContainerWidth;
	                var lastSnapContainerWidth = scrollerWidth - (snapXCount - 1) * snapContainerWidth;
	                var containerWidth = void 0;
	                for (var i = 0; i < colsObj.snapXCount; i++) {
	                    //最后一个snap容器的宽度需要单独设置 否则可能所有的snap容器宽度和会大于scroller的宽度
	                    if (i == colsObj.snapXCount - 1) {
	                        containerWidth = lastSnapContainerWidth;
	                    } else {
	                        containerWidth = snapContainerWidth;
	                    }
	                    snapContainer += "<li class=\"contentsContainer" + cid + "\"\n                                      style='width:" + containerWidth + "px;height:100%;float:left;'>\n                                  </li>";
	                }
	            }
	            //Y轴滚动
	            else if (scrollY) {
	                    var scrollerHeight = parseInt($scroller.css("height"));
	                    var snapYCount = colsObj.snapYCount;
	                    var snapContainerHeight = colsObj.snapContainerHeight;
	                    var lastSnapContainerHeight = scrollerHeight - (snapYCount - 1) * snapContainerHeight;
	                    for (var i = 0; i < colsObj.snapYCount; i++) {
	                        snapContainer += "<li class=\"contentsContainer" + cid + "\"\n                                      style='height:" + snapContainerHeight + "px;width:100%;float:left;'>\n                                  </li>";
	                    }
	                }

	            snapContainer = $(snapContainer);
	            snapContainer.appendTo($scroller);
	            return snapContainer;
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            if (this.scrolls.length) {
	                for (var i = 0; i < this.scrolls.length; i++) {
	                    var obj = this.scrolls[i];
	                    if (obj) {
	                        obj.scrollTo(0, 0);
	                        obj.destroy();
	                    }
	                    this.scrolls[i] = null;
	                }
	                this.scrolls = null;
	            }
	            this.data.container = null;
	            this.options = null;
	        }
	    }]);

	    return ScrollArea;
	}();

	exports.default = ScrollArea;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /********************************************************************
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  创建所有的JS页面零件类
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  1 js
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  2 page
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  3 svg
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  4 canvas
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                  5 webgL
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * *******************************************************************/

	var _loader = __webpack_require__(89);

	var _data = __webpack_require__(86);

	var _adv = __webpack_require__(28);

	var _adv2 = _interopRequireDefault(_adv);

	var _scroll = __webpack_require__(87);

	var _scroll2 = _interopRequireDefault(_scroll);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 解析数据,获取content对象
	 * @return {[type]} [description]
	 */
	var parseContentObjs = function parseContentObjs(pageType, inputPara) {
	    var contentIds = [];
	    inputPara.content && _.each(inputPara.content, function (contentId) {
	        contentIds.push(contentId);
	    });
	    return Xut.Contents.GetPageWidgetData(pageType, contentIds);
	};

	/**
	 * 页面零件
	 * @param {[type]} data [description]
	 */

	var PageWidget = function () {
	    function PageWidget(data) {
	        _classCallCheck(this, PageWidget);

	        _.extend(this, data);
	        this.pageObj = null;
	        this._init();
	    }

	    /**
	     * 获取参数
	     * 得到content对象与数据
	     * @return {[type]} [description]
	     */


	    _createClass(PageWidget, [{
	        key: '_getOptions',
	        value: function _getOptions() {
	            return [(0, _data.createData)(this.inputPara, this.scrollPaintingMode, this.calculate), parseContentObjs(this.pageType, this.inputPara)];
	        }

	        /**
	         * 初始化,加载文件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_init',
	        value: function _init() {

	            //滚动区域
	            if (this.widgetId == 60 && this.widgetName == "scrollarea") {
	                var arg = this._getOptions();
	                this.pageObj = new _scroll2.default(arg[0], arg[1]);
	            }
	            //Load the localized code first
	            //Combined advanced Sprite
	            else if (this.widgetId == 72 && this.widgetName == "spirit") {
	                    var arg = this._getOptions();
	                    this.pageObj = (0, _adv2.default)(arg[0], arg[1]);
	                }
	                //直接扩展加载
	                else {
	                        //If there is no
	                        if (typeof window[this.widgetName + "Widget"] != "function") {
	                            this.hasload = true;
	                            (0, _loader.loadFile)(this._executive, this);
	                        } else {
	                            this._executive();
	                        }
	                    }
	        }

	        /**
	         * 执行函数
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_executive',
	        value: function _executive() {
	            if (typeof window[this.widgetName + "Widget"] == "function") {
	                var arg = this._getOptions();
	                this.pageObj = new window[this.widgetName + "Widget"](arg[0], arg[1]);
	            } else {
	                console.error("Function [" + this.widgetName + "Widget] does not exist.");
	            }
	        }

	        /**
	         * 动画运行
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'play',
	        value: function play() {
	            return this.pageObj.play();
	        }

	        /**
	         * 外部切换调用接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'toggle',
	        value: function toggle() {
	            this.pageObj && this.pageObj.toggle && this.pageObj.toggle();
	        }

	        /**
	         * 动作停止接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            this.pageObj && this.pageObj.stop && this.pageObj.stop();
	        }

	        /**
	         * 销毁页面零件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.hasload && (0, _loader.removeLoad)();
	            this.pageObj && this.pageObj.destroy && this.pageObj.destroy();
	        }
	    }]);

	    return PageWidget;
	}();

	exports.default = PageWidget;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.removeLoad = removeLoad;
	exports.loadFile = loadFile;

	var _loader = __webpack_require__(10);

	var _index = __webpack_require__(1);

	/**
	 * 路径地址
	 * @param  {[type]} name [description]
	 * @return {[type]}      [description]
	 */
	function path(fileName, widgetId) {
	    return _index.config.getWidgetPath() + widgetId + '/' + fileName;
	}

	/**
	 * 去重加载处理
	 */
	var toRepeat = {};

	var add = function add(path, callback) {
	    //去重复处理
	    //可能同时执行了多个同样的js文件加载
	    if (!toRepeat[path]) {
	        toRepeat[path] = [];
	    }
	    toRepeat[path].push(callback);
	    if (toRepeat[path].length > 1) {
	        return;
	    }
	    (0, _loader.loadfile)(path, function () {
	        _.each(toRepeat[path], function (fn) {
	            fn && fn();
	        });
	        toRepeat[path] = null;
	        delete toRepeat[path];
	    });
	};

	function removeLoad() {
	    toRepeat = {};
	}

	/**
	 * 加载js,css文件
	 * @return {[type]} [description]
	 */
	function loadFile(callback, base) {
	    var jsPath,
	        cssPath,
	        completeCount,
	        widgetId = base.widgetId,

	    //定义css,js的命名
	    jsName = base.widgetName + '.min.js',
	        cssName = base.widgetType == 'page' || base.widgetType == 'js' ? 'style.min.css' : 0;

	    //需要等待完成
	    var completeCount = function () {
	        var count = 0;
	        jsName && count++;
	        cssName && count++;
	        return function () {
	            if (count === 1) {
	                return callback && callback.call(base);
	            }
	            count--;
	        };
	    }();

	    //加载css
	    if (cssName) {
	        cssPath = path(cssName, widgetId);
	        add(cssPath, completeCount);
	    }

	    //加载js
	    if (jsName) {
	        jsPath = path(jsName, widgetId);
	        add(jsPath, completeCount);
	    }
	}

/***/ },
/* 90 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * 数据配置
	 */
	exports.default = {

	  /**
	   * 支持电子在在线阅读,向服务端取数据
	   * 自定义配置地址即可'
	   * @type {String}
	   */
	  onlineModeUrl: 'lib/data/database.php',

	  /**
	   * 2016.7.26
	   * 读酷增加强制插件模式
	   * [isPlugin description]
	   * @type {Boolean}
	   */
	  isPlugin: window.DUKUCONFIG && Xut.plat.isIOS,

	  /**
	   * 数据库名
	   * @type {[type]}
	   */
	  dbName: window.xxtmagzinedbname || 'magazine',

	  /**
	   * 存储模式
	   * 0 APK应用本身
	   * 1 外置SD卡
	   */
	  storageMode: 0,

	  /**
	   * 应用路径唯一标示
	   * @type {[type]}
	   */
	  appId: null,

	  /**
	   * 资源路径
	   * @type {[type]}
	   */
	  pathAddress: null

	};

/***/ },
/* 91 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getSize = getSize;
	exports.getLayerMode = getLayerMode;
	/**
	 * 屏幕尺寸
	 * @return {[type]} [description]
	 */
	function getSize() {
	    //如果是IBooks模式处理
	    if (Xut.IBooks.Enabled) {
	        var screen = Xut.IBooks.CONFIG.screenSize;
	        if (screen) {
	            return {
	                "width": screen.width,
	                "height": screen.height
	            };
	        }
	    }

	    return {
	        "width": document.documentElement.clientWidth || $(window).width(),
	        "height": document.documentElement.clientHeight || $(window).height()
	    };
	}

	/**
	 * 排版判断
	 * @return {[type]} [description]
	 */
	function getLayerMode(screenSize) {
	    return screenSize.width > screenSize.height ? "horizontal" : "vertical";
	}

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = __webpack_require__(19);

	var isIOS = Xut.plat.isIOS;
	var isAndroid = Xut.plat.isAndroid;
	var DUKUCONFIG = window.DUKUCONFIG;
	var MMXCONFIG = window.MMXCONFIG;
	var CLIENTCONFIGT = window.CLIENTCONFIGT;
	var SUbCONFIGT = window.SUbCONFIGT;

	/**
	 * 读酷模式下的路径
	 * @param  {[type]} DUKUCONFIG [description]
	 * @return {[type]}                   [description]
	 */
	if (DUKUCONFIG) {
	    DUKUCONFIG.path = DUKUCONFIG.path.replace('//', '/');
	}

	/**
	 * 除右端的"/"
	 * @param  {[type]} str [description]
	 * @return {[type]}     [description]
	 */
	var rtrim = function rtrim(str) {
	    if (typeof str != 'string') return str;
	    var lastIndex = str.length - 1;
	    if (str.charAt(lastIndex) === '/') {
	        return str.substr(0, lastIndex);
	    } else {
	        return str;
	    }
	};

	// var MMXCONFIGPath = '.'
	// if (MMXCONFIG && MMXCONFIG.path) {
	//     MMXCONFIGPath = location.href.replace(/^file:\/\/\/?/i, '/').replace(/[^\/]*$/, '');
	// }
	var MMXCONFIGPath = location.href.replace(/^file:\/\/\/?/i, '/').replace(/[^\/]*$/, '');
	if (MMXCONFIG && MMXCONFIG.path) {
	    MMXCONFIGPath = rtrim(MMXCONFIG.path);
	}

	/**
	 *  通过iframe加载判断当前的加载方式
	 *  1 本地iframe打开子文档
	 *  2 读酷加载电子杂志
	 *  3 读酷加载电子杂志打开子文档
	 */
	var iframeMode = function () {
	    var mode = void 0;
	    if (SUbCONFIGT && DUKUCONFIG) {
	        //通过读酷客户端开打子文档方式
	        mode = 'iframeDuKuSubDoc';
	    } else {
	        //子文档加载
	        if (SUbCONFIGT) {
	            mode = 'iframeSubDoc';
	        }
	        //读酷客户端加载
	        if (DUKUCONFIG) {
	            mode = 'iframeDuKu';
	        }
	        //客户端模式
	        //通过零件加载
	        if (CLIENTCONFIGT) {
	            mode = 'iframeClient';
	        }
	        //秒秒学客户端加载
	        if (MMXCONFIG) {
	            mode = 'iframeMiaomiaoxue';
	        }
	    }
	    return mode;
	}();

	//iframe嵌套配置
	//1 新阅读
	//2 子文档
	//3 秒秒学
	exports.default = {

	    /**
	     * 资源图片
	     * @return {[type]} [description]
	     */
	    resources: function resources() {
	        if (isIOS) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return (0, _get.getSourcePath)();
	                case 'iframeDuKuSubDoc':
	                    return (0, _get.getSourcePath)();
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }

	        if (isAndroid) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * 视频路径
	     * @return {[type]} [description]
	     */
	    video: function video() {
	        if (isIOS) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return (0, _get.getSourcePath)();
	                case 'iframeDuKuSubDoc':
	                    return (0, _get.getSourcePath)();
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }

	        if (isAndroid) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return 'android.resource://#packagename#/raw/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * 音频路径
	     * @return {[type]} [description]
	     */
	    audio: function audio() {
	        if (isIOS) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return (0, _get.getSourcePath)();
	                case 'iframeDuKuSubDoc':
	                    return (0, _get.getSourcePath)();
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	        if (isAndroid) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * 调用插件处理
	     * @return {[type]} [description]
	     */
	    svg: function svg() {
	        if (isIOS) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    //www/content/subdoc/00c83e668a6b6bad7eda8eedbd2110ad/content/gallery/
	                    return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }

	        if (isAndroid) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * js零件
	     * 2016.8.3 喵喵学
	     * @return {[type]} [description]
	     */
	    jsWidget: function jsWidget() {
	        return MMXCONFIGPath + '/content/widget/';
	    }
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _get = __webpack_require__(19);

	var isIOS = Xut.plat.isIOS;
	var isAndroid = Xut.plat.isAndroid;

	//杂志直接打开
	exports.default = {

	    /**
	     * 资源图片
	     * @return {[type]} [description]
	     */
	    resources: function resources(config) {
	        if (isIOS) {
	            return (0, _get.getSourcePath)();
	        }
	        if (isAndroid) {
	            if (parseInt(config.storageMode)) {
	                //sd卡加载资源数据
	                return "/sdcard/appcarrier/magazine/" + config.appId + "/" + (0, _get.getSourcePath)();
	            } else {
	                //android_asset缓存加载资源
	                return "/android_asset/www/" + (0, _get.getSourcePath)();
	            }
	        }
	    },


	    /**
	     * 视频路径
	     * ios平台在缓存
	     * 安卓在编译raw中
	     */
	    video: function video() {
	        if (isIOS) {
	            return (0, _get.getSourcePath)();
	        }
	        if (isAndroid) {
	            return 'android.resource://#packagename#/raw/';
	        }
	    },


	    /**
	     * 音频路径
	     * ios平台在缓存
	     * 安卓在缓存中
	     * @return {[type]} [description]
	     */
	    audio: function audio() {
	        if (isIOS) {
	            return (0, _get.getSourcePath)();
	        }
	        if (isAndroid) {
	            return "/android_asset/www/" + (0, _get.getSourcePath)();
	        }
	    },


	    /**
	     * 读取svg路径前缀
	     * @return {[type]} [description]
	     */
	    svg: function svg() {
	        return 'www/' + (0, _get.getSourcePath)();
	    },


	    /**
	     * js零件
	     * 2016.8.3 喵喵学
	     * @return {[type]} [description]
	     */
	    jsWidget: function jsWidget() {
	        if (isIOS) {
	            return (0, _get.getWidgetPath)();
	        }
	        if (isAndroid) {
	            return "/android_asset/www/" + (0, _get.getWidgetPath)();
	        }
	    }
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.destroyCache = destroyCache;
	exports.destroyResult = destroyResult;

	var _result = __webpack_require__(21);

	var _cache = __webpack_require__(20);

	/**
	 * 销毁缓存
	 */
	function destroyCache(isRefresh) {
	  (0, _cache.removeCache)(); //userCache
	}

	/**
	 * 销毁结果集
	 * @param  {Boolean} isRefresh [description]
	 * @return {[type]}            [description]
	 */
	function destroyResult(isRefresh) {
	  (0, _result.removeResults)(); //json database
	}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = execute;

	var _result = __webpack_require__(21);

	var _index = __webpack_require__(1);

	/**
	 * 创建执行方法
	 * @return {[type]} [description]
	 */
	function createfactory(sql, fn) {
	    var key;
	    if (typeof sql === 'string') {
	        fn(key, sql);
	    } else {
	        for (key in sql) {
	            fn(key, sql[key]);
	        }
	    }
	}

	/**
	 * 模拟database获取数据
	 * @return {[type]}            [description]
	 */
	function executeDB(sql, callback, errorCB, tName) {
	    var jsonResult = (0, _result.getResults)();
	    var data = void 0;
	    var resultObj = void 0;

	    //如果json格式数据
	    if (jsonResult) {
	        if (jsonResult[tName]) {
	            data = jsonResult[tName];
	            resultObj = {
	                length: Object.keys(data).length,
	                item: function item(num) {
	                    return data[num];
	                }
	            };
	            callback(resultObj);
	        } else {
	            errorCB({
	                tName: ':table not exist!!'
	            });
	        }
	    }
	    //否则直接ajax php
	    else {
	            $.ajax({
	                url: _index.config.onlineModeUrl,
	                dataType: 'json',
	                data: {
	                    xxtsql: sql
	                },
	                success: function success(rs) {
	                    data = rs;
	                    resultObj = {
	                        length: rs.length,
	                        item: function item(num) {
	                            return data[num];
	                        }
	                    };
	                    callback(resultObj);
	                },

	                error: errorCB
	            });
	        }
	}

	//建立sql查询
	function execute(selectSql, callback) {

	    var database = _index.config.db,
	        tableName,
	        //表名
	    successResults = {},
	        //成功的数据
	    tempClosure = [],
	        //临时收集器
	    collectError = [],
	        //收集错误查询
	    buildTotal = function () {
	        //如果只有一条
	        if (typeof selectSql === 'string') {
	            return 1;
	        } else {
	            return Object.keys(selectSql).length;
	        }
	    }();

	    createfactory(selectSql, function (key, value) {
	        //开始执行查询
	        createSelect(key || 'results', value);
	    });

	    /**
	     * 创建查询
	     */
	    function createSelect(key, value) {
	        buildTotal--;
	        tempClosure.push(executeTemplate(key, value));
	        0 === buildTotal && executeBuild();
	    }

	    /**
	     * 执行查询
	     * @return {[type]} [description]
	     */
	    function executeBuild() {
	        if (tempClosure.length) {
	            var temp = tempClosure.shift();
	            tableName = temp.tableName;
	            temp.execute();
	        } else {
	            //successResults['results'] 成功表数据
	            //collectError 失败表
	            callback(successResults['results'] ? successResults['results'] : successResults, collectError);
	        }
	    }

	    //成功后方法
	    function success() {
	        executeBuild();
	    }

	    //失败
	    function errorCB(error) {
	        collectError.push(tableName);
	        console.log("数据查询错误 " + error.message, '类型', tableName);
	        executeBuild();
	    }

	    /**
	     * 构建执行作用域
	     */
	    function executeTemplate(tName, sql) {
	        return {
	            tableName: tName,
	            execute: function execute() {
	                //支持本地查询
	                if (database) {
	                    database.transaction(function (tx) {
	                        tx.executeSql(sql, [], function (tx, result) {
	                            successResults[tName] = result.rows;
	                        });
	                    }, errorCB, success);
	                }
	                //json与ajax
	                else {
	                        executeDB(sql, function (result) {
	                            successResults[tName] = result;
	                            success();
	                        }, errorCB, tName);
	                    }
	            }
	        };
	    }
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.createStore = createStore;

	var _sql = __webpack_require__(30);

	var _cache = __webpack_require__(20);

	/**
	 * 初始化数据类
	 * 获取ppt总数
	 * @return {[type]} [description]
	 */
	function createStore(callback) {
	    (0, _sql.dataQuery)(function (results, collectError) {
	        //保存缓存
	        (0, _cache.saveCache)(results, collectError);
	        //数据缓存转化
	        (0, _cache.convertCache)();
	        //设置API
	        (0, _cache.setApi)(results.Novel.item(0)['_id']);
	        callback(results);
	    });
	}

/***/ },
/* 97 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * 计算数据偏移量
	 * @param  {[type]} tableName [description]
	 * @return {[type]}           [description]
	 */
	var dataOffset = exports.dataOffset = function dataOffset(dataCache) {

	    var set = function set(tableName) {
	        var start = void 0;
	        var data = dataCache[tableName];
	        if (data.length) {
	            if (data.item(0)) {
	                if (start = data.item(0)._id) {
	                    dataCache[tableName].start = start;
	                }
	            }
	        }
	    };

	    //数据段标记
	    for (var key in dataCache) {
	        if (dataCache[key].item) {
	            set(key);
	        }
	    }

	    return dataCache;
	};

	/**
	 * 转化video的activtiy信息
	 * 因为Video不是靠id关联的 是靠activtiy关联
	 * [description]
	 * @return {[type]} [description]
	 */
	var transformVideoActivity = exports.transformVideoActivity = function transformVideoActivity(dataCache) {
	    var data = void 0;
	    var activityIds = {};
	    var video = dataCache.Video;
	    _.each(video, function (_, index) {
	        data = video.item(index);

	        //确保activityIdID是有值，
	        //这样才是靠activity关联的video,
	        //而不是动画的video
	        if (data && data.activityId) {
	            activityIds[data.activityId] = data._id;
	        }
	    });
	    return activityIds;
	};

	/**
	 * chpater分段
	 * 转化section信息
	 * 带有场景处理
	 * @return {[type]} [description]
	 */
	var transformSectionRelated = exports.transformSectionRelated = function transformSectionRelated(dataCache) {
	    var seasonId,
	        start,
	        length,
	        sid,
	        i,
	        id,
	        seasonInfo,
	        toolbar,
	        Chapters,
	        container = {},
	        Chapter = dataCache.Chapter,
	        l = Chapter.length,
	        end = 0;

	    //找到指定的season信息
	    var findSeasonInfo = function findSeasonInfo(seasonId) {
	        var temp,
	            seasonNum = dataCache.Season.length;
	        while (seasonNum--) {
	            if (temp = dataCache.Season.item(seasonNum)) {
	                if (temp._id == seasonId) {
	                    return temp;
	                }
	            }
	        }
	    };

	    for (i = 0; i < l; i++) {
	        Chapters = Chapter.item(i);
	        if (Chapters) {
	            id = Chapters._id - 1; //保存兼容性,用0开头
	            seasonId = Chapters.seasonId;
	            sid = 'seasonId->' + seasonId;
	            //如果不在集合,先创建
	            if (!container[sid]) {
	                //场景工具栏配置信息
	                if (seasonInfo = findSeasonInfo(seasonId)) {
	                    toolbar = seasonInfo.parameter;
	                }
	                container[sid] = {
	                    start: id,
	                    length: 1,
	                    end: id,
	                    toolbar: toolbar
	                };
	            } else {
	                container[sid].end = id;
	                container[sid].length = container[sid].length + 1;
	            }
	        }
	    }

	    return container;
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _index = __webpack_require__(56);

	var _index2 = _interopRequireDefault(_index);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {

	    /**
	     * 创建节点
	     * @return {[type]}
	     */
	    createDom: function createDom() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _id = _ref._id,
	            md5 = _ref.md5,
	            actType = _ref.actType,
	            scaleWidth = _ref.scaleWidth,
	            scaleHeight = _ref.scaleHeight,
	            scaleTop = _ref.scaleTop,
	            scaleLeft = _ref.scaleLeft;

	        var chpaterData = arguments[1];
	        var chapterId = arguments[2];
	        var pageIndex = arguments[3];
	        var zIndex = arguments[4];
	        var pageType = arguments[5];


	        //热点背景图
	        var backgroundImage = '';
	        if (md5) {
	            backgroundImage = "background-image: url(" + Xut.config.pathAddress + md5 + ");";
	        }

	        var id = actType + "_" + _id;

	        var html = '<div id="' + id + '"\n                           data-belong="' + pageType + '"\n                           data-delegate="action"\n                           style="cursor:pointer;\n                                  width:' + scaleWidth + 'px;\n                                  height:' + scaleHeight + 'px;\n                                  left:' + scaleLeft + 'px;\n                                  top:' + scaleTop + 'px;\n                                  background-size:100% 100%;\n                                  position:absolute;\n                                  z-index:' + zIndex + ';\n                                  ' + backgroundImage + '">\n                      </div>';

	        return String.styleFormat(html);
	    }

	    /*
	     * touchEnd 全局派发的点击事件
	     * 如果stopGlobalEvent == ture 事件由全局派发
	     */
	    ,
	    trigger: function trigger(data) {
	        (0, _index2.default)(data);
	    }
	}; /**
	    * 动作热点
	    * 1. 跳转页面
	    * 2. 打开系统应用程序
	    */

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _index = __webpack_require__(2);

	var _index2 = __webpack_require__(1);

	var _manager = __webpack_require__(6);

	var _manager2 = __webpack_require__(4);

	//临时音频动作数据
	var tempData = {};

	exports.default = {
	    createDom: function createDom() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _id = _ref._id,
	            md5 = _ref.md5,
	            actType = _ref.actType,
	            category = _ref.category,
	            itemArray = _ref.itemArray,
	            scaleWidth = _ref.scaleWidth,
	            scaleHeight = _ref.scaleHeight,
	            scaleTop = _ref.scaleTop,
	            scaleLeft = _ref.scaleLeft;

	        var chpaterData = arguments[1];
	        var chapterId = arguments[2];
	        var pageIndex = arguments[3];
	        var zIndex = arguments[4];
	        var pageType = arguments[5];


	        var html = void 0;
	        var mediaIcon = '';
	        var startImage = '';

	        //如果没有宽高则不创建绑定节点
	        if (!scaleWidth || !scaleHeight) return '';

	        //解析音乐动作
	        //冒泡动作靠节点传递数据
	        if (itemArray) {
	            itemArray = (0, _index.parseJSON)(itemArray);
	            var start = itemArray[0];
	            var stop = itemArray[1];
	            tempData[_id] = {};
	            if (start) {
	                if (start.startImg) {
	                    startImage = start.startImg;
	                    tempData[_id]['startImg'] = startImage;
	                    startImage = 'background-image:url(' + _index2.config.pathAddress + startImage + ');';
	                }
	                if (start.script) {
	                    tempData[_id]['startScript'] = start.script;
	                }
	            }
	            if (stop) {
	                if (stop.stopImg) {
	                    tempData[_id]['stopImg'] = stop.stopImg;
	                }
	                if (stop.script) {
	                    tempData[_id]['stopScript'] = stop.script;
	                }
	            }
	        }

	        //首字母大写
	        var mediaType = category.replace(/(\w)/, function (v) {
	            return v.toUpperCase();
	        });

	        var viewSize = _index2.config.viewSize;

	        //只针对网页插件增加单独的点击界面
	        //如果有视频图标
	        if (category == 'webpage' && scaleWidth > 200 && scaleHeight > 100 && scaleWidth <= viewSize.width && scaleHeight <= viewSize.height) {

	            var mediaIconSize = 74;
	            var posX = (scaleWidth - mediaIconSize) / 2;
	            var posY = (scaleHeight - mediaIconSize) / 2;
	            var icon = 'background-image:url(images/icons/web_hotspot.png)';
	            mediaIcon = '<div id="icon_' + _id + '"\n                                  type="icon"\n                                  style="width:' + mediaIconSize + 'px;\n                                         height:' + mediaIconSize + 'px;\n                                         top:' + posY + 'px;\n                                         left:' + posX + 'px;\n                                         position:absolute;\n                                         ' + icon + '">\n                          </div>';
	        }

	        //创建音频对象
	        //Webpage_1
	        //Audio_1
	        //Video_1
	        return String.styleFormat('<div id="' + (mediaType + "_" + _id) + '"\n                      data-belong="' + pageType + '"\n                      data-delegate="' + category + '"\n                      style="width:' + scaleWidth + 'px;\n                             height:' + scaleHeight + 'px;\n                             left:' + scaleLeft + 'px;\n                             top:' + scaleTop + 'px;\n                             z-index:' + zIndex + ';\n                             ' + startImage + '\n                             background-size:100% 100%;\n                             position:absolute;">\n                ' + mediaIcon + '\n            </div>');
	    }

	    /**
	     * 仅创建一次
	     * data传递参数问题
	     * @param  {[type]} id [description]
	     * @return {[type]}    [description]
	     */
	    ,
	    onlyCreateOnce: function onlyCreateOnce(id) {
	        var data;
	        if (data = tempData[id]) {
	            delete tempData[id];
	            return data;
	        }
	    }

	    /**
	     * 自动运行
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    autoPlay: function autoPlay(_ref2) {
	        var id = _ref2.id,
	            category = _ref2.category,
	            rootNode = _ref2.rootNode,
	            pageIndex = _ref2.pageIndex,
	            chapterId = _ref2.chapterId;

	        if (!category) return;
	        if (category == 'audio') {
	            (0, _manager.autoAudio)(chapterId, id, this.onlyCreateOnce(id));
	        } else {
	            (0, _manager2.autoVideo)(chapterId, id, rootNode);
	        }
	    }

	    /**
	     * touchEnd 全局派发的点击事件
	     * 如果stopGlobalEvent == ture 事件由全局派发
	     */
	    ,
	    trigger: function trigger(_ref3) {
	        var id = _ref3.id,
	            target = _ref3.target,
	            rootNode = _ref3.rootNode,
	            pageIndex = _ref3.pageIndex,
	            activityId = _ref3.activityId;

	        var category = target.getAttribute('data-delegate');
	        if (category) {
	            var chapterId = Xut.Presentation.GetPageId(pageIndex);
	            /**
	             * 传入chapterId 页面ID
	             * activityId    视频ID
	             * eleName       节点名  //切换控制
	             * 根节点
	             */
	            if (category == 'audio') {
	                (0, _manager.triggerAudio)(chapterId, activityId, this.onlyCreateOnce(id));
	            } else {
	                var videoObj = (0, _manager2.hasVideoObj)(chapterId, activityId);
	                if (videoObj) {
	                    videoObj.play();
	                } else {
	                    (0, _manager2.triggerVideo)(chapterId, activityId, $(rootNode));
	                }
	            }
	        }
	    }
	};

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _index = __webpack_require__(82);

	var _index2 = __webpack_require__(1);

	exports.default = {

	    /**
	     * 创建热点元素结构（用于布局可触发点）
	     * 根据数据创建自己的热点元素结构（用于拼接结构字符串）
	     * 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
	     * actType + "_" + _id
	     * @return {[type]}              [description]
	     */
	    createDom: function createDom(activityData, chpaterData, chapterId, pageIndex, zIndex, pageType) {

	        var id = activityData['_id'];
	        var width = activityData.scaleWidth;
	        var height = activityData.scaleHeight;
	        var newWidth = (width + height) / 2 * _index2.config.iconHeight;

	        var html = '<div id="ShowNote_' + id + '"\n                      class="xut-showNote"\n                      data-belong ="' + pageType + '"\n                      data-delegate="shownote"\n                      style="width:' + newWidth + 'px;height:' + newWidth + 'px">\n                 </div>';

	        return String.styleFormat(html);
	    }

	    /**
	     * touchEnd 全局派发的点击事件
	     * 如果stopGlobalEvent == ture 事件由全局派发
	     */
	    ,
	    trigger: function trigger(data) {
	        data.data = Xut.Presentation.GetPageData(data.pageIndex);
	        new _index.ShowNote(data);
	    }

	    /**
	     * 自动运行生成Action或者widget触发点对象
	     * @param  {[type]} opts [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    autoPlay: function autoPlay() {}

	    /**
	     * 销毁页面hotspot事件与Action或widget事件
	     * @param  {[type]} activeObejct [需要处理的活动对象]
	     * @param  {[type]} pageIndex    [页码标示]
	     * @param  {[type]} rootEle      [根元素]
	     * @return {[type]}              [description]
	     */
	    ,
	    destroy: function destroy(opts) {
	        this && this.destroy();
	    }
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _adapter = __webpack_require__(84);

	exports.default = {

	    /**
	     * 创建热点元素结构（用于布局可触发点
	     * 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
	     * 根据数据创建自己的热点元素结构（用于拼接结构字符串）
	     * @return {[type]}              [description]
	     */
	    createDom: function createDom() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _id = _ref._id,
	            md5 = _ref.md5,
	            autoPlay = _ref.autoPlay,
	            actType = _ref.actType,
	            scaleWidth = _ref.scaleWidth,
	            scaleHeight = _ref.scaleHeight,
	            scaleTop = _ref.scaleTop,
	            scaleLeft = _ref.scaleLeft;

	        var chpaterData = arguments[1];
	        var chapterId = arguments[2];
	        var pageIndex = arguments[3];
	        var zIndex = arguments[4];
	        var pageType = arguments[5];


	        var backgroundImage = '';

	        //如果是自动播放,则不创建结构
	        if (autoPlay) {
	            return '';
	        }

	        //热点背景图
	        if (md5) {
	            backgroundImage = "background-image: url(" + Xut.config.pathAddress + md5 + ");";
	        }

	        var id = actType + "_" + _id;
	        var html = '<div id="' + id + '"\n                  data-belong="' + pageType + '"\n                  data-delegate="' + actType + '"\n                  style="cursor:pointer;\n                         background-size:100% 100%;\n                         position:absolute;\n                         width:' + scaleWidth + 'px;\n                         height:' + scaleHeight + 'px;\n                         left:' + scaleLeft + 'px;\n                         top:' + scaleTop + 'px;\n                         z-index:' + zIndex + ';\n                         ' + backgroundImage + '">\n            </div>';

	        return String.styleFormat(html);
	    }

	    /**
	     * 自动零件
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    autoPlay: function autoPlay() {
	        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            id = _ref2.id,
	            rootNode = _ref2.rootNode,
	            pageType = _ref2.pageType,
	            pageIndex = _ref2.pageIndex;

	        (0, _adapter.Adapter)({
	            rootNode: rootNode,
	            pageType: pageType,
	            pageIndex: pageIndex,
	            activityId: id,
	            isAutoPlay: true
	        });
	    }

	    /**
	     * 事件委托
	     * 通过点击触发
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    trigger: function trigger(data) {
	        return (0, _adapter.Adapter)(data);
	    }
	};

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = setDynamicApi;

	var _option = __webpack_require__(11);

	var typeFilter = ['page', 'master'];

	/**
	 * 合并参数设置
	 * 1 pageMgr
	 * 2 masterMgr
	 * 3 修正pageType
	 * 4 args参数
	 * 5 回调每一个上下文
	 */
	/**
	 * 应用对外接口
	 * 此模块的所有方法都是动态修正上下文，自动切换场景
	 * 1.   Xut.Application
	 *          a)  整个应用程序的接口，执行应用级别的操作，例如退出应用之类。
	 * 2.   Xut.DocumentWindow
	 *          a)  窗口的接口。窗口就是电子杂志的展示区域，可以操作诸如宽度、高度、长宽比之类。
	 * 3.   Xut.View
	 *          a)  视图接口。视图是窗口的展示方式，和页面相关的接口，都在这里。
	 * 4.   Xut.Presentation
	 *          a)  数据接口。和电子杂志的数据相关的接口，都在这里。
	 * 5.   Xut.Slides
	 *          a)  所有页面的集合
	 * 6.   Xut.Slide
	 *          a)  单个页面
	 * 7.   Xut.Master
	 *          a)  页面的母版
	 * @return {[type]} [description]
	 */

	var createaAccess = function createaAccess(mgr) {
	    return function (callback, pageType, args, eachContext) {
	        //如果第一个参数不是pageType模式
	        //参数移位
	        if (pageType !== undefined && -1 === typeFilter.indexOf(pageType)) {
	            var temp = args;
	            args = pageType;
	            eachContext = temp;
	            pageType = 'page';
	        }

	        //pageIndex为pageType参数
	        if (-1 !== typeFilter.indexOf(args)) {
	            pageType = args;
	            args = null;
	        }

	        pageType = pageType || 'page';

	        if (mgr[pageType]) {
	            return callback(mgr[pageType], pageType, args, eachContext);
	        } else {
	            // console.log('传递到access的pageType错误！')
	        }
	    };
	};

	/**
	 * 判断是否存在页码索引
	 * 如果不存在默认取当前页面
	 */
	var createExistIndex = function createExistIndex($globalEvent) {
	    return function (pageIndex) {
	        //如果不存在
	        if (pageIndex == undefined) {
	            pageIndex = $globalEvent.getHindex(); //当前页面
	        }
	        return pageIndex;
	    };
	};

	function setDynamicApi(vm) {

	    var $globalEvent = vm.$globalEvent;
	    var options = vm.options;
	    var $dispatcher = vm.$dispatcher;

	    //页面与母版的管理器
	    var access = createaAccess({
	        page: $dispatcher.pageMgr,
	        master: $dispatcher.masterMgr
	    });

	    var isExistIndex = createExistIndex($globalEvent);

	    /**
	     * 获取当前页码
	     */
	    Xut.Presentation.GetPageIndex = function () {
	        return $globalEvent.getHindex();
	    };

	    /**
	     * 获取页面的总数据
	     * 1 chapter数据
	     * 2 section数据
	     * @return {[type]}
	     */
	    _.each(["Section", "Page"], function (apiName) {
	        Xut.Presentation['GetApp' + apiName + 'Data'] = function (callback) {
	            var i = 0,
	                temp = [],
	                cps = Xut.data.query('app' + apiName),
	                cpsLength = cps.length;
	            for (i; i < cpsLength; i++) {
	                temp.push(cps.item(i));
	            }
	            return temp;
	        };
	    });

	    /**
	     * 获取首页的pageId
	     * @param {[type]} seasonId [description]
	     */
	    Xut.Presentation.GetFirstPageId = function (seasonId) {
	        var sectionRang = Xut.data.query('sectionRelated', seasonId);
	        var pageData = Xut.data.query('appPage');
	        return pageData.item(sectionRang.start);
	    };

	    /**
	     *  四大数据接口
	     *  快速获取一个页面的nodes值
	     *  获取当前页面的页码编号 - chapterId
	     *  快速获取指定页面的chapter数据
	     *  pagebase页面管理对象
	     * @return {[type]}            [description]
	     */
	    _.each(["GetPageId", "GetPageNode", "GetPageData", "GetPageObj"], function (apiName) {
	        Xut.Presentation[apiName] = function (pageType, pageIndex) {
	            return access(function (manager, pageType, pageIndex) {
	                pageIndex = isExistIndex(pageIndex);
	                return manager["abstract" + apiName](pageIndex, pageType);
	            }, pageType, pageIndex);
	        };
	    });

	    /**
	     * 得到页面根节点
	     * li节点
	     */
	    Xut.Presentation.GetPageElement = function () {
	        var obj = Xut.Presentation.GetPageObj();
	        return obj.$pageNode;
	    };

	    /**
	     * 获取页码标记
	     * 因为非线性的关系，页面都是按chpater组合的
	     * page_0
	     * page_10
	     * 但是每一个章节页面的索引是从0开始的
	     * 区分pageIndex
	     */
	    Xut.Presentation.GetPagePrefix = function (pageType, pageIndex) {
	        var pageObj = Xut.Presentation.GetPageObj(pageType, pageIndex);
	        return pageObj.pid;
	    };

	    //命名前缀
	    var prefix = 'Content_';

	    /**
	     * 创建一个content的命名规则
	     */
	    Xut.Presentation.MakeContentPrefix = function (pageIndex) {
	        return prefix + Xut.Presentation.GetPagePrefix(pageIndex) + "_";
	    };

	    /**
	     * 获取命名规则
	     */
	    Xut.Presentation.GetContentName = function (id) {
	        if (id) {
	            return prefix + Xut.Presentation.GetPagePrefix() + "_" + id;
	        } else {
	            return prefix + Xut.Presentation.GetPagePrefix();
	        }
	    };

	    /**
	     * 设置页面的potion编码
	     * 为分栏修改
	     */
	    Xut.View.setPointer = function (pageIndex) {
	        $globalEvent.setPointer(pageIndex);
	    };

	    /**
	     * 更新页码
	     * @param {[type]} point [description]
	     *   parentIndex  父索引
	     *   subIndex     子索引
	     */
	    Xut.View.PageUpdate = function () {
	        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
	            arg[_key] = arguments[_key];
	        }

	        vm.$emit.apply(vm, ['change:pageUpdate'].concat(arg));
	    };

	    /**
	     * 显示工具栏
	     * 没有参数显示 工具栏与控制翻页按钮
	     * 有参数单独显示指定的
	     */
	    Xut.View.ShowToolBar = function (point) {
	        vm.$emit('change:toggleToolbar', 'show', point);
	    };

	    /**
	     * 隐藏工具栏
	     * 没有参数隐藏 工具栏与控制翻页按钮
	     * 有参数单独隐藏指定
	     */
	    Xut.View.HideToolBar = function (point) {
	        vm.$emit('change:toggleToolbar', 'hide', point);
	    };

	    /**
	     * 指定特定的显示与隐藏
	     *  Xut.View.Toolbar({
	     *       show :'bottom',
	     *       hide :'controlBar'
	     *   })
	     *
	     *  //工具栏与翻页按钮全部显示/隐藏
	     *  Xut.View.Toolbar('show')
	     *  Xut.View.Toolbar('hide')
	     *
	     * @return {[type]} [description]
	     */
	    Xut.View.Toolbar = function (cfg) {
	        vm.$emit('change:toggleToolbar', cfg);
	    };

	    /**
	     * 跳转到上一个页面
	     */
	    Xut.View.GotoPrevSlide = function (seasonId, chapterId) {
	        if (seasonId && chapterId) {
	            Xut.View.LoadScenario({
	                'scenarioId': seasonId,
	                'chapterId': chapterId
	            });
	            return;
	        }

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
	            location.href = Xut.IBooks.pageIndex - 1 + ".xhtml";
	            return;
	        }

	        options.multiplePages && $globalEvent.prev();
	    };

	    /**
	     * 跳转到下一个页面
	     */
	    Xut.View.GotoNextSlide = function (seasonId, chapterId) {
	        if (seasonId && chapterId) {
	            Xut.View.LoadScenario({
	                'scenarioId': seasonId,
	                'chapterId': chapterId
	            });
	            return;
	        }

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
	            location.href = Xut.IBooks.pageIndex + 1 + ".xhtml";
	            return;
	        }

	        options.multiplePages && $globalEvent.next();
	    };

	    /**
	     * 跳转页面
	     * 场景内部切换
	     * 跳转到指定编号的页面
	     * Action 类型跳转
	     * xxtlink 超连接跳转,svg内嵌跳转标记处理
	     * 文本框跳转
	     * ........
	     */
	    Xut.View.GotoSlide = function (seasonId, chapterId) {

	        //修正参数
	        var fixParameter = function fixParameter(pageIndex) {
	            pageIndex = Number(pageIndex) - 1;
	            if (pageIndex < 0) {
	                pageIndex = 0;
	            }
	            return pageIndex;
	        };

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (Xut.IBooks.Enabled && Xut.IBooks.runMode() && chapterId) {
	            location.href = chapterId + ".xhtml";
	            return;
	        }

	        //兼容数据错误
	        if (!seasonId && !chapterId) return;

	        //如果是一个参数是传递页码数,则为内部跳转
	        if (arguments.length === 1) {
	            //复位翻页按钮
	            vm.$emit('change:showNext');
	            return $globalEvent.scrollToPage(fixParameter(seasonId));
	        }

	        //场景模式内部跳转
	        if (options.scenarioId == seasonId) {
	            //chpaterId 转化成实际页码
	            var sectionRang = Xut.data.query('sectionRelated', seasonId);
	            var pageIndex = chapterId - sectionRang.start;
	            vm.$emit('change:showNext');
	            return $globalEvent.scrollToPage(fixParameter(pageIndex));
	        }

	        //场景与场景的跳转
	        return Xut.View.LoadScenario({
	            'scenarioId': seasonId,
	            'chapterId': chapterId
	        });
	    };

	    /**
	     * 是否为翻页的边界
	     * @return {Boolean} [description]
	     */
	    Xut.View.isFlipBorderBounce = function (distance) {
	        return $globalEvent.isBorder(distance);
	    };

	    /**
	     * 页面滑动
	     * @param {[type]} distance  [description]
	     * @param {[type]} speed     [description]
	     * @param {[type]} direction [description]
	     * @param {[type]} action    [description]
	     */
	    Xut.View.MovePage = function (distance, speed, direction, action) {

	        //如果禁止翻页模式 || 如果是滑动,不是边界
	        if (!options.multiplePages || $globalEvent.isMoving() || action === 'flipMove' && $globalEvent.isBorder(distance)) {
	            return;
	        }

	        var pagePointer = $globalEvent.getPointer();
	        var data = {
	            'distance': distance,
	            'speed': speed,
	            'direction': direction,
	            'action': action,
	            'leftIndex': pagePointer.leftIndex,
	            'pageIndex': pagePointer.currIndex,
	            'rightIndex': pagePointer.rightIndex
	        };
	        $dispatcher.movePageBases(data);
	    };

	    /**
	     * 辅助对象的控制接口
	     * 运行辅助动画
	     * 辅助对象的activityId,或者合集activityId
	     * Run
	     * stop
	     * 1 零件
	     * 2 音频动画
	     */
	    _.each(["Run", "Stop"], function (apiName) {
	        Xut.Assist[apiName] = function (pageType, activityId, outCallBack) {
	            access(function (manager, pageType, activityId, outCallBack) {
	                //数组
	                if (_.isArray(activityId)) {
	                    //完成通知
	                    var markComplete = function () {
	                        var completeStatistics = activityId.length; //动画完成统计
	                        return function () {
	                            if (completeStatistics === 1) {
	                                outCallBack && outCallBack();
	                                markComplete = null;
	                            }
	                            completeStatistics--;
	                        };
	                    }();
	                    _.each(activityId, function (id) {
	                        manager.abstractAssistAppoint(id, $globalEvent.getHindex(), markComplete, apiName);
	                    });
	                } else {
	                    manager.abstractAssistAppoint(activityId, $globalEvent.getHindex(), outCallBack, apiName);
	                }
	            }, pageType, activityId, outCallBack);
	        };
	    });

	    /**
	     * 针对page页面的content类型操作接口
	     * @type {[type]}
	     */

	    /**
	     * 获取指定的对象
	     * 传递参数
	     * 单一 id
	     * 数据id合集 [1,2,4,5,6]
	     * @param {[type]}   contentIds  [description]
	     * @param {Function} eachContext 回调遍历每一个上下文
	     */
	    Xut.Contents.Get = function (pageType, contentIds, eachContext) {

	        return access(function (manager, pageType, contentIds, eachContext) {

	            var contentObj,
	                contentObjs,
	                pageIndex = Xut.Presentation.GetPageIndex();

	            function findContent(currIndex, contentId) {
	                var pageObj;
	                if (pageObj = manager.abstractGetPageObj(currIndex)) {
	                    return pageObj.baseGetContentObject(contentId);
	                }
	            }

	            //如果传递是数组合集
	            if (_.isArray(contentIds)) {
	                contentObjs = [];
	                _.each(contentIds, function (id) {
	                    contentObj = findContent(pageIndex, id);
	                    if (eachContext) {
	                        //传递每一个处理的上下文
	                        eachContext(id, contentObj);
	                    } else {
	                        if (contentObj) {
	                            contentObjs.push(contentObj);
	                        } else {
	                            // console.log('error', '找不到对应的content数据' + id)
	                        }
	                    }
	                });
	                return contentObjs;
	            }

	            //如果传递的是Content_1_3组合情况
	            if (/_/.test(contentIds)) {
	                var expr = contentIds.split('_');
	                if (expr.length > 1) {
	                    return findContent(expr[1], expr[2]);
	                }
	            }

	            //单一content id
	            contentObj = findContent(pageIndex, contentIds);

	            if (eachContext) {
	                eachContext(contentObj);
	            } else {
	                return contentObj;
	            }
	        }, pageType, contentIds, eachContext);
	    };

	    /**
	     * 得到指定页面零件的数据
	     * 获取指定的content数据
	     * @param  {[type]} contentId [description]
	     * @return {[type]}           [description]
	     */
	    Xut.Contents.GetPageWidgetData = function (pageType, contentId) {

	        //如果没有传递pageType取默认
	        if (-1 === typeFilter.indexOf(pageType)) {
	            contentId = pageType;
	            pageType = 'page';
	        }

	        //必须有数据
	        if (!contentId || !contentId.length) {
	            return;
	        }

	        //保证是数组格式
	        if (_.isString(contentId)) {
	            contentId = [contentId];
	        }

	        var contentDas,
	            contents = [];

	        Xut.Contents.Get(pageType, contentId, function (cid, content) {
	            //是内部对象
	            if (content && (contentDas = content.contentDas)) {
	                //通过内部管理获取对象
	                contents.push({
	                    'id': content.id,
	                    'idName': content.actName,
	                    'element': content.$contentNode,
	                    'theTitle': contentDas.theTitle,
	                    'scaleHeight': contentDas.scaleHeight,
	                    'scaleLeft': contentDas.scaleLeft,
	                    'scaleTop': contentDas.scaleTop,
	                    'scaleWidth': contentDas.scaleWidth,
	                    'contentData': contentDas,
	                    'source': 'innerObjet' //获取方式内部对象
	                });
	            } else {
	                //如果通过内部找不到对象的content数据,则直接查找数据库
	                //可能是一个事件的钩子对象
	                if (contentDas = seekQuery(cid)) {
	                    var actName = Xut.Presentation.GetContentName(cid);
	                    var element;
	                    //如果对象是事件钩子或者是浮动对象
	                    //没有具体的数据
	                    if (content && content.$contentNode) {
	                        element = content.$contentNode;
	                    } else {
	                        element = $('#' + actName);
	                    }
	                    contents.push({
	                        'id': cid,
	                        'idName': actName,
	                        'element': element,
	                        'theTitle': contentDas.theTitle,
	                        'scaleHeight': contentDas.scaleHeight,
	                        'scaleLeft': contentDas.scaleLeft,
	                        'scaleTop': contentDas.scaleTop,
	                        'scaleWidth': contentDas.scaleWidth,
	                        'contentData': contentDas,
	                        'source': 'dataBase'
	                    });
	                } else {
	                    // console.log('error', '找不到对应的GetPageWidgetData数据' + cid)
	                }
	            }
	        });
	        return contents;
	    };

	    //数据库查找
	    function seekQuery(id) {
	        var contentData = Xut.data.query('Content', id);
	        if (contentData) {
	            return (0, _option.reviseSize)(_.extend({}, contentData));
	        }
	    }

	    /**
	     * 互斥接口
	     * 直接显示\隐藏\停止动画
	     */

	    //检测类型为字符串
	    function typeCheck(objNameList) {
	        return !objNameList || typeof objNameList !== 'string' ? true : false;
	    }

	    /**
	     * 针对文本对象的直接操作
	     * 显示
	     * 隐藏
	     * 停止动画
	     */
	    _.each(["Show", "Hide", "StopAnim"], function (operate) {
	        Xut.Contents[operate] = function (pageType, nameList) {
	            access(function (manager, pageType, nameList) {
	                if (typeCheck(nameList)) return;
	                var pageBaseObj;
	                if (!(pageBaseObj = manager.abstractAssistPocess($globalEvent.getHindex()))) {
	                    console.log('注入互斥接口数据错误！');
	                    return;
	                }
	                _.each(nameList.split(','), function (contentId) {
	                    pageBaseObj.baseContentMutex(contentId, operate);
	                });
	            }, pageType, nameList);
	        };
	    });

	    /**
	     * 获取一个存在的实例对象
	     * 区分不同层级page/master
	     * 不同类型    content/widget
	     */
	    Xut.Application.GetSpecifiedObject = function (pageType, data) {
	        return access(function (manager, pageType) {
	            var pageObj;
	            if (pageObj = manager.abstractGetPageObj(data.pageIndex)) {
	                if (data.type === 'Content') {
	                    return pageObj.baseSpecifiedContent(data);
	                } else {
	                    return pageObj.baseSpecifiedComponent(data);
	                }
	            }
	        }, pageType);
	    };

	    /**
	     * 应用滑动接口
	     * @return {[type]}
	     */

	    /**
	     * 是否翻页中
	     * @return {Boolean} [description]
	     */
	    Xut.Application.Swiping = function () {
	        return $globalEvent.isMoving();
	    };

	    /**
	     * 禁止滑动
	     */
	    Xut.Application.Bansliding = function () {
	        $globalEvent.bansliding();
	    };

	    /**
	     * 允许滑动
	     */
	    Xut.Application.Allowliding = function () {
	        $globalEvent.allowliding();
	    };

	    /**
	     * 设置翻页完成
	     */
	    Xut.Application.SetTransitionComplete = function () {
	        $globalEvent.setTransitionComplete();
	    };

	    _.each(["closeSwipe", "openSwipe"], function (operate) {
	        Xut.Application[operate] = function () {
	            $globalEvent[operate]();
	        };
	    });

	    return function () {
	        $globalEvent = null;
	        $dispatcher = null;
	        access = null;
	        isExistIndex = null;
	    };
	}

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _index = __webpack_require__(1);

	var _scenario = __webpack_require__(155);

	var _controller = __webpack_require__(9);

	var _global = __webpack_require__(104);

	var _global2 = _interopRequireDefault(_global);

	var _index2 = __webpack_require__(16);

	var _index3 = _interopRequireDefault(_index2);

	var _busy = __webpack_require__(23);

	var _index4 = __webpack_require__(8);

	var _index5 = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 *
	 * 杂志全局API
	 *
	 *  *** 有方法体的是全局接口，不会被重载***
	 *  *** 无方法体的是场景接口，总会切换到当前可视区域场景***
	 *
	 * 1.   Xut.Application
	 *          a)  整个应用程序的接口，执行应用级别的操作，例如退出应用之类。
	 * 2.   Xut.DocumentWindow
	 *          a)  窗口的接口。窗口就是电子杂志的展示区域，可以操作诸如宽度、高度、长宽比之类。
	 * 3.   Xut.View
	 *          a)  视图接口。视图是窗口的展示方式，和页面相关的接口，都在这里。
	 * 4.   Xut.Presentation
	 *          a)  数据接口。和电子杂志的数据相关的接口，都在这里。
	 * 5.   Xut.Slides
	 *          a)  所有页面的集合
	 * 6.   Xut.Slide
	 *          a)  单个页面
	 * 7.   Xut.Master
	 *          a)  页面的母版
	 *
	 *
	 * @return {[type]} [description]
	 */

	var plat = Xut.plat;
	var Presentation = Xut.Presentation = {};
	var _View = Xut.View = {};
	var Contents = Xut.Contents = {};
	var Application = Xut.Application = {};

	Xut.Assist = {};

	/**
	 * 获取缓存
	 * @param  {[type]} name [description]
	 * @return {[type]}      [description]
	 */
	var getStorage = function getStorage(name) {
	    return parseInt((0, _index5.$$get)(name));
	};

	/**
	 * 忙碌光标
	 * */
	(0, _index5.$$extend)(_View, {
	    ShowBusy: _busy.ShowBusy,
	    HideBusy: _busy.HideBusy,
	    ShowTextBusy: _busy.ShowTextBusy
	});

	//重复点击
	var repeatClick = false;

	/**
	 * 场景
	 * */
	(0, _index5.$$extend)(_View, {

	    /**
	     * 关闭场景
	     */
	    CloseScenario: function CloseScenario() {
	        if (repeatClick) return;
	        repeatClick = true;
	        var serial = _controller.sceneController.takeOutPrevChainId();
	        _View.LoadScenario({
	            'scenarioId': serial.scenarioId,
	            'chapterId': serial.chapterId,
	            'createMode': 'sysClose'
	        }, function () {
	            repeatClick = false;
	        });
	    },


	    /**
	     * 加载一个新的场景
	     * 1 节与节跳
	     *    单场景情况
	     *    多场景情况
	     * 2 章与章跳
	     * useUnlockCallBack 用来解锁回调,重复判断
	     * isInApp 是否跳转到提示页面
	     */
	    LoadScenario: function LoadScenario(options, useUnlockCallBack) {

	        var seasonId = (0, _index5.toNumber)(options.scenarioId),
	            chapterId = (0, _index5.toNumber)(options.chapterId),
	            pageIndex = (0, _index5.toNumber)(options.pageIndex),
	            createMode = options.createMode,
	            isInApp = options.isInApp;

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (!options.main && Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
	            location.href = chapterId + ".xhtml";
	            return;
	        }

	        //用户指定的跳转入口，而不是通过内部关闭按钮处理的
	        var userAssign = createMode === 'sysClose' ? false : true,

	        //当前活动场景容器对象
	        current = _controller.sceneController.containerObj('current');

	        //获取到当前的页面对象
	        //用于跳转去重复
	        if (current && current.vm) {
	            var curVmPage;
	            if (curVmPage = current.vm.$curVmPage) {
	                if (curVmPage.scenarioId == seasonId && curVmPage.chapterId == chapterId) {
	                    (0, _index5.$$warn)('\u91CD\u590D\u89E6\u53D1\u9875\u9762\u52A0\u8F7D:seasonId:' + seasonId + ',chapterId:' + chapterId);
	                    return;
	                }
	            }
	        }

	        /**
	         * 场景内部跳转
	         * 节相同，章与章的跳转
	         * 用户指定跳转模式,如果目标对象是当前应用页面，按内部跳转处理
	         * @return {[type]}            [description]
	         */
	        if (userAssign && current && current.scenarioId === seasonId) {
	            _View.GotoSlide(seasonId, chapterId);
	            return;
	        }

	        /**
	         * 场景外部跳转
	         * 节与节的跳转,需要对场景的处理
	         */
	        //清理热点动作
	        current && current.vm.$suspend();

	        //通过内部关闭按钮加载新场景处理
	        if (current && userAssign) {
	            //检测是不是往回跳转,重复处理
	            _controller.sceneController.checkToRepeat(seasonId);
	        }

	        /**
	         * 加载新的场景
	         */

	        //读酷启动时不需要忙碌光标
	        if (window.DUKUCONFIG && options.main) {
	            _View.HideBusy();
	        } else {
	            _View.ShowBusy();
	        }

	        /**
	         * 跳出去
	         * $multiScenario
	         * 场景模式
	         * $multiScenario
	         *      true  多场景
	         *      false 单场景模式
	         * 如果当前是从主场景加载副场景
	         * 关闭系统工具栏
	         */
	        if (current && !current.vm.$multiScenario) {
	            _View.HideToolBar();
	        }

	        /**
	         * 重写场景的顺序编号
	         * 用于记录场景最后记录
	         */
	        var pageId;
	        if (current && (pageId = Xut.Presentation.GetPageId())) {
	            _controller.sceneController.rewrite(current.scenarioId, pageId);
	        }

	        /**
	         * 场景信息
	         * @type {[type]}
	         */
	        var sectionRang = Xut.data.query('sectionRelated', seasonId);
	        var barInfo = sectionRang.toolbar; //场景工具栏配置信息
	        var pageTotal = sectionRang.length;

	        /**
	         * 通过chapterId转化为实际页码指标
	         * season 2 {
	         *     chapterId : 1  => 0
	         *     chpaterId : 2  => 1
	         *  }
	         * [description]
	         * @return {[type]} [description]
	         */
	        var parseInitIndex = function parseInitIndex() {
	            return chapterId ? function () {
	                //如果节点内部跳转方式加载,无需转化页码
	                if (createMode === 'GotoSlide') {
	                    return chapterId;
	                }
	                //初始页从0开始，减去下标1
	                return chapterId - sectionRang.start - 1;
	            }() : 0;
	        };

	        /**
	         * 传递的参数
	         * seasonId    节ID
	         * chapterId   页面ID
	         * pageIndex   指定页码
	         * isInApp     是否跳到收费提示页
	         * pageTotal   页面总数
	         * barInfo     工具栏配置文件
	         * history     历史记录
	         * sectionRang 节信息
	         * complete    构件完毕回调
	         * @type {Object}
	         */
	        var data = {
	            seasonId: seasonId,
	            chapterId: chapterId,
	            pageIndex: pageIndex || parseInitIndex(),
	            isInApp: isInApp,
	            pageTotal: pageTotal,
	            barInfo: barInfo,
	            history: options.history,
	            sectionRang: sectionRang,
	            //制作场景切换后处理
	            complete: function complete(nextBack) {
	                //销毁多余场景
	                current && current.destroy();
	                //下一个任务存在,执行切换回调后,在执行页面任务
	                nextBack && nextBack();
	                //去掉忙碌
	                _View.HideBusy();
	                //解锁回调
	                useUnlockCallBack && useUnlockCallBack();
	            }
	        };

	        //主场景判断（第一个节,因为工具栏的配置不同）
	        if (options.main || _controller.sceneController.mianId === seasonId) {
	            //清理缓存
	            (0, _index5.$$remove)("history");
	            //确定主场景
	            _controller.sceneController.mianId = seasonId;
	            //是否主场景
	            data.isMain = true;
	        }

	        new _scenario.SceneFactory(data);
	    }
	});

	/**
	 * 行为
	 * */
	(0, _index5.$$extend)(_View, {
	    /**
	     * 通过插件打开一个新view窗口
	     */
	    Open: function Open(pageUrl, width, height, left, top) {
	        Xut.Plugin.WebView.open(pageUrl, left, top, height, width, 1);
	    },


	    //关闭view窗口
	    Close: function Close() {
	        Xut.Plugin.WebView.close();
	    }
	});

	/**
	 * content
	 * */
	(0, _index5.$$extend)(Contents, {

	    //存在文档碎片
	    //针对音频字幕增加的快捷查找
	    contentsFragment: {},

	    /**
	     * 是否为canvas元素
	     * 用来判断事件冒泡
	     * 判断当前元素是否支持滑动
	     * 默认任何元素都支持滑动
	     * @type {Boolean}
	     */
	    Canvas: {

	        /**
	         * 是否允许滑动
	         * @type {Boolean}
	         */
	        SupportSwipe: true,

	        /**
	         * 对象是否滑动
	         * @type {Boolean}
	         */
	        isSwipe: false,

	        /**
	         * 对象是否点击
	         */
	        isTap: false,

	        /**
	         * 复位标记
	         */
	        Reset: function Reset() {
	            Contents.Canvas.SupportSwipe = true;
	            Contents.Canvas.isSwipe = false;
	        },


	        /**
	         * 判断是否可以滑动
	         * @return {[type]} [description]
	         */
	        getSupportState: function getSupportState() {
	            var state;
	            if (Contents.Canvas.SupportSwipe) {
	                state = true;
	            } else {
	                state = false;
	            }
	            //清空状态
	            Contents.Canvas.Reset();
	            return state;
	        },


	        /**
	         * 判断是否绑定了滑动事件
	         * @return {Boolean} [description]
	         */
	        getIsSwipe: function getIsSwipe() {
	            var state;
	            if (Contents.Canvas.isSwipe) {
	                state = true;
	            } else {
	                state = false;
	            }
	            //清空状态
	            Contents.Canvas.Reset();
	            return state;
	        },


	        /**
	         * 是否绑定了点击事件
	         */
	        getIsTap: function getIsTap() {
	            var state = Contents.Canvas.isTap;
	            Contents.Canvas.isTap = false;
	            return state;
	        }
	    },

	    /**
	     * 恢复节点的默认控制
	     * 默认是系统接管
	     * 如果'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'等事件会重写
	     * 还需要考虑第三方调用，所以需要给一个重写的接口
	     * @return {[type]} [description]
	     * Content_1_3
	     * [Content_1_3,Content_1_4,Content_1_5]
	     */
	    ResetDefaultControl: function ResetDefaultControl(pageType, id, value) {
	        if (!id) return;
	        var elements;
	        var handle = function handle(ele) {
	            if (value) {
	                ele.attr('data-behavior', value);
	            } else {
	                ele.attr('data-behavior', 'disable');
	            }
	        };
	        if ((elements = Contents.Get(pageType, id)) && elements.$contentNode) {
	            handle(elements.$contentNode);
	        } else {
	            elements = $("#" + id);
	            elements.length && handle(elements);
	        }
	    },


	    /**
	     * 针对SVG无节点操作
	     * 关闭控制
	     */
	    DisableControl: function DisableControl(callback) {
	        return {
	            behavior: 'data-behavior',
	            value: 'disable'
	        };
	    },


	    /**
	     * 针对SVG无节点操作
	     * 启动控制
	     */
	    EnableControl: function EnableControl(Value) {
	        return {
	            behavior: 'data-behavior',
	            value: Value || 'click-swipe'
	        };
	    }
	});

	/**
	 * 应用事件监听
	 * 1 完成
	 * Xut.Application.Watch('complete',fn)
	 */
	var __app__ = new _index3.default();
	Application.Watch = function (event, callback) {
	    __app__.$watch('app:' + event, function () {
	        callback.apply(__app__, arguments);
	    });
	};
	Application.Notify = function (event, options) {
	    __app__.$emit('app:' + event, options);
	};

	/**
	 * 后台运行
	 * @type {Number}
	 */
	var backstage = 0;

	/**
	 * 应用加载状态
	 * false未加载
	 * true 已加载
	 * @type {Boolean}
	 */
	var appState = false;

	(0, _index5.$$extend)(Application, {

	    /**
	     * 后台运行
	     * @type {Number}
	     */
	    IsBackStage: function IsBackStage() {
	        return backstage;
	    },


	    /**
	     * home隐藏
	     * 后台运行的时候,恢复到初始化状态
	     * 用于进来的时候激活Activate
	     */
	    Original: function Original() {
	        backstage = 1;

	        //传递一个完全关闭的参数
	        (0, _index4.$$suspend)('', '', true);
	        (0, _index4.$$original)();
	    },


	    /**
	     * home显示
	     * 后台弹回来
	     * 激活应用行为
	     */
	    Activate: function Activate() {
	        backstage = 0;
	        (0, _index4.$$autoRun)();
	    },


	    /**
	     * 销毁应用
	     */
	    Destroy: function Destroy() {
	        (0, _global2.default)('destroy');
	    },


	    /**
	     * 2016.10.11
	     * 刷新程序
	     * 这个与销毁有点区别
	     * 比如外联的数据，不需要删除
	     */
	    Refresh: function Refresh() {
	        (0, _global2.default)('refresh');
	    },


	    /**
	     * 退出app
	     * 提供给iframe方式加载后退出app处理接口
	     */
	    DropApp: function DropApp() {

	        /**
	         * iframe模式,退出处理
	         * @return {[type]} [description]
	         */
	        var destroy = function destroy() {
	            __app__.$off();
	            //退出应用
	            (0, _global2.default)('exit');
	            window.GLOBALCONTEXT = null;
	        };

	        /**
	         * 动态配置
	         * @param  {[type]} window.DYNAMICCONFIGT [description]
	         * @return {[type]}                       [description]
	         */
	        if (window.DYNAMICCONFIGT) {
	            destroy();
	            return;
	        }

	        //如果读酷
	        if (window.DUKUCONFIG) {
	            //外部回调通知
	            if (window.DUKUCONFIG.iframeDrop) {
	                var appId = (0, _index5.$$get)('appId');
	                window.DUKUCONFIG.iframeDrop(['appId-' + appId, 'novelId-' + appId, 'pageIndex-' + appId]);
	            }
	            window.DUKUCONFIG = null;
	            destroy();
	            return;
	        }

	        //客户端模式
	        if (window.CLIENTCONFIGT) {
	            //外部回调通知
	            if (window.CLIENTCONFIGT.iframeDrop) {
	                window.CLIENTCONFIGT.iframeDrop();
	            }
	            window.CLIENTCONFIGT = null;
	            destroy();
	            return;
	        }

	        //妙妙学客户端
	        if (window.MMXCONFIG) {
	            //外部回调通知
	            if (window.MMXCONFIG.iframeDrop) {
	                window.MMXCONFIG.iframeDrop();
	            }
	            window.MMXCONFIG = null;
	            destroy();
	            return;
	        }
	    },


	    /**
	     * 停止应用
	     * skipMedia 跳过音频你处理(跨页面)
	     * dispose   成功处理回调
	     * processed 处理完毕回调
	     */
	    Suspend: function Suspend(_ref) {
	        var skipAudio = _ref.skipAudio,
	            dispose = _ref.dispose,
	            processed = _ref.processed;

	        (0, _index4.$$stop)(skipAudio);
	        processed && processed();
	    }
	});

	(0, _index5.$$extend)(Application, {

	    /**
	     * 启动应用
	     */
	    Launch: function Launch() {},


	    /**
	     * 设置应用状态
	     */
	    setAppState: function setAppState() {
	        appState = true;
	    },


	    /**
	     * 删除应用状态
	     * @return {[type]} [description]
	     */
	    delAppState: function delAppState() {
	        appState = false;
	    },


	    /**
	     * 获取应用加载状态
	     * @return {[type]} [description]
	     */
	    getAppState: function getAppState() {
	        return appState;
	    },


	    /**
	     * 延时APP运用
	     * 一般是在等待视频先加载完毕
	     * @return {[type]} [description]
	     */
	    delayAppRun: function delayAppRun() {
	        Application.setAppState();
	    },


	    /**
	     * 启动app
	     * 重载启动方法
	     * 如果调用在重载之前，就删除，
	     * 否则被启动方法重载
	     * @type {[type]}
	     */
	    LaunchApp: function LaunchApp() {
	        Application.delAppState();
	    },


	    /**
	     * 应用加载完毕
	     */
	    AddEventListener: function AddEventListener() {}
	});

	/**
	 * u3d接口
	 */
	Xut.U3d = {
	    /**
	     * 跳转接口
	     * @param {[type]} seasonId  [description]
	     * @param {[type]} chapterId [description]
	     */
	    View: function View(seasonId, chapterId) {
	        _View.LoadScenario({
	            'scenarioId': seasonId,
	            'chapterId': chapterId
	        });
	    }
	};

	/**
	 * 脚本注入接口
	 * @type {Object}
	 */
	window.XXTAPI = {

	    /**
	     *读取系统中保存的变量的值。
	     *如果变量不存在，则新建这个全局变量
	     *如果系统中没有保存的值，用默认值进行赋值
	     *这个函数，将是创建全局变量的默认函数。
	     */
	    ReadVar: function ReadVar(variable, defaultValue) {
	        var temp;
	        if (temp = (0, _index5.$$get)(variable)) {
	            return temp;
	        } else {
	            (0, _index5.$$set)(variable, defaultValue);
	            return defaultValue;
	        }
	    },


	    /**
	     * 将变量的值保存起来
	     */
	    SaveVar: function SaveVar(variable, value) {
	        (0, _index5.$$set)(variable, value);
	    },


	    /*
	     *对变量赋值，然后保存变量的值
	     *对于全局变量，这个函数将是主要使用的，替代简单的“=”赋值
	     */
	    SetVar: function SetVar(variable, value) {
	        (0, _index5.$$set)(variable, value);
	    }
	};

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Destroy;

	var _controller = __webpack_require__(9);

	var _manager = __webpack_require__(6);

	var _manager2 = __webpack_require__(4);

	var _adapter = __webpack_require__(12);

	var _fix = __webpack_require__(15);

	var _destroy = __webpack_require__(94);

	var _index = __webpack_require__(1);

	var _stroage = __webpack_require__(17);

	var _android = __webpack_require__(31);

	/**
	 * 销毁接口
	 * action 可能是
	 * 1 destory 默认，单页面切换，只做销毁。但是代码还是同一份
	 * 2 refresh 刷新，旋转切换（需要做一些数据保留，比如外联json数据）
	 * 3 exit 退出应用，所以这个应该是全销毁
	 * @param {[type]} action [description]
	 */
	function Destroy() {
	    var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'destory';


	    //销毁所有场景
	    _controller.sceneController.destroyAllScene();

	    //销毁只创建一次的对象
	    //修复的音频对象
	    //数据的结果集
	    if (action === 'exit') {
	        if (Xut.plat.isBrowser) {
	            $(document).off(); //左右按钮
	            $(window).off(); //横竖切换
	        }

	        //修复的音频对象
	        (0, _fix.destroyFixAudio)();
	    }

	    //refresh状态不删除结果集
	    if (action === 'destory' || action === 'exit') {
	        (0, _destroy.destroyResult)();
	    }

	    //config路径缓存
	    (0, _index.destroyConfig)();

	    //删除数据匹配缓存
	    (0, _destroy.destroyCache)();

	    //音视频
	    (0, _manager.clearAudio)();

	    //音频
	    (0, _manager2.clearVideo)();

	    //expand销毁
	    //flow的一些接口缓存
	    (0, _adapter.adapterDestory)();

	    //销毁独立APK的键盘事件
	    (0, _android.offAndroid)();

	    /**
	     * 重设缓存的UUID
	     * 为了只计算一次
	     * @return {[type]} [description]
	     */
	    (0, _stroage.$$resetUUID)();

	    Xut.TransformFilter = null;
	    Xut.CreateFilter = null;

	    //销毁节点
	    Xut.Application.$$removeNode();
	}

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * 默认值，未定义
	 * @type {[type]}
	 */
	var DEFAULT = undefined;

	/**
	 * 模式配置
	 */
	exports.default = {

	  /**
	   * 是否支持错误日志打印
	   * @type {Boolean}
	   */
	  silent: process.env.NODE_ENV !== 'production',

	  /**
	   * 忙碌光标
	   * cursor: {
	   *   url: 'images/icons/showNote.png',
	   *   time: 500
	   * },
	   * @type {[type]}
	   */
	  cursor: {
	    delayTime: DEFAULT, //延时间显示时间
	    url: DEFAULT //url
	  },

	  /**
	   * 页面可视模式
	   * 2016.9.19
	   * 4种分辨率显示模式:
	   * 默认全屏缩放
	   *
	   * 0：永远100%屏幕尺寸自适应
	   *
	   * 1：画轴模式：
	   *    在不同分辨率下，按照正比缩放拼接
	   *    在一个可视区中，可以看到3个li拼接后的效果
	   *    按照宽度正比缩放,高度正比缩放，居中(适应画轴拼接模式)
	   *
	   * 2：宽度100% 正比自适应高度
	   *     横版PPT：
	   *        1：横板显示(充满全屏。第1种模式)
	   *        2：竖版显示(宽度100%。上下自适应，显示居中小块)
	   *     竖版PPT:
	   *        1: 竖版显示(宽度100%。上下空白，显示居中，整体缩短, 整理变化不大)
	   *        2: 在横版显示(高度100%，缩放宽度，左右留边)
	   *
	   * 3：高度100% 正比自适应宽度
	   *     横版：
	   *        1：横板显示(充满全屏。第1种模式)
	   *        2：竖版显示(宽度100%。上下自适应，显示居中小块)
	   *     竖版:
	   *        1: 竖版ppt竖版显示(高度100%。宽度溢出，只显示中间部分，整体拉长)
	   *        2: 竖版ppt在横版显示(高度100%，显示居中，左右空白，整体缩短)
	   * @type {Number}
	   */
	  visualMode: 0,

	  /**
	   * 全局翻页模式
	   * 给妙妙单独开的一个模式
	   * 一个novel对应多个season表 所以这里其实不能算全局设置，可以存在多个novel
	   * novel表定义，数据库定义的翻页模式
	   * 用来兼容客户端的制作模式
	   * 妙妙学模式处理，多页面下翻页切换
	   *
	   * 0 通过滑动翻页
	   * 1 禁止滑动,直接快速切换页面(通过左右按键快速切换页面)
	   * @type {Number}
	   */
	  flipMode: 0, //默认0，待数据库填充

	  /**
	   * 应用的加载模式
	   * 0： 应用自行启动
	   * 1： 应用通过接口启动
	   *     Xut.Application.Launch
	   *     提供全局可配置参数
	   * @type {Number}
	   */
	  lauchMode: 0,

	  /**
	   * 应用横竖自适应切换
	   * 默认在浏览器端打开
	   * 这里可以定义打开关闭
	   * 打开：1
	   * 默认：0
	   * [orientate description]
	   * @type {[type]}
	   */
	  orientateMode: Xut.plat.isBrowser ? true : false,

	  /**
	   * 是否启动页面缩放，mini排版处理
	   * 默认自动，根据是否存在flow数据处理
	   * 如果强行介入，这里设置
	   * 1 true 启动
	   * 2 false 禁止
	   */
	  saleMode: DEFAULT, //默认不配置，系统指定，如果有flow自动打开，否则按照配置文件处理
	  saleMultiples: 4, //默认缩放的倍数4倍

	  /**
	   * 是否需要保存记录加载
	   * 1 true 启动缓存
	   * 2 false 关闭缓存
	   * @type {[type]}
	   */
	  historyMode: DEFAULT, //默认不配置，这里需要数据库填充， 如果指定了false，跳过数据库填充

	  /**
	   * 滑动事件委托
	   * 这个东东是针对mini开发的
	   * 左右翻页手势提升到全局响应
	   * 相应的对象形成形成事件队列
	   * [content1,content2,...,翻页]
	   * 1 true 启动
	   * 2 false 禁止
	   */
	  swipeDelegate: DEFAULT, //默认关闭，min杂志自动启用

	  /**
	   *  仅做测试处理，因为每个section都可以对应配置pageMode参数
	   *  翻页模式（数据库section指定）
	   *
	   *  每个场景对应自己的模式
	   *  所以如果这里配置了，那么所有的场景全部统一配置了
	   *  这里其实是不合理的，所以仅作为测试
	   *
	   *  pageMode：(如果用户没有选择任何处理，pageMode字段就为空)
	   *   0 禁止滑动
	   *   1 允许滑动无翻页按钮
	   *   2 允许滑动带翻页按钮
	   *
	   *  主场景工具栏配置：默认2
	   *  副场景工具栏配置：默认 0
	   */
	  pageMode: DEFAULT, //默认不设置，待数据库填充。如设置,数据库设置忽略

	  /**
	   * 仅做测试处理，因为每个section都可以对应配置tpType参数
	   * 配置工具栏行为
	   *
	   *  工具栏类型
	   *  toolType：(如果用户没有选择任何工具栏信息处理，tbType字段就为空)
	   *   0  禁止工具栏
	   *   1  系统工具栏   - 显示IOS系统工具栏
	   *   2  场景工具栏   - 显示关闭按钮
	   *   3  场景工具栏   - 显示返回按钮
	   *   4  场景工具栏   - 显示顶部小圆点式标示
	   *   填充数组格式，可以多项选择[1,2,3,4]
	   */
	  toolType: { //默认不设置，待数据库填充。如设置,数据库设置忽略
	    mian: DEFAULT, //主场景，系统工具栏
	    deputy: DEFAULT, //副场景，函数工具栏
	    number: DEFAULT //独立配置，默认会启动页面，针对分栏处理
	  },

	  /**
	   * 双页面模式，竖版ppt在横版显示
	   * 一个view中，显示2个page
	   * 一个页面宽度50%，拼接2个页面100%
	   * 高度正比，这样高度不溢出，中间布局留空白
	   * 默认禁止：
	   * 1 true 启动
	   * 2 false 禁止
	   */
	  doublePageMode: false,

	  /**
	   * 独立canvas模式处理
	   * 为了测试方便
	   * 可以直接切换到dom模式
	   *
	   * 默认禁止：
	   * 1 true 启动
	   * 2 false 禁止
	   * @type {Boolean}
	   */
	  onlyDomMode: false,

	  /**
	   * 直接通过数据库的历史记录定位到指定的页面
	   * Xut.View.LoadScenario({
	   *     'scenarioId' : scenarioInfo[0],
	   *     'chapterId'  : scenarioInfo[1],
	   *     'pageIndex'  : scenarioInfo[2]
	   *  })
	   *  {
	   *     'scenarioId' : 7,
	   *     'chapterId'  : 9
	   *  }
	   * @type {Boolean}
	   */
	  deBugHistory: DEFAULT
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _index = __webpack_require__(1);

	var _global = __webpack_require__(103);

	var _manager = __webpack_require__(6);

	var _manager2 = __webpack_require__(4);

	var _fix = __webpack_require__(15);

	var _busy = __webpack_require__(23);

	var _nexttick = __webpack_require__(44);

	var _nexttick2 = _interopRequireDefault(_nexttick);

	var _index2 = __webpack_require__(108);

	var _index3 = _interopRequireDefault(_index2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	Xut.Version = 870.2;

	if (Xut.plat.isBrowser) {
	    //Mobile browser automatically broadcast platform media processing
	    if (Xut.plat.noAutoPlayMedia) {
	        (0, _fix.fixAudio)();
	    }
	    //Desktop binding mouse control
	    $(document).keyup(function (event) {
	        switch (event.keyCode) {
	            case 37:
	                Xut.View.GotoPrevSlide();
	                break;
	            case 39:
	                Xut.View.GotoNextSlide();
	                break;
	        }
	    });
	}

	/**
	 * 基本结构
	 */
	var getContentHTML = function getContentHTML(cursor) {
	    //忙碌可配置
	    var busyIcon = '<div class="xut-busy-icon xut-fullscreen"></div>';
	    if (!cursor) {
	        (0, _busy.disable)(true);
	        busyIcon = '';
	    }

	    if (_index.config.cursor && _index.config.cursor.time) {
	        (0, _busy.setDelay)(_index.config.cursor.time);
	    }

	    //默认背景图
	    var coverImage = '<div class="xut-cover xut-fullscreen xut-cover-image"></div>';

	    //重写背景图
	    if (window.DYNAMICCONFIGT && window.DYNAMICCONFIGT.resource) {
	        var coverUrl = window.DYNAMICCONFIGT.resource + '/gallery/cover.jpg';
	        coverImage = '<div class="xut-cover xut-fullscreen" style="background-image: url(' + coverUrl + ');"></div>';
	    }

	    return busyIcon + '\n            ' + coverImage + '\n            <div class="xut-scene-container xut-fullscreen xut-overflow-hidden"></div>';
	};

	/**
	 * 根节点
	 */
	var getNode = function getNode() {
	    var nodeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#xxtppt-app-container';
	    var cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    var $rootNode = void 0;
	    if (nodeName) {
	        $rootNode = $(nodeName);
	    }
	    if (!$rootNode.length) {
	        //如果没有传递节点名，直接放到body下面
	        nodeName = '';
	        $rootNode = $('body');
	    }

	    var contentHtml = getContentHTML(cursor);

	    //如果根节点不存在,配置根节点
	    if (!nodeName) {
	        contentHtml = '<div id="xxtppt-app-container" class="xut-fullscreen xut-overflow-hidden">\n                            ' + contentHtml + '\n                       </div>';
	    }

	    return {
	        $rootNode: $rootNode,
	        $contentNode: $(String.styleFormat(contentHtml))
	    };
	};

	/**
	 * 接口接在参数
	 * 用户横竖切换刷新
	 * @type {Array}
	 */
	var lauchOptions = void 0;

	/**
	 * 加载应用app
	 * @return {[type]} [description]
	 */
	var loadApp = function loadApp() {
	    var node = getNode.apply(undefined, arguments);
	    Xut.Application.$$removeNode = function () {
	        node.$contentNode.remove();
	        node.$contentNode = null;
	        node.$rootNode = null;
	        node = null;
	        Xut.Application.$$removeNode = null;
	    };
	    (0, _nexttick2.default)({
	        container: node.$rootNode,
	        content: node.$contentNode
	    }, _index3.default);
	};

	// $('body').on('dblclick', () => {
	//     // alert(11)
	//     Xut.Application.Refresh()
	//     loadApp()
	// })

	/**
	 * 横竖切换
	 */
	Xut.plat.isBrowser && $(window).on('orientationchange', function () {

	    //安卓设备上,对横竖切换的处理反映很慢
	    //所以这里需要延时加载获取设备新的分辨率
	    //2016.11.8
	    var delay = function delay(fn) {
	        setTimeout(fn, 500);
	    };

	    //如果启动了这个模式
	    if (_index.config.orientateMode) {
	        (function () {
	            var temp = lauchOptions;
	            Xut.Application.Refresh();
	            if (temp && temp.length) {
	                delay(function () {
	                    Xut.Application.Launch(temp.pop());
	                    temp = null;
	                });
	            } else {
	                delay(function () {
	                    loadApp();
	                });
	            }
	        })();
	    }
	});

	/**
	 * 提供全局配置文件
	 */
	var setMode = function setMode(setConfig) {
	    if (setConfig) {
	        Xut.extend(_index.config, setConfig);
	    }
	};

	/**
	 * 新版本加载
	 */
	Xut.Application.Launch = function (_ref) {
	    var el = _ref.el,
	        paths = _ref.paths,
	        cursor = _ref.cursor;

	    var setConfig = Xut.Application.setConfig;
	    if (setConfig && setConfig.lauchMode === 1) {
	        setMode(setConfig);
	        lauchOptions = [{
	            el: el,
	            paths: paths,
	            cursor: cursor
	        }];
	        window.DYNAMICCONFIGT = { //外部配置文件
	            resource: paths.resource,
	            database: paths.database
	        };
	        loadApp(el, cursor);
	    }
	};

	/**
	 * 老版本加载
	 */
	setTimeout(function () {
	    var setConfig = Xut.Application.setConfig;
	    if (!setConfig || setConfig && !setConfig.lauchMode) {
	        setMode(setConfig);
	        loadApp();
	    }
	}, 100);

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = dynamic;

	var _busy = __webpack_require__(23);

	var _filter = __webpack_require__(61);

	var _result = __webpack_require__(21);

	var _index = __webpack_require__(2);

	var _index2 = __webpack_require__(1);

	var _toolbar = __webpack_require__(110);

	var _toolbar2 = _interopRequireDefault(_toolbar);

	var _layout = __webpack_require__(80);

	var _layout2 = _interopRequireDefault(_layout);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 加载css
	 * @return {[type]} [description]
	 */
	var loadStyle = function loadStyle(callback) {

	    var svgsheet = window.DYNAMICCONFIGT ? window.DYNAMICCONFIGT.resource + '/gallery/svgsheet.css' : _index2.config.pathAddress + 'svgsheet.css';

	    //加载横版或者竖版css
	    //nodeBuildMode 是node build下的test.html文件
	    //加载build/*.css压缩文件
	    //否则就是默认的css/*.css
	    var baseCss = window.nodeBuildMode ? window.nodeBuildMode.csspath : './css/' + _index2.config.layoutMode + '.css';
	    var cssArr = [baseCss, svgsheet];

	    //是否需要加载svg
	    //如果是ibooks模式
	    //并且没有svg
	    //兼容安卓2.x
	    if (Xut.IBooks.Enabled && !Xut.IBooks.existSvg) {
	        cssArr = [baseCss];
	    }

	    _index.loader.load(cssArr, callback, null, true);
	};

	/**
	 * 新增模式,用于记录浏览器退出记录
	 * 默认启动
	 * 是否回到退出的页面
	 * set表中写一个recordHistory
	 * 是   1
	 * 否   0
	 * [description]
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	var setHistory = function setHistory(data) {
	    var historyMode = 1; //默认启动
	    if (data.recordHistory !== undefined) {
	        historyMode = Number(data.recordHistory);
	    }

	    //如果启动桌面调试模式
	    //自动打开缓存加载
	    if (!historyMode && _index2.config.isBrowser) {
	        historyMode = 1;
	    }

	    _index2.config.historyMode = historyMode;
	};

	var setMode = function setMode(data) {
	    //如果没有config配置，默认数据库
	    if (!_index2.config.visualMode && Number(data.scrollPaintingMode)) {
	        _index2.config.visualMode = 1;
	    }
	};

	/**
	 * 动态代码变动区域
	 */
	function dynamic(callback) {

	    //导入数据缓存
	    (0, _result.importDatabase)(function () {

	        //初始化工具栏
	        //与数据库setting数据
	        (0, _toolbar2.default)(function (novelData, tempSettingData) {

	            //创建过滤器
	            Xut.CreateFilter = (0, _filter.contentFilter)('createFilter');
	            Xut.TransformFilter = (0, _filter.contentFilter)('transformFilter');

	            //初始化配置一些信息
	            (0, _index2.initConfig)(novelData.pptWidth, novelData.pptHeight);

	            //新增模式,用于记录浏览器退出记录
	            //如果强制配置文件recordHistory = false则跳过数据库的给值
	            if (_index2.config.historyMode !== false) {
	                setHistory(tempSettingData);
	            }

	            //2015.2.26
	            //启动画轴模式
	            setMode(tempSettingData);

	            //创建忙碌光标
	            if (!Xut.IBooks.Enabled) {
	                (0, _busy.createCursor)();
	            }

	            //初始资源地址
	            (0, _index2.initPathAddress)();

	            /**
	             * 初始flows排版
	             * 嵌入index
	             * 默认有flow并且没有强制设置关闭的情况，打开缩放
	             */
	            if ((0, _layout2.default)()) {
	                //缩放
	                if (_index2.config.saleMode !== false) {
	                    _index2.config.saleMode = true;
	                }
	                //动画事件委托
	                if (_index2.config.swipeDelegate !== false) {
	                    _index2.config.swipeDelegate = true;
	                }
	            }

	            //iframe要要Xut.config
	            loadStyle(function () {
	                return callback(novelData);
	            });
	        });
	    });
	}

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = init;

	var _index = __webpack_require__(1);

	var _app = __webpack_require__(32);

	var _base = __webpack_require__(107);

	var _base2 = _interopRequireDefault(_base);

	var _android = __webpack_require__(31);

	var _load = __webpack_require__(109);

	var _load2 = _interopRequireDefault(_load);

	var _index2 = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var getCache = function getCache(name) {
	    return parseInt((0, _index2.$$get)(name));
	};

	/**
	 * 进入主页面
	 * @return {[type]} [description]
	 */
	var initMain = function initMain(novelData) {

	    var novelId = void 0;
	    var parameter = void 0;
	    var pageIndex = getCache('pageIndex');
	    var flipMode = getCache('flipMode') || 0;

	    /**
	     * IBOOS模式
	     */
	    if (Xut.IBooks.Enabled) {
	        //删除背景图
	        $(".xut-cover").remove();
	        (0, _load2.default)({
	            "pageIndex": Xut.IBooks.CONFIG.pageIndex
	        });
	        return;
	    }

	    /**
	     * 多模式判断
	     * 全局翻页模式
	     * 0 滑动翻页
	     * 1 直接换
	     * 所以pageFlip只有在左面的情况下
	     */
	    if (parameter = novelData.parameter) {
	        parameter = (0, _index2.parseJSON)(parameter);

	        //配置全局翻页模式
	        //flipMode可以为0
	        //兼容flipMode错误,强制转化成数字类型
	        if (parameter.pageflip !== undefined) {
	            flipMode = Number(parameter.pageflip);
	            (0, _index2.$$set)({ 'flipMode': flipMode });
	        }
	    }

	    /**
	     * 设置全局翻页模式
	     * @return {[type]} [description]
	     */
	    if (flipMode) {
	        _index.config.flipMode = Number(flipMode);
	    }

	    /**
	     * 缓存加载
	     * 如果启动recordHistory记录
	     */
	    if (_index.config.historyMode && pageIndex !== undefined) {
	        //加强判断
	        if (novelId = getCache("novelId")) {
	            return (0, _load2.default)({
	                "novelId": novelId,
	                "pageIndex": pageIndex,
	                'history': (0, _index2.$$get)('history')
	            });
	        }
	    }

	    //第一次加载
	    //没有缓存
	    (0, _load2.default)({
	        "novelId": novelData._id,
	        "pageIndex": 0
	    });
	};

	/**
	 * 加载app应用
	 * @param  {[type]} config [description]
	 * @return {[type]}        [description]
	 */
	var initApp = function initApp() {
	    return (0, _base2.default)(initMain);
	};

	/**
	 * 如果是安卓桌面端
	 * 绑定事件
	 * @return {[type]} [description]
	 */
	var operation = function operation() {
	    //安卓上
	    if (Xut.plat.isAndroid) {
	        //预加载处理视频
	        //妙妙学不加载视频
	        //读库不加载视频
	        if (!window.MMXCONFIG && !window.DUKUCONFIG) {
	            (0, _app.plugVideo)();
	        }

	        //不是子文档指定绑定按键
	        if (!window.SUbCONFIGT) {
	            Xut.Application.AddEventListener = function () {
	                (0, _android.bindAndroid)();
	            };
	        }
	    }

	    if (window.DUKUCONFIG) {
	        PMS.bind("MagazineExit", function () {
	            PMS.unbind();
	            Xut.Application.DropApp();
	        }, "*");
	    }
	    initApp();
	};

	function init() {

	    //如果不是读库模式
	    //播放HTML5视频
	    //在IOS
	    // if (!window.DUKUCONFIG && !window.GLOBALIFRAME && Xut.plat.isIOS) {
	    //     html5Video()
	    // }

	    //Ifarme嵌套处理
	    //1 新阅读
	    //2 子文档
	    //3 pc
	    //4 ios/android
	    if (window.GLOBALIFRAME) {
	        operation();
	    } else {

	        //brower or mobile(apk or ipa)
	        if (_index.config.isBrowser) {
	            initApp();
	        } else {
	            window.openDatabase(_index.config.dbName, "1.0", "Xxtebook Database", _index.config.dbSize);
	            document.addEventListener("deviceready", function () {
	                Xut.plat.hasPlugin = true; //支持插件
	                Xut.Plugin.XXTEbookInit.startup(_index.config.dbName, operation, function () {});
	            }, false);
	        }
	    }
	}

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (options) {

	    options = initDefaultValues(options || {});

	    //设置缓存
	    setDataToStorage(options);

	    //应用脚本注入
	    runScript();

	    //检测下scenarioId的正确性
	    //scenarioId = 1 找不到chapter数据
	    //通过sectionRelated递归检测下一条数据
	    var scenarioId, seasondata, i;
	    for (i = 0; i < Xut.data.Season.length; i++) {
	        seasondata = Xut.data.Season.item(i);
	        if (Xut.data.query('sectionRelated', seasondata._id)) {
	            scenarioId = seasondata._id;
	            break;
	        }
	    }

	    //加载新的场景
	    Xut.View.LoadScenario({
	        'main': true, //主场景入口
	        'scenarioId': scenarioId,
	        'pageIndex': options.pageIndex,
	        'history': options.history
	    });
	};

	var _index = __webpack_require__(1);

	var _index2 = __webpack_require__(2);

	/**
	 * 设置缓存
	 * @param {[type]} parameter [description]
	 */
	var setDataToStorage = function setDataToStorage(parameter) {
	    _index.config.pageIndex = parameter.pageIndex;
	    _index.config.novelId = parameter.novelId;
	    (0, _index2.$$set)({
	        "pageIndex": parameter.pageIndex,
	        "novelId": parameter.novelId
	    });
	};

	/**
	 * 初始化值
	 * @param {[type]} options [description]
	 */
	var initDefaultValues = function initDefaultValues(options) {
	    return {
	        'novelId': Number(options.novelId),
	        'pageIndex': Number(options.pageIndex),
	        'history': options.history
	    };
	};

	/**
	 * 检测脚本注入
	 * @return {[type]} [description]
	 */
	var runScript = function runScript() {
	    var preCode,
	        novels = Xut.data.query('Novel');
	    if (preCode = novels.preCode) {
	        (0, _index2.execScript)(preCode, 'novelpre脚本');
	    }
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (callback) {
	    supportTransaction(function () {
	        return setStore(callback);
	    });
	};

	var _index = __webpack_require__(96);

	var _index2 = __webpack_require__(1);

	var _index3 = __webpack_require__(2);

	/**
	 * 默认工具栏配置
	 * @type {Object}
	 */
	var defaults = {
	    ToolbarPos: 0, //工具栏[0顶部,1底部]
	    NavbarPos: 1, //左右翻页按钮[0顶部, 1中间, 2底部]
	    HomeBut: 1, //主页按钮[0不显示,1显示]
	    ContentBut: 1, //目录按钮[0不显示,1显示]
	    PageBut: 1, //页码按钮[0不显示,1显示]
	    NavLeft: 1, //左翻页按钮[0不显示,1显示]
	    NavRight: 1, //右翻页按钮[0不显示,1显示]
	    customButton: 0, //自定义翻页按钮
	    CloseBut: window.SUbDOCCONTEXT ? 1 : 0 //关闭按钮[0不显示,1显示]
	};

	/**
	 * 配置默认数据
	 * @return {[type]} [description]
	 */
	var initDefaults = function initDefaults(setData) {

	    var rs = void 0;
	    var data = {};
	    var setConfig = {};

	    _.each(setData, function (key, index) {
	        rs = setData.item(index);
	        data[rs.name] = rs.value;
	    });

	    _.defaults(data, defaults);

	    for (var i in defaults) {
	        setConfig[i] = Number(data[i]);
	    }

	    _index2.config.settings = setConfig;
	    _index2.config.appId = data.appId; //应用配置唯一标示符
	    _index2.config.shortName = data.shortName;
	    _index2.config.Inapp = data.Inapp; //是否为应用内购买
	    _index2.config.delayTime = data.delayTime;

	    //应用的唯一标识符
	    //生成时间+appid
	    _index2.config.appUUID = data.adUpdateTime ? data.appId + '-' + /\S*/.exec(data.adUpdateTime)[0] : data.adUpdateTime;

	    //缓存应用ID
	    (0, _index3.$$set)({
	        'appId': data.appId
	    });

	    //广告Id
	    //2014.9.2
	    Xut.Presentation.AdsId = data.adsId;

	    return data;
	};

	/**
	 * 根据set表初始化数据
	 * @return {[type]} [description]
	 */
	var setStore = function setStore(callback) {
	    (0, _index.createStore)(function (dataRet) {
	        var novelData = dataRet.Novel.item(0);
	        callback(novelData, initDefaults(dataRet.Setting));
	    });
	};

	/**
	 * 数据库支持
	 * @return {[type]} [description]
	 */
	var supportTransaction = function supportTransaction(callback) {
	    if (window.openDatabase) {
	        try {
	            //数据库链接对象
	            Xut.config.db = window.openDatabase(_index2.config.dbName, "1.0", "Xxtebook Database", _index2.config.dbSize);
	        } catch (err) {
	            console.log('window.openDatabase出错');
	        }
	    }
	    //如果读不出数据
	    if (Xut.config.db) {
	        Xut.config.db.transaction(function (tx) {
	            tx.executeSql('SELECT * FROM Novel', [], function (tx, rs) {
	                callback();
	            }, function () {
	                Xut.config.db = null;
	                callback();
	            });
	        });
	    } else {
	        callback();
	    }
	};

	/**
	 * 初始化
	 * 数据结构
	 */

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = closestProcessor;

	var _hooks = __webpack_require__(33);

	var _hooks2 = _interopRequireDefault(_hooks);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 简化委托处理，默认一层元素只能绑定一个委托事件
	 */
	function closestProcessor(event, pageType) {

	    var i,
	        k,
	        attribute,
	        attributes,
	        value,
	        cur = event.target;

	    if (cur.nodeType) {
	        //如果触发点直接是li
	        if (cur === this) {
	            return {
	                'rootNode': this,
	                'elem': cur,
	                'handlers': _hooks2.default['data-container']
	            };
	        }
	        //否则是内部的节点
	        try {
	            for (; cur !== this; cur = cur.parentNode || this) {
	                //如果是canvas节点
	                if (cur.nodeName && cur.nodeName.toLowerCase() === 'canvas') {
	                    //是否为滑动行为
	                    if (Xut.Contents.Canvas.getSupportState()) {
	                        return true;
	                    } else {
	                        return false;
	                    }
	                }
	                //如果是dom节点
	                attributes = cur['attributes'];
	                for (k in _hooks2.default) {
	                    if (attribute = attributes[k]) {
	                        value = attribute['value' || 'nodeValue'];
	                        return {
	                            'rootNode': this,
	                            'elem': cur,
	                            'attribute': value,
	                            'pageType': pageType,
	                            'handlers': _hooks2.default[k]
	                        };
	                    }
	                }
	            }
	        } catch (err) {
	            // config.isBrowser && console.log('默认事件跟踪', err)
	        }
	    }
	} //事件钩子

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.offsetPage = offsetPage;
	exports.getDirection = getDirection;
	exports.converVisiblePid = converVisiblePid;
	exports.initPointer = initPointer;
	exports.indexConverChapterId = indexConverChapterId;
	exports.indexConverChapterData = indexConverChapterData;
	exports.checkMasterCreate = checkMasterCreate;

	var _cache = __webpack_require__(20);

	var _query = __webpack_require__(29);

	/**
	 * 判断是否能整除2
	 * @param  {[type]} num [description]
	 * @return {[type]}     [description]
	 */
	function offsetPage(num) {
	    return num % 2 == 0 ? 'left' : 'right';
	}

	/**
	 * 页面之间关系
	 * @param  {[type]} createIndex [description]
	 * @param  {[type]} currIndex   [description]
	 * @return {[type]}             [description]
	 */
	function getDirection(createIndex, currIndex) {
	    var direction = void 0;
	    if (createIndex < currIndex) {
	        direction = 'before';
	    } else if (createIndex > currIndex) {
	        direction = 'after';
	    } else if (currIndex == createIndex) {
	        direction = 'middle';
	    }
	    return direction;
	}

	var mixRang = function mixRang(pageIndex, start) {
	    return pageIndex.map(function (oldPageIndex) {
	        return oldPageIndex - start;
	    });
	};

	/**
	 * 如果是场景加载，转化页码数
	 * 转化按0开始
	 * pageIndex 页码
	 * visiblePid 可见页面chpaterId
	 */
	function converVisiblePid(pageIndex, visiblePid) {
	    //转化可视区域值viewPageIndex
	    if (this.options.multiScenario) {
	        var sectionRang = this.options.sectionRang;
	        //如果传入的是数组数据
	        if (!visiblePid && _.isArray(pageIndex)) {
	            return mixRang(pageIndex, sectionRang.start);
	        }
	        pageIndex -= sectionRang.start;
	        visiblePid += sectionRang.start;
	    } else {
	        //pageIndex是数组，并且realPage为空
	        if (_.isArray(pageIndex)) {
	            return pageIndex;
	        }
	    }

	    return {
	        pageIndex: pageIndex,
	        visiblePid: visiblePid
	    };
	}

	/**
	 * 计算初始化页码
	 */
	function initPointer(targetIndex, pageTotal, multiplePages) {

	    var leftscope = 0,
	        initPointer = {},
	        createPointer = [];

	    function setValue(index) {
	        if (index.leftIndex !== undefined) {
	            initPointer.leftIndex = index.leftIndex;
	            createPointer.push(index.leftIndex);
	        }
	        if (index.currIndex !== undefined) {
	            initPointer.currIndex = index.currIndex;
	            createPointer.push(index.currIndex);
	        }
	        if (index.rightIndex !== undefined) {
	            initPointer.rightIndex = index.rightIndex;
	            createPointer.push(index.rightIndex);
	        }
	    }

	    //如果只有一页 or  非线性,只创建一个页面
	    if (pageTotal === 1 || !multiplePages) {
	        setValue({
	            'currIndex': targetIndex
	        });
	    } else {
	        //多页情况
	        if (targetIndex === leftscope) {
	            //首页
	            setValue({
	                'currIndex': targetIndex,
	                'rightIndex': targetIndex + 1
	            });
	        } else if (targetIndex === pageTotal - 1) {
	            //尾页
	            setValue({
	                'currIndex': targetIndex,
	                'leftIndex': targetIndex - 1
	            });
	        } else {
	            //中间页
	            setValue({
	                'currIndex': targetIndex,
	                'leftIndex': targetIndex - 1,
	                'rightIndex': targetIndex + 1
	            });
	        }
	    }

	    return {
	        createPointer: createPointer,
	        initPointer: initPointer
	    };
	}

	/**
	 * 索引转化成chapter ID
	 * 确保解析的正确排序
	 * 保证可视页面第一个分解
	 * createPage 需要创建的页面 [0,1,2]
	 * visualPage 可视区页面       [1]
	 * @param  {[type]} createPage [description]
	 * @param  {[type]} visualPage [description]
	 * @return {[type]}            [description]
	 */
	function indexConverChapterId(createPage, visualPage) {
	    var _this = this;

	    //如果第一个不是可视区域
	    //切换位置
	    //加快创建速度
	    if (createPage[0] !== visualPage) {
	        var indexOf = createPage.indexOf(visualPage);
	        var less = createPage.splice(indexOf, 1);
	        createPage = less.concat(createPage);
	    }

	    //场景加载模式,计算正确的chapter顺序
	    //多场景的模式chpater分段后
	    //叠加起始段落
	    if (this.options.multiScenario) {
	        (function () {
	            //需要提前解析数据库的排列方式
	            //chpater的开始位置
	            var start = _this.options.sectionRang.start;
	            //拼接位置
	            createPage.forEach(function (page, index) {
	                createPage.splice(index, 1, page + start);
	            });
	        })();
	    }

	    // [0,1,2] => [73,74,75]
	    return createPage;
	}

	/**
	 * 页码转化成相对应的chpater表数据
	 * @param  {[type]} createPage [description]
	 * @return {[type]}            [description]
	 */
	function indexConverChapterData(createPage) {
	    return (0, _query.query)('chapter', createPage);
	}

	/**
	 * 检测是否构建母板模块处理
	 * @return {[type]} [description]
	 */
	function checkMasterCreate() {
	    var table = (0, _cache.errorTable)();
	    //如果没有Master数据,直接过滤
	    if (-1 !== table.indexOf('Master') || !Xut.data['Master'] || !Xut.data['Master'].length) {
	        return false;
	    }
	    return true;
	}

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = goToPage;

	var _translation = __webpack_require__(24);

	/**
	 * 跳转之前提高层级问题
	 * @return {[type]}          [description]
	 */
	var improveIndex = function improveIndex(complier) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        currIndex = _ref.currIndex;

	    //提高page层级
	    complier.pageMgr.abstractAssistPocess(currIndex, function (pageObj) {
	        pageObj.$pageNode.css({
	            'z-index': 9997
	        });
	    });

	    //提高mater层级
	    complier.masterContext(function () {
	        this.abstractAssistPocess(currIndex, function (pageObj) {
	            pageObj.$pageNode.css({
	                'z-index': 1
	            });
	        });
	    });
	};

	/**
	 * 处理跳转逻辑
	 * @param  {[type]} complier       [description]
	 * @param  {[type]} data           [description]
	 * @param  {[type]} createCallback [description]
	 * @return {[type]}                [description]
	 */
	var calculateFlip = function calculateFlip(complier, data, createCallback) {
	    //缓存当前页面索引用于销毁
	    var pageIndex,
	        i = 0,
	        collectContainers = [],
	        create = data.create,
	        targetIndex = data.targetIndex;

	    //需要创建的页面闭包器
	    for (; i < create.length; i++) {
	        pageIndex = create[i];
	        collectContainers.push(function (targetIndex, pageIndex) {
	            return function (callback) {
	                //创建新结构
	                complier.createPageBases([pageIndex], targetIndex, 'toPage', callback, {
	                    'opacity': 0 //同页面切换,规定切换的样式
	                });
	            };
	        }(targetIndex, pageIndex));
	    }

	    /**
	     * 二维数组保存，创建返回的对象
	     * 1 page对象
	     * 2 母版对象
	     * @type {Array}
	     */
	    data.pageBaseCollect = [];

	    var i = 0,
	        collectLength,
	        count,
	        count = collectLength = collectContainers.length;

	    if (collectContainers && collectLength) {
	        for (; i < collectLength; i++) {
	            //收集创建的根节点,异步等待容器的创建
	            collectContainers[i].call(complier, function (callbackPageBase) {
	                if (count === 1) {
	                    collectContainers = null;
	                    setTimeout(function () {
	                        createCallback(data);
	                    }, 100);
	                }
	                //接受创建后返回的页面对象
	                data.pageBaseCollect.push(callbackPageBase);
	                count--;
	            });
	        }
	    }
	};

	/**
	 * 节点创建完毕后，切换页面动，执行动作
	 * @param  {[type]} complier [description]
	 * @param  {[type]} data     [description]
	 * @return {[type]}          [description]
	 */
	var createContainerView = function createContainerView(complier, data) {

	    var prveHindex = data.currIndex;
	    var pageMgr = complier.pageMgr;

	    //停止当前页面动作
	    complier.suspendPageBases({
	        'stopPointer': prveHindex
	    });

	    //========处理跳转中逻辑=========

	    /**
	     * 清除掉不需要的页面
	     * 排除掉当前提高层次页面
	     */
	    _.each(data['destroy'], function (destroyIndex) {
	        if (destroyIndex !== data.currIndex) {
	            pageMgr.clearPage(destroyIndex);
	        }
	    });

	    //修正翻页2页的页面坐标值
	    _.each(data['ruleOut'], function (pageIndex) {
	        if (pageIndex > data['targetIndex']) {
	            pageMgr.abstractAssistAppoint(pageIndex, function (pageObj) {
	                (0, _translation.fix)(pageObj.$pageNode, 'nextEffect');
	            });
	        }
	        if (pageIndex < data['targetIndex']) {
	            pageMgr.abstractAssistAppoint(pageIndex, function (pageObj) {
	                (0, _translation.fix)(pageObj.$pageNode, 'prevEffect');
	            });
	        }
	    });

	    var jumpPocesss = void 0;

	    //母版
	    complier.masterContext(function () {
	        jumpPocesss = this.makeJumpPocesss(data);
	        jumpPocesss.pre();
	    });

	    //===========跳槽后逻辑========================
	    pageMgr.clearPage(prveHindex);

	    jumpPocesss && jumpPocesss.clean(data.currIndex, data.targetIndex);

	    /**
	     * 同页面切换,规定切换的样式复位
	     * @param  {[type]} pageBase [description]
	     * @return {[type]}          [description]
	     */
	    _.each(data.pageBaseCollect, function (pageBase) {
	        _.each(pageBase, function (pageObj) {
	            pageObj.$pageNode && pageObj.$pageNode.css({
	                'opacity': 1
	            });
	        });
	    });

	    data.pageBaseCollect = null;
	    jumpPocesss = null;
	};

	/**
	 * 跳转页面逻辑处理
	 * @param  {[type]} complier [description]
	 * @param  {[type]} data     [description]
	 * @param  {[type]} success  [description]
	 * @return {[type]}          [description]
	 */
	function goToPage(complier, data, success) {
	    //跳前逻辑
	    improveIndex(complier, data);
	    //处理逻辑
	    calculateFlip(complier, data, function (data) {
	        createContainerView(complier, data);
	        success.call(complier, data);
	    });
	}

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*********************************************************************
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                 调度器 生成页面模块
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *            处理：事件动作分派
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *            调度：
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                1. PageMgr     模块
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                2. MasterMgr 模块
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                                                                    *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      **********************************************************************/

	var _index = __webpack_require__(1);

	var _page = __webpack_require__(117);

	var _page2 = _interopRequireDefault(_page);

	var _master = __webpack_require__(116);

	var _master2 = _interopRequireDefault(_master);

	var _goto = __webpack_require__(113);

	var _goto2 = _interopRequireDefault(_goto);

	var _controller = __webpack_require__(9);

	var _adapter = __webpack_require__(12);

	var _distance = __webpack_require__(46);

	var _distance2 = _interopRequireDefault(_distance);

	var _container = __webpack_require__(172);

	var _container2 = _interopRequireDefault(_container);

	var _index2 = __webpack_require__(2);

	var _stack = __webpack_require__(45);

	var _stack2 = _interopRequireDefault(_stack);

	var _conver = __webpack_require__(112);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Dispatcher = function () {
	    function Dispatcher(vm) {
	        _classCallCheck(this, Dispatcher);

	        this.vm = vm;

	        this.options = vm.options;

	        /**
	         * 创建前景页面管理模块
	         * @type {PageMgr}
	         */
	        this.pageMgr = new _page2.default(vm);

	        /**
	         * 检测是否需要创母版模块
	         * @return {[type]} [description]
	         */
	        if ((0, _conver.checkMasterCreate)()) {
	            this.masterMgr = new _master2.default(vm);
	        }
	    }

	    /**
	     * 初始化页面创建
	     * 因为多个页面的问题，所以不是创建调用
	     * 统一回调
	     * @return {[type]} [description]
	     */


	    _createClass(Dispatcher, [{
	        key: 'initCreate',
	        value: function initCreate() {

	            var options = this.options;

	            //pointer
	            //  createPointer
	            //  initPointer
	            var pointer = (0, _conver.initPointer)(options.initIndex, options.pagetotal, options.multiplePages);

	            this.pagePointer = pointer.initPointer;

	            //初始化
	            if (this.pageMgr.swipe) {
	                this.pageMgr.swipe.initTranslation(pointer.createPointer, options.initIndex);
	            }

	            //始化构建页面容器对象
	            this.createPageBases(pointer.createPointer, options.initIndex, 'init');
	        }

	        /**
	         *  创建普通页面
	         *  创建母版页面
	         *  createPointer     需要创建的页面索引
	         *  visiblePageIndex  当前可视区页面索引
	         *  action            创建的动作：toPage/init/flipOver
	         *  toPageCallback    跳转页面支持回调通知
	         *  userStyle         规定创建的style属性
	         **/

	    }, {
	        key: 'createPageBases',
	        value: function createPageBases(createPageIndex, visiblePageIndex, action, toPageCallback, userStyle) {

	            //2016.1.20
	            //修正苗苗学问题 确保createPage不是undefined
	            if (createPageIndex[0] === undefined) {
	                return;
	            }

	            var self = this;
	            var multiplePages = this.options.multiplePages; //是否线性
	            var createTotal = createPageIndex.length; //需要创建的总页面
	            var toPageAction = action === 'toPage'; //如果是跳转
	            var filpOverAction = action === 'flipOver'; //如果是翻页

	            //将页码pageIndex转化成对应的chapter && 使用第一个是分解可见页面
	            //不同场景会自动转化chapter的下标
	            //createChapterIndexs
	            //  创建的页码ID合集
	            //  代表数据库chpaterID的索引
	            var createChapterIndexs = _conver.indexConverChapterId.call(this, createPageIndex, visiblePageIndex);

	            //收集创建的页面对象
	            //用于处理2个页面在切换的时候闪屏问题
	            //主要是传递createStyle自定义样式的处理
	            var collectPageBase = [];

	            //是否触发母版的自动时间
	            //因为页面每次翻页都会驱动auto事件
	            //但是母版可能是共享的
	            var createMaster = false;

	            //收集完成回调
	            var collectCallback = function () {
	                //收集创建页码的数量
	                var createContent = 0;
	                return function (callback) {
	                    ++createContent;
	                    if (createContent === createTotal) {
	                        callback();
	                    }
	                };
	            }();

	            //构建执行代码
	            var callbackAction = {
	                //初始化
	                init: function init() {
	                    collectCallback(function () {
	                        self._loadPage('init');
	                    });
	                },

	                //翻页
	                flipOver: function flipOver() {
	                    collectCallback(function () {
	                        self._autoRun({ //翻页
	                            'createPointer': createChapterIndexs,
	                            'createMaster': createMaster
	                        });
	                    });
	                },

	                //跳转
	                toPage: function toPage() {
	                    collectCallback(function () {
	                        toPageCallback(collectPageBase);
	                    });
	                }
	            };

	            //chapter页码，转化成页面chapter数据集合
	            var chpaterResults = (0, _conver.indexConverChapterData)(createChapterIndexs);

	            /**
	             * 预编译
	             * 因为要需要对多个页面进行预处理
	             * 需要同步多个页面数据判断
	             * 这样需要预编译出数据，做了中间处理后再执行后续动作
	             * @type {Array}
	             */
	            var compile = new _stack2.default();

	            //收集有用的数据
	            var usefulData = (0, _index2.hash)();
	            var hasFlow = false;
	            _.each(chpaterResults, function (chapterData, index) {
	                compile.push(function () {

	                    //创建的页面索引
	                    var createChapterIndex = createChapterIndexs[index];

	                    //转化可视区页码对应的chapter的索引号
	                    //获取出实际的pageIndex号
	                    var conversion = _conver.converVisiblePid.call(self, createChapterIndex, visiblePageIndex);
	                    var visibleChapterIndex = conversion.visiblePid;
	                    var pageIndex = conversion.pageIndex;

	                    if (createTotal === 1) {
	                        self.options.chapterId = chapterData._id;
	                    }

	                    //确定存在flows类型页面
	                    var isFlows = chapterData.note === 'flow';
	                    if (isFlows) {
	                        hasFlow = true;
	                    }

	                    //跳转的时候，创建新页面可以自动样式信息
	                    //优化设置，只是改变当前页面即可
	                    if (toPageAction && visibleChapterIndex !== createChapterIndex) {
	                        userStyle = undefined;
	                    }

	                    //收集页面之间可配置数据
	                    usefulData[createChapterIndex] = {
	                        isFlows: isFlows,
	                        pid: createChapterIndex,
	                        visiblePid: visibleChapterIndex,
	                        userStyle: userStyle,
	                        direction: (0, _conver.getDirection)(createChapterIndex, visibleChapterIndex)
	                    };

	                    //延迟创建
	                    //先处理style规则
	                    return function (newstyle) {
	                        //构件新的页面
	                        //masterFilter 母板过滤器回调函数
	                        var _createPageBase = function _createPageBase(masterFilter) {
	                            //初始化构建页面对象
	                            //1:page
	                            //2:master
	                            var pageBase = this.create({
	                                'pid': createChapterIndex,
	                                'visiblePid': visibleChapterIndex,
	                                'chapterData': chapterData,
	                                'isFlows': isFlows,
	                                'getStyle': newstyle[createChapterIndex],
	                                'pageIndex': pageIndex,
	                                'multiplePages': multiplePages
	                            }, pageIndex, masterFilter);

	                            //构建页面对象后
	                            //开始执行
	                            if (pageBase) {
	                                //开始线程任务
	                                //当为滑动模式,支持快速创建
	                                pageBase.startThreadTask(filpOverAction, function () {
	                                    callbackAction[action]();
	                                });

	                                //收集自定义样式的页面对象
	                                if (userStyle) {
	                                    collectPageBase.push(pageBase);
	                                }
	                            }
	                        };

	                        //母版层
	                        if (chapterData.pptMaster && self.masterMgr) {
	                            _createPageBase.call(self.masterMgr, function () {
	                                //母版是否创建等待通知
	                                //母版是共享的所以不一定每次翻页都会创建
	                                //如果需要创建,则叠加总数
	                                ++createTotal;
	                                createMaster = true;
	                            });
	                        }

	                        //页面层
	                        _createPageBase.call(self.pageMgr);
	                    };
	                }());
	            });

	            /**
	             * 创建页面的样式与翻页的布局
	             * 存在存在flows页面处理
	             * 这里创建处理的Transfrom
	             * @param  {[type]} hasFlows [description]
	             * @return {[type]}            [description]
	             */
	            var newstyle = (0, _container2.default)({
	                action: action,
	                hasFlow: hasFlow,
	                usefulData: usefulData
	            });

	            /**
	             * 执行编译
	             */
	            compile.shiftAll(newstyle).destroy();
	        }

	        /**
	         * 滑动处理
	         *  1 滑动
	         *  2 反弹
	         *  3 翻页
	         */

	    }, {
	        key: 'movePageBases',
	        value: function movePageBases(_ref) {
	            var _this = this;

	            var action = _ref.action,
	                speed = _ref.speed,
	                distance = _ref.distance,
	                leftIndex = _ref.leftIndex,
	                pageIndex = _ref.pageIndex,
	                rightIndex = _ref.rightIndex,
	                direction = _ref.direction,
	                setSwipeInvalid = _ref.setSwipeInvalid;


	            //用户强制直接切换模式
	            //禁止页面跟随滑动
	            if (this.options.flipMode && action == 'flipMove') {
	                return;
	            }

	            var currIndex = pageIndex;
	            var currObj = this.pageMgr.abstractGetPageObj(currIndex);

	            //2016.11.8
	            //mini杂志功能
	            //一次是拦截
	            //一次是触发动作
	            if (_index.config.swipeDelegate) {

	                //如果是swipe就全局处理
	                if (action === 'swipe') {
	                    //执行动画序列
	                    currObj.callSwipeSequence(direction);
	                    return;
	                }

	                //2016.11.8
	                //mini杂志功能
	                //如果有动画序列
	                //拦截翻页动作
	                //执行序列动作
	                //拦截
	                if (currObj.hasSwipeSequence(direction)) {
	                    //设置为无效翻页
	                    setSwipeInvalid && setSwipeInvalid();
	                    return;
	                }
	            }

	            //移动的距离
	            var moveDist = (0, _distance2.default)({
	                action: action,
	                distance: distance,
	                direction: direction,
	                leftIndex: leftIndex,
	                pageIndex: pageIndex,
	                rightIndex: rightIndex
	            }, (0, _adapter.getFlowDistance)());

	            //视觉差页面滑动
	            var chapterData = currObj.chapterData;
	            var nodes = chapterData && chapterData.nodes ? chapterData.nodes : undefined;

	            var data = {
	                nodes: nodes,
	                speed: speed,
	                action: action,
	                moveDist: moveDist,
	                leftIndex: leftIndex,
	                currIndex: currIndex,
	                rightIndex: rightIndex,
	                direction: direction
	            };

	            this.pageMgr.move(data);
	            this.masterContext(function () {
	                this.move(data);
	            });

	            //更新页码
	            if (action === 'flipOver') {
	                Xut.nextTick(function () {
	                    _this.vm.$emit('change:pageUpdate', {
	                        action: action,
	                        parentIndex: direction === 'next' ? rightIndex : leftIndex,
	                        direction: direction
	                    });
	                });
	            }
	        }

	        /**
	         * 翻页松手后
	         * 暂停页面的各种活动动作
	         * @param  {[type]} pointers [description]
	         * @return {[type]}          [description]
	         */

	    }, {
	        key: 'suspendPageBases',
	        value: function suspendPageBases(pointers) {
	            //关闭层事件
	            this.pageMgr.suspend(pointers);
	            this.masterContext(function () {
	                this.suspend(pointers);
	            });

	            //复位工具栏
	            this.vm.$emit('change:resetToolbar');
	        }

	        /**
	         * 翻页动画完毕后
	         * @return {[type]}              [description]
	         */

	    }, {
	        key: 'completePageBases',
	        value: function completePageBases(direction, pagePointer, unfliplock, isQuickTurn) {
	            //方向
	            this.direction = direction;
	            //是否快速翻页
	            this.isQuickTurn = isQuickTurn || false;
	            //解锁
	            this.unfliplock = unfliplock;
	            //清理上一个页面
	            this._clearPage(pagePointer.destroyPointer);
	            this._updatePointer(pagePointer);
	            //预创建下一页
	            this._advanceCreate(direction, pagePointer);
	        }

	        /**
	         * 页面跳转
	         * @param  {[type]} data [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: 'gotoPageBases',
	        value: function gotoPageBases(data) {

	            Xut.View.ShowBusy();

	            //如果是非线性,创建页面修改
	            if (!this.options.multiplePages) {
	                data.create = [data.targetIndex];
	                data.destroy = [data.currIndex];
	                data.ruleOut = [data.targetIndex];
	                data.pagePointer = {
	                    currIndex: data.targetIndex
	                };
	            }

	            //执行页面切换
	            (0, _goto2.default)(this, data, function (data) {
	                this._updatePointer(data.pagePointer);
	                this._autoRun({
	                    'action': 'toPage',
	                    'createPointer': data['create']
	                });
	                Xut.View.HideBusy();
	            });
	        }

	        /**
	         * 调用母版管理器
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'masterContext',
	        value: function masterContext(callback) {
	            if (this.masterMgr) {
	                callback.call(this.masterMgr);
	            }
	        }

	        /**
	         * 销毁接口
	         * 对应多场景操作
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroyPageBases',
	        value: function destroyPageBases() {
	            this.pageMgr.destroy();
	            this.masterContext(function () {
	                this.destroy();
	            });
	        }

	        /**
	         * 自动运行处理
	         *  流程四:执行自动触发动作
	         *   1.初始化创建页面完毕
	         *   2.翻页完毕
	         */

	    }, {
	        key: '_autoRun',
	        value: function _autoRun(para) {
	            var options = this.options;
	            var pagePointer = this.pagePointer;
	            var prevIndex = pagePointer.leftIndex;
	            var currIndex = pagePointer.currIndex;
	            var nextIndex = pagePointer.rightIndex;
	            var action = para ? para.action : '';
	            var createPointer = para ? para.createPointer : '';
	            var direction = this.direction;

	            //暂停的页面索引autorun
	            var suspendIndex = action === 'init' ? '' : direction === 'next' ? prevIndex : nextIndex;

	            /**
	             * 存在2中模式的情况下
	             * 转化页码标记
	             */
	            if (createPointer) {
	                createPointer = _conver.converVisiblePid.call(this, createPointer);
	            }

	            var data = {
	                'prevIndex': prevIndex,
	                'currIndex': currIndex,
	                'nextIndex': nextIndex,
	                'suspendIndex': suspendIndex,
	                'createPointer': createPointer,
	                'direction': direction,
	                'isQuickTurn': this.isQuickTurn,
	                //中断通知
	                'suspendCallback': options.suspendAutoCallback,
	                //构建完毕通知
	                'buildComplete': function buildComplete(scenarioId) {
	                    /**
	                     * 构建完成通知,用于处理历史缓存记录
	                     * 如果是调试模式 && 不是收费提示页面 && 多场景应用
	                     */
	                    if (_index.config.historyMode && !options.isInApp && options.multiScenario) {
	                        var history;
	                        if (history = _controller.sceneController.sequence(scenarioId, currIndex)) {
	                            (0, _index2.$$set)("history", history);
	                        }
	                    }
	                },

	                //流程结束通知
	                //包括动画都已经结束了
	                'processComplete': function processComplete() {}
	            };

	            //页面自动运行
	            this.pageMgr.autoRun(data);

	            //模板自动运行
	            this.masterContext(function () {
	                //如果动作是初始化，或者触发了母版自动运行
	                //如果是越界处理
	                //console.log(action,this.isBoundary,para.createMaster)
	                if (action || this.isBoundary) {
	                    this.autoRun(data);
	                }
	            });

	            /**
	             * 触发自动通知
	             * @type {[type]}
	             */
	            var vm = this.vm;

	            /**
	             * 初始化与跳转针对翻页案例的设置逻辑
	             * @return {[type]} [description]
	             */
	            var setToolbar = function setToolbar() {
	                //不显示首尾对应的按钮
	                if (currIndex == 0) {
	                    vm.$emit('change:hidePrev');
	                } else if (currIndex == options.pagetotal - 1) {
	                    vm.$emit('change:hideNext');
	                    vm.$emit('change:showPrev');
	                } else {
	                    vm.$emit('change:showNext');
	                    vm.$emit('change:showPrev');
	                }
	            };

	            switch (action) {
	                case 'init':
	                    //更新页码标示
	                    vm.$emit('change:pageUpdate', {
	                        action: action,
	                        parentIndex: currIndex,
	                        direction: direction
	                    });
	                    setToolbar.call(this);
	                    break;
	                case 'toPage':
	                    //更新页码标示
	                    vm.$emit('change:pageUpdate', {
	                        action: action,
	                        parentIndex: currIndex,
	                        direction: direction
	                    });
	                    setToolbar.call(this);
	                    break;
	            }

	            /**
	             * 线性结构
	             * 保存目录索引
	             */
	            if (!options.multiScenario) {
	                (0, _index2.$$set)("pageIndex", currIndex);
	            }

	            /**
	             * 解锁翻页
	             * 允许继续执行下一个翻页作用
	             */
	            if (this.unfliplock) {
	                this.unfliplock();
	                this.unfliplock = null;
	            }

	            //关闭快速翻页
	            this.isQuickTurn = false;
	        }

	        /**
	         * 清理页面结构
	         * @param  {[type]} clearPageIndex [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_clearPage',
	        value: function _clearPage(clearPageIndex) {
	            this.pageMgr.clearPage(clearPageIndex);
	        }

	        /**
	         * 更新页码索引标示
	         * @param  {[type]} pagePointer [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_updatePointer',
	        value: function _updatePointer(pagePointer) {
	            this.pagePointer = pagePointer;
	        }

	        /**
	         * 预创建新页面
	         * @param  {[type]} direction   [description]
	         * @param  {[type]} pagePointer [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_advanceCreate',
	        value: function _advanceCreate(direction, pagePointer) {
	            var _this2 = this;

	            var pagetotal = this.options.pagetotal;
	            var vm = this.vm;
	            var createPointer = pagePointer.createPointer;

	            //清理页码
	            var clearPointer = function clearPointer() {
	                delete pagePointer.createPointer;
	                delete pagePointer.destroyPointer;
	            };

	            //创建新的页面对象
	            var createNextPageBase = function createNextPageBase(currIndex) {
	                return _this2.createPageBases([createPointer], currIndex, 'flipOver');
	            };

	            //如果是左边翻页
	            if (direction === 'prev') {
	                //首尾无须创建页面
	                if (pagePointer.currIndex === 0) {
	                    this._autoRun();
	                    if (pagetotal == 2) {
	                        //如果总数只有2页，那么首页的按钮是关闭的，需要显示
	                        vm.$emit('change:showNext');
	                    }
	                    vm.$emit('change:hidePrev');
	                    return;
	                }
	                if (pagePointer.currIndex > -1) {
	                    //创建的页面
	                    createNextPageBase(pagePointer.currIndex);
	                    clearPointer();
	                    vm.$emit('change:showNext');
	                    return;
	                }
	            }

	            //如果是右边翻页
	            if (direction === 'next') {
	                //首尾无须创建页面
	                if (pagePointer.currIndex === pagetotal - 1) {
	                    this._autoRun();
	                    if (pagetotal == 2) {
	                        //如果总数只有2页，那么首页的按钮是关闭的，需要显示
	                        vm.$emit('change:showPrev');
	                    }
	                    //多页处理
	                    vm.$emit('change:hideNext');
	                    return;
	                }
	                if (createPointer < pagetotal) {
	                    //创建的页面
	                    createNextPageBase(pagePointer.currIndex);
	                    clearPointer();
	                    vm.$emit('change:showPrev');
	                    return;
	                }
	            }

	            clearPointer();

	            return;
	        }

	        /**
	         * 加载页面事件与动作
	         * @param  {[type]} action [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_loadPage',
	        value: function _loadPage(action) {
	            var _this3 = this;

	            var self = this;

	            //触发自动任务
	            var triggerAuto = function triggerAuto() {
	                //第一次进入，处理背景
	                var $cover = $(".xut-cover");
	                if ($cover.length) {
	                    $cover.transition({
	                        opacity: 0,
	                        duration: 1000,
	                        easing: 'in',
	                        complete: function complete() {
	                            $cover && $cover.hide().remove();
	                            self._autoRun({
	                                'action': action
	                            });
	                            $cover = null;
	                            self = null;
	                        }
	                    });
	                } else {
	                    self._autoRun({
	                        'action': action
	                    });
	                    $cover = null;
	                    self = null;
	                }
	            };

	            //创建完成回调
	            this.vm.$emit('change:createComplete', function () {
	                if (_this3.options.multiScenario) {
	                    triggerAuto();
	                }
	                //第一次加载
	                //进入应用
	                else {
	                        if (window.GLOBALIFRAME) {
	                            triggerAuto();
	                            return;
	                        }
	                        //获取应用的状态
	                        if (Xut.Application.getAppState()) {
	                            //保留启动方法
	                            var pre = Xut.Application.LaunchApp;
	                            Xut.Application.LaunchApp = function () {
	                                pre();
	                                triggerAuto();
	                            };
	                        } else {
	                            triggerAuto();
	                        }
	                    }
	            });
	        }
	    }]);

	    return Dispatcher;
	}();

	exports.default = Dispatcher;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(16);

	var _index2 = _interopRequireDefault(_index);

	var _index3 = __webpack_require__(114);

	var _index4 = _interopRequireDefault(_index3);

	var _hooks = __webpack_require__(33);

	var _hooks2 = _interopRequireDefault(_hooks);

	var _closest = __webpack_require__(111);

	var _closest2 = _interopRequireDefault(_closest);

	var _index5 = __webpack_require__(2);

	var _index6 = __webpack_require__(43);

	var _index7 = _interopRequireDefault(_index6);

	var _dynamic = __webpack_require__(102);

	var _dynamic2 = _interopRequireDefault(_dynamic);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*********************************************************************
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *              场景容器构造器
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *          1 构件页面级容器
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *          2 翻页全局事件
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **********************************************************************/

	/**
	 * 配置多页面参数
	 * @return {[type]} [description]
	 */
	var configMultiple = function configMultiple(options) {

	    //如果是epub,强制转换为单页面
	    if (Xut.IBooks.Enabled) {
	        options.multiplePages = false;
	    } else {
	        //判断多页面情况
	        //1 数据库定义
	        //2 系统优化
	        options.multiplePages = options.flipMode ? options.flipMode : options.pageMode ? true : false;
	    }
	};

	/**
	 * 判断处理那个页面层次
	 * 找到pageType类型
	 * 项目分4个层
	 * page mater page浮动 mater浮动
	 * 通过
	 * 因为冒泡的元素，可能是页面层，也可能是母板上的
	 * @return {Boolean} [description]
	 */
	var isBelong = function isBelong(target) {
	    var pageType = 'page';
	    if (target.dataset && target.dataset.belong) {
	        pageType = target.dataset.belong;
	    }
	    return pageType;
	};

	/**
	 * 阻止元素的默认行为
	 * 在火狐下面image带有href的行为
	 * 会自动触发另存为
	 * @return {[type]} [description]
	 *
	 * 2016.3.18
	 * 妙妙学 滚动插件默认行为被阻止
	 *
	 * 2016.7.26
	 * 读库强制PC模式了
	 */
	var preventDefault = function preventDefault(evtObj, target) {
	    //var tagName = target.nodeName.toLowerCase();
	    if (Xut.plat.isBrowser && !Xut.IBooks.Enabled && !window.MMXCONFIG && !window.DUKUCONFIG) {
	        evtObj.preventDefault && evtObj.preventDefault();
	    }
	};

	var Mediator = function (_Observer) {
	    _inherits(Mediator, _Observer);

	    function Mediator(parameter) {
	        _classCallCheck(this, Mediator);

	        var _this = _possibleConstructorReturn(this, (Mediator.__proto__ || Object.getPrototypeOf(Mediator)).call(this));

	        var vm = _this;

	        //配置文件
	        var options = vm.options = _.extend({
	            //是否多场景加载
	            //单页场景 false
	            //多场景   true
	            'multiScenario': false,
	            //是否为连续页面
	            //通过pageMode的参数定义
	            'multiplePages': false
	        }, parameter, {
	            flipMode: Xut.config.flipMode
	        });

	        //配置多页面参数
	        configMultiple(options);

	        var $globalEvent = vm.$globalEvent = new _index7.default(options);
	        var $dispatcher = vm.$dispatcher = new _index4.default(vm);

	        //如果是主场景,才能切换系统工具栏
	        if (options.multiplePages) {
	            _this.addTools(vm);
	        }

	        //事件句柄对象
	        var handlerObj = null;

	        /**
	         * 过滤器.全局控制函数
	         * return true 阻止页面滑动
	         */
	        $globalEvent.$watch('onFilter', function (hookCallback, point, evtObj) {
	            var target = point.target;
	            //阻止默认行为
	            preventDefault(evtObj, target);
	            //页面类型
	            var pageType = isBelong(target);
	            //冒泡的ul根节点
	            var parentNode = $globalEvent.findBubbleRootNode(point, pageType);
	            //执行过滤处理
	            handlerObj = _closest2.default.call(parentNode, point, pageType);
	            //停止翻页,针对content对象可以拖动,滑动的情况处理
	            if (!handlerObj || handlerObj.attribute === 'disable') {
	                hookCallback();
	            }
	        });

	        /**
	         * 触屏滑动,通知pageMgr处理页面移动
	         * @return {[type]} [description]
	         */
	        $globalEvent.$watch('onMove', function (data) {
	            $dispatcher.movePageBases(data);
	        });

	        /**
	         * 触屏松手点击
	         * 无滑动
	         */
	        $globalEvent.$watch('onTap', function (pageIndex, hookCallback) {
	            if (handlerObj) {
	                if (handlerObj.handlers) {
	                    handlerObj.handlers(handlerObj.elem, handlerObj.attribute, handlerObj.rootNode, pageIndex);
	                } else {
	                    if (!Xut.Contents.Canvas.getIsTap()) {
	                        vm.$emit('change:toggleToolbar');
	                    }
	                }
	                handlerObj = null;
	                hookCallback();
	            }
	        });

	        /**
	         * 触屏滑动,通知ProcessMgr关闭所有激活的热点
	         * @return {[type]}          [description]
	         */
	        $globalEvent.$watch('onUpSlider', function (pointers) {
	            $dispatcher.suspendPageBases(pointers);
	        });

	        /**
	         * 翻页动画完成回调
	         * @return {[type]}              [description]
	         */
	        $globalEvent.$watch('onComplete', function () {
	            $dispatcher.completePageBases.apply($dispatcher, arguments);
	        });

	        /**
	         * 切换页面
	         * @return {[type]}      [description]
	         */
	        $globalEvent.$watch('onJumpPage', function (data) {
	            $dispatcher.gotoPageBases(data);
	        });

	        /**
	         * 退出应用
	         * @return {[type]}      [description]
	         */
	        $globalEvent.$watch('onDropApp', function (data) {
	            window.GLOBALIFRAME && Xut.publish('magazine:dropApp');
	        });

	        /**
	         * 母板移动反馈
	         * 只有存在data-parallaxProcessed
	         * 才需要重新激活对象
	         * 删除parallaxProcessed
	         */
	        $globalEvent.$watch('onMasterMove', function (hindex, target) {
	            if (/Content/i.test(target.id) && target.getAttribute('data-parallaxProcessed')) {
	                $dispatcher.masterMgr && $dispatcher.masterMgr.reactivation(target);
	            }
	        });

	        /**
	         * 销毁接口api
	         * @type {[type]}
	         */
	        _this.destoryDynamicApi = (0, _dynamic2.default)(_this);
	        return _this;
	    }

	    /**
	     * 系统工具栏
	     */


	    _createClass(Mediator, [{
	        key: 'addTools',
	        value: function addTools(vm) {

	            _.extend(_hooks2.default, {

	                /**
	                 * li节点,多线程创建的时候处理滑动
	                 */
	                'data-container': function dataContainer() {
	                    vm.$emit('change:toggleToolbar');
	                },


	                /**
	                 * 是背景层
	                 */
	                'data-multilayer': function dataMultilayer() {
	                    //改变工具条状态
	                    vm.$emit('change:toggleToolbar');
	                },


	                /**
	                 * 默认content元素可以翻页
	                 */
	                'data-behavior': function dataBehavior(target, attribute, rootNode, pageIndex) {
	                    //没有事件的元素,即可翻页又可点击切换工具栏
	                    if (attribute == 'click-swipe') {
	                        vm.$emit('change:toggleToolbar');
	                    }
	                }
	            });
	        }
	    }]);

	    return Mediator;
	}(_index2.default);

	/**
	 * 是否多场景模式
	 */


	exports.default = Mediator;
	(0, _index5.defAccess)(Mediator.prototype, '$multiScenario', {
	    get: function get() {
	        return this.options.multiScenario;
	    }
	});

	/**
	 * 动态注入对象接口
	 * 注入对象管理,注册所有widget组件对象
	 *  content类型  创建时注册
	 *  widget类型   执行时注册
	 *  widget 包括 视频 音频 Action 子文档 弹出口 类型
	 *  这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
	 */
	(0, _index5.defAccess)(Mediator.prototype, '$injectionComponent', {
	    set: function set(regData) {
	        var injection;
	        if (injection = this.$dispatcher[regData.pageType + 'Mgr']) {
	            injection.abstractAssistPocess(regData.pageIndex, function (pageObj) {
	                pageObj.baseRegisterComponent.call(pageObj, regData.widget);
	            });
	        } else {
	            console.log('注册injection失败,regData=' + regData);
	        }
	    }
	});

	/**
	 * 得到当前的视图页面
	 * @return {[type]}   [description]
	 */
	(0, _index5.defAccess)(Mediator.prototype, '$curVmPage', {
	    get: function get() {
	        return this.$dispatcher.pageMgr.abstractGetPageObj(this.$globalEvent.getHindex());
	    }
	});

	/**
	 *  监听viewmodel内部的状态的改变,触发后传入值
	 *
	 *  与状态有关的change:
	 *      翻页
	 *          'flipOver' : function(pageIndex) {},
	 *
	 *      切换工具栏
	 *          'toggleToolbar' : function(state, pointer) {},
	 *
	 *      复位工具栏
	 *          'resetToolbar'  : function() {},
	 *
	 *      隐藏下一页按钮
	 *          'hideNext'   : function(state) {},
	 *
	 *      显示下一页按钮
	 *          'showNext'   : function() {}
	 *
	 *  与创建相关
	 *      创建完毕回调
	 *          'createComplete': null,
	 *      创建后中断自动运行回调
	 *          'suspendAutoCallback': null
	 *
	 */
	(0, _index5.defProtected)(Mediator.prototype, '$bind', function (key, callback) {
	    var vm = this;
	    vm.$watch('change:' + key, function () {
	        callback.apply(vm, arguments);
	    });
	});

	/**
	 * 创建页面
	 * @return {[type]} [description]
	 */
	(0, _index5.defProtected)(Mediator.prototype, '$init', function () {
	    this.$dispatcher.initCreate();
	});

	/**
	 * 运动动画
	 * @return {[type]} [description]
	 */
	(0, _index5.defProtected)(Mediator.prototype, '$run', function () {
	    var vm = this;
	    vm.$dispatcher.pageMgr.activateAutoRuns(vm.$globalEvent.getHindex(), Xut.Presentation.GetPageObj());
	});

	/**
	 * 复位对象
	 * @return {[type]} [description]
	 */
	(0, _index5.defProtected)(Mediator.prototype, '$reset', function () {
	    return this.$dispatcher.pageMgr.resetOriginal(this.$globalEvent.getHindex());
	});

	/**
	 * 停止所有任务
	 * @return {[type]} [description]
	 */
	(0, _index5.defProtected)(Mediator.prototype, '$suspend', function () {
	    Xut.Application.Suspend({
	        skipAudio: true //跨页面不处理
	    });
	});

	/**
	 * 销毁场景内部对象
	 * @return {[type]} [description]
	 */
	(0, _index5.defProtected)(Mediator.prototype, '$destroy', function () {
	    this.$off(); //观察事件
	    this.$globalEvent.destroy(); //全局事件
	    this.$dispatcher.destroyPageBases(); //派发器
	    this.$dispatcher = null;
	    this.$globalEvent = null;
	    this.destoryDynamicApi(); //动态api
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _abstract = __webpack_require__(34);

	var _pagebase = __webpack_require__(36);

	var _index = __webpack_require__(8);

	var _util = __webpack_require__(18);

	var _index2 = __webpack_require__(1);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 母版管理模块
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @param  {[type]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @return {[type]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


	/**
	 * 扁平化对象到数组
	 * @param  {[type]} filter [description]
	 * @return {[type]}        [description]
	 */
	var toArray = function toArray(filter) {
	    var arr = [];
	    if (!filter.length) {
	        for (var key in filter) {
	            arr.push(filter[key]);
	        }
	        filter = arr;
	    }
	    return filter;
	};

	var rword = "-";
	var transitionDuration = Xut.style.transitionDuration;
	var transform = Xut.style.transform;
	var translateZ = Xut.style.translateZ;

	/**
	 * parallaObjsCollection: Object
	 *      0: Page
	 *      1: Page
	 *
	 *  recordMasterId: Object
	 *      0: 9001
	 *      1: 9001
	 *
	 *  recordMasterscope: Object
	 *      9001: Array[2]
	 *
	 *  rootNode: ul # parallax.xut - parallax xut - flip
	 *
	 *  currMasterId: 9001 //实际的可使区
	 */

	var MasterMgr = function (_Abstract) {
	    _inherits(MasterMgr, _Abstract);

	    function MasterMgr(vm) {
	        _classCallCheck(this, MasterMgr);

	        var _this = _possibleConstructorReturn(this, (MasterMgr.__proto__ || Object.getPrototypeOf(MasterMgr)).call(this));

	        _this.viewWidth = _index2.config.viewSize.width;
	        _this.viewHeight = _index2.config.viewSize.height;

	        _this.pageType = 'master';

	        _this.rootNode = vm.options.rootMaster;
	        _this.recordMasterscope = {}; //记录master区域范围
	        _this.recordMasterId = {}; //记录页面与母板对应的编号
	        _this.currMasterId = null; //可视区母板编号

	        /**
	         * 记录视察处理的对象
	         * @type {Object}
	         */
	        _this.parallaxProcessedContetns = {};

	        /**
	         * 抽象方法
	         * 创建视觉差容器
	         */
	        _this.abstractCreateCollection();
	        return _this;
	    }

	    /**
	     * 注册状态管理
	     * @param  {[type]} pageIndex  [description]
	     * @param  {[type]} type       [description]
	     * @param  {[type]} hotspotObj [description]
	     * @return {[type]}            [description]
	     */


	    _createClass(MasterMgr, [{
	        key: 'register',
	        value: function register(pageIndex, type, hotspotObj) {
	            var parallaxObj = this.abstractGetPageObj(this.converMasterId(pageIndex));
	            if (parallaxObj) {
	                parallaxObj.registerCotents.apply(parallaxObj, arguments);
	            }
	        }

	        /**
	         * 创建
	         * @param  {[type]} dataOpts       [description]
	         * @param  {[type]} pageIndex      [description]
	         * @param  {[type]} createCallBack [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: 'create',
	        value: function create(dataOpts, pageIndex, createCallBack) {
	            var reuseMasterKey = void 0;
	            var pptMaster = dataOpts.chapterData.pptMaster;
	            var pageOffset = dataOpts.chapterData.pageOffset;

	            //母板复用的标示
	            var reuseMasterId = pageOffset && pageOffset.split(rword);

	            //组合下标
	            if (reuseMasterId && reuseMasterId.length === 3) {
	                reuseMasterKey = pptMaster + rword + reuseMasterId[2];
	            } else {
	                reuseMasterKey = pptMaster;
	            }

	            //检测视觉差对象是否重复创建
	            if (this._checkRepeat(reuseMasterKey, pageOffset, pageIndex)) {
	                return;
	            }

	            //通知外部,需要创建的母版
	            createCallBack();

	            var masterObj = new _pagebase.Pagebase(_.extend(dataOpts, {
	                'pageType': this.pageType, //创建页面的类型
	                'rootNode': this.rootNode, //根元素
	                'pptMaster': pptMaster //ppt母板ID
	            }));

	            //增加页面管理
	            this.abstractAddCollection(reuseMasterKey, masterObj);

	            return masterObj;
	        }

	        /**
	         * 页面滑动处理
	         * 1 母版之间的切换
	         * 2 浮动对象的切换
	         */

	    }, {
	        key: 'move',
	        value: function move() {
	            var _this2 = this;

	            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	                nodes = _ref.nodes,
	                speed = _ref.speed,
	                action = _ref.action,
	                moveDist = _ref.moveDist,
	                leftIndex = _ref.leftIndex,
	                currIndex = _ref.currIndex,
	                rightIndex = _ref.rightIndex,
	                direction = _ref.direction;

	            //是边界处理
	            //边界外处理母版
	            //边界内处理视觉差
	            var isBoundary = false;

	            //找到需要滑动的母版
	            var masterObjs = this._findMaster(leftIndex, currIndex, rightIndex, direction, action);
	            _.each(masterObjs, function (pageObj, index) {
	                if (pageObj) {
	                    isBoundary = true;
	                    pageObj.moveContainer(action, moveDist[index], speed, moveDist[3]);
	                }
	            });

	            //越界不需要处理内部视察对象
	            this.isBoundary = isBoundary;
	            if (isBoundary) {
	                return;
	            }

	            /**
	             * 移动内部的视察对象
	             * 处理当前页面内的视觉差对象效果
	             */
	            var moveParallaxObject = function moveParallaxObject(nodes) {
	                var getMasterId = _this2.converMasterId(currIndex);
	                var currParallaxObj = _this2.abstractGetPageObj(getMasterId);
	                if (currParallaxObj) {
	                    //处理当前页面内的视觉差对象效果
	                    currParallaxObj.moveParallax({
	                        action: action,
	                        direction: direction,
	                        moveDist: moveDist,
	                        speed: speed,
	                        nodes: nodes,
	                        parallaxProcessedContetns: _this2.parallaxProcessedContetns
	                    });
	                }
	            };

	            //移动视察对象
	            switch (direction) {
	                case 'prev':
	                    moveParallaxObject();
	                    break;
	                case 'next':
	                    nodes && moveParallaxObject(nodes);
	                    break;
	            }
	        }

	        /**
	         * 停止行为
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'suspend',
	        value: function suspend(pointers) {
	            //如果未越界不需要处理行为
	            if (!this.isBoundary) return;
	            var masterObj,
	                stopPointer = pointers.stopPointer;
	            if (masterObj = this.abstractGetPageObj(stopPointer)) {
	                var pageId = masterObj.baseGetPageId(stopPointer);
	                //停止活动对象活动
	                (0, _index.$$suspend)(masterObj, pageId);
	            }
	        }

	        /**
	         * 复位初始状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'resetOriginal',
	        value: function resetOriginal(pageIndex) {
	            var originalPageObj;
	            if (originalPageObj = this.abstractGetPageObj(pageIndex)) {
	                (0, _index.$$original)(originalPageObj);
	            }
	        }

	        /**
	         *  母版自动运行
	         */

	    }, {
	        key: 'autoRun',
	        value: function autoRun(data) {
	            var masterObj;
	            if (masterObj = this.abstractGetPageObj(data.currIndex)) {
	                //热点状态复位
	                this.resetOriginal(data.suspendIndex);
	                (0, _index.$$autoRun)(masterObj, data.currIndex);
	            }
	        }

	        /**
	         * 重新激动视觉差对象
	         * 因为视察滑动对象有动画
	         * 2个CSS3动画冲突的
	         * 所以在视察滑动的情况下先停止动画
	         * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
	         * 通过动画回调在重新加载动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reactivation',
	        value: function reactivation(target) {
	            if (this.parallaxProcessedContetns) {
	                var actName = target.id;
	                var contentObj = this.parallaxProcessedContetns[actName];
	                if (contentObj) {
	                    contentObj.runAnimations();
	                    //视觉差处理一次,停止过动画
	                    contentObj.parallaxProcessed = false;
	                    //移除标记
	                    target.removeAttribute('data-parallaxProcessed');
	                    //记录
	                    delete this.parallaxProcessedContetns[actName];
	                }
	            }
	        }

	        /**
	         * 制作处理器
	         * 针对跳转页面
	         * @param  {[type]} data [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: 'makeJumpPocesss',
	        value: function makeJumpPocesss(data) {
	            var filter;
	            var master = this;
	            return {
	                pre: function pre() {
	                    var targetIndex = data.targetIndex;
	                    //目标母板对象
	                    var targetkey = master.converMasterId(targetIndex);
	                    //得到过滤的边界keys
	                    //在filter中的页面为过滤
	                    filter = master._scanBounds(targetIndex, targetkey);
	                    //清理多余母板
	                    //filter 需要保留的范围
	                    master._checkClear(filter, true);
	                    //更新可视母板编号
	                    master.currMasterId = targetkey;
	                },
	                //修正位置
	                clean: function clean(currIndex, targetIndex) {
	                    master._fixPosition(filter);
	                    master._checkParallaxPox(currIndex, targetIndex);
	                }
	            };
	        }

	        /**
	         * 销毁整个页面对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.rootNode = null;
	            //销毁对象
	            this.abstractDestroyCollection();
	        }

	        /**
	         * 找到当前页面的可以需要滑动是视觉页面对象
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_findMaster',
	        value: function _findMaster(leftIndex, currIndex, rightIndex, direction, action) {
	            var prevFlag,
	                nextFlag,
	                prevMasterObj,
	                currMasterObj,
	                nextMasterObj,
	                prevMasterId = this.converMasterId(leftIndex),
	                currMasterId = this.converMasterId(currIndex),
	                nextMasterId = this.converMasterId(rightIndex);

	            switch (direction) {
	                case 'prev':
	                    if (prevFlag = currMasterId !== prevMasterId) {
	                        currMasterObj = this.abstractGetPageObj(currMasterId);
	                    }
	                    if (prevMasterId && prevFlag) {
	                        action === 'flipOver' && this._checkClear([currMasterId, prevMasterId]); //边界清理
	                        prevMasterObj = this.abstractGetPageObj(prevMasterId);
	                    }
	                    break;
	                case 'next':
	                    if (nextFlag = currMasterId !== nextMasterId) {
	                        currMasterObj = this.abstractGetPageObj(currMasterId);
	                    }
	                    if (nextMasterId && nextFlag) {
	                        action === 'flipOver' && this._checkClear([currMasterId, nextMasterId]); //边界清理
	                        nextMasterObj = this.abstractGetPageObj(nextMasterId);
	                    }
	                    break;
	            }
	            return [prevMasterObj, currMasterObj, nextMasterObj];
	        }

	        //扫描边界
	        //扫描key的左右边界
	        //当前页面的左右边

	    }, {
	        key: '_scanBounds',
	        value: function _scanBounds(currPage, currkey) {
	            var currKey = this.converMasterId(currPage),
	                filter = {},
	                i = currPage,
	                prevKey,
	                nextKey;

	            //往前
	            while (i--) {
	                prevKey = this.converMasterId(i);
	                if (prevKey && prevKey !== currkey) {
	                    filter['prev'] = prevKey;
	                    break;
	                }
	            }

	            //往后
	            nextKey = this.converMasterId(currPage + 1);

	            //如果有下一条记录
	            if (nextKey && nextKey !== currkey) {
	                //如果不是当期页面满足范围要求
	                filter['next'] = nextKey;
	            }

	            //当前页面
	            if (currKey) {
	                filter['curr'] = currKey;
	            }
	            return filter;
	        }

	        /**
	         * 修正位置
	         * @param  {[type]} filter [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_fixPosition',
	        value: function _fixPosition(filter) {

	            var self = this;

	            var setPosition = function setPosition(parallaxObj, position) {

	                /**
	                 * 设置移动
	                 */
	                var _fixToMove = function _fixToMove(distance, speed) {
	                    var $pageNode = parallaxObj.$pageNode;
	                    if ($pageNode) {
	                        $pageNode.css(transitionDuration, speed + 'ms');
	                        $pageNode.css(transform, 'translate(' + distance + 'px,0px)' + translateZ);
	                    }
	                };

	                if (position === 'prev') {
	                    _fixToMove(-self.viewWidth);
	                } else if (position === 'next') {
	                    _fixToMove(self.viewWidth);
	                } else if (position === 'curr') {
	                    _fixToMove(0);
	                }
	            };

	            for (var key in filter) {
	                switch (key) {
	                    case 'prev':
	                        setPosition(this.abstractGetPageObj(filter[key]), 'prev');
	                        break;
	                    case 'curr':
	                        setPosition(this.abstractGetPageObj(filter[key]), 'curr');
	                        break;
	                    case 'next':
	                        setPosition(this.abstractGetPageObj(filter[key]), 'next');
	                        break;
	                }
	            }
	        }
	    }, {
	        key: '_checkParallaxPox',
	        value: function _checkParallaxPox(currPageIndex, targetIndex) {
	            var key,
	                pageObj,
	                pageCollection = this.abstractGetCollection();
	            for (key in pageCollection) {
	                pageObj = pageCollection[key];
	                //跳跃过的视觉容器处理
	                this._fixParallaxPox(pageObj, currPageIndex, targetIndex);
	            }
	        }

	        /**
	         * 当前同一视觉页面作用的范围
	         * @param  {[type]} reuseMasterKey [description]
	         * @param  {[type]} pageIndex      [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_toRepeat',
	        value: function _toRepeat(reuseMasterKey, pageIndex) {
	            var temp;
	            if (temp = this.recordMasterscope[reuseMasterKey]) {
	                return temp;
	            }
	            return false;
	        }

	        //更新母板作用域范围
	        //recordMasterscope:{
	        //   9001-1:[0,1], master 对应记录的页码
	        //   9002-1:[2,3]
	        //   9001-2:[4,5]
	        //}

	    }, {
	        key: '_updataMasterscope',
	        value: function _updataMasterscope(reuseMasterKey, pageIndex) {
	            var scope;
	            if (scope = this.recordMasterscope[reuseMasterKey]) {
	                if (-1 === scope.indexOf(pageIndex)) {
	                    scope.push(pageIndex);
	                }
	            } else {
	                this.recordMasterscope[reuseMasterKey] = [pageIndex];
	            }
	        }

	        /**
	         * 记录页面与模板标示的映射
	         * @param  {[type]} reuseMasterKey [description]
	         * @param  {[type]} pageIndex      [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_updatadParallaxMaster',
	        value: function _updatadParallaxMaster(reuseMasterKey, pageIndex) {
	            //记录页面与模板标示的映射
	            this.recordMasterId[pageIndex] = reuseMasterKey;

	            //更新可视区母板的编号
	            this.currMasterId = this.converMasterId(Xut.Presentation.GetPageIndex());
	        }

	        /**
	         * 检测是否需要创建视觉差
	         * @param  {[type]} reuseMasterKey [description]
	         * @param  {[type]} pageOffset     [description]
	         * @param  {[type]} pageIndex      [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_checkRepeat',
	        value: function _checkRepeat(reuseMasterKey, pageOffset, pageIndex) {
	            var tag = this._toRepeat(reuseMasterKey, pageIndex); //false就是没找到视察对象
	            this._updataMasterscope(reuseMasterKey, pageIndex);
	            this._updatadParallaxMaster(reuseMasterKey, pageIndex);
	            return tag;
	        }

	        /**
	         * 修正跳转后视觉对象坐标
	         * @param  {[type]} parallaxObj   [description]
	         * @param  {[type]} currPageIndex [description]
	         * @param  {[type]} targetIndex   [description]
	         * @return {[type]}               [description]
	         */

	    }, {
	        key: '_fixParallaxPox',
	        value: function _fixParallaxPox(parallaxObj, currPageIndex, targetIndex) {
	            var self = this;
	            var contentObjs = void 0;
	            var prevNodes = void 0;
	            var nodes = void 0;

	            var repairNodes = function repairNodes(parallax) {
	                var rangePage = parallax.calculateRangePage();
	                var parameters = parallax.parameters;
	                var initProperty = parallax.initProperty;

	                if (targetIndex > currPageIndex) {
	                    //next
	                    if (targetIndex > rangePage['end']) {
	                        nodes = 1;
	                    }
	                } else {
	                    //prev
	                    if (targetIndex < rangePage['start']) {
	                        nodes = 0;
	                    }
	                }

	                var property = (0, _util.converValue)(parameters, -self.viewWidth, nodes);

	                //直接操作元素
	                (0, _util.setStyle)({
	                    $contentNode: parallax.$contentNode,
	                    action: 'master',
	                    property: property,
	                    speed: 300,
	                    opacityStart: initProperty.opacityStart
	                });

	                (0, _util.overMemory)(property, initProperty);
	            };

	            if (contentObjs = parallaxObj.baseGetContent()) {
	                //获取到页面nodes
	                nodes = Xut.Presentation.GetPageNode(targetIndex - 1);
	                contentObjs.forEach(function (contentObj) {
	                    contentObj.eachAssistContents(function (scope) {
	                        if (scope.parallax) {
	                            repairNodes(scope.parallax);
	                        }
	                    });
	                });
	            }
	        }

	        //检测是否需要清理
	        // 1 普通翻页清理  【数组过滤条件】
	        // 2 跳转页面清理  【对象过滤条件】

	    }, {
	        key: '_checkClear',
	        value: function _checkClear(filter, toPage) {
	            var key,
	                indexOf,
	                removeMasterId = _.keys(this.abstractGetCollection());

	            // 如果有2个以上的母板对象,就需要清理
	            if (removeMasterId.length > 2 || toPage) {
	                //或者是跳转页面
	                //解析对象
	                filter = toArray(filter);
	                //过滤
	                _.each(filter, function (masterId) {
	                    if (masterId !== undefined) {
	                        indexOf = removeMasterId.indexOf(masterId.toString());
	                        if (-1 !== indexOf) {
	                            //过滤需要删除的对象
	                            removeMasterId.splice(indexOf, 1);
	                        }
	                    }
	                });
	                this._clearMemory(removeMasterId);
	            }
	        }

	        /**
	         * 清理内存
	         * 需要清理的key合集
	         * @param  {[type]} removeMasterId [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_clearMemory',
	        value: function _clearMemory(removeMasterId) {
	            var pageObj,
	                self = this;
	            _.each(removeMasterId, function (removekey) {
	                //销毁页面对象事件
	                if (pageObj = self.abstractGetPageObj(removekey)) {
	                    //移除事件
	                    pageObj.baseDestroy();
	                    //移除列表
	                    self.abstractRemoveCollection(removekey);
	                    self._removeRecordMasterscope(removekey);
	                }
	                //清理作用域缓存
	                delete self.recordMasterscope[removekey];
	            });
	        }

	        /**
	         * page转化成母版ID
	         * @param  {[type]} pageIndex [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: 'converMasterId',
	        value: function converMasterId(pageIndex) {
	            return this.recordMasterId ? this.recordMasterId[pageIndex] : undefined;
	        }
	    }, {
	        key: '_removeRecordMasterscope',
	        value: function _removeRecordMasterscope(removekey) {
	            var me = this;
	            var recordMasterscope = me.recordMasterscope[removekey];
	            //清理页码指示标记
	            recordMasterscope.forEach(function (scope) {
	                delete me.recordMasterId[scope];
	            });
	        }
	    }]);

	    return MasterMgr;
	}(_abstract.Abstract);

	exports.default = MasterMgr;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _abstract = __webpack_require__(34);

	var _pagebase = __webpack_require__(36);

	var _edge = __webpack_require__(169);

	var _manager = __webpack_require__(4);

	var _index = __webpack_require__(2);

	var _index2 = __webpack_require__(8);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 页面模块
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @param  {[type]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @return {[type]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


	/**
	 * 检测脚本注入
	 * @return {[type]} [description]
	 */
	var runScript = function runScript(pageObject, type) {
	    var code = pageObject.chapterData[type];
	    if (code) {
	        (0, _index.execScript)(code, type);
	    }
	};

	var PageMgr = function (_Abstract) {
	    _inherits(PageMgr, _Abstract);

	    function PageMgr(vm) {
	        _classCallCheck(this, PageMgr);

	        var _this = _possibleConstructorReturn(this, (PageMgr.__proto__ || Object.getPrototypeOf(PageMgr)).call(this));

	        _this.pageType = 'page';

	        //页面根节点
	        _this.pagesNode = vm.options.rootPage;

	        //创建合集容器
	        _this.abstractCreateCollection();
	        return _this;
	    }

	    /**
	     * 创建页新的页面
	     * @param  {[type]} dataOpts  [description]
	     * @param  {[type]} pageIndex [description]
	     * @return {[type]}           [description]
	     */


	    _createClass(PageMgr, [{
	        key: 'create',
	        value: function create(dataOpts, pageIndex) {

	            //生成指定页面对象
	            var pageObjs = new _pagebase.Pagebase(_.extend(dataOpts, {
	                'pageType': this.pageType, //创建页面的类型
	                'rootNode': this.pagesNode //根元素
	            }));

	            //增加页面管理
	            this.abstractAddCollection(pageIndex, pageObjs);

	            return pageObjs;
	        }

	        /**
	         * 移动页面
	         * @return {[type]}
	         */

	    }, {
	        key: 'move',
	        value: function move(_ref) {
	            var nodes = _ref.nodes,
	                speed = _ref.speed,
	                action = _ref.action,
	                moveDist = _ref.moveDist,
	                leftIndex = _ref.leftIndex,
	                currIndex = _ref.currIndex,
	                rightIndex = _ref.rightIndex,
	                direction = _ref.direction;

	            _.each([this.abstractGetPageObj(leftIndex), this.abstractGetPageObj(currIndex), this.abstractGetPageObj(rightIndex)], function (pageObj, index) {
	                if (pageObj) {
	                    var distance = moveDist[index];
	                    pageObj.moveContainer(action, distance, speed, moveDist[3]);
	                }
	            });
	        }

	        /**
	         * 触屏翻页开始
	         * 1 中断所有任务
	         * 2 停止热点对象运行
	         *     停止动画,视频音频等等
	         */

	    }, {
	        key: 'suspend',
	        value: function suspend(pointers) {
	            var stopPointer = pointers.stopPointer,
	                suspendPageObj = this.abstractGetPageObj(stopPointer),
	                prveChpterId = suspendPageObj.baseGetPageId(stopPointer);

	            //翻页结束脚本
	            runScript(suspendPageObj, 'postCode');

	            //中断节点创建任务
	            this.$$suspendInnerCreateTasks(pointers);

	            //停止活动对象活动
	            suspendPageObj.destroyPageAction();
	            suspendPageObj.resetSwipeSequence();

	            (0, _index2.$$suspend)(suspendPageObj, prveChpterId);
	        }

	        /**
	         * 复位初始状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'resetOriginal',
	        value: function resetOriginal(pageIndex) {
	            var originalPageObj, floatNode;
	            if (originalPageObj = this.abstractGetPageObj(pageIndex)) {
	                if (floatNode = originalPageObj.floatContents.PageContainer) {
	                    //floatPages设置的content溢出后处理
	                    //在非视区增加overflow:hidden
	                    //可视区域overflow:''
	                    floatNode.css({
	                        'zIndex': 2000,
	                        'overflow': 'hidden'
	                    });
	                }
	                (0, _index2.$$original)(originalPageObj);
	            }
	        }

	        /**
	         * 触屏翻页完成
	         * 1 停止热点动作
	         * 2 触发新的页面动作
	         * @param  {[type]} prevPageIndex [上一页面]
	         * @param  {[type]} currPageIndex [当前页码]
	         * @param  {[type]} nextPageIndex [下一页页码]
	         * @param  {[type]} suspendIndex  [停止动作的页码]因为要区分滑动的方向
	         * @param  {[type]} createPointer [正在创建的页面]
	         * @param  {[type]} direction     [滑动方向]
	         */

	    }, {
	        key: 'autoRun',
	        value: function autoRun(data) {

	            var self = this;

	            /**
	             * 预执行背景创建
	             * 支持多线程快速翻页
	             * 1 初始化,或者快速翻页补全前后页面
	             * 2 正常翻页创建前后
	             */
	            var preCreate = function preCreate(preCreateTask) {
	                var resumePointer;
	                if (data.isQuickTurn || !data.direction) {
	                    resumePointer = [data.prevIndex, data.nextIndex];
	                } else {
	                    resumePointer = data.createPointer || data.nextIndex || data.prevIndex;
	                }
	                self._checkPreforkTasks(resumePointer, preCreateTask);
	            };

	            //激活自动运行对象
	            var startAutoRun = function startAutoRun(currPageObj, data) {

	                //结束通知
	                function complete() {
	                    data.processComplete();
	                    preCreate();
	                }

	                //如果页面容器存在,才处理自动运行
	                var currpagesNode = currPageObj.getContainsNode();
	                if (!currpagesNode) {
	                    return complete();
	                }

	                //运行动作
	                function startRun() {
	                    (0, _index2.$$autoRun)(currPageObj, data.currIndex, complete);
	                }

	                //运行如果被中断,则等待
	                if (data.suspendCallback) {
	                    data.suspendCallback(startRun);
	                } else {
	                    startRun();
	                }
	            };

	            //检测当前页面构建任务的情况
	            //如果任务没有完成，则等待任务完成
	            this._checkTaskCompleted(data.currIndex, function (currPageObj) {

	                currPageObj.createPageAction();

	                //提升当前页面浮动对象的层级
	                //因为浮动对象可以是并联的
	                var floatNode;
	                if (floatNode = currPageObj.floatContents.PageContainer) {
	                    floatNode.css({
	                        'zIndex': 2001,
	                        'overflow': ''
	                    });
	                }

	                //IE上不支持蒙版效果的处理
	                if (Xut.style.noMaskBoxImage) {
	                    (0, _edge.addEdges)();
	                }

	                //构件完成通知
	                data.buildComplete(currPageObj.scenarioId);

	                //执行自动动作之前的脚本
	                runScript(currPageObj, 'preCode');

	                //热点状态复位
	                self.resetOriginal(data.suspendIndex);

	                //预构建背景
	                preCreate('background');

	                //等待动画结束后构建
	                startAutoRun(currPageObj, data);
	            });
	        }

	        /**
	         * 销毁整个页面管理对象
	         * @param  {[type]} clearPageIndex [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: 'clearPage',
	        value: function clearPage(clearPageIndex) {
	            var pageObj = this.abstractGetPageObj(clearPageIndex);
	            //销毁页面对象事件
	            if (pageObj) {
	                //移除事件
	                pageObj.baseDestroy();
	                //移除列表
	                this.abstractRemoveCollection(clearPageIndex);
	            }
	        }

	        /**
	         * 销毁整个页面管理对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            //清理视频
	            var pageId = Xut.Presentation.GetPageId(Xut.Presentation.GetPageIndex());

	            (0, _manager.removeVideo)(pageId);

	            //清理对象
	            this.abstractDestroyCollection();
	            //清理节点
	            this.pagesNode = null;
	        }

	        /**
	         * 设置中断正在创建的页面对象任务
	         * @param {[type]}   currIndex [description]
	         * @param {Function} callback  [description]
	         */

	    }, {
	        key: '$$suspendInnerCreateTasks',
	        value: function $$suspendInnerCreateTasks(pointers) {
	            var pageObj,
	                self = this;
	            [pointers.leftIndex, pointers.currIndex, pointers.rightIndex].forEach(function (pointer) {
	                if (pageObj = self.abstractGetPageObj(pointer)) {
	                    pageObj.setTaskSuspend();
	                }
	            });
	        }

	        /**
	         * 检测活动窗口任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_checkTaskCompleted',
	        value: function _checkTaskCompleted(currIndex, callback) {
	            var currPageObj,
	                self = this;
	            // console.log('激活活动任务',currIndex)
	            if (currPageObj = self.abstractGetPageObj(currIndex)) {
	                currPageObj.checkThreadTask(function () {
	                    // console.log('11111111111当前页面创建完毕',currIndex+1)
	                    callback(currPageObj);
	                });
	            }
	        }

	        /**
	         * 检测后台预创建任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_checkPreforkTasks',
	        value: function _checkPreforkTasks(resumePointer, preCreateTask) {
	            var resumeObj, resumeCount;
	            if (!resumePointer.length) {
	                resumePointer = [resumePointer];
	            }
	            resumeCount = resumePointer.length;
	            while (resumeCount--) {
	                if (resumeObj = this.abstractGetPageObj(resumePointer[resumeCount])) {
	                    resumeObj.createPreforkTasks(function () {
	                        // console.log('后台处理完毕')
	                    }, preCreateTask);
	                }
	            }
	        }
	    }]);

	    return PageMgr;
	}(_abstract.Abstract);

	exports.default = PageMgr;

/***/ },
/* 118 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Collection;
	/**
	 * [ description]
	 * @return {[type]} [description]
	 */

	/**
	 * 处理合集
	 */
	function Collection() {
	    this.remove();
	}

	Collection.prototype = {
	    register: function register(contentObj) {
	        if (!this.list) {
	            this.list = [contentObj];
	        } else {
	            this.list.push(contentObj);
	        }
	    },
	    get: function get() {
	        return this.list;
	    },


	    /**
	     * 是否存在
	     * @return {Boolean} [description]
	     */
	    isExist: function isExist() {
	        return this.list.length;
	    },

	    /**
	     * 得到一个指定的实例
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    specified: function specified(data) {
	        var instance;
	        var listLength = this.list.length;
	        while (listLength) {
	            listLength--;
	            if (instance = this.list[listLength]) {
	                if (instance.type === data.type && instance.id === data.id) {
	                    return instance;
	                }
	            }
	        }
	    },
	    remove: function remove() {
	        this.list = [];
	    },
	    reset: function reset() {
	        this.remove();
	    }
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	        value: true
	});

	var _index = __webpack_require__(16);

	var _index2 = _interopRequireDefault(_index);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // 观察


	/**
	 * canvas相关处理
	 * 启动canvas,pixi库
	 * 事件，动画等
	 * 需要收集所有content的执行
	 * 因为canvas只能绘制一次
	 * cnavas模式下 category === "Sprite" 转化cid
	 */
	var Factory = function (_Observer) {
	        _inherits(Factory, _Observer);

	        function Factory() {
	                _classCallCheck(this, Factory);

	                /**
	                 * 是否启动模式
	                 * @type {Boolean}
	                 */
	                var _this = _possibleConstructorReturn(this, (Factory.__proto__ || Object.getPrototypeOf(Factory)).call(this));

	                _this.enable = false;

	                /**
	                 * CompSprite非常特殊
	                 * 可以在dom的情况下使用
	                 * 所以如果是dom模式要强制开始enable‘
	                 * 这样会导致 精灵等动画强制转canvas
	                 * 这是错误的，所以增加一个判断
	                 *
	                 */
	                _this.onlyCompSprite = false;

	                /**
	                 * 加载失败content列表
	                 * @type {Array}
	                 */
	                _this.failCid = [];

	                //所有contentId
	                _this.cid = [];

	                //开启了contentMode的节点
	                //对应的content转化成canvas模式
	                //普通精灵动画
	                //ppt动画=>转化
	                _this.pptId = [];

	                //普通灵精
	                _this.spiritId = [];

	                //widget零件保存的content id
	                //高级精灵动画
	                _this.widgetId = [];

	                //复杂精灵动画
	                _this.compSpriteId = [];

	                //默认canvas容器的层级
	                //取精灵动画最高层级
	                //2016.2.25
	                _this.containerIndex = 1;

	                /**
	                 * cid=>wid
	                 * 对应的pixi对象容器
	                 * @type {Object}
	                 */
	                _this.collections = {};
	                return _this;
	        }

	        return Factory;
	}(_index2.default);

	exports.default = Factory;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (baseProto) {

	    /**
	     * 转化序列名
	     * @return {[type]} [description]
	     */
	    baseProto._converSequenceName = function (direction) {
	        return direction === 'next' ? 'swipeleft' : 'swiperight';
	    };

	    /**
	     * 是否有动画序列
	     */
	    baseProto.hasSwipeSequence = function (direction) {
	        var eventName = this._converSequenceName(direction);
	        var swipeSequence = this._swipeSequence;

	        //如果执行完毕了
	        if (swipeSequence[eventName + 'Index'] === swipeSequence[eventName + 'Total']) {
	            return false;
	        }
	        return swipeSequence[eventName].length;
	    };

	    /**
	     * 执行动画序列
	     * @return {[type]} [description]
	     */
	    baseProto.callSwipeSequence = function (direction) {
	        if (!this._swipeSequence) {
	            return;
	        }
	        var eventName = this._converSequenceName(direction);
	        var sequence = this._swipeSequence[eventName];
	        var callAnimSequence = sequence[this._swipeSequence[eventName + 'Index']];
	        if (callAnimSequence) {
	            ++this._swipeSequence[eventName + 'Index'];
	            callAnimSequence(); //动画不能在回调中更改状态，因为翻页动作可能在动画没有结束之前，所以会导致翻页卡住
	        }
	    };

	    /**
	     * 复位动画序列
	     * @param  {[type]} direction [description]
	     * @return {[type]}           [description]
	     */
	    baseProto.resetSwipeSequence = function () {
	        if (!this._swipeSequence) {
	            return;
	        }
	        this._swipeSequence.swipeleftIndex = 0;
	        this._swipeSequence.swiperightIndex = 0;
	    };

	    /**
	     * 对象实例内部构建
	     * @return {[type]} [description]
	     */
	    baseProto.checkInstanceTasks = function (taskName) {
	        var tasksObj;
	        if (tasksObj = this.createRelated.cacheTasks[taskName]) {
	            tasksObj.runSuspendTasks();
	            return true;
	        }
	    };

	    /**
	     * 获取页面数据
	     * @return {[type]} [description]
	     */
	    baseProto.baseData = function () {
	        return this._dataCache[this.pageType];
	    };

	    /**
	     * 获取热点数据信息
	     * @return {[type]} [description]
	     */
	    baseProto.baseActivits = function () {
	        return this._dataCache['activitys'];
	    };

	    /**
	     * 获取自动运行数据
	     * @return {[type]} [description]
	     */
	    baseProto.baseAutoRun = function () {
	        var data = this._dataCache['auto'];
	        return data && data;
	    };

	    /**
	     * 获取chapterid
	     * @param  {[type]} pid [description]
	     * @return {[type]}     [description]
	     */
	    baseProto.baseGetPageId = function (pid) {
	        return this.baseData(pid)['_id'];
	    };

	    /**
	     * 找到对象的content对象
	     * @param  {[type]}   contentId [description]
	     * @param  {Function} callback  [description]
	     * @return {[type]}             [description]
	     */
	    baseProto.baseGetContentObject = function (contentId) {
	        var contentsObj;
	        if (contentsObj = this._contentsCollector[contentId]) {
	            return contentsObj;
	        } else {
	            //查找浮动母版
	            return this.floatContents.Master[contentId];
	        }
	    };

	    /**
	     * Xut.Content.show/hide 针对互斥效果增加接口
	     * 扩充，显示，隐藏，动画控制接口
	     * @param  {[type]} name [description]
	     * @return {[type]}      [description]
	     */
	    baseProto.baseContentMutex = function (contentId, type) {
	        var contentObj = void 0;
	        if (contentObj = this.baseGetContentObject(contentId)) {
	            (function () {
	                var $contentElement = contentObj.$contentNode.view ? contentObj.$contentNode.view : contentObj.$contentNode;

	                var handle = {
	                    'Show': function Show() {
	                        if (contentObj.type === 'dom') {
	                            $contentElement.css({
	                                'display': 'blcok',
	                                'visibility': 'visible'
	                            }).prop("mutex", false);
	                        } else {
	                            $contentElement.visible = true;
	                        }
	                    },
	                    'Hide': function Hide() {
	                        if (contentObj.type === 'dom') {
	                            $contentElement.css({
	                                'display': 'none',
	                                'visibility': 'hidden'
	                            }).prop("mutex", true);
	                        } else {
	                            $contentElement.visible = false;
	                        }
	                    },
	                    'StopAnim': function StopAnim() {
	                        contentObj.stopAnims && contentObj.stopAnims();
	                    }
	                };
	                handle[type]();
	            })();
	        }
	    };

	    //content接口
	    _.each(["Get", "Specified"], function (type) {
	        baseProto['base' + type + 'Content'] = function (data) {
	            switch (type) {
	                case 'Get':
	                    return this._abActivitys.get();
	                case 'Specified':
	                    return this._abActivitys.specified(data);
	            }
	        };
	    });

	    //components零件类型处理
	    //baseGetComponent
	    //baseRemoveComponent
	    //baseRegisterComponent
	    //baseSpecifiedComponent
	    _.each(["Get", "Remove", "Register", "Specified"], function (type) {
	        baseProto['base' + type + 'Component'] = function (data) {
	            switch (type) {
	                case 'Register':
	                    return this._components.register(data);
	                case 'Get':
	                    return this._components.get();
	                case 'Specified':
	                    return this._components.specified(data);
	                case 'Remove':
	                    return this._components.remove();
	            }
	        };
	    });

	    /**
	     *  运行辅助对象事件
	     * @param  {[type]} activityId  [description]
	     * @param  {[type]} outCallBack [description]
	     * @param  {[type]} actionName  [description]
	     * @return {[type]}             [description]
	     */
	    baseProto.baseAssistRun = function (activityId, outCallBack, actionName) {
	        var activity;
	        if (activity = this._abActivitys) {
	            _.each(activity.get(), function (contentObj, index) {
	                if (activityId == contentObj.activityId) {
	                    if (actionName == 'Run') {
	                        contentObj.runAnimation(outCallBack, true);
	                    }
	                    if (actionName == 'Stop') {
	                        contentObj.stopAnimation(outCallBack);
	                    }
	                }
	            }, this);
	        }
	    };
	};

	var _index = __webpack_require__(1);

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (baseProto) {

	    /**
	     * 销毁页面对象
	     * @return {[type]} [description]
	     */
	    baseProto.baseDestroy = function () {

	        // //清理图片缓存
	        // //读库快速退出模式下报错修正
	        // try {
	        //     this.$pageNode.hide().find('img').each(function(aaa, img) {
	        //         img.src = 'images/icons/clearmem.png'
	        //     })
	        // } catch (e) {
	        //     console.log('销毁图片出错')
	        // }

	        //最后一页动作处理
	        //for miaomiaoxue
	        this.destroyPageAction();

	        //2016/9/30
	        //for flow
	        //销毁缩放动作
	        if (this._pinchObj) {
	            this._pinchObj.destroy();
	        }

	        //流式布局对象
	        //2016.9.10
	        var _flows = this._flows.get();
	        if (_flows.length) {
	            _flows.forEach(function (flowObj) {
	                flowObj.destroy();
	                flowObj = null;
	            });
	            this._flows = null;
	        }

	        //清理线程任务块
	        var cacheTasks = void 0,
	            key = void 0,
	            tasks = void 0;
	        if (cacheTasks = this.createRelated.cacheTasks) {
	            for (key in cacheTasks) {
	                if (tasks = cacheTasks[key]) {
	                    tasks.clearReference();
	                }
	            }
	        }

	        //浮动对象
	        var floatMaterContents = this.floatContents.Master;

	        //是否有浮动对象
	        var hasFloatMater = !_.isEmpty(floatMaterContents);

	        //清理content类型对象
	        var contents = void 0;
	        if (contents = this._abActivitys.get()) {
	            contents.forEach(function (contentObj) {
	                contentObj.destroy(function (destroyObj) {
	                    //如果不是浮动对象,清理元素引用
	                    if (!hasFloatMater || destroyObj && !floatMaterContents[destroyObj.id]) {
	                        destroyObj.$contentNode = null;
	                    }
	                });
	            });
	        }

	        //清除母版浮动容器
	        if (hasFloatMater && this.floatContents.MasterContainer) {
	            this.floatContents.MasterContainer.remove();
	        }

	        //清除浮动页面对象
	        if (this.floatContents.Page && this.floatContents.PageContainer) {
	            this.floatContents.PageContainer.remove();
	        }

	        //清理零件类型对象
	        var _components = void 0;
	        if (_components = this.baseGetComponent()) {
	            _components.length && _components.forEach(function (componentObj) {
	                componentObj.destroy && componentObj.destroy();
	            });
	        }

	        //多事件销毁
	        (0, _multievent.destroy)(this);

	        //伪li节点
	        if (this.$pseudoElement) {
	            this.$pseudoElement = null;
	        }

	        //移除li容器节点节点
	        this.$pageNode.remove();
	        this.rootNode = null;
	        this.$pageNode = null;
	    };
	};

	var _multievent = __webpack_require__(35);

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (baseProto) {

	    /**
	     * 初始化多线程任务
	     * @return {[type]} [description]
	     */
	    baseProto.initState = function (options) {

	        var instance = this;

	        _.extend(instance, options);

	        /**
	         * 数据缓存容器
	         * @type {Object}
	         */
	        this._dataCache = {};
	        this.scenarioId = this.chapterData.seasonId;
	        this.chapterId = this.chapterData._id;

	        /**
	         * 是否开启多线程,默认开启
	         * 如果是非线性，则关闭多线程创建
	         * 启动 true
	         * 关闭 false
	         * @type {[type]}
	         */
	        this.isMultithread = this.multiplePages ? true : false;

	        //母版处理
	        if (instance.pageType === 'master') {
	            this.isMaster = true;
	        }

	        //canvas模式
	        this.canvasRelated = new _factory2.default();

	        /**
	         * 内部钩子相关
	         * 监听状态的钩子
	         * 注册所有content对象管理
	         * 收集所有content对象
	         * 构建li主结构后,即可翻页
	         * 构建所有对象完毕后处理
	         */

	        /**
	         * 抽象activtiys合集,用于关联各自的content
	         * 划分各自的子作用域
	         * 1对多的关系
	         * @type {Collection}
	         */
	        this._abActivitys = new _collection2.default();

	        /**
	         * widget热点处理类
	         * 只存在当前页面
	         * 1 iframe零件
	         * 2 页面零件
	         * @type {Collection}
	         */
	        this._components = new _collection2.default();

	        /**
	         * 缓存所有的content对象引用
	         * 1对1的关系
	         * @type {Object}
	         */
	        this._contentsCollector = {};

	        /**
	         * 2016.9.7
	         * flow热点对象
	         * @type {Collection}
	         */
	        this._flows = new _collection2.default();

	        /**
	         * 流式布局页面
	         * 排除母版
	         * @param  {[type]} instance.pageType [description]
	         * @return {[type]}                   [description]
	         */
	        if (this.pageType === 'master' && this.isFlows) {
	            this.isFlows = false;
	        }

	        /**
	         * 为mini杂志新功能
	         * 动画的调用序列
	         * 收集滑动委托对象，针对事件合集触发处理
	         * 2016.11.8
	         * @type {Array}
	         */
	        if (_index.config.swipeDelegate) {
	            this._swipeSequence = {
	                swipeleft: [],
	                swiperight: [],
	                swipeleftTotal: 0,
	                swiperightTotal: 0,
	                swipeleftIndex: 0,
	                swiperightIndex: 0
	            };
	        }

	        /**
	         * 浮动对象
	         * 1 母版中
	         * 2 页面中
	         * 页面中是最高的
	         * @type {Object}
	         */
	        var floatContents = this.floatContents = {

	            /**
	             * 页面浮动对象容器
	             * @type {[type]}
	             */
	            PageContainer: null,

	            /**
	             * 浮动页面对象
	             * @type {Object}
	             */
	            Page: {},

	            /**
	             * 浮动母版容器
	             */
	            MasterContainer: null,

	            /**
	             * 浮动母版的content对象
	             * 用于边界切换,自动加上移动
	             * @type {Object}
	             *     1：Object {}      //空对象,零件
	             *     2: PPTeffect  {}  //行为对象
	             */
	            Master: {}
	        };

	        /**
	         * 对象的处理情况的内部钩子方法
	         * @type {Object}
	         */
	        this.listenerHooks = {

	            /**
	             * 注册抽象Activity类content(大类,总content对象)
	             * @param  {[type]} contentsObjs [description]
	             * @return {[type]}              [description]
	             */
	            registerActivitys: function registerActivitys(contentsObjs) {
	                instance._abActivitys.register(contentsObjs);
	            },


	            /**
	             * 搜集所有的content(每一个content对象)
	             * 因为content多页面共享的,所以content的合集需要保存在pageMgr中（特殊处理）
	             */
	            contents: function contents(pid, id, contentScope) {
	                var scope = instance.baseGetContentObject[id];
	                //特殊处理,如果注册了事件ID,上面还有动画,需要覆盖
	                if (scope && scope.isBindEventHooks) {
	                    instance._contentsCollector[id] = contentScope;
	                }
	                if (!scope) {
	                    instance._contentsCollector[id] = contentScope;
	                }
	            },


	            /**
	             * 2014.11.7
	             * 新概念，浮动页面对象
	             * 用于是最顶层的，比母版浮动对象还要高
	             * 所以这个浮动对象需要跟随页面动
	             */
	            floatPages: function floatPages(data) {
	                //浮动页面对象容器
	                var contentObj = void 0;
	                floatContents.PageContainer = data.container;
	                _.each(data.ids, function (id) {
	                    if (contentObj = instance.baseGetContentObject(id)) {
	                        //初始视察坐标
	                        if (contentObj.parallax) {
	                            contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
	                        }
	                        floatContents.Page[id] = contentObj;
	                    } else {
	                        console.log('页面浮动对象找不到');
	                    }
	                });
	            },


	            /**
	             * 浮动母版对象
	             * 1 浮动的对象是有动画数据或者视觉差数据
	             * 2 浮动的对象是用于零件类型,这边只提供创建
	             *  所以需要制造一个空的容器，用于母版交界动
	             */
	            floatMaters: function floatMaters(data) {
	                var prefix = void 0;
	                var contentObj = void 0;
	                var contentNode = void 0;
	                var contentsFragment = void 0;

	                //浮动容器
	                floatContents.MasterContainer = data.container;
	                //浮动对象
	                _.each(data.ids, function (id) {
	                    //转化成实际操作的浮动对象,保存
	                    if (contentObj = instance.baseGetContentObject(id)) {
	                        //初始视察坐标
	                        if (contentObj.parallax) {
	                            contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
	                        }
	                        floatContents.Master[id] = contentObj;
	                    } else {
	                        Xut.plat.isBrowser && console.log('浮动母版对象数据不存在原始对象,制作伪对象母版移动', id);
	                        //获取DOM节点
	                        if (contentsFragment = instance.createRelated.cacheTasks.contents.contentsFragment) {
	                            prefix = 'Content_' + instance.pid + "_";
	                            _.each(contentsFragment, function (dom) {
	                                var makePrefix = prefix + id;
	                                if (dom.id == makePrefix) {
	                                    contentNode = dom;
	                                }
	                            });
	                        }
	                        //制作一个伪数据
	                        //作为零件类型的空content处理
	                        floatContents.Master[id] = {
	                            id: id,
	                            pid: instance.pid,
	                            $contentNode: $(contentNode),
	                            'empty': true //空类型
	                        };
	                    }
	                });
	            },


	            /**
	             * 多事件钩子
	             * 执行多事件绑定
	             * @param  {[type]} eventRelated [description]
	             * @return {[type]}              [description]
	             */
	            eventBinding: function eventBinding(eventRelated) {
	                (0, _multievent.create)(instance, eventRelated);
	            },


	            /**
	             * 2016.11.8
	             * 收集滑动委托对象，针对事件合集触发处理
	             * @return {[type]} [description]
	             */
	            swipeDelegateContents: function swipeDelegateContents(eventName, fn) {
	                ++instance._swipeSequence[eventName + 'Total'];
	                instance._swipeSequence[eventName].push(fn);
	            }
	        };

	        /**
	         * 初始化任务
	         * 等待状态初始化，比如_isFlows
	         */
	        (0, _tasks2.default)(instance);
	    };
	};

	var _index = __webpack_require__(1);

	var _multievent = __webpack_require__(35);

	var _collection = __webpack_require__(118);

	var _collection2 = _interopRequireDefault(_collection);

	var _tasks = __webpack_require__(142);

	var _tasks2 = _interopRequireDefault(_tasks);

	var _factory = __webpack_require__(119);

	var _factory2 = _interopRequireDefault(_factory);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 123 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (baseProto) {

	    /**
	     * 开始调用任务
	     * dispatch=>index=>create=>startThreadTask
	     * @return {[type]} [description]
	     */
	    baseProto.startThreadTask = function (flipOver, callback) {
	        var _this = this;

	        //制作回调
	        //如果是快速翻页,立刻调用
	        //构建container调用preforkComplete
	        this.createRelated.preforkComplete = function () {
	            return function () {
	                //1 滑动允许打断创建
	                //
	                //swich
	                //2 所有继续分解任务
	                flipOver ? callback() : _this._checkTasksCreate(callback, _this);
	            };
	        }();

	        //继续构建任务
	        this.dispatchTasks();
	    };

	    /**
	     * 任务调度
	     * @return {[type]} [description]
	     */
	    baseProto.dispatchTasks = function () {
	        var threadtasks = void 0;
	        if (threadtasks = this.threadtasks[this.createRelated.nextRunTask]) {
	            threadtasks();
	        }
	    };

	    /**
	     * 处理最后一页动作
	     * [destroyPageAction description]
	     * @return {[type]} [description]
	     */
	    baseProto.destroyPageAction = function () {
	        if (this.stopLastPageAction) {
	            this.stopLastPageAction();
	            this.stopLastPageAction = null;
	        }
	    };

	    /**
	     * 创建最后一次页面动作
	     * @return {[type]} [description]
	     */
	    baseProto.createPageAction = function () {
	        //如果有最后一个动作触发
	        //2016.10.13 给妙妙学增加watch('complete')
	        if (this.runLastPageAction) {
	            //返回停止方法
	            this.stopLastPageAction = this.runLastPageAction();
	        }
	    };

	    /**
	     * 检测任务是否完成
	     * page => autoRun中需要保证任务完成后才能执行
	     * 快速翻页中遇到
	     * actTasksCallback 活动任务完成
	     * @return {[type]} [description]
	     */
	    baseProto.checkThreadTask = function (actTasksCallback) {
	        var _this2 = this;

	        this.isAutoRun = true;
	        this._checkTasksCreate(function () {
	            _this2.isAutoRun = false;
	            actTasksCallback();
	        });
	    };

	    /**
	     * 开始执行下一个线程任务,检测是否中断
	     * outSuspendTasks,
	     * outNextTasks
	     * taskName
	     * @return {[type]} [description]
	     */
	    baseProto.nextTasks = function (callback) {
	        this._asyTasks({
	            suspendCallback: function suspendCallback() {
	                callback.outSuspendTasks && callback.outSuspendTasks();
	            },
	            nextTaskCallback: function nextTaskCallback() {
	                callback.outNextTasks && callback.outNextTasks();
	            }
	        }, callback.interrupt);
	    };

	    /**
	     * 设置任务中断
	     */
	    baseProto.setTaskSuspend = function () {
	        this.isAutoRun = false;
	        this.canvasRelated.isTaskSuspend = true;
	        this.createRelated.preCreateTasks = false;
	        this.createRelated.tasksHang = null;
	    };

	    /**
	     * 后台预创建任务
	     * @param  {[type]} tasksTimer [时间间隔]
	     * @return {[type]}            [description]
	     */
	    baseProto.createPreforkTasks = function (callback, isPreCreate) {
	        var self = this;
	        //2个预创建间隔太短
	        //背景预创建还在进行中，先挂起来等待
	        if (this.createRelated.preCreateTasks) {
	            this.createRelated.tasksHang = function (callback) {
	                return function () {
	                    self._checkTasksCreate(callback);
	                };
	            }(callback);
	            return;
	        }

	        /**
	         * 翻页完毕后
	         * 预创建背景
	         */
	        if (isPreCreate) {
	            this.createRelated.preCreateTasks = true;
	        }

	        this._checkTasksCreate(callback);
	    };

	    /**
	     * 自动运行：检测是否需要开始创建任务
	     * 1 如果任务全部完成了毕
	     * 2 如果有中断任务,就需要继续创建未完成的任务
	     * 3 如果任务未中断,还在继续创建
	     * currtask 是否为当前任务，加速创建
	     */
	    baseProto._checkTasksCreate = function (callback, context) {

	        //如果任务全部完成
	        if (this.createRelated.nextRunTask === 'complete') {
	            return callback.call(context);
	        }

	        var self = this;

	        //开始构未完成的任务
	        this._cancelTaskSuspend();

	        //完毕回调
	        this.createRelated.createTasksComplete = function () {
	            callback.call(context);
	        };

	        //派发任务
	        this.nextTasks({
	            outNextTasks: function outNextTasks() {
	                self.dispatchTasks();
	            }
	        });
	    };

	    /**
	     * 取消任务中断
	     * @return {[type]} [description]
	     */
	    baseProto._cancelTaskSuspend = function () {
	        this.canvasRelated.isTaskSuspend = false;
	    };

	    /**
	     * 检测任务是否需要中断
	     * @return {[type]} [description]
	     */
	    baseProto._checkTaskSuspend = function () {
	        return this.canvasRelated.isTaskSuspend;
	    };

	    /**
	     * 多线程检测
	     * @return {[type]} [description]
	     */
	    baseProto._multithreadCheck = function (callbacks, interrupt) {
	        var _this3 = this;

	        var check = function check() {
	            if (_this3._checkTaskSuspend()) {
	                _this3.tasksTimeOutId && clearTimeout(_this3.tasksTimeOutId);
	                callbacks.suspendCallback.call(_this3);
	            } else {
	                callbacks.nextTaskCallback.call(_this3);
	            }
	        };

	        var next = function next() {
	            _this3.tasksTimeOutId = setTimeout(function () {
	                check();
	            }, _this3.canvasRelated.tasksTimer);
	        };

	        //自动运行页面构建
	        if (this.isAutoRun) {
	            //自动运行content中断检测 打断一次
	            if (interrupt) {
	                next();
	            } else {
	                check();
	            }
	        } else {
	            //后台构建
	            next();
	        }
	    };

	    /**
	     * 任务队列挂起
	     * nextTaskCallback 成功回调
	     * suspendCallback  中断回调
	     * @return {[type]} [description]
	     */
	    baseProto._asyTasks = function (callbacks, interrupt) {

	        //如果关闭多线程,不检测任务调度
	        if (!this.isMultithread) {
	            return callbacks.nextTaskCallback.call(this);
	        }

	        //多线程检测
	        this._multithreadCheck(callbacks, interrupt);
	    };
	};

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (baseProto) {

	    /**
	     * 页面移动
	     * @return {[type]} [description]
	     */
	    baseProto.moveContainer = function (action, distance, speed, viewOffset) {

	        var pageNode = this.$pageNode[0];

	        //浮动页面
	        if (this.pageType === 'page') {
	            //移动浮动页面容器
	            var $floatElement = this.floatContents.PageContainer;
	            if ($floatElement) {
	                _translation.translation[action]($floatElement[0], distance, speed);
	            }
	        }

	        //浮动母版
	        if (this.pageType === 'master') {
	            //母版交接判断
	            //用户事件的触发
	            this.onceMaster = false;

	            //移动浮动容器
	            var $masterElement = this.floatContents.MasterContainer;
	            if ($masterElement) {
	                _translation.translation[action]($masterElement[0], distance, speed);
	            }
	        }

	        //过滤多个动画回调，
	        //保证指向始终是当前页面
	        //翻页 && 是母版页 && 是当前页面
	        var isVisual = false; // 是可视页面
	        if (action === 'flipOver' && this.pageType === 'page' && distance === viewOffset) {
	            //增加可视页面标记
	            pageNode.setAttribute('data-view', true);
	            isVisual = true;
	        }

	        //当前页面
	        _translation.translation[action](pageNode, distance, speed, function () {
	            //修正flipMode切换页面的处理
	            //没有翻页效果
	            //强制给动画结束触发
	            //可视区页面
	            //排除母版的情况
	            if (_index.config.flipMode && isVisual) {
	                //设置动画完成
	                Xut.Application.SetTransitionComplete(pageNode, pageNode.getAttribute('data-view'));
	                return true;
	            }
	        });
	    };
	};

	var _index = __webpack_require__(1);

	var _translation = __webpack_require__(24);

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (baseProto) {

	    /**
	     * 移动视察对象
	     */
	    baseProto.moveParallax = function (_ref2) {
	        var action = _ref2.action,
	            direction = _ref2.direction,
	            moveDist = _ref2.moveDist,
	            speed = _ref2.speed,
	            nodes = _ref2.nodes,
	            parallaxProcessedContetns = _ref2.parallaxProcessedContetns;


	        var base = this;
	        var baseContents = this.baseGetContent();

	        if (!baseContents) {
	            return;
	        }

	        //移动距离
	        var distance = moveDist.length ? moveDist[1] : moveDist;

	        //遍历所有活动对象
	        _.each(baseContents, function (content) {
	            content.eachAssistContents(function (scope) {
	                //如果是视察对象移动
	                if (scope.parallax) {

	                    var $contentNode = scope.parallax.$contentNode;
	                    var contentObj = base.baseGetContentObject(scope.id);

	                    /**
	                     * 如果有这个动画效果
	                     * 先停止否则通过视觉差移动会出问题
	                     * 影响，摩天轮转动APK
	                     * 重新激动视觉差对象
	                     * 因为视察滑动对象有动画
	                     * 2个CSS3动画冲突的
	                     * 所以在视察滑动的情况下先停止动画
	                     * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
	                     * 通过动画回调在重新加载动画
	                     */
	                    if (contentObj && action === "flipMove" && contentObj.pptObj //ppt动画
	                    && !contentObj.parallaxProcessed) {
	                        //标记
	                        var actName = contentObj.actName;
	                        contentObj.stopAnimations();
	                        //视觉差处理一次,停止过动画
	                        contentObj.parallaxProcessed = true;
	                        //增加标记
	                        $contentNode.attr('data-parallaxProcessed', actName);
	                        //记录
	                        parallaxProcessedContetns[actName] = contentObj;
	                    }

	                    //移动视觉差对象
	                    translateParallax({
	                        $contentNode: $contentNode,
	                        scope: scope.parallax,
	                        direction: direction,
	                        action: action,
	                        speed: speed,
	                        nodes: nodes,
	                        distance: distance
	                    });
	                }
	            });
	        });
	    };
	};

	var _util = __webpack_require__(18);

	/**
	 * 移动视觉差对象
	 */
	var translateParallax = function translateParallax(_ref) {
	    var $contentNode = _ref.$contentNode,
	        scope = _ref.scope,
	        direction = _ref.direction,
	        action = _ref.action,
	        speed = _ref.speed,
	        nodes = _ref.nodes,
	        distance = _ref.distance;


	    var parameters = scope.parameters;
	    var initProperty = scope.initProperty;

	    //往前翻页
	    if (direction === 'prev') {
	        //分割的比例
	        var nodes_1 = scope.nodeProportion;
	        //如果往前溢出则取0
	        nodes = nodes == nodes_1 ? 0 : nodes_1;
	    }

	    var property = (0, _util.converValue)(parameters, distance, nodes);

	    switch (action) {
	        case 'flipMove':
	            //移动中
	            property = (0, _util.flipMove)(property, initProperty);
	            break;
	        case 'flipRebound':
	            //反弹
	            property = (0, _util.flipRebound)(property, initProperty);
	            break;
	        case 'flipOver':
	            //翻页结束,记录上一页的坐标
	            if (direction === 'prev') {
	                property = (0, _util.flipOver)(property, initProperty);
	            }
	            (0, _util.overMemory)(property, initProperty);
	            break;
	    }

	    //直接操作元素
	    (0, _util.setStyle)({
	        $contentNode: $contentNode,
	        action: 'master',
	        property: property,
	        speed: speed,
	        opacityStart: initProperty.opacityStart
	    });
	};

	/**
	 * 滑动
	 * @param  {[type]} baseProto [description]
	 * @return {[type]}           [description]
	 */

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _cache = __webpack_require__(129);

	var _cache2 = _interopRequireDefault(_cache);

	var _index = __webpack_require__(131);

	var _index2 = _interopRequireDefault(_index);

	var _index3 = __webpack_require__(127);

	var _index4 = _interopRequireDefault(_index3);

	var _index5 = __webpack_require__(133);

	var _index6 = _interopRequireDefault(_index5);

	var _index7 = __webpack_require__(130);

	var _index8 = _interopRequireDefault(_index7);

	var _index9 = __webpack_require__(139);

	var _index10 = _interopRequireDefault(_index9);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 解析canvas配置
	 * contentMode 分为  0 或者 1
	 * 1 是dom模式
	 * 0 是canvas模式
	 * 以后如果其余的在增加
	 * 针对页面chapter中的parameter写入 contentMode   值为 1
	 * 针对每一个content中的parameter写入 contentMode 值为 1
	 * 如果是canvas模式的时候，同时也是能够存在dom模式是
	 * @return {[type]} [description]
	 */
	var parseMode = function parseMode(pageData, base) {
	    var parameter = pageData.parameter;
	    if (parameter) {
	        try {
	            parameter = JSON.parse(parameter);
	            if (parameter) {
	                if (parameter.contentMode && parameter.contentMode == 1) {
	                    //非强制dom模式
	                    if (!Xut.config.onlyDomMode) {
	                        //启动dom模式
	                        base.canvasRelated.enable = true;
	                    }
	                }
	                //如果是最后一页处理
	                if (parameter.lastPage && base.pageType === 'page') {
	                    //运行应用运行时间
	                    base.runLastPageAction = function () {
	                        var runTime = Number(Xut.config.delayTime);
	                        var timeout = void 0;
	                        if (runTime) {
	                            timeout = setTimeout(function () {
	                                Xut.Application.Notify('complete');
	                            }, runTime * 1000); //转成秒
	                        }
	                        return function () {
	                            //返回停止方法
	                            if (timeout) {
	                                clearTimeout(timeout);
	                                timeout = null;
	                            }
	                        };
	                    };
	                }
	            }
	        } catch (e) {
	            console.log('JSON错误,chpterId为', base.chapterId, parameter);
	        }
	    }
	};

	/**
	 * 分配Container构建任务
	 * 1 同步数据
	 * 2 构建容器
	 * 3 给出构建回调,这里不能中断,翻页必须存在节点
	 * 4 等待之后自动创建或者后台空闲创建之后的任务
	 * @return {[type]} [description]
	 */
	exports.default = {

	    /**
	     * 主容器
	     */
	    'Container': function Container(taskCallback, base) {
	        //同步数据
	        _cache2.default.call(base, [base.pid], function () {
	            var pageData = base.baseData();
	            //contentMode模式
	            parseMode(pageData, base);
	            (0, _index2.default)(base, pageData, taskCallback);
	        });
	    },


	    /**
	     * 流式排版
	     */
	    'Flow': function Flow(taskCallback, base) {
	        (0, _index10.default)(base, taskCallback);
	    },


	    /**
	     *  分配背景构建任务
	     *    1 构建数据与结构,执行中断检测
	     *    2 绘制结构,执行回调
	     *
	     *  提供2组回调
	     *    1 构建数据结构 suspendCallback
	     *    2 执行innerhtml构建完毕 successCallback
	     */
	    'Background': function Background(taskCallback, base) {

	        if (base.checkInstanceTasks('background')) {
	            return;
	        }

	        var data = base.baseData(base.pid);

	        /**
	         * 构建中断回调
	         */
	        var suspendCallback = function suspendCallback(innerNextTasks, innerSuspendTasks) {
	            base.nextTasks({
	                'taskName': '内部background',
	                'outSuspendTasks': innerSuspendTasks,
	                'outNextTasks': innerNextTasks
	            });
	        };

	        /**
	         * 获取数据成功回调
	         * @return {[type]} [description]
	         */
	        var successCallback = function successCallback() {
	            taskCallback();
	        };

	        base.createRelated.cacheTasks['background'] = new _index4.default({
	            data: data,
	            $containsNode: base.getContainsNode(),
	            suspendCallback: suspendCallback,
	            successCallback: successCallback
	        });
	    },


	    /**
	     * 分配Components构建任务
	     * @return {[type]} [description]
	     */
	    'Components': function Components(taskCallback, base) {

	        if (base.checkInstanceTasks('components')) {
	            return;
	        }

	        var chapterData = base.chapterData;
	        var baseData = base.baseData();

	        /**
	         * 构建中断回调
	         * @param  {[type]} innerNextTasks    [description]
	         * @param  {[type]} innerSuspendTasks [description]
	         * @return {[type]}                   [description]
	         */
	        var suspendCallback = function suspendCallback(innerNextTasks, innerSuspendTasks) {
	            base.nextTasks({
	                'taskName': '内部widgets',
	                'outSuspendTasks': innerSuspendTasks,
	                'outNextTasks': innerNextTasks
	            });
	        };

	        /**
	         * 获取数据成功回调
	         * @return {[type]} [description]
	         */
	        var successCallback = function successCallback() {
	            taskCallback();
	        };

	        base.createRelated.cacheTasks['components'] = new _index8.default({
	            '$containsNode': base.getContainsNode(),
	            'nodes': chapterData['nodes'],
	            'pageOffset': chapterData['pageOffset'],
	            'activitys': base.baseActivits(),
	            'chpaterData': baseData,
	            'chapterId': baseData['_id'],
	            'pid': base.pid,
	            'pageType': base.pageType,
	            'virtualOffset': base.virtualOffset
	        }, suspendCallback, successCallback);
	    },


	    /**
	     * 分配contetns构建任务
	     * @return {[type]} [description]
	     */
	    'Contents': function Contents(taskCallback, base) {

	        //通过content数据库为空处理
	        if (Xut.data.preventContent) {
	            return taskCallback();
	        }

	        if (base.checkInstanceTasks('contents')) {
	            return;
	        }

	        var chapterData = base.chapterData;
	        var baseData = base.baseData();
	        var chapterId = baseData['_id'];
	        var activitys = base.baseActivits();

	        /**
	         * 生成钩子
	         */
	        var pageBaseHooks = _.extend({}, {
	            /**
	             * 构建中断回调
	             * @return {[type]}                   [description]
	             */
	            suspend: function suspend(taskName, innerNextTasks, innerSuspendTasks) {
	                //如果是当前页面构建,允许打断一次
	                var interrupt;
	                if (base.isAutoRun && taskName === 'strAfter') {
	                    interrupt = true;
	                }
	                base.nextTasks({
	                    'interrupt': interrupt,
	                    'taskName': '内部contents',
	                    'outSuspendTasks': innerSuspendTasks,
	                    'outNextTasks': innerNextTasks
	                });
	            },


	            /**
	             * 获取数据成功回调
	             * @return {[type]} [description]
	             */
	            success: function success() {
	                taskCallback();
	            }
	        }, base.listenerHooks);

	        base.createRelated.cacheTasks['contents'] = new _index6.default({
	            'canvasRelated': base.canvasRelated,
	            'rootNode': base.rootNode,
	            '$containsNode': base.getContainsNode(),
	            'pageType': base.pageType,
	            'nodes': chapterData['nodes'],
	            'pageOffset': chapterData['pageOffset'],
	            'activitys': activitys,
	            'chpaterData': baseData,
	            'chapterId': chapterId,
	            'pageIndex': base.pageIndex,
	            'pid': base.pid,
	            'pageBaseHooks': pageBaseHooks,
	            'virtualOffset': base.virtualOffset,
	            'getStyle': base.getStyle
	        });
	    }
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _option = __webpack_require__(11);

	var _layout = __webpack_require__(128);

	var _layout2 = _interopRequireDefault(_layout);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 构建背景类
	 * @param {[type]} $containsNode         [根节点]
	 * @param {[type]} data                 [数据]
	 * @param {[type]} suspendCallback      [中断回调]
	 * @param {[type]} successCallback      [description]
	 */
	var TaskBackground = function () {
	    function TaskBackground(_ref) {
	        var data = _ref.data,
	            $containsNode = _ref.$containsNode,
	            suspendCallback = _ref.suspendCallback,
	            successCallback = _ref.successCallback;

	        _classCallCheck(this, TaskBackground);

	        var layer,
	            suspendTasks,
	            nextTasks,
	            self = this,
	            content = data["md5"],
	            isSVGContent = /.svg$/i.test(content) ? true : false;

	        this.callback = {
	            'suspendCallback': suspendCallback,
	            'successCallback': successCallback
	        };

	        //iboosk节点预编译
	        //在执行的时候节点已经存在
	        //不需要在创建
	        if (Xut.IBooks.runMode()) {
	            //找到背景节点
	            // var $element = $containsNode.find('.multilayer');
	            successCallback();
	            return;
	        }

	        //背景是否需要SVG解析
	        this.parseMaster(isSVGContent, content, function (svgContents) {
	            svgContents = (0, _option.replacePath)(svgContents);
	            //构建背景
	            var backgroundStr = (0, _layout2.default)(svgContents, data);
	            if (backgroundStr) {
	                svgContents = null;
	                self.compileSuspend($(backgroundStr), $containsNode);
	            } else {
	                successCallback();
	            }
	        });
	    }

	    _createClass(TaskBackground, [{
	        key: 'clearReference',
	        value: function clearReference() {}

	        /**
	         * 构建中断函数
	         * @param  {[type]} $background [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: 'compileSuspend',
	        value: function compileSuspend($background, $containsNode) {

	            var nextTasks,
	                suspendTasks,
	                self = this;

	            //继续执行
	            nextTasks = function nextTasks() {
	                Xut.nextTick({
	                    'container': $containsNode,
	                    'content': $background
	                }, function () {
	                    self.clearReference();
	                    self.callback.successCallback();
	                });
	            };

	            //中断方法
	            suspendTasks = function suspendTasks() {
	                self.suspendQueues = [];
	                self.suspendQueues.push(function () {
	                    nextTasks();
	                });
	            };

	            self.callback.suspendCallback(nextTasks, suspendTasks);
	        }

	        /**
	         * 运行被阻断的线程任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'runSuspendTasks',
	        value: function runSuspendTasks() {
	            if (this.suspendQueues) {
	                var fn;
	                if (fn = this.suspendQueues.pop()) {
	                    fn();
	                }
	                this.suspendQueues = null;
	            }
	        }

	        /**
	         * /解析SVG背景
	         * @param  {Boolean}  isSVGContent [description]
	         * @param  {[type]}   content      [description]
	         * @param  {Function} callback     [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: 'parseMaster',
	        value: function parseMaster(isSVGContent, content, callback) {
	            if (isSVGContent) {
	                //背景需要SVG解析的
	                (0, _option.readFile)(content, function (svgContents) {
	                    callback(svgContents);
	                });
	            } else {
	                callback('');
	            }
	        }
	    }]);

	    return TaskBackground;
	}();

	exports.default = TaskBackground;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = createBackground;

	var _index = __webpack_require__(1);

	var maskBoxImage = Xut.style.maskBoxImage;

	/**
	 * 修正尺寸
	 * @return {[type]} [description]
	 */
	var setDataSize = function setDataSize(data) {
	    //缩放比
	    var proportion = _index.config.proportion;

	    //路径
	    data.path = _index.config.pathAddress;

	    if (data.imageWidth) {
	        data.imageWidth = data.imageWidth * proportion.width;
	    }
	    if (data.imageHeight) {
	        data.imageHeight = data.imageHeight * proportion.height;
	    }
	    if (data.imageLeft) {
	        data.imageLeft = data.imageLeft * proportion.left;
	    }
	    if (data.imageTop) {
	        data.imageTop = data.imageTop * proportion.top;
	    }
	};

	/**
	 * 计算出对页排版偏移值
	 * @return {[type]} [description]
	 */
	var getOffset = function getOffset(pageSide) {
	    var background = void 0;
	    switch (Number(pageSide)) {
	        case 1:
	            background = 'background-position:0';
	            break;
	        case 2:
	            background = 'background-position:' + _index.config.screenSize.width + 'px';
	            break;
	    }
	    return background;
	};

	/**
	 * 创建分层背景图层
	 * [createMaster description]
	 * @param  {[type]} svgContent [description]
	 * @param  {[type]} data       [description]
	 * @return {[type]}            [description]
	 */
	function createBackground(svgContent, data) {

	    var imageLayer,
	        maskLayer,
	        imageLayerData = data.imageLayer,
	        //图片层
	    imageMaskData = data.imageMask,
	        //蒙版层
	    backImageData = data.backImage,
	        //真实图片层
	    backMaskData = data.backMask,
	        //真实蒙版层
	    masterData = data.master,
	        //母板
	    backText = data.md5,
	        //背景文字
	    pptMaster = data.pptMaster; //母板PPTID

	    /**
	     * 未分层结构
	     * 只有SVG数据，没有层次数据 ,不是视觉差
	     * @return {[type]}          [description]
	     */
	    if (backText && !masterData && !pptMaster && !imageLayerData) {
	        if (svgContent) {
	            return String.styleFormat('<div data-multilayer ="true"\n                      class="multilayer">\n                    ' + svgContent + '\n                </div>');
	        } else {
	            return '';
	        }
	    }

	    /**
	     * 分层结构
	     * 1 分母板 文字层 背景 蒙版
	     * 2 视觉差分层处理
	     */

	    /**
	     * 修正尺寸
	     */
	    setDataSize(data);

	    /**
	     * 母版图
	     * 如果有母板数据,如果不是视觉差
	     * @return {[type]} [description]
	     */
	    var masterHTML = '';
	    if (masterData && !pptMaster) {
	        var masterImage = data.path + masterData;
	        masterHTML = '<div class="multilayer-master"\n                  style="background-image:url(' + masterImage + ')">\n             </div>';
	    }

	    /**
	     * 存在背景图
	     * @return {[type]}
	     */
	    var maskHTML = '';
	    if (imageLayerData) {
	        //蒙版图（与背景图是组合关系）
	        var _maskLayer = data.imageMask ? maskBoxImage + ":url(" + data.path + data.imageMask + ");" : "";
	        var maskImage = data.path + imageLayerData;
	        maskHTML = '<div class="multilayer-imageLayer"\n                  style="width:' + data.imageWidth + 'px;\n                         height:' + data.imageHeight + 'px;\n                         top:' + data.imageTop + 'px;\n                         left:' + data.imageLeft + 'px;\n                         background-image:url(' + maskImage + ');' + _maskLayer + '">\n            </div>';
	    }

	    /**
	     * 新增的 真实背景图 默认全屏
	     * @return {[type]
	     */
	    var backImageHTML = '';
	    if (backImageData) {
	        //计算出对页排版偏移值
	        var backImageOffset = getOffset(data.pageSide);
	        var backImagePosition = backImageOffset ? backImageOffset : '';
	        var newWidth = backImageOffset ? '200%' : '100%';
	        var newBackImage = data.path + backImageData;
	        var newBackMask = data.path + backMaskData;
	        if (backMaskData) {
	            //带蒙版
	            if (maskBoxImage != undefined) {
	                backImageHTML = '<div class="multilayer-backImage"\n                          style="width:' + newWidth + ';\n                                 background-image:url(' + newBackImage + ');\n                                 ' + maskBoxImage + ':url(' + newBackMask + ');\n                                 ' + backImagePosition + '">\n                    </div>';
	            } else {
	                //无蒙版
	                backImageHTML = '<canvas class="multilayer-backImage edges"\n                             height=' + document.body.clientHeight + '\n                             width=' + document.body.clientWidth + '\n                             src=' + newBackImage + '\n                             mask=' + newBackMask + '\n                             style="width:' + newWidth + ';\n                                    opacity:0;\n                                    ' + maskBoxImage + ':url(' + newBackImage + ');\n                                    ' + backImagePosition + '">\n                    </canvas>';
	            }
	        } else {
	            //图片层
	            backImageHTML = '<div class="multilayer-backImage"\n                                  style="width:' + newWidth + ';\n                                         background-image:url(' + newBackImage + ');\n                                         ' + backImagePosition + '">\n                            </div>';
	        }
	    }

	    /**
	     * 存在svg文字
	     * @return {[type]}
	     */
	    var backTextHTML = '';
	    if (backText) {
	        backTextHTML = '<div class="multilayer-word">\n                            ' + svgContent + '\n                        </div>';
	    }

	    /**
	     * 组层背景图开始
	     * @type {String}
	     */
	    return String.styleFormat('<div data-multilayer ="true"\n              class="multilayer">\n            ' + masterHTML + '\n            ' + maskHTML + '\n            ' + backImageHTML + '\n            ' + backTextHTML + '\n        </div>');
	}

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (pid, callback) {
	    var fn = void 0,
	        base = this,
	        pageType = base.pageType;

	    //缓存数据
	    var addCacheDas = function addCacheDas(namespace, data) {
	        var key = void 0;
	        if (!base._dataCache[namespace]) {
	            base._dataCache[namespace] = data;
	        } else {
	            for (key in data) {
	                base._dataCache[namespace][key] = data[key];
	            }
	        }
	    };

	    //增加数据缓存
	    var addCache = function addCache(data, activitys, autoData) {
	        addCacheDas(base.pageType, data); //挂载页面容器数据
	        addCacheDas('activitys', activitys); //挂载activitys数据
	        addCacheDas('auto', autoData); //挂载自动运行数据
	    };

	    (0, _query.query)(pageType, {
	        'pageIndex': pid,
	        'pageData': base.chapterData,
	        'pptMaster': base.pptMaster
	    }, function (data, activitys, autoData) {
	        addCache.apply(addCache, arguments);
	        callback(data);
	    });
	};

	var _query = __webpack_require__(29);

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = TaskComponents;

	var _index = __webpack_require__(22);

	var _index2 = _interopRequireDefault(_index);

	var _option = __webpack_require__(11);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 *  创建widgets对象任务片
	 *  state状态
	 *      0 未创建
	 *      1 正常创建
	 *      2 创建完毕
	 *      3 创建失败
	 */
	function TaskComponents(data, suspendCallback, successCallback) {

	    //预编译模式跳过创建
	    if (Xut.IBooks.runMode()) {
	        successCallback();
	        return;
	    }

	    if (data['activitys'].length) {
	        var str;
	        this.$containsNode = data['$containsNode'];
	        this.callback = {
	            'suspendCallback': suspendCallback,
	            'successCallback': successCallback
	        };
	        str = this.create(data);
	        this.compileSuspend(str);
	    } else {
	        successCallback();
	    }
	}

	TaskComponents.prototype = {

	    clearReference: function clearReference() {
	        this.$containsNode = null;
	    },

	    create: function create(data) {
	        var actType,
	            pageType = data.pageType,
	            createWidgets = data.activitys,
	            chpaterData = data.chpaterData,
	            chapterId = data.chapterId,
	            pid = data.pid,
	            virtualOffset = data.virtualOffset,
	            widgetRetStr = [];

	        //创建
	        function startCreate(actType, activityData) {
	            //创建DOM元素结构
	            //返回是拼接字符串
	            widgetRetStr.push(_index2.default[actType]['createDom'](activityData, chpaterData, chapterId, pid, Xut.zIndexlevel(), pageType));
	        }

	        //需要创建的数据结构
	        createWidgets.forEach(function (activityData, index) {

	            //创建类型
	            actType = activityData.actType || activityData.animation;

	            //特殊类型 showNote
	            if (!actType && activityData.note) {
	                activityData['actType'] = actType = "ShowNote";
	            }

	            switch (actType) {
	                case 'ShowNote':
	                case 'Action':
	                case 'Widget':
	                case 'Audio':
	                case 'Video':

	                    //缩放比
	                    activityData = (0, _option.reviseSize)(activityData);

	                    startCreate(actType, activityData);
	                    break;
	            }
	        });

	        return widgetRetStr.join("");
	    },

	    /**
	     * 编译中断函数
	     * @return {[type]} [description]
	     */
	    compileSuspend: function compileSuspend(str) {

	        var nextTasks,
	            suspendTasks,
	            self = this;

	        //继续执行
	        nextTasks = function nextTasks() {
	            Xut.nextTick({
	                container: self.$containsNode,
	                content: $(str)
	            }, function () {
	                self.clearReference();
	                self.callback.successCallback();
	            });
	        };

	        //中断方法
	        suspendTasks = function suspendTasks() {
	            self.suspendQueues = [];
	            self.suspendQueues.push(function () {
	                nextTasks();
	            });
	        };

	        self.callback.suspendCallback(nextTasks, suspendTasks);
	    },

	    //运行被阻断的线程任务
	    runSuspendTasks: function runSuspendTasks() {
	        if (this.suspendQueues) {
	            var fn;
	            if (fn = this.suspendQueues.pop()) {
	                fn();
	            }
	            this.suspendQueues = null;
	        }
	    }
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (base, pageData, taskCallback) {

	    var $pageNode = void 0;
	    var $pseudoElement = void 0;

	    var prefix = base.pageType + "-" + (base.pageIndex + 1) + "-" + base.chapterId;
	    var getStyle = base.getStyle;

	    //iboosk编译
	    //在执行的时候节点已经存在
	    //不需要在创建
	    if (Xut.IBooks.runMode()) {
	        $pageNode = $("#" + prefix);
	        taskCallback($pageNode, $pseudoElement);
	        return;
	    }

	    //创建的flip结构体
	    $pageNode = createContainer(base, pageData, getStyle, prefix);

	    Xut.nextTick({
	        container: base.rootNode,
	        content: $pageNode,
	        position: getStyle.direction === 'before' ? 'first' : 'last'
	    }, function () {
	        taskCallback($pageNode, $pseudoElement);
	    });
	};

	var _index = __webpack_require__(1);

	var _lang = __webpack_require__(3);

	/**
	 *  创建主容器任务片
	 *  state状态
	 *      0 未创建
	 *      1 正常创建
	 *      2 创建完毕
	 *      3 创建失败
	 */
	var TANSFROM = Xut.style.transform;

	/**
	 * 创建页面容器li
	 */
	var createli = function createli() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        base = _ref.base,
	        prefix = _ref.prefix,
	        translate = _ref.translate,
	        customStyle = _ref.customStyle,
	        pageData = _ref.pageData,
	        background = _ref.background;

	    var getStyle = base.getStyle;

	    return String.styleFormat('<li id="' + prefix + '"\n            data-id="' + pageData._id + '"\n            data-map="' + base.pid + '"\n            data-pageType="' + base.pageType + '"\n            data-container="true"\n            class="xut-flip fix-transform"\n            style="width:' + getStyle.viewWidth + 'px;\n                   height:' + getStyle.viewHeight + 'px;\n                   left:' + getStyle.viewLeft + 'px;\n                   top:' + getStyle.viewTop + 'px;\n                   ' + TANSFROM + ':' + translate + ';\n                   ' + background + '\n                   ' + customStyle + '\n                   overflow:hidden;">\n            <div class="page-pinch"></div>\n        </li>');
	};

	/**
	 * 创建父容器li结构
	 */
	var createContainer = function createContainer(base, pageData, getStyle, prefix) {

	    var background = '';

	    //chpater有背景，不是svg格式
	    if (!/.svg$/i.test(pageData.md5)) {
	        background = 'background-image:url(' + _index.config.pathAddress + pageData.md5 + ');';
	    }

	    /**
	     * 自定义配置了样式
	     * 因为单页面跳槽层级的问题处理
	     */
	    var customStyle = '';
	    var userStyle = getStyle.userStyle;
	    if (userStyle !== undefined) {
	        //解析自定义规则
	        _.each(userStyle, function (value, key) {
	            customStyle += key + ':' + value + ';';
	        });
	    }

	    return $(createli({
	        base: base,
	        prefix: prefix,
	        translate: getStyle.translate,
	        customStyle: customStyle,
	        pageData: pageData,
	        background: background
	    }));
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.activityParser = activityParser;
	exports.contentParser = contentParser;

	var _index = __webpack_require__(2);

	//零件类型,快速判断
	//新增content卷滚区域,所有JS零件content
	//类型选择,content有扩充的子类型
	//针对零件类型在category字段中的子分类
	var widgetType = {}; /********************************************************
	                      *
	                      *  数据过滤,去重算法
	                      *  content数据解析息息相关的方法
	                      *
	                      *======================================================*/

	_.each("jsWidget content svgWidget canvasWidget path".split(" "), function (key, name) {
	    widgetType[key] = true;
	});

	/**
	 * 类型统一
	 * @param  {[type]} activity [description]
	 * @return {[type]}          [description]
	 */
	function unifyType(activity) {
	    //满足条件统一为零件类型
	    return widgetType[activity.category] ? "JsWidget" : activity.actType;
	}

	/**
	 * 创建事件容器
	 * @param  {[type]} eventId [description]
	 * @return {[type]}         [description]
	 */
	function createEventContainer(relateds, eventId) {
	    if (!relateds.seasonRelated[eventId]) {
	        relateds.seasonRelated[eventId] = {};
	    }
	}

	/**
	 * 配合出item中相关信息
	 * 1.场景信息
	 * 2.收费信息
	 * @param  {[type]} tokens [description]
	 * @return {[type]}        [description]
	 */
	function adapterItemArrayRelated(relateds, activitys, tokens) {
	    //如果分解出节信息
	    var seasonId,
	        inAppValue,
	        chapterId,
	        values,
	        eventId = activitys.imageId;

	    _.each(['seasonId', 'Inapp', 'SearchBar', 'BookMarks'], function (type) {
	        values = tokens[type];
	        //如果有值
	        if (values !== undefined) {
	            //创建容器
	            createEventContainer(relateds, eventId);
	            switch (type) {
	                //跳转新场景信息
	                case 'seasonId':
	                    chapterId = tokens['chapterId'] || tokens['chapter'];
	                    relateds.seasonRelated[eventId] = {
	                        seasonId: values[0],
	                        chapterId: chapterId ? chapterId[0] : ''
	                    };
	                    break;
	                //收费信息,给事件上绑定收费接口
	                //0 收费 1 已收费
	                case 'Inapp':
	                    relateds.seasonRelated[eventId]['Inapp'] = values[0];
	                    break;
	                default:
	                    //搜索栏
	                    //书签
	                    relateds.seasonRelated[eventId][type] = eventId;
	                    break;
	            }
	        }
	    });
	}

	/**************************************************************************
	 *
	 *      分组Content表中对应的多个Conte
	 *      1：Animation表
	 *      2: Parallax表
	 *      3: seed种子合集 就是解析1：Animation表，Parallax表得到的数据
	 *
	 ****************************************************************************/
	function resolveContentToActivity(callback, activity, pageType, pid) {
	    var animContentIds,
	        paraContentIds,
	        parallaxRelated,
	        parallaxDas,
	        animRelated,
	        animationDas = '',
	        eventId = activity.imageId,

	    //需要分解的contentIds合集
	    // 1 动画表数据      Animation
	    // 2 视觉差数据     Parallax
	    // 3 超链接            seasonId
	    // 4 收费         Inapp
	    tokens = tokenize(activity['itemArray']) || [],

	    //解析Animations,Parallaxs数据
	    //  seed {
	    //      Animation:[data,Ids]
	    //      Parallax:[data,Ids]
	    //  }
	    seed = callback(tokens),


	    //判断类型
	    type = Object.keys(seed)[0];

	    /**
	     * 去重事件ID
	     * original  原ID合集
	     * detection 需要检测去重的ID
	     *
	     */
	    function toRepeatContents(original) {
	        if (original && eventId) {
	            var indexOf = original.indexOf(eventId);
	            if (-1 !== indexOf) {
	                original.splice(indexOf, 1);
	            }
	        }
	    }

	    switch (type) {
	        //容器
	        case 'Container':
	            animContentIds = seed.Container;
	            toRepeatContents(animContentIds);
	            break;
	        //多事件处理
	        case 'Contents':
	            return seed.Contents;
	        default:
	            /**
	             * 如果是对象处理，
	             * 针对动画表，视觉差表,行为的处理
	             */
	            //需要创建的content合集
	            if (_.keys(seed).length) {
	                animRelated = seed.Animation;
	                parallaxRelated = seed.Parallax;
	                //页面模式
	                if (pageType === 'page') {
	                    if (animRelated) {
	                        animContentIds = animRelated.ids;
	                        animationDas = animRelated.das;
	                    }
	                } else {
	                    //视觉差存在视觉差表处理
	                    // console.log(1111,animRelated, parallaxRelated)
	                    //母版的动画数据
	                    if (animRelated) {
	                        animContentIds = animRelated.ids;
	                        animationDas = animRelated.das;
	                    }
	                    //母版的视察数据
	                    if (parallaxRelated) {
	                        paraContentIds = parallaxRelated.ids;
	                        parallaxDas = parallaxRelated.das;
	                    }
	                }

	                //如果id都存在
	                //合并
	                if (animContentIds && paraContentIds) {
	                    animContentIds = animContentIds.concat(paraContentIds);
	                }

	                //只存在视察
	                if (!animContentIds && paraContentIds) {
	                    animContentIds = paraContentIds;
	                }
	                toRepeatContents(animContentIds);
	            }
	            break;
	    }

	    //创建对象是层次关系
	    return {
	        'pageType': pageType,
	        'activity': activity,
	        'imageIds': eventId,
	        //data
	        'seed': {
	            'animation': animationDas,
	            'parallax': parallaxDas
	        },
	        //id
	        'ids': {
	            'content': animContentIds,
	            'parallax': paraContentIds
	        }
	    };
	}

	/************************************************************************
	 *
	 *     合并,过滤需要处理的content
	 *     combineImageIds  可以创建的imageId合集，也就是content的合集,用来绑定自定义事件
	 *     createContentIds 可以创建的content合集,过滤合并重复
	 *
	 * **********************************************************************/
	function toRepeatCombineGroup(compilerActivitys, mixFilterRelated, pageType) {
	    var ids,
	        contentIds,
	        needCreateContentIds,
	        imageIds,
	        activityRelated,
	        parallaxId,
	        combineItemIds = [],
	        combineImageIds = [],
	        i = compilerActivitys.length;

	    function pushCache(target, original, callback) {
	        var id,
	            i = original.length;
	        while (i--) {
	            id = Number(original[i]);
	            target.push(id);
	            callback && callback(id);
	        }
	    }

	    while (i--) {
	        //开始执行过滤操作
	        activityRelated = compilerActivitys[i];
	        ids = activityRelated.ids;
	        contentIds = ids.content;
	        parallaxId = ids.parallax; //浮动类型的对象
	        imageIds = activityRelated.imageIds;

	        //针对普通content对象
	        if (contentIds && contentIds.length) {
	            //如果不为空
	            pushCache(combineItemIds, contentIds);
	        }

	        //视察对象
	        if (parallaxId && parallaxId.length) {
	            //如果不为空
	            pushCache(combineItemIds, parallaxId);
	        }

	        //事件合集
	        if (imageIds) {
	            combineImageIds.push(Number(imageIds));
	        }
	    }

	    //混入外部合并了逻辑
	    if (mixFilterRelated && mixFilterRelated.length) {
	        _.each(mixFilterRelated, function (data) {
	            if (data) {
	                combineItemIds = combineItemIds.concat(data);
	            }
	        });
	    }

	    //过滤合并多个content数据
	    if (combineImageIds.length) {
	        needCreateContentIds = (0, _index.arrayUnique)(combineItemIds.concat(combineImageIds));
	    } else {
	        needCreateContentIds = (0, _index.arrayUnique)(combineItemIds);
	    }

	    //排序
	    needCreateContentIds = needCreateContentIds.sort(function (a, b) {
	        return a - b;
	    });

	    /**
	     * 合并创建信息
	     * 需要创建的事件
	     * 需要创建的所有对象
	     */
	    return [combineImageIds, needCreateContentIds];
	}

	/**
	 * 解析指定类型数据
	 * strengthenAnmin 视觉差增强动画表
	 * @return {[type]}
	 */
	function parseTypeRelation(tableName, tokenIds) {
	    var tokenId;
	    var itemData = {};
	    _.each(tableName, function (tName) {
	        if (tokenId = tokenIds[tName]) {
	            if (itemData[tName]) {
	                console.log('未处理解析同一个表');
	            } else {
	                itemData[tName] = inGroup(tName, tokenId);
	            }
	        }
	    });
	    return itemData;
	}

	/**
	 * 分组
	 * @return {[type]} [description]
	 */
	function inGroup(tableName, contentIds) {
	    var k,
	        keyName,
	        data,
	        contentId,
	        temp = {},
	        das = [],
	        ids = [],
	        query = Xut.data.query;

	    _.each(contentIds, function (id) {
	        if (data = query(tableName, id)) {
	            contentId = data.contentId;
	            if (-1 === ids.indexOf(contentId)) {
	                ids.push(contentId);
	            }
	            //合并同个contentId多条动画数据的情况
	            keyName = "contentId-" + contentId;
	            if (temp[keyName]) {
	                temp[keyName].push(data);
	            } else {
	                temp[keyName] = [data];
	            }
	        }
	    });

	    //转成数组格式
	    for (k in temp) {
	        das.push(temp[k]);
	    }

	    return {
	        das: das,
	        ids: ids
	    };
	}

	//解析itemArray序列,得到对应的id
	function tokenize(itemArray) {
	    var itemJson,
	        actType,
	        anmins = {};
	    if (!itemArray) return;
	    itemJson = (0, _index.parseJSON)(itemArray);
	    //解析多个参数
	    if (itemJson.length) {
	        _.each(itemJson, function (opts) {
	            actType = opts.actType;
	            if (!anmins[actType]) {
	                anmins[actType] = [];
	            }
	            anmins[actType].push(opts.id);
	        });
	    } else {
	        actType = itemJson.actType;
	        anmins[actType] = [];
	        //actType: "Animation", id: 14
	        //actType: "Inapp", value: 0
	        anmins[actType].push(itemJson.id || itemJson.value);
	    }
	    return anmins;
	}

	/**
	 * 解析出需要构建的content对象
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	function activityParser(activityData) {
	    var actType = void 0;
	    var compileContent = [];

	    //需要创建的数据结构
	    _.each(activityData.activitys, function (activityData) {
	        actType = activityData.actType || activityData.animation;
	        //特殊类型 showNote
	        if (!actType && activityData.note) {
	            activityData['actType'] = actType = "ShowNote";
	        }
	        //匹配content处理相关类型
	        if (activityData.itemArray || activityData.autoPlay !== 2) {
	            switch (actType) {
	                case 'Container':
	                case 'Content':
	                case 'Parallax':
	                case 'Contents':
	                    compileContent.push(activityData);
	                    break;
	            }
	        }
	    });

	    return compileContent;
	}

	/**
	 * 解析解析每一条 Activitys 对应的数据结构
	 * @param  {[type]} compileActivitys [description]
	 * @param  {[type]} data             [description]
	 * @return {[type]}                  [description]
	 */
	function contentParser(compileActivitys, data) {

	    var activitys,
	        hookType,
	        resultsActivitys,
	        //结果结合
	    i = compileActivitys.length,
	        pageType = data.pageType,
	        pid = data.pid,


	    /**
	     * 相关数据合集
	     * @type {Object}
	     */
	    activityRelated = [],
	        //Activit合集相关数据信息
	    tempRelated = [],
	        //临时数据

	    /**
	     * 解析出来的相关信息
	     * @type {Object}
	     */
	    relateds = {
	        seasonRelated: {}, //节信息
	        containerRelated: [], //容器合集相关数据信息
	        eventRelated: {}, //多事件容器合集
	        partContentRelated: [] //卷滚conten只创建,不处理行为
	    };

	    /**
	     * 创建解析
	     * @param  {Function} callback [description]
	     * @return {[type]}            [description]
	     */
	    var createResolve = function createResolve(callback) {
	        return resolveContentToActivity(function (tokens) {
	            return callback(tokens);
	        }, activitys, pageType, pid);
	    };

	    /**
	     * 类型处理器
	     * 除去动画的其余处理类型
	     * @type {Object}
	     */
	    var hookResolve = {

	        /**
	         * 单独处理容器类型
	         * @param  {[type]} relateds [description]
	         * @return {[type]}          [description]
	         */
	        Container: function Container() {
	            relateds.containerRelated.push(createResolve(function (tokens) {
	                return {
	                    'Container': tokens['Content']
	                };
	            }));
	        },


	        /**
	         * 多事件
	         * @param  {[type]} relateds [description]
	         * @return {[type]}          [description]
	         */
	        Contents: function Contents() {
	            var item;
	            if (item = createResolve(function (tokens) {
	                return {
	                    'Contents': [tokens]
	                };
	            })[0]) {
	                //给content注册多个绑定事件
	                var eventId = activitys.imageId;
	                var eventData = {
	                    'eventContentId': eventId,
	                    'activityId': activitys._id,
	                    'registers': item['activity'],
	                    'eventType': activitys.eventType,
	                    'dragdropPara': activitys.para1 //拖拽对象
	                };
	                var isEvt = relateds.eventRelated['eventContentId->' + eventId];
	                if (isEvt) {
	                    isEvt.push(eventData);
	                } else {
	                    relateds.eventRelated['eventContentId->' + eventId] = [eventData];
	                }
	            }
	        },


	        /**
	         * 所有js零件
	         * @param  {[type]} relateds [description]
	         * @return {[type]}          [description]
	         */
	        JsWidget: function JsWidget() {
	            var scrollContents = (0, _index.parseJSON)(activitys.itemArray);
	            if (_.isArray(scrollContents)) {
	                _.each(scrollContents, function (data) {
	                    relateds.partContentRelated.push(data.id);
	                });
	            } else {
	                relateds.partContentRelated.push(scrollContents.id);
	            }
	        }
	    };

	    /**
	     * 解析出当前页面的所有的Activit表
	     * 1个chpater页面 可以对应多个Activit表中的数据
	     * 1 Container 容器类型
	     * 2 page 类型
	     * 3 parallax 类型
	     * 4 Scenario 类型
	     * 5 content合集 contents处理
	     */
	    while (activitys = compileActivitys.shift()) {
	        //统一类型
	        hookType = unifyType(activitys);
	        if (!hookResolve[hookType] //类型匹配
	        || hookResolve[hookType] && hookResolve[hookType](relateds)) {
	            //钩子事件
	            //如果是动画表,视觉差表关联的content类型
	            resultsActivitys = createResolve(function (tokens) {
	                //解析itemArray字段中的相关的信息
	                adapterItemArrayRelated(relateds, activitys, tokens);
	                if (pageType === 'page') {
	                    //页面只有动画
	                    return parseTypeRelation(['Animation'], tokens);
	                } else if (pageType === 'master') {
	                    //新增第三个参数，
	                    //视觉差支持所有content动画
	                    return parseTypeRelation(['Animation', 'Parallax'], tokens);
	                }
	            });

	            //如果有手动触发器,置于最后
	            if (activitys.imageId) {
	                tempRelated.push(resultsActivitys);
	            } else {
	                activityRelated.push(resultsActivitys);
	            }

	            resultsActivitys = null;
	        }
	    }

	    //合并排序
	    if (tempRelated.length) {
	        activityRelated = activityRelated.concat(tempRelated);
	        tempRelated = null;
	    }

	    /**
	     *  过滤出与创建相关的content合集ID
	     *      createEventIds  主content列表 (用来绑定eventType事件)
	     *      createContentIds 合并所有content操作后,过滤掉重复的content,得到可以创建的content的ID合集
	     */
	    var createRelevant = toRepeatCombineGroup(activityRelated, relateds.partContentRelated, pageType);
	    var createEventIds = createRelevant[0];
	    var createContentIds = createRelevant[1];

	    //如果存在过滤器
	    if (Xut.CreateFilter.size()) {
	        var filterEach = Xut.CreateFilter.each(data.chapterId);
	        if (filterEach) {
	            filterEach(createEventIds, function (indexOf) {
	                createEventIds.splice(indexOf, 1);
	            });
	            filterEach(createContentIds, function (indexOf) {
	                createContentIds.splice(indexOf, 1);
	            });
	            filterEach = null;
	        }
	    }

	    return _.extend(data, relateds, {
	        'createEventIds': createEventIds, //事件ID数
	        'createContentIds': createContentIds, //创建的content总ID数
	        'createActivitys': activityRelated
	    });
	}

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /****************************************************
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *           构建TaskContents对象
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      依赖数据解析算法类 Algorithm
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      结构合并创建类    Structure
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      行为动画绑定类     Content
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ***************************************************/

	var _index = __webpack_require__(137);

	var _index2 = _interopRequireDefault(_index);

	var _index3 = __webpack_require__(70);

	var _index4 = _interopRequireDefault(_index3);

	var _data = __webpack_require__(132);

	var _index5 = __webpack_require__(2);

	var _nexttick = __webpack_require__(44);

	var _nexttick2 = _interopRequireDefault(_nexttick);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TRANSFORM = Xut.style.transform;

	function createFn(obj, id, callback) {
	    var cObj = obj[id];
	    if (!cObj) {
	        cObj = obj[id] = {};
	    }
	    callback.call(cObj);
	}

	/**
	 * 转成数组格式
	 * @param  {[type]} contentsFragment [description]
	 * @return {[type]}                  [description]
	 */
	function toArray(o) {
	    var contentsFragment = [];
	    _.each(o, function ($node) {
	        contentsFragment.push($node);
	    });
	    return contentsFragment;
	}

	/**
	 * 构建快速查询节点对象
	 * 转成哈希方式
	 * @return {[type]} [description]
	 */
	function toObject(cachedContentStr) {
	    var tempFragmentHash = {};
	    _.each($(cachedContentStr), function (ele, index) {
	        tempFragmentHash[ele.id] = ele;
	    });
	    return tempFragmentHash;
	}

	/**
	 * 行为反馈
	 *  content id = {
	 *      弹动
	 *      音频URl
	 *  }
	 */
	function addBehavior(data) {
	    var parameter,
	        soundSrc,
	        contentId,
	        isButton,
	        feedbackBehavior = data.feedbackBehavior = {};
	    _.each(data.activitys, function (activitys) {
	        if (activitys.parameter && (parameter = (0, _index5.parseJSON)(activitys.parameter))) {
	            contentId = activitys.imageId;
	            //视觉反馈
	            if (isButton = parameter['isButton']) {
	                if (isButton != 0) {
	                    //过滤数据的字符串类型
	                    createFn(feedbackBehavior, contentId, function () {
	                        this['isButton'] = true;
	                    });
	                }
	            }
	            //音频行为
	            if (soundSrc = parameter['behaviorSound']) {
	                if (soundSrc != 0) {
	                    createFn(feedbackBehavior, contentId, function () {
	                        this['behaviorSound'] = soundSrc;
	                    });
	                }
	            }
	        }
	    });
	}

	/**
	 *创建浮动相关的信息
	 * @return {[type]} [description]
	 */
	function crateFloat(callback, floatName, dasFloat, data, base) {

	    var $containsNodes = [];
	    var prefix = 'Content_' + data.pid + "_";

	    //去重复
	    dasFloat.ids = (0, _index5.arrayUnique)(dasFloat.ids);

	    var makePrefix,
	        fragment,
	        zIndex,
	        zIndexs = dasFloat.zIndex;

	    data.count++;

	    //分离出浮动节点
	    _.each(dasFloat.ids, function (id) {
	        makePrefix = prefix + id;
	        if (fragment = data.contentsFragment[makePrefix]) {
	            zIndex = zIndexs[id];
	            //保证层级关系
	            // fragment.style.zIndex = (Number(zIndex) + Number(fragment.style.zIndex)) 
	            $containsNodes.push(fragment);
	            delete data.contentsFragment[makePrefix];
	        }
	    });

	    //floatPages模式下面
	    //如果是当前页面
	    //因为会产生三页面并联
	    //所以中间去最高层级
	    if (floatName === 'floatPages' && data.getStyle.offset === 0) {
	        zIndex = 2001;
	    } else {
	        zIndex = 2000;
	    }

	    //浮动根节点
	    //floatPages设置的content溢出后处理
	    //在非视区增加overflow:hidden
	    //可视区域overflow:''
	    var overflow = 'overflow:hidden;';
	    //如果是母板,排除
	    if (floatName === 'floatMaters') {
	        overflow = '';
	    }

	    var floatStr = String.format('<div id="' + floatName + '-li-{0}" class="xut-float" style="' + TRANSFORM + ':{1};z-index:' + zIndex + ';{2}"></div>', data.pid, data.getStyle.translate, overflow);

	    var container = $(floatStr);

	    //增加浮动容器
	    $(data.rootNode).after(container);

	    callback($containsNodes, container);
	}

	/**
	 * 创建浮动母版对象
	 * @return {[type]} [description]
	 */
	function createFloatMater(base, data, complete) {
	    //创建浮动对象
	    crateFloat(function ($containsNodes, container) {
	        //浮动容器
	        data.floatMaters.container = container;

	        (0, _nexttick2.default)({
	            'container': container,
	            'content': $containsNodes
	        }, function () {
	            //收集浮动母版对象标识
	            base.pageBaseHooks.floatMaters(data.floatMaters);
	            complete(data);
	        });
	    }, 'floatMaters', data.floatMaters, data, base);
	}

	/**
	 * 创建浮动的页面对象
	 */
	function createFloatPage(base, data, complete) {
	    //创建浮动对象
	    crateFloat(function ($containsNodes, container) {
	        //浮动容器
	        data.floatPages.container = container;
	        (0, _nexttick2.default)({
	            'container': container,
	            'content': $containsNodes
	        }, function () {
	            //收集浮动母版对象标识
	            base.pageBaseHooks.floatPages(data.floatPages);
	            complete(data);
	        });
	    }, 'floatPages', data.floatPages, data, base);
	}

	/** 配置ID
	 * @return {[type]} [description]
	 */
	function autoUUID() {
	    return 'autoRun-' + Math.random().toString(36).substring(2, 15);
	}

	/**
	 * 给所有content节点绑定对应的事件与动画
	 * 1 动画
	 * 2 事件
	 * 3 视觉差
	 * 4 动画音频
	 * 5 canvas动画
	 * @return {[type]} [description]
	 */
	function bindActivitys(data, contentDas, callback) {
	    var compiler,
	        $containsNode = data.$containsNode,
	        eventRelated = data.eventRelated,
	        //合集事件
	    pid = data.pid,
	        createActivitys = data.createActivitys,
	        feedbackBehavior = data.feedbackBehavior,
	        //反馈数据,跟事件相关
	    pageBaseHooks = data.pageBaseHooks,
	        pageId = data.chapterId;

	    //如果有浮动对象,才需要计算偏移量
	    //母版里面可能存在浮动或者不浮动的对象
	    //那么在布局的时候想对点不一样
	    //如果在浮动区域就取浮动初始值
	    //否则就是默认的想对点0
	    var getTransformOffset = function (ids, initTransformOffset) {
	        return function (id) {
	            //匹配是不是属于浮动对象
	            if (ids.length && ids[id]) {
	                //初始化容器布局的坐标
	                return initTransformOffset;
	            }
	            return 0;
	        };
	    }(data.floatMaters.ids, data.getStyle.offset);

	    //相关回调
	    var relatedCallback = {

	        /**
	         * 绑定卷滚条钩子
	         */
	        'iscrollHooks': [],

	        /**
	         * contetn钩子回调
	         */
	        'contentsHooks': pageBaseHooks.contents,

	        /**
	         * 收集滑动事件
	         * 针对mini
	         * 2016.11.8
	         */
	        'swipeDelegateContents': pageBaseHooks.swipeDelegateContents
	    };

	    //相关数据
	    var relatedData = {
	        'floatMaters': data.floatMaters,
	        'seasonId': data.chpaterData.seasonId,
	        'pageId': pageId,
	        'contentDas': contentDas, //所有的content数据合集
	        'container': data.liRootNode,
	        'seasonRelated': data.seasonRelated,
	        'containerPrefix': data.containerPrefix,
	        'nodes': data.nodes,
	        'pageOffset': data.pageOffset,
	        'createContentIds': data.createContentIds,
	        'partContentRelated': data.partContentRelated,
	        'getTransformOffset': getTransformOffset,
	        'contentsFragment': data.contentsFragment,
	        'contentHtmlBoxIds': data.contentHtmlBoxIds
	    };

	    /**
	     * 继续下一个任务
	     * @return {[type]} [description]
	     */
	    var nextTask = function nextTask() {
	        //多事件合集处理pagebase
	        if (eventRelated) {
	            pageBaseHooks.eventBinding && pageBaseHooks.eventBinding(eventRelated);
	        }
	        //删除钩子
	        delete relatedCallback.contentsHooks;
	        callback(relatedCallback);
	    };

	    /**
	     * 生成activty控制对象
	     * @type {[type]}
	     */
	    var makeActivitys = function makeActivitys(compiler) {
	        return function (callback) {
	            var filters;
	            var imageId = compiler['imageIds']; //父id
	            var activity = compiler['activity'];
	            var eventType = activity.eventType;
	            var dragdropPara = activity.para1;
	            var eventContentId = imageId;

	            /**
	             * 多事件数据过滤
	             * 为了防止数据写入错误数据
	             * 如果当前对象上有多事件的行为
	             * 则默认的事件去掉
	             * @type {[type]}
	             */
	            if (filters = eventRelated['eventContentId->' + imageId]) {
	                _.each(filters, function (edata) {
	                    //id不需要
	                    //eventContentId = void 0;
	                    if (edata.eventType == activity.eventType) {
	                        //写入的是伪数据,此行为让多事件抽象接管
	                        eventType = dragdropPara = undefined;
	                    }
	                });
	            }

	            //需要绑定事件的数据
	            var eventData = {
	                'eventContentId': eventContentId,
	                'eventType': eventType,
	                'dragdropPara': dragdropPara,
	                'feedbackBehavior': feedbackBehavior
	            };

	            var actdata = {
	                'noticeComplete': callback, //监听完成
	                'pageIndex': data.pageIndex,
	                'canvasRelated': data.canvasRelated, //父类引用
	                'id': imageId || autoUUID(),
	                "type": 'Content',
	                'pageId': pageId,
	                'activityId': activity._id,
	                '$containsNode': $containsNode,
	                'pageType': compiler['pageType'], //构建类型 page/master
	                'seed': compiler['seed'], //动画表数据 or 视觉差表数据
	                "pid": pid, //页码
	                'eventData': eventData, //事件数据
	                'relatedData': relatedData, //相关数据,所有子作用域Activity对象共享
	                'relatedCallback': relatedCallback //相关回调
	            };

	            //注册引用
	            pageBaseHooks.registerActivitys(new _index4.default(actdata));
	        };
	    };

	    //制作curry Activity闭包
	    var fnsActivity = [];
	    while (compiler = createActivitys.shift()) {
	        fnsActivity.push(makeActivitys(compiler));
	    }

	    // 递归解析 activitys
	    var recursiveParse = function recursiveParse() {
	        if (!fnsActivity.length) {
	            nextTask();
	            return;
	        }
	        var first = fnsActivity.shift();
	        first(function () {
	            recursiveParse();
	        });
	    };
	    recursiveParse();
	}

	/**
	 * content任务类
	 */

	var TaskContents = function () {
	    function TaskContents(activityData) {
	        _classCallCheck(this, TaskContents);

	        _.extend(this, activityData);

	        //只解析content有关的activityData
	        var compileActivitys = (0, _data.activityParser)(activityData);

	        //如果有预执行动作
	        //Activity表数据存在
	        if (compileActivitys) {
	            //解析动画表数据结构
	            activityData = (0, _data.contentParser)(compileActivitys, activityData);

	            //如果有需要构建的content
	            //开始多线程处理
	            activityData.createContentIds.length ? this._dataAfterCheck(activityData) : this._loadComplete();
	        } else {
	            this._loadComplete();
	        }
	    }

	    /**
	     * 构建完毕
	     * @return {[type]} [description]
	     */


	    _createClass(TaskContents, [{
	        key: '_loadComplete',
	        value: function _loadComplete() {
	            this.pageBaseHooks.success();
	        }

	        /**
	         * 任务断言
	         */

	    }, {
	        key: '_assert',
	        value: function _assert(taskName, tasks) {

	            var self = this;

	            //中断方法
	            var suspendTasks = function suspendTasks() {
	                self.suspendQueues = [];
	                self.suspendQueues.push(function () {
	                    tasks.call(self);
	                });
	            };

	            //完成方法
	            var nextTasks = function nextTasks() {
	                tasks.call(self);
	            };

	            self.pageBaseHooks.suspend(taskName, nextTasks, suspendTasks);
	        }

	        /**
	         * 中断一:构建数据之后
	         * @param  {[type]} data [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: '_dataAfterCheck',
	        value: function _dataAfterCheck(data) {

	            this._assert('dataAfter', function () {
	                var _this = this;

	                //浮动模板
	                //用于实现模板上的事件
	                data.floatMaters = {
	                    'ids': [], //浮动id
	                    'container': {}, //浮动容器
	                    'zIndex': {}
	                };

	                //浮动页面
	                //母板事件引起的层级遮挡问题
	                //用于提升最高
	                data.floatPages = {
	                    'ids': [],
	                    'zIndex': {}
	                };

	                //增加点击行为反馈
	                addBehavior(data);

	                //构建页面content类型结构
	                //contentDas, contentStr, containerPrefix, idFix, contentHtmlBoxIds
	                (0, _index2.default)(function (userData) {

	                    data.contentHtmlBoxIds = userData.contentHtmlBoxIds;
	                    data.contentsFragment = {};

	                    //iboosk节点预编译
	                    //在执行的时候节点已经存在
	                    //不需要在创建
	                    if (Xut.IBooks.runMode()) {
	                        _.each(userData.idFix, function (id) {
	                            data.contentsFragment[id] = data.$containsNode.find("#" + id)[0];
	                        });
	                    } else {
	                        //构件快速查询节点对象
	                        data.contentsFragment = toObject(userData.contentStr);
	                        delete userData.contentStr;
	                    }

	                    //容器的前缀
	                    data.containerPrefix = userData.containerPrefix;

	                    /* eslint-disable */
	                    //2015.5.6暴露到全局
	                    //提供给音频字幕上下文
	                    if (!Xut.Contents.contentsFragment[data.chapterId]) {
	                        Xut.Contents.contentsFragment[data.chapterId];
	                    }
	                    Xut.Contents.contentsFragment[data.chapterId] = data.contentsFragment;
	                    /* elist-enable */

	                    //开始下一个任务
	                    _this._dataStrCheck(data, userData.contentDas);
	                }, data, this);
	            });
	        }

	        /**
	         * 中断二:构建结构之后
	         * @param  {[type]} data       [description]
	         * @param  {[type]} contentDas [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_dataStrCheck',
	        value: function _dataStrCheck(data, contentDas) {
	            this._assert('strAfter', function () {
	                var _this2 = this;

	                //保留场景的留信息
	                //用做软件制作单页预加载
	                Xut.sceneController.seasonRelated = data.seasonRelated;

	                //初始化content对象
	                bindActivitys(data, contentDas, function (delayHooks) {
	                    return _this2._eventAfterCheck(data, delayHooks);
	                });
	            });
	        }

	        /**
	         * 中断三:绑定事件事件之后
	         * @param  {[type]} iScrollHooks [description]
	         * @return {[type]}              [description]
	         */

	    }, {
	        key: '_eventAfterCheck',
	        value: function _eventAfterCheck(data, delayHooks) {

	            var self = this;

	            this._assert('eventAfter', function () {

	                data.count = 1; //计算回调的成功的次数

	                /**
	                 * 完成钩子函数
	                 * 1 content的卷滚条
	                 * 2 canvas事件绑定
	                 * @return {[type]} [description]
	                 */
	                var callHooks = function callHooks() {
	                    var iscrollHooks = delayHooks.iscrollHooks;
	                    var hook = void 0;
	                    if (iscrollHooks.length) {
	                        while (hook = iscrollHooks.shift()) {
	                            hook();
	                        }
	                    }
	                };

	                var nextTask = function nextTask() {
	                    callHooks();
	                    self._applyAfterCheck();
	                };

	                /**
	                 * 1 页面浮动
	                 * 2 母版浮动
	                 * 3 正常对象
	                 */
	                var complete = function (data) {
	                    return function () {
	                        if (data.count === 1) {
	                            nextTask();
	                            return;
	                        }
	                        data.count--;
	                    };
	                }(data);

	                //浮动页面对
	                //浮动对象比任何层级都都要高
	                //超过母版
	                if (data.floatPages.ids && data.floatPages.ids.length) {
	                    createFloatPage(this, data, complete);
	                }

	                //如果存在母版浮动节点
	                //在创建节点structure中过滤出来，根据参数的tipmost
	                if (data.floatMaters.ids && data.floatMaters.ids.length) {
	                    createFloatMater(this, data, complete);
	                }

	                //iboosk节点预编译
	                //在执行的时候节点已经存在
	                //不需要在创建
	                if (Xut.IBooks.runMode()) {
	                    complete();
	                } else {
	                    //正常对象
	                    (0, _nexttick2.default)({
	                        'container': data.$containsNode,
	                        'content': toArray(data.contentsFragment)
	                    }, complete);
	                }
	            });
	        }

	        /**
	         * 中断四：渲染content
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_applyAfterCheck',
	        value: function _applyAfterCheck() {
	            this._assert('applyAfter', function () {
	                this._loadComplete(true);
	            });
	        }

	        /**
	         * 运行被阻断的线程任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'runSuspendTasks',
	        value: function runSuspendTasks() {
	            if (this.suspendQueues) {
	                var fn;
	                if (fn = this.suspendQueues.pop()) {
	                    fn();
	                }
	                this.suspendQueues = null;
	            }
	        }

	        /**
	         * 清理引用
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'clearReference',
	        value: function clearReference() {
	            //删除字幕用的碎片文档
	            if (Xut.Contents.contentsFragment[this.chapterId]) {
	                delete Xut.Contents.contentsFragment[this.chapterId];
	            }
	            this.canvasRelated = null;
	            this.pageBaseHooks = null;
	            this.$containsNode = null;
	            this.rootNode = null;
	            this.contentsFragment = null;
	        }
	    }]);

	    return TaskContents;
	}();

	exports.default = TaskContents;

/***/ },
/* 134 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.createCanvas = createCanvas;
	/**
	 * 组成HTML结构
	 * @param  {[type]} argument [description]
	 * @return {[type]}          [description]
	 */
	function createCanvas(data, wrapObj) {

	    var mark = '';
	    if (data.category) {
	        var cats = data.category.split(",");
	        var len = cats.length;
	        if (len) {
	            while (len--) {
	                mark += cats[len];
	            }
	        }
	    }

	    var temp = '<canvas id="{0}"' + ' data-ctype={1}' + ' width="{2}"' + ' height="{3}">' + '</canvas>';

	    var str = String.format(temp, wrapObj.makeId('canvas'), mark.toLocaleLowerCase(), data.scaleWidth, data.scaleHeight);

	    return str;
	}

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.createContainer = createContainer;

	var _option = __webpack_require__(11);

	var _parsecontent = __webpack_require__(37);

	/**
	 * 针对容器类型的处理
	 * @param  {[type]} containerName [description]
	 * @param  {[type]} contentId     [description]
	 * @param  {[type]} pid     [description]
	 * @return {[type]}               [description]
	 */
	var createContainerWrap = function createContainerWrap(containerName, contentId, pid) {

	    var contentDas = (0, _parsecontent.parseContentDas)([contentId]);
	    var data = (0, _option.reviseSize)(contentDas[0]);
	    var wapper = '<div  id="' + containerName + '"\n               data-behavior="click-swipe"\n               style="width:' + data.scaleWidth + 'px;\n                      height:' + data.scaleHeight + 'px;\n                      top:' + data.scaleTop + 'px;\n                      left:' + data.scaleLeft + 'px;\n                      position:absolute;\n                      z-index:' + data.zIndex + ';">';

	    return String.styleFormat(wapper);
	};

	function createContainer(containerRelated, pid) {
	    var itemIds,
	        uuid,
	        contentId,
	        containerName,
	        containerObj = {
	        createUUID: [],
	        containerName: []
	    };

	    containerRelated.forEach(function (data, index) {
	        contentId = data.imageIds;
	        containerName = "Container_" + pid + "_" + contentId;
	        uuid = "aaron" + Math.random();
	        containerObj[uuid] = {
	            'start': [createContainerWrap(containerName, contentId, pid)],
	            'end': '</div>'
	        };
	        containerObj.createUUID.push(uuid);
	        containerObj.containerName.push(containerName);
	        data.itemIds.forEach(function (id) {
	            containerObj[id] = uuid;
	        });
	    });
	    return containerObj;
	}

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.createDom = createDom;

	var _index = __webpack_require__(2);

	var maskBoxImage = Xut.style.maskBoxImage;
	var FLOOR = Math.floor;

	/**
	 * 蒙版动画
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var maskContent = function maskContent(data, wrapObj) {

	    var restr = "";

	    //如果有蒙版图
	    var isMaskImg = data.mask ? maskBoxImage + ":url(" + Xut.config.pathAddress + data.mask + ");" : "";
	    var pathImg = wrapObj.pathImg;

	    //蒙板图
	    if (data.mask || wrapObj['isGif']) {
	        //蒙版图
	        if (maskBoxImage != undefined) {
	            restr += String.styleFormat("<img data-type=\"mask-images\"\n                      class=\"inherit-size fullscreen-background edges\"\n                      src=\"" + pathImg + "\"\n                      style=\"" + isMaskImg + "\"/>");
	        } else {
	            //canvas
	            restr += String.styleFormat("<canvas class=\"inherit-size fullscreen-background edges\"\n                         src=\"" + pathImg + "\"\n                         mask=\"" + isMaskImg + "\"\n                         width=\"" + data.scaleWidth + "\"\n                         height=\"" + data.scaleHeight + "\"\n                         style=\"opacity:0;" + (Xut.config.pathAddress.replace(/\//g, "\/") + data.mask) + "\"/>");
	        }

	        //精灵图
	    } else if (data.category == 'Sprite') {

	        var matrixX = 100 * data.thecount;
	        var matrixY = 100;

	        //如果有参数
	        //精灵图是矩阵图
	        if (data.parameter) {
	            var parameter = (0, _index.parseJSON)(data.parameter);
	            if (parameter && parameter.matrix) {
	                var matrix = parameter.matrix.split("-");
	                matrixX = 100 * Number(matrix[0]);
	                matrixY = 100 * Number(matrix[1]);
	            }
	        }
	        restr += String.styleFormat("<div data-type=\"sprite-images\"\n                  class=\"sprite\"\n                  style=\"height:" + data.scaleHeight + "px;\n                         background-image:url(" + wrapObj['pathImg'] + ");\n                         background-size:" + matrixX + "% " + matrixY + "%;\">\n            </div>");
	    } else {
	        //普通图片
	        restr += String.styleFormat("<img data-type=\"ordinary-images\"\n                  class=\"inherit-size fullscreen-background\"\n                  src=\"" + pathImg + "\"\n                  style=\"" + isMaskImg + "\"/>");
	    }

	    return restr;
	};

	/**
	 * 纯文本内容
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	var textContent = function textContent(data) {
	    return String.styleFormat("<div id = \"" + data['_id'] + "\" style=\"background-size:100% 100%;height:auto\">\n              " + data.content + "\n         </div>");
	};

	/**
	 * 如果是.js结尾的
	 * 新增的html文件
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var jsContent = function jsContent(data, wrapObj) {
	    return (0, _index.replacePath)(wrapObj.htmlstr);
	};

	/**
	 * 如果内容是svg
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var svgContent = function svgContent(data, wrapObj) {
	    var restr = "";
	    var svgstr = wrapObj.svgstr;
	    var scaleWidth = data.scaleWidth;

	    //从SVG文件中，读取Viewport的值
	    if (svgstr != undefined) {

	        //替换svg内部读取文件地址
	        svgstr = (0, _index.replacePath)(svgstr);

	        var startPos = svgstr.search('viewBox="');
	        var searchTmp = svgstr.substring(startPos, startPos + 64).replace('viewBox="', '').replace('0 0 ', '');
	        var endPos = searchTmp.search('"');
	        var temp = searchTmp.substring(0, endPos);
	        var sptArray = temp.split(" ");
	        var svgwidth = sptArray[0];
	        var svgheight = sptArray[1];

	        //svg内容宽度:svg内容高度 = viewBox宽:viewBox高
	        //svg内容高度 = svg内容宽度 * viewBox高 / viewBox宽
	        var svgRealHeight = FLOOR(scaleWidth * svgheight / svgwidth);
	        //如果svg内容高度大于布局高度则添加滚动条
	        if (svgRealHeight > data.scaleHeight + 1) {
	            var svgRealWidth = FLOOR(scaleWidth);
	            //if there do need scrollbar, then restore text to its original prop
	            //布局位置
	            var marginleft = wrapObj.backMode ? data.scaleLeft - data.scaleBackLeft : 0;
	            var margintop = wrapObj.backMode ? data.scaleTop - data.scaleBackTop : 0;

	            if (data.isScroll) {
	                restr = String.styleFormat("<div data-type=\"svg\"\n                          style=\"width:" + svgRealWidth + "px;\n                                 height:" + svgRealHeight + "px;\n                                 margin-left:" + marginleft + "px;\n                                 margin-top:" + margintop + "px;\">\n                        " + svgstr + "\n                     </div>");
	            } else {
	                restr = String.styleFormat("<div data-type=\"svg\"\n                          class=\"inherit-size\"\n                          style=\"margin-left:" + marginleft + "px;\n                                 margin-top:" + margintop + "px;\">\n                        " + svgstr + "\n                    </div>");
	            }
	        } else {
	            restr += svgstr;
	        }
	    }
	    return restr;
	};

	/**
	 * 填充content内容
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var fillContent = function fillContent(data, wrapObj) {
	    var restr = '';
	    //如果内容是图片
	    //如果是svg或者html
	    if (wrapObj.imgContent) {
	        //如果是SVG
	        if (wrapObj.isSvg) {
	            restr += svgContent(data, wrapObj);
	        }
	        //如果是.js结构的html文件
	        else if (wrapObj.isJs) {
	                restr += jsContent(data, wrapObj);
	            }
	            //如果是蒙板，或者是gif类型的动画，给高度
	            else {
	                    restr += maskContent(data, wrapObj);
	                }
	    }
	    //纯文本文字
	    else {
	            restr += textContent(data, wrapObj);
	        }
	    return restr;
	};

	/**
	 * 创建包含容器content
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var createContainer = function createContainer(data, wrapObj) {
	    var wapper = void 0;
	    var backwidth = void 0,
	        backheight = void 0,
	        backleft = void 0,
	        backtop = void 0;
	    var zIndex = data.zIndex;
	    var id = data._id;

	    //Content_23_37
	    //Content_23_38
	    //Content_23_39
	    var containerName = wrapObj.containerName;
	    var pid = wrapObj.pid;
	    var makeId = wrapObj.makeId;
	    var background = data.background ? 'background-image: url(' + Xut.config.pathAddress + data.background + ');' : '';

	    //背景尺寸优先
	    if (data.scaleBackWidth && data.scaleBackHeight) {
	        backwidth = data.scaleBackWidth;
	        backheight = data.scaleBackHeight;
	        backleft = data.scaleBackLeft;
	        backtop = data.scaleBackTop;
	        wrapObj.backMode = true; //背景图模式
	    } else {
	        backwidth = data.scaleWidth;
	        backheight = data.scaleHeight;
	        backleft = data.scaleLeft;
	        backtop = data.scaleTop;
	    }

	    //content默认是显示的数据的
	    //content.visible = 0
	    //如果为1 就隐藏改成hidden
	    //05.1.14
	    var visibility = 'visible';
	    if (data.visible) {
	        visibility = 'hidden';
	    }

	    // var isHtml = "";
	    //2015.12.29
	    //如果是html内容
	    if (wrapObj.isJs) {
	        wapper = "<div id=\"" + containerName + "\"\n                       data-behavior=\"click-swipe\"\n                       class=\"fullscreen-background \"\n                       style=\"width:" + backwidth + "px;\n                              height:" + backheight + "px;\n                              top:" + backtop + "px;\n                              left:" + backleft + "px;\n                              position:absolute;\n                              z-index:" + zIndex + ";\n                              visibility:" + visibility + ";\n                              {10}\">\n                 <div data-type=\"scroller\"\n                      style=\"width:" + backwidth + "px;\n                             position:absolute;\">";
	        return String.styleFormat(wapper);
	    }

	    //scroller:=> absolute 因为别的元素有依赖

	    //正常content类型
	    //如果是scroller需要绝对的尺寸，所以替换100% 不可以
	    wapper = "<div id=\"" + containerName + "\"\n                   data-behavior=\"click-swipe\"\n                   style=\"width:" + backwidth + "px;\n                          height:" + backheight + "px;\n                          top:" + backtop + "px;\n                          left:" + backleft + "px;\n                          position:absolute;\n                          z-index:" + zIndex + ";\n                          visibility:" + visibility + "\">\n              <div data-type=\"scroller\"\n                   class=\"fullscreen-background \"\n                   style=\"width:" + backwidth + "px;\n                          height:" + backheight + "px;\n                          position:absolute;\n                          " + background + "\">";

	    return String.styleFormat(wapper);
	};

	/**
	 * 组成HTML结构
	 * @param  {[type]} argument [description]
	 * @return {[type]}          [description]
	 */
	function createDom(data, wrapObj) {
	    var restr = '';

	    //创建包装容器content节点
	    restr += createContainer(data, wrapObj);

	    //创建内容
	    restr += fillContent(data, wrapObj);
	    restr += "</div></div>";

	    return restr;
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = structure;

	var _index = __webpack_require__(1);

	var _parsetype = __webpack_require__(138);

	var _container = __webpack_require__(135);

	var _dom = __webpack_require__(136);

	var _canvas = __webpack_require__(134);

	var _parsecontent = __webpack_require__(37);

	var _index2 = __webpack_require__(2);

	/**
	 * 解析序列中需要的数据
	 * @param  {[type]}   contentIds [description]
	 * @param  {Function} callback   [description]
	 * @return {[type]}              [description]
	 */

	/**
	 * 制作包装对象
	 * 用于隔绝content数据的引用关系
	 * 导致重复数据被修正的问题
	 * @return {[type]}             [description]
	 */
	var makeWarpObj = function makeWarpObj(contentId, content, pageType, pid, virtualOffset) {
	    //唯一标示符
	    var prefix = "_" + pid + "_" + contentId;
	    return {
	        pageType: pageType,
	        contentId: contentId,
	        isJs: /.js$/i.test(content.md5), //html类型
	        isSvg: /.svg$/i.test(content.md5), //svg类型
	        data: content,
	        pid: pid,
	        virtualOffset: virtualOffset, //布局位置
	        containerName: 'Content' + prefix,
	        makeId: function makeId(name) {
	            return name + prefix;
	        }
	    };
	};

	/**
	 * 创建图片地址
	 * @return {[type]}         [description]
	 */
	/**
	 * 编译content的容器
	 * 2013.10.12
	 * 1 为处理重复content数据引用问题,增加
	 *            makeWarpObj方法,用于隔绝content数据的引用关系，导致重复数据被修正的问题
	 * 2 多个页面引用同一个content的处理，Conetnt_0_1 ,类型+页码+ID的标示
	 * @return {[type]} [description]
	 */

	var analysisPath = function analysisPath(wrapObj, conData) {
	    var pathImg, imgContent, isGif, originalPathImg, resourcePath, results, name;

	    imgContent = conData.md5;
	    isGif = /.gif$/i.test(imgContent); //是gif格式
	    originalPathImg = _index.config.pathAddress + imgContent; //原始地址

	    if (isGif) {
	        pathImg = Xut.createRandomImg(originalPathImg); //处理gif图片缓存+随机数
	    } else {
	        pathImg = originalPathImg;
	    }

	    if (conData.category === "AutoCompSprite") {
	        try {
	            resourcePath = _index.config.pathAddress + imgContent + "/app.json";
	            results = (0, _index2.getResources)(resourcePath);
	            var spiritList = results.spiritList[0];
	            var actListName = spiritList.params.actList;
	            name = spiritList.params[actListName].ImageList[0].name;

	            pathImg += '/' + name;
	            conData.resource = results;
	            conData.containerName = wrapObj.containerName;
	        } catch (err) {
	            console.log('AutoCompSprite获取数据失败');
	        }
	    }

	    wrapObj.imgContent = imgContent;
	    wrapObj.isGif = isGif;
	    wrapObj.pathImg = pathImg;
	};

	/**
	 * content
	 *  svg数据
	 *  html数据
	 * 解析外部文件
	 * @param  {[type]} wrapObj     [description]
	 * @param  {[type]} svgCallback [description]
	 * @return {[type]}             [description]
	 */
	var externalFile = function externalFile(wrapObj, svgCallback) {
	    //svg零件不创建解析具体内容
	    if (wrapObj.isSvg) {
	        (0, _index2.readFile)(wrapObj.data.md5, function (svgdata) {
	            wrapObj.svgstr = svgdata;
	            svgCallback(wrapObj);
	        });
	    } else if (wrapObj.isJs) {
	        //如果是.js的svg文件
	        (0, _index2.readFile)(wrapObj.data.md5, function (htmldata) {
	            wrapObj.htmlstr = htmldata;
	            svgCallback(wrapObj);
	        }, "js");
	    } else {
	        svgCallback(wrapObj);
	    }
	};

	//=====================================================
	//
	//  构建content的序列tokens
	//  createImageIds,
	//  createContentIds
	//  pid,
	//  pageType,
	//  dydCreate //重要判断,动态创建
	//
	//=======================================================
	function structure(callback, data, context) {
	    var content,
	        contentId,
	        wrapObj,
	        containerObj,
	        sizeResults,
	        contentCollection,
	        contentCount,
	        cloneContentCount,
	        pid = data.pid,
	        pageType = data.pageType,
	        containerRelated = data.containerRelated,
	        seasonRelated = data.seasonRelated,
	        isMaster = pageType === 'master',


	    //容器li生成的位置
	    //left,right
	    virtualOffset = data.virtualOffset,


	    ////////////
	    //浮动处理 //
	    //1.浮动母版对象
	    //2.浮动页面对象
	    ////////////
	    floatMaters = data.floatMaters,
	        floatPages = data.floatPages,


	    //文本框
	    //2016.1.7
	    contentHtmlBoxIds = [],


	    //所有content的id记录
	    //返回出去给ibooks预编译使用
	    idFix = [],


	    //缓存contentDas
	    contentDas = {},

	    //缓存content结构
	    cachedContentStr = [];

	    /**
	     * 容器结构创建
	     */
	    if (containerRelated && containerRelated.length) {
	        containerObj = (0, _container.createContainer)(containerRelated, pid);
	    }

	    /**
	     * 转化canvas模式 contentMode 0/1
	     * 页面或者母板浮动对象
	     * 页面是最顶级的
	     * @return {[type]}           [description]
	     */
	    var eachPara = function eachPara(parameter, contentId, conData) {
	        var zIndex;
	        _.each(parameter, function (para) {
	            //针对母版content的topmost数据处理，找出浮动的对象Id
	            //排除数据topmost为0的处理
	            zIndex = para['topmost'];
	            if (zIndex && zIndex != 0) {
	                if (isMaster) {
	                    //收集浮动的母版对象id
	                    floatMaters.ids.push(contentId);
	                    floatMaters.zIndex[contentId] = zIndex;
	                } else {
	                    //浮动页面
	                    floatPages.ids.push(contentId);
	                    floatPages.zIndex[contentId] = zIndex;
	                }
	            }
	        });
	    };

	    /**
	     * 开始过滤参数
	     * @return {[type]}           [description]
	     */
	    var prefilter = function prefilter(conData, contentId) {
	        var eventId, parameter;
	        var category = conData.category;

	        //如果是模板书签，强制为浮动对象
	        if (isMaster && (eventId = seasonRelated[contentId])) {
	            if (eventId['BookMarks']) {
	                floatMaters.ids.push(contentId);
	            }
	        }

	        //如果有parameter参数
	        //1 浮动对象
	        //2 canvas对象
	        if (conData) {
	            //匹配canvas对象数据
	            if (category) {
	                //解析canvas先关数据
	                (0, _parsetype.parseCanvas)(contentId, category, conData, data);
	            }
	            //如果有parameter
	            if (conData.parameter) {
	                if (parameter = (0, _index2.parseJSON)(conData.parameter)) {
	                    //parameter保持数组格式
	                    eachPara(parameter.length ? parameter : [parameter], contentId, conData);
	                }
	            }
	        }
	    };

	    /**
	     * 解析出每一个content对应的动作
	     * 传递prefilter过滤器
	     * 1 浮动动作
	     * 2 canvas动作
	     * @type {[type]}
	     */
	    contentCollection = (0, _parsecontent.parseContentDas)(data.createContentIds, prefilter);
	    contentCount = cloneContentCount = contentCollection.length;

	    //如果是启动了特殊高精灵动画
	    //强制打开canvas模式设置
	    //这里可以排除掉其余的canvas动画
	    if (data.canvasRelated.onlyCompSprite) {
	        data.canvasRelated.enable = true;
	    }

	    ////////////////
	    //开始生成所有的节点 //
	    //1:dom
	    //2:canvas
	    ////////////////
	    while (contentCount--) {

	        //根据数据创content结构
	        if (content = contentCollection[contentCount]) {
	            contentId = content['_id'];

	            //创建包装器,处理数据引用关系
	            wrapObj = makeWarpObj(contentId, content, pageType, pid, virtualOffset);
	            idFix.push(wrapObj.containerName);

	            //保存文本框content的Id
	            if (wrapObj.isJs) {
	                contentHtmlBoxIds.push(contentId);
	            }
	            //转换缩放比
	            sizeResults = (0, _index2.reviseSize)(wrapObj.data);

	            //正常模式下创建
	            startCreate(wrapObj, content, contentId);
	        } else {
	            //或者数据出错
	            checkComplete();
	        }
	    }

	    /**
	     * analysisPath
	     * @param  {[type]} wrapObj   [description]
	     * @param  {[type]} content   [description]
	     * @param  {[type]} contentId [description]
	     * @return {[type]}           [description]
	     */
	    function startCreate(wrapObj, content, contentId) {
	        //缓存数据
	        contentDas[contentId] = content;
	        //开始创建
	        createRelated(contentId, wrapObj);
	    }

	    /**
	     * 清理剔除的content
	     * @param  {[type]} contentId [description]
	     * @return {[type]}           [description]
	     */
	    function clearContent(contentId) {
	        data.createContentIds.splice(data.createContentIds.indexOf(contentId), 1);
	        checkComplete();
	    }

	    /**
	     * 创建content节点
	     * @param  {[type]} wrapObj [description]
	     * @return {[type]}         [description]
	     */
	    function createRelated(contentId, wrapObj) {
	        externalFile(wrapObj, function (wrapObj) {
	            var uuid = void 0,
	                startStr = void 0,
	                contentStr = void 0;

	            var conData = wrapObj.data;

	            //拼接地址
	            analysisPath(wrapObj, conData);

	            //canvas节点
	            if (conData.canvasMode) {
	                contentStr = (0, _canvas.createCanvas)(conData, wrapObj);
	            } else {
	                //dom节点
	                contentStr = (0, _dom.createDom)(conData, wrapObj);
	            }

	            //如果创建的是容器对象
	            if (containerObj && (uuid = containerObj[contentId])) {
	                startStr = containerObj[uuid];
	                startStr.start.push(contentStr);
	            } else {
	                //普通对象
	                cachedContentStr.unshift(contentStr);
	            }

	            //检测完毕
	            checkComplete();
	        });
	    }

	    /**
	     * 返回处理
	     * @return {[type]} [description]
	     */
	    function checkComplete() {
	        if (cloneContentCount === 1) {
	            var data = {
	                contentDas: contentDas,
	                idFix: idFix,
	                contentHtmlBoxIds: contentHtmlBoxIds,
	                containerPrefix: ''
	            };
	            //针对容器处理
	            if (containerObj) {
	                var start, end, containerPrefix, containerStr;
	                containerStr = [];

	                //合并容器
	                containerObj.createUUID.forEach(function (uuid) {
	                    start = containerObj[uuid].start.join('');
	                    end = containerObj[uuid].end;
	                    containerStr.push(start.concat(end));
	                });
	                containerStr = containerStr.join('');
	                containerPrefix = containerObj.containerName;
	                containerObj = null;

	                data.contentStr = cachedContentStr.join('').concat(containerStr);
	                data.containerPrefix = containerPrefix;
	            } else {
	                data.contentStr = cachedContentStr.join('');
	            }

	            callback.call(context, data);
	        }
	        cloneContentCount--;
	    }
	}

	/**
	 * 针对分段处理
	 * 只构件必要的节点节点对象
	 * content字段中visible === 0 是构建显示的对象
	 *                      === 1 是构建隐藏的对象
	 *
	 * 并且不是动态创建
	 */
	// if (false && (1 == content.visible) && !data.dydCreate) {
	// endReturn();  //false 先屏蔽 ，客户端未实现
	// }else{}

/***/ },
/* 138 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.parseCanvas = parseCanvas;
	/**
	 * 设置canvas数据
	 */
	var createCanvasData = function createCanvasData(type, opts) {

		var data = opts.data;
		var contentId = opts.contentId;
		var conData = opts.conData;

		//content收集id标记
		//cid =>content=> 普通动画 ppt
		//wid =>widget=>高级动画
		if (data.canvasRelated[type].indexOf(contentId) == -1) {
			data.canvasRelated[type].push(contentId);
			conData.actionTypes[type] = true;
		}

		if (data.canvasRelated.cid.indexOf(contentId) == -1) {
			data.canvasRelated.cid.push(contentId);
		}

		//给content数据增加直接判断标示
		conData.canvasMode = true;

		//拿到最高层级
		if (conData.zIndex) {
			if (conData.zIndex > data.canvasRelated.containerIndex) {
				data.canvasRelated.containerIndex = conData.zIndex;
			}
		}
	};

	/**
	 * canvas pixi.js类型处理转化
	 * 填充cid, wid
	 * @type {Object}
	 */
	var pixiType = {
		//普通精灵动画
		"Sprite": function Sprite(opts, data) {
			if (data.canvasRelated.enable) {
				//启动精灵模式
				//在动画处理的时候给initAnimations快速调用
				createCanvasData('spiritId', opts);
			}
		},
		//ppt=》pixi动画
		"PPT": function PPT(opts, data) {
			//双重判断
			//必须启动cnavas模式
			//必须数据是canvs模式
			//因为ppt只支持 高级与复杂精灵
			if (data.canvasRelated.enable && opts.conData.canvasMode) {
				createCanvasData('pptId', opts);
			}
		},
		//高级精灵动画
		//widget
		"SeniorSprite": function SeniorSprite(opts, data) {
			if (data.canvasRelated.enable) {
				createCanvasData('widgetId', opts);
			}
		},
		//复杂精灵动画
		//可以在dom模式与canvas混合使用
		//所以dom下还要强制开始canvasMode
		"CompSprite": function CompSprite(opts) {
			var data = opts.data;
			var conData = opts.conData;
			if (/\./i.test(opts.conData.md5)) {
				console.log('复杂精灵动画数据错误');
				return;
			}

			//特殊判断，见canvas.js
			//如果没有启动canvas也能走进这个程序
			//给上特殊标示
			if (!data.canvasRelated.enable && !data.canvasRelated.onlyCompSprite) {
				//仅仅只是满足特殊动画
				//特殊模式，可能chapter表中没有启动canvas模式
				data.canvasRelated.onlyCompSprite = true;
			}
			createCanvasData('compSpriteId', opts);
		}

	};

	/**
	 * 解析参数
	 */
	function callResolveArgs(category, opts) {
		var cate;
		var val;
		var data = opts.data;
		var cates = category.split(",");
		var length = cates.length;
		var i = 0;
		//判断ppt是不是数组中最后一个
		//如果不是，需要对调位置
		var pptindex = cates.indexOf('PPT');

		//如果是首位
		if (pptindex == 0) {
			//ppt永远最后一个
			cates = cates.concat(cates.splice(pptindex, 1));
		}

		if (length) {
			for (var i = 0; i < length; i++) {
				cate = cates[i];
				//匹配数据类型
				pixiType[cate] && pixiType[cate](opts, data);
			}
		}
	}

	/**
	 * 解析canvas数据
	 *
	 */
	function parseCanvas(contentId, category, conData, data) {

		//类型转化
		//双数据类型转行单个类型
		if (Xut.config.onlyDomMode) {
			if (category) {
				var cat;
				var cats = category.split(",");
				var len = cats.length;
				if (len > 1) {
					//删除ppt
					var pptindex = cats.indexOf('PPT');
					if (-1 != pptindex) {
						cats.splice(pptindex, 1);
					}
				}
				conData.category = cats[0];
			}
			return;
		}

		//动作类型
		//用于动画判断
		conData.actionTypes = {};

		//下一个数据
		var opts = {
			contentId: contentId,
			conData: conData,
			data: data
		};

		//转成canvas标记
		//如果有pixi的处理类型
		//2016.2.25
		//SeniorSprite,PPT
		//Sprite,PPT
		//SeniorSprite
		//Sprite
		//PPT
		//CompSprite
		//多种处理方式
		//可以组合
		category && callResolveArgs(category, opts);
	}

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (base, successCallback) {
	    var chapterData = base.chapterData;
	    //只有页面类型支持flow && chpater页存在flow数据
	    if (base.pageType === "page" && (0, _get.isFlowPage)(chapterData.seasonId, base.chapterId)) {
	        base._flows.register(new _flow2.default({
	            pptMaster: base.chapterData.pptMaster, //母版ID
	            pageIndex: base.pageIndex,
	            $pinchNode: base.getContainsNode(),
	            seasonId: base.chapterData.seasonId,
	            chapterId: base.chapterId,
	            successCallback: successCallback
	        }));
	    } else {
	        successCallback();
	    }
	};

	var _flow = __webpack_require__(79);

	var _flow2 = _interopRequireDefault(_flow);

	var _get = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Pinch;

	var _pinch = __webpack_require__(39);

	var _pinch2 = _interopRequireDefault(_pinch);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var transform = Xut.style.transform;
	var transitionDuration = Xut.style.transitionDuration;

	/**
	 * 缩放平移
	 * @param {[type]} node [description]
	 */
	function Pinch($pagePinch, pageIndex) {

	    var relatedMasterObj = Xut.Presentation.GetPageObj('master', pageIndex);
	    var pageMasterNode = void 0;
	    if (relatedMasterObj) {
	        pageMasterNode = relatedMasterObj.getContainsNode()[0];
	    }

	    return new _pinch2.default({
	        $pagePinch: $pagePinch,
	        update: function update(styleText, speed) {
	            if (pageMasterNode) {
	                pageMasterNode.style[transform] = styleText;
	                pageMasterNode.style[transitionDuration] = speed + 'ms';
	            }
	        }
	    });
	}

/***/ },
/* 141 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = initstate;

	var noop = function noop() {};

	function initstate(instance) {

	  return {
	    /**
	     * 主线任务等待
	     */
	    tasksHang: null,

	    /**
	     * 创建相关的信息
	     * @type {Object}
	     */
	    tasksTimer: 0,

	    /**
	     * 当前任务是否中断
	     * return
	     *     true  中断
	     *     false 没有中断
	     */
	    isTaskSuspend: false,

	    /**
	     * 是否预创建背景中
	     */
	    preCreateTasks: false,

	    /**
	     * 下一个将要运行的任务标示
	     * 1 主容器任务
	     * 2 背景任务
	     * 3 widget热点任务
	     * 4 content对象任务
	     */
	    nextRunTask: 'container',

	    /**
	     * 缓存构建中断回调
	     * 构建分2步骤
	     * 1 构建数据与结构（执行中断处理）
	     * 2 构建绘制页面
	     * @type {Object}
	     */
	    cacheTasks: function () {
	      var cacheTasks = {};
	      _.each(["Flow", "background", "components", "contents"], function (taskName) {
	        cacheTasks[taskName] = false;
	      });
	      return cacheTasks;
	    }(),

	    /**
	     * 预创建
	     * 构建页面主容器完毕后,此时可以翻页
	     * @return {[type]} [description]
	     */
	    preforkComplete: noop,

	    /**
	     * 整个页面都构建完毕通知
	     * @return {[type]} [description]
	     */
	    createTasksComplete: noop
	  };
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (instance) {

	    /**
	     * 创建相关的信息
	     * @type {Object}
	     */
	    var createRelated = instance.createRelated = (0, _states2.default)(instance);

	    /**
	     * 设置下一个标记
	     * 用于标记完成度
	     */
	    var setNextRunTask = function setNextRunTask(taskName) {
	        createRelated.nextRunTask = taskName;
	    };

	    var callContextTasks = function callContextTasks(taskName, fn) {
	        return _assign2.default[taskName](fn, instance);
	    };

	    /**
	     * 任务钩子
	     * @type {Object}
	     */
	    instance.threadtasks = {

	        /**
	         * li容器
	         * @return {[type]} [description]
	         */
	        container: function container() {

	            callContextTasks('Container', function ($pageNode, $pseudoElement) {
	                //////////////
	                //li,li-div //
	                //////////////
	                instance.$pageNode = $pageNode;
	                instance.$pseudoElement = $pseudoElement;

	                /**
	                 * 获取根节点
	                 * 获取包含容器
	                 * @return {[type]} [description]
	                 */
	                var $containsElement = $pageNode.children('.page-pinch');
	                instance.getContainsNode = function () {
	                    return $pseudoElement ? $pseudoElement : $containsElement;
	                };

	                setNextRunTask('background');

	                //构建主容器li完毕,可以提前执行翻页动作
	                createRelated.preforkComplete();

	                //视觉差不管
	                if (instance.isMaster) {
	                    instance.nextTasks({
	                        'taskName': '外部Background',
	                        'outNextTasks': function outNextTasks() {
	                            instance.dispatchTasks();
	                        }
	                    });
	                }
	            });
	        },


	        /**
	         * 背景
	         * @return {[type]} [description]
	         */
	        background: function background() {
	            callContextTasks('Background', function () {
	                createRelated.preCreateTasks = false;
	                setNextRunTask('flow');

	                //针对当前页面的检测
	                if (!createRelated.tasksHang || instance.isMaster) {
	                    instance.nextTasks({
	                        'taskName': '外部widgets',
	                        outNextTasks: function outNextTasks() {
	                            instance.dispatchTasks();
	                        }
	                    });
	                }

	                //如果有挂起任务，则继续执行
	                if (createRelated.tasksHang) {
	                    createRelated.tasksHang();
	                }
	            });
	        },


	        /**
	         * 2016.9.7
	         * 特殊的一个内容
	         * 是否为流式排版
	         * @return {[type]} [description]
	         */
	        flow: function flow() {

	            //如果是页面类型
	            var isPageType = instance.pageType === 'page';

	            //创建缩放
	            var createPinch = function createPinch(flow) {
	                if (isPageType && _index.config.saleMode) {
	                    var $pagePinch = instance.getContainsNode();
	                    if (flow) {
	                        //flow页面不处理
	                        //目前只处理图片
	                        // instance._pinchObj = Pinch( $pagePinch.find('.page-flow-pinch'), $pagePinch)
	                    } else {
	                        instance._pinchObj = new _pinch2.default($pagePinch, instance.pageIndex);
	                    }
	                }
	            };

	            //chapter=>note == 'flow'
	            //因为设计chapter只有一个flow效果，所以直接跳过别的创建
	            //只处理页面类型
	            //母版跳过
	            if (isPageType && instance.chapterData.note == 'flow') {
	                callContextTasks('Flow', function () {
	                    createPinch('flow');
	                    setNextRunTask('complete');
	                    createRelated.createTasksComplete();
	                });
	            } else {
	                createPinch();
	                setNextRunTask('components');
	                instance.dispatchTasks();
	            }
	        },


	        /**
	         * 组件
	         * @return {[type]} [description]
	         */
	        components: function components() {
	            //构件零件类型任务
	            callContextTasks('Components', function () {
	                setNextRunTask('contents');
	                instance.nextTasks({
	                    'taskName': '外部contents',
	                    outNextTasks: function outNextTasks() {
	                        instance.dispatchTasks();
	                    }
	                });
	            });
	        },


	        /**
	         * content
	         * @return {[type]} [description]
	         */
	        contents: function contents() {
	            callContextTasks('Contents', function () {
	                setNextRunTask('complete');
	                createRelated.createTasksComplete();
	            });
	        }
	    };
	};

	var _index = __webpack_require__(1);

	var _assign = __webpack_require__(126);

	var _assign2 = _interopRequireDefault(_assign);

	var _states = __webpack_require__(141);

	var _states2 = _interopRequireDefault(_states);

	var _pinch = __webpack_require__(140);

	var _pinch2 = _interopRequireDefault(_pinch);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var noop = function noop() {};

/***/ },
/* 143 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = fade;

	var filter = Xut.style.filter;

	/**
	 * 淡入淡出动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function fade(animproto) {

	    //出现/消失
	    animproto.getEffectAppear = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        if (isExit == false) t1.to(object, 0.001, {
	            autoAlpha: 1
	        });else t1.to(object, 0.001, {
	            css: {
	                visibility: "hidden"
	            }
	        });
	        return t1;
	    };

	    //淡出
	    animproto.getEffectFade = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                ease: parameter.tweenEase,
	                immediateRender: false
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //闪烁(一次)
	    animproto.getEffectFlashOnce = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var time = duration / 3;
	        t1.to(object, 0.001, {
	            css: {
	                visibility: "hidden"
	            }
	        }).to(object, time * 2, {}).to(object, time, {
	            css: {
	                visibility: "visible"
	            }
	        });
	        return t1;
	    };

	    //不饱和
	    animproto.getEffectDesaturate = function (parameter, object, duration, delay, repeat) {
	        if (!(filter in object[0].style)) return new TimelineMax();
	        var saturation = parameter.saturation ? parameter.saturation : 0.5; //饱和度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateSaturate
	        });
	        return t1;

	        function updateSaturate() {
	            var progress = t1.progress();
	            var percent = progress <= 0.5 ? progress * 2 : 1;
	            var val = 1 + (saturation - 1) * percent;
	            object.css(filter, "saturate(" + val + ")");
	        }
	    };

	    //加深
	    animproto.getEffectDarken = function (parameter, object, duration, delay, repeat) {
	        if (!(filter in object[0].style)) return new TimelineMax();
	        var brightness = parameter.brightness && parameter.brightness < 1 ? brightness.saturation : 0.5; //亮度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateBrightness
	        });
	        return t1;

	        function updateBrightness() {
	            var progress = t1.progress();
	            var percent = progress <= 0.5 ? progress * 2 : 1;
	            var val = 1 + (brightness - 1) * percent;
	            object.css(filter, "brightness(" + val + ")");
	        }
	    };

	    //变淡
	    animproto.getEffectLighten = function (parameter, object, duration, delay, repeat) {
	        if (!(filter in object[0].style)) return new TimelineMax();
	        var brightness = parameter.brightness && parameter.brightness > 1 ? parameter.brightness : 1.5; //亮度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateBrightness
	        });
	        return t1;

	        function updateBrightness() {
	            var progress = t1.progress();
	            var percent = progress <= 0.5 ? progress * 2 : 1;
	            var val = 1 + (brightness - 1) * percent;
	            object.css(filter, "brightness(" + val + ")");
	        }
	    };

	    //透明
	    animproto.getEffectTransparency = function (parameter, object, duration, delay, repeat) {
	        var opacity = parameter.amount ? parameter.amount : 0.5; //透明度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            autoAlpha: opacity,
	            ease: parameter.tweenEase
	        });
	        return t1;
	    };
	}

/***/ },
/* 144 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = fly;

	/**
	 * 飞入飞出动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function fly(animproto) {

	    //飞入效果
	    animproto.getEffectFly = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(上、下、左、右、左上、左下、右上、右下)
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        var easeString = Expo.easeOut;
	        var x, y;

	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (parameter.smoothStart == 1 || parameter.smoothEnd == 1 || parameter.bounceEnd == 1) {
	            if (isExit == true) easeString = Power4.easeOut;else easeString = Elastic.easeOut;
	        }

	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "visible"
	                }]
	            });
	            switch (direction) {
	                case "DirectionDown":
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.from(object, duration, {
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    t1.from(object, duration, {
	                        x: x,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionUp":
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.from(object, duration, {
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    t1.from(object, duration, {
	                        x: x,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionDownLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionDownRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionUpLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionUpRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                default:
	                    console.log("getEffectFly:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    x: 0,
	                    y: 0,
	                    visibility: "hidden" //clearProps功能(对象被还原)必须隐藏对象
	                }]
	            });
	            switch (direction) {
	                case "DirectionDown":
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.to(object, duration, {
	                        y: y,
	                        //clearProps: "y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    t1.to(object, duration, {
	                        x: x,
	                        //clearProps: "x",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionUp":
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.to(object, duration, {
	                        y: y,
	                        //clearProps: "y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    t1.to(object, duration, {
	                        x: x,
	                        //clearProps: "x",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionDownLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionDownRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionUpLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionUpRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                default:
	                    console.log("getEffectFly:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //浮入/浮出(下方)
	    animproto.getEffectAscend = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            //t1.to(object, 0.001, {opacity: 0, y: 100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                y: 100,
	                ease: parameter.tweenEase,
	                immediateRender: false
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    y: 0
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                y: 100,
	                //clearProps: "y", //己失效
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //浮入/浮出(上方)
	    animproto.getEffectDescend = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            //t1.to(object, 0.001, {y: -100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                y: -100,
	                ease: parameter.tweenEase,
	                immediateRender: false
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                y: -100,
	                ease: parameter.tweenEase,
	                clearProps: "y"
	            });
	        }
	        return t1;
	    };

	    //切入/出
	    animproto.getEffectPeek = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(上下左右)
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionUp":
	                    t1.from(object, duration, {
	                        y: -objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
	                    });
	                    break;
	                case "DirectionDown":
	                    t1.from(object, duration, {
	                        y: objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
	                    });
	                    break;
	                case "DirectionLeft":
	                    t1.from(object, duration, {
	                        x: -objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
	                    });
	                    break;
	                case "DirectionRight":
	                    t1.from(object, duration, {
	                        x: objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
	                    });
	                    break;
	                default:
	                    console.log("getEffectPeek:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionUp":
	                    t1.to(object, duration, {
	                        y: -objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
	                    });
	                    break;
	                case "DirectionDown":
	                    t1.to(object, duration, {
	                        y: objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
	                    });
	                    break;
	                case "DirectionLeft":
	                    t1.to(object, duration, {
	                        x: -objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
	                    });
	                    break;
	                case "DirectionRight":
	                    t1.to(object, duration, {
	                        x: objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
	                    });
	                    break;
	                default:
	                    console.log("getEffectPeek:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //螺旋飞入/出
	    animproto.getEffectSpiral = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var easeString = Power1.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1.from(object, duration, {
	                scale: 0,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: -200
	                    }, {
	                        x: 0,
	                        y: -400
	                    }, {
	                        x: -500,
	                        y: -600
	                    }]
	                },
	                ease: easeString
	            });
	        } else {
	            t1.to(object, duration, {
	                scale: 0,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: -200
	                    }, {
	                        x: 0,
	                        y: -400
	                    }, {
	                        x: -500,
	                        y: -600
	                    }]
	                },
	                ease: easeString
	            });
	        }
	        return t1;
	    };

	    //曲线向上/下
	    animproto.getEffectArcUp = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Power1.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                scale: 2,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 400
	                    }, {
	                        x: -500,
	                        y: 600
	                    }]
	                },
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    scale: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                scale: 2,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 400
	                    }, {
	                        x: -500,
	                        y: 600
	                    }]
	                },
	                ease: easeString,
	                clearProps: "x,y"
	            });
	        }
	        return t1;
	    };

	    //升起/下沉
	    animproto.getEffectRiseUp = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        var y = objInfo.offsetBottom + objInfo.height;
	        var easeString = Back.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                y: y,
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                y: y,
	                ease: easeString
	            });
	        }
	        return t1;
	    };
	}

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = path;

	var _util = __webpack_require__(40);

	var _move = __webpack_require__(151);

	var _move2 = _interopRequireDefault(_move);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var hasTouch = Xut.plat.hasTouch;

	/**
	 * 路径动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function path(animproto) {

	    //路径动画
	    animproto.getPathAnimation = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var path = parameter.path ? parameter.path : ""; //路径
	        if (!path || path == "") return t1;

	        var autoReverse = parameter.autoReverse == 1 ? true : false; //自动翻转(系统自带,实为沿路径返回)
	        var subRepeat = autoReverse == true ? 1 : 0; //如果autoReverse为真而子动画必须为1，否则默认为0
	        var autoRotate = parameter.objFollow == 1 ? true : false; //是否跟随路径旋转对象(Z轴)
	        var autoTurn = parameter.objFollow == 2 ? true : false; //反向运动时自动翻转对象(Y轴)
	        //连续行为参数处理
	        var axis = 0;
	        var degree = 0; //旋转角度
	        var scaleFactor = null; //缩放比例(未设置时必须为null才能不影响其它动画效果)

	        // var motionScript = ""; //连续脚本
	        if (parameter.attrAlongPath) {
	            axis = parameter.attrAlongPath.axis ? parameter.attrAlongPath.axis : 0;
	            degree = Math.abs(parameter.attrAlongPath.degree) > 0 ? Number(parameter.attrAlongPath.degree) : 0;
	            scaleFactor = parameter.attrAlongPath.scaleFactor > 0 ? parameter.attrAlongPath.scaleFactor : null;
	            // motionScript = parameter.attrAlongPath.motionScript;
	        }

	        var currentFrame = 0; //当前帧
	        var currentDegree = 0; //当前翻转角度
	        var currentOffset = object.offset(); //对象当前位置
	        var turnState = ""; //当前运动状态(左/右)
	        //对象原点坐标（相对页面原点）
	        var objInfo = {
	            top: currentOffset.top,
	            left: currentOffset.left,
	            oX: currentOffset.left + object.width() / 2, //计算object的中心点x坐标
	            oY: currentOffset.top + object.height() / 2 //计算object的中心点有y坐标
	        };
	        //移动起点坐标（默认为对象原点0,0）
	        var x0 = 0,
	            y0 = 0;
	        //对象当前坐标
	        var cx = 0,
	            cy = 0;

	        function resetStartPoint(x, y) {
	            //如果路径动画为：EffectPathStairsDown向下阶梯、EffectPathBounceLeft向左弹跳、EffectPathBounceRight 向右弹跳，则需要重置起点坐标(此问题待验证,暂取消)
	            /*if (parameter.animationName == "EffectPathStairsDown" || parameter.animationName == "EffectPathBounceLeft" || parameter.animationName == "EffectPathBounceRight") {
	                x0 = x;
	                y0 = y;
	            }*/
	            //更新当前坐标
	            cx = x;
	            cy = y;
	        }
	        var isCurve = path.indexOf("C") < 0 && path.indexOf("c") < 0; //是否为曲线路径
	        var ArrPath = path.split(' ');
	        var svgPath = ''; //VML路径转SVG路径(测试)
	        var quArr = [];
	        var x, y;
	        for (var k = 0; k < ArrPath.length; k++) {
	            var str = ArrPath[k];
	            switch (str) {
	                case "M": //移动（开始）
	                case "m":
	                    x = Math.round(ArrPath[k + 1] * this.screenWidth);
	                    y = Math.round(ArrPath[k + 2] * this.screenHeight);
	                    /*t1.add(TweenMax.to(object, 0.001, {
	                        x: x,
	                        y: y
	                    }));*/
	                    quArr.push({
	                        x: x,
	                        y: y
	                    });
	                    k = k + 2;
	                    resetStartPoint(x, y);
	                    svgPath += 'M ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
	                    break;
	                case "C": //曲线
	                case "c":
	                    var x1 = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
	                    var y1 = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
	                    var x2 = x0 + Math.round(ArrPath[k + 3] * this.screenWidth);
	                    var y2 = y0 + Math.round(ArrPath[k + 4] * this.screenHeight);
	                    var x3 = x0 + Math.round(ArrPath[k + 5] * this.screenWidth);
	                    var y3 = y0 + Math.round(ArrPath[k + 6] * this.screenHeight);
	                    quArr.push({
	                        x: x1,
	                        y: y1
	                    }, {
	                        x: x2,
	                        y: y2
	                    }, {
	                        x: x3,
	                        y: y3
	                    });
	                    k = k + 6;
	                    resetStartPoint(x3, y3);
	                    svgPath += ' C ' + (objInfo.oX + x1) + ' ' + (objInfo.oY + y1) + ' ' + (objInfo.oX + x2) + ' ' + (objInfo.oY + y2) + ' ' + (objInfo.oX + x3) + ' ' + (objInfo.oY + y3);
	                    break;
	                case "L": //直线
	                case "l":
	                    x = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
	                    y = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
	                    if (x == cx && y == cy) {
	                        k = k + 2;
	                        break;
	                    }
	                    quArr.push({
	                        x: x,
	                        y: y
	                    });
	                    k = k + 2;
	                    resetStartPoint(x, y);
	                    svgPath += ' L ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
	                    break;
	                case "Z":
	                    //闭合
	                    if (quArr[0].x != quArr[quArr.length - 1].x || quArr[0].y != quArr[quArr.length - 1].y) {
	                        quArr.push({
	                            x: quArr[0].x,
	                            y: quArr[0].y
	                        });
	                    }
	                    svgPath += ' Z';
	                    break;
	                case "E":
	                    //结束
	                    break;
	            }
	        }

	        //启用手势
	        if (parameter.gesture) {
	            t1 = new TimelineMax({
	                paused: true,
	                useFrames: true
	            });
	            parameter.tweenEase = "Linear.easeNone"; //手势控制必须为匀速运动

	            //创建SVG路径(用于测试)
	            /*if (isDesktop) {
	                if ($("#svgPathContainer").length == 0)
	                    this.container.append('<div id="svgPathContainer" style="position:absolute;width:100%;height:100%;"><svg width="100%" height="100%"  xmlns="http://www.w3.org/2000/svg" version="1.1"></svg></div>');
	                var svgDocument = $("#svgPathContainer").find("svg")[0];
	                //创建当前路径
	                var p = makeShape("Path", {
	                    id: "Path_" + object[0].id,
	                    d: svgPath
	                });
	                svgDocument.appendChild(p);
	            }*/

	            //创建手势控制区域
	            var controlId = object[0].id; //控制区ID
	            if (parameter.gesture.controlType == 1) {
	                if (parameter.pathContent > 0) {
	                    controlId = controlId.replace(/\d+$/, parameter.pathContent);
	                } else {
	                    controlId = "Cont_" + object[0].id;
	                    // var expandArea = 20; //最小可触摸尺寸(扩展外框)
	                    //     var rect = p.getBoundingClientRect();
	                    //     this.container.append('<div id="' + controlId + '" style="z-index:9999;position:absolute;left:' + (rect.left - expandArea) + 'px;top:' + (rect.top - expandArea) + 'px;width:' + (rect.width + expandArea * 2) + 'px;height:' + (rect.height + expandArea * 2) + 'px;"></div>');
	                }
	            }
	            //计算路径距离
	            var distance = 0;
	            //distance = p.getTotalLength(); //SVG路径获取长度
	            var sprotInfo = [];
	            for (var m = 1; m < quArr.length; m++) {
	                //获取距离
	                distance += (0, _util.calculateDistance)(quArr[m], quArr[m - 1]);
	                sprotInfo.push({
	                    start: 0,
	                    end: distance,
	                    quadrant: (0, _util.calculateDirection)(quArr[m], quArr[m - 1])
	                });
	            }
	            //修改时间为帧数(距离转换为帧)
	            duration = Math.floor(distance);
	            //触发点列表
	            var cuePoints = [];
	            if (parameter.gesture.cuePoints) {
	                for (var i = 0; i < parameter.gesture.cuePoints.length; i++) {
	                    cuePoints.push({
	                        cueStart: Math.floor(parameter.gesture.cuePoints[i].cueStart * duration),
	                        cueEnd: Math.floor(parameter.gesture.cuePoints[i].cueEnd * duration),
	                        valueStart: parameter.gesture.cuePoints[i].valueStart,
	                        valueEnd: parameter.gesture.cuePoints[i].valueEnd,
	                        mouseEnter: false,
	                        mouseLeave: false
	                    });
	                }
	            }

	            //绑定手势事件
	            var historyPoint = null;

	            var startEvent = function startEvent(e) {
	                historyPoint = {
	                    x: hasTouch ? e.changedTouches[0].pageX : e.clientX,
	                    y: hasTouch ? e.changedTouches[0].pageY : e.clientY
	                };
	            };

	            var moveEnd = function moveEnd() {
	                historyPoint = null;
	                //松手后行为(辅助对象ID)
	                if (parameter.gesture.afterTouch > 0) Xut.Assist.Run(parameter.pageType, parameter.gesture.afterTouch, null);
	            };

	            var moveEvent = function moveEvent(e) {
	                var i;
	                var currentPoint = {
	                    x: hasTouch ? e.changedTouches[0].pageX : e.clientX,
	                    y: hasTouch ? e.changedTouches[0].pageY : e.clientY
	                };
	                var d = (0, _util.calculateDistance)(currentPoint, historyPoint); //鼠示移动距离
	                var quadrant1 = 0; //对象移动方向
	                for (i = 0; i < sprotInfo.length; i++) {
	                    if (currentFrame <= sprotInfo[i].end) {
	                        quadrant1 = sprotInfo[i].quadrant;
	                        break;
	                    }
	                }
	                var quadrant2 = (0, _util.calculateDirection)(currentPoint, historyPoint); //鼠标移动方向
	                switch (quadrant1) {
	                    case "1":
	                    case "2":
	                        if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame + d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame + (currentPoint.x - historyPoint.x);else if (quadrant1 == "1" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame - (currentPoint.y - historyPoint.y);else if (quadrant1 == "2" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
	                        break;
	                    case "3":
	                    case "4":
	                        if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame - (currentPoint.x - historyPoint.x);else if (quadrant1 == "3" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame + (currentPoint.y - historyPoint.y);else if (quadrant1 == "4" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
	                        break;
	                    case "+x":
	                        if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame + d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame + (currentPoint.x - historyPoint.x);
	                        break;
	                    case "-x":
	                        if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame - d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame - (currentPoint.x - historyPoint.x);
	                        break;
	                    case "+y":
	                        if (quadrant2 == "1" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "2" || quadrant2 == "3") currentFrame = currentFrame + d;else if (quadrant2 == "+y" || quadrant2 == "-y") currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
	                        break;
	                    case "-y":
	                        if (quadrant2 == "1" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "2" || quadrant2 == "3") currentFrame = currentFrame - d;else if (quadrant2 == "+y" || quadrant2 == "-y") currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
	                        break;
	                }
	                if (currentFrame <= 0) currentFrame = 0;
	                if (currentFrame >= duration) currentFrame = duration;
	                t1.seek(currentFrame);
	                updateTurnState();
	                historyPoint = currentPoint;
	                //处理触发点列表
	                for (i = 0; i < cuePoints.length; i++) {
	                    if (cuePoints[i].mouseEnter == false && currentFrame >= cuePoints[i].cueStart && currentFrame <= cuePoints[i].cueEnd) {
	                        cuePoints[i].mouseEnter = true;
	                        cuePoints[i].mouseLeave = false;
	                        if (cuePoints[i].valueStart > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueStart, null);
	                        break;
	                    } else if (cuePoints[i].mouseEnter == true && cuePoints[i].mouseLeave == false && (currentFrame < cuePoints[i].cueStart || currentFrame > cuePoints[i].cueEnd)) {
	                        cuePoints[i].mouseEnter = false;
	                        cuePoints[i].mouseLeave = true;
	                        if (cuePoints[i].valueEnd > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueEnd, null);
	                        break;
	                    }
	                }
	            };

	            var objectId = object[0].id;
	            if (parameter.gesture.controlType == 1) {
	                objectId = controlId;
	            }

	            new _move2.default(parameter.pageType, controlId, objectId, startEvent, moveEvent, moveEnd);
	        }
	        //贝赛尔曲线参数构造
	        var bezierObj = {
	            type: "soft",
	            values: quArr,
	            autoRotate: autoRotate
	        };
	        if (isCurve == true) {
	            bezierObj = {
	                curviness: 0, //curviness圆滑度(数字越大越圆滑),默认为1,0是直线运动
	                values: quArr,
	                autoRotate: autoRotate
	            };
	        }
	        //实例化动画参数
	        if (degree == 0) {
	            t1.to(object, duration, {
	                scale: scaleFactor,
	                bezier: bezierObj,
	                repeat: subRepeat,
	                yoyo: autoReverse,
	                onUpdate: updateTurnState,
	                ease: parameter.tweenEase
	            });
	        } else {
	            switch (axis) {
	                default:
	                case 0:
	                    //Z轴
	                    t1.to(object, duration, {
	                        scale: scaleFactor,
	                        rotation: degree + "deg",
	                        bezier: bezierObj,
	                        repeat: subRepeat,
	                        yoyo: autoReverse,
	                        onUpdate: updateTurnState,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case 1:
	                    //X轴
	                    t1.to(object, duration, {
	                        scale: scaleFactor,
	                        rotationX: degree + "deg",
	                        bezier: bezierObj,
	                        repeat: subRepeat,
	                        yoyo: autoReverse,
	                        onUpdate: updateTurnState,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case 2:
	                    //Y轴
	                    t1.to(object, duration, {
	                        scale: scaleFactor,
	                        rotationY: degree + "deg",
	                        bezier: bezierObj,
	                        repeat: subRepeat,
	                        yoyo: autoReverse,
	                        onUpdate: updateTurnState,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	            }
	        }

	        //初始化定位(百分比)
	        if (parameter.gesture && parameter.gesture.initPos > 0) {
	            currentFrame = duration * parameter.gesture.initPos;
	            t1.seek(currentFrame);
	        }

	        return t1;

	        function updateTurnState() {
	            /*var sel=object[0]
	            sel.style.display = 'none';
	            sel.offsetHeight;
	            sel.style.display = 'block';*/
	            if (autoTurn == false) return;
	            var oldOffset = currentOffset;
	            currentOffset = object.offset();
	            if (turnState == "") {
	                if (currentOffset.left > oldOffset.left) {
	                    turnState = "left";
	                } else if (currentOffset.left < oldOffset.left) {
	                    turnState = "right";
	                }
	            } else {
	                if (currentOffset.left > oldOffset.left) {
	                    if (turnState == "right") {
	                        if (currentDegree == 0) currentDegree = 180;else currentDegree = 0;
	                        TweenLite.set(object.children(), {
	                            rotationY: currentDegree
	                        });
	                        turnState = "left";
	                    }
	                } else if (currentOffset.left < oldOffset.left) {
	                    if (turnState == "left") {
	                        if (currentDegree == 0) currentDegree = 180;else currentDegree = 0;
	                        TweenLite.set(object.children(), {
	                            rotationY: currentDegree
	                        });
	                        turnState = "right";
	                    }
	                }
	            }
	        }
	    };
	}

/***/ },
/* 146 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = rotate;

	/**
	 * 旋转类动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function rotate(animproto) {

	    //基本旋转
	    animproto.getEffectSwivel = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical
	        var t1 = null;
	        var easeString = Linear.easeNone;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionHorizontal":
	                    t1.from(object, duration, {
	                        rotationY: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionVertical":
	                    t1.from(object, duration, {
	                        rotationX: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                default:
	                    console.log("getEffectSwivel:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden"
	                }]
	            });
	            switch (direction) {
	                case "DirectionHorizontal":
	                    t1.to(object, duration, {
	                        rotationY: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionVertical":
	                    t1.to(object, duration, {
	                        rotationX: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                default:
	                    console.log("getEffectSwivel:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //陀螺旋转
	    animproto.getEffectSpin = function (parameter, object, duration, delay, repeat) {
	        var degree = parameter.amount ? parameter.amount : 360; //陀螺旋转角度
	        if (Math.abs(parameter.degree) > 0) degree = parameter.degree;
	        if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
	        switch (parameter.centerPos) {
	            case 1:
	                //左上角
	                object.css("-webkit-transform-origin", "left top");
	                break;
	            case 2:
	                //上边中心
	                object.css("-webkit-transform-origin", "center top");
	                break;
	            case 3:
	                //右上角
	                object.css("-webkit-transform-origin", "right top");
	                break;
	            case 4:
	                //左边中心
	                object.css("-webkit-transform-origin", "left cneter");
	                break;
	            case 5:
	                //右边中心
	                object.css("-webkit-transform-origin", "right center");
	                break;
	            case 6:
	                //左下角
	                object.css("-webkit-transform-origin", "left bottom");
	                break;
	            case 7:
	                //下边中心
	                object.css("-webkit-transform-origin", "center bottom");
	                break;
	            case 8:
	                //右下角
	                object.css("-webkit-transform-origin", "right bottom");
	                break;
	            case 0:
	            default:
	                //默认中心0
	                object.css("-webkit-transform-origin", "center");
	                break;
	        }

	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        //t1.to(object, duration, {rotation:degree+"deg",ease:parameter.tweenEase});
	        switch (parameter.axis) {
	            case 1:
	                //X轴
	                t1.to(object, duration, {
	                    rotationX: "+=" + degree + "deg",
	                    ease: parameter.tweenEase
	                });
	                break;
	            case 2:
	                //Y轴
	                t1.to(object, duration, {
	                    rotationY: "+=" + degree + "deg",
	                    ease: parameter.tweenEase
	                });
	                break;
	            case 0: //Z轴
	            default:
	                t1.to(object, duration, {
	                    rotation: "+=" + degree + "deg",
	                    ease: parameter.tweenEase
	                });
	                break;
	        }
	        return t1;
	    };

	    //飞旋
	    animproto.getEffectBoomerang = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var time = duration / 3;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.add(TweenMax.to(object, 0.01, {
	                x: 300,
	                y: -200,
	                rotation: "-60deg"
	            }), "first");
	            t1.add(TweenMax.to(object, time, {
	                autoAlpha: 1,
	                x: 0,
	                y: 0,
	                rotation: "0deg"
	            }), "second");
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "-80deg"
	            }), "second");
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "0deg"
	            }));
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    x: 0,
	                    y: 0,
	                    rotation: "0deg"
	                }]
	            });
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "-80deg"
	            }), "frist");
	            t1.add(TweenMax.to(object, time, {
	                autoAlpha: 0,
	                x: 300,
	                y: -200,
	                rotation: "-60deg"
	            }), "second");
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "0deg"
	            }), "second");
	        }
	        return t1;
	    };

	    //中心旋转
	    animproto.getEffectCenterRevolve = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Power1.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 100
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 300
	                    }]
	                },
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden"
	                }]
	            });
	            t1.to(object, duration, {
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 100
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 300
	                    }]
	                },
	                ease: easeString
	            });
	        }
	        return t1;
	    };

	    //回旋
	    animproto.getEffectSpinner = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Expo.easeOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                scale: 0,
	                rotation: "180deg",
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden",
	                    scale: 1,
	                    rotation: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                scale: 0,
	                rotation: "180deg",
	                ease: easeString
	            });
	        }
	        return t1;
	    };

	    //旋转(淡出式回旋)
	    animproto.getEffectFadedSwivel = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Linear.easeNone;
	        var degree = Math.abs(parameter.degree) > 0 ? Number(parameter.degree) : 90;
	        if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
	        switch (parameter.centerPos) {
	            case 1:
	                //左上角
	                object.css("-webkit-transform-origin", "left top");
	                break;
	            case 2:
	                //上边中心
	                object.css("-webkit-transform-origin", "center top");
	                break;
	            case 3:
	                //右上角
	                object.css("-webkit-transform-origin", "right top");
	                break;
	            case 4:
	                //左边中心
	                object.css("-webkit-transform-origin", "left cneter");
	                break;
	            case 5:
	                //右边中心
	                object.css("-webkit-transform-origin", "right center");
	                break;
	            case 6:
	                //左下角
	                object.css("-webkit-transform-origin", "left bottom");
	                break;
	            case 7:
	                //下边中心
	                object.css("-webkit-transform-origin", "center bottom");
	                break;
	            case 8:
	                //右下角
	                object.css("-webkit-transform-origin", "right bottom");
	                break;
	            case 0:
	            default:
	                //默认中心0
	                object.css("-webkit-transform-origin", "center");
	                break;
	        }
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            //t1.from(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
	            switch (parameter.axis) {
	                case 0:
	                    //Z轴
	                    t1.from(object, duration, {
	                        autoAlpha: 0,
	                        rotation: degree + "deg",
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case 1:
	                    //X轴
	                    t1.from(object, duration, {
	                        autoAlpha: 0,
	                        rotationX: degree + "deg",
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case 2: //Y轴
	                default:
	                    t1.from(object, duration, {
	                        autoAlpha: 0,
	                        rotationY: degree + "deg",
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            //t1.to(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
	            switch (parameter.axis) {
	                case 0:
	                    //Z轴
	                    t1.to(object, duration, {
	                        autoAlpha: 0,
	                        rotation: degree + "deg",
	                        ease: easeString
	                    });
	                    break;
	                case 1:
	                    //X轴
	                    t1.to(object, duration, {
	                        autoAlpha: 0,
	                        rotationX: degree + "deg",
	                        ease: easeString
	                    });
	                    break;
	                case 2: //Y轴
	                default:
	                    t1.to(object, duration, {
	                        autoAlpha: 0,
	                        rotationY: degree + "deg",
	                        ease: easeString
	                    });
	                    break;
	            }
	        }
	        return t1;
	    };
	}

/***/ },
/* 147 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = shape;

	/**
	 * 形状动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function shape(animproto) {

	    //形状一(圆)
	    animproto.getEffectCircle = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var result = this._getObjectInfo(object);
	        var radius = Math.ceil(Math.sqrt(result.width * result.width / 4 + result.height * result.height / 4));
	        switch (direction) {
	            case "DirectionIn": //放大
	            case "DirectionOut":
	                //缩小
	                if (isExit == false) {
	                    t1.to(object, duration, {
	                        onUpdate: updateCircleGradient
	                    });
	                } else {
	                    t1.to(object, duration, {
	                        onUpdate: updateCircleGradient
	                    });
	                }
	                break;
	            default:
	                console.log("getEffectCircle:parameter error.");
	                break;
	        }
	        return t1;

	        function updateCircleGradient() {
	            var progress = t1.progress();
	            var len = parseInt(progress * radius);
	            if (isExit == false) switch (direction) {
	                case "DirectionIn":
	                    //DirectionIn放大
	                    object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,1)),to(rgba(0,0,0,0)),color-stop(10%,rgba(0,0,0,0)))");
	                    if (len == radius) object.css("-webkit-mask", "none");
	                    break;
	                case "DirectionOut":
	                    //DirectionOut缩小
	                    object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,1)), to(rgba(0,0,0,0)), color-stop(90%, rgba(0,0,0,1)))");
	                    if (len == radius) object.css("-webkit-mask", "none");
	                    break;
	            } else {
	                switch (direction) {
	                    case "DirectionIn":
	                        //DirectionIn放大
	                        object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,0)),to(rgba(0,0,0,1)),color-stop(10%,rgba(0,0,0,1)))");
	                        if (len == radius) {
	                            //object.css("opacity","0");
	                            object.css("visibility", "hidden");
	                            object.css("-webkit-mask", "none");
	                        }
	                        break;
	                    case "DirectionOut":
	                        //DirectionOut缩小
	                        object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,0)), to(rgba(0,0,0,1)), color-stop(90%, rgba(0,0,0,0)))");
	                        if (len == radius) {
	                            //object.css("opacity","0");
	                            object.css("visibility", "hidden");
	                            object.css("-webkit-mask", "none");
	                        }
	                        break;
	                }
	            }
	        }
	    };

	    //形状二(方框)
	    animproto.getEffectBox = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        if (this.useMask == false) direction = "DirectionOut";

	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var objInfo = this._getObjectInfo(object);
	        t1.to(object, duration, {
	            onUpdate: updateEffectBox
	        });
	        return t1;

	        function updateEffectBox() {
	            var width, height, left, top;
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionOut":
	                        top = objInfo.height * (0.5 - percent);
	                        height = objInfo.height - top;
	                        left = objInfo.width * (0.5 - percent);
	                        width = objInfo.width - left;
	                        object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionOut":
	                        top = objInfo.height * percent;
	                        height = objInfo.height - top;
	                        left = objInfo.width * percent;
	                        width = objInfo.width - left;
	                        object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //形状三(菱形)
	    animproto.getEffectDiamond = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        // var objInfo = this._getObjectInfo(object);
	        t1.to(object, duration, {
	            onUpdate: updateEffectBox
	        });
	        return t1;

	        function updateEffectBox() {
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionOut":
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionOut":
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //形状四(加号)
	    animproto.getEffectPlus = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectPlus
	        });
	        return t1;

	        function updateEffectPlus() {
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionIn":
	                    case "DirectionOut":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))");
	                        break;
	                    default:
	                        console.log("getEffectPlus:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionIn":
	                    case "DirectionOut":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + percent + ",transparent),color-stop(" + percent + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + percent + ",transparent),color-stop(" + percent + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))");
	                        break;
	                    default:
	                        console.log("getEffectPlus:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };
	}

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = special;

	var _util = __webpack_require__(40);

	var filter = Xut.style.filter;

	function special(animproto) {

	    //文字动画
	    animproto.getTextAnimation = function (parameter, object, duration, delay, repeat) {
	        if (delay == 0) delay = 0.1; //子对象间延时不能为0
	        var type = parameter.effectType ? parameter.effectType : "text1";
	        var color = parameter.startColor ? parameter.startColor : "";
	        var svgElement = object.find("svg").children();
	        var t1 = new TimelineMax({
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        switch (type) {
	            default:
	            case "text5": //文字逐行蹦出(以行为单位)
	            case "text1":
	                //文字逐个蹦出(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0
	                    }
	                }, delay);
	                break;
	            case "text2":
	                //文字放大出现(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0,
	                        "font-size": 120
	                    },
	                    ease: "Strong.easeOut"
	                }, delay);
	                break;
	            case "text3":
	                //文字缩小出现(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0,
	                        "font-size": 0
	                    },
	                    ease: "Power1.easeIn"
	                }, delay);
	                break;
	            case "text4":
	                //文字渐变出现(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0,
	                        "fill": color
	                    },
	                    ease: "Power1.easeIn"
	                }, delay);
	                break;
	        }
	        return t1;
	    };

	    //脉冲
	    animproto.getEffectFlashBulb = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var range = Number(parameter.range) ? parameter.range : 0.1;
	        var time = duration / 2;
	        t1.to(object, time, {
	            autoAlpha: 0.5,
	            scale: "+=" + range
	        }).to(object, time, {
	            autoAlpha: 1,
	            scale: "-=" + range
	        });
	        return t1;
	    };

	    //百叶窗
	    animproto.getEffectBlinds = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical）
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectBlinds
	        });
	        return t1;

	        function updateEffectBlinds() {
	            var num = 6; //分成N等份
	            var progress = t1.progress();
	            var percent = progress / num;
	            var avg = 1 / num;
	            var temp = 0.01; //渐变的过渡区
	            var str = "";
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionHorizontal":
	                        //水平
	                        str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + percent + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
	                        for (var i = 1; i < num; i++) {
	                            str += ",color-stop(" + i * avg + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg + temp) + ",rgba(0,0,0,1))";
	                            str += ",color-stop(" + (i * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg + percent + temp) + ",rgba(0,0,0,0))";
	                        }
	                        str += ")";
	                        break;
	                    case "DirectionVertical":
	                        //垂直
	                        str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + percent + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
	                        for (var j = 1; j < num; j++) {
	                            str += ",color-stop(" + j * avg + ",rgba(0,0,0,0))" + ",color-stop(" + (j * avg + temp) + ",rgba(0,0,0,1))";
	                            str += ",color-stop(" + (j * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (j * avg + percent + temp) + ",rgba(0,0,0,0))";
	                        }
	                        str += ")";
	                        break;
	                    default:
	                        console.log("getEffectBlinds:parameter error.");
	                        break;
	                }
	                object.css("-webkit-mask", str);
	                if (percent >= avg - temp) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionHorizontal":
	                        //水平
	                        str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
	                        for (var n = 1; n < num; n++) {
	                            str += ",color-stop(" + n * avg + ",rgba(0,0,0,1))" + ",color-stop(" + (n * avg - temp) + ",rgba(0,0,0,0))";
	                            str += ",color-stop(" + (n * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (n * avg - percent - temp) + ",rgba(0,0,0,1))";
	                        }
	                        str += ")";
	                        break;
	                    case "DirectionVertical":
	                        //垂直
	                        str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
	                        for (var k = 1; k < num; k++) {
	                            str += ",color-stop(" + k * avg + ",rgba(0,0,0,1))" + ",color-stop(" + (k * avg - temp) + ",rgba(0,0,0,0))";
	                            str += ",color-stop(" + (k * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (k * avg - percent - temp) + ",rgba(0,0,0,1))";
	                        }
	                        str += ")";
	                        break;
	                    default:
	                        console.log("getEffectBlinds:parameter error.");
	                        break;
	                }
	                object.css("-webkit-mask", str);
	                if (percent >= avg - temp) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //劈裂
	    animproto.getEffectSplit = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionVerticalIn、DirectionHorizontalIn、DirectionHorizontalOut、DirectionVerticalOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectSplit
	        });
	        return t1;

	        function updateEffectSplit() {
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                if (progress > 0.9) {
	                    //跳过最后10%（解决iPad的闪问题）
	                    object.css("-webkit-mask", "none");
	                    return;
	                }
	                switch (direction) {
	                    case "DirectionVerticalIn":
	                        //左右向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionHorizontalIn":
	                        //上下向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionHorizontalOut":
	                        //中间向上下展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
	                        break;
	                    case "DirectionVerticalOut":
	                        //中间向左右展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
	                        break;
	                    default:
	                        console.log("getEffectSplit:parameter error.");
	                        break;
	                }
	                //if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                if (progress < 0.1) return; //跳过前面10%（解决iPad的闪问题）
	                switch (direction) {
	                    case "DirectionVerticalIn":
	                        //左右向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
	                        break;
	                    case "DirectionHorizontalIn":
	                        //上下向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
	                        break;
	                    case "DirectionHorizontalOut":
	                        //中间向上下展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionVerticalOut":
	                        //中间向左右展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
	                        break;
	                    default:
	                        console.log("getEffectSplit:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //擦除
	    animproto.getEffectWipe = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(上下左右)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var objInfo = this._getObjectInfo(object);
	        if (isExit == false) {
	            //t1.to(object,duration,{onStart:this._startHandler,onStartParams:[object],onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
	            t1.to(object, duration, {
	                onUpdate: this._updateClipRect,
	                onUpdateParams: [t1, object, isExit, direction, objInfo]
	            });
	        } else {
	            //t1.to(object,duration,{onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
	            t1.to(object, duration, {
	                onUpdate: this._updateClipRect,
	                onUpdateParams: [t1, object, isExit, direction, objInfo]
	            });
	        }
	        return t1;
	    };

	    //翻转式由远及近
	    animproto.getEffectGrowAndTurn = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "90deg",
	                ease: parameter.tweenEase,
	                clearProps: "scale,rotation"
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    scale: 1,
	                    rotation: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "90deg",
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //玩具风车
	    animproto.getEffectPinwheel = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "540deg",
	                ease: parameter.tweenEase
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    scale: 1,
	                    rotation: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "540deg",
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //展开/收缩
	    animproto.getEffectExpand = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                rotationY: "45deg",
	                ease: parameter.tweenEase
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    rotationY: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                rotationY: "45deg",
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //浮动
	    animproto.getEffectFloat = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        var x, y;
	        if (isExit == false) {
	            x = objInfo.offsetRight + objInfo.width;
	            y = 0 - (objInfo.offsetTop + objInfo.height);
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                rotation: "-45deg",
	                x: x,
	                y: y,
	                ease: parameter.tweenEase
	            });
	        } else {
	            x = objInfo.offsetRight + objInfo.width;
	            y = 0 - (objInfo.offsetTop + objInfo.height);
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                rotation: "-45deg",
	                x: x,
	                y: y,
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //字幕式
	    animproto.getEffectCredits = function (parameter, object, isExit, duration, delay, repeat) {
	        var objInfo = this._getObjectInfo(object);
	        var y = 0,
	            top = 0;
	        if (isExit == false) {
	            //从下往上移
	            y = 0 - (this.screenHeight + objInfo.height);
	            top = objInfo.top + objInfo.offsetBottom + objInfo.height;
	        } else {
	            //从上往下移
	            y = this.screenHeight + objInfo.height;
	            top = objInfo.top - (objInfo.offsetTop + objInfo.height);
	        }
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible",
	                top: top + "px"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            y: y,
	            ease: parameter.tweenEase
	        });
	        return t1;
	    };

	    //弹跳
	    animproto.getEffectBounce = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var objInfo = this._getObjectInfo(object);

	        var time2, time3, time4, time5, y1, y2, y3, y4, lastY, height, time1, total, width;

	        if (isExit == false) {
	            total = duration;
	            time1 = total / 5;
	            time2 = total / 10;
	            time3 = total / 20;
	            time4 = total / 40;
	            time5 = total / 80;
	            width = 50 + 20 + 10 + 5 + 2.5 + 1 + 0.5 + 0.2 + 0.1;
	            height = this.screenHeight / 4;
	            y1 = height / 2;
	            y2 = height / 4;
	            y3 = height / 8;
	            y4 = height / 16;
	            lastY = objInfo.offsetBottom - height + objInfo.height;

	            t1.to(object, 0.01, {
	                x: -width,
	                y: -height
	            }).to(object, time1, {
	                x: "+=50",
	                y: "+=" + height,
	                ease: Circ.easeIn
	            }) //慢到快
	            .to(object, time1, {
	                x: "+=20",
	                y: "-=" + y1,
	                scaleY: 0.8,
	                ease: Circ.easeOut
	            }) //快到慢
	            .to(object, time1, {
	                x: "+=10",
	                y: "+=" + y1,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time2, {
	                x: "+=5",
	                y: "-=" + y2,
	                scaleY: 0.85,
	                ease: Circ.easeOut
	            }).to(object, time2, {
	                x: "+=2.5",
	                y: "+=" + y2,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time3, {
	                x: "+=1",
	                y: "-=" + y3,
	                scaleY: 0.9,
	                ease: Circ.easeOut
	            }).to(object, time3, {
	                x: "+=0.5",
	                y: "+=" + y3,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time4, {
	                x: "+=0.2",
	                y: "-=" + y4,
	                scaleY: 0.95,
	                ease: Circ.easeOut
	            }).to(object, time4, {
	                x: "+=0.1",
	                y: "+=" + y4,
	                scaleY: 1,
	                ease: Circ.easeIn,
	                clearProps: "x,y"
	            });
	            return t1;
	        } else {
	            total = duration;
	            time1 = total / 5;
	            time2 = total / 10;
	            time3 = total / 20;
	            time4 = total / 40;
	            time5 = total / 80;
	            height = this.screenHeight / 4;
	            y1 = height / 2;
	            y2 = height / 4;
	            y3 = height / 8;
	            y4 = height / 16;
	            lastY = objInfo.offsetBottom - height + objInfo.height;
	            t1.to(object, time1, {
	                x: "+=50",
	                y: "+=" + height,
	                ease: Circ.easeIn
	            }) //慢到快
	            .to(object, time1, {
	                x: "+=20",
	                y: "-=" + y1,
	                scaleY: 0.8,
	                ease: Circ.easeOut
	            }) //快到慢
	            .to(object, time1, {
	                x: "+=10",
	                y: "+=" + y1,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time2, {
	                x: "+=5",
	                y: "-=" + y2,
	                scaleY: 0.85,
	                ease: Circ.easeOut
	            }).to(object, time2, {
	                x: "+=2.5",
	                y: "+=" + y2,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time3, {
	                x: "+=1",
	                y: "-=" + y3,
	                scaleY: 0.9,
	                ease: Circ.easeOut
	            }).to(object, time3, {
	                x: "+=0.5",
	                y: "+=" + y3,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time4, {
	                x: "+=0.2",
	                y: "-=" + y4,
	                scaleY: 0.95,
	                ease: Circ.easeOut
	            }).to(object, time4, {
	                x: "+=0.1",
	                y: "+=" + y4,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time5, {
	                x: "+=0.1",
	                y: "+=" + lastY,
	                ease: Circ.easeIn
	            });
	        }
	        return t1;
	    };

	    //彩色脉冲
	    animproto.getEffectFlicker = function (parameter, object, duration, delay, repeat) {
	        if (!(filter in object[0].style)) return new TimelineMax();
	        //if (repeat < 2) repeat = 2; //默认三次
	        var color2 = parameter.color2 ? parameter.color2 : "#fff"; //颜色
	        var maxGlowSize = parameter.maxGlowSize ? parameter.maxGlowSize : 0.1; //光晕最大尺寸(百分比)
	        var minGlowSize = parameter.minGlowSize ? parameter.minGlowSize : 0.05; //光晕最小尺寸(百分比)
	        var size = object.width() > object.height() ? object.height() : object.width();
	        var maxSize = maxGlowSize * size;
	        var minSize = minGlowSize * size;
	        var opacity = Number(parameter.opacity) ? parameter.opcity : 0.75; //不透明度
	        var distance = Number(parameter.distance) ? parameter.distance * size : 0; //距离
	        var color = (0, _util.colorHexToRGB)(color2, opacity);
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                //"box-shadow": "none"
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectFlicker
	        });
	        return t1;

	        function updateEffectFlicker() {
	            var progress = t1.progress();
	            var percent = parseInt(progress * (maxSize - minSize));
	            if (progress > 0.5) percent = parseInt((1 - progress) * (maxSize - minSize));
	            //object.css("box-shadow", distance + "px " + distance + "px " + minSize + "px " + (minSize + percent) + "px " + color);
	            object.css(filter, "drop-shadow(" + color + " " + distance + "px " + distance + "px " + (minSize + percent) + "px)");
	        }
	    };

	    //跷跷板
	    animproto.getEffectTeeter = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        // var mode = parameter.mode;
	        var range = Number(parameter.range) ? parameter.range : 0.02;
	        var time = duration / 8; //计算指定动画时间内每次运动时间(总时长不变，循环除外)
	        switch (parameter.mode) {
	            case 1:
	                //左右移动
	                range = range * object.width();
	                t1.to(object, time, {
	                    x: -range
	                }).to(object, time * 2, {
	                    x: range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    x: -range
	                });
	                t1.to(object, time * 2, {
	                    x: range
	                });
	                //}
	                t1.to(object, time, {
	                    x: 0
	                });
	                break;
	            case 2:
	                //上下移动
	                range = range * object.height();
	                t1.to(object, time, {
	                    y: -range
	                }).to(object, time * 2, {
	                    y: range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    y: -range
	                });
	                t1.to(object, time * 2, {
	                    y: range
	                });
	                //}
	                t1.to(object, time, {
	                    y: 0
	                });
	                break;
	            case 3:
	                //左右挤压
	                t1.to(object, time, {
	                    scaleX: 1 + range
	                }).to(object, time * 2, {
	                    scaleX: 1 - range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    scaleX: 1 + range
	                });
	                t1.to(object, time * 2, {
	                    scaleX: 1 - range
	                });
	                //}
	                t1.to(object, time, {
	                    scaleX: 1
	                });
	                break;
	            case 4:
	                //上下挤压
	                t1.to(object, time, {
	                    scaleY: 1 + range
	                }).to(object, time * 2, {
	                    scaleY: 1 - range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    scaleY: 1 + range
	                });
	                t1.to(object, time * 2, {
	                    scaleY: 1 - range
	                });
	                //}
	                t1.to(object, time, {
	                    scaleY: 1
	                });
	                break;
	            case 0: //左右晃晃
	            default:
	                range = range * 100;
	                t1.to(object, time, {
	                    rotation: range + "deg"
	                }).to(object, time * 2, {
	                    rotation: -range + "deg"
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    rotation: range + "deg"
	                });
	                t1.to(object, time * 2, {
	                    rotation: -range + "deg"
	                });
	                //}
	                t1.to(object, time, {
	                    rotation: "0deg"
	                });
	                break;
	        }
	        return t1;
	    };

	    //补色
	    animproto.getEffectComplementaryColor = function (parameter, object, duration, delay, repeat) {
	        var zIndex = Number(object.css("z-index"));
	        if (isNaN(zIndex)) {
	            zIndex = 10;
	            console.log("The Z-index property for this object to get error.");
	        }
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                "z-Index": zIndex + 100
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                "z-Index": zIndex
	            }]
	        });
	        t1.to(object, duration, {
	            autoAlpha: 1
	        });
	        return t1;
	    };

	    //rect切割效果更新
	    animproto._updateClipRect = function (t1, object, isExit, direction, objInfo) {
	        var progress = t1.progress();
	        var len = progress;
	        var width, left, top, height;
	        if (isExit == false) {
	            top = objInfo.height * (1 - len);
	            height = objInfo.height - top;
	            left = objInfo.width * (1 - len);
	            width = objInfo.width - left;
	            switch (direction) {
	                case "DirectionUp":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
	                    break;
	                case "DirectionDown":
	                    object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
	                    break;
	                case "DirectionLeft":
	                    object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
	                    break;
	                case "DirectionRight":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
	                    break;
	                default:
	                    console.log("_updateClipRect:parameter error.");
	                    break;
	            }
	        } else {
	            top = objInfo.height * len;
	            height = objInfo.height - top;
	            left = objInfo.width * len;
	            width = objInfo.width - left;
	            switch (direction) {
	                case "DirectionUp":
	                    object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
	                    break;
	                case "DirectionDown":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
	                    break;
	                case "DirectionLeft":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
	                    break;
	                case "DirectionRight":
	                    object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
	                    break;
	                default:
	                    console.log("_updateClipRect:parameter error.");
	                    break;
	            }
	        }
	    };
	}

/***/ },
/* 149 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = zoom;
	var filter = Xut.style.filter;

	/**
	 * 缩放类动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function zoom(animproto) {

	    //基本缩放
	    animproto.getEffectZoom = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(放大:DirectionIn、屏幕中心放大:DirectionInCenter、轻微放大:DirectionInSlightly、缩小:DirectionOut、屏幕底部缩小:DirectionOutBottom、轻微缩小:DirectionOutSlightly)
	        var t1 = null;
	        var result;
	        object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionIn":
	                    t1.from(object, duration, {
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInCenter":
	                    result = this._getDirectionInCenter(object);
	                    t1.from(object, duration, {
	                        scale: 0,
	                        x: result.x,
	                        y: result.y,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInSlightly":
	                    t1.from(object, duration, {
	                        scale: 0.7,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOut":
	                    t1.from(object, duration, {
	                        scale: 3,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutBottom":
	                    //屏幕底部缩小(理解为底部的中间开始)
	                    t1.from(object, duration, {
	                        scale: 2,
	                        top: this.screenWidth + "px",
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutSlightly":
	                    t1.from(object, duration, {
	                        scale: 1.5,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectZoom:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden"
	                }]
	            });
	            switch (direction) {
	                case "DirectionIn":
	                    t1.to(object, duration, {
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInCenter":
	                    result = this._getDirectionInCenter(object);
	                    t1.to(object, duration, {
	                        scale: 0,
	                        x: result.x,
	                        y: result.y,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInSlightly":
	                    t1.to(object, duration, {
	                        scale: 0.7,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOut":
	                    t1.to(object, duration, {
	                        scale: 3,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutBottom":
	                    t1.to(object, duration, {
	                        scale: 2,
	                        top: this.screenHeight + "px",
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutSlightly":
	                    t1.to(object, duration, {
	                        scale: 1.5,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectZoom:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //缩放 淡出式缩放
	    animproto.getEffectFadedZoom = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(对象中心DirectionIn、幻灯片中心DirectionInCenter)
	        var t1 = null;
	        object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
	        var svgElement = object.find("svg"); //获取SVG对象
	        if (svgElement) svgElement.css('-webkit-transform', 'translate3d(0px, 0px, 0px)'); //解决SVG文字错乱问题

	        var keepRatio = parameter.keepRatio == 0 ? false : true; //保持长宽比
	        var fullScreen = parameter.fullScreen == 1 ? true : false; //缩放到全屏
	        var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
	        var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
	        var result;
	        if (fullScreen == true) {
	            //计算比例
	            var xScale = this.screenWidth / object.width();
	            var yScale = this.screenHeight / object.height();
	            var scaleValue = xScale;
	            if (xScale > yScale) scaleValue = yScale;
	            result = this._getDirectionInCenter(object);
	            if (isExit == false) {
	                t1 = new TimelineMax({
	                    delay: delay,
	                    repeat: repeat,
	                    onStart: this._startHandler,
	                    onStartParams: [parameter, object, {
	                        opacity: 0
	                    }],
	                    onComplete: this._completeHandler,
	                    onCompleteParams: [parameter, object]
	                });
	                t1.to(object, duration, {
	                    x: result.x,
	                    y: result.y,
	                    autoAlpha: 1,
	                    scale: scaleValue,
	                    ease: parameter.tweenEase
	                });
	            } else {
	                t1 = new TimelineMax({
	                    delay: delay,
	                    repeat: repeat,
	                    onStart: this._startHandler,
	                    onStartParams: [parameter, object],
	                    onComplete: this._completeHandler,
	                    onCompleteParams: [parameter, object]
	                });
	                t1.to(object, duration, {
	                    x: result.x,
	                    y: result.y,
	                    autoAlpha: 0,
	                    scale: scaleValue,
	                    ease: parameter.tweenEase
	                });
	            }
	        } else if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionIn":
	                    if (keepRatio == true) t1.from(object, duration, {
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });else {
	                        t1.from(object, duration, {
	                            autoAlpha: 0,
	                            scaleX: scaleX,
	                            scaleY: scaleY,
	                            ease: parameter.tweenEase
	                        });
	                    }
	                    break;
	                case "DirectionInCenter":
	                    result = this._getDirectionInCenter(object);
	                    if (keepRatio == true) t1.from(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });else t1.from(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scaleX: scaleX,
	                        scaleY: scaleY,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectFadedZoom:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            switch (direction) {
	                case "DirectionOut":
	                    if (keepRatio == true) t1.to(object, duration, {
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase,
	                        clearProps: "scale"
	                    });else t1.to(object, duration, {
	                        autoAlpha: 0,
	                        scaleX: scaleX,
	                        scaleY: scaleY,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutCenter":
	                    result = this._getDirectionInCenter(object);
	                    if (keepRatio == true) t1.to(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });else t1.to(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scaleX: scaleX,
	                        scaleY: scaleY,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectFadedZoom:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //放大/缩小
	    animproto.getEffectGrowShrink = function (parameter, object, duration, delay, repeat) {
	        var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
	        var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
	        // var keepRatio = (parameter.keepRatio == 0) ? false : true; //保持长宽比
	        var fullScreen = parameter.fullScreen == 1 ? true : false; //缩放到全屏
	        var resetSize = parameter.resetSize == 1 ? true : false; //恢复默认尺寸
	        var easeString = Linear.easeNone; //Elastic.easeOut
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        if (fullScreen == true) {
	            //计算比例
	            var xScale = this.screenWidth / object.width();
	            var yScale = this.screenHeight / object.height();
	            var scaleValue = xScale;
	            if (xScale > yScale) scaleValue = yScale;
	            var result = this._getDirectionInCenter(object);
	            t1.to(object, duration, {
	                x: result.x,
	                y: result.y,
	                scale: scaleValue,
	                ease: parameter.tweenEase
	            });
	        } else if (resetSize == true) {
	            t1.to(object, duration, {
	                scaleX: 1,
	                scaleY: 1,
	                ease: easeString
	            });
	        } else t1.to(object, duration, {
	            scaleX: scaleX,
	            scaleY: scaleY,
	            ease: easeString
	        });
	        return t1;
	    };

	    /**
	     * 获取对象至屏幕中心的距离
	     * @param  {[type]} object [description]
	     * @return {[type]}        [description]
	     */
	    animproto._getDirectionInCenter = function (object) {
	        var objInfo = this._getObjectInfo(object);
	        var x = Math.round(this.screenWidth / 2 - objInfo.offsetLeft - objInfo.width / 2);
	        var y = Math.round(this.screenHeight / 2 - objInfo.offsetTop - objInfo.height / 2);
	        return {
	            x: x,
	            y: y
	        };
	    };
	}

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(1);

	var _adv = __webpack_require__(28);

	var _manager = __webpack_require__(6);

	var _fade = __webpack_require__(143);

	var _fade2 = _interopRequireDefault(_fade);

	var _fly = __webpack_require__(144);

	var _fly2 = _interopRequireDefault(_fly);

	var _path = __webpack_require__(145);

	var _path2 = _interopRequireDefault(_path);

	var _rotate = __webpack_require__(146);

	var _rotate2 = _interopRequireDefault(_rotate);

	var _special = __webpack_require__(148);

	var _special2 = _interopRequireDefault(_special);

	var _zoom = __webpack_require__(149);

	var _zoom2 = _interopRequireDefault(_zoom);

	var _shape = __webpack_require__(147);

	var _shape2 = _interopRequireDefault(_shape);

	var _lang = __webpack_require__(3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ROUND = Math.round;
	var CEIL = Math.ceil;

	var isMacOS = Xut.plat.isMacOS;
	var isDesktop = Xut.plat.isDesktop;

	/**
	 * 参数说明
	 * pageType: 页面类型
	 * chapterId: 当前页ID
	 * element: 动画对象
	 * parameter: 动画参数数组
	 * container: 父容器
	 * hasLoop: 是否循环动画
	 * startEvent: 整个动画开始事件
	 * completeEvent: 整个动画结束事件
	 **/

	var Powepoint = function () {
	    function Powepoint(pageIndex, pageType, chapterId, element, parameter, container) {
	        _classCallCheck(this, Powepoint);

	        if (_.isArray(parameter) && parameter.length) {
	            this.options = parameter;
	        } else {
	            console.log("Animation options error is not Array.");
	            return;
	        }

	        this.screenWidth = _index.config.viewSize.width;
	        this.screenHeight = _index.config.viewSize.height;
	        this.container = container || $(document.body); //父容器(主要用于手势控制路径动画)
	        this.isDebug = false; //是否显示调试信息

	        this.pageIndex = pageIndex;
	        this.pageType = pageType;
	        this.chapterId = chapterId;
	        this.element = element;

	        /**
	         * 动画对象默认样式
	         * @type {String}
	         */
	        this.elementStyle = '';

	        /**
	         * 初始化后对象状态
	         * @type {String}
	         */
	        this.elementVisibility = 'visible';

	        /**
	         * 是否使用CSS渐变效果
	         * @type {[type]}
	         */
	        this.useMask = isDesktop || isMacOS ? true : false;

	        /**
	         * 第一个动画参数（默认支持多个动画作用于一个对象）
	         * @type {[type]}
	         */
	        this.parameter0 = null;

	        /**
	         * 第一个动画类型（进入/退出）
	         * @type {Boolean}
	         */
	        this.isExit0 = false;

	        /**
	         * 动画前脚本
	         * @type {String}
	         */
	        this.preCode = '';

	        /**
	         * 动画后脚本
	         * @type {String}
	         */
	        this.postCode = '';

	        /**
	         * 延时
	         * @type {Number}
	         */
	        this.codeDelay = 0;

	        /**
	         * 是否完全执行过(用于解决重复执行问题)
	         * @type {Boolean}
	         */
	        this.isCompleted = false;

	        /**
	         * 初始对象状态:opacity(visibility)
	         */
	        this._initElement();
	    }

	    /**
	     * 解析脚本代码
	     * 包装能函数
	     * @return {[type]} [description]
	     */


	    _createClass(Powepoint, [{
	        key: '_parseCode',
	        value: function _parseCode(code1, code2) {
	            if (code1 && code1.length > 0) {
	                return (0, _lang.makeJsonPack)(code1);
	            } else if (code2 && code2.length > 0) {
	                return (0, _lang.makeJsonPack)(code2);
	            }
	        }

	        /**
	         * 解析延时脚本
	         * @param  {[type]} code1 [description]
	         * @param  {[type]} code2 [description]
	         * @return {[type]}       [description]
	         */

	    }, {
	        key: '_parseDelayCode',
	        value: function _parseDelayCode(code1, code2) {
	            if (code1 && code1.length > 0) {
	                return code1;
	            } else if (code2 && code2.length > 0) {
	                return code2;
	            }
	        }

	        /**
	         * 根据数据库的设置
	         * 对象初始化(visibility)
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initElement',
	        value: function _initElement() {

	            var data = this.options[0];
	            this.parameter0 = (0, _lang.parseJSON)(data.parameter);

	            //为高级动画修改增加
	            //2016.3.16
	            this.parameter0.pageType = this.pageType;
	            this.parameter0.pageIndex = this.pageIndex;

	            this.isExit0 = this.parameter0.exit ? this.parameter0.exit.toLowerCase() == "true" : false;

	            //获取动画前脚本
	            this.preCode = this._parseCode(data.preCode, this.parameter0.preCode);

	            //获取动画后脚本
	            this.postCode = this._parseCode(data.postCode, this.parameter0.postCode);

	            //获取延时时间
	            this.codeDelay = this._parseDelayCode(data.codeDelay, this.parameter0.codeDelay);

	            //给元素增加ppt属性标记
	            if (!this.element.attr("data-pptAnimation")) {
	                var animationName = data.animationName;

	                //路径动画对象默认显示
	                if (animationName.indexOf("EffectPath") == 0 || animationName == "EffectCustom") {
	                    this.element.css("visibility", "visible");
	                } else {
	                    switch (animationName) {
	                        //强调动画默认显示
	                        case "EffectFlashBulb": //脉冲
	                        case "EffectFlicker": //彩色脉冲
	                        case "EffectTeeter": //跷跷板
	                        case "EffectSpin": //陀螺旋转
	                        case "EffectGrowShrink": //放大/缩小
	                        case "EffectDesaturate": //不饱和
	                        case "EffectDarken": //加深
	                        case "EffectLighten": //变淡
	                        case "EffectTransparency": //透明
	                        case "EffectColorBlend": //对象颜色
	                        case "EffectComplementaryColor": //补色
	                        case "EffectChangeLineColor": //线条颜色
	                        case "EffectChangeFillColor": //填允颜色
	                        case "EffectFlashOnce":
	                            //闪烁(一次)
	                            this.element.css("visibility", "visible");
	                            break;
	                        case "EffectCredits":
	                            //字幕式特殊处理
	                            this.element.css("visibility", "hidden");
	                            break;
	                        default:
	                            if (this.isExit0) this.element.css("visibility", "visible"); //退出动画默认显示
	                            else this.element.css("visibility", "hidden"); //进入动画默认隐藏
	                            break;
	                    }
	                }

	                //标识初始化状态
	                this.element.attr("data-pptAnimation", true);
	                this.elementStyle = this.element[0].style.cssText;
	                this.elementVisibility = this.element.css("visibility");
	            }
	        }

	        /**
	         * 获取对象相关信息
	         * @param  {[type]} object [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_getObjectInfo',
	        value: function _getObjectInfo(object) {
	            var width = ROUND(object.width()); //四舍五入取整
	            var height = ROUND(object.height());
	            var top = ROUND(parseInt(object.css("top")));
	            var left = ROUND(parseInt(object.css("left")));
	            var offsetTop = ROUND(object.offset().top);

	            if (object.attr("offsetTop")) {
	                offsetTop = parseInt(object.attr("offsetTop"));
	            } else {
	                object.attr("offsetTop", offsetTop);
	            }

	            var offsetBottom = CEIL(this.screenHeight - offsetTop - height);
	            var offsetLeft = ROUND(object.offset().left);
	            if (object.attr("offsetLeft")) {
	                offsetLeft = parseInt(object.attr("offsetLeft"));
	            } else {
	                object.attr("offsetLeft", offsetLeft);
	            }
	            var offsetRight = CEIL(this.screenWidth - offsetLeft - width);

	            return {
	                width: width,
	                height: height,
	                top: top,
	                left: left,
	                offsetTop: offsetTop,
	                offsetLeft: offsetLeft,
	                offsetBottom: offsetBottom,
	                offsetRight: offsetRight
	            };
	        }

	        /**
	         * 子动画通用开始事件
	         * @param  {[type]} parameter [description]
	         * @param  {[type]} object    [description]
	         * @param  {[type]} params    [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_startHandler',
	        value: function _startHandler(parameter, object, params) {
	            for (var item in params) {
	                switch (item) {
	                    case "x":
	                        TweenLite.set(object, {
	                            x: params[item]
	                        });
	                        break;
	                    case "y":
	                        TweenLite.set(object, {
	                            y: params[item]
	                        });
	                        break;
	                    case "rotation":
	                        TweenLite.set(object, {
	                            rotation: params[item]
	                        });
	                        break;
	                    case "rotationX":
	                        TweenLite.set(object, {
	                            rotationX: params[item]
	                        });
	                        break;
	                    case "rotationY":
	                        TweenLite.set(object, {
	                            rotationY: params[item]
	                        });
	                        break;
	                    case "scale":
	                        TweenLite.set(object, {
	                            scale: params[item]
	                        });
	                        break;
	                    default:
	                        object.css(item, params[item]);
	                        break;
	                }
	            }

	            //ppt动画音频
	            if (parameter.videoId > 0) {
	                (0, _manager.createContentAudio)(parameter.chapterId, parameter.videoId);
	            }

	            /*eslint-disable */

	            //ppt动画扩展处理
	            if (parameter.pptanimation && parameter.pptanimation.pptapi) {

	                var params = parameter.pptanimation.parameters ? parameter.pptanimation.parameters : {};
	                switch (parameter.pptanimation.pptapi) {
	                    case "bonesWidget":
	                        //骨骼动画
	                        bonesWidget.updateAction(object.attr("id"), params.actList);
	                        break;
	                    case "spiritWidget":
	                        // if (window.spiritWidget) {
	                        (0, _adv.updateAction)(object.attr("id"), params);
	                        // }
	                        break;
	                }
	            }

	            /*eslint-enable */
	        }

	        /**
	         * 子动画通用结束事件
	         * @param  {[type]} parameter [description]
	         * @param  {[type]} object    [description]
	         * @param  {[type]} params    [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_completeHandler',
	        value: function _completeHandler(parameter, object, params) {
	            //if(parameter.pptAudio) parameter.pptAudio.end(); //声音存在延时问题，马上结束可导制无法听到声音
	            for (var item in params) {
	                switch (item) {
	                    case "x":
	                        TweenLite.set(object, {
	                            x: params[item]
	                        });
	                        break;
	                    case "y":
	                        TweenLite.set(object, {
	                            y: params[item]
	                        });
	                        break;
	                    case "rotation":
	                        TweenLite.set(object, {
	                            rotation: params[item]
	                        });
	                        break;
	                    case "rotationX":
	                        TweenLite.set(object, {
	                            rotationX: params[item]
	                        });
	                        break;
	                    case "rotationY":
	                        TweenLite.set(object, {
	                            rotationY: params[item]
	                        });
	                        break;
	                    case "scale":
	                        TweenLite.set(object, {
	                            scale: params[item]
	                        });
	                        break;
	                    default:
	                        object.css(item, params[item]);
	                        break;
	                }
	            }
	        }

	        /**
	         * 返回动画对象
	         * @param  {[type]} data  [description]
	         * @param  {[type]} index [description]
	         * @return {[type]}       [description]
	         */

	    }, {
	        key: '_getTimeline',
	        value: function _getTimeline(data, index) {
	            var object = this.element;
	            var parameter = this.parameter0;
	            var isExit = this.isExit0;
	            if (index > 0 || this.parameter0 == null) {
	                parameter = (0, _lang.parseJSON)(data.parameter);
	                isExit = parameter.exit ? parameter.exit.toLowerCase() == "true" : false; //false:进入 true:消失
	                if (index == 0) {
	                    this.parameter0 = parameter;
	                    this.isExit0 = isExit;
	                }
	            }
	            var duration = data.speed / 1000; //执行时间
	            var delay = data.delay / 1000; //延时时间
	            if (navigator.epubReadingSystem) {
	                //如果是epub阅读器则动画延时0.15秒
	                delay += 0.15;
	            }
	            var repeat = data.repeat >= 0 ? data.repeat - 1 : 0; //重复次数
	            parameter.pageType = this.pageType;
	            parameter.chapterId = this.chapterId;
	            parameter.animationName = data.animationName;
	            //赋给动画音频Id
	            parameter.videoId = data.videoId;

	            var animationName = parameter.animationName;

	            //文字动画
	            if (animationName == "xxtTextEffect") {
	                return this.getTextAnimation(parameter, object, duration, delay, repeat);
	            }

	            //路径动画
	            if (animationName.indexOf("EffectPath") == 0 || animationName == "EffectCustom") {
	                return this.getPathAnimation(parameter, object, duration, delay, repeat);
	            }

	            switch (animationName) {
	                case "EffectFade":
	                    //淡出
	                    return this.getEffectFade(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFly":
	                    //飞入/飞出
	                    return this.getEffectFly(parameter, object, isExit, duration, delay, repeat);
	                case "EffectAscend":
	                    //浮入/浮出(上升)
	                    return this.getEffectAscend(parameter, object, isExit, duration, delay, repeat);
	                case "EffectDescend":
	                    //浮入/浮出(下降)
	                    return this.getEffectDescend(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSplit":
	                    //劈裂(分割)
	                    return this.getEffectSplit(parameter, object, isExit, duration, delay, repeat);
	                case "EffectWipe":
	                    //擦除
	                    return this.getEffectWipe(parameter, object, isExit, duration, delay, repeat);
	                case "EffectCircle":
	                    //形状一(圆)
	                    return this.getEffectCircle(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBox":
	                    //形状二(方框)
	                    return this.getEffectBox(parameter, object, isExit, duration, delay, repeat);
	                case "EffectDiamond":
	                    //形状三(菱形)
	                    return this.getEffectDiamond(parameter, object, isExit, duration, delay, repeat);
	                case "EffectPlus":
	                    //形状四(加号)
	                    return this.getEffectPlus(parameter, object, isExit, duration, delay, repeat);
	                case "EffectGrowAndTurn":
	                    //翻转式由远及近
	                    return this.getEffectGrowAndTurn(parameter, object, isExit, duration, delay, repeat);
	                case "EffectZoom":
	                    //基本缩放
	                    return this.getEffectZoom(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFadedZoom":
	                    //淡出式缩放
	                    return this.getEffectFadedZoom(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSwivel":
	                    //基本旋转
	                    return this.getEffectSwivel(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFadedSwivel":
	                    //旋转(淡出式回旋)
	                    return this.getEffectFadedSwivel(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBounce":
	                    //弹跳
	                    return this.getEffectBounce(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBlinds":
	                    //百叶窗
	                    return this.getEffectBlinds(parameter, object, isExit, duration, delay, repeat);
	                case "EffectPeek":
	                    //切入/出
	                    return this.getEffectPeek(parameter, object, isExit, duration, delay, repeat);
	                case "EffectExpand":
	                    //展开/收缩
	                    return this.getEffectExpand(parameter, object, isExit, duration, delay, repeat);
	                case "EffectRiseUp":
	                    //升起/下沉
	                    return this.getEffectRiseUp(parameter, object, isExit, duration, delay, repeat);
	                case "EffectCenterRevolve":
	                    //中心旋转
	                    return this.getEffectCenterRevolve(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSpinner":
	                    //回旋
	                    return this.getEffectSpinner(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFloat":
	                    //浮动
	                    return this.getEffectFloat(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSpiral":
	                    //螺旋飞入/出
	                    return this.getEffectSpiral(parameter, object, isExit, duration, delay, repeat);
	                case "EffectPinwheel":
	                    //玩具风车
	                    return this.getEffectPinwheel(parameter, object, isExit, duration, delay, repeat);
	                case "EffectCredits":
	                    //字幕式
	                    return this.getEffectCredits(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBoomerang":
	                    //飞旋
	                    return this.getEffectBoomerang(parameter, object, isExit, duration, delay, repeat);
	                case "EffectArcUp":
	                    //曲线向上/下
	                    return this.getEffectArcUp(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFlashBulb":
	                    //脉冲
	                    return this.getEffectFlashBulb(parameter, object, duration, delay, repeat);
	                case "EffectFlicker":
	                    //彩色脉冲
	                    return this.getEffectFlicker(parameter, object, duration, delay, repeat);
	                case "EffectTeeter":
	                    //跷跷板
	                    return this.getEffectTeeter(parameter, object, duration, delay, repeat);
	                case "EffectSpin":
	                    //陀螺旋转
	                    return this.getEffectSpin(parameter, object, duration, delay, repeat);
	                case "EffectGrowShrink":
	                    //放大/缩小
	                    return this.getEffectGrowShrink(parameter, object, duration, delay, repeat);
	                case "EffectDesaturate":
	                    //不饱和
	                    return this.getEffectDesaturate(parameter, object, duration, delay, repeat);
	                case "EffectDarken":
	                    //加深
	                    return this.getEffectDarken(parameter, object, duration, delay, repeat);
	                case "EffectLighten":
	                    //变淡
	                    return this.getEffectLighten(parameter, object, duration, delay, repeat);
	                case "EffectTransparency":
	                    //透明
	                    return this.getEffectTransparency(parameter, object, duration, delay, repeat);
	                case "EffectColorBlend":
	                    //对象颜色
	                    return new TimelineMax();
	                case "EffectComplementaryColor":
	                    //补色
	                    return this.getEffectComplementaryColor(parameter, object, duration, delay, repeat);
	                case "EffectChangeLineColor":
	                    //线条颜色
	                    return new TimelineMax();
	                case "EffectChangeFillColor":
	                    //填允颜色
	                    return new TimelineMax();
	                case "EffectFlashOnce":
	                    //闪烁(一次)
	                    return this.getEffectFlashOnce(parameter, object, duration, delay, repeat);
	                //进入退出动画
	                default:
	                case "EffectAppear":
	                    //出现/消失
	                    return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);
	            }
	        }

	        /**
	         * 初始化
	         * @param  {[type]} startEvent    [description]
	         * @param  {[type]} completeEvent [description]
	         * @return {[type]}               [description]
	         */

	    }, {
	        key: '_initAnimation',
	        value: function _initAnimation(completeEvent) {
	            var self = this;

	            /**
	             * 整个动画完成事件(动画不需继续执行视为执行完成)
	             * @return {[type]} [description]
	             */
	            var completeAction = function completeAction() {
	                if (completeEvent && _.isFunction(completeEvent)) {
	                    completeEvent();
	                }
	            };

	            var tl = new TimelineLite({
	                paused: true,
	                onStartParams: [this.preCode],
	                onCompleteParams: [this.postCode, this.codeDelay],
	                onStart: function onStart(preCode) {
	                    //条件判断动画是否执行
	                    if (preCode && _.isFunction(preCode)) {
	                        self.animation.pause();
	                        var result = false;
	                        try {
	                            result = preCode();
	                        } catch (error) {
	                            console.log("Run preCode is error in startHandler:" + error);
	                        }
	                        if (result == true) self.animation.resume();else {
	                            self.animation.stop();
	                            completeAction();
	                        }
	                    }
	                },
	                onComplete: function onComplete(postCode, codeDelay) {
	                    self.isCompleted = true;
	                    //延迟执行postCode代码
	                    try {
	                        if (typeof postCode == "function") {
	                            if (codeDelay > 0) {
	                                setTimeout(postCode, codeDelay);
	                            } else {
	                                postCode();
	                            }
	                        }
	                    } catch (error) {
	                        console.log("Run postCode is error in completeHandler:" + error);
	                    }
	                    completeAction();
	                }
	            });

	            for (var i = 0; i < this.options.length; i++) {
	                if (i == 0) {
	                    tl.add(this._getTimeline(this.options[i], i), "shape0");
	                } else {
	                    var invokeMode = this.options[i].invokeMode;
	                    if (invokeMode == 2) tl.add(this._getTimeline(this.options[i], i));else tl.add(this._getTimeline(this.options[i], i), "shape0"); //"shape"+(i-1)
	                }
	            }
	            return tl;
	        }

	        /**
	         * 执行动画
	         * @param  {[type]} scopeComplete [description]
	         * @return {[type]}               [description]
	         */

	    }, {
	        key: 'play',
	        value: function play(animComplete) {
	            if (this.isCompleted) {
	                this.reset();
	            }
	            this.animation && this.stop();
	            this.animation = this._initAnimation(animComplete);
	            this.animation.play();
	        }

	        /**
	         * 停止动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            if (this.animation instanceof TimelineLite) {
	                this.animation.stop();
	                this.animation.kill();
	                this.animation.clear();
	                this.animation.vars = null;
	            }
	            this.animation = null;
	        }

	        /**
	         * 复位动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            this.animation && this.stop();
	            if (this.elementStyle && this.elementStyle.length) {
	                var origin = this.element.css("-webkit-transform-origin");
	                //卷滚区域里的对象不需要还原
	                if (this.element.attr("isscroll") == null) {
	                    this.element[0].style.cssText = this.elementStyle;
	                }
	                this.element.css("-webkit-transform-origin", origin);
	                this.element.css("visibility", this.elementVisibility);
	                this.element.css("-webkit-transform", "none");
	                this.element[0]["_gsTransform"] = null; //清理对象上绑定的动画属性
	            }
	            this.isCompleted = false;
	        }

	        /**
	         * 销毁动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.stop();
	            this.container = null;
	            this.options = null;
	            this.element = null;
	        }
	    }]);

	    return Powepoint;
	}();

	//动画扩展


	exports.default = Powepoint;
	(0, _fade2.default)(Powepoint.prototype);
	(0, _fly2.default)(Powepoint.prototype);
	(0, _path2.default)(Powepoint.prototype);
	(0, _rotate2.default)(Powepoint.prototype);
	(0, _special2.default)(Powepoint.prototype);
	(0, _zoom2.default)(Powepoint.prototype);
	(0, _shape2.default)(Powepoint.prototype);

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _dom = __webpack_require__(5);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*基本动画类鼠标响应事件*/

	var hasTouch = Xut.plat.hasTouch;

	var MoveMent = function () {
	    function MoveMent(pageType, parentId, objectId, startCallback, moveCallback, endCallback) {
	        _classCallCheck(this, MoveMent);

	        this.hasTouch = hasTouch;
	        this.parent = document.getElementById(parentId);
	        this.scroller = document.getElementById(objectId);
	        this.startCallback = startCallback;
	        this.moveCallback = moveCallback;
	        this.endCallback = endCallback;
	        if (this.scroller == null) {
	            console.error("The control area of the object is empty.");
	            return;
	        }

	        //取消默认翻页行为
	        if (Xut.Contents.ResetDefaultControl) {
	            Xut.Contents.ResetDefaultControl(pageType, parentId);
	        }

	        //注销重复事件
	        if (this.scroller["bindMoveMent"]) {
	            this.scroller["bindMoveMent"].destroy();
	        }

	        (0, _dom.$$on)(this.scroller, {
	            start: this
	        });

	        this.scroller["bindMoveMent"] = this; //实例化对象绑定到元素，便于后期调用
	    }

	    _createClass(MoveMent, [{
	        key: "handleEvent",
	        value: function handleEvent(e) {
	            (0, _dom.$$handle)({
	                start: function start(e) {
	                    this._start(e);
	                },
	                move: function move(e) {
	                    this._move(e);
	                },
	                end: function end(e) {
	                    this._end(e);
	                },
	                cancel: function cancel(e) {
	                    this._end(e);
	                }
	            }, this, e);
	        }
	    }, {
	        key: "_start",
	        value: function _start(e) {
	            e.preventDefault();
	            if (typeof this.startCallback == "function") this.startCallback(e);
	            (0, _dom.$$on)(this.scroller, {
	                move: this,
	                end: this,
	                cancel: this
	            });
	        }
	    }, {
	        key: "_move",
	        value: function _move(e) {
	            if (typeof this.moveCallback == "function") this.moveCallback(e);
	        }
	    }, {
	        key: "_end",
	        value: function _end(e) {
	            (0, _dom.$$off)(this.scroller, {
	                move: this,
	                end: this,
	                cancel: this
	            });
	            if (typeof this.endCallback == "function") this.endCallback(e);
	        }
	    }, {
	        key: "destroy",
	        value: function destroy(type, el, bubble) {
	            (0, _dom.$$off)(this.scroller, {
	                start: this,
	                move: this,
	                end: this,
	                cancel: this
	            });
	            this.scroller = null;
	        }
	    }]);

	    return MoveMent;
	}();

	exports.default = MoveMent;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = css3;

	var _lang = __webpack_require__(3);

	var style = Xut.style; /**
	                        * 普通精灵动画
	                        * dom版本
	                        * css3模式
	                        */

	var keyframes = style.keyframes;
	var animationEnd = style.animationEnd;
	var playState = style.animationPlayState;
	var prefixAnims = style.animation;

	var styleElement = null;

	/**
	 * [ description]动态插入一条样式规则
	 * @param  {[type]} rule [样式规则]
	 * @return {[type]}      [description]
	 */
	function insertCSSRule(rule) {
	    var number, sheet, cssRules;
	    //如果有全局的style样式文件
	    if (styleElement) {
	        number = 0;
	        try {
	            sheet = styleElement.sheet;
	            cssRules = sheet.cssRules;
	            number = cssRules.length;
	            sheet.insertRule(rule, number);
	        } catch (e) {
	            console.log(e);
	        }
	    } else {
	        //创建样式文件
	        styleElement = document.createElement("style");
	        styleElement.type = 'text/css';
	        styleElement.innerHTML = rule;
	        styleElement.uuid = 'aaron';
	        document.head.appendChild(styleElement);
	    }
	}

	/**
	 * [ description]删除一条样式规则
	 * @param  {[type]} ruleName [样式名]
	 * @return {[type]}          [description]
	 */
	function deleteCSSRule(ruleName) {
	    if (styleElement) {
	        var sheet = styleElement.sheet,
	            cssRules = sheet.rules || sheet.cssRules,
	            //取得规则列表
	        i = 0,
	            n = cssRules.length,
	            rule;
	        for (i; i < n; i++) {
	            rule = cssRules[i];
	            if (rule.name === ruleName) {
	                //删除单个规则
	                sheet.deleteRule(i);
	                break;
	            }
	        }
	        //删除style样式
	        if (cssRules.length == 0) {
	            document.head.removeChild(styleElement);
	            styleElement = null;
	        }
	    }
	}

	/**
	 * css3模式
	 * 单图
	 * 矩形图
	 * @param  {[type]} options [description]
	 * @return {[type]}         [description]
	 */
	function css3(options) {

	    var matrix = void 0,
	        parameter = void 0,
	        rule1 = void 0,
	        rule2 = void 0,
	        timer = void 0;

	    var $spriteNode = options.$contentNode.find('.sprite');
	    var data = options.data;
	    var callback = options.callback || function () {};
	    var aniName = 'sprite_' + options.id;
	    var count = data.thecount;
	    var fps = data.fps;
	    var time = Math.round(1 / fps * count * 10) / 10;
	    var width = Math.ceil(data.scaleWidth * count);
	    var loop = data.loop ? 'infinite' : 1;

	    //如果是矩形图
	    if (data.parameter) {
	        parameter = (0, _lang.parseJSON)(data.parameter);
	        if (parameter && parameter.matrix) {
	            matrix = parameter.matrix.split("-");
	        }
	    }

	    /**
	     * 设置精灵动画位置
	     * @param {[type]} aniName [description]
	     * @param {[type]} x       [description]
	     */
	    function setPostion(aniName, x) {
	        //矩阵生成step的处理
	        //  0 1 2
	        //  3 4 5
	        //  6 7 8
	        if (matrix) {
	            var frames = [];
	            var base = 100 / count;
	            var col = Number(matrix[0]); //列数
	            //首次
	            frames.push(0 + '% { background-position:0% 0%}');
	            for (var i = 0; i < count; i++) {
	                // var currRow = Math.ceil((i + 1) / col); //当前行数
	                var currCol = Math.floor(i / col); //当前列数
	                var period = currCol * col; //每段数量
	                x = 100 * (i - period);
	                var y = 100 * currCol;
	                x = x == 0 ? x : "-" + x;
	                y = y == 0 ? y : "-" + y;
	                frames.push((i + 1) * base + '% { background-position: ' + x + '% ' + y + '%}');
	            }
	            return aniName + '{' + frames.join("") + '}';
	        } else {
	            var rule = '{0} {from { background-position:0 0; } to { background-position: -{1}px 0px}}';
	            return String.format(rule, aniName, Math.round(x));
	        }
	    }

	    /**
	     * 格式化样式表达式
	     * 2016.7.15 add paused control
	     * @param {[type]}   [description]
	     */
	    function setStep(aniName, time, count, loop) {
	        var rule;
	        if (matrix) {
	            rule = '{0} {1}s step-start {2}';
	            return String.format(rule, aniName, time, loop);
	        } else {
	            rule = '{0} {1}s steps({2}, end) {3}';
	            return String.format(rule, aniName, time, count, loop);
	        }
	    }

	    /**
	     * 设置动画样式
	     * @param {[type]} rule     [description]
	     */
	    function initStyle(rule) {
	        prefixAnims && $spriteNode.css(prefixAnims, rule).css(playState, 'paused');
	    }

	    /**
	     * 添加到样式规则中
	     * @param {[type]} rule [description]
	     */
	    function setKeyframes(rule) {
	        if (keyframes) {
	            insertCSSRule(keyframes + rule);
	        }
	    }

	    //动画css关键帧规则
	    rule1 = setStep(aniName, time, count, loop);
	    rule2 = setPostion(aniName, width);

	    initStyle(rule1);
	    setKeyframes(rule2);
	    $spriteNode.on(animationEnd, callback);

	    var clearTimer = function clearTimer() {
	        if (timer) {
	            clearTimeout(timer);
	            timer = null;
	        }
	    };

	    return {
	        play: function play() {
	            //添加定时器 解决设备卡顿时普通精灵动画不播放的问题
	            timer = setTimeout(function () {
	                clearTimer();
	                $spriteNode.css(playState, 'running');
	            }, 0);
	        },
	        stop: function stop() {
	            clearTimer();
	            $spriteNode.css(playState, 'paused');
	        },
	        destroy: function destroy() {
	            //停止精灵动画
	            deleteCSSRule(aniName);
	            $spriteNode.off(animationEnd, callback);
	            clearTimer();
	            $spriteNode = null;
	        }
	    };
	}

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = keyframe;

	var _lang = __webpack_require__(3);

	function keyframe(options) {
	    var matrix = void 0,
	        parameter = void 0,
	        timer = void 0,
	        x = void 0,
	        y = void 0;

	    var arrays = [];
	    var t = 0;
	    var $spriteNode = options.$contentNode.find('.sprite');
	    var data = options.data;
	    var callback = options.callback || function () {};

	    var count = data.thecount;
	    var fps = data.fps;
	    var loop = data.loop;
	    var width = data.scaleWidth;
	    var height = data.scaleHeight;

	    //如果是矩形图
	    if (data.parameter) {
	        parameter = (0, _lang.parseJSON)(data.parameter);
	        if (parameter && parameter.matrix) {
	            matrix = parameter.matrix.split("-");
	        }
	    }

	    getCoordinate();
	    //得到坐标：矩阵图：X Y坐标 普通：X坐标
	    function getCoordinate() {
	        //矩阵图
	        if (matrix) {
	            var cols = matrix[0];
	            var rows = matrix[1];
	            for (var i = 0; i < rows; i++) {
	                y = -height * i + 'px';
	                for (var k = 0; k < cols; k++) {
	                    x = -width * k + 'px';

	                    arrays.push(x, y);
	                }
	            }
	            //数组长度大于给定的数量时 删除数组中多余的数据
	            if (arrays.length / 2 > count) {
	                var temp = arrays.length / 2 - count;
	                for (var f = 2 * temp; f > 0; f--) {
	                    arrays.pop();
	                }
	            }
	        } else {
	            for (var i = 0; i < count; i++) {
	                x = -width * i + 'px';
	                arrays.push(x);
	            }
	        }
	    }

	    function start() {
	        if (matrix) {
	            if (t > arrays.length / 2 - 1) {
	                if (loop > 0) {
	                    t = 0;
	                    time();
	                } else {
	                    return;
	                }
	            } else {
	                time();
	            }
	        } else {
	            if (t > count - 1) {
	                if (loop > 0) {
	                    t = 0;
	                    time();
	                } else {
	                    return;
	                }
	            } else {
	                time();
	            }
	        }
	    }

	    function time() {
	        timer = setTimeout(function () {
	            if (matrix) {
	                x = arrays[2 * t];
	                y = arrays[2 * t + 1];
	                $spriteNode.css('backgroundPositionX', x);
	                $spriteNode.css('backgroundPositionY', y);
	            } else {
	                x = arrays[t];
	                $spriteNode.css('backgroundPositionX', x);
	            }
	            t++;
	            start();
	        }, 1000 / fps);
	    }

	    return {
	        play: function play() {
	            start();
	        },

	        stop: function stop() {
	            clearTimeout(timer);
	        },

	        destroy: function destroy() {
	            //停止精灵动画
	            this.stop();
	            t = 0;
	            $spriteNode = null;
	            data = null;
	            arrays = null;
	        }

	    };
	} /**
	   * 帧模式-多图
	   * @param  {[type]} options [description]
	   * @return {[type]}         [description]
	   */

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.pMainBar = pMainBar;
	exports.pDeputyBar = pDeputyBar;

	var _index = __webpack_require__(2);

	/**
	 *
	 * 配置工具栏行为
	 *  1.  工具栏类型
	 *  tbType：(如果用户没有选择任何工具栏信息处理，tbType字段就为空)
	 *   0  禁止工具栏
	 *   1  系统工具栏   - 显示IOS系统工具栏
	 *   2  场景工具栏   - 显示关闭按钮
	 *   3  场景工具栏   - 显示返回按钮
	 *   4  场景工具栏   - 显示顶部小圆点式标示
	 *
	 *  2.  翻页模式
	 *  pageMode：(如果用户没有选择任何处理，pageMode字段就为空)
	 *   0 禁止滑动
	 *   1 允许滑动无翻页按钮
	 *   2 允许滑动带翻页按钮
	 *
	 * @return {[type]} [description]
	 */

	/**
	 * 分解工具栏配置文件
	 * @return {[type]}          [description]
	 */
	var parseTooBar = function parseTooBar(toolbar, toolType, pageMode) {
	    if (toolbar = (0, _index.parseJSON)(toolbar)) {
	        //兼容数据库中未指定的情况
	        var n = Number(toolbar.pageMode);
	        pageMode = _.isFinite(n) ? n : pageMode;
	        if (_.isString(toolbar.tbType)) {
	            toolType = _.map(toolbar.tbType.split(','), function (num) {
	                return Number(num);
	            });
	        }
	    }
	    return {
	        'toolType': toolType,
	        'pageMode': pageMode
	    };
	};

	/**
	 * 主场景工具栏配置
	 * pageMode:默认2 允许滑动,带翻页按钮
	 * @param  {[type]} scenarioId [description]
	 * @return {[type]}            [description]
	 */
	function pMainBar(scenarioId) {
	    var sectionRang = Xut.data.query('sectionRelated', scenarioId);

	    //场景工具栏配置信息
	    var toolbar = sectionRang.toolbar;
	    var pagetotal = sectionRang.length;

	    //默认显示系统工具栏
	    var toolType = [1];

	    //默认2 允许滑动,带翻页按钮
	    var pageMode = pagetotal > 1 ? 2 : 0;

	    return parseTooBar(toolbar, toolType, pageMode);
	}

	/**
	 * 副场景工具栏配置
	 * pageMode 是否支持滑动翻页  0禁止滑动 1允许滑动
	 * toolType   工具栏显示的类型 [0-5]
	 */
	function pDeputyBar(toolbar, pagetotal) {
	    var toolType = [0];
	    var pageMode = pagetotal > 1 ? 1 : 0;
	    return parseTooBar(toolbar, toolType, pageMode);
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.SceneFactory = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(1);

	var _index2 = __webpack_require__(159);

	var _index3 = _interopRequireDefault(_index2);

	var _deputy = __webpack_require__(158);

	var _deputy2 = _interopRequireDefault(_deputy);

	var _index4 = __webpack_require__(165);

	var _index5 = _interopRequireDefault(_index4);

	var _page = __webpack_require__(164);

	var _page2 = _interopRequireDefault(_page);

	var _controller = __webpack_require__(9);

	var _mediator = __webpack_require__(115);

	var _mediator2 = _interopRequireDefault(_mediator);

	var _get = __webpack_require__(7);

	var _scene = __webpack_require__(156);

	var _bar = __webpack_require__(154);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 找到对应容器
	 * @return {[type]}            [description]
	 */
	var findContainer = function findContainer($rootNode, scenarioId, isMain) {
	    return function (pane, parallax) {
	        var node;
	        if (isMain) {
	            node = '#' + pane;
	        } else {
	            node = '#' + parallax + scenarioId;
	        }
	        return $rootNode.find(node)[0];
	    };
	};

	/**
	 * 如果启动了缓存记录
	 * 加载新的场景
	 * @return {[type]} [description]
	 */
	var checkHistory = function checkHistory(history) {

	    //直接启用快捷调试模式
	    if (_index.config.deBugHistory) {
	        Xut.View.LoadScenario(_index.config.deBugHistory);
	        return true;
	    }

	    //如果有历史记录
	    if (history) {
	        var scenarioInfo = _controller.sceneController.seqReverse(history);
	        if (scenarioInfo) {
	            scenarioInfo = scenarioInfo.split('-');
	            Xut.View.LoadScenario({
	                'scenarioId': scenarioInfo[0],
	                'chapterId': scenarioInfo[1],
	                'pageIndex': scenarioInfo[2]
	            });
	            return true;
	        } else {
	            return false;
	        }
	    }
	};

	/**
	 * 场景创建类
	 * @param  {[type]} seasonId               [description]
	 * @param  {[type]} chapterId              [description]
	 * @param  {[type]} createCompleteCallback [创建完毕通知回调]
	 * @param  {[type]} createMode             [创建模式]
	 * @param  {[type]} sceneChainId           [场景ID链,用于后退按钮加载前一个场景]
	 * @return {[type]}                        [description]
	 */

	var SceneFactory = exports.SceneFactory = function () {
	    function SceneFactory(data) {
	        var _this = this;

	        _classCallCheck(this, SceneFactory);

	        //基本配置信息
	        var seasonId = data.seasonId;
	        var chapterId = data.chapterId;

	        var options = _.extend(this, data, {
	            'scenarioId': seasonId,
	            'chapterId': chapterId,
	            '$container': $('.xut-scene-container')
	        });

	        //创建主场景
	        this._createHTML(options, function () {
	            //配置工具栏行为
	            if (!Xut.IBooks.Enabled) {
	                _.extend(_this, _this._initToolBar());
	            }
	            //构建Mediator对象
	            _this._createMediator();
	            //注入场景管理
	            _controller.sceneController.add(seasonId, chapterId, _this);
	        });
	    }

	    /**
	     * 创建场景
	     * @return {[type]} [description]
	     */


	    _createClass(SceneFactory, [{
	        key: '_createHTML',
	        value: function _createHTML(options, callback) {

	            //如果是静态文件执行期
	            //支持Xut.IBooks模式
	            //都不需要创建节点
	            if (Xut.IBooks.runMode()) {
	                this.$rootNode = $('#xut-main-scene');
	                callback();
	                return;
	            }

	            var layout = void 0;

	            if (options.isMain) {
	                layout = (0, _scene.mainScene)();
	            } else {
	                layout = (0, _scene.deputyScene)(this.scenarioId);
	            }

	            this.$rootNode = $(layout);

	            Xut.nextTick({
	                'container': this.$container,
	                'content': this.$rootNode
	            }, callback);
	        }

	        /**
	         * 初始化工具栏
	         * 1 主场景，系统工具栏
	         * 2 副场景，函数工具栏
	         * 3 全场景，页码显示（右下角）
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initToolBar',
	        value: function _initToolBar() {
	            var scenarioId = this.scenarioId;
	            var pageTotal = this.pageTotal;
	            var pageIndex = this.pageIndex;
	            var $rootNode = this.$rootNode;
	            var findControlBar = function findControlBar() {
	                return $rootNode.find('.xut-control-bar');
	            };

	            //配置文件
	            var barConfig = {};

	            //主场景工具栏设置
	            if (this.isMain) {
	                barConfig = (0, _bar.pMainBar)(scenarioId, pageTotal);
	                if (_index.config.visualMode === 1) {
	                    //word模式,自动启动工具条
	                    this.mainToolbar = new _index5.default({
	                        sceneNode: $rootNode,
	                        controlNode: findControlBar(),
	                        pageMode: barConfig.pageMode
	                    });
	                }
	                //如果工具拦提供可配置
	                //或者config.pageMode 带翻页按钮
	                else if (_.some(barConfig.toolType)) {
	                        //普通模式
	                        this.mainToolbar = new _index3.default({
	                            sceneNode: $rootNode,
	                            controlNode: findControlBar(),
	                            pageTotal: pageTotal,
	                            currentPage: pageIndex + 1,
	                            pageMode: barConfig.pageMode,
	                            toolType: barConfig.toolType
	                        });
	                    }
	            }
	            //副场景
	            else {
	                    //副场工具栏配置
	                    barConfig = (0, _bar.pDeputyBar)(this.barInfo, pageTotal);
	                    if (_.some(barConfig.toolType)) {
	                        this.deputyToolbar = new _deputy2.default({
	                            sceneNode: $rootNode,
	                            toolType: barConfig.toolType,
	                            pageTotal: pageTotal,
	                            currentPage: pageIndex,
	                            pageMode: barConfig.pageMode
	                        });
	                    }
	                }

	            //2016.9.29
	            //新增页码显示
	            //如果有分栏
	            var flowCounts = (0, _get.getFlowCount)(this.seasonId);
	            if (_index.config.toolType.number !== false && flowCounts) {
	                //获取分栏的chapter数，总数需要减去
	                var flowChpterCount = (0, _get.getFlowChpaterCount)(this.seasonId);
	                this.numberToolbar = new _page2.default({
	                    $rootNode: $rootNode,
	                    currentPage: pageIndex,
	                    pageTotal: pageTotal + flowCounts - flowChpterCount
	                });
	            }

	            return barConfig;
	        }

	        /**
	         * 构建创建对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createMediator',
	        value: function _createMediator() {
	            var _this2 = this;

	            var self = this;
	            var scenarioId = this.scenarioId;
	            var pageTotal = this.pageTotal;
	            var pageIndex = this.pageIndex;
	            var $rootNode = this.$rootNode;
	            var isMain = this.isMain;
	            var tempfind = findContainer($rootNode, scenarioId, isMain);

	            //页面容器
	            var scenarioPage = tempfind('xut-page-container', 'scenarioPage-');
	            //视差容器
	            var scenarioMaster = tempfind('xut-master-container', 'scenarioMaster-');

	            //场景容器对象
	            var vm = this.vm = new _mediator2.default({
	                'pageMode': this.pageMode,
	                'container': this.$rootNode[0],
	                'multiScenario': !isMain,
	                'rootPage': scenarioPage,
	                'rootMaster': scenarioMaster,
	                'initIndex': pageIndex, //保存索引从0开始
	                'pagetotal': pageTotal,
	                'sectionRang': this.sectionRang,
	                'scenarioId': scenarioId,
	                'chapterId': this.chapterId,
	                'isInApp': this.isInApp //提示页面
	            });

	            /**
	             * 配置选项
	             * @type {[type]}
	             */
	            var isToolbar = this.isToolbar = this.deputyToolbar ? this.deputyToolbar : this.mainToolbar;

	            /**
	             * 监听翻页
	             * 用于更新页码
	             *   parentIndex  父索引
	             *   subIndex     子索引
	             * @return {[type]} [description]
	             */
	            vm.$bind('pageUpdate', function () {
	                isToolbar && isToolbar.updatePointer.apply(isToolbar, arguments);
	                if (_this2.numberToolbar) {
	                    var _numberToolbar;

	                    _this2.numberToolbar && (_numberToolbar = _this2.numberToolbar).updatePointer.apply(_numberToolbar, arguments);
	                }
	            });

	            /**
	             * 显示下一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('showNext', function () {
	                isToolbar && isToolbar.showNext();
	            });

	            /**
	             * 隐藏下一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('hideNext', function () {
	                isToolbar && isToolbar.hideNext();
	            });

	            /**
	             * 显示上一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('showPrev', function () {
	                isToolbar && isToolbar.showPrev();
	            });

	            /**
	             * 隐藏上一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('hidePrev', function () {
	                isToolbar && isToolbar.hidePrev();
	            });

	            /**
	             * 切换工具栏
	             * state, pointer
	             * @return {[type]} [description]
	             */
	            vm.$bind('toggleToolbar', function () {
	                isToolbar && isToolbar.toggle.apply(isToolbar, arguments);
	                if (_this2.numberToolbar) {
	                    var _numberToolbar2;

	                    _this2.numberToolbar && (_numberToolbar2 = _this2.numberToolbar).toggle.apply(_numberToolbar2, arguments);
	                }
	            });

	            /**
	             * 复位工具栏
	             * @return {[type]} [description]
	             */
	            vm.$bind('resetToolbar', function () {
	                if (_this2.mainToolbar) {
	                    _this2.mainToolbar.resetArrow(); //左右翻页按钮
	                    _this2.mainToolbar.hideNavbar(); //导航栏
	                }
	            });

	            /**
	             * 监听创建完成
	             * @return {[type]} [description]
	             */
	            vm.$bind('createComplete', function (nextAction) {
	                self.complete && setTimeout(function () {
	                    if (isMain) {
	                        self.complete(function () {
	                            Xut.View.HideBusy();
	                            //检测是不是有缓存加载
	                            if (!checkHistory(self.history)) {
	                                //指定自动运行的动作
	                                nextAction && nextAction();
	                            }
	                            //全局接口,应用加载完毕
	                            Xut.Application.AddEventListener();
	                        });
	                    } else {
	                        self.complete(nextAction);
	                    }
	                }, 200);
	            });

	            //如果是读酷端加载
	            if (window.DUKUCONFIG && isMain && window.DUKUCONFIG.success) {
	                window.DUKUCONFIG.success();
	                vm.$init();
	                //如果是客户端加载
	            } else if (window.CLIENTCONFIGT && isMain && window.CLIENTCONFIGT.success) {
	                window.CLIENTCONFIGT.success();
	                vm.$init();
	            } else {
	                //正常加载
	                vm.$init();
	            }
	        }

	        /**
	         * 销毁场景对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {

	            //销毁当前场景
	            this.vm.$destroy();

	            //销毁工具栏
	            if (this.isToolbar) {
	                this.isToolbar.destroy();
	                this.isToolbar = null;
	            }

	            this.$container = null;

	            //销毁节点
	            this.$rootNode.off();
	            this.$rootNode.remove();
	            this.$rootNode = null;

	            //销毁引用
	            _controller.sceneController.remove(this.scenarioId);
	        }
	    }]);

	    return SceneFactory;
	}();

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.mainScene = mainScene;
	exports.deputyScene = deputyScene;

	var _index = __webpack_require__(1);

	var round = Math.round; /**
	                         * 布局文件
	                         * 1 控制条
	                         * 2 导航栏
	                         * @param  {[type]} config [description]
	                         * @return {[type]}        [description]
	                         */

	var ratio = 6;
	var isIOS = Xut.plat.isIOS;
	var TOP = isIOS ? 20 : 0;

	/**
	 * 主场景
	 * @return {[type]} [description]
	 */
	function mainScene() {

	    var iconHeight = _index.config.iconHeight;
	    var proportion = _index.config.proportion;

	    var sWidth = _index.config.viewSize.width;
	    var sHeight = _index.config.viewSize.height;

	    //横版模式
	    var isHorizontal = _index.config.layoutMode == 'horizontal';

	    proportion = isHorizontal ? proportion.width : proportion.height;
	    iconHeight = isIOS ? iconHeight : round(proportion * iconHeight);

	    var navBarWidth = isHorizontal ? '100%' : Math.min(sWidth, sHeight) / (isIOS ? 8 : 3) + 'px';
	    var navBarHeight = isHorizontal ? round(sHeight / ratio) : round((sHeight - iconHeight - TOP) * 0.96);
	    var navBarTop = isHorizontal ? '' : 'top:' + (iconHeight + TOP + 2) + 'px;';
	    var navBarLeft = isHorizontal ? '' : 'left:' + iconHeight + 'px;';
	    var navBarBottom = isHorizontal ? 'bottom:4px;' : '';
	    var navBaroOverflow = isHorizontal ? 'hidden' : 'visible';

	    //导航
	    var navBarHTML = '<div class="xut-nav-bar"\n              style="width:' + navBarWidth + ';\n                     height:' + navBarHeight + 'px;\n                     ' + navBarTop + '\n                     ' + navBarLeft + '\n                     ' + navBarBottom + '\n                     background-color:white;\n                     border-top:1px solid rgba(0,0,0,0.1);\n                     overflow:' + navBaroOverflow + ';">\n        </div>';

	    var homeWidth = _index.config.viewSize.width;
	    // const homeHeight = config.viewSize.height
	    var homeLeft = _index.config.viewSize.left;
	    var homeIndex = Xut.sceneController.createIndex();
	    var homeOverflow = _index.config.visualMode === 1 ? 'visible' : 'hidden';

	    //主体
	    var homeHTML = '<div id="xut-main-scene"\n              style="width:' + homeWidth + 'px;\n                     height:100%;\n                     top:0;\n                     left:' + homeLeft + 'px;\n                     position:absolute;\n                     z-index:' + homeIndex + ';\n                     overflow:' + homeOverflow + ';">\n\n            <div id="xut-control-bar" class="xut-control-bar"></div>\n            <ul id="xut-page-container" class="xut-flip"></ul>\n            <ul id="xut-master-container" class="xut-master xut-flip"></ul>\n            ' + navBarHTML + '\n            <div id="xut-tool-tip"></div>\n        </div>';

	    return String.styleFormat(homeHTML);
	}

	/**
	 * 副场景
	 * @param  {[type]} options [description]
	 * @return {[type]}         [description]
	 */
	function deputyScene(id) {

	    var scenarioId = 'scenario-' + id;
	    var overflow = _index.config.visualMode === 1 ? 'visible' : 'hidden';
	    var pageId = 'scenarioPage-' + id;
	    var masterId = 'scenarioMaster-' + id;

	    var html = '<div id="' + scenarioId + '"\n              style="width:' + _index.config.viewSize.width + 'px;\n                     height:100%;\n                     left:' + _index.config.viewSize.left + 'px;\n                     z-index:' + Xut.sceneController.createIndex() + ';\n                     position:absolute;\n                     overflow:' + overflow + ';">\n            <ul id="' + pageId + '" class="xut-flip" style="z-index:2"></ul>\n            <ul id="' + masterId + '" class="xut-flip" style="z-index:1"></ul>\n        </div>';

	    return String.styleFormat(html);
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = api;

	var _depend = __webpack_require__(42);

	function api(Swipe) {

	    /**
	     * 获取初始化距离值
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.getInitDistance = function () {
	        return this._initDistance;
	    };

	    /**
	     * 模拟完成状态调用
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.simulationComplete = function () {
	        var _this = this;

	        setTimeout(function () {
	            _this._restore();
	            _this._unlockSwipe();
	        });
	    };

	    //允许滑动
	    Swipe.prototype.allowliding = function () {
	        this._unlockSwipe();
	    };

	    //禁止滑动
	    Swipe.prototype.bansliding = function () {
	        this._lockSwipe();
	    };

	    /**
	     * 停止翻页
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.openSwipe = function () {
	        this._initOperation();
	    };

	    /**
	     * 启动翻页
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.closeSwipe = function () {
	        if (!this._isMoving) {
	            this._off();
	        }
	    };

	    /**
	     * 是否为边界
	     * @param  {[type]}  distance [description]
	     * @return {Boolean}          [description]
	     */
	    Swipe.prototype.isBorder = function () {
	        this._borderBounce.apply(this, arguments);
	    };

	    /**
	     * 检车是否还在移动中
	     * @return {Boolean} [description]
	     */
	    Swipe.prototype.isMoving = function () {
	        return this._isMoving;
	    };

	    /**
	     * 前翻页接口
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.prev = function () {
	        if (!this._borderBounce(1)) {
	            this._slideTo('prev');
	        } else {
	            //边界反弹
	            this._setRebound(this._hindex, 'next');
	        }
	    };

	    /**
	     * 后翻页接口
	     * @return {Function} [description]
	     */
	    Swipe.prototype.next = function () {
	        if (!this._borderBounce(-1)) {
	            this._slideTo('next');
	        } else {
	            //边界反弹
	            this._setRebound(this._hindex, 'prev');
	        }
	    };

	    /**
	     * 获取当前页码
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.getHindex = function () {
	        return this._hindex;
	    };

	    /**
	     * 主动设置页码编号
	     * 因为分栏的关系，内部修改外部
	     * 页面需要拼接
	     */
	    Swipe.prototype.setPointer = function (target, pagetotal) {
	        this.pagePointer = (0, _depend.initPointer)(target, pagetotal || this.pagetotal);
	    };

	    /**
	     * 获取页面Pointer
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.getPointer = function () {
	        return this.pagePointer;
	    };

	    /**
	     * 跳指定页面
	     * @param  {[type]} targetIndex [description]
	     * @param  {[type]} preMode     [description]
	     * @param  {[type]} complete    [description]
	     * @return {[type]}             [description]
	     */
	    Swipe.prototype.scrollToPage = function (targetIndex) {
	        //目标页面

	        //如果还在翻页中
	        if (this._fliplock) return;

	        var currIndex = this._hindex; //当前页面

	        //相邻页
	        switch (targetIndex) {
	            //前一页
	            case currIndex - 1:
	                if (this.options.multiplePages) {
	                    return this.prev();
	                }
	                break;
	            //首页
	            case currIndex:
	                if (currIndex == 0) {
	                    this.$emit('onDropApp');
	                }
	                return;
	            //后一页
	            case currIndex + 1:
	                if (this.options.multiplePages) {
	                    return this.next();
	                }
	                break;
	        }

	        //算出是相关数据
	        var data = (0, _depend.calculationIndex)(currIndex, targetIndex, this.pagetotal);

	        //更新页码索引
	        this._updataPointer(data);

	        data.pagePointer = this.pagePointer;

	        this.$emit('onJumpPage', data);
	    };

	    /**
	     * 销毁所有
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.destroy = function () {
	        this._off();
	        this.$off();
	        if (this._bubbleNode) {
	            this._bubbleNode.page = null;
	            this._bubbleNode.master = null;
	        }
	        this.container = null;
	    };

	    /**
	     * 调用动画完成
	     * @param {[type]} element [description]
	     */
	    Swipe.prototype.setTransitionComplete = function () {
	        this._distributed.apply(this, arguments);
	    };

	    /**
	     * 目标元素
	     * 找到li元素
	     * @param  {Function} callback [description]
	     * @return {[type]}            [description]
	     */
	    Swipe.prototype.findBubbleRootNode = function (point, pageType) {
	        var liNode = void 0,
	            map = void 0;
	        var _hindex = this._hindex;
	        var sectionRang = this.options.sectionRang;

	        //找到对应的li
	        var childNodes = this._bubbleNode[pageType].childNodes;
	        var nodeTotal = childNodes.length;

	        while (nodeTotal--) {
	            liNode = childNodes[nodeTotal];
	            map = liNode.getAttribute('data-map');
	            if (sectionRang) {
	                _hindex += sectionRang.start;
	            }
	            if (map == _hindex) {
	                return liNode;
	            }
	            _hindex = this._hindex;
	        }
	    };
	}

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _bar = __webpack_require__(25);

	var _bar2 = _interopRequireDefault(_bar);

	var _index = __webpack_require__(1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 函数工具栏
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var isIOS = Xut.plat.isIOS;

	var closeScenario = function closeScenario() {
	    Xut.View.CloseScenario();
	};

	var fnBar = function (_Bar) {
	    _inherits(fnBar, _Bar);

	    function fnBar() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            pageMode = _ref.pageMode,
	            sceneNode = _ref.sceneNode,
	            toolType = _ref.toolType,
	            pageTotal = _ref.pageTotal,
	            currentPage = _ref.currentPage;

	        _classCallCheck(this, fnBar);

	        var _this = _possibleConstructorReturn(this, (fnBar.__proto__ || Object.getPrototypeOf(fnBar)).call(this));

	        _this.pageTips = null;
	        _this.currTip = null;
	        _this.tipsMode = 0;
	        _this.top = _this.super_barHeight;
	        _this.Lock = false;
	        _this.delay = 50;
	        _this.hasTopBar = false;
	        _this.barStatus = true;

	        //options
	        _this.pageMode = pageMode;
	        _this.$sceneNode = sceneNode;
	        _this.toolType = toolType;
	        _this.pageTotal = pageTotal;
	        _this.currentPage = currentPage;

	        _this._initTool();
	        return _this;
	    }

	    /**
	     * 创建工具栏
	     * toolType:
	     *      0   禁止工具栏
	     *      1   系统工具栏   - 显示IOS系统工具栏
	     *      2   场景工具栏   - 显示关闭按钮
	     *      3   场景工具栏   - 显示返回按钮
	     *      4   场景工具栏   - 显示顶部小圆点式标示
	     *  pageMode:
	     *      0禁止滑动
	     *      1允许滑动无翻页按钮
	     *      2 允许滑动带翻页按钮
	     * @return {[type]} [description]
	     */


	    _createClass(fnBar, [{
	        key: '_initTool',
	        value: function _initTool() {
	            var $sceneNode = this.$sceneNode;

	            var type = void 0;

	            $sceneNode.hide();

	            this.controlBar = [];
	            //配置工具栏
	            while (type = this.toolType.shift()) {
	                switch (type) {
	                    case 1:
	                        this._createSystemBar();
	                        break;
	                    case 2:
	                        this._createCloseIcon();
	                        break;
	                    case 3:
	                        this._createBackIcon();
	                        break;
	                    case 4:
	                        this._createPageTips();
	                        break;
	                    default:
	                        this.barStatus = false;
	                        this.hasTopBar = false;
	                        break;
	                }
	            }

	            //创建翻页按钮
	            if (this.pageMode === 2) {
	                this.super_createArrows();
	            }

	            $sceneNode.show();
	        }

	        /**
	         * 系统工具栏
	         */

	    }, {
	        key: '_createSystemBar',
	        value: function _createSystemBar() {
	            var html = '<div class="xut-control-bar"\n                         style="top:0;height:' + this.super_iconHeight + 'px;padding-top:' + this.top + 'px">\n                    </div>';
	            html = $(String.styleFormat(html));
	            this.super_showSystemBar();
	            this._createBackIcon(html);
	            this._createTitle(html);
	            this._createPageNum(html);
	            this.controlBar = html;
	            this.$sceneNode.append(html);
	            this.hasTopBar = true;
	        }

	        /**
	         * 页码小圆点
	         */

	    }, {
	        key: '_createPageTips',
	        value: function _createPageTips() {
	            var _this2 = this;

	            var chapters = this.pageTotal;
	            var height = this.super_iconHeight;
	            var html = '';

	            //li内容
	            var content = '';

	            //如果只有一页则不显示小圆
	            if (chapters < 2) {
	                return html;
	            }

	            //圆点尺寸
	            var size = isIOS ? 7 : Math.max(8, Math.round(this.super_propHeight * 8));
	            var width = 2.5 * size; //圆点间距
	            var tipsWidth = chapters * width; //圆点总宽度
	            var top = (height - size) / 2; //保持圆点垂直居中
	            var left = (_index.config.viewSize.width - tipsWidth) / 2; //保持圆点水平居中


	            for (var i = 1; i <= chapters; i++) {
	                content += '<li class="xut-scenario-dark" \n                      style="float:left;width:' + width + 'px;height:' + height + 'px;" \n                      data-index="' + i + '">\n                    <div class="xut-scenario-radius" \n                          style="width:' + size + 'px;height:' + size + 'px;margin:' + top + 'px auto">\n                    </div>\n                </li>';
	            }

	            html = '<ul class="xut-scenario-tips"  \n                    style="top:' + this.top + 'px;left:' + left + 'px;width:' + tipsWidth + 'px;opacity:0.6">\n                    ' + content + '\n                </ul>';

	            html = $(String.styleFormat(html));

	            //点击跳转页面
	            this.$tipsNode = html;
	            this.$tipsNode.on('click', function (e) {
	                var target = e.target;
	                switch (target.className) {
	                    case 'xut-control-nav-hide':
	                        _this2.hideTopBar();
	                        break;
	                    case 'xut-scenario-dark':
	                        if (_this2.pageMode) {
	                            var index = target.getAttribute('data-index') || 1;
	                            Xut.View.GotoSlide(Number(index));
	                        }
	                        break;
	                    default:
	                        break;
	                }
	            });
	            this.pageTips = html.children();
	            this.tipsMode = 1;
	            this.controlBar.push(html);
	            this.$sceneNode.append(html);
	        }

	        /**
	         * 更新页码指示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer(_ref2) {
	            var parentIndex = _ref2.parentIndex;

	            switch (this.tipsMode) {
	                case 1:
	                    if (this.prevTip) {
	                        this.prevTip.className = 'xut-scenario-dark';
	                    }
	                    this.currTip = this.pageTips[parentIndex];
	                    this.currTip.className = 'xut-scenario-light';
	                    this.prevTip = this.currTip;
	                    break;
	                case 2:
	                    this.currTip.html(parentIndex + 1);
	                    break;
	                default:
	                    break;
	            }
	        }
	    }, {
	        key: '_onBackClose',
	        value: function _onBackClose(el) {
	            el.on("mouseup touchend", function (e) {
	                closeScenario();
	                return false;
	            });
	            return function () {
	                el.off();
	                el = null;
	            };
	        }

	        /**
	         * font字体版本：关闭按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createCloseIcon',
	        value: function _createCloseIcon() {
	            var height = this.super_iconHeight;
	            var html = $('<div class="si-icon xut-scenario-close icomoon icon-close" \n                style="top:' + this.top + 'px;width:' + height + 'px;height:' + height + 'px;line-height:' + height + 'px;text-align:center;font-size:3vh;">\n            </div>');

	            this.$closeIcon = html;
	            this._onBackClose(this.$closeIcon);
	            this.controlBar.push(html);
	            this.$sceneNode.append(html);
	        }

	        /**
	         * font字体版本：返回按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createBackIcon',
	        value: function _createBackIcon() {
	            var height = this.super_iconHeight;
	            var html = $('<div class="si-icon xut-scenario-back icomoon icon-arrow-left" \n                  style="top:' + this.top + 'px;width:' + height + 'px;height:' + height + 'px;line-height:' + height + 'px;">\n            </div>');

	            this.$backIcon = html;
	            this._onBackClose(this.$backIcon);
	            this.controlBar.push(html);
	            this.$sceneNode.append(html);
	        }

	        /**
	         * 创建页码数
	         * @param  {[type]} $sceneNode [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_createPageNum',
	        value: function _createPageNum($sceneNode) {
	            var pageTotal = this.pageTotal,
	                TOP = this.top,
	                height = this.super_iconHeight,
	                currentPage = this.currentPage,
	                style,
	                html;

	            html = '<div class="xut-control-pageindex" \n                  style="position:absolute;\n                         right:4px;\n                         top:' + (height * 0.25 + TOP) + 'px;\n                         padding:0 0.25em;\n                         height:' + height * 0.5 + 'px;\n                         line-height:' + height * 0.5 + 'px;\n                         border-radius:0.5em">\n                <span class="currentPage">' + currentPage + '</span>/<span>' + pageTotal + '</span>\n            </div>';
	            html = $(String.styleFormat(html));
	            this.tipsMode = 2;
	            this.currTip = html.children().first();
	            $sceneNode.append(html);
	        }

	        /**
	         * 应用标题
	         * @param  {[type]} $sceneNode [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_createTitle',
	        value: function _createTitle($sceneNode) {
	            var html = '<div class="xut-control-title"\n                  style="line-height:' + this.super_iconHeight + 'px">\n                ' + this.appName + '\n            </div>';
	            $sceneNode.append(String.styleFormat(html));
	        }

	        /**
	         * 显示顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showTopBar',
	        value: function showTopBar() {
	            var that = this,
	                delay = this.delay,
	                controlBar = this.controlBar;
	            if (this.barStatus) {
	                this.Lock = false;
	                return;
	            }
	            if (this.hasTopBar) {
	                controlBar.css({
	                    'display': 'block',
	                    'opacity': 0
	                });
	                setTimeout(function () {
	                    controlBar.transition({
	                        'opacity': 1
	                    }, delay, 'linear', function () {
	                        that.__showSystemBar();
	                        that.barStatus = true;
	                        that.Lock = false;
	                    });
	                });
	            } else {
	                controlBar.forEach(function (el) {
	                    el.show();
	                    that.Lock = false;
	                    that.barStatus = true;
	                });
	            }
	        }

	        /**
	         * 隐藏顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideTopBar',
	        value: function hideTopBar() {
	            var that = this,
	                delay = this.delay,
	                controlBar = this.controlBar;

	            if (!this.barStatus) {
	                this.Lock = false;
	                return;
	            }
	            if (this.hasTopBar) {
	                controlBar.transition({
	                    'opacity': 0
	                }, delay, 'linear', function () {
	                    that.controlBar.hide();
	                    that.__hideSystemBar();
	                    that.barStatus = false;
	                    that.Lock = false;
	                });
	            } else {
	                controlBar.forEach(function (el) {
	                    el.hide(delay, function () {
	                        that.Lock = false;
	                        that.barStatus = false;
	                    });
	                });
	            }
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$sceneNode = null;
	            this.controlBar = null;
	            this.pageTips = null;
	            this.currTip = null;
	            this.prevTip = null;

	            //小图标点击事件
	            if (this.$tipsNode) {
	                this.$tipsNode.off();
	                this.$tipsNode = null;
	            }

	            //关闭按钮
	            if (this.$closeIcon) {
	                this.$closeIcon.off();
	                this.$closeIcon = null;
	            }

	            //返回按钮
	            if (this.$backIcon) {
	                this.$backIcon.off();
	                this.$backIcon = null;
	            }

	            //销毁超类
	            this.super_destory();
	        }
	    }]);

	    return fnBar;
	}(_bar2.default);

	exports.default = fnBar;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _bar = __webpack_require__(25);

	var _bar2 = _interopRequireDefault(_bar);

	var _index = __webpack_require__(160);

	var _index2 = _interopRequireDefault(_index);

	var _str = __webpack_require__(163);

	var _index3 = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 系统工具栏
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 主场景工具栏
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


	var sysBar = function (_Bar) {
	    _inherits(sysBar, _Bar);

	    function sysBar() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            controlNode = _ref.controlNode,
	            sceneNode = _ref.sceneNode,
	            pageMode = _ref.pageMode,
	            pageTotal = _ref.pageTotal,
	            currentPage = _ref.currentPage,
	            toolType = _ref.toolType;

	        _classCallCheck(this, sysBar);

	        var _this = _possibleConstructorReturn(this, (sysBar.__proto__ || Object.getPrototypeOf(sysBar)).call(this));

	        _this.curTips = null; //当前页码对象
	        _this.Lock = false; //操作锁
	        _this.delay = 50; //动画延时
	        _this.hasTopBar = true; //有顶部工具条

	        _this.$controlNode = controlNode; //导航控制条节点
	        _this.eventElement = controlNode[0]; //绑定事件
	        _this.$sceneNode = sceneNode; //场景根节点
	        _this.pageTotal = pageTotal;
	        _this.currentPage = currentPage;

	        //顶部工具栏可配置
	        //0 禁止工具栏
	        //1 系统工具栏 - 显示IOS系统工具栏
	        _.some(toolType) && _this._initToolbar();

	        //翻页按钮
	        pageMode == 2 && _this.super_createArrows();
	        return _this;
	    }

	    /**
	     * 初始化顶部工具栏
	     * @return {[type]} [description]
	     */


	    _createClass(sysBar, [{
	        key: '_initToolbar',
	        value: function _initToolbar() {

	            var $controlNode = this.$controlNode;
	            var setting = this.settings;
	            var iconHeight = this.super_iconHeight;

	            //工具栏的显示状态
	            this.toolBarStatus = $controlNode.css('display') === 'none' ? false : true;

	            //工具栏摆放位置
	            this._toolbarPostion($controlNode, setting.ToolbarPos);

	            var html = '';

	            //首页按钮
	            if (setting.HomeBut) {
	                html += (0, _str.createHomeIcon)(iconHeight);
	            }

	            //目录按钮
	            if (setting.ContentBut) {
	                html += (0, _str.createDirIcon)(iconHeight);
	            }

	            //添加标题
	            html += (0, _str.createTitle)(iconHeight, this.appName);

	            //工具栏隐藏按钮
	            html += (0, _str.createHideToolbar)(iconHeight);

	            //关闭子文档
	            if (setting.CloseBut) {
	                html += (0, _str.createCloseIcon)(iconHeight);
	            }

	            //页码数
	            if (setting.PageBut) {
	                html += (0, _str.createPageNumber)(iconHeight, this.currentPage, this.pageTotal);
	            }

	            //显示
	            Xut.nextTick($controlNode.append(String.styleFormat(html)));

	            //当前页码标识
	            this.curTips = $controlNode.find('.control-current-page');

	            //事件
	            (0, _index3.$$on)(this.eventElement, {
	                start: this
	            });
	        }

	        /**
	         * 相应事件
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {
	            (0, _index3.$$handle)({
	                start: function start(e) {
	                    switch ((0, _index3.$$target)(e).className) {
	                        //跳主页
	                        case "xut-control-backhome":
	                            (0, _str.goHomePage)();
	                            break;
	                        //切换目录
	                        case "xut-control-navbar":
	                            this._toggleNavBar();
	                            break;
	                        //隐藏工具栏
	                        case 'xut-control-hidebar':
	                            this.hideTopBar();
	                            break;
	                    }
	                }
	            }, this, e);
	        }

	        /**
	         * 系统工具条的位置
	         * position
	         *     0 顶部
	         *     1 底部
	         * @param  {[type]} bar      [description]
	         * @param  {[type]} position [description]
	         * @return {[type]}          [description]
	         */

	    }, {
	        key: '_toolbarPostion',
	        value: function _toolbarPostion($controlNode, position) {
	            var height = this.super_iconHeight;
	            if (position == 1) {
	                //在底部
	                $controlNode.css({
	                    bottom: 0,
	                    height: height + 'px'
	                });
	            } else {
	                //在顶部
	                $controlNode.css({
	                    top: 0,
	                    height: height + 'px',
	                    paddingTop: this.super_barHeight + 'px'
	                });
	            }
	        }

	        /**
	         * 切换目录导航
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_toggleNavBar',
	        value: function _toggleNavBar() {
	            var pageIndex = Xut.Presentation.GetPageIndex();
	            if (this.navbarObj) {
	                this.navbarObj.toggle(pageIndex);
	            } else {
	                this.navbarObj = new _index2.default(pageIndex);
	            }
	        }

	        /**
	         * 更新页码指示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer(_ref2) {
	            var parentIndex = _ref2.parentIndex;

	            this.curTips && this.curTips.html(parentIndex + 1);
	        }

	        /**
	         * 隐藏导航栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideNavbar',
	        value: function hideNavbar() {
	            this.navbarObj && this.navbarObj.hide('hide');
	        }

	        /**
	         * 显示顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showTopBar',
	        value: function showTopBar() {
	            var self = this;

	            if (this.toolBarStatus) {
	                this.Lock = false;
	                return;
	            }
	            this.$controlNode.css({
	                'display': 'block',
	                'opacity': 0
	            });

	            self.$controlNode && self.$controlNode.transition({
	                'opacity': 1
	            }, self.delay, 'in', function () {
	                self.hideNavbar();
	                self.super_showSystemBar();
	                self.toolBarStatus = true;
	                self.Lock = false;
	            });
	        }

	        /**
	         * 隐藏顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideTopBar',
	        value: function hideTopBar() {
	            var self = this;

	            if (!this.toolBarStatus) {
	                this.Lock = false;
	                return;
	            }

	            this.$controlNode && this.$controlNode.transition({
	                'opacity': 0
	            }, self.delay, 'in', function () {
	                self.hideNavbar();
	                self.$controlNode.hide();
	                self.super_hideSystemBar();
	                self.toolBarStatus = false;
	                self.Lock = false;
	            });
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            //目录导航
	            this.navbarObj && this.navbarObj.destroy();

	            //解除事件
	            (0, _index3.$$off)(this.eventElement, {
	                start: this
	            });

	            //销毁超类
	            this.super_destory();

	            this.curTips = null;
	            this.toolBarStatus = false;
	            this.$controlNode = null;
	            this.eventElement = null;
	        }
	    }]);

	    return sysBar;
	}(_bar2.default);

	exports.default = sysBar;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 目录列表
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param  {[type]} hindex    [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param  {[type]} pageArray [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param  {[type]} modules   [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @return {[type]}           [description]
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _struct = __webpack_require__(162);

	var _struct2 = _interopRequireDefault(_struct);

	var _section = __webpack_require__(161);

	var _section2 = _interopRequireDefault(_section);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Navbar = function () {
	    _createClass(Navbar, [{
	        key: 'toggle',


	        /**
	         * 切换
	         * @param  {[type]} pageIndex [description]
	         * @return {[type]}           [description]
	         */
	        value: function toggle(pageIndex) {
	            this.pageIndex = pageIndex;
	            this._navControl();
	        }

	        /**
	         * 隐藏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hide',
	        value: function hide() {
	            this.isRunning && this._navControl();
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this.sectionObj) {
	                this.sectionObj.destroy();
	                this.sectionObj = null;
	            }
	            this.$container = null;
	            this.$button = null;
	        }
	    }]);

	    function Navbar(pageIndex) {
	        _classCallCheck(this, Navbar);

	        this.pageIndex = pageIndex;
	        this.isRunning = false; //运行状态
	        this.$container = $(".xut-nav-bar"); //显示容器
	        this.$button = $(".xut-control-navbar"); //触发按钮
	        this._initialize();
	    }

	    _createClass(Navbar, [{
	        key: '_initialize',
	        value: function _initialize() {
	            var _this = this;

	            var data = [];
	            Xut.data.query('Chapter', Xut.data.novelId, 'seasonId', function (item) {
	                return data.push(item);
	            });
	            Xut.nextTick({
	                'container': this.$container,
	                'content': (0, _struct2.default)(data)
	            }, function () {
	                _this.sectionObj = new _section2.default(data); //目录对象
	                _this.sectionObj.userIscroll(_this.pageIndex); //初始化滑动
	                _this.sectionObj.createThumb(); //初始缩略图
	                _this._navControl(); //初始化样式
	            });
	        }

	        /**
	         * 控制导航条
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_navControl',
	        value: function _navControl() {

	            var action = this.$button.attr('fly') || 'in'; //判断点击的动作
	            var isIn = action === 'in';

	            //初始化目录栏的样式
	            //能够显示出来
	            if (isIn) {
	                this.$container.css({
	                    'z-index': 0,
	                    'opacity': 0,
	                    'display': 'block'
	                });
	            }

	            //触发控制条
	            this.$button.css('opacity', isIn ? 0.5 : 1);

	            //执行动画
	            //出现
	            if (isIn) {
	                //导航需要重置
	                //不同的页面定位不一定
	                this.sectionObj.refresh();
	                this.sectionObj.scrollTo(this.pageIndex);

	                //动画出现
	                this.$container.css({
	                    'z-index': Xut.zIndexlevel(),
	                    'opacity': 1
	                });
	                this.$button.attr('fly', 'out');
	                this.isRunning = true;
	            } else {
	                //隐藏
	                this.$button.attr('fly', 'in');
	                this.$container.hide();
	                this.isRunning = false;
	            }
	        }
	    }]);

	    return Navbar;
	}();

	exports.default = Navbar;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(1);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 下拉章节列表
	 */
	var Section = function () {
	    function Section(data) {
	        _classCallCheck(this, Section);

	        this._isHorizontal = _index.config.layoutMode === 'horizontal';
	        this._pagedata = data;
	        this._$section = $('#xut-nav-section-list');
	        this._$list = this._$section.find("li");
	    }

	    /**
	     * 卷滚条
	     * @param  {[type]} pageIndex [description]
	     * @return {[type]}           [description]
	     */


	    _createClass(Section, [{
	        key: 'userIscroll',
	        value: function userIscroll(pageIndex) {
	            var _this = this;

	            var isHorizontal = this._isHorizontal;

	            if (this.hBox) {
	                if (isHorizontal) {
	                    this.hBox.goToPage(pageIndex, 0, 0);
	                } else {
	                    this.hBox.goToPage(0, pageIndex, 0);
	                }
	            } else {
	                this.hBox = new iScroll('#xut-nav-wrapper', {
	                    snap: 'li',
	                    tap: true,
	                    scrollX: isHorizontal,
	                    scrollY: !isHorizontal,
	                    scrollbars: true,
	                    fadeScrollbars: true,
	                    stopPropagation: true
	                });

	                //滑动结束,动态处理缩略图
	                this.hBox.on('scrollEnd', function (e) {
	                    _this.createThumb();
	                    _this._removeThumb();
	                });

	                this._$section.on('tap', this._toJump);
	            }
	        }

	        /**
	         * 点击元素跳转
	         */

	    }, {
	        key: '_toJump',
	        value: function _toJump(e) {
	            var target = e.target;
	            var xxtlink = void 0;
	            if (target) {
	                var _xxtlink = target.getAttribute('data-xxtlink');
	                if (_xxtlink) {
	                    _xxtlink = _xxtlink.split('-');
	                    Xut.View.GotoSlide(_xxtlink[0], _xxtlink[1]);
	                }
	            }
	        }

	        /**
	         * [ 创建缩略图]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createThumb',
	        value: function createThumb() {
	            var index = this._getPageIndex(),
	                //最左边的索引
	            count = this._getViewLen(),
	                //允许显示的页数
	            createBak = this.createBak || [],
	                //已创建的页码索引
	            createNew = [],
	                //新建的页码索引
	            pageData = this._pagedata,
	                maxLen = pageData.length,
	                path = _index.config.pathAddress;

	            //确保不会溢出
	            count = count > maxLen ? maxLen : count;
	            //尽可能地填满
	            index = index + count > maxLen ? maxLen - count : index;

	            var i = 0;
	            var j = void 0;
	            var page = void 0;

	            for (i = 0; i < count; i++) {
	                j = index + i;
	                page = pageData[j];
	                createNew.push(j);
	                if (_.contains(createBak, j)) continue;
	                createBak.push(j);

	                //如果是分层母板了,此时用icon代替
	                if (page.iconImage) {
	                    this._$list.eq(j).css({
	                        'background-image': 'url(' + path + page.iconImage + ')'
	                    });
	                } else {
	                    this._$list.eq(j).css({
	                        'background-image': 'url(' + path + page.md5 + ')',
	                        'background-color': 'white'
	                    });
	                }
	            }

	            this.createNew = createNew;
	            this.createBak = createBak;
	        }

	        /**
	         * [ 清理隐藏的缩略图]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_removeThumb',
	        value: function _removeThumb() {
	            var list = this._$list;
	            var createNew = this.createNew;
	            var createBak = this.createBak;

	            _.each(createBak, function (val, i) {
	                if (!_.contains(createNew, val)) {
	                    //标记要清理的索引
	                    createBak[i] = -1;
	                    list.eq(val).css({
	                        'background': ''
	                    });
	                }
	            });

	            //执行清理
	            this.createBak = _.without(createBak, -1);
	        }

	        /**
	         * [ 得到滑动列表中最左侧的索引]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_getPageIndex',
	        value: function _getPageIndex() {
	            if (this.hBox.options.scrollX) {
	                return this.hBox.currentPage.pageX;
	            } else {
	                return this.hBox.currentPage.pageY;
	            }
	        }

	        /**
	         * [ 获取待创建的缩略图的个数]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_getViewLen',
	        value: function _getViewLen() {
	            var hBox = this.hBox,
	                eleSize = 1,
	                //单个li的高度,
	            count = 1,
	                len = this._pagedata.length; //li的总数

	            if (this._isHorizontal) {
	                eleSize = hBox.scrollerWidth / len;
	                count = hBox.wrapperWidth / eleSize;
	            } else {
	                eleSize = hBox.scrollerHeight / len;
	                count = hBox.wrapperHeight / eleSize;
	            }
	            //多创建一个
	            return Math.ceil(count) + 1;
	        }

	        /**
	         * 滚动指定位置
	         */

	    }, {
	        key: 'scrollTo',
	        value: function scrollTo(pageIndex) {
	            this.userIscroll(pageIndex);
	        }

	        /**
	         * 刷新
	         */

	    }, {
	        key: 'refresh',
	        value: function refresh() {
	            this.hBox && this.hBox.refresh();
	        }

	        /**
	         * 销毁
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this.hBox) {
	                this._$section.off();
	                this._$section = null;
	                this._$list = null;
	                this.hBox.destroy();
	                this.hBox = null;
	            }
	            this._pagedata = null;
	        }
	    }]);

	    return Section;
	}();

	exports.default = Section;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = navLayout;

	var _index = __webpack_require__(1);

	var round = Math.round;
	var ratio = 6;
	var isIOS = Xut.plat.isIOS;
	var TOP = isIOS ? 20 : 0;

	var getNavOptions = function getNavOptions() {

	    var iconHeight = _index.config.iconHeight;
	    var proportion = _index.config.proportion;
	    var viewSize = _index.config.viewSize;

	    //横版模式
	    var isHorizontal = _index.config.layoutMode == 'horizontal';

	    proportion = isHorizontal ? proportion.width : proportion.height;
	    iconHeight = isIOS ? iconHeight : round(proportion * iconHeight);

	    //导航菜单宽高
	    var navHeight = void 0,
	        navWidth = void 0;
	    var sWidth = viewSize.width;
	    var sHeight = viewSize.height;

	    //横版模版
	    if (isHorizontal) {
	        navHeight = round(sHeight / ratio);
	    } else {
	        navWidth = Math.min(sWidth, sHeight) / (isIOS ? 8 : 3);
	        navHeight = round((sHeight - iconHeight - TOP) * 0.96);
	    }

	    return {
	        sWidth: sWidth,
	        sHeight: sHeight,
	        navHeight: navHeight,
	        navWidth: navWidth,
	        proportion: proportion
	    };
	};

	/**
	 * 获得css配置数据
	 * @param  {[type]} seasonlist [description]
	 * @return {[type]}            [description]
	 */
	var getWrapper = function getWrapper(seasonlist) {

	    var width = void 0,
	        height = void 0,
	        blank = void 0,
	        scroller = void 0,
	        contentstyle = void 0,
	        containerstyle = void 0,
	        overwidth = void 0,
	        overHeigth = void 0;

	    //获得css配置数据
	    var options = getNavOptions();
	    var font = round(options.proportion * 2);

	    var navWidth = options.navWidth;
	    var navHeight = options.navHeight;
	    var sWidth = options.sWidth;
	    var sHeight = options.sHeight;

	    if (_index.config.layoutMode == 'horizontal') {
	        height = round(navHeight * 0.9);
	        width = round(height * sWidth / sHeight); //保持缩略图的宽高比
	        blank = round(navHeight * 0.05); //缩略图之间的间距
	        scroller = 'width:' + seasonlist * (width + blank) + 'px>';
	        contentstyle = 'float:left;width:' + width + 'px;height:' + height + 'px;margin-left:' + blank + 'px';
	        containerstyle = 'width:96%;height:' + height + 'px;margin:' + blank + 'px auto;font-size:' + font + 'em';
	        //横版左右滑动
	        //溢出长度+上偏移量
	        overwidth = width * seasonlist + seasonlist * blank;
	    } else {
	        width = round(navWidth * 0.9);
	        height = round(navWidth * 1.1);
	        blank = round(navWidth * 0.05);
	        contentstyle = 'width:' + width + 'px;height:' + height + 'px;margin:' + blank + 'px auto;border-bottom:1px solid rgba(0,0,0,0.3)';
	        containerstyle = 'height:' + (navHeight - 4) + 'px;overflow:hidden;margin:2px auto;font-size:' + font + 'em';
	        //竖版上下滑动
	        overHeigth = height * seasonlist + seasonlist * blank;
	    }

	    return {
	        contentstyle: contentstyle,
	        containerstyle: containerstyle,
	        overwidth: overwidth,
	        overHeigth: overHeigth,
	        scroller: scroller
	    };
	};

	/**
	 * 导航菜单
	 * @param  {[type]} seasonSqlRet [description]
	 * @return {[type]}              [description]
	 */
	function navLayout(results) {

	    var seasonlist = results.length;
	    var options = getWrapper(seasonlist);

	    var list = '';
	    var seasonId = void 0;
	    var chapterId = void 0;
	    var data = void 0;
	    var xxtlink = void 0;

	    for (var i = 0; i < seasonlist; i++) {
	        data = results[i];
	        seasonId = data.seasonId;
	        chapterId = data._id;
	        xxtlink = seasonId + '-' + chapterId;
	        list += '<li style="' + options.contentstyle + '">\n                <div data-xxtlink="' + xxtlink + '">\n                    ' + (i + 1) + '\n                </div>\n           </li>';
	    }

	    //导航
	    var navHTML = '<div id="xut-nav-wrapper" style="' + options.containerstyle + '">\n            <div style="width:' + options.overwidth + 'px;\n                                           height:' + options.overHeigth + 'px;\n                                           ' + options.scroller + '">\n                <ul id="xut-nav-section-list">\n                    ' + list + '\n                </ul>\n            </div>\n        </div>';

	    return String.styleFormat(navHTML);
	}

/***/ },
/* 163 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.goHomePage = goHomePage;
	exports.createHomeIcon = createHomeIcon;
	exports.createDirIcon = createDirIcon;
	exports.createTitle = createTitle;
	exports.createPageNumber = createPageNumber;
	exports.createHideToolbar = createHideToolbar;
	exports.createCloseIcon = createCloseIcon;
	/**
	 * 跳转首页
	 * @return {[type]} [description]
	 */
	function goHomePage() {
	    if (window.DUKUCONFIG) {
	        Xut.Application.Suspend({
	            processed: function processed() {
	                Xut.Application.DropApp(); //退出应用
	            }
	        });
	        return;
	    }
	    //动作处理
	    //如果有动作则关闭，否则直接跳转
	    Xut.Application.Suspend({
	        processed: function processed() {
	            Xut.View.GotoSlide(1);
	        }
	    });
	}

	/**
	 * 创建主页按钮
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createHomeIcon(height) {
	    return "<div class=\"xut-control-backhome\"\n                 style=\"float:left;text-indent:0.25em;height:" + height + "px;line-height:" + height + "px;color:#007aff\">\n                \u4E3B\u9875\n            </div>";
	}

	/**
	 * 创建目录按钮
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createDirIcon(height) {
	    return "<div class=\"xut-control-navbar\"\n                 style=\"float:left;margin-left:4px;width:" + height + "px;height:" + height + "px;background-size:cover\">\n            </div>";
	}

	/**
	 * 应用标题
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createTitle(height, appName) {
	    return "<div class=\"xut-control-title\"\n                 style=\"z-index:-99;width:100%;position:absolute;line-height:" + height + "px;pointer-events:none\">\n                " + appName + "\n            </div>";
	}

	/**
	 * 创建页码数
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createPageNumber(height, currentPage, pageTotal) {
	    var marginTop = height * 0.25;
	    var iconH = height * 0.5;
	    return "<div class=\"xut-control-pageIndex\"\n                 style=\"float:right;\n                        margin:" + marginTop + "px 4px;\n                        padding:0 0.25em;\n                        height:" + iconH + "px;\n                        line-height:" + iconH + "px;\n                        border-radius:0.5em\">\n                  <span class=\"control-current-page\">" + currentPage + "</span>/<span>" + pageTotal + "</span>\n            </div>";
	}

	/**
	 * 工具栏隐藏按钮
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createHideToolbar(height) {
	    return "<div class=\"xut-control-hidebar\"\n                 style=\"float:right;width:" + height + "px;height:" + height + "px;background-size:cover\">\n            </div>";
	}

	/**
	 * 关闭子文档按钮(font字体版本)
	 * @param  {[type]} height [description]
	 * @return {[type]}        [description]
	 */
	function createCloseIcon(height) {
	    return "<div class=\"si-icon icomoon icon-close\"\n                 style=\"float:right;margin-right:4px;width:" + height + "px;height:" + height + "px\">\n            </div>";
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _index = __webpack_require__(1);

	var _get = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 页码显示
	 */
	var NumberBar = function () {
	    function NumberBar(_ref) {
	        var _this = this;

	        var $rootNode = _ref.$rootNode,
	            pageTotal = _ref.pageTotal,
	            currentPage = _ref.currentPage;

	        _classCallCheck(this, NumberBar);

	        this.$container = this._createDom(pageTotal);
	        this.$currtNode = this.$container.find('div:first');
	        this.$allNode = this.$container.find('div:last');

	        this.toolBarStatus = true;

	        Xut.nextTick(function () {
	            $rootNode.append(_this.$container);
	        });
	    }

	    _createClass(NumberBar, [{
	        key: '_createDom',
	        value: function _createDom(pageTotal) {
	            //存在模式3的情况，所以页码要处理溢出的情况。left值
	            var right = 0;
	            if (_index.config.viewSize.overflowWidth) {
	                right = Math.abs(_index.config.viewSize.left) + 'px';
	            }
	            return $('<div class="xut-page-number" style="right:' + right + ';">\n                <div>1</div>\n                <strong>/</strong>\n                <div>' + pageTotal + '</div>\n             </div>');
	        }
	    }, {
	        key: '_showToolBar',
	        value: function _showToolBar() {
	            this.$container.show();
	        }
	    }, {
	        key: '_hideToolBar',
	        value: function _hideToolBar() {
	            this.$container.hide();
	        }
	    }, {
	        key: 'toggle',
	        value: function toggle(state, pointer) {
	            if (pointer !== 'pageNumber') return;
	            switch (state) {
	                case 'show':
	                    this._showToolBar();
	                    break;
	                case 'hide':
	                    this._hideToolBar();
	                    break;
	                default:
	                    //默认：工具栏显示隐藏互斥处理
	                    this.toolBarStatus ? this._hideToolBar() : this._showToolBar();
	                    break;
	            }
	        }

	        /**
	         * 更新页码
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer(_ref2) {
	            var _this2 = this;

	            var action = _ref2.action,
	                direction = _ref2.direction,
	                parentIndex = _ref2.parentIndex,
	                _ref2$hasSon = _ref2.hasSon,
	                hasSon = _ref2$hasSon === undefined ? false : _ref2$hasSon,
	                _ref2$sonIndex = _ref2.sonIndex,
	                sonIndex = _ref2$sonIndex === undefined ? 0 : _ref2$sonIndex;


	            var chapterData = Xut.Presentation.GetPageData('page', parentIndex);

	            //从正索引开始
	            ++parentIndex;

	            //默认，需要拿到前置的总和(出去当前)
	            var beforeCount = (0, _get.getBeforeCount)(chapterData.seasonId, chapterData._id);
	            var updateIndex = parentIndex + beforeCount + sonIndex;

	            //前翻页，需要叠加flow的总和
	            if (direction === 'prev') {
	                //前翻页：内部翻页
	                if (hasSon) {
	                    updateIndex = parentIndex + beforeCount + sonIndex - 2;
	                }
	                //前翻页：外部往内部翻页，正好前一页是内部页，所以需要获取内部页总和
	                else {
	                        //前翻页，需要拿到当期那到前置的总和
	                        updateIndex = parentIndex + (0, _get.getCurrentBeforeCount)(chapterData.seasonId, chapterData._id);
	                    }
	            }

	            Xut.nextTick(function () {
	                _this2.$currtNode.text(updateIndex);
	                if (action === 'init') {
	                    _this2.$container.show();
	                }
	            });
	        }
	    }]);

	    return NumberBar;
	}();

	exports.default = NumberBar;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mark = __webpack_require__(166);

	var _mark2 = _interopRequireDefault(_mark);

	var _index = __webpack_require__(2);

	var _dom = __webpack_require__(5);

	var _bar = __webpack_require__(25);

	var _bar2 = _interopRequireDefault(_bar);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * 阅读模式工具栏
	 * @param options object
	 * @demo {$sceneNode:页面容器,$controlNode:工具栏容器,...}
	 * @desc 继承自Toolbar.js
	 */
	var BookBar = function (_Bar) {
	    _inherits(BookBar, _Bar);

	    function BookBar() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            pageMode = _ref.pageMode,
	            sceneNode = _ref.sceneNode,
	            controlNode = _ref.controlNode;

	        _classCallCheck(this, BookBar);

	        //工具栏父容器
	        var _this = _possibleConstructorReturn(this, (BookBar.__proto__ || Object.getPrototypeOf(BookBar)).call(this));

	        _this.$sceneNode = sceneNode;

	        //工具栏容器
	        _this.$controlNode = controlNode;

	        _this.pageMode = pageMode;

	        //是否有顶部工具栏
	        _this.hasTopBar = true;
	        _this.Lock = false;
	        _this.delay = 50;

	        //图书工具栏高度
	        _this.topBarHeight = _this.super_iconHeight * 1.25;

	        _this.initTool();
	        return _this;
	    }

	    /**
	     * 初始化
	     */


	    _createClass(BookBar, [{
	        key: 'initTool',
	        value: function initTool() {

	            //工具栏的显示状态
	            var display = this.$controlNode.css('display');
	            this.barStatus = display == 'none' ? false : true;
	            this.setToolbarStyle();

	            this.createBackIcon();
	            this.createDirIcon();
	            this.createMarkIcon();

	            // this.createStarIcon();

	            //翻页按钮
	            if (this.pageMode == 2) {
	                this.super_createArrows();
	            }

	            //监听事件
	            (0, _dom.$$on)(this.$sceneNode[0], {
	                end: this
	            });
	        }

	        /**
	         * 工具条的样式
	         */

	    }, {
	        key: 'setToolbarStyle',
	        value: function setToolbarStyle() {
	            var height = this.topBarHeight;

	            //在顶部
	            this.$controlNode.css({
	                top: 0,
	                height: height + 'px',
	                paddingTop: this.super_barHeight + 'px', //系统工具栏占用的高度
	                backgroundColor: 'rgba(0, 0, 0, 0.2)', //transparent
	                fontSize: '0.625em',
	                color: 'white'
	            });
	        }

	        /**
	         * 更新页码
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer() {}
	        //预留


	        /**
	         *  font版本：创建目录图标
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createDirIcon',
	        value: function createDirIcon() {
	            var parent = document.createElement('div');
	            var icon = document.createElement('div');
	            var iconText = document.createElement('div');

	            parent.style.width = '48px';
	            parent.style.height = "100%";
	            parent.style.float = "left";
	            parent.style.marginLeft = "3vw";
	            parent.style.cursor = "pointer";
	            parent.style.position = "relative";

	            icon.style.fontSize = "2.5vh";
	            icon.style.color = "#fff";
	            icon.className = 'icomoon icon-th-list2';
	            icon.style.position = "absolute";
	            icon.style.bottom = this.super_iconHeight * 0.5 + 'px';

	            iconText.innerHTML = '目录';
	            iconText.className = "xut-book-dirFont";
	            // iconText.style.height = "40%";
	            // iconText.style.width = "100%";
	            iconText.style.position = "absolute";
	            iconText.style.bottom = "0";

	            parent.appendChild(icon);
	            parent.appendChild(iconText);
	            this.$controlNode.append(parent);
	        }

	        /**
	         * font版本：创建书签图标
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createMarkIcon',
	        value: function createMarkIcon() {
	            var parent = document.createElement('div');
	            var icon = document.createElement('div');
	            var iconText = document.createElement('div');

	            parent.style.width = '48px';
	            parent.style.height = "100%";
	            parent.style.float = "left";
	            parent.style.marginLeft = "1vw";
	            parent.style.cursor = "pointer";
	            parent.style.position = "relative";

	            icon.style.fontSize = "2.5vh";
	            icon.style.color = "#fff";
	            icon.style.position = "absolute";
	            icon.style.bottom = this.super_iconHeight * 0.5 + 'px';
	            icon.className = 'icomoon icon-bookmark2';

	            iconText.innerHTML = '书签';
	            iconText.className = "xut-book-markFont";
	            //iconText.style.height = "40%";
	            iconText.style.position = "absolute";
	            iconText.style.bottom = "0";

	            parent.appendChild(icon);
	            parent.appendChild(iconText);
	            this.$controlNode.append(parent);
	        }

	        /**
	         * 创建评分图标
	         */

	    }, {
	        key: 'createStarIcon',
	        value: function createStarIcon(bar) {
	            var icon = document.createElement('div');
	            icon.innerHTML = '评分';
	            icon.style.width = this.super_iconHeight + 'px';
	            icon.style.lineHeight = 1.5 * this.topBarHeight + 'px';
	            icon.className = 'xut-book-bar-star';
	            this.$controlNode.append(icon);
	        }

	        /**
	         * font字体版本：后退按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createBackIcon',
	        value: function createBackIcon() {
	            var icon = document.createElement('div');
	            icon.style.width = this.topBarHeight + 'px';
	            icon.style.lineHeight = this.topBarHeight + 'px';
	            icon.style.color = "#fff";

	            icon.className = 'icomoon icon-angle-left icon-book-bar';
	            icon.style.fontSize = "6vh";
	            this.$controlNode.append(icon);
	        }

	        /**
	         * 显示顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showTopBar',
	        value: function showTopBar() {
	            var that = this;

	            if (this.barStatus) {
	                this.Lock = false;
	                return;
	            }

	            this.$controlNode.css({
	                'display': 'block',
	                'opacity': 0
	            });

	            setTimeout(function () {
	                that.$controlNode.transition({
	                    'opacity': 1
	                }, that.delay, 'linear', function () {
	                    that.super_showSystemBar();
	                    that.barStatus = true;
	                    that.Lock = false;
	                });
	            }, 50);
	        }

	        /**
	         * 隐藏顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideTopBar',
	        value: function hideTopBar() {
	            var that = this;

	            if (!this.barStatus) {
	                this.Lock = false;
	                return;
	            }

	            this.$controlNode.transition({
	                'opacity': 0
	            }, that.delay, 'linear', function () {
	                that.$controlNode.hide();
	                that.super_hideSystemBar();
	                that.barStatus = false;
	                that.Lock = false;
	            });
	        }
	    }, {
	        key: 'hideNavbar',
	        value: function hideNavbar() {}

	        /**
	         * 创建目录菜单
	         */

	    }, {
	        key: 'createDirMenu',
	        value: function createDirMenu() {
	            var self = this;
	            var wrap = document.createElement('div');
	            var mask = document.createElement('div');
	            //添加遮层
	            mask.className = 'xut-book-menu-mask';
	            //获取内容
	            this.getDirContent();
	            wrap.className = 'xut-book-menu';
	            wrap.innerHTML = '<ul>' + this.contentText + '</ul>';
	            this.$sceneNode.append(wrap);
	            //是否滚动
	            this.isScrolled = false;

	            //添加滚动条
	            //url : http://iscrolljs.com/
	            this.iscroll = new iScroll(wrap, {
	                scrollbars: true,
	                fadeScrollbars: true,
	                scrollX: false
	            });

	            this.menu = wrap;

	            this.setColor();

	            this.iscroll.on('scrollStart', function (e) {
	                self.isScrolled = true;
	            });

	            this.iscroll.on('scrollEnd', function (e) {
	                self.isScrolled = false;
	            });

	            wrap.appendChild(mask);
	        }

	        /**
	         *  显示目录菜单
	         */

	    }, {
	        key: 'showDirMenu',
	        value: function showDirMenu() {
	            //获取当前页面
	            var page = Xut.Presentation.GetPageElement();

	            if (this.menu) {
	                this.menu.style.display = 'block';
	            } else {
	                this.createDirMenu();
	            }

	            //添加模糊效果
	            page.addClass('filter');
	            this.page = page;

	            //隐藏顶部工具栏
	            this.$controlNode.hide();
	            var iscroll = this.iscroll;
	            //自动定位到上一位置
	            if (iscroll.y > iscroll.wrapperHeight) {
	                iscroll.scrollToElement(this.selectedChild);
	            }
	        }

	        /**
	         *  隐藏目录菜单
	         */

	    }, {
	        key: 'hideDirMenu',
	        value: function hideDirMenu() {
	            this.menu.style.display = 'none';
	            //恢复顶部工具栏
	            this.$controlNode.show();
	            //移除模糊效果
	            this.page.removeClass('filter');
	        }

	        /**
	         *  创建目录内容
	         */

	    }, {
	        key: 'getDirContent',
	        value: function getDirContent() {

	            var Api = Xut.Presentation;
	            var data = Api.GetAppSectionData();
	            var sns = data[0];
	            var seaonId = sns._id;
	            var cids = Xut.data.Chapter;

	            ////////////////////////////
	            //针对book模式，合并了Season的参数 //
	            //1 SeasonTitle
	            //2 ChapterList列表的范围区间
	            ////////////////////////////
	            data = (0, _index.parseJSON)(sns.parameter);

	            if (!data) {
	                console.log('book模式parameter数据出错');
	                return;
	            }

	            //二级目录
	            function secondaryDirectory(startCid, endCid) {
	                var cid,
	                    str = '';
	                for (startCid; startCid <= endCid; startCid++) {
	                    cid = cids.item(startCid - 1);
	                    if (cid && cid.chapterTitle) {
	                        str += '<section><a class="xut-book-menu-item" data-mark=' + seaonId + '-' + startCid + ' href="javascript:0">' + cid.chapterTitle + '</a></section>';
	                    }
	                }
	                return str;
	            }

	            var i = 0;
	            var len = data.length;
	            var li = '<li class="title"><center class="select">目录</center></li>';
	            var seasonInfo, mark, seasonTitle, seaonId, startCid, endCid;

	            for (i; i < len; i++) {
	                seasonInfo = data[i];
	                startCid = seasonInfo.ChapterList[0];
	                endCid = seasonInfo.ChapterList[1];
	                mark = seaonId + '-' + startCid;
	                if (seasonInfo.SeasonTitle.length <= 0) continue;
	                seasonTitle = seasonInfo.SeasonTitle || '第' + (i + 1) + '章';
	                //第一级目录
	                li += '<li>' + '<a class="xut-book-menu-item" data-mark="' + mark + '" href="javascript:0">' + seasonTitle + '</a>' +
	                //第二级目录
	                secondaryDirectory(startCid, endCid) + '</li>';
	            }

	            this.contentText = li;
	        }

	        /**
	         * 突出显示点击颜色
	         */

	    }, {
	        key: 'setColor',
	        value: function setColor(element) {
	            if (this.selectedChild) {
	                this.selectedChild.className = 'xut-book-menu-item';
	            }
	            element = element || this.menu.querySelectorAll('li')[1].children[0];
	            element.className = 'select';
	            this.selectedChild = element;
	        }

	        /**
	         * 跳转到指定书页
	         */

	    }, {
	        key: 'turnToPage',
	        value: function turnToPage(target) {
	            //忽略滚动点击
	            if (this.isScrolled) return;
	            this.setColor(target);
	            this.hideDirMenu();
	            var data = target.dataset.mark || '';
	            if (data) {
	                data = data.split('-');
	                Xut.View.LoadScenario({
	                    'scenarioId': data[0],
	                    'chapterId': data[1]
	                });
	            }
	        }

	        /**
	         * 显示书签
	         */

	    }, {
	        key: 'showBookMark',
	        value: function showBookMark() {
	            if (this.bookMark) {
	                this.bookMark.restore();
	            } else {
	                var pageData = Xut.Presentation.GetPageData();
	                this.bookMark = new _mark2.default({
	                    parent: this.$sceneNode,
	                    seasonId: pageData.seasonId,
	                    pageId: pageData._id
	                });
	            }
	        }

	        /**
	         * 返回首页
	         */

	    }, {
	        key: 'goBack',
	        value: function goBack() {
	            var self = this;
	            Xut.Application.Suspend({
	                processed: function processed() {
	                    Xut.View.GotoSlide(1); //调整到首页
	                    self.setColor();
	                }
	            });
	        }

	        /**
	         * 相应事件
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {
	            var target = e.target || e.srcElement;
	            (0, _dom.$$handle)({
	                end: function end(e) {
	                    switch ((0, _dom.$$target)(e).className) {
	                        case 'icomoon icon-angle-left icon-book-bar':
	                            this.goBack();
	                            //返回
	                            break;
	                        case 'icomoon icon-th-list2':
	                        case 'xut-book-dirFont':
	                            //目录
	                            this.showDirMenu();
	                            break;
	                        case 'icomoon icon-bookmark2':
	                        case 'xut-book-markFont':
	                            //书签
	                            this.showBookMark();
	                            break;
	                        case 'xut-book-bar-star':
	                            //评分
	                            break;
	                        case 'xut-book-menu-item':
	                            //跳转
	                            this.turnToPage(target);
	                            break;
	                        case 'xut-book-menu-mask':
	                        case 'select':
	                            this.hideDirMenu();
	                            break;
	                        default:
	                            // console.log(name+':undefined')
	                            break;
	                    }
	                }
	            }, this, e);
	        }

	        /**
	         * 销毁
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.iscroll && this.iscroll.destroy();
	            this.bookMark && this.bookMark.destroy();
	            (0, _dom.$$off)(this.$sceneNode[0], {
	                end: this
	            });
	            this.iscroll = null;
	            this.menu = null;
	            this.page = null;
	            //销毁超类
	            this.super_destory();
	        }
	    }]);

	    return BookBar;
	}(_bar2.default);

	exports.default = BookBar;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 书签栏
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 加入这个书签功能后，可以让用户自由选择哪页是需要保存记录的
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @param options object
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @example {parent:页面容器,pageId:chapterId,seasonId:seasionId}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _index = __webpack_require__(1);

	var _index2 = __webpack_require__(2);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 行高
	 * @type {[type]}
	 */
	var sLineHeiht = parseInt($('body').css('font-size')) || 16; //行高

	/**
	 * 书签缓存
	 */
	var BOOKCACHE = void 0;

	var Mark = function () {
	    function Mark() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            parent = _ref.parent,
	            pageId = _ref.pageId,
	            seasonId = _ref.seasonId;

	        _classCallCheck(this, Mark);

	        this.parent = parent;
	        this.pageId = pageId;
	        this.seasonId = seasonId;

	        this.viewSize = _index.config.viewSize;
	        this.sHeight = this.viewSize.height;
	        this.sWidth = this.viewSize.width;

	        //是否已存储
	        this.isStored = false;
	        this.init();
	    }

	    /**
	     * 初始化
	     * @return {[type]} [description]
	     */


	    _createClass(Mark, [{
	        key: 'init',
	        value: function init() {
	            var $bookMark = this.createBookMarkFont(),
	                dom = this.parent[0],
	                that = this;

	            this.parent.append($bookMark);
	            this.bookMarkMenu = $bookMark.eq(0);
	            //显示书签
	            setTimeout(function () {
	                that.restore();
	            }, 20);
	            //获取历史记录
	            BOOKCACHE = this.getHistory();

	            //邦定用户事件
	            (0, _index2.$$on)(dom, {
	                end: this
	            });
	        }

	        /**
	         * 创建书签(font版本)
	         * @return {[object]} [jquery生成的dom对象]
	         */

	    }, {
	        key: 'createBookMarkFont',
	        value: function createBookMarkFont() {
	            var height = sLineHeiht * 3; // menu的高为3em
	            var sHeight = this.sHeight;
	            var box = '<div class="xut-bookmark-menu" \n               style="width:100%;height:' + height + 'px;left:0;top:' + sHeight + 'px;">\n              <div class="xut-bookmark-wrap">\n                <div class="xut-bookmark-add">\u52A0\u5165\u4E66\u7B7E</div>\n                <div class="xut-bookmark-off icomoon icon-chevron-down" style="vertical-align:bottom;"></div>\n                <div class="xut-bookmark-view">\u4E66\u7B7E\u8BB0\u5F55</div>\n              </div>\n            </div>\n            <div class="xut-bookmark-list" style="display:none;width:100%;height:' + sHeight + 'px;">\n              <ul class="xut-bookmark-head">\n                <li class="xut-bookmark-back">\u8FD4\u56DE</li>\n                <li>\u4E66\u7B7E</li>\n              </ul>\n              <ul class="xut-bookmark-body"></ul>\n            </div>';
	            this.markHeight = height;
	            return $(box);
	        }

	        /**
	         * 生成书签列表
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createMarkList',
	        value: function createMarkList() {
	            var tmp,
	                seasonId,
	                pageId,
	                list = '',
	                box = '',
	                self = this;

	            //取历史记录
	            _.each(BOOKCACHE, function (mark) {
	                tmp = mark.split('-');
	                seasonId = tmp[0];
	                pageId = tmp[1];
	                mark = self.getMarkId(seasonId, pageId);
	                list += '<li>\n               <a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">\u7B2C' + pageId + '\u9875</a>\n               <a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a>\n             </li>';
	            });

	            return list;
	        }

	        /**
	         * 创建存储标签
	         * 存储格式 seasonId-pageId
	         * @return {string} [description]
	         */

	    }, {
	        key: 'getMarkId',
	        value: function getMarkId(seasonId, pageId) {
	            return seasonId + '-' + pageId;
	        }

	        /**
	         * 获取历史记录
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'getHistory',
	        value: function getHistory() {
	            var mark = (0, _index2.$$get)('bookMark');
	            if (mark) {
	                return mark.split(',');
	            }
	            return [];
	        }

	        /**
	         * 添加书签
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'addBookMark',
	        value: function addBookMark() {
	            var key;

	            this.updatePageInfo();
	            key = this.getMarkId(this.seasonId, this.pageId);

	            //避免重复缓存
	            if (BOOKCACHE.indexOf(key) > -1) {
	                return;
	            }
	            BOOKCACHE.push(key);
	            (0, _index2.$$set)('bookMark', BOOKCACHE);
	        }

	        /**
	         * 更新页信息
	         *  针对母板层上的书签
	         */

	    }, {
	        key: 'updatePageInfo',
	        value: function updatePageInfo() {
	            var pageData = Xut.Presentation.GetPageData();
	            this.pageId = pageData._id;
	            this.seasonId = pageData.seasonId;
	        }

	        /**
	         * 删除书签
	         * @param {object} [key] [事件目标对象]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'delBookMark',
	        value: function delBookMark(target) {
	            if (!target || !target.dataset) return;

	            var key = target.dataset.mark,
	                index = BOOKCACHE.indexOf(key);

	            BOOKCACHE.splice(index, 1);
	            (0, _index2.$$set)('bookMark', BOOKCACHE);

	            if (BOOKCACHE.length == 0) {
	                (0, _index2.$$remove)('bookMark');
	            }

	            //移除该行
	            $(target).parent().remove();
	        }

	        /**
	         * 显示书签
	         * @param {object} [target] [事件目标对象]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'viewBookMark',
	        value: function viewBookMark(target) {
	            var $bookMarkList,
	                list = this.createMarkList();

	            if (this.bookMarkList) {
	                $bookMarkList = this.bookMarkList;
	            } else {
	                $bookMarkList = $(target).parent().parent().next();
	            }
	            //更新书签内容
	            $bookMarkList.find('.xut-bookmark-body').html(list);
	            this.bookMarkList = $bookMarkList;
	            $bookMarkList.fadeIn();
	        }

	        /**
	         * 点击放大效果
	         * @param  {[object]} target [事件目标对象]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: 'iconManager',
	        value: function iconManager(target) {
	            var $icon = this.bookMarkIcon = $(target),
	                restore = this.iconRestore;

	            $icon.css({
	                'transform': 'scale(1.2)',
	                'transition-duration': '500ms'
	            })[0].addEventListener(Xut.style.transitionEnd, restore.bind(this), false);
	        }

	        /**
	         * 复原按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'iconRestore',
	        value: function iconRestore() {
	            this.bookMarkIcon.css('transform', '');
	        }

	        /**
	         * 跳转到书签页
	         * @param  {[type]} target [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: 'goBookMark',
	        value: function goBookMark(target) {
	            if (!target || !target.dataset) return;

	            var key = target.dataset.mark.split('-');
	            var seasonId = Number(key[0]);
	            var pageId = Number(key[1]);

	            this.updatePageInfo();
	            //关闭书签列表
	            this.backBookMark();

	            //忽略当前页的跳转
	            if (this.pageId == pageId && this.seasonId == seasonId) {
	                return;
	            }

	            Xut.View.LoadScenario({
	                'scenarioId': seasonId,
	                'chapterId': pageId
	            });
	        }

	        /**
	         * 书签回退键
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'backBookMark',
	        value: function backBookMark() {
	            this.bookMarkList.fadeOut();
	        }

	        /**
	         * 邦定事件
	         * @param  {[type]} evt [事件]
	         * @return {[type]}     [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {
	            var target = e.target;
	            (0, _index2.$$handle)({
	                end: function end(e) {
	                    switch ((0, _index2.$$target)(e).className) {
	                        //加入书签
	                        case 'xut-bookmark-add':
	                            this.addBookMark();
	                            this.iconManager(target);
	                            break;
	                        //显示书签记录
	                        case 'xut-bookmark-view':
	                            this.viewBookMark(target);
	                            this.iconManager(target);
	                            break;
	                        //关闭书签
	                        case 'xut-bookmark-off':
	                        case 'xut-bookmark-off icomoon icon-chevron-down':
	                            this.closeBookMark(target);
	                            break;
	                        //返回书签主菜单
	                        case 'xut-bookmark-back':
	                            this.backBookMark();
	                            break;
	                        //删除书签记录
	                        case 'xut-bookmark-del':
	                            this.delBookMark(target);
	                            break;
	                        //跳转到书签页
	                        case 'xut-bookmark-id':
	                            this.goBookMark(target);
	                            break;
	                        default:
	                            //console.log(target.className)
	                            break;
	                    }
	                }
	            }, this, e);
	        }

	        /**
	         * 关闭书签菜单
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'closeBookMark',
	        value: function closeBookMark(target) {
	            this.bookMarkMenu.css({
	                transform: 'translate3d(0,0,0)',
	                'transition-duration': '1s'
	            });
	        }

	        /**
	         * 恢复书签菜单
	         */

	    }, {
	        key: 'restore',
	        value: function restore() {
	            this.bookMarkMenu.css({
	                transform: 'translate3d(0,-' + this.markHeight + 'px,0)',
	                'transition-duration': '1s'
	            });
	        }

	        /**
	         * 销毁书签
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var dom = this.parent[0];

	            (0, _index2.$$off)(dom, {
	                end: this
	            });

	            //菜单部分
	            if (this.bookMarkMenu) {
	                this.bookMarkMenu.remove();
	                this.bookMarkMenu = null;
	            }

	            //列表部分
	            if (this.bookMarkList) {
	                this.bookMarkList.remove();
	                this.bookMarkList = null;
	            }

	            //按钮效果
	            if (this.bookMarkIcon) {
	                this.bookMarkIcon[0].removeEventListener(Xut.style.transitionEnd, this.iconRestore, false);
	                this.bookMarkIcon = null;
	            }

	            this.parent = null;
	        }
	    }]);

	    return Mark;
	}();

	exports.default = Mark;

/***/ },
/* 167 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * 缓存池
	 * @return {[type]} [description]
	 */
	function createCache() {
	    var keys = [];
	    function cache(key, value) {
	        if (keys.push(key) > 20) {
	            delete cache[keys.shift()];
	        }
	        return cache[key] = value;
	    }
	    return cache;
	}

	var contentCache = exports.contentCache = createCache();

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.$$warn = undefined;

	var _index = __webpack_require__(1);

	var $$warn = function $$warn() {};

	if (process.env.NODE_ENV !== 'production') {
	    (function () {
	        var hasConsole = typeof console !== 'undefined';
	        exports.$$warn = $$warn = function $$warn(msg) {
	            if (hasConsole && _index.config.silent) {
	                console.error('[Xut warn]: ' + msg);
	            }
	        };
	    })();
	}

	exports.$$warn = $$warn;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ },
/* 169 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.addEdges = addEdges;
	/**
	 * 利用canvas绘制出蒙板效果替换，需要蒙板效果的图片先用一个canvas占位，绘制是异步的
	 */

	function _getCanvas(className) {
	    var children = document.getElementsByTagName('canvas'),
	        elements = new Array(),
	        i = 0,
	        child,
	        classNames,
	        j = 0;
	    for (i = 0; i < children.length; i++) {
	        child = children[i];
	        classNames = child.className.split(' ');
	        for (var j = 0; j < classNames.length; j++) {
	            if (classNames[j] == className) {
	                elements.push(child);
	                break;
	            }
	        }
	    }
	    return elements;
	}

	function _addEdge(canvas) {

	    var img = new Image(),
	        maskimg = new Image();

	    var classNames = canvas.className.split(' ');
	    var context = canvas.getContext("2d");
	    img.addEventListener("load", loadimg);
	    maskimg.addEventListener("load", loadmask);

	    function loadimg() {
	        context.clearRect(0, 0, canvas.width, canvas.height);
	        context.globalCompositeOperation = "source-over";
	        context.drawImage(img, 0, 0, canvas.width, canvas.height);
	        maskimg.src = canvas.getAttribute("mask");
	        img.removeEventListener("load", loadimg);
	        img.src = null;
	        img = null;
	    }

	    function loadmask() {
	        context.globalCompositeOperation = "destination-atop";
	        context.drawImage(maskimg, 0, 0, canvas.width, canvas.height);
	        canvas.style.opacity = 1;
	        maskimg.removeEventListener("load", loadmask);
	        maskimg.src = null;
	        maskimg = null;
	        context = null;
	        classNames = null;
	        canvas.className = canvas.className.replace("edges", "");
	    }
	    img.src = canvas.getAttribute("src");
	}

	function addEdges() {
	    var thecanvas = _getCanvas('edges'),
	        i;
	    for (i = 0; i < thecanvas.length; i++) {
	        _addEdge(thecanvas[i]);
	    }
	}

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _index = __webpack_require__(1);

	/**
	 * 设置默认的样式
	 * @return {[type]} [description]
	 */

	var transform = Xut.style.transform;
	var translateZ = Xut.style.translateZ;

	/**
	 * 创建translate初始值
	 * @param  {[type]} offset [description]
	 * @return {[type]}        [description]
	 */
	var createTranslate = function createTranslate(offset) {
	    return 'translate(' + offset + 'px,0px)' + translateZ;
	};

	/**
	 * 混入钩子处理
	 * @param  {[type]} original [description]
	 * @param  {[type]} hook     [description]
	 * @return {[type]}          [description]
	 */
	var mixHooks = function mixHooks(original, hook) {
	    if (hook) {
	        var newValue = hook(original);
	        if (newValue !== undefined) {
	            return newValue;
	        }
	    }
	    return original;
	};

	/**
	 * 创建li的translate起始坐标信息
	 * flowType 如果是flow类型
	 * @return {[type]}
	 */
	exports.default = {

	    /**
	     * 默认视图
	     * @return {[type]} [description]
	     */
	    view: function view() {
	        var viewSize = _index.config.viewSize;
	        return {
	            viewWidth: viewSize.width,
	            viewHeight: viewSize.height,
	            viewTop: viewSize.top,
	            viewLeft: 0
	        };
	    }

	    /**
	     * 默认样式
	     * @param  {Object} options.hooks [description]
	     * @param  {[type]} createIndex   [description]
	     * @param  {Object} currIndex                     } [description]
	     * @return {[type]}               [description]
	     */
	    ,
	    translate: function translate() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _ref$hooks = _ref.hooks,
	            hooks = _ref$hooks === undefined ? {} : _ref$hooks,
	            createIndex = _ref.createIndex,
	            currIndex = _ref.currIndex,
	            direction = _ref.direction;

	        var translate = void 0;
	        var offset = void 0;
	        var offsetLeft = void 0;
	        var offsetMiddle = void 0;
	        var offsetRight = void 0;

	        var viewWidth = _index.config.viewSize.width;

	        switch (direction) {
	            case 'before':
	                offsetLeft = -viewWidth;
	                offsetLeft = mixHooks(offsetLeft, hooks.left);
	                translate = createTranslate(offsetLeft);
	                offset = offsetLeft;
	                break;
	            case 'middle':
	                offsetMiddle = 0;
	                offsetMiddle = mixHooks(offsetMiddle, hooks.middle);
	                translate = createTranslate(offsetMiddle);
	                offset = offsetMiddle;
	                break;
	            case 'after':
	                offsetRight = viewWidth;
	                offsetRight = mixHooks(offsetRight, hooks.right);
	                translate = createTranslate(offsetRight);
	                offset = offsetRight;
	                break;
	        }

	        return {
	            translate: translate,
	            offset: offset
	        };
	    }
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _index = __webpack_require__(1);

	exports.default = {
	    view: function view() {

	        var viewWidth = _index.config.screenSize.width;
	        var viewHeight = _index.config.screenSize.height;
	        var viewTop = 0;
	        var viewLeft = 0;

	        //宽度100%的情况下
	        //如果是flow页面处理,全屏
	        if (_index.config.visualMode === 2) {
	            if (_index.config.pptVertical) {
	                //其他页面上下压缩，左右100%
	                //flows页面宽高都是100%
	                if (_index.config.screenVertical) {
	                    viewWidth = _index.config.screenSize.width;
	                    viewHeight = _index.config.screenSize.height;
	                    viewTop = 0;
	                } else {
	                    viewWidth = _index.config.viewSize.width;
	                    viewHeight = _index.config.viewSize.height;
	                    viewTop = 0;
	                }
	            }
	            return {
	                viewWidth: viewWidth,
	                viewHeight: viewHeight,
	                viewTop: viewTop
	            };
	        }

	        //高度100%的情况下
	        //flow下,设置容易宽度
	        if (_index.config.visualMode === 3) {
	            if (_index.config.pptVertical) {
	                //竖版竖版
	                //存在溢出或者未填满全屏(ipad)的情况
	                if (_index.config.screenVertical) {
	                    //溢出强制全屏
	                    if (_index.config.viewSize.overflowWidth) {
	                        viewWidth = _index.config.screenSize.width;
	                    }
	                    //如果没有填满采用可视区大小
	                    if (_index.config.viewSize.notFillWidth) {
	                        viewWidth = _index.config.viewSize.width;
	                    }
	                } else {}
	            }
	        }

	        return {
	            viewWidth: viewWidth,
	            viewHeight: viewHeight,
	            viewTop: viewTop,
	            viewLeft: viewLeft
	        };
	    }

	    /**
	     * 容器translate的规则
	     * @param  {[type]} data       [description]
	     * @param  {[type]} usefulData [description]
	     * @return {[type]}            [description]
	     */
	    ,
	    translate: function translate(data, usefulData) {
	        if (_index.config.viewSize.overflowWidth) {
	            return {
	                left: function left(offsetLeft) {
	                    var middle = usefulData.getStyle('middle');
	                    if (middle && middle.isFlows) {
	                        return -(middle.viewWidth + middle.offset);
	                    }
	                },
	                middle: function middle(originalOffset) {
	                    if (data.isFlows) {
	                        return -_index.config.viewSize.left;
	                    }
	                },
	                right: function right(originalOffset) {
	                    //获取上一页的styles状态
	                    //如果上一页是通过flow方式处理过的
	                    //当前页面小姐要不去重新处理
	                    var middle = usefulData.getStyle('middle');
	                    if (middle && middle.isFlows) {
	                        return middle.viewWidth + middle.offset;
	                    }
	                }
	            };
	        }
	    }

	    /**
	     * 滑动值
	     * @return {[type]} [description]
	     */
	    ,
	    distance: function distance() {
	        if (_index.config.viewSize.overflowWidth) {
	            return {
	                flipMove: {
	                    left: function left(data) {
	                        var leftFlow = data.$$checkFlows(data.$$leftIndex);
	                        if (leftFlow) {
	                            data.left = data.$$left + Math.abs(_index.config.viewSize.left) * 2;
	                        }
	                    },
	                    right: function right(data) {
	                        var middleFlow = data.$$checkFlows(data.$$middleIndex);
	                        if (middleFlow) {
	                            data.right = data.$$right - Math.abs(_index.config.viewSize.left) * 2;
	                        }
	                    }
	                },
	                /**
	                 * 反弹是反向设置，这个需要注意
	                 * @type {Object}
	                 */
	                flipRebound: {
	                    left: function left(data) {
	                        //往右边滑动反弹，所以left为左边处理
	                        //而且只修正当期那是flow
	                        var middleFlow = data.$$checkFlows(data.$$middleIndex);
	                        if (middleFlow) {
	                            data.middle = Math.abs(_index.config.viewSize.left);
	                        }
	                    },
	                    right: function right(data) {
	                        var middleFlow = data.$$checkFlows(data.$$middleIndex);
	                        if (middleFlow) {
	                            data.middle = Math.abs(_index.config.viewSize.left);
	                        }
	                    }
	                },
	                flipOver: {
	                    left: function left(data) {
	                        var leftFlow = data.$$checkFlows(data.$$leftIndex);
	                        if (leftFlow) {
	                            data.left = -_index.config.viewSize.left;
	                        }
	                    },
	                    right: function right(data) {
	                        var rightFlow = data.$$checkFlows(data.$$rightIndex);
	                        //当前正常页面，下一页flow
	                        if (rightFlow) {
	                            data.right = Math.abs(_index.config.viewSize.left);
	                        }
	                    }
	                }
	            };
	        }
	    }
	};

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = styleConfig;

	var _container = __webpack_require__(170);

	var _container2 = _interopRequireDefault(_container);

	var _stack = __webpack_require__(45);

	var _stack2 = _interopRequireDefault(_stack);

	var _adapter = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 自定义样式页面容器的样式
	 * 创建页面的样式，与布局
	 * 1 创建页面的初始化的Transform值
	 * 是否初始化创建
	 * @return {[type]} [description]
	 */
	function styleConfig(_ref) {
	    var action = _ref.action,
	        hasFlow = _ref.hasFlow,
	        usefulData = _ref.usefulData;


	    /**
	     * 获取指定页面样式
	     * @return {[type]} [description]
	     */
	    usefulData.getStyle = function (pageName) {
	        return this[this['_' + pageName]];
	    };

	    var compile = new _stack2.default();

	    _.each(usefulData, function (data, index) {

	        //跳过getStyle方法
	        if (_.isFunction(data)) {
	            return;
	        }

	        //只处理页面的样式对象
	        //确保中间页第一个解析
	        compile[data.direction == 'middle' ? 'shift' : 'push'](function () {

	            //容器默认默认尺寸
	            _.extend(data, _container2.default.view());

	            //提供可自定义配置接口
	            if (data.isFlows) {
	                _.extend(data, (0, _adapter.getFlowView)());
	            }

	            //设置容器样式
	            var translate = _container2.default.translate({
	                //提供容器的样式钩子
	                hooks: hasFlow ? (0, _adapter.setFlowTranslate)(data, usefulData) : {},
	                createIndex: data.pid,
	                currIndex: data.visiblePid,
	                direction: data.direction
	            });

	            //提供快速索引
	            usefulData['_' + data.direction] = data.pid;
	            _.extend(data, translate);
	        });
	    });

	    compile.shiftAll().destroy();

	    return usefulData;
	}

/***/ },
/* 173 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getFullProportion = getFullProportion;
	exports.getRealProportion = getRealProportion;
	/**
	 * 默认ppt尺寸
	 * @type {Number}
	 */
	var PPTWIDTH = 1024;
	var PPTHEIGHT = 768;

	/**
	 * 获取默认全屏比值关系
	 * 用来设置新的view尺寸
	 * @param  {[type]} config    [description]
	 * @param  {[type]} pptWidth  [description]
	 * @param  {[type]} pptHeight [description]
	 * @return {[type]}           [description]
	 */
	function getFullProportion(config, pptWidth, pptHeight) {
	    //设备分辨率
	    var screenWidth = config.screenSize.width;
	    var screenHeight = config.screenSize.height;

	    var screenHorizontal = config.screenHorizontal;

	    //默认ppt尺寸
	    var designWidth = pptWidth ? pptWidth : screenHorizontal ? PPTWIDTH : PPTHEIGHT;
	    var designHeight = pptHeight ? pptHeight : screenHorizontal ? PPTHEIGHT : PPTWIDTH;

	    //当前屏幕的尺寸与数据库设计的尺寸，比例
	    var widthProp = screenWidth / designWidth;
	    var heightProp = screenHeight / designHeight;

	    return {
	        width: widthProp,
	        height: heightProp,
	        left: widthProp,
	        top: heightProp,
	        pptWidth: designWidth,
	        pptHeight: designHeight
	    };
	}

	/**
	 * 计算真正的缩放比
	 * 依照真正的view尺寸设置
	 * @param  {[type]} pptWidth  [description]
	 * @param  {[type]} pptHeight [description]
	 * @return {[type]}           [description]
	 */
	function getRealProportion(config, viewSize, fullProportion) {
	    var widthProp = viewSize.width / fullProportion.pptWidth;
	    var heightProp = viewSize.height / fullProportion.pptHeight;

	    //布局的偏移量，可能是采用了画轴模式，一个可视区可以容纳3个页面
	    var offsetTop = 0;
	    var offsetLeft = 0;

	    return {
	        width: widthProp,
	        height: heightProp,
	        left: widthProp,
	        top: heightProp,
	        offsetTop: offsetTop,
	        offsetLeft: offsetLeft
	    };
	}

/***/ },
/* 174 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = setView;
	var FLOOR = Math.floor;
	var CEIL = Math.ceil;

	/**
	 * 全局可视区域布局处理
	 * @param  {[type]} () [description]
	 * @return {[type]}    [description]
	 */
	function setView(config, fullProportion) {

	    var screenWidth = config.screenSize.width;
	    var screenHeight = config.screenSize.height;

	    var newWidth = screenWidth;
	    var newHeight = screenHeight;
	    var newTop = 0;
	    var newLeft = 0;

	    /**
	     * 画轴拼接模式
	     * 高度100%，正比缩放宽度，然后设置父容器溢出不隐藏了
	     * 可以看到是连续拼接的页面
	     * @param  {[type]} config.visualMode [description]
	     * @return {[type]}                   [description]
	     */
	    if (config.visualMode === 1) {

	        var designWidth = fullProportion.pptWidth;
	        var designHeight = fullProportion.pptHeight;

	        //竖版PPT
	        if (config.pptVertical) {
	            //横版显示
	            //比如模式3的处理是一致的。只是父容易溢出吧隐藏了
	            if (config.screenHorizontal) {
	                newWidth = fullProportion.pptWidth * fullProportion.height;
	                newLeft = (screenWidth - newWidth) / 2;
	            }
	            //竖版显示
	            //正常全屏显示，类似模式0
	            //config.screenVertical
	        }

	        //横版ppt
	        if (config.pptHorizontal) {
	            //横版设计，在竖版手机上显示，强制分2页，虚拟一页
	            //假如启用了画轴模式，看看是不是竖版的情况，需要切半模版virtualMode
	            //word是两栏，竖版需要强制分开
	            if (config.screenVertical) {}
	            //启动虚拟双页模式
	            // config.doublePageMode = true


	            //横版显示，默认0全屏
	            //config.screenHorizontal
	        }

	        // if (config.doublePageMode && !config.screenHorizontal) {
	        //     //假设高度不会溢出,按两倍屏宽计算
	        //     var _prop = 2 * screenWidth / designWidth;
	        //     offsetLeft = 0;
	        //     scaleHeight = designHeight * _prop;
	        //     offsetTop = (screenHeight - scaleHeight) / 2;

	        //     //如果高度溢出,按屏高计算
	        //     if (scaleHeight > screenHeight) {
	        //         _prop = screenHeight / designHeight;
	        //         scaleWidth = designWidth * _prop;

	        //         offsetTop = 0;
	        //         offsetLeft = (2 * screenWidth - scaleWidth) / 2;
	        //     }

	        //     widthProp = heightProp = _prop;
	        // }
	    }

	    /**
	     * 宽度100%
	     * 正比缩放高度
	     * @param  {[type]} config.visualMode [description]
	     * @return {[type]}                   [description]
	     */
	    if (config.visualMode === 2) {

	        //竖版PPT
	        if (config.pptVertical) {
	            //竖版显示
	            if (config.screenVertical) {
	                newHeight = fullProportion.pptHeight * fullProportion.width;
	                newTop = (screenHeight - newHeight) / 2;
	            }
	            //横版显示
	            else {
	                    newWidth = fullProportion.pptWidth * fullProportion.height;
	                    newLeft = (screenWidth - newWidth) / 2;
	                }
	        }

	        //横版PPT
	        if (config.pptHorizontal) {
	            //竖版显示(宽度100%。上下自适应，显示居中小块)
	            if (config.screenVertical) {
	                newHeight = fullProportion.pptHeight * fullProportion.width;
	                newTop = (screenHeight - newHeight) / 2;
	            }
	        }
	    }

	    /**
	     * 高度100%
	     * 正比缩放宽度
	     * @param  {[type]} config.visualMode [description]
	     * @return {[type]}                   [description]
	     */
	    if (config.visualMode === 3) {

	        //竖版PPT
	        if (config.pptVertical) {
	            //竖版显示
	            //高度100%，宽度溢出
	            if (config.screenVertical) {
	                newWidth = fullProportion.pptWidth * fullProportion.height;
	                newLeft = (screenWidth - newWidth) / 2;
	            }
	        }

	        //横版PPT
	        if (config.pptHorizontal) {
	            //竖版显示(宽度100%。上下自适应，显示居中小块)
	            if (config.screenVertical) {
	                newHeight = fullProportion.pptHeight * fullProportion.width;
	                newTop = (screenHeight - newHeight) / 2;
	            }
	        }
	    }

	    /**
	     * 默认全屏
	     * config.visualMode === 0
	     * @return {[type]}
	     */
	    return {
	        width: CEIL(newWidth),
	        height: CEIL(newHeight),
	        left: CEIL(newLeft),
	        top: CEIL(newTop)
	    };
	}

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/*
	   * CommonJS module that exports EventSource polyfill version 0.9.6
	   * This module is intended for browser side use
	   * =====================================================================
	   * THIS IS A POLYFILL MODULE, SO IT HAS SIDE EFFECTS
	   * IT AUTOMATICALLY CHECKS IF window OBJECT DEFINES EventSource
	   * AND ADD THE EXPORTED ONE IN CASE IT IS UNDEFINED
	   * =====================================================================
	   * Supported by sc AmvTek srl
	   * :email: devel@amvtek.com
	 */


	var PolyfillEventSource = __webpack_require__(176).EventSource;
	module.exports = PolyfillEventSource;

	// Add EventSource to window if it is missing...
	if (window && !window.EventSource){
	    window.EventSource = PolyfillEventSource;
	    if (console){
		console.log("polyfill-eventsource added missing EventSource to window");
	    }
	}


/***/ },
/* 176 */
/***/ function(module, exports) {

	/*
	   * EventSource polyfill version 0.9.6
	   * Supported by sc AmvTek srl
	   * :email: devel@amvtek.com
	 */
	;(function (global) {

	    if (global.EventSource && !global._eventSourceImportPrefix){
	        return;
	    }

	    var evsImportName = (global._eventSourceImportPrefix||'')+"EventSource";

	    var EventSource = function (url, options) {

	        if (!url || typeof url != 'string') {
	            throw new SyntaxError('Not enough arguments');
	        }

	        this.URL = url;
	        this.setOptions(options);
	        var evs = this;
	        setTimeout(function(){evs.poll()}, 0);
	    };

	    EventSource.prototype = {

	        CONNECTING: 0,

	        OPEN: 1,

	        CLOSED: 2,

	        defaultOptions: {

	            loggingEnabled: false,

	            loggingPrefix: "eventsource",

	            interval: 500, // milliseconds

	            bufferSizeLimit: 256*1024, // bytes

	            silentTimeout: 300000, // milliseconds

	            getArgs:{
	                'evs_buffer_size_limit': 256*1024
	            },

	            xhrHeaders:{
	                'Accept': 'text/event-stream',
	                'Cache-Control': 'no-cache',
	                'X-Requested-With': 'XMLHttpRequest'
	            }
	        },

	        setOptions: function(options){

	            var defaults = this.defaultOptions;
	            var option;

	            // set all default options...
	            for (option in defaults){

	                if ( defaults.hasOwnProperty(option) ){
	                    this[option] = defaults[option];
	                }
	            }

	            // override with what is in options
	            for (option in options){

	                if (option in defaults && options.hasOwnProperty(option)){
	                    this[option] = options[option];
	                }
	            }

	            // if getArgs option is enabled
	            // ensure evs_buffer_size_limit corresponds to bufferSizeLimit
	            if (this.getArgs && this.bufferSizeLimit) {

	                this.getArgs['evs_buffer_size_limit'] = this.bufferSizeLimit;
	            }

	            // if console is not available, force loggingEnabled to false
	            if (typeof console === "undefined" || typeof console.log === "undefined") {

	                this.loggingEnabled = false;
	            }
	        },

	        log: function(message) {

	            if (this.loggingEnabled) {

	                console.log("[" + this.loggingPrefix +"]:" + message)
	            }
	        },

	        poll: function() {

	            try {

	                if (this.readyState == this.CLOSED) {
	                    return;
	                }

	                this.cleanup();
	                this.readyState = this.CONNECTING;
	                this.cursor = 0;
	                this.cache = '';
	                this._xhr = new this.XHR(this);
	                this.resetNoActivityTimer();

	            }
	            catch (e) {

	                // in an attempt to silence the errors
	                this.log('There were errors inside the pool try-catch');
	                this.dispatchEvent('error', { type: 'error', data: e.message });
	            }
	        },

	        pollAgain: function (interval) {

	            // schedule poll to be called after interval milliseconds
	            var evs = this;
	            evs.readyState = evs.CONNECTING;
	            evs.dispatchEvent('error', {
	                type: 'error',
	                data: "Reconnecting "
	            });
	            this._pollTimer = setTimeout(function(){evs.poll()}, interval||0);
	        },


	        cleanup: function() {

	            this.log('evs cleaning up')

	            if (this._pollTimer){
	                clearInterval(this._pollTimer);
	                this._pollTimer = null;
	            }

	            if (this._noActivityTimer){
	                clearInterval(this._noActivityTimer);
	                this._noActivityTimer = null;
	            }

	            if (this._xhr){
	                this._xhr.abort();
	                this._xhr = null;
	            }
	        },

	        resetNoActivityTimer: function(){

	            if (this.silentTimeout){

	                if (this._noActivityTimer){
	                    clearInterval(this._noActivityTimer);
	                }
	                var evs = this;
	                this._noActivityTimer = setTimeout(
	                        function(){ evs.log('Timeout! silentTImeout:'+evs.silentTimeout); evs.pollAgain(); },
	                        this.silentTimeout
	                        );
	            }
	        },

	        close: function () {

	            this.readyState = this.CLOSED;
	            this.log('Closing connection. readyState: '+this.readyState);
	            this.cleanup();
	        },

	        ondata: function() {

	            var request = this._xhr;

	            if (request.isReady() && !request.hasError() ) {
	                // reset the timer, as we have activity
	                this.resetNoActivityTimer();

	                // move this EventSource to OPEN state...
	                if (this.readyState == this.CONNECTING) {
	                    this.readyState = this.OPEN;
	                    this.dispatchEvent('open', { type: 'open' });
	                }

	                var buffer = request.getBuffer();

	                if (buffer.length > this.bufferSizeLimit) {
	                    this.log('buffer.length > this.bufferSizeLimit');
	                    this.pollAgain();
	                }

	                if (this.cursor == 0 && buffer.length > 0){

	                    // skip byte order mark \uFEFF character if it starts the stream
	                    if (buffer.substring(0,1) == '\uFEFF'){
	                        this.cursor = 1;
	                    }
	                }

	                var lastMessageIndex = this.lastMessageIndex(buffer);
	                if (lastMessageIndex[0] >= this.cursor){

	                    var newcursor = lastMessageIndex[1];
	                    var toparse = buffer.substring(this.cursor, newcursor);
	                    this.parseStream(toparse);
	                    this.cursor = newcursor;
	                }

	                // if request is finished, reopen the connection
	                if (request.isDone()) {
	                    this.log('request.isDone(). reopening the connection');
	                    this.pollAgain(this.interval);
	                }
	            }
	            else if (this.readyState !== this.CLOSED) {

	                this.log('this.readyState !== this.CLOSED');
	                this.pollAgain(this.interval);

	                //MV: Unsure why an error was previously dispatched
	            }
	        },

	        parseStream: function(chunk) {

	            // normalize line separators (\r\n,\r,\n) to \n
	            // remove white spaces that may precede \n
	            chunk = this.cache + this.normalizeToLF(chunk);

	            var events = chunk.split('\n\n');

	            var i, j, eventType, datas, line, retry;

	            for (i=0; i < (events.length - 1); i++) {

	                eventType = 'message';
	                datas = [];
	                parts = events[i].split('\n');

	                for (j=0; j < parts.length; j++) {

	                    line = this.trimWhiteSpace(parts[j]);

	                    if (line.indexOf('event') == 0) {

	                        eventType = line.replace(/event:?\s*/, '');
	                    }
	                    else if (line.indexOf('retry') == 0) {

	                        retry = parseInt(line.replace(/retry:?\s*/, ''));
	                        if(!isNaN(retry)) {
	                            this.interval = retry;
	                        }
	                    }
	                    else if (line.indexOf('data') == 0) {

	                        datas.push(line.replace(/data:?\s*/, ''));
	                    }
	                    else if (line.indexOf('id:') == 0) {

	                        this.lastEventId = line.replace(/id:?\s*/, '');
	                    }
	                    else if (line.indexOf('id') == 0) { // this resets the id

	                        this.lastEventId = null;
	                    }
	                }

	                if (datas.length) {
	                    // dispatch a new event
	                    var event = new MessageEvent(eventType, datas.join('\n'), window.location.origin, this.lastEventId);
	                    this.dispatchEvent(eventType, event);
	                }
	            }

	            this.cache = events[events.length - 1];
	        },

	        dispatchEvent: function (type, event) {
	            var handlers = this['_' + type + 'Handlers'];

	            if (handlers) {

	                for (var i = 0; i < handlers.length; i++) {
	                    handlers[i].call(this, event);
	                }
	            }

	            if (this['on' + type]) {
	                this['on' + type].call(this, event);
	            }

	        },

	        addEventListener: function (type, handler) {
	            if (!this['_' + type + 'Handlers']) {
	                this['_' + type + 'Handlers'] = [];
	            }

	            this['_' + type + 'Handlers'].push(handler);
	        },

	        removeEventListener: function (type, handler) {
	            var handlers = this['_' + type + 'Handlers'];
	            if (!handlers) {
	                return;
	            }
	            for (var i = handlers.length - 1; i >= 0; --i) {
	                if (handlers[i] === handler) {
	                    handlers.splice(i, 1);
	                    break;
	                }
	            }
	        },

	        _pollTimer: null,

	        _noactivityTimer: null,

	        _xhr: null,

	        lastEventId: null,

	        cache: '',

	        cursor: 0,

	        onerror: null,

	        onmessage: null,

	        onopen: null,

	        readyState: 0,

	        // ===================================================================
	        // helpers functions
	        // those are attached to prototype to ease reuse and testing...

	        urlWithParams: function (baseURL, params) {

	            var encodedArgs = [];

	            if (params){

	                var key, urlarg;
	                var urlize = encodeURIComponent;

	                for (key in params){
	                    if (params.hasOwnProperty(key)) {
	                        urlarg = urlize(key)+'='+urlize(params[key]);
	                        encodedArgs.push(urlarg);
	                    }
	                }
	            }

	            if (encodedArgs.length > 0){

	                if (baseURL.indexOf('?') == -1)
	                    return baseURL + '?' + encodedArgs.join('&');
	                return baseURL + '&' + encodedArgs.join('&');
	            }
	            return baseURL;
	        },

	        lastMessageIndex: function(text) {

	            var ln2 =text.lastIndexOf('\n\n');
	            var lr2 = text.lastIndexOf('\r\r');
	            var lrln2 = text.lastIndexOf('\r\n\r\n');

	            if (lrln2 > Math.max(ln2, lr2)) {
	                return [lrln2, lrln2+4];
	            }
	            return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]
	        },

	        trimWhiteSpace: function(str) {
	            // to remove whitespaces left and right of string

	            var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
	            return str.replace(reTrim, '');
	        },

	        normalizeToLF: function(str) {

	            // replace \r and \r\n with \n
	            return str.replace(/\r\n|\r/g, '\n');
	        }

	    };

	    if (!isOldIE()){

	        EventSource.isPolyfill = "XHR";

	        // EventSource will send request using XMLHttpRequest
	        EventSource.prototype.XHR = function(evs) {

	            request = new XMLHttpRequest();
	            this._request = request;
	            evs._xhr = this;

	            // set handlers
	            request.onreadystatechange = function(){
	                if (request.readyState > 1 && evs.readyState != evs.CLOSED) {
	                    if (request.status == 200 || (request.status>=300 && request.status<400)){
	                        evs.ondata();
	                    }
	                    else {
	                        request._failed = true;
	                        evs.readyState = evs.CLOSED;
	                        evs.dispatchEvent('error', {
	                            type: 'error',
	                            data: "The server responded with "+request.status
	                        });
	                        evs.close();
	                    }
	                }
	            };

	            request.onprogress = function () {
	            };

	            request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true);

	            var headers = evs.xhrHeaders; // maybe null
	            for (var header in headers) {
	                if (headers.hasOwnProperty(header)){
	                    request.setRequestHeader(header, headers[header]);
	                }
	            }
	            if (evs.lastEventId) {
	                request.setRequestHeader('Last-Event-Id', evs.lastEventId);
	            }

	            request.send();
	        };

	        EventSource.prototype.XHR.prototype = {

	            useXDomainRequest: false,

	            _request: null,

	            _failed: false, // true if we have had errors...

	            isReady: function() {


	                return this._request.readyState >= 2;
	            },

	            isDone: function() {

	                return (this._request.readyState == 4);
	            },

	            hasError: function() {

	                return (this._failed || (this._request.status >= 400));
	            },

	            getBuffer: function() {

	                var rv = '';
	                try {
	                    rv = this._request.responseText || '';
	                }
	                catch (e){}
	                return rv;
	            },

	            abort: function() {

	                if ( this._request ) {
	                    this._request.abort();
	                }
	            }
	        };
	    }
	    else {

		EventSource.isPolyfill = "IE_8-9";

	        // patch EventSource defaultOptions
	        var defaults = EventSource.prototype.defaultOptions;
	        defaults.xhrHeaders = null; // no headers will be sent
	        defaults.getArgs['evs_preamble'] = 2048 + 8;

	        // EventSource will send request using Internet Explorer XDomainRequest
	        EventSource.prototype.XHR = function(evs) {

	            request = new XDomainRequest();
	            this._request = request;

	            // set handlers
	            request.onprogress = function(){
	                request._ready = true;
	                evs.ondata();
	            };

	            request.onload = function(){
	                this._loaded = true;
	                evs.ondata();
	            };

	            request.onerror = function(){
	                this._failed = true;
	                evs.readyState = evs.CLOSED;
	                evs.dispatchEvent('error', {
	                    type: 'error',
	                    data: "XDomainRequest error"
	                });
	            };

	            request.ontimeout = function(){
	                this._failed = true;
	                evs.readyState = evs.CLOSED;
	                evs.dispatchEvent('error', {
	                    type: 'error',
	                    data: "XDomainRequest timed out"
	                });
	            };

	            // XDomainRequest does not allow setting custom headers
	            // If EventSource has enabled the use of GET arguments
	            // we add parameters to URL so that server can adapt the stream...
	            var reqGetArgs = {};
	            if (evs.getArgs) {

	                // copy evs.getArgs in reqGetArgs
	                var defaultArgs = evs.getArgs;
	                    for (var key in defaultArgs) {
	                        if (defaultArgs.hasOwnProperty(key)){
	                            reqGetArgs[key] = defaultArgs[key];
	                        }
	                    }
	                if (evs.lastEventId){
	                    reqGetArgs['evs_last_event_id'] = evs.lastEventId;
	                }
	            }
	            // send the request

	            request.open('GET', evs.urlWithParams(evs.URL,reqGetArgs));
	            request.send();
	        };

	        EventSource.prototype.XHR.prototype = {

	            useXDomainRequest: true,

	            _request: null,

	            _ready: false, // true when progress events are dispatched

	            _loaded: false, // true when request has been loaded

	            _failed: false, // true if when request is in error

	            isReady: function() {

	                return this._request._ready;
	            },

	            isDone: function() {

	                return this._request._loaded;
	            },

	            hasError: function() {

	                return this._request._failed;
	            },

	            getBuffer: function() {

	                var rv = '';
	                try {
	                    rv = this._request.responseText || '';
	                }
	                catch (e){}
	                return rv;
	            },

	            abort: function() {

	                if ( this._request){
	                    this._request.abort();
	                }
	            }
	        };
	    }

	    function MessageEvent(type, data, origin, lastEventId) {

	        this.bubbles = false;
	        this.cancelBubble = false;
	        this.cancelable = false;
	        this.data = data || null;
	        this.origin = origin || '';
	        this.lastEventId = lastEventId || '';
	        this.type = type || 'message';
	    }

	    function isOldIE () {

	        //return true if we are in IE8 or IE9
	        return (window.XDomainRequest && (window.XMLHttpRequest && new XMLHttpRequest().responseType === undefined)) ? true : false;
	    }

	    global[evsImportName] = EventSource;
	})(this);


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/*eslint-env browser*/

	var clientOverlay = document.createElement('div');
	var styles = {
	  background: 'rgba(0,0,0,0.85)',
	  color: '#E8E8E8',
	  lineHeight: '1.2',
	  whiteSpace: 'pre',
	  fontFamily: 'Menlo, Consolas, monospace',
	  fontSize: '13px',
	  position: 'fixed',
	  zIndex: 9999,
	  padding: '10px',
	  left: 0,
	  right: 0,
	  top: 0,
	  bottom: 0,
	  overflow: 'auto',
	  dir: 'ltr'
	};
	for (var key in styles) {
	  clientOverlay.style[key] = styles[key];
	}

	var ansiHTML = __webpack_require__(179);
	var colors = {
	  reset: ['transparent', 'transparent'],
	  black: '181818',
	  red: 'E36049',
	  green: 'B3CB74',
	  yellow: 'FFD080',
	  blue: '7CAFC2',
	  magenta: '7FACCA',
	  cyan: 'C3C2EF',
	  lightgrey: 'EBE7E3',
	  darkgrey: '6D7891'
	};
	ansiHTML.setColors(colors);

	var Entities = __webpack_require__(180).AllHtmlEntities;
	var entities = new Entities();

	exports.showProblems =
	function showProblems(type, lines) {
	  clientOverlay.innerHTML = '';
	  lines.forEach(function(msg) {
	    msg = ansiHTML(entities.encode(msg));
	    var div = document.createElement('div');
	    div.style.marginBottom = '26px';
	    div.innerHTML = problemType(type) + ' in ' + msg;
	    clientOverlay.appendChild(div);
	  });
	  if (document.body) {
	    document.body.appendChild(clientOverlay);
	  }
	};

	exports.clear =
	function clear() {
	  if (document.body && clientOverlay.parentNode) {
	    document.body.removeChild(clientOverlay);
	  }
	};

	var problemColors = {
	  errors: colors.red,
	  warnings: colors.yellow
	};

	function problemType (type) {
	  var color = problemColors[type] || colors.red;
	  return (
	    '<span style="background-color:#' + color + '; color:#fff; padding:2px 4px; border-radius: 2px">' +
	      type.slice(0, -1).toUpperCase() +
	    '</span>'
	  );
	}


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__resourceQuery, module) {/*eslint-env browser*/
	/*global __resourceQuery __webpack_public_path__*/

	var options = {
	  path: "/__webpack_hmr",
	  timeout: 20 * 1000,
	  overlay: true,
	  reload: false,
	  log: true,
	  warn: true
	};
	if (true) {
	  var querystring = __webpack_require__(185);
	  var overrides = querystring.parse(__resourceQuery.slice(1));
	  if (overrides.path) options.path = overrides.path;
	  if (overrides.timeout) options.timeout = overrides.timeout;
	  if (overrides.overlay) options.overlay = overrides.overlay !== 'false';
	  if (overrides.reload) options.reload = overrides.reload !== 'false';
	  if (overrides.noInfo && overrides.noInfo !== 'false') {
	    options.log = false;
	  }
	  if (overrides.quiet && overrides.quiet !== 'false') {
	    options.log = false;
	    options.warn = false;
	  }
	  if (overrides.dynamicPublicPath) {
	    options.path = __webpack_require__.p + options.path;
	  }
	}

	if (typeof window === 'undefined') {
	  // do nothing
	} else if (typeof window.EventSource === 'undefined') {
	  console.warn(
	    "webpack-hot-middleware's client requires EventSource to work. " +
	    "You should include a polyfill if you want to support this browser: " +
	    "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools"
	  );
	} else {
	  connect(window.EventSource);
	}

	function connect(EventSource) {
	  var source = new EventSource(options.path);
	  var lastActivity = new Date();

	  source.onopen = handleOnline;
	  source.onmessage = handleMessage;
	  source.onerror = handleDisconnect;

	  var timer = setInterval(function() {
	    if ((new Date() - lastActivity) > options.timeout) {
	      handleDisconnect();
	    }
	  }, options.timeout / 2);

	  function handleOnline() {
	    if (options.log) console.log("[HMR] connected");
	    lastActivity = new Date();
	  }

	  function handleMessage(event) {
	    lastActivity = new Date();
	    if (event.data == "\uD83D\uDC93") {
	      return;
	    }
	    try {
	      processMessage(JSON.parse(event.data));
	    } catch (ex) {
	      if (options.warn) {
	        console.warn("Invalid HMR message: " + event.data + "\n" + ex);
	      }
	    }
	  }

	  function handleDisconnect() {
	    clearInterval(timer);
	    source.close();
	    setTimeout(function() { connect(EventSource); }, options.timeout);
	  }

	}

	var reporter;
	// the reporter needs to be a singleton on the page
	// in case the client is being used by mutliple bundles
	// we only want to report once.
	// all the errors will go to all clients
	var singletonKey = '__webpack_hot_middleware_reporter__';
	if (typeof window !== 'undefined' && !window[singletonKey]) {
	  reporter = window[singletonKey] = createReporter();
	}

	function createReporter() {
	  var strip = __webpack_require__(186);

	  var overlay;
	  if (typeof document !== 'undefined' && options.overlay) {
	    overlay = __webpack_require__(177);
	  }

	  return {
	    problems: function(type, obj) {
	      if (options.warn) {
	        console.warn("[HMR] bundle has " + type + ":");
	        obj[type].forEach(function(msg) {
	          console.warn("[HMR] " + strip(msg));
	        });
	      }
	      if (overlay && type !== 'warnings') overlay.showProblems(type, obj[type]);
	    },
	    success: function() {
	      if (overlay) overlay.clear();
	    },
	    useCustomOverlay: function(customOverlay) {
	      overlay = customOverlay;
	    }
	  };
	}

	var processUpdate = __webpack_require__(188);

	var customHandler;
	var subscribeAllHandler;
	function processMessage(obj) {
	  switch(obj.action) {
	    case "building":
	      if (options.log) console.log("[HMR] bundle rebuilding");
	      break;
	    case "built":
	      if (options.log) {
	        console.log(
	          "[HMR] bundle " + (obj.name ? obj.name + " " : "") +
	          "rebuilt in " + obj.time + "ms"
	        );
	      }
	      // fall through
	    case "sync":
	      if (obj.errors.length > 0) {
	        if (reporter) reporter.problems('errors', obj);
	      } else {
	        if (reporter) {
	          if (obj.warnings.length > 0) reporter.problems('warnings', obj);
	          reporter.success();
	        }
	        processUpdate(obj.hash, obj.modules, options);
	      }
	      break;
	    default:
	      if (customHandler) {
	        customHandler(obj);
	      }
	  }

	  if (subscribeAllHandler) {
	    subscribeAllHandler(obj);
	  }
	}

	if (module) {
	  module.exports = {
	    subscribeAll: function subscribeAll(handler) {
	      subscribeAllHandler = handler;
	    },
	    subscribe: function subscribe(handler) {
	      customHandler = handler;
	    },
	    useCustomOverlay: function useCustomOverlay(customOverlay) {
	      if (reporter) reporter.useCustomOverlay(customOverlay);
	    }
	  };
	}

	/* WEBPACK VAR INJECTION */}.call(exports, "?noInfo=true&reload=true", __webpack_require__(189)(module)))

/***/ },
/* 179 */
/***/ function(module, exports) {

	'use strict'

	module.exports = ansiHTML

	// Reference to https://github.com/sindresorhus/ansi-regex
	var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

	var _defColors = {
	  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
	  black: '000',
	  red: 'ff0000',
	  green: '209805',
	  yellow: 'e8bf03',
	  blue: '0000ff',
	  magenta: 'ff00ff',
	  cyan: '00ffee',
	  lightgrey: 'f0f0f0',
	  darkgrey: '888'
	}
	var _styles = {
	  30: 'black',
	  31: 'red',
	  32: 'green',
	  33: 'yellow',
	  34: 'blue',
	  35: 'magenta',
	  36: 'cyan',
	  37: 'lightgrey'
	}
	var _openTags = {
	  '1': 'font-weight:bold', // bold
	  '2': 'opacity:0.8', // dim
	  '3': '<i>', // italic
	  '4': '<u>', // underscore
	  '8': 'display:none', // hidden
	  '9': '<del>' // delete
	}
	var _closeTags = {
	  '23': '</i>', // reset italic
	  '24': '</u>', // reset underscore
	  '29': '</del>' // reset delete
	}

	;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
	  _closeTags[n] = '</span>'
	})

	/**
	 * Converts text with ANSI color codes to HTML markup.
	 * @param {String} text
	 * @returns {*}
	 */
	function ansiHTML (text) {
	  // Returns the text if the string has no ANSI escape code.
	  if (!_regANSI.test(text)) {
	    return text
	  }

	  // Cache opened sequence.
	  var ansiCodes = []
	  // Replace with markup.
	  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
	    var ot = _openTags[seq]
	    if (ot) {
	      // If current sequence has been opened, close it.
	      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
	        ansiCodes.pop()
	        return '</span>'
	      }
	      // Open tag.
	      ansiCodes.push(seq)
	      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
	    }

	    var ct = _closeTags[seq]
	    if (ct) {
	      // Pop sequence
	      ansiCodes.pop()
	      return ct
	    }
	    return ''
	  })

	  // Make sure tags are closed.
	  var l = ansiCodes.length
	  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

	  return ret
	}

	/**
	 * Customize colors.
	 * @param {Object} colors reference to _defColors
	 */
	ansiHTML.setColors = function (colors) {
	  if (typeof colors !== 'object') {
	    throw new Error('`colors` parameter must be an Object.')
	  }

	  var _finalColors = {}
	  for (var key in _defColors) {
	    var hex = colors.hasOwnProperty(key) ? colors[key] : null
	    if (!hex) {
	      _finalColors[key] = _defColors[key]
	      continue
	    }
	    if ('reset' === key) {
	      if (typeof hex === 'string') {
	        hex = [hex]
	      }
	      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
	        return typeof h !== 'string'
	      })) {
	        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
	      }
	      var defHexColor = _defColors[key]
	      if (!hex[0]) {
	        hex[0] = defHexColor[0]
	      }
	      if (hex.length === 1 || !hex[1]) {
	        hex = [hex[0]]
	        hex.push(defHexColor[1])
	      }

	      hex = hex.slice(0, 2)
	    } else if (typeof hex !== 'string') {
	      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
	    }
	    _finalColors[key] = hex
	  }
	  _setTags(_finalColors)
	}

	/**
	 * Reset colors.
	 */
	ansiHTML.reset = function () {
	  _setTags(_defColors)
	}

	/**
	 * Expose tags, including open and close.
	 * @type {Object}
	 */
	ansiHTML.tags = {}

	if (Object.defineProperty) {
	  Object.defineProperty(ansiHTML.tags, 'open', {
	    get: function () { return _openTags }
	  })
	  Object.defineProperty(ansiHTML.tags, 'close', {
	    get: function () { return _closeTags }
	  })
	} else {
	  ansiHTML.tags.open = _openTags
	  ansiHTML.tags.close = _closeTags
	}

	function _setTags (colors) {
	  // reset all
	  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
	  // inverse
	  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
	  // dark grey
	  _openTags['90'] = 'color:#' + colors.darkgrey

	  for (var code in _styles) {
	    var color = _styles[code]
	    var oriColor = colors[color] || '000'
	    _openTags[code] = 'color:#' + oriColor
	    code = parseInt(code)
	    _openTags[(code + 10).toString()] = 'background:#' + oriColor
	  }
	}

	ansiHTML.reset()


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  XmlEntities: __webpack_require__(182),
	  Html4Entities: __webpack_require__(181),
	  Html5Entities: __webpack_require__(47),
	  AllHtmlEntities: __webpack_require__(47)
	};


/***/ },
/* 181 */
/***/ function(module, exports) {

	var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'Oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'oelig', 'oelig', 'scaron', 'scaron', 'yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
	var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

	var alphaIndex = {};
	var numIndex = {};

	var i = 0;
	var length = HTML_ALPHA.length;
	while (i < length) {
	    var a = HTML_ALPHA[i];
	    var c = HTML_CODES[i];
	    alphaIndex[a] = String.fromCharCode(c);
	    numIndex[c] = a;
	    i++;
	}

	/**
	 * @constructor
	 */
	function Html4Entities() {}

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.decode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
	        var chr;
	        if (entity.charAt(0) === "#") {
	            var code = entity.charAt(1).toLowerCase() === 'x' ?
	                parseInt(entity.substr(2), 16) :
	                parseInt(entity.substr(1));

	            if (!(isNaN(code) || code < -32768 || code > 65535)) {
	                chr = String.fromCharCode(code);
	            }
	        } else {
	            chr = alphaIndex[entity];
	        }
	        return chr || s;
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.decode = function(str) {
	    return new Html4Entities().decode(str);
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encode = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var alpha = numIndex[str.charCodeAt(i)];
	        result += alpha ? "&" + alpha + ";" : str.charAt(i);
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encode = function(str) {
	    return new Html4Entities().encode(str);
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encodeNonUTF = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var cc = str.charCodeAt(i);
	        var alpha = numIndex[cc];
	        if (alpha) {
	            result += "&" + alpha + ";";
	        } else if (cc < 32 || cc > 126) {
	            result += "&#" + cc + ";";
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encodeNonUTF = function(str) {
	    return new Html4Entities().encodeNonUTF(str);
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encodeNonASCII = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encodeNonASCII = function(str) {
	    return new Html4Entities().encodeNonASCII(str);
	};

	module.exports = Html4Entities;


/***/ },
/* 182 */
/***/ function(module, exports) {

	var ALPHA_INDEX = {
	    '&lt': '<',
	    '&gt': '>',
	    '&quot': '"',
	    '&apos': '\'',
	    '&amp': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&apos;': '\'',
	    '&amp;': '&'
	};

	var CHAR_INDEX = {
	    60: 'lt',
	    62: 'gt',
	    34: 'quot',
	    39: 'apos',
	    38: 'amp'
	};

	var CHAR_S_INDEX = {
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    '\'': '&apos;',
	    '&': '&amp;'
	};

	/**
	 * @constructor
	 */
	function XmlEntities() {}

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/<|>|"|'|&/g, function(s) {
	        return CHAR_S_INDEX[s];
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encode = function(str) {
	    return new XmlEntities().encode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.decode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
	        if (s.charAt(1) === '#') {
	            var code = s.charAt(2).toLowerCase() === 'x' ?
	                parseInt(s.substr(3), 16) :
	                parseInt(s.substr(2));

	            if (isNaN(code) || code < -32768 || code > 65535) {
	                return '';
	            }
	            return String.fromCharCode(code);
	        }
	        return ALPHA_INDEX[s] || s;
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.decode = function(str) {
	    return new XmlEntities().decode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encodeNonUTF = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        var alpha = CHAR_INDEX[c];
	        if (alpha) {
	            result += "&" + alpha + ";";
	            i++;
	            continue;
	        }
	        if (c < 32 || c > 126) {
	            result += '&#' + c + ';';
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encodeNonUTF = function(str) {
	    return new XmlEntities().encodeNonUTF(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encodeNonASCII = function(str) {
	    var strLenght = str.length;
	    if (strLenght === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLenght) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encodeNonASCII = function(str) {
	    return new XmlEntities().encodeNonASCII(str);
	 };

	module.exports = XmlEntities;


/***/ },
/* 183 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 184 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(183);
	exports.encode = exports.stringify = __webpack_require__(184);


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(187)();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },
/* 187 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
	};


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Based heavily on https://github.com/webpack/webpack/blob/
	 *  c0afdf9c6abc1dd70707c594e473802a566f7b6e/hot/only-dev-server.js
	 * Original copyright Tobias Koppers @sokra (MIT license)
	 */

	/* global window __webpack_hash__ */

	if (false) {
	  throw new Error("[HMR] Hot Module Replacement is disabled.");
	}

	var hmrDocsUrl = "http://webpack.github.io/docs/hot-module-replacement-with-webpack.html"; // eslint-disable-line max-len

	var lastHash;
	var failureStatuses = { abort: 1, fail: 1 };
	var applyOptions = { ignoreUnaccepted: true };

	function upToDate(hash) {
	  if (hash) lastHash = hash;
	  return lastHash == __webpack_require__.h();
	}

	module.exports = function(hash, moduleMap, options) {
	  var reload = options.reload;
	  if (!upToDate(hash) && module.hot.status() == "idle") {
	    if (options.log) console.log("[HMR] Checking for updates on the server...");
	    check();
	  }

	  function check() {
	    var cb = function(err, updatedModules) {
	      if (err) return handleError(err);

	      if(!updatedModules) {
	        if (options.warn) {
	          console.warn("[HMR] Cannot find update (Full reload needed)");
	          console.warn("[HMR] (Probably because of restarting the server)");
	        }
	        performReload();
	        return null;
	      }

	      var applyCallback = function(applyErr, renewedModules) {
	        if (applyErr) return handleError(applyErr);

	        if (!upToDate()) check();

	        logUpdates(updatedModules, renewedModules);
	      };

	      var applyResult = module.hot.apply(applyOptions, applyCallback);
	      // webpack 2 promise
	      if (applyResult && applyResult.then) {
	        // HotModuleReplacement.runtime.js refers to the result as `outdatedModules`
	        applyResult.then(function(outdatedModules) {
	          applyCallback(null, outdatedModules);
	        });
	        applyResult.catch(applyCallback);
	      }

	    };

	    var result = module.hot.check(false, cb);
	    // webpack 2 promise
	    if (result && result.then) {
	        result.then(function(updatedModules) {
	            cb(null, updatedModules);
	        });
	        result.catch(cb);
	    }
	  }

	  function logUpdates(updatedModules, renewedModules) {
	    var unacceptedModules = updatedModules.filter(function(moduleId) {
	      return renewedModules && renewedModules.indexOf(moduleId) < 0;
	    });

	    if(unacceptedModules.length > 0) {
	      if (options.warn) {
	        console.warn(
	          "[HMR] The following modules couldn't be hot updated: " +
	          "(Full reload needed)\n" +
	          "This is usually because the modules which have changed " +
	          "(and their parents) do not know how to hot reload themselves. " +
	          "See " + hmrDocsUrl + " for more details."
	        );
	        unacceptedModules.forEach(function(moduleId) {
	          console.warn("[HMR]  - " + moduleMap[moduleId]);
	        });
	      }
	      performReload();
	      return;
	    }

	    if (options.log) {
	      if(!renewedModules || renewedModules.length === 0) {
	        console.log("[HMR] Nothing hot updated.");
	      } else {
	        console.log("[HMR] Updated modules:");
	        renewedModules.forEach(function(moduleId) {
	          console.log("[HMR]  - " + moduleMap[moduleId]);
	        });
	      }

	      if (upToDate()) {
	        console.log("[HMR] App is up to date.");
	      }
	    }
	  }

	  function handleError(err) {
	    if (module.hot.status() in failureStatuses) {
	      if (options.warn) {
	        console.warn("[HMR] Cannot check for update (Full reload needed)");
	        console.warn("[HMR] " + err.stack || err.message);
	      }
	      performReload();
	      return;
	    }
	    if (options.warn) {
	      console.warn("[HMR] Update check failed: " + err.stack || err.message);
	    }
	  }

	  function performReload() {
	    if (reload) {
	      if (options.warn) console.warn("[HMR] Reloading page");
	      window.location.reload();
	    }
	  }
	};


/***/ },
/* 189 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }
/******/ ]);
//# sourceMappingURL=app.js.map