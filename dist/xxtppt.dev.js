/**
 * 判断加载环境 是否嵌套iframe
 * 1 单独杂志
 * 2 读库客户端
 * 3 妙妙学客户端
 * 4 新阅读客户端
 * 5 子文档模式
 * ........
 *
 * GLOBALCONTEXT 插件全局调用接口
 * GLOBALIFRAME  是否iframe加载
 *
 *
 *提供给iframe内的配置文件
 *
 *  window.XXTIFRAME = {
 *       path: "sdcard/" + config.appId + "/content/gallery/",
 *       iframeDrop: function () {
 *            //iframe退出的处理方法
 *       }
 *   }
 *
 */
;(function(CONFIG) {

    //上文环境
    //1 新阅读
    //2 子文档
    //3 本身
    //插件的上下文永远是GLOBALCONTEXT调用
    window.GLOBALCONTEXT = CONFIG.context; //全局上下文(兼容iframe父容器与本身执行环境)
    window.GLOBALIFRAME = CONFIG.iframeMode; //是否为iframe加载

    //读酷配置文件
    window.DUKUCONFIG = CONFIG.dukuConfig;
    //await
    //path
    //ifrmeDrop

    //嵌套子文档上下文
    window.SUbDOCCONTEXT = CONFIG.subContext;
    window.SUbCONFIGT = CONFIG.subConfig;

    //2014.11.26
    //新客户端模式Client
    //地址:url
    //ifrmeDrop
    //path
    //success
    window.CLIENTCONFIGT = CONFIG.clientConfig;

    //2015.3.11
    //秒秒学客户端配置
    window.MMXCONFIG = CONFIG.mmxConfig;

    /**
     * 2016.9.13
     * 新增动态模式
     * 本意去掉iframe模式
     * 这样可以做自动切换xxtppt.js
     * @type {Boolean}
     */
    window.DYNAMICCONFIGT = undefined

})(function() {

    //是否为iframe加载
    var iframeMode = false

    //最外层上下文
    var topContext = window

    //读库配置文件
    var dukuConfig

    //客户端配置文件
    var clientConfig

    //秒秒学客户端配置文件
    var mmxConfig

    //子容器上下文
    var subContext

    //子文档模式
    var subConfig


    //兼容ios处理
    //妙妙客户端版处理问题ios版
    try {
        if (top && top.audioHandler) {
            window.audioHandler = top.audioHandler
        }
    } catch (err) {}


    var match = {

        /**
         * 读库iframe加载
         */
        XXTIFRAME: function(context) {
            dukuConfig = context.XXTIFRAME
            topContext = context
            iframeMode = true
        },

        /**
         * 秒秒学在线客户端加载
         * @return {[type]} [description]
         */
        miaomiaoxue: function(context) {
            mmxConfig = context.miaomiaoxue
            topContext = context
            iframeMode = true
        },

        /**
         * 子文档加载
         */
        XXTSUbDOC: function(context) {
            if (!topContext) {
                topContext = context;
            }
            subContext = context;
            iframeMode = true;
            subConfig = context.XXTSUbDOC
        },

        /**
         * 客户端模式
         * 零件动态加载iframe
         */
        XXTClient: function(context) {
            clientConfig = context.XXTClient
            topContext = context;
            iframeMode = true;
        },

        /**
         * pc调试模式
         * @return {[type]} [description]
         */
        iframe: function() {
            if (!iframeMode) {
                iframeMode = true
            }
        }
    }


    /**
     * 匹配配置文件
     * @param  {[type]} context [description]
     * @return {[type]}         [description]
     */
    var scopeMatch = function(context) {
        try {
            if (!context) return;
            'XXTIFRAME,miaomiaoxue,XXTSUbDOC,XXTClient,iframe'.split(',').forEach(function(name) {
                context[name] && match[name](context)
            })
        } catch (er) {}
    }

    //搜索2层作用域
    //1 top
    //2 parent
    scopeMatch(parent)
    //嵌套iframe
    if (parent != top) {
        scopeMatch(top)
    }

    return {
        context: topContext,
        iframeMode: iframeMode,
        subContext: subContext,
        dukuConfig: dukuConfig,
        mmxConfig: mmxConfig,
        clientConfig: clientConfig,
        subConfig: subConfig
    }
}());

/**
 * 电子杂志全局命名
 * @singleton
 */
//sf浏览器调试 不能用hash 否则报错
window.Xut = {}

/**
 * 插件
 * @type {[type]}
 */
Xut.Plugin = {}
Xut.plugins = {}

/**
 * 平台
 * @type {[type]}
 */
Xut.plat = {}

/**
 * 样式
 * @type {[type]}
 */
Xut.style = {}

/**
 * 浅拷贝
 * @param  {[type]} target [description]
 * @param  {[type]} source [description]
 * @return {[type]}        [description]
 */
Xut.extend = function(target, source) {
    if (!source) {
        source = target
        target = this
    }
    for (var p in source) {
        if (source.hasOwnProperty(p)) {
            target[p] = source[p]
        }
    }
    return target
}

Xut.extend({

    /**
     * 生成32位UUID的方法
     * @return {[type]}               [description]
     */
    createUUID: (function(uuidRegEx, uuidReplacer) {
        return function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
        return v.toString(16);
    }),

    /**
     * 创建一个唯一的uuid
     * @param  {[type]} pre [description]
     * @return {[type]}     [description]
     */
    guid: function(pre) {
        return (pre || 'Xut_') + (+new Date()) + (Math.random() + '').slice(-8);
    },

    /**
     * 数组化
     * @return {[type]} [description]
     */
    toArray: function() {
        var slice = Array.prototype.slice
        return function(a, i, j) {
            return slice.call(a, i || 0, j || a.length);
        }
    }()
})


/**
 * @class String
 * 格式化字符串
 */
String.format = function(format) {
    var args = Xut.toArray(arguments, 1);
    return format.replace(/\{(\d+)\}/g, function(m, i) {
        return args[i];
    });
}


String.styleFormat = function(format) {
    return format.replace(/\s+/g, " ")
}

/**
 * 设备平台判断
 * @return {[type]} [description]
 */
;
(function() {

    // Browser environment sniffing
    var inBrowser =
        typeof window !== 'undefined' &&
        Object.prototype.toString.call(window) !== '[object Object]'

    //在读酷pc端 navigator的值被改写过了!!
    //navigator.appVersion: "xxt 1.0.5260.29725"
    var UA = inBrowser && window.navigator.userAgent.toLowerCase()
    var UV = inBrowser && window.navigator.appVersion.toLowerCase()
    var isAndroid = UA && UA.indexOf('android') > 0
    var isMacOS = UA && UA.indexOf('mac') > 0
    var isIphone = (/iphone|ipod/gi).test(UA)
    var isIpad = (/ipad/gi).test(UA)
    var isIOS = isIphone || isIpad
    var isIOS7 = isIOS && (/os\s7/gi).test(UA)
    var has3d = 'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix()

    //webkit内核
    var isWebKit = /applewebkit/ig.test(UV)

    //微信
    var isWeiXin = /micromessenger/ig.test(UV)

    //针对win8的处理
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i

    //支持触屏
    var SUPPORT_TOUCH = ('ontouchstart' in window)

    //支持鼠标
    var SUPPORT_MOUSE = ('onmousedown' in window)

    //移动端仅仅只支持touch
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(UA);

    //判断是否为浏览器
    //http://localhost:12344/index.html
    var location = document.location.href
    var boolBrowser = location.indexOf('http') > -1 || location.indexOf('https') > -1;


    /**
     * 私有前缀
     * @type {[type]}
     */
    var rdashAlpha = /-([a-z]|[0-9])/ig
    var rmsPrefix = /^-ms-/
    var fcamelCase = function(all, letter) {
        return (letter + '').toUpperCase();
    }
    var camelCase = function(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var PREFIX = ['webkit', 'Moz', 'ms', 'o']
    var _elementStyle = document.createElement('div').style
    var _cache = Object.create(null)
    var _prefixStyle = function(attr) {
        var name
            //缓存中存在
        if (_cache[attr]) {
            return _cache[attr];
        }
        //不需要加前缀
        if (attr in _elementStyle) {
            return _cache[attr] = attr;
        }
        //需要加前缀
        PREFIX.forEach(function(v) {
            if (camelCase(v + '-' + attr) in _elementStyle) {
                name = '-' + v + '-' + attr;
                return _cache[attr] = name;
            }
        })
        return name;
    }



    /**
     * css3 keyframes
     * @return {[type]} [description]
     */
    var transitionEnd = 'transitionend'
    var animationEnd = 'animationend'
    var keyframes = '@keyframes '
    var animation = _prefixStyle('animation');
    (function() {
        var vendors = animation
        var transitionEnd_NAMES = {
            "moz": "transitionend",
            "webkit": "webkitTransitionEnd",
            "ms": "MSTransitionEnd",
            "o": "oTransitionEnd"
        }
        var animationEnd_NAMES = {
            "moz": "animationend",
            "webkit": "webkitAnimationEnd",
            "ms": "MSAnimationEnd",
            "o": "oAnimationEnd"
        }
        if (!vendors) return;
        vendors = vendors.split('-');
        if (!vendors[1]) return;
        transitionEnd = transitionEnd_NAMES[vendors[1]];
        animationEnd = animationEnd_NAMES[vendors[1]];
        keyframes = '@-' + vendors[1] + '-keyframes ';
    })()


    var isBrowser = boolBrowser ? boolBrowser : !SUPPORT_ONLY_TOUCH

    //有hasMutationObserverBug
    var iosVersionMatch = isIOS && UA.match(/os ([\d_]+)/)
    var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_')
        // detecting iOS UIWebView by indexedDB
    var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB


    /**
     * 平台支持
     * @type {Object}
     */
    Xut.extend(Xut.plat, {
        has3d: has3d,
        isAndroid: isAndroid,
        isIphone: isIphone,
        isIpad: isIpad,
        isIOS: isIOS,
        isIOS7: isIOS7,
        isMacOS: isMacOS,

        hasMutationObserverBug: hasMutationObserverBug,

        /**
         * 是否在支持插件
         * phonegap
         * @type {Boolean}
         */
        hasPlugin:false,

        /**
         * 不能自动播放媒体
         * audio
         * video
         * @type {[type]}
         * 浏览器端
         * 不是微信
         * 是webkit
         * 是手机端浏览器
         */
        noAutoPlayMedia: !isWeiXin && isBrowser && SUPPORT_ONLY_TOUCH,

        /**
         * 支持触摸
         * @type {Boolean}
         */
        hasTouch: SUPPORT_ONLY_TOUCH,

        /**
         * 游览器平台 解决ios Android浏览器判断问题
         * @type {Boolean}
         */
        isBrowser: isBrowser,

        /**
         * 2015.3.23
         * isSurface
         * 可以点击与触摸
         * @type {Boolean}
         */
        isSurface: SUPPORT_TOUCH && SUPPORT_MOUSE && !SUPPORT_ONLY_TOUCH,

        /**
         * 是否桌面
         * @type {Boolean}
         */
        isDesktop: !SUPPORT_ONLY_TOUCH,

        /**
         * 事件对象
         * @param  {[type]} event    [description]
         * @param  {[type]} original [description]
         * @return {[type]}          [description]
         */
            evtTarget: function(event, original) {
            var currTouches = null;
            if (SUPPORT_ONLY_TOUCH) {
                currTouches = event.touches;
                if (currTouches && currTouches.length > 0) {
                    event = currTouches[0];
                }
            }
            return original ? event : event.target;
        }
    })


    /**
     * 支持转换效果
     * @type {Boolean}
     */
    var hasPerspective = _prefixStyle('perspective') in _elementStyle
    var translateZ = hasPerspective ? ' translateZ(0)' : ''
    var maskBoxImage = _prefixStyle('mask-box-image')


    var reqAnimationFrame = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) { window.setTimeout(callback, 1000 / 60); };

    /**
     * 样式style支持
     * @type {Object}
     */
    Xut.extend(Xut.style, {

        reqAnimationFrame: reqAnimationFrame,

        /**
         * 不支持蒙版
         * @type {[type]}
         */
        noMaskBoxImage: maskBoxImage == undefined,

        /**
         * 前缀
         * @type {[type]}
         */
        prefixStyle: _prefixStyle,

        /**
         * transform
         * @type {[type]}
         */
        transform: _prefixStyle('transform'),
        transition: _prefixStyle('transition'),
        transitionDuration: _prefixStyle('transition-duration'),
        transitionDelay: _prefixStyle('transition-delay'),
        transformOrigin: _prefixStyle('transform-origin'),
        transitionTimingFunction: _prefixStyle('transition-timing-function'),
        transitionEnd: transitionEnd,

        /**
         * css3 admination
         * @type {[type]}
         */
        animation: animation,
        animationDelay: _prefixStyle('animation-delay'),
        animationPlayState: _prefixStyle('animation-play-state'),
        animationEnd: animationEnd,
        keyframes: keyframes,

        /**
         * 支持3d Z
         * @type {[type]}
         */
        translateZ: translateZ,
        setTranslateZ: function(zValue) {
            return hasPerspective ? ' translateZ(' + zValue + ')' : ''
        },

        /**
         * 额外样式
         * @type {[type]}
         */
        filter: _prefixStyle('filter'),
        maskBoxImage: maskBoxImage,
        borderRadius: _prefixStyle('border-radius'),

        /**
         * css3分栏
         * @type {[type]}
         */
        columnWidth: _prefixStyle('column-width'),
        columnGap: _prefixStyle('column-gap')

    })

})()

/*
     **  frame窗口通信指导
     **  PMS 用于frame窗口之间通信
     **  PMS对象暴露三个接口
     * bind : 用于注册事件，当有窗口发送消息过来并且类匹配时，则会触发注册时相应的回调函数
     * send : 用于向指定的目标窗口发送信息
     * unbind : 取消之肖注册的事件
     *
     * 使用demo
     * 现在假设我们有两个frame窗口,一个是主窗口mainFrame ,一个是子窗口childFrame
     * 现在我们得在两个frame窗口中进行消息传递,则我们可以像下面这样操作
     *
     * 1 、 mainFrame传递消息到childFrame
     *    1.1 childFrame注册事件，在childFrame的js代码中
     *    PMS.bind('onload' , function(e){} , '*')
     *    此时childFrame已经注册了消息处理，当有窗口往childFrame消息事，此处注册的回调就会被执行
     *    参数{onload : 消息类型 , function : 回调函数 , '*' : 消息通信的域}
     *
     *    1.2 此时子窗口已准备，等待其它窗口发送消息的到来
     *    此时mainFrame给childFrame发送一个消息
     *    此处写在mainFrame的代码中
     *    PMS.send({
     *        target : frames[0],       //发送到目标窗口
     *        url :                     //URL
     *        type : 'onload' ,         //消息类型
     *        data : {                  //附带数据
     *            name : 'alice' ,
     *            age : 27
     *        },
     *        success : function(){     //成功回调
     *        },
     *        error : function(e){      //失败回调
     *        }
     *    });
     *
     *
     *   其它frame通信跟上面差不多,
     *   多个frame之间也能相互通信，只要通信目标正确即可
     *
     *   如果是子窗口发信息给父窗口，则像下面之样即可
     *   PMS.send({
     *       target : window.parent
     *       其它参数与上面相同
     *   });
     *
     *    target : 必填
     *    type : 必填
     *    其它参数可选
     *
     *    参考
     *    https://developer.mozilla.org/en-US/docs/DOM/window.postMessage
     *
     *  了解更多可分析下面源码
     *
 */

;(function(glob) {
    var PMS = function(options) {
        pm.send(options);
    };
    PMS.send = PMS;

    PMS.bind = function(type, fn, origin, hash, async_reply) {
        pm.bind(type, fn, origin, hash, async_reply === true);
    };

    PMS.event = {

        onData: function(fn, origin, hash, async_reply) {
            PMS.bind('onData', fn, origin || '*', hash, async_reply);
        },

        onLoad : function(fn, origin, hash, async_reply){
            PMS.bind('onLoad' , fn , origin || '*' , hash , async_reply);
        },

        onDestory :function(fn, origin, hash, async_reply){
            PMS.bind('onDestory' , fn ,  origin || '*' , hash , async_reply);
        },

        onHide : function(fn, origin, hash, async_reply){
            PMS.bind('onHide' , fn ,  origin || '*' , hash , async_reply);
        },

        onShow : function(fn, origin, hash, async_reply){
            PMS.bind('onShow' , fn ,  origin || '*' , hash , async_reply);
        },
        onFullscreen : function(fn, origin, hash, async_reply){
            PMS.bind('onFullscreen' , fn ,  origin || '*' , hash , async_reply);
        }
    };

    PMS.unbind = function(type, fn) {
        pm.unbind(type, fn);
    };

    var extend = function(destination, source) {
        for (var property in source) {
            destination[property] = source[property];
        }
        return destination;
    };

    var pm = {

        send: function(options) {
            var o = extend(pm.defaults, options),
                target = o.target;
            if (!o.target) {
                console.warn("消息目标窗口必须填写!");
                return;
            }
            var msg = {
                data: o.data,
                type: o.type
            };
            if (o.success) {
                msg.callback = pm._callback(o.success);
            }
            if (o.error) {
                msg.errback = pm._callback(o.error);
            }
            if (("postMessage" in target) && !o.hash) {
                pm._bind();
                target.postMessage(JSON.stringify(msg), o.origin || '*');
            }
        },

        bind: function(type, fn, origin, hash, async_reply) {
            pm._replyBind(type, fn, origin, hash, async_reply);
        },

        _replyBind: function(type, fn, origin, hash, isCallback) {
            if (("postMessage" in window) && !hash) {
                pm._bind();
            }
            var l = pm.data("listeners.postmessage");
            if (!l) {
                l = {};
                pm.data("listeners.postmessage", l);
            }
            var fns = l[type];
            if (!fns) {
                fns = [];
                l[type] = fns;
            }
            fns.push({
                fn: fn,
                callback: isCallback,
                origin: origin || $.pm.origin
            });
        },

        unbind: function(type, fn) {
            var l = pm.data("listeners.postmessage"),
                c = pm.data("callbacks.postmessage");
            if (l) {
                if (type) {
                    if (fn) {
                        var fns = l[type];
                        if (fns) {
                            var m = [];
                            for (var i = 0, len = fns.length; i < len; i++) {
                                var o = fns[i];
                                if (o.fn !== fn) {
                                    m.push(o);
                                }
                            }
                            l[type] = m;
                        }
                    } else {
                        delete l[type];
                    }
                } else {
                    for (var i in l) {
                        delete l[i];
                    }
                }
            }

            if (c) {
                if (type) {
                    if (fn) {
                        var fns = c[type];
                        if (fns) {
                            var m = [];
                            for (var i = 0, len = fns.length; i < len; i++) {
                                var o = fns[i];
                                if (o.fn !== fn) {
                                    m.push(o);
                                }
                            }
                            c[type] = m;
                        }
                    } else {
                        delete c[type];
                    }
                } else {
                    for (var i in c) {
                        delete c[i];
                    }
                }
            }
        },

        data: function(k, v) {
            if (v === undefined) {
                return pm._data[k];
            }
            pm._data[k] = v;
            return v;
        },

        _data: {},

        _generate: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        },

        _callback: function(fn) {
            var cbs = pm.data("callbacks.postmessage");
            if (!cbs) {
                cbs = {};
                pm.data("callbacks.postmessage", cbs);
            }
            var r = pm._generate();
            cbs[r] = fn;
            return r;
        },

        _bind: function() {
            if (!pm.data("listening.postmessage")) {
                if (window.addEventListener) {
                    window.addEventListener("message", pm._dispatch, false);
                } else if (window.attachEvent) {
                    window.attachEvent("onmessage", pm._dispatch);
                }
                pm.data("listening.postmessage", 1);
            }
        },
        _dispatch: function(e) {
            try {
                var msg = JSON.parse(e.data);
            } catch (ex) {
                console.warn("消息的数据是无效的json", ex);
                return;
            }
            if (!msg.type) {
                console.warn("必须填写对应的消息类型");
                return;
            }
            var cbs = pm.data("callbacks.postmessage") || {},
            cb = cbs[msg.type];
            if (cb) {
                cb(msg.data);
            } else {
                var l = pm.data("listeners.postmessage") || {};
                var fns = l[msg.type] || [];
                for (var i = 0, len = fns.length; i < len; i++) {
                    var o = fns[i];
                    if (o.origin && o.origin !== '*' && e.origin !== o.origin) {
                        console.warn("消息来源不匹配!", e.origin, o.origin);
                        if (msg.errback) {
                            var error = {
                                message: "消息来源不匹配",
                                origin: [e.origin, o.origin]
                            };

                            pm.send({
                                target: e.source,
                                data: error,
                                type: msg.errback
                            });
                        }
                        continue;
                    }

                    function sendReply(data) {
                        if (msg.callback) {
                            pm.send({
                                target: e.source,
                                data: data,
                                type: msg.callback
                            });
                        }
                    }
                    try {
                        if (o.callback) {
                            o.fn(msg.data, sendReply, e);
                        } else {
                            sendReply(o.fn(msg.data, e));
                        }
                    } catch (ex) {
                        if (msg.errback) {
                            pm.send({
                                target: e.source,
                                data: ex,
                                type: msg.errback
                            });
                        } else {
                            throw ex;
                        }
                    }
                };
            }
        }
    };

    pm.defaults = {
        target: null,
        /* 目标窗口 (required) */
        url: null,
        /* 目标窗口URL (optional) */
        type: null,
        /* 消息类型 (required) */
        data: null,
        /* 消息数据 (optional) */
        success: null,
        /* 成功回调 (optional) */
        error: null,
        /* 失败回调 (optional) */
        origin: "*"
        /* 消息域 (optional) */
    }

    var module = module || 'undefined';
    (typeof module != "undefined" && module.exports) ? (module.exports = PMS) : (typeof define != "undefined" ? (define("PMS", [], function() {
        return PMS;
    })) : (glob.PMS = PMS));
})(this);
/**************************
 *
 *   epub新增加
 *   需要调用2次
 *   一次是因为打包的关系，全局加载
 *   二次是 实际epub模式加载
 *
 * *************************/

/**
 * 动态html文件挂载点
 * 用于content动态加载js文件
 * 目前暂时给epub使用，文本框
 * @type {Object}
 */
window.HTMLCONFIG = {}


/**
 *
 * 2015.10.19新增
 * ibooks处理
 * epub ibooks模式的配置文件
 * 这个是在index.html中会传入几个值
 *
 *   window.IBOOKSCONFIG = {
 *       compiled: true,
 *       pageIndex: 1,
 *       existSvg: true,
 *       screenSize: {
 *           "width": 718,
 *           "height": 958
 *       }
 *   }
 */
var IBOOKSCONFIG = window.IBOOKSCONFIG;

//如果是IBOOS模式处理
//注入保持与数据库H5查询一致
if (IBOOKSCONFIG && IBOOKSCONFIG.data) {
    _.each(IBOOKSCONFIG.data, function(data, tabName) {
            data.item = function(index) {
                return this[index];
            }
        })
        //ios上的ibooks模式
        //直接修改改isBrowser模式
    Xut.plat.isBrowser = true;
    Xut.plat.isIOS = false;
}

//配置ibooks参数
Xut.IBooks = {

    /**
     * 当前页面编号
     * @return {[type]} [description]
     */
    pageIndex: function() {
        if (IBOOKSCONFIG) {
            //当期页面索引1开始
            return IBOOKSCONFIG.pageIndex + 1;
        }
    }(),

    /**
     * 是否存在svg
     * @type {[type]}
     */
    existSvg: IBOOKSCONFIG ? IBOOKSCONFIG.existSvg : false,

    /**
     * 是否启动了ibooks模式
     * @return {[type]} [description]
     */
    Enabled: function() {
        return IBOOKSCONFIG ? true : false;
    }(),

    /**
     * 全部对象
     * @type {[type]}
     */
    CONFIG: IBOOKSCONFIG,

    /**
     * 运行期间
     * @return {[type]} [description]
     */
    runMode: function() {
        //确定为ibooks的运行状态
        //而非预编译状态
        if (IBOOKSCONFIG && !IBOOKSCONFIG.compiled) {
            return true;
        }
        return false;
    },
    /**
     * 编译期间
     * @return {[type]} [description]
     */
    compileMode: function() {
        //确定为ibooks的编译状态
        //而非预编译状态
        if (IBOOKSCONFIG && IBOOKSCONFIG.compiled) {
            return true;
        }
        return false;
    }
};


/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

  if ( typeof module === "object" && typeof module.exports === "object" ) {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ?
      factory( global, true ) :
      function( w ) {
        if ( !w.document ) {
          throw new Error( "jQuery requires a window with a document" );
        }
        return factory( w );
      };
  } else {
    factory( global );
  }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
  // Use the correct document accordingly with window argument (sandbox)
  document = window.document,

  version = "2.1.3",

  // Define a local copy of jQuery
  jQuery = function( selector, context ) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init( selector, context );
  },

  // Support: Android<4.1
  // Make sure we trim BOM and NBSP
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

  // Matches dashed string for camelizing
  rmsPrefix = /^-ms-/,
  rdashAlpha = /-([\da-z])/gi,

  // Used by jQuery.camelCase as callback to replace()
  fcamelCase = function( all, letter ) {
    return letter.toUpperCase();
  };

jQuery.fn = jQuery.prototype = {
  // The current version of jQuery being used
  jquery: version,

  constructor: jQuery,

  // Start with an empty selector
  selector: "",

  // The default length of a jQuery object is 0
  length: 0,

  toArray: function() {
    return slice.call( this );
  },

  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function( num ) {
    return num != null ?

      // Return just the one element from the set
      ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

      // Return all the elements in a clean array
      slice.call( this );
  },

  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function( elems ) {

    // Build a new jQuery matched element set
    var ret = jQuery.merge( this.constructor(), elems );

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;
    ret.context = this.context;

    // Return the newly-formed element set
    return ret;
  },

  // Execute a callback for every element in the matched set.
  // (You can seed the arguments with an array of args, but this is
  // only used internally.)
  each: function( callback, args ) {
    return jQuery.each( this, callback, args );
  },

  map: function( callback ) {
    return this.pushStack( jQuery.map(this, function( elem, i ) {
      return callback.call( elem, i, elem );
    }));
  },

  slice: function() {
    return this.pushStack( slice.apply( this, arguments ) );
  },

  first: function() {
    return this.eq( 0 );
  },

  last: function() {
    return this.eq( -1 );
  },

  eq: function( i ) {
    var len = this.length,
      j = +i + ( i < 0 ? len : 0 );
    return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
  },

  end: function() {
    return this.prevObject || this.constructor(null);
  },

  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push: push,
  sort: arr.sort,
  splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
  var options, name, src, copy, copyIsArray, clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // Handle a deep copy situation
  if ( typeof target === "boolean" ) {
    deep = target;

    // Skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
    target = {};
  }

  // Extend jQuery itself if only one argument is passed
  if ( i === length ) {
    target = this;
    i--;
  }

  for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
      // Extend the base object
      for ( name in options ) {
        src = target[ name ];
        copy = options[ name ];

        // Prevent never-ending loop
        if ( target === copy ) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
          if ( copyIsArray ) {
            copyIsArray = false;
            clone = src && jQuery.isArray(src) ? src : [];

          } else {
            clone = src && jQuery.isPlainObject(src) ? src : {};
          }

          // Never move original objects, clone them
          target[ name ] = jQuery.extend( deep, clone, copy );

        // Don't bring in undefined values
        } else if ( copy !== undefined ) {
          target[ name ] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

jQuery.extend({
  // Unique for each copy of jQuery on the page
  expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  // Assume jQuery is ready without the ready module
  isReady: true,

  error: function( msg ) {
    throw new Error( msg );
  },

  noop: function() {},

  isFunction: function( obj ) {
    return jQuery.type(obj) === "function";
  },

  isArray: Array.isArray,

  isWindow: function( obj ) {
    return obj != null && obj === obj.window;
  },

  isNumeric: function( obj ) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
  },

  isPlainObject: function( obj ) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
      return false;
    }

    if ( obj.constructor &&
        !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
      return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
  },

  isEmptyObject: function( obj ) {
    var name;
    for ( name in obj ) {
      return false;
    }
    return true;
  },

  type: function( obj ) {
    if ( obj == null ) {
      return obj + "";
    }
    // Support: Android<4.0, iOS<6 (functionish RegExp)
    return typeof obj === "object" || typeof obj === "function" ?
      class2type[ toString.call(obj) ] || "object" :
      typeof obj;
  },

  // Evaluates a script in a global context
  globalEval: function( code ) {
    var script,
      indirect = eval;

    code = jQuery.trim( code );

    if ( code ) {
      // If the code includes a valid, prologue position
      // strict mode pragma, execute code by injecting a
      // script tag into the document.
      if ( code.indexOf("use strict") === 1 ) {
        script = document.createElement("script");
        script.text = code;
        document.head.appendChild( script ).parentNode.removeChild( script );
      } else {
      // Otherwise, avoid the DOM node creation, insertion
      // and removal by using an indirect global eval
        indirect( code );
      }
    }
  },

  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE9-11+
  // Microsoft forgot to hump their vendor prefix (#9572)
  camelCase: function( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  },

  nodeName: function( elem, name ) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  },

  // args is for internal usage only
  each: function( obj, callback, args ) {
    var value,
      i = 0,
      length = obj.length,
      isArray = isArraylike( obj );

    if ( args ) {
      if ( isArray ) {
        for ( ; i < length; i++ ) {
          value = callback.apply( obj[ i ], args );

          if ( value === false ) {
            break;
          }
        }
      } else {
        for ( i in obj ) {
          value = callback.apply( obj[ i ], args );

          if ( value === false ) {
            break;
          }
        }
      }

    // A special, fast, case for the most common use of each
    } else {
      if ( isArray ) {
        for ( ; i < length; i++ ) {
          value = callback.call( obj[ i ], i, obj[ i ] );

          if ( value === false ) {
            break;
          }
        }
      } else {
        for ( i in obj ) {
          value = callback.call( obj[ i ], i, obj[ i ] );

          if ( value === false ) {
            break;
          }
        }
      }
    }

    return obj;
  },

  // Support: Android<4.1
  trim: function( text ) {
    return text == null ?
      "" :
      ( text + "" ).replace( rtrim, "" );
  },

  // results is for internal usage only
  makeArray: function( arr, results ) {
    var ret = results || [];

    if ( arr != null ) {
      if ( isArraylike( Object(arr) ) ) {
        jQuery.merge( ret,
          typeof arr === "string" ?
          [ arr ] : arr
        );
      } else {
        push.call( ret, arr );
      }
    }

    return ret;
  },

  inArray: function( elem, arr, i ) {
    return arr == null ? -1 : indexOf.call( arr, elem, i );
  },

  merge: function( first, second ) {
    var len = +second.length,
      j = 0,
      i = first.length;

    for ( ; j < len; j++ ) {
      first[ i++ ] = second[ j ];
    }

    first.length = i;

    return first;
  },

  grep: function( elems, callback, invert ) {
    var callbackInverse,
      matches = [],
      i = 0,
      length = elems.length,
      callbackExpect = !invert;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( ; i < length; i++ ) {
      callbackInverse = !callback( elems[ i ], i );
      if ( callbackInverse !== callbackExpect ) {
        matches.push( elems[ i ] );
      }
    }

    return matches;
  },

  // arg is for internal usage only
  map: function( elems, callback, arg ) {
    var value,
      i = 0,
      length = elems.length,
      isArray = isArraylike( elems ),
      ret = [];

    // Go through the array, translating each of the items to their new values
    if ( isArray ) {
      for ( ; i < length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret.push( value );
        }
      }

    // Go through every key on the object,
    } else {
      for ( i in elems ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret.push( value );
        }
      }
    }

    // Flatten any nested arrays
    return concat.apply( [], ret );
  },

  // A global GUID counter for objects
  guid: 1,

  // Bind a function to a context, optionally partially applying any
  // arguments.
  proxy: function( fn, context ) {
    var tmp, args, proxy;

    if ( typeof context === "string" ) {
      tmp = fn[ context ];
      context = fn;
      fn = tmp;
    }

    // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.
    if ( !jQuery.isFunction( fn ) ) {
      return undefined;
    }

    // Simulated bind
    args = slice.call( arguments, 2 );
    proxy = function() {
      return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
    };

    // Set the guid of unique handler to the same of original handler, so it can be removed
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

    return proxy;
  },

  now: Date.now,

  // jQuery.support is not used in Core but other projects attach their
  // properties to it so it needs to exist.
  support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
  class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
  var length = obj.length,
    type = jQuery.type( obj );

  if ( type === "function" || jQuery.isWindow( obj ) ) {
    return false;
  }

  if ( obj.nodeType === 1 && length ) {
    return true;
  }

  return type === "array" || length === 0 ||
    typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
  support,
  Expr,
  getText,
  isXML,
  tokenize,
  compile,
  select,
  outermostContext,
  sortInput,
  hasDuplicate,

  // Local document vars
  setDocument,
  document,
  docElem,
  documentIsHTML,
  rbuggyQSA,
  rbuggyMatches,
  matches,
  contains,

  // Instance-specific data
  expando = "sizzle" + 1 * new Date(),
  preferredDoc = window.document,
  dirruns = 0,
  done = 0,
  classCache = createCache(),
  tokenCache = createCache(),
  compilerCache = createCache(),
  sortOrder = function( a, b ) {
    if ( a === b ) {
      hasDuplicate = true;
    }
    return 0;
  },

  // General-purpose constants
  MAX_NEGATIVE = 1 << 31,

  // Instance methods
  hasOwn = ({}).hasOwnProperty,
  arr = [],
  pop = arr.pop,
  push_native = arr.push,
  push = arr.push,
  slice = arr.slice,
  // Use a stripped-down indexOf as it's faster than native
  // http://jsperf.com/thor-indexof-vs-for/5
  indexOf = function( list, elem ) {
    var i = 0,
      len = list.length;
    for ( ; i < len; i++ ) {
      if ( list[i] === elem ) {
        return i;
      }
    }
    return -1;
  },

  booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

  // Regular expressions

  // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
  whitespace = "[\\x20\\t\\r\\n\\f]",
  // http://www.w3.org/TR/css3-syntax/#characters
  characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

  // Loosely modeled on CSS identifier characters
  // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
  // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  identifier = characterEncoding.replace( "w", "w#" ),

  // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
    // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace +
    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
    "*\\]",

  pseudos = ":(" + characterEncoding + ")(?:\\((" +
    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
    // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
    // 3. anything else (capture 2)
    ".*" +
    ")\\)|)",

  // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  rwhitespace = new RegExp( whitespace + "+", "g" ),
  rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

  rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

  rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

  rpseudo = new RegExp( pseudos ),
  ridentifier = new RegExp( "^" + identifier + "$" ),

  matchExpr = {
    "ID": new RegExp( "^#(" + characterEncoding + ")" ),
    "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
    "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
    "ATTR": new RegExp( "^" + attributes ),
    "PSEUDO": new RegExp( "^" + pseudos ),
    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
      "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
      "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
    // For use in libraries implementing .is()
    // We use this for POS matching in `select`
    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
      whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  },

  rinputs = /^(?:input|select|textarea|button)$/i,
  rheader = /^h\d$/i,

  rnative = /^[^{]+\{\s*\[native \w/,

  // Easily-parseable/retrievable ID or TAG or CLASS selectors
  rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  rsibling = /[+~]/,
  rescape = /'|\\/g,

  // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
  funescape = function( _, escaped, escapedWhitespace ) {
    var high = "0x" + escaped - 0x10000;
    // NaN means non-codepoint
    // Support: Firefox<24
    // Workaround erroneous numeric interpretation of +"0x"
    return high !== high || escapedWhitespace ?
      escaped :
      high < 0 ?
        // BMP codepoint
        String.fromCharCode( high + 0x10000 ) :
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  },

  // Used for iframes
  // See setDocument()
  // Removing the function wrapper causes a "Permission Denied"
  // error in IE
  unloadHandler = function() {
    setDocument();
  };

// Optimize for push.apply( _, NodeList )
try {
  push.apply(
    (arr = slice.call( preferredDoc.childNodes )),
    preferredDoc.childNodes
  );
  // Support: Android<4.0
  // Detect silently failing push.apply
  arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
  push = { apply: arr.length ?

    // Leverage slice if possible
    function( target, els ) {
      push_native.apply( target, slice.call(els) );
    } :

    // Support: IE<9
    // Otherwise append directly
    function( target, els ) {
      var j = target.length,
        i = 0;
      // Can't trust NodeList.length
      while ( (target[j++] = els[i++]) ) {}
      target.length = j - 1;
    }
  };
}

function Sizzle( selector, context, results, seed ) {
  var match, elem, m, nodeType,
    // QSA vars
    i, groups, old, nid, newContext, newSelector;

  if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
    setDocument( context );
  }

  context = context || document;
  results = results || [];
  nodeType = context.nodeType;

  if ( typeof selector !== "string" || !selector ||
    nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

    return results;
  }

  if ( !seed && documentIsHTML ) {

    // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
    if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
      // Speed-up: Sizzle("#ID")
      if ( (m = match[1]) ) {
        if ( nodeType === 9 ) {
          elem = context.getElementById( m );
          // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document (jQuery #6963)
          if ( elem && elem.parentNode ) {
            // Handle the case where IE, Opera, and Webkit return items
            // by name instead of ID
            if ( elem.id === m ) {
              results.push( elem );
              return results;
            }
          } else {
            return results;
          }
        } else {
          // Context is not a document
          if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
            contains( context, elem ) && elem.id === m ) {
            results.push( elem );
            return results;
          }
        }

      // Speed-up: Sizzle("TAG")
      } else if ( match[2] ) {
        push.apply( results, context.getElementsByTagName( selector ) );
        return results;

      // Speed-up: Sizzle(".CLASS")
      } else if ( (m = match[3]) && support.getElementsByClassName ) {
        push.apply( results, context.getElementsByClassName( m ) );
        return results;
      }
    }

    // QSA path
    if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
      nid = old = expando;
      newContext = context;
      newSelector = nodeType !== 1 && selector;

      // qSA works strangely on Element-rooted queries
      // We can work around this by specifying an extra ID on the root
      // and working up from there (Thanks to Andrew Dupont for the technique)
      // IE 8 doesn't work on object elements
      if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
        groups = tokenize( selector );

        if ( (old = context.getAttribute("id")) ) {
          nid = old.replace( rescape, "\\$&" );
        } else {
          context.setAttribute( "id", nid );
        }
        nid = "[id='" + nid + "'] ";

        i = groups.length;
        while ( i-- ) {
          groups[i] = nid + toSelector( groups[i] );
        }
        newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
        newSelector = groups.join(",");
      }

      if ( newSelector ) {
        try {
          push.apply( results,
            newContext.querySelectorAll( newSelector )
          );
          return results;
        } catch(qsaError) {
        } finally {
          if ( !old ) {
            context.removeAttribute("id");
          }
        }
      }
    }
  }

  // All others
  return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *  deleting the oldest entry
 */
function createCache() {
  var keys = [];

  function cache( key, value ) {
    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
    if ( keys.push( key + " " ) > Expr.cacheLength ) {
      // Only keep the most recent entries
      delete cache[ keys.shift() ];
    }
    return (cache[ key + " " ] = value);
  }
  return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
  fn[ expando ] = true;
  return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
  var div = document.createElement("div");

  try {
    return !!fn( div );
  } catch (e) {
    return false;
  } finally {
    // Remove from its parent by default
    if ( div.parentNode ) {
      div.parentNode.removeChild( div );
    }
    // release memory in IE
    div = null;
  }
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
  var arr = attrs.split("|"),
    i = attrs.length;

  while ( i-- ) {
    Expr.attrHandle[ arr[i] ] = handler;
  }
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
  var cur = b && a,
    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
      ( ~b.sourceIndex || MAX_NEGATIVE ) -
      ( ~a.sourceIndex || MAX_NEGATIVE );

  // Use IE sourceIndex if available on both nodes
  if ( diff ) {
    return diff;
  }

  // Check if b follows a
  if ( cur ) {
    while ( (cur = cur.nextSibling) ) {
      if ( cur === b ) {
        return -1;
      }
    }
  }

  return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return name === "input" && elem.type === type;
  };
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return (name === "input" || name === "button") && elem.type === type;
  };
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
  return markFunction(function( argument ) {
    argument = +argument;
    return markFunction(function( seed, matches ) {
      var j,
        matchIndexes = fn( [], seed.length, argument ),
        i = matchIndexes.length;

      // Match elements found at the specified indexes
      while ( i-- ) {
        if ( seed[ (j = matchIndexes[i]) ] ) {
          seed[j] = !(matches[j] = seed[j]);
        }
      }
    });
  });
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
  return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
  // documentElement is verified for cases where it doesn't yet exist
  // (such as loading iframes in IE - #4833)
  var documentElement = elem && (elem.ownerDocument || elem).documentElement;
  return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
  var hasCompare, parent,
    doc = node ? node.ownerDocument || node : preferredDoc;

  // If no document and documentElement is available, return
  if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
    return document;
  }

  // Set our document
  document = doc;
  docElem = doc.documentElement;
  parent = doc.defaultView;

  // Support: IE>8
  // If iframe document is assigned to "document" variable and if iframe has been reloaded,
  // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
  // IE6-8 do not support the defaultView property so parent will be undefined
  if ( parent && parent !== parent.top ) {
    // IE11 does not have attachEvent, so all must suffer
    if ( parent.addEventListener ) {
      parent.addEventListener( "unload", unloadHandler, false );
    } else if ( parent.attachEvent ) {
      parent.attachEvent( "onunload", unloadHandler );
    }
  }

  /* Support tests
  ---------------------------------------------------------------------- */
  documentIsHTML = !isXML( doc );

  /* Attributes
  ---------------------------------------------------------------------- */

  // Support: IE<8
  // Verify that getAttribute really returns attributes and not properties
  // (excepting IE8 booleans)
  support.attributes = assert(function( div ) {
    div.className = "i";
    return !div.getAttribute("className");
  });

  /* getElement(s)By*
  ---------------------------------------------------------------------- */

  // Check if getElementsByTagName("*") returns only elements
  support.getElementsByTagName = assert(function( div ) {
    div.appendChild( doc.createComment("") );
    return !div.getElementsByTagName("*").length;
  });

  // Support: IE<9
  support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

  // Support: IE<10
  // Check if getElementById returns elements by name
  // The broken getElementById methods don't pick up programatically-set names,
  // so use a roundabout getElementsByName test
  support.getById = assert(function( div ) {
    docElem.appendChild( div ).id = expando;
    return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
  });

  // ID find and filter
  if ( support.getById ) {
    Expr.find["ID"] = function( id, context ) {
      if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
        var m = context.getElementById( id );
        // Check parentNode to catch when Blackberry 4.6 returns
        // nodes that are no longer in the document #6963
        return m && m.parentNode ? [ m ] : [];
      }
    };
    Expr.filter["ID"] = function( id ) {
      var attrId = id.replace( runescape, funescape );
      return function( elem ) {
        return elem.getAttribute("id") === attrId;
      };
    };
  } else {
    // Support: IE6/7
    // getElementById is not reliable as a find shortcut
    delete Expr.find["ID"];

    Expr.filter["ID"] =  function( id ) {
      var attrId = id.replace( runescape, funescape );
      return function( elem ) {
        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
        return node && node.value === attrId;
      };
    };
  }

  // Tag
  Expr.find["TAG"] = support.getElementsByTagName ?
    function( tag, context ) {
      if ( typeof context.getElementsByTagName !== "undefined" ) {
        return context.getElementsByTagName( tag );

      // DocumentFragment nodes don't have gEBTN
      } else if ( support.qsa ) {
        return context.querySelectorAll( tag );
      }
    } :

    function( tag, context ) {
      var elem,
        tmp = [],
        i = 0,
        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName( tag );

      // Filter out possible comments
      if ( tag === "*" ) {
        while ( (elem = results[i++]) ) {
          if ( elem.nodeType === 1 ) {
            tmp.push( elem );
          }
        }

        return tmp;
      }
      return results;
    };

  // Class
  Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
    if ( documentIsHTML ) {
      return context.getElementsByClassName( className );
    }
  };

  /* QSA/matchesSelector
  ---------------------------------------------------------------------- */

  // QSA and matchesSelector support

  // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  rbuggyMatches = [];

  // qSa(:focus) reports false when true (Chrome 21)
  // We allow this because of a bug in IE8/9 that throws an error
  // whenever `document.activeElement` is accessed on an iframe
  // So, we allow :focus to pass through QSA all the time to avoid the IE error
  // See http://bugs.jquery.com/ticket/13378
  rbuggyQSA = [];

  if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
    // Build QSA regex
    // Regex strategy adopted from Diego Perini
    assert(function( div ) {
      // Select is set to empty string on purpose
      // This is to test IE's treatment of not explicitly
      // setting a boolean content attribute,
      // since its presence should be enough
      // http://bugs.jquery.com/ticket/12359
      docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
        "<select id='" + expando + "-\f]' msallowcapture=''>" +
        "<option selected=''></option></select>";

      // Support: IE8, Opera 11-12.16
      // Nothing should be selected when empty strings follow ^= or $= or *=
      // The test attribute must be unknown in Opera but "safe" for WinRT
      // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
      if ( div.querySelectorAll("[msallowcapture^='']").length ) {
        rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
      }

      // Support: IE8
      // Boolean attributes and "value" are not treated correctly
      if ( !div.querySelectorAll("[selected]").length ) {
        rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
      }

      // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
      if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
        rbuggyQSA.push("~=");
      }

      // Webkit/Opera - :checked should return selected option elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      // IE8 throws error here and will not see later tests
      if ( !div.querySelectorAll(":checked").length ) {
        rbuggyQSA.push(":checked");
      }

      // Support: Safari 8+, iOS 8+
      // https://bugs.webkit.org/show_bug.cgi?id=136851
      // In-page `selector#id sibing-combinator selector` fails
      if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
        rbuggyQSA.push(".#.+[+~]");
      }
    });

    assert(function( div ) {
      // Support: Windows 8 Native Apps
      // The type and name attributes are restricted during .innerHTML assignment
      var input = doc.createElement("input");
      input.setAttribute( "type", "hidden" );
      div.appendChild( input ).setAttribute( "name", "D" );

      // Support: IE8
      // Enforce case-sensitivity of name attribute
      if ( div.querySelectorAll("[name=d]").length ) {
        rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
      }

      // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
      // IE8 throws error here and will not see later tests
      if ( !div.querySelectorAll(":enabled").length ) {
        rbuggyQSA.push( ":enabled", ":disabled" );
      }

      // Opera 10-11 does not throw on post-comma invalid pseudos
      div.querySelectorAll("*,:x");
      rbuggyQSA.push(",.*:");
    });
  }

  if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
    docElem.webkitMatchesSelector ||
    docElem.mozMatchesSelector ||
    docElem.oMatchesSelector ||
    docElem.msMatchesSelector) )) ) {

    assert(function( div ) {
      // Check to see if it's possible to do matchesSelector
      // on a disconnected node (IE 9)
      support.disconnectedMatch = matches.call( div, "div" );

      // This should fail with an exception
      // Gecko does not error, returns false instead
      matches.call( div, "[s!='']:x" );
      rbuggyMatches.push( "!=", pseudos );
    });
  }

  rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
  rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

  /* Contains
  ---------------------------------------------------------------------- */
  hasCompare = rnative.test( docElem.compareDocumentPosition );

  // Element contains another
  // Purposefully does not implement inclusive descendent
  // As in, an element does not contain itself
  contains = hasCompare || rnative.test( docElem.contains ) ?
    function( a, b ) {
      var adown = a.nodeType === 9 ? a.documentElement : a,
        bup = b && b.parentNode;
      return a === bup || !!( bup && bup.nodeType === 1 && (
        adown.contains ?
          adown.contains( bup ) :
          a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
      ));
    } :
    function( a, b ) {
      if ( b ) {
        while ( (b = b.parentNode) ) {
          if ( b === a ) {
            return true;
          }
        }
      }
      return false;
    };

  /* Sorting
  ---------------------------------------------------------------------- */

  // Document order sorting
  sortOrder = hasCompare ?
  function( a, b ) {

    // Flag for duplicate removal
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    // Sort on method existence if only one input has compareDocumentPosition
    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    if ( compare ) {
      return compare;
    }

    // Calculate position if both inputs belong to the same document
    compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
      a.compareDocumentPosition( b ) :

      // Otherwise we know they are disconnected
      1;

    // Disconnected nodes
    if ( compare & 1 ||
      (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

      // Choose the first element that is related to our preferred document
      if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
        return -1;
      }
      if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
        return 1;
      }

      // Maintain original order
      return sortInput ?
        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
        0;
    }

    return compare & 4 ? -1 : 1;
  } :
  function( a, b ) {
    // Exit early if the nodes are identical
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    var cur,
      i = 0,
      aup = a.parentNode,
      bup = b.parentNode,
      ap = [ a ],
      bp = [ b ];

    // Parentless nodes are either documents or disconnected
    if ( !aup || !bup ) {
      return a === doc ? -1 :
        b === doc ? 1 :
        aup ? -1 :
        bup ? 1 :
        sortInput ?
        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
        0;

    // If the nodes are siblings, we can do a quick check
    } else if ( aup === bup ) {
      return siblingCheck( a, b );
    }

    // Otherwise we need full lists of their ancestors for comparison
    cur = a;
    while ( (cur = cur.parentNode) ) {
      ap.unshift( cur );
    }
    cur = b;
    while ( (cur = cur.parentNode) ) {
      bp.unshift( cur );
    }

    // Walk down the tree looking for a discrepancy
    while ( ap[i] === bp[i] ) {
      i++;
    }

    return i ?
      // Do a sibling check if the nodes have a common ancestor
      siblingCheck( ap[i], bp[i] ) :

      // Otherwise nodes in our document sort first
      ap[i] === preferredDoc ? -1 :
      bp[i] === preferredDoc ? 1 :
      0;
  };

  return doc;
};

Sizzle.matches = function( expr, elements ) {
  return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
  // Set document vars if needed
  if ( ( elem.ownerDocument || elem ) !== document ) {
    setDocument( elem );
  }

  // Make sure that attribute selectors are quoted
  expr = expr.replace( rattributeQuotes, "='$1']" );

  if ( support.matchesSelector && documentIsHTML &&
    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

    try {
      var ret = matches.call( elem, expr );

      // IE 9's matchesSelector returns false on disconnected nodes
      if ( ret || support.disconnectedMatch ||
          // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11 ) {
        return ret;
      }
    } catch (e) {}
  }

  return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
  // Set document vars if needed
  if ( ( context.ownerDocument || context ) !== document ) {
    setDocument( context );
  }
  return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
  // Set document vars if needed
  if ( ( elem.ownerDocument || elem ) !== document ) {
    setDocument( elem );
  }

  var fn = Expr.attrHandle[ name.toLowerCase() ],
    // Don't get fooled by Object.prototype properties (jQuery #13807)
    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
      fn( elem, name, !documentIsHTML ) :
      undefined;

  return val !== undefined ?
    val :
    support.attributes || !documentIsHTML ?
      elem.getAttribute( name ) :
      (val = elem.getAttributeNode(name)) && val.specified ?
        val.value :
        null;
};

Sizzle.error = function( msg ) {
  throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
  var elem,
    duplicates = [],
    j = 0,
    i = 0;

  // Unless we *know* we can detect duplicates, assume their presence
  hasDuplicate = !support.detectDuplicates;
  sortInput = !support.sortStable && results.slice( 0 );
  results.sort( sortOrder );

  if ( hasDuplicate ) {
    while ( (elem = results[i++]) ) {
      if ( elem === results[ i ] ) {
        j = duplicates.push( i );
      }
    }
    while ( j-- ) {
      results.splice( duplicates[ j ], 1 );
    }
  }

  // Clear input after sorting to release objects
  // See https://github.com/jquery/sizzle/pull/225
  sortInput = null;

  return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
  var node,
    ret = "",
    i = 0,
    nodeType = elem.nodeType;

  if ( !nodeType ) {
    // If no nodeType, this is expected to be an array
    while ( (node = elem[i++]) ) {
      // Do not traverse comment nodes
      ret += getText( node );
    }
  } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
    // Use textContent for elements
    // innerText usage removed for consistency of new lines (jQuery #11153)
    if ( typeof elem.textContent === "string" ) {
      return elem.textContent;
    } else {
      // Traverse its children
      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
        ret += getText( elem );
      }
    }
  } else if ( nodeType === 3 || nodeType === 4 ) {
    return elem.nodeValue;
  }
  // Do not include comment or processing instruction nodes

  return ret;
};

Expr = Sizzle.selectors = {

  // Can be adjusted by the user
  cacheLength: 50,

  createPseudo: markFunction,

  match: matchExpr,

  attrHandle: {},

  find: {},

  relative: {
    ">": { dir: "parentNode", first: true },
    " ": { dir: "parentNode" },
    "+": { dir: "previousSibling", first: true },
    "~": { dir: "previousSibling" }
  },

  preFilter: {
    "ATTR": function( match ) {
      match[1] = match[1].replace( runescape, funescape );

      // Move the given value to match[3] whether quoted or unquoted
      match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

      if ( match[2] === "~=" ) {
        match[3] = " " + match[3] + " ";
      }

      return match.slice( 0, 4 );
    },

    "CHILD": function( match ) {
      /* matches from matchExpr["CHILD"]
        1 type (only|nth|...)
        2 what (child|of-type)
        3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
        4 xn-component of xn+y argument ([+-]?\d*n|)
        5 sign of xn-component
        6 x of xn-component
        7 sign of y-component
        8 y of y-component
      */
      match[1] = match[1].toLowerCase();

      if ( match[1].slice( 0, 3 ) === "nth" ) {
        // nth-* requires argument
        if ( !match[3] ) {
          Sizzle.error( match[0] );
        }

        // numeric x and y parameters for Expr.filter.CHILD
        // remember that false/true cast respectively to 0/1
        match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
        match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

      // other types prohibit arguments
      } else if ( match[3] ) {
        Sizzle.error( match[0] );
      }

      return match;
    },

    "PSEUDO": function( match ) {
      var excess,
        unquoted = !match[6] && match[2];

      if ( matchExpr["CHILD"].test( match[0] ) ) {
        return null;
      }

      // Accept quoted arguments as-is
      if ( match[3] ) {
        match[2] = match[4] || match[5] || "";

      // Strip excess characters from unquoted arguments
      } else if ( unquoted && rpseudo.test( unquoted ) &&
        // Get excess from tokenize (recursively)
        (excess = tokenize( unquoted, true )) &&
        // advance to the next closing parenthesis
        (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

        // excess is a negative index
        match[0] = match[0].slice( 0, excess );
        match[2] = unquoted.slice( 0, excess );
      }

      // Return only captures needed by the pseudo filter method (type and argument)
      return match.slice( 0, 3 );
    }
  },

  filter: {

    "TAG": function( nodeNameSelector ) {
      var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
      return nodeNameSelector === "*" ?
        function() { return true; } :
        function( elem ) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
    },

    "CLASS": function( className ) {
      var pattern = classCache[ className + " " ];

      return pattern ||
        (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
        classCache( className, function( elem ) {
          return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
        });
    },

    "ATTR": function( name, operator, check ) {
      return function( elem ) {
        var result = Sizzle.attr( elem, name );

        if ( result == null ) {
          return operator === "!=";
        }
        if ( !operator ) {
          return true;
        }

        result += "";

        return operator === "=" ? result === check :
          operator === "!=" ? result !== check :
          operator === "^=" ? check && result.indexOf( check ) === 0 :
          operator === "*=" ? check && result.indexOf( check ) > -1 :
          operator === "$=" ? check && result.slice( -check.length ) === check :
          operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
          operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
          false;
      };
    },

    "CHILD": function( type, what, argument, first, last ) {
      var simple = type.slice( 0, 3 ) !== "nth",
        forward = type.slice( -4 ) !== "last",
        ofType = what === "of-type";

      return first === 1 && last === 0 ?

        // Shortcut for :nth-*(n)
        function( elem ) {
          return !!elem.parentNode;
        } :

        function( elem, context, xml ) {
          var cache, outerCache, node, diff, nodeIndex, start,
            dir = simple !== forward ? "nextSibling" : "previousSibling",
            parent = elem.parentNode,
            name = ofType && elem.nodeName.toLowerCase(),
            useCache = !xml && !ofType;

          if ( parent ) {

            // :(first|last|only)-(child|of-type)
            if ( simple ) {
              while ( dir ) {
                node = elem;
                while ( (node = node[ dir ]) ) {
                  if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                    return false;
                  }
                }
                // Reverse direction for :only-* (if we haven't yet done so)
                start = dir = type === "only" && !start && "nextSibling";
              }
              return true;
            }

            start = [ forward ? parent.firstChild : parent.lastChild ];

            // non-xml :nth-child(...) stores cache data on `parent`
            if ( forward && useCache ) {
              // Seek `elem` from a previously-cached index
              outerCache = parent[ expando ] || (parent[ expando ] = {});
              cache = outerCache[ type ] || [];
              nodeIndex = cache[0] === dirruns && cache[1];
              diff = cache[0] === dirruns && cache[2];
              node = nodeIndex && parent.childNodes[ nodeIndex ];

              while ( (node = ++nodeIndex && node && node[ dir ] ||

                // Fallback to seeking `elem` from the start
                (diff = nodeIndex = 0) || start.pop()) ) {

                // When found, cache indexes on `parent` and break
                if ( node.nodeType === 1 && ++diff && node === elem ) {
                  outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                  break;
                }
              }

            // Use previously-cached element index if available
            } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
              diff = cache[1];

            // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
            } else {
              // Use the same loop as above to seek `elem` from the start
              while ( (node = ++nodeIndex && node && node[ dir ] ||
                (diff = nodeIndex = 0) || start.pop()) ) {

                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                  // Cache the index of each encountered element
                  if ( useCache ) {
                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                  }

                  if ( node === elem ) {
                    break;
                  }
                }
              }
            }

            // Incorporate the offset, then check against cycle size
            diff -= last;
            return diff === first || ( diff % first === 0 && diff / first >= 0 );
          }
        };
    },

    "PSEUDO": function( pseudo, argument ) {
      // pseudo-class names are case-insensitive
      // http://www.w3.org/TR/selectors/#pseudo-classes
      // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
      // Remember that setFilters inherits from pseudos
      var args,
        fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
          Sizzle.error( "unsupported pseudo: " + pseudo );

      // The user may use createPseudo to indicate that
      // arguments are needed to create the filter function
      // just as Sizzle does
      if ( fn[ expando ] ) {
        return fn( argument );
      }

      // But maintain support for old signatures
      if ( fn.length > 1 ) {
        args = [ pseudo, pseudo, "", argument ];
        return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
          markFunction(function( seed, matches ) {
            var idx,
              matched = fn( seed, argument ),
              i = matched.length;
            while ( i-- ) {
              idx = indexOf( seed, matched[i] );
              seed[ idx ] = !( matches[ idx ] = matched[i] );
            }
          }) :
          function( elem ) {
            return fn( elem, 0, args );
          };
      }

      return fn;
    }
  },

  pseudos: {
    // Potentially complex pseudos
    "not": markFunction(function( selector ) {
      // Trim the selector passed to compile
      // to avoid treating leading and trailing
      // spaces as combinators
      var input = [],
        results = [],
        matcher = compile( selector.replace( rtrim, "$1" ) );

      return matcher[ expando ] ?
        markFunction(function( seed, matches, context, xml ) {
          var elem,
            unmatched = matcher( seed, null, xml, [] ),
            i = seed.length;

          // Match elements unmatched by `matcher`
          while ( i-- ) {
            if ( (elem = unmatched[i]) ) {
              seed[i] = !(matches[i] = elem);
            }
          }
        }) :
        function( elem, context, xml ) {
          input[0] = elem;
          matcher( input, null, xml, results );
          // Don't keep the element (issue #299)
          input[0] = null;
          return !results.pop();
        };
    }),

    "has": markFunction(function( selector ) {
      return function( elem ) {
        return Sizzle( selector, elem ).length > 0;
      };
    }),

    "contains": markFunction(function( text ) {
      text = text.replace( runescape, funescape );
      return function( elem ) {
        return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
      };
    }),

    // "Whether an element is represented by a :lang() selector
    // is based solely on the element's language value
    // being equal to the identifier C,
    // or beginning with the identifier C immediately followed by "-".
    // The matching of C against the element's language value is performed case-insensitively.
    // The identifier C does not have to be a valid language name."
    // http://www.w3.org/TR/selectors/#lang-pseudo
    "lang": markFunction( function( lang ) {
      // lang value must be a valid identifier
      if ( !ridentifier.test(lang || "") ) {
        Sizzle.error( "unsupported lang: " + lang );
      }
      lang = lang.replace( runescape, funescape ).toLowerCase();
      return function( elem ) {
        var elemLang;
        do {
          if ( (elemLang = documentIsHTML ?
            elem.lang :
            elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

            elemLang = elemLang.toLowerCase();
            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
          }
        } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
        return false;
      };
    }),

    // Miscellaneous
    "target": function( elem ) {
      var hash = window.location && window.location.hash;
      return hash && hash.slice( 1 ) === elem.id;
    },

    "root": function( elem ) {
      return elem === docElem;
    },

    "focus": function( elem ) {
      return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
    },

    // Boolean properties
    "enabled": function( elem ) {
      return elem.disabled === false;
    },

    "disabled": function( elem ) {
      return elem.disabled === true;
    },

    "checked": function( elem ) {
      // In CSS3, :checked should return both checked and selected elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      var nodeName = elem.nodeName.toLowerCase();
      return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
    },

    "selected": function( elem ) {
      // Accessing this property makes selected-by-default
      // options in Safari work properly
      if ( elem.parentNode ) {
        elem.parentNode.selectedIndex;
      }

      return elem.selected === true;
    },

    // Contents
    "empty": function( elem ) {
      // http://www.w3.org/TR/selectors/#empty-pseudo
      // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
      //   but not by others (comment: 8; processing instruction: 7; etc.)
      // nodeType < 6 works because attributes (2) do not appear as children
      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
        if ( elem.nodeType < 6 ) {
          return false;
        }
      }
      return true;
    },

    "parent": function( elem ) {
      return !Expr.pseudos["empty"]( elem );
    },

    // Element/input types
    "header": function( elem ) {
      return rheader.test( elem.nodeName );
    },

    "input": function( elem ) {
      return rinputs.test( elem.nodeName );
    },

    "button": function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === "button" || name === "button";
    },

    "text": function( elem ) {
      var attr;
      return elem.nodeName.toLowerCase() === "input" &&
        elem.type === "text" &&

        // Support: IE<8
        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
        ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
    },

    // Position-in-collection
    "first": createPositionalPseudo(function() {
      return [ 0 ];
    }),

    "last": createPositionalPseudo(function( matchIndexes, length ) {
      return [ length - 1 ];
    }),

    "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
      return [ argument < 0 ? argument + length : argument ];
    }),

    "even": createPositionalPseudo(function( matchIndexes, length ) {
      var i = 0;
      for ( ; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "odd": createPositionalPseudo(function( matchIndexes, length ) {
      var i = 1;
      for ( ; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
      var i = argument < 0 ? argument + length : argument;
      for ( ; --i >= 0; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
      var i = argument < 0 ? argument + length : argument;
      for ( ; ++i < length; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    })
  }
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
  Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
  var matched, match, tokens, type,
    soFar, groups, preFilters,
    cached = tokenCache[ selector + " " ];

  if ( cached ) {
    return parseOnly ? 0 : cached.slice( 0 );
  }

  soFar = selector;
  groups = [];
  preFilters = Expr.preFilter;

  while ( soFar ) {

    // Comma and first run
    if ( !matched || (match = rcomma.exec( soFar )) ) {
      if ( match ) {
        // Don't consume trailing commas as valid
        soFar = soFar.slice( match[0].length ) || soFar;
      }
      groups.push( (tokens = []) );
    }

    matched = false;

    // Combinators
    if ( (match = rcombinators.exec( soFar )) ) {
      matched = match.shift();
      tokens.push({
        value: matched,
        // Cast descendant combinators to space
        type: match[0].replace( rtrim, " " )
      });
      soFar = soFar.slice( matched.length );
    }

    // Filters
    for ( type in Expr.filter ) {
      if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
        (match = preFilters[ type ]( match ))) ) {
        matched = match.shift();
        tokens.push({
          value: matched,
          type: type,
          matches: match
        });
        soFar = soFar.slice( matched.length );
      }
    }

    if ( !matched ) {
      break;
    }
  }

  // Return the length of the invalid excess
  // if we're just parsing
  // Otherwise, throw an error or return tokens
  return parseOnly ?
    soFar.length :
    soFar ?
      Sizzle.error( selector ) :
      // Cache the tokens
      tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
  var i = 0,
    len = tokens.length,
    selector = "";
  for ( ; i < len; i++ ) {
    selector += tokens[i].value;
  }
  return selector;
}

function addCombinator( matcher, combinator, base ) {
  var dir = combinator.dir,
    checkNonElements = base && dir === "parentNode",
    doneName = done++;

  return combinator.first ?
    // Check against closest ancestor/preceding element
    function( elem, context, xml ) {
      while ( (elem = elem[ dir ]) ) {
        if ( elem.nodeType === 1 || checkNonElements ) {
          return matcher( elem, context, xml );
        }
      }
    } :

    // Check against all ancestor/preceding elements
    function( elem, context, xml ) {
      var oldCache, outerCache,
        newCache = [ dirruns, doneName ];

      // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
      if ( xml ) {
        while ( (elem = elem[ dir ]) ) {
          if ( elem.nodeType === 1 || checkNonElements ) {
            if ( matcher( elem, context, xml ) ) {
              return true;
            }
          }
        }
      } else {
        while ( (elem = elem[ dir ]) ) {
          if ( elem.nodeType === 1 || checkNonElements ) {
            outerCache = elem[ expando ] || (elem[ expando ] = {});
            if ( (oldCache = outerCache[ dir ]) &&
              oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

              // Assign to newCache so results back-propagate to previous elements
              return (newCache[ 2 ] = oldCache[ 2 ]);
            } else {
              // Reuse newcache so results back-propagate to previous elements
              outerCache[ dir ] = newCache;

              // A match means we're done; a fail means we have to keep checking
              if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                return true;
              }
            }
          }
        }
      }
    };
}

function elementMatcher( matchers ) {
  return matchers.length > 1 ?
    function( elem, context, xml ) {
      var i = matchers.length;
      while ( i-- ) {
        if ( !matchers[i]( elem, context, xml ) ) {
          return false;
        }
      }
      return true;
    } :
    matchers[0];
}

function multipleContexts( selector, contexts, results ) {
  var i = 0,
    len = contexts.length;
  for ( ; i < len; i++ ) {
    Sizzle( selector, contexts[i], results );
  }
  return results;
}

function condense( unmatched, map, filter, context, xml ) {
  var elem,
    newUnmatched = [],
    i = 0,
    len = unmatched.length,
    mapped = map != null;

  for ( ; i < len; i++ ) {
    if ( (elem = unmatched[i]) ) {
      if ( !filter || filter( elem, context, xml ) ) {
        newUnmatched.push( elem );
        if ( mapped ) {
          map.push( i );
        }
      }
    }
  }

  return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  if ( postFilter && !postFilter[ expando ] ) {
    postFilter = setMatcher( postFilter );
  }
  if ( postFinder && !postFinder[ expando ] ) {
    postFinder = setMatcher( postFinder, postSelector );
  }
  return markFunction(function( seed, results, context, xml ) {
    var temp, i, elem,
      preMap = [],
      postMap = [],
      preexisting = results.length,

      // Get initial elements from seed or context
      elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

      // Prefilter to get matcher input, preserving a map for seed-results synchronization
      matcherIn = preFilter && ( seed || !selector ) ?
        condense( elems, preMap, preFilter, context, xml ) :
        elems,

      matcherOut = matcher ?
        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

          // ...intermediate processing is necessary
          [] :

          // ...otherwise use results directly
          results :
        matcherIn;

    // Find primary matches
    if ( matcher ) {
      matcher( matcherIn, matcherOut, context, xml );
    }

    // Apply postFilter
    if ( postFilter ) {
      temp = condense( matcherOut, postMap );
      postFilter( temp, [], context, xml );

      // Un-match failing elements by moving them back to matcherIn
      i = temp.length;
      while ( i-- ) {
        if ( (elem = temp[i]) ) {
          matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
        }
      }
    }

    if ( seed ) {
      if ( postFinder || preFilter ) {
        if ( postFinder ) {
          // Get the final matcherOut by condensing this intermediate into postFinder contexts
          temp = [];
          i = matcherOut.length;
          while ( i-- ) {
            if ( (elem = matcherOut[i]) ) {
              // Restore matcherIn since elem is not yet a final match
              temp.push( (matcherIn[i] = elem) );
            }
          }
          postFinder( null, (matcherOut = []), temp, xml );
        }

        // Move matched elements from seed to results to keep them synchronized
        i = matcherOut.length;
        while ( i-- ) {
          if ( (elem = matcherOut[i]) &&
            (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

            seed[temp] = !(results[temp] = elem);
          }
        }
      }

    // Add elements to results, through postFinder if defined
    } else {
      matcherOut = condense(
        matcherOut === results ?
          matcherOut.splice( preexisting, matcherOut.length ) :
          matcherOut
      );
      if ( postFinder ) {
        postFinder( null, results, matcherOut, xml );
      } else {
        push.apply( results, matcherOut );
      }
    }
  });
}

function matcherFromTokens( tokens ) {
  var checkContext, matcher, j,
    len = tokens.length,
    leadingRelative = Expr.relative[ tokens[0].type ],
    implicitRelative = leadingRelative || Expr.relative[" "],
    i = leadingRelative ? 1 : 0,

    // The foundational matcher ensures that elements are reachable from top-level context(s)
    matchContext = addCombinator( function( elem ) {
      return elem === checkContext;
    }, implicitRelative, true ),
    matchAnyContext = addCombinator( function( elem ) {
      return indexOf( checkContext, elem ) > -1;
    }, implicitRelative, true ),
    matchers = [ function( elem, context, xml ) {
      var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
        (checkContext = context).nodeType ?
          matchContext( elem, context, xml ) :
          matchAnyContext( elem, context, xml ) );
      // Avoid hanging onto element (issue #299)
      checkContext = null;
      return ret;
    } ];

  for ( ; i < len; i++ ) {
    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
      matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
    } else {
      matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

      // Return special upon seeing a positional matcher
      if ( matcher[ expando ] ) {
        // Find the next relative operator (if any) for proper handling
        j = ++i;
        for ( ; j < len; j++ ) {
          if ( Expr.relative[ tokens[j].type ] ) {
            break;
          }
        }
        return setMatcher(
          i > 1 && elementMatcher( matchers ),
          i > 1 && toSelector(
            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
          ).replace( rtrim, "$1" ),
          matcher,
          i < j && matcherFromTokens( tokens.slice( i, j ) ),
          j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
          j < len && toSelector( tokens )
        );
      }
      matchers.push( matcher );
    }
  }

  return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  var bySet = setMatchers.length > 0,
    byElement = elementMatchers.length > 0,
    superMatcher = function( seed, context, xml, results, outermost ) {
      var elem, j, matcher,
        matchedCount = 0,
        i = "0",
        unmatched = seed && [],
        setMatched = [],
        contextBackup = outermostContext,
        // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
        // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
        len = elems.length;

      if ( outermost ) {
        outermostContext = context !== document && context;
      }

      // Add elements passing elementMatchers directly to results
      // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
      // Support: IE<9, Safari
      // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
      for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
        if ( byElement && elem ) {
          j = 0;
          while ( (matcher = elementMatchers[j++]) ) {
            if ( matcher( elem, context, xml ) ) {
              results.push( elem );
              break;
            }
          }
          if ( outermost ) {
            dirruns = dirrunsUnique;
          }
        }

        // Track unmatched elements for set filters
        if ( bySet ) {
          // They will have gone through all possible matchers
          if ( (elem = !matcher && elem) ) {
            matchedCount--;
          }

          // Lengthen the array for every element, matched or not
          if ( seed ) {
            unmatched.push( elem );
          }
        }
      }

      // Apply set filters to unmatched elements
      matchedCount += i;
      if ( bySet && i !== matchedCount ) {
        j = 0;
        while ( (matcher = setMatchers[j++]) ) {
          matcher( unmatched, setMatched, context, xml );
        }

        if ( seed ) {
          // Reintegrate element matches to eliminate the need for sorting
          if ( matchedCount > 0 ) {
            while ( i-- ) {
              if ( !(unmatched[i] || setMatched[i]) ) {
                setMatched[i] = pop.call( results );
              }
            }
          }

          // Discard index placeholder values to get only actual matches
          setMatched = condense( setMatched );
        }

        // Add matches to results
        push.apply( results, setMatched );

        // Seedless set matches succeeding multiple successful matchers stipulate sorting
        if ( outermost && !seed && setMatched.length > 0 &&
          ( matchedCount + setMatchers.length ) > 1 ) {

          Sizzle.uniqueSort( results );
        }
      }

      // Override manipulation of globals by nested matchers
      if ( outermost ) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }

      return unmatched;
    };

  return bySet ?
    markFunction( superMatcher ) :
    superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
  var i,
    setMatchers = [],
    elementMatchers = [],
    cached = compilerCache[ selector + " " ];

  if ( !cached ) {
    // Generate a function of recursive functions that can be used to check each element
    if ( !match ) {
      match = tokenize( selector );
    }
    i = match.length;
    while ( i-- ) {
      cached = matcherFromTokens( match[i] );
      if ( cached[ expando ] ) {
        setMatchers.push( cached );
      } else {
        elementMatchers.push( cached );
      }
    }

    // Cache the compiled function
    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

    // Save selector and tokenization
    cached.selector = selector;
  }
  return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
  var i, tokens, token, type, find,
    compiled = typeof selector === "function" && selector,
    match = !seed && tokenize( (selector = compiled.selector || selector) );

  results = results || [];

  // Try to minimize operations if there is no seed and only one group
  if ( match.length === 1 ) {

    // Take a shortcut and set the context if the root selector is an ID
    tokens = match[0] = match[0].slice( 0 );
    if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
        support.getById && context.nodeType === 9 && documentIsHTML &&
        Expr.relative[ tokens[1].type ] ) {

      context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
      if ( !context ) {
        return results;

      // Precompiled matchers will still verify ancestry, so step up a level
      } else if ( compiled ) {
        context = context.parentNode;
      }

      selector = selector.slice( tokens.shift().value.length );
    }

    // Fetch a seed set for right-to-left matching
    i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
    while ( i-- ) {
      token = tokens[i];

      // Abort if we hit a combinator
      if ( Expr.relative[ (type = token.type) ] ) {
        break;
      }
      if ( (find = Expr.find[ type ]) ) {
        // Search, expanding context for leading sibling combinators
        if ( (seed = find(
          token.matches[0].replace( runescape, funescape ),
          rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
        )) ) {

          // If seed is empty or no tokens remain, we can return early
          tokens.splice( i, 1 );
          selector = seed.length && toSelector( tokens );
          if ( !selector ) {
            push.apply( results, seed );
            return results;
          }

          break;
        }
      }
    }
  }

  // Compile and execute a filtering function if one is not provided
  // Provide `match` to avoid retokenization if we modified the selector above
  ( compiled || compile( selector, match ) )(
    seed,
    context,
    !documentIsHTML,
    results,
    rsibling.test( selector ) && testContext( context.parentNode ) || context
  );
  return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
  // Should return 1, but returns 4 (following)
  return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
  div.innerHTML = "<a href='#'></a>";
  return div.firstChild.getAttribute("href") === "#" ;
}) ) {
  addHandle( "type|href|height|width", function( elem, name, isXML ) {
    if ( !isXML ) {
      return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
    }
  });
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
  div.innerHTML = "<input/>";
  div.firstChild.setAttribute( "value", "" );
  return div.firstChild.getAttribute( "value" ) === "";
}) ) {
  addHandle( "value", function( elem, name, isXML ) {
    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
      return elem.defaultValue;
    }
  });
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
  return div.getAttribute("disabled") == null;
}) ) {
  addHandle( booleans, function( elem, name, isXML ) {
    var val;
    if ( !isXML ) {
      return elem[ name ] === true ? name.toLowerCase() :
          (val = elem.getAttributeNode( name )) && val.specified ?
          val.value :
        null;
    }
  });
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
  if ( jQuery.isFunction( qualifier ) ) {
    return jQuery.grep( elements, function( elem, i ) {
      /* jshint -W018 */
      return !!qualifier.call( elem, i, elem ) !== not;
    });

  }

  if ( qualifier.nodeType ) {
    return jQuery.grep( elements, function( elem ) {
      return ( elem === qualifier ) !== not;
    });

  }

  if ( typeof qualifier === "string" ) {
    if ( risSimple.test( qualifier ) ) {
      return jQuery.filter( qualifier, elements, not );
    }

    qualifier = jQuery.filter( qualifier, elements );
  }

  return jQuery.grep( elements, function( elem ) {
    return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
  });
}

jQuery.filter = function( expr, elems, not ) {
  var elem = elems[ 0 ];

  if ( not ) {
    expr = ":not(" + expr + ")";
  }

  return elems.length === 1 && elem.nodeType === 1 ?
    jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
    jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
      return elem.nodeType === 1;
    }));
};

jQuery.fn.extend({
  find: function( selector ) {
    var i,
      len = this.length,
      ret = [],
      self = this;

    if ( typeof selector !== "string" ) {
      return this.pushStack( jQuery( selector ).filter(function() {
        for ( i = 0; i < len; i++ ) {
          if ( jQuery.contains( self[ i ], this ) ) {
            return true;
          }
        }
      }) );
    }

    for ( i = 0; i < len; i++ ) {
      jQuery.find( selector, self[ i ], ret );
    }

    // Needed because $( selector, context ) becomes $( context ).find( selector )
    ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
    ret.selector = this.selector ? this.selector + " " + selector : selector;
    return ret;
  },
  filter: function( selector ) {
    return this.pushStack( winnow(this, selector || [], false) );
  },
  not: function( selector ) {
    return this.pushStack( winnow(this, selector || [], true) );
  },
  is: function( selector ) {
    return !!winnow(
      this,

      // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test( selector ) ?
        jQuery( selector ) :
        selector || [],
      false
    ).length;
  }
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

  // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

  init = jQuery.fn.init = function( selector, context ) {
    var match, elem;

    // HANDLE: $(""), $(null), $(undefined), $(false)
    if ( !selector ) {
      return this;
    }

    // Handle HTML strings
    if ( typeof selector === "string" ) {
      if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [ null, selector, null ];

      } else {
        match = rquickExpr.exec( selector );
      }

      // Match html or make sure no context is specified for #id
      if ( match && (match[1] || !context) ) {

        // HANDLE: $(html) -> $(array)
        if ( match[1] ) {
          context = context instanceof jQuery ? context[0] : context;

          // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present
          jQuery.merge( this, jQuery.parseHTML(
            match[1],
            context && context.nodeType ? context.ownerDocument || context : document,
            true
          ) );

          // HANDLE: $(html, props)
          if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
            for ( match in context ) {
              // Properties of context are called as methods if possible
              if ( jQuery.isFunction( this[ match ] ) ) {
                this[ match ]( context[ match ] );

              // ...and otherwise set as attributes
              } else {
                this.attr( match, context[ match ] );
              }
            }
          }

          return this;

        // HANDLE: $(#id)
        } else {
          elem = document.getElementById( match[2] );

          // Support: Blackberry 4.6
          // gEBID returns nodes no longer in the document (#6963)
          if ( elem && elem.parentNode ) {
            // Inject the element directly into the jQuery object
            this.length = 1;
            this[0] = elem;
          }

          this.context = document;
          this.selector = selector;
          return this;
        }

      // HANDLE: $(expr, $(...))
      } else if ( !context || context.jquery ) {
        return ( context || rootjQuery ).find( selector );

      // HANDLE: $(expr, context)
      // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor( context ).find( selector );
      }

    // HANDLE: $(DOMElement)
    } else if ( selector.nodeType ) {
      this.context = this[0] = selector;
      this.length = 1;
      return this;

    // HANDLE: $(function)
    // Shortcut for document ready
    } else if ( jQuery.isFunction( selector ) ) {
      return typeof rootjQuery.ready !== "undefined" ?
        rootjQuery.ready( selector ) :
        // Execute immediately if ready is not present
        selector( jQuery );
    }

    if ( selector.selector !== undefined ) {
      this.selector = selector.selector;
      this.context = selector.context;
    }

    return jQuery.makeArray( selector, this );
  };

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
  // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };

jQuery.extend({
  dir: function( elem, dir, until ) {
    var matched = [],
      truncate = until !== undefined;

    while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
      if ( elem.nodeType === 1 ) {
        if ( truncate && jQuery( elem ).is( until ) ) {
          break;
        }
        matched.push( elem );
      }
    }
    return matched;
  },

  sibling: function( n, elem ) {
    var matched = [];

    for ( ; n; n = n.nextSibling ) {
      if ( n.nodeType === 1 && n !== elem ) {
        matched.push( n );
      }
    }

    return matched;
  }
});

jQuery.fn.extend({
  has: function( target ) {
    var targets = jQuery( target, this ),
      l = targets.length;

    return this.filter(function() {
      var i = 0;
      for ( ; i < l; i++ ) {
        if ( jQuery.contains( this, targets[i] ) ) {
          return true;
        }
      }
    });
  },

  closest: function( selectors, context ) {
    var cur,
      i = 0,
      l = this.length,
      matched = [],
      pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
        jQuery( selectors, context || this.context ) :
        0;

    for ( ; i < l; i++ ) {
      for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
        // Always skip document fragments
        if ( cur.nodeType < 11 && (pos ?
          pos.index(cur) > -1 :

          // Don't pass non-elements to Sizzle
          cur.nodeType === 1 &&
            jQuery.find.matchesSelector(cur, selectors)) ) {

          matched.push( cur );
          break;
        }
      }
    }

    return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
  },

  // Determine the position of an element within the set
  index: function( elem ) {

    // No argument, return index in parent
    if ( !elem ) {
      return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
    }

    // Index in selector
    if ( typeof elem === "string" ) {
      return indexOf.call( jQuery( elem ), this[ 0 ] );
    }

    // Locate the position of the desired element
    return indexOf.call( this,

      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[ 0 ] : elem
    );
  },

  add: function( selector, context ) {
    return this.pushStack(
      jQuery.unique(
        jQuery.merge( this.get(), jQuery( selector, context ) )
      )
    );
  },

  addBack: function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter(selector)
    );
  }
});

function sibling( cur, dir ) {
  while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
  return cur;
}

jQuery.each({
  parent: function( elem ) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function( elem ) {
    return jQuery.dir( elem, "parentNode" );
  },
  parentsUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "parentNode", until );
  },
  next: function( elem ) {
    return sibling( elem, "nextSibling" );
  },
  prev: function( elem ) {
    return sibling( elem, "previousSibling" );
  },
  nextAll: function( elem ) {
    return jQuery.dir( elem, "nextSibling" );
  },
  prevAll: function( elem ) {
    return jQuery.dir( elem, "previousSibling" );
  },
  nextUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "nextSibling", until );
  },
  prevUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "previousSibling", until );
  },
  siblings: function( elem ) {
    return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
  },
  children: function( elem ) {
    return jQuery.sibling( elem.firstChild );
  },
  contents: function( elem ) {
    return elem.contentDocument || jQuery.merge( [], elem.childNodes );
  }
}, function( name, fn ) {
  jQuery.fn[ name ] = function( until, selector ) {
    var matched = jQuery.map( this, fn, until );

    if ( name.slice( -5 ) !== "Until" ) {
      selector = until;
    }

    if ( selector && typeof selector === "string" ) {
      matched = jQuery.filter( selector, matched );
    }

    if ( this.length > 1 ) {
      // Remove duplicates
      if ( !guaranteedUnique[ name ] ) {
        jQuery.unique( matched );
      }

      // Reverse order for parents* and prev-derivatives
      if ( rparentsprev.test( name ) ) {
        matched.reverse();
      }
    }

    return this.pushStack( matched );
  };
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
  var object = optionsCache[ options ] = {};
  jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
    object[ flag ] = true;
  });
  return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *      the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:     will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:     will keep track of previous values and will call any callback added
 *          after the list has been fired right away with the latest "memorized"
 *          values (like a Deferred)
 *
 *  unique:     will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:  interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

  // Convert options from String-formatted to Object-formatted if needed
  // (we check in cache first)
  options = typeof options === "string" ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );

  var // Last fire value (for non-forgettable lists)
    memory,
    // Flag to know if list was already fired
    fired,
    // Flag to know if list is currently firing
    firing,
    // First callback to fire (used internally by add and fireWith)
    firingStart,
    // End of the loop when firing
    firingLength,
    // Index of currently firing callback (modified by remove if needed)
    firingIndex,
    // Actual callback list
    list = [],
    // Stack of fire calls for repeatable lists
    stack = !options.once && [],
    // Fire callbacks
    fire = function( data ) {
      memory = options.memory && data;
      fired = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      firing = true;
      for ( ; list && firingIndex < firingLength; firingIndex++ ) {
        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
          memory = false; // To prevent further calls using add
          break;
        }
      }
      firing = false;
      if ( list ) {
        if ( stack ) {
          if ( stack.length ) {
            fire( stack.shift() );
          }
        } else if ( memory ) {
          list = [];
        } else {
          self.disable();
        }
      }
    },
    // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function() {
        if ( list ) {
          // First, we save the current length
          var start = list.length;
          (function add( args ) {
            jQuery.each( args, function( _, arg ) {
              var type = jQuery.type( arg );
              if ( type === "function" ) {
                if ( !options.unique || !self.has( arg ) ) {
                  list.push( arg );
                }
              } else if ( arg && arg.length && type !== "string" ) {
                // Inspect recursively
                add( arg );
              }
            });
          })( arguments );
          // Do we need to add the callbacks to the
          // current firing batch?
          if ( firing ) {
            firingLength = list.length;
          // With memory, if we're not firing then
          // we should call right away
          } else if ( memory ) {
            firingStart = start;
            fire( memory );
          }
        }
        return this;
      },
      // Remove a callback from the list
      remove: function() {
        if ( list ) {
          jQuery.each( arguments, function( _, arg ) {
            var index;
            while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
              list.splice( index, 1 );
              // Handle firing indexes
              if ( firing ) {
                if ( index <= firingLength ) {
                  firingLength--;
                }
                if ( index <= firingIndex ) {
                  firingIndex--;
                }
              }
            }
          });
        }
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function( fn ) {
        return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
      },
      // Remove all callbacks from the list
      empty: function() {
        list = [];
        firingLength = 0;
        return this;
      },
      // Have the list do nothing anymore
      disable: function() {
        list = stack = memory = undefined;
        return this;
      },
      // Is it disabled?
      disabled: function() {
        return !list;
      },
      // Lock the list in its current state
      lock: function() {
        stack = undefined;
        if ( !memory ) {
          self.disable();
        }
        return this;
      },
      // Is it locked?
      locked: function() {
        return !stack;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function( context, args ) {
        if ( list && ( !fired || stack ) ) {
          args = args || [];
          args = [ context, args.slice ? args.slice() : args ];
          if ( firing ) {
            stack.push( args );
          } else {
            fire( args );
          }
        }
        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function() {
        self.fireWith( this, arguments );
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function() {
        return !!fired;
      }
    };

  return self;
};


jQuery.extend({

  Deferred: function( func ) {
    var tuples = [
        // action, add listener, listener list, final state
        [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
        [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
        [ "notify", "progress", jQuery.Callbacks("memory") ]
      ],
      state = "pending",
      promise = {
        state: function() {
          return state;
        },
        always: function() {
          deferred.done( arguments ).fail( arguments );
          return this;
        },
        then: function( /* fnDone, fnFail, fnProgress */ ) {
          var fns = arguments;
          return jQuery.Deferred(function( newDefer ) {
            jQuery.each( tuples, function( i, tuple ) {
              var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
              // deferred[ done | fail | progress ] for forwarding actions to newDefer
              deferred[ tuple[1] ](function() {
                var returned = fn && fn.apply( this, arguments );
                if ( returned && jQuery.isFunction( returned.promise ) ) {
                  returned.promise()
                    .done( newDefer.resolve )
                    .fail( newDefer.reject )
                    .progress( newDefer.notify );
                } else {
                  newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                }
              });
            });
            fns = null;
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function( obj ) {
          return obj != null ? jQuery.extend( obj, promise ) : promise;
        }
      },
      deferred = {};

    // Keep pipe for back-compat
    promise.pipe = promise.then;

    // Add list-specific methods
    jQuery.each( tuples, function( i, tuple ) {
      var list = tuple[ 2 ],
        stateString = tuple[ 3 ];

      // promise[ done | fail | progress ] = list.add
      promise[ tuple[1] ] = list.add;

      // Handle state
      if ( stateString ) {
        list.add(function() {
          // state = [ resolved | rejected ]
          state = stateString;

        // [ reject_list | resolve_list ].disable; progress_list.lock
        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
      }

      // deferred[ resolve | reject | notify ]
      deferred[ tuple[0] ] = function() {
        deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
        return this;
      };
      deferred[ tuple[0] + "With" ] = list.fireWith;
    });

    // Make the deferred a promise
    promise.promise( deferred );

    // Call given func if any
    if ( func ) {
      func.call( deferred, deferred );
    }

    // All done!
    return deferred;
  },

  // Deferred helper
  when: function( subordinate /* , ..., subordinateN */ ) {
    var i = 0,
      resolveValues = slice.call( arguments ),
      length = resolveValues.length,

      // the count of uncompleted subordinates
      remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

      // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

      // Update function for both resolve and progress values
      updateFunc = function( i, contexts, values ) {
        return function( value ) {
          contexts[ i ] = this;
          values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
          if ( values === progressValues ) {
            deferred.notifyWith( contexts, values );
          } else if ( !( --remaining ) ) {
            deferred.resolveWith( contexts, values );
          }
        };
      },

      progressValues, progressContexts, resolveContexts;

    // Add listeners to Deferred subordinates; treat others as resolved
    if ( length > 1 ) {
      progressValues = new Array( length );
      progressContexts = new Array( length );
      resolveContexts = new Array( length );
      for ( ; i < length; i++ ) {
        if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
          resolveValues[ i ].promise()
            .done( updateFunc( i, resolveContexts, resolveValues ) )
            .fail( deferred.reject )
            .progress( updateFunc( i, progressContexts, progressValues ) );
        } else {
          --remaining;
        }
      }
    }

    // If we're not waiting on anything, resolve the master
    if ( !remaining ) {
      deferred.resolveWith( resolveContexts, resolveValues );
    }

    return deferred.promise();
  }
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
  // Add the callback
  jQuery.ready.promise().done( fn );

  return this;
};

jQuery.extend({
  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,

  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,

  // Hold (or release) the ready event
  holdReady: function( hold ) {
    if ( hold ) {
      jQuery.readyWait++;
    } else {
      jQuery.ready( true );
    }
  },

  // Handle when the DOM is ready
  ready: function( wait ) {

    // Abort if there are pending holds or we're already ready
    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
      return;
    }

    // Remember that the DOM is ready
    jQuery.isReady = true;

    // If a normal DOM Ready event fired, decrement, and wait if need be
    if ( wait !== true && --jQuery.readyWait > 0 ) {
      return;
    }

    // If there are functions bound, to execute
    readyList.resolveWith( document, [ jQuery ] );

    // Trigger any bound ready events
    if ( jQuery.fn.triggerHandler ) {
      jQuery( document ).triggerHandler( "ready" );
      jQuery( document ).off( "ready" );
    }
  }
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
  document.removeEventListener( "DOMContentLoaded", completed, false );
  window.removeEventListener( "load", completed, false );
  jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
  if ( !readyList ) {

    readyList = jQuery.Deferred();

    // Catch cases where $(document).ready() is called after the browser event has already occurred.
    // We once tried to use readyState "interactive" here, but it caused issues like the one
    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
    if ( document.readyState === "complete" ) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      setTimeout( jQuery.ready );

    } else {

      // Use the handy event callback
      document.addEventListener( "DOMContentLoaded", completed, false );

      // A fallback to window.onload, that will always work
      window.addEventListener( "load", completed, false );
    }
  }
  return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  var i = 0,
    len = elems.length,
    bulk = key == null;

  // Sets many values
  if ( jQuery.type( key ) === "object" ) {
    chainable = true;
    for ( i in key ) {
      jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
    }

  // Sets one value
  } else if ( value !== undefined ) {
    chainable = true;

    if ( !jQuery.isFunction( value ) ) {
      raw = true;
    }

    if ( bulk ) {
      // Bulk operations run against the entire set
      if ( raw ) {
        fn.call( elems, value );
        fn = null;

      // ...except when executing function values
      } else {
        bulk = fn;
        fn = function( elem, key, value ) {
          return bulk.call( jQuery( elem ), value );
        };
      }
    }

    if ( fn ) {
      for ( ; i < len; i++ ) {
        fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
      }
    }
  }

  return chainable ?
    elems :

    // Gets
    bulk ?
      fn.call( elems ) :
      len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
  // Accepts only:
  //  - Node
  //    - Node.ELEMENT_NODE
  //    - Node.DOCUMENT_NODE
  //  - Object
  //    - Any
  /* jshint -W018 */
  return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
  // Support: Android<4,
  // Old WebKit does not have Object.preventExtensions/freeze method,
  // return new empty object instead with no [[set]] accessor
  Object.defineProperty( this.cache = {}, 0, {
    get: function() {
      return {};
    }
  });

  this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
  key: function( owner ) {
    // We can accept data for non-element nodes in modern browsers,
    // but we should not, see #8335.
    // Always return the key for a frozen object.
    if ( !Data.accepts( owner ) ) {
      return 0;
    }

    var descriptor = {},
      // Check if the owner object already has a cache key
      unlock = owner[ this.expando ];

    // If not, create one
    if ( !unlock ) {
      unlock = Data.uid++;

      // Secure it in a non-enumerable, non-writable property
      try {
        descriptor[ this.expando ] = { value: unlock };
        Object.defineProperties( owner, descriptor );

      // Support: Android<4
      // Fallback to a less secure definition
      } catch ( e ) {
        descriptor[ this.expando ] = unlock;
        jQuery.extend( owner, descriptor );
      }
    }

    // Ensure the cache object
    if ( !this.cache[ unlock ] ) {
      this.cache[ unlock ] = {};
    }

    return unlock;
  },
  set: function( owner, data, value ) {
    var prop,
      // There may be an unlock assigned to this node,
      // if there is no entry for this "owner", create one inline
      // and set the unlock as though an owner entry had always existed
      unlock = this.key( owner ),
      cache = this.cache[ unlock ];

    // Handle: [ owner, key, value ] args
    if ( typeof data === "string" ) {
      cache[ data ] = value;

    // Handle: [ owner, { properties } ] args
    } else {
      // Fresh assignments by object are shallow copied
      if ( jQuery.isEmptyObject( cache ) ) {
        jQuery.extend( this.cache[ unlock ], data );
      // Otherwise, copy the properties one-by-one to the cache object
      } else {
        for ( prop in data ) {
          cache[ prop ] = data[ prop ];
        }
      }
    }
    return cache;
  },
  get: function( owner, key ) {
    // Either a valid cache is found, or will be created.
    // New caches will be created and the unlock returned,
    // allowing direct access to the newly created
    // empty data object. A valid owner object must be provided.
    var cache = this.cache[ this.key( owner ) ];

    return key === undefined ?
      cache : cache[ key ];
  },
  access: function( owner, key, value ) {
    var stored;
    // In cases where either:
    //
    //   1. No key was specified
    //   2. A string key was specified, but no value provided
    //
    // Take the "read" path and allow the get method to determine
    // which value to return, respectively either:
    //
    //   1. The entire cache object
    //   2. The data stored at the key
    //
    if ( key === undefined ||
        ((key && typeof key === "string") && value === undefined) ) {

      stored = this.get( owner, key );

      return stored !== undefined ?
        stored : this.get( owner, jQuery.camelCase(key) );
    }

    // [*]When the key is not a string, or both a key and value
    // are specified, set or extend (existing objects) with either:
    //
    //   1. An object of properties
    //   2. A key and value
    //
    this.set( owner, key, value );

    // Since the "set" path can have two possible entry points
    // return the expected data based on which path was taken[*]
    return value !== undefined ? value : key;
  },
  remove: function( owner, key ) {
    var i, name, camel,
      unlock = this.key( owner ),
      cache = this.cache[ unlock ];

    if ( key === undefined ) {
      this.cache[ unlock ] = {};

    } else {
      // Support array or space separated string of keys
      if ( jQuery.isArray( key ) ) {
        // If "name" is an array of keys...
        // When data is initially created, via ("key", "val") signature,
        // keys will be converted to camelCase.
        // Since there is no way to tell _how_ a key was added, remove
        // both plain key and camelCase key. #12786
        // This will only penalize the array argument path.
        name = key.concat( key.map( jQuery.camelCase ) );
      } else {
        camel = jQuery.camelCase( key );
        // Try the string as a key before any manipulation
        if ( key in cache ) {
          name = [ key, camel ];
        } else {
          // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace
          name = camel;
          name = name in cache ?
            [ name ] : ( name.match( rnotwhite ) || [] );
        }
      }

      i = name.length;
      while ( i-- ) {
        delete cache[ name[ i ] ];
      }
    }
  },
  hasData: function( owner ) {
    return !jQuery.isEmptyObject(
      this.cache[ owner[ this.expando ] ] || {}
    );
  },
  discard: function( owner ) {
    if ( owner[ this.expando ] ) {
      delete this.cache[ owner[ this.expando ] ];
    }
  }
};
var data_priv = new Data();

var data_user = new Data();



//  Implementation Summary
//
//  1. Enforce API surface and semantic compatibility with 1.9.x branch
//  2. Improve the module's maintainability by reducing the storage
//    paths to a single mechanism.
//  3. Use the same single mechanism to support "private" and "user" data.
//  4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//  5. Avoid exposing implementation details on user objects (eg. expando properties)
//  6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
  var name;

  // If nothing was found internally, try to fetch any
  // data from the HTML5 data-* attribute
  if ( data === undefined && elem.nodeType === 1 ) {
    name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
    data = elem.getAttribute( name );

    if ( typeof data === "string" ) {
      try {
        data = data === "true" ? true :
          data === "false" ? false :
          data === "null" ? null :
          // Only convert to a number if it doesn't change the string
          +data + "" === data ? +data :
          rbrace.test( data ) ? jQuery.parseJSON( data ) :
          data;
      } catch( e ) {}

      // Make sure we set the data so it isn't changed later
      data_user.set( elem, key, data );
    } else {
      data = undefined;
    }
  }
  return data;
}

jQuery.extend({
  hasData: function( elem ) {
    return data_user.hasData( elem ) || data_priv.hasData( elem );
  },

  data: function( elem, name, data ) {
    return data_user.access( elem, name, data );
  },

  removeData: function( elem, name ) {
    data_user.remove( elem, name );
  },

  // TODO: Now that all calls to _data and _removeData have been replaced
  // with direct calls to data_priv methods, these can be deprecated.
  _data: function( elem, name, data ) {
    return data_priv.access( elem, name, data );
  },

  _removeData: function( elem, name ) {
    data_priv.remove( elem, name );
  }
});

jQuery.fn.extend({
  data: function( key, value ) {
    var i, name, data,
      elem = this[ 0 ],
      attrs = elem && elem.attributes;

    // Gets all values
    if ( key === undefined ) {
      if ( this.length ) {
        data = data_user.get( elem );

        if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
          i = attrs.length;
          while ( i-- ) {

            // Support: IE11+
            // The attrs elements can be null (#14894)
            if ( attrs[ i ] ) {
              name = attrs[ i ].name;
              if ( name.indexOf( "data-" ) === 0 ) {
                name = jQuery.camelCase( name.slice(5) );
                dataAttr( elem, name, data[ name ] );
              }
            }
          }
          data_priv.set( elem, "hasDataAttrs", true );
        }
      }

      return data;
    }

    // Sets multiple values
    if ( typeof key === "object" ) {
      return this.each(function() {
        data_user.set( this, key );
      });
    }

    return access( this, function( value ) {
      var data,
        camelKey = jQuery.camelCase( key );

      // The calling jQuery object (element matches) is not empty
      // (and therefore has an element appears at this[ 0 ]) and the
      // `value` parameter was not undefined. An empty jQuery object
      // will result in `undefined` for elem = this[ 0 ] which will
      // throw an exception if an attempt to read a data cache is made.
      if ( elem && value === undefined ) {
        // Attempt to get data from the cache
        // with the key as-is
        data = data_user.get( elem, key );
        if ( data !== undefined ) {
          return data;
        }

        // Attempt to get data from the cache
        // with the key camelized
        data = data_user.get( elem, camelKey );
        if ( data !== undefined ) {
          return data;
        }

        // Attempt to "discover" the data in
        // HTML5 custom data-* attrs
        data = dataAttr( elem, camelKey, undefined );
        if ( data !== undefined ) {
          return data;
        }

        // We tried really hard, but the data doesn't exist.
        return;
      }

      // Set the data...
      this.each(function() {
        // First, attempt to store a copy or reference of any
        // data that might've been store with a camelCased key.
        var data = data_user.get( this, camelKey );

        // For HTML5 data-* attribute interop, we have to
        // store property names with dashes in a camelCase form.
        // This might not apply to all properties...*
        data_user.set( this, camelKey, value );

        // *... In the case of properties that might _actually_
        // have dashes, we need to also store a copy of that
        // unchanged property.
        if ( key.indexOf("-") !== -1 && data !== undefined ) {
          data_user.set( this, key, value );
        }
      });
    }, null, value, arguments.length > 1, null, true );
  },

  removeData: function( key ) {
    return this.each(function() {
      data_user.remove( this, key );
    });
  }
});


jQuery.extend({
  queue: function( elem, type, data ) {
    var queue;

    if ( elem ) {
      type = ( type || "fx" ) + "queue";
      queue = data_priv.get( elem, type );

      // Speed up dequeue by getting out quickly if this is just a lookup
      if ( data ) {
        if ( !queue || jQuery.isArray( data ) ) {
          queue = data_priv.access( elem, type, jQuery.makeArray(data) );
        } else {
          queue.push( data );
        }
      }
      return queue || [];
    }
  },

  dequeue: function( elem, type ) {
    type = type || "fx";

    var queue = jQuery.queue( elem, type ),
      startLength = queue.length,
      fn = queue.shift(),
      hooks = jQuery._queueHooks( elem, type ),
      next = function() {
        jQuery.dequeue( elem, type );
      };

    // If the fx queue is dequeued, always remove the progress sentinel
    if ( fn === "inprogress" ) {
      fn = queue.shift();
      startLength--;
    }

    if ( fn ) {

      // Add a progress sentinel to prevent the fx queue from being
      // automatically dequeued
      if ( type === "fx" ) {
        queue.unshift( "inprogress" );
      }

      // Clear up the last queue stop function
      delete hooks.stop;
      fn.call( elem, next, hooks );
    }

    if ( !startLength && hooks ) {
      hooks.empty.fire();
    }
  },

  // Not public - generate a queueHooks object, or return the current one
  _queueHooks: function( elem, type ) {
    var key = type + "queueHooks";
    return data_priv.get( elem, key ) || data_priv.access( elem, key, {
      empty: jQuery.Callbacks("once memory").add(function() {
        data_priv.remove( elem, [ type + "queue", key ] );
      })
    });
  }
});

jQuery.fn.extend({
  queue: function( type, data ) {
    var setter = 2;

    if ( typeof type !== "string" ) {
      data = type;
      type = "fx";
      setter--;
    }

    if ( arguments.length < setter ) {
      return jQuery.queue( this[0], type );
    }

    return data === undefined ?
      this :
      this.each(function() {
        var queue = jQuery.queue( this, type, data );

        // Ensure a hooks for this queue
        jQuery._queueHooks( this, type );

        if ( type === "fx" && queue[0] !== "inprogress" ) {
          jQuery.dequeue( this, type );
        }
      });
  },
  dequeue: function( type ) {
    return this.each(function() {
      jQuery.dequeue( this, type );
    });
  },
  clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
  },
  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function( type, obj ) {
    var tmp,
      count = 1,
      defer = jQuery.Deferred(),
      elements = this,
      i = this.length,
      resolve = function() {
        if ( !( --count ) ) {
          defer.resolveWith( elements, [ elements ] );
        }
      };

    if ( typeof type !== "string" ) {
      obj = type;
      type = undefined;
    }
    type = type || "fx";

    while ( i-- ) {
      tmp = data_priv.get( elements[ i ], type + "queueHooks" );
      if ( tmp && tmp.empty ) {
        count++;
        tmp.empty.add( resolve );
      }
    }
    resolve();
    return defer.promise( obj );
  }
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
  };

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
  var fragment = document.createDocumentFragment(),
    div = fragment.appendChild( document.createElement( "div" ) ),
    input = document.createElement( "input" );

  // Support: Safari<=5.1
  // Check state lost if the name is set (#11217)
  // Support: Windows Web Apps (WWA)
  // `name` and `type` must use .setAttribute for WWA (#14901)
  input.setAttribute( "type", "radio" );
  input.setAttribute( "checked", "checked" );
  input.setAttribute( "name", "t" );

  div.appendChild( input );

  // Support: Safari<=5.1, Android<4.2
  // Older WebKit doesn't clone checked state correctly in fragments
  support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  // Support: IE<=11+
  // Make sure textarea (and checkbox) defaultValue is properly cloned
  div.innerHTML = "<textarea>x</textarea>";
  support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
  rkeyEvent = /^key/,
  rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
  rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
  return true;
}

function returnFalse() {
  return false;
}

function safeActiveElement() {
  try {
    return document.activeElement;
  } catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

  global: {},

  add: function( elem, types, handler, data, selector ) {

    var handleObjIn, eventHandle, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = data_priv.get( elem );

    // Don't attach events to noData or text/comment nodes (but allow plain objects)
    if ( !elemData ) {
      return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if ( handler.handler ) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if ( !handler.guid ) {
      handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    if ( !(events = elemData.events) ) {
      events = elemData.events = {};
    }
    if ( !(eventHandle = elemData.handle) ) {
      eventHandle = elemData.handle = function( e ) {
        // Discard the second event of a jQuery.event.trigger() and
        // when an event is called after a page has unloaded
        return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
          jQuery.event.dispatch.apply( elem, arguments ) : undefined;
      };
    }

    // Handle multiple events separated by a space
    types = ( types || "" ).match( rnotwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
      tmp = rtypenamespace.exec( types[t] ) || [];
      type = origType = tmp[1];
      namespaces = ( tmp[2] || "" ).split( "." ).sort();

      // There *must* be a type, no attaching namespace-only handlers
      if ( !type ) {
        continue;
      }

      // If event changes its type, use the special event handlers for the changed type
      special = jQuery.event.special[ type ] || {};

      // If selector defined, determine special event api type, otherwise given type
      type = ( selector ? special.delegateType : special.bindType ) || type;

      // Update special based on newly reset type
      special = jQuery.event.special[ type ] || {};

      // handleObj is passed to all event handlers
      handleObj = jQuery.extend({
        type: type,
        origType: origType,
        data: data,
        handler: handler,
        guid: handler.guid,
        selector: selector,
        needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
        namespace: namespaces.join(".")
      }, handleObjIn );

      // Init the event handler queue if we're the first
      if ( !(handlers = events[ type ]) ) {
        handlers = events[ type ] = [];
        handlers.delegateCount = 0;

        // Only use addEventListener if the special events handler returns false
        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
          if ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, false );
          }
        }
      }

      if ( special.add ) {
        special.add.call( elem, handleObj );

        if ( !handleObj.handler.guid ) {
          handleObj.handler.guid = handler.guid;
        }
      }

      // Add to the element's handler list, delegates in front
      if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
      } else {
        handlers.push( handleObj );
      }

      // Keep track of which events have ever been used, for event optimization
      jQuery.event.global[ type ] = true;
    }

  },

  // Detach an event or set of events from an element
  remove: function( elem, types, handler, selector, mappedTypes ) {

    var j, origCount, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = data_priv.hasData( elem ) && data_priv.get( elem );

    if ( !elemData || !(events = elemData.events) ) {
      return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = ( types || "" ).match( rnotwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
      tmp = rtypenamespace.exec( types[t] ) || [];
      type = origType = tmp[1];
      namespaces = ( tmp[2] || "" ).split( "." ).sort();

      // Unbind all events (on this namespace, if provided) for the element
      if ( !type ) {
        for ( type in events ) {
          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
        }
        continue;
      }

      special = jQuery.event.special[ type ] || {};
      type = ( selector ? special.delegateType : special.bindType ) || type;
      handlers = events[ type ] || [];
      tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

      // Remove matching events
      origCount = j = handlers.length;
      while ( j-- ) {
        handleObj = handlers[ j ];

        if ( ( mappedTypes || origType === handleObj.origType ) &&
          ( !handler || handler.guid === handleObj.guid ) &&
          ( !tmp || tmp.test( handleObj.namespace ) ) &&
          ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
          handlers.splice( j, 1 );

          if ( handleObj.selector ) {
            handlers.delegateCount--;
          }
          if ( special.remove ) {
            special.remove.call( elem, handleObj );
          }
        }
      }

      // Remove generic event handler if we removed something and no more handlers exist
      // (avoids potential for endless recursion during removal of special event handlers)
      if ( origCount && !handlers.length ) {
        if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
          jQuery.removeEvent( elem, type, elemData.handle );
        }

        delete events[ type ];
      }
    }

    // Remove the expando if it's no longer used
    if ( jQuery.isEmptyObject( events ) ) {
      delete elemData.handle;
      data_priv.remove( elem, "events" );
    }
  },

  trigger: function( event, data, elem, onlyHandlers ) {

    var i, cur, tmp, bubbleType, ontype, handle, special,
      eventPath = [ elem || document ],
      type = hasOwn.call( event, "type" ) ? event.type : event,
      namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

    cur = tmp = elem = elem || document;

    // Don't do events on text and comment nodes
    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
      return;
    }

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
      return;
    }

    if ( type.indexOf(".") >= 0 ) {
      // Namespaced trigger; create a regexp to match event type in handle()
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }
    ontype = type.indexOf(":") < 0 && "on" + type;

    // Caller can pass in a jQuery.Event object, Object, or just an event type string
    event = event[ jQuery.expando ] ?
      event :
      new jQuery.Event( type, typeof event === "object" && event );

    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    event.isTrigger = onlyHandlers ? 2 : 3;
    event.namespace = namespaces.join(".");
    event.namespace_re = event.namespace ?
      new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
      null;

    // Clean up the event in case it is being reused
    event.result = undefined;
    if ( !event.target ) {
      event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data == null ?
      [ event ] :
      jQuery.makeArray( data, [ event ] );

    // Allow special events to draw outside the lines
    special = jQuery.event.special[ type ] || {};
    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
      return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

      bubbleType = special.delegateType || type;
      if ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
      }
      for ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
      }

      // Only add window if we got to document (e.g., not plain obj or detached DOM)
      if ( tmp === (elem.ownerDocument || document) ) {
        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
      }
    }

    // Fire handlers on the event path
    i = 0;
    while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

      event.type = i > 1 ?
        bubbleType :
        special.bindType || type;

      // jQuery handler
      handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
      if ( handle ) {
        handle.apply( cur, data );
      }

      // Native handler
      handle = ontype && cur[ ontype ];
      if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
        event.result = handle.apply( cur, data );
        if ( event.result === false ) {
          event.preventDefault();
        }
      }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

      if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
        jQuery.acceptData( elem ) ) {

        // Call a native DOM method on the target with the same name name as the event.
        // Don't do default actions on window, that's where global variables be (#6170)
        if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

          // Don't re-trigger an onFOO event when we call its FOO() method
          tmp = elem[ ontype ];

          if ( tmp ) {
            elem[ ontype ] = null;
          }

          // Prevent re-triggering of the same event, since we already bubbled it above
          jQuery.event.triggered = type;
          elem[ type ]();
          jQuery.event.triggered = undefined;

          if ( tmp ) {
            elem[ ontype ] = tmp;
          }
        }
      }
    }

    return event.result;
  },

  dispatch: function( event ) {

    // Make a writable jQuery.Event from the native event object
    event = jQuery.event.fix( event );

    var i, j, ret, matched, handleObj,
      handlerQueue = [],
      args = slice.call( arguments ),
      handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
      special = jQuery.event.special[ event.type ] || {};

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[0] = event;
    event.delegateTarget = this;

    // Call the preDispatch hook for the mapped type, and let it bail if desired
    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
      return;
    }

    // Determine handlers
    handlerQueue = jQuery.event.handlers.call( this, event, handlers );

    // Run delegates first; they may want to stop propagation beneath us
    i = 0;
    while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
      event.currentTarget = matched.elem;

      j = 0;
      while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

        // Triggered event must either 1) have no namespace, or 2) have namespace(s)
        // a subset or equal to those in the bound event (both can have no namespace).
        if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

          event.handleObj = handleObj;
          event.data = handleObj.data;

          ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
              .apply( matched.elem, args );

          if ( ret !== undefined ) {
            if ( (event.result = ret) === false ) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }

    // Call the postDispatch hook for the mapped type
    if ( special.postDispatch ) {
      special.postDispatch.call( this, event );
    }

    return event.result;
  },

  handlers: function( event, handlers ) {
    var i, matches, sel, handleObj,
      handlerQueue = [],
      delegateCount = handlers.delegateCount,
      cur = event.target;

    // Find delegate handlers
    // Black-hole SVG <use> instance trees (#13180)
    // Avoid non-left-click bubbling in Firefox (#3861)
    if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

      for ( ; cur !== this; cur = cur.parentNode || this ) {

        // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
        if ( cur.disabled !== true || event.type !== "click" ) {
          matches = [];
          for ( i = 0; i < delegateCount; i++ ) {
            handleObj = handlers[ i ];

            // Don't conflict with Object.prototype properties (#13203)
            sel = handleObj.selector + " ";

            if ( matches[ sel ] === undefined ) {
              matches[ sel ] = handleObj.needsContext ?
                jQuery( sel, this ).index( cur ) >= 0 :
                jQuery.find( sel, this, null, [ cur ] ).length;
            }
            if ( matches[ sel ] ) {
              matches.push( handleObj );
            }
          }
          if ( matches.length ) {
            handlerQueue.push({ elem: cur, handlers: matches });
          }
        }
      }
    }

    // Add the remaining (directly-bound) handlers
    if ( delegateCount < handlers.length ) {
      handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
    }

    return handlerQueue;
  },

  // Includes some event props shared by KeyEvent and MouseEvent
  props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

  fixHooks: {},

  keyHooks: {
    props: "char charCode key keyCode".split(" "),
    filter: function( event, original ) {

      // Add which for key events
      if ( event.which == null ) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
      }

      return event;
    }
  },

  mouseHooks: {
    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter: function( event, original ) {
      var eventDoc, doc, body,
        button = original.button;

      // Calculate pageX/Y if missing and clientX/Y available
      if ( event.pageX == null && original.clientX != null ) {
        eventDoc = event.target.ownerDocument || document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;

        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
      }

      // Add which for click: 1 === left; 2 === middle; 3 === right
      // Note: button is not normalized, so don't use it
      if ( !event.which && button !== undefined ) {
        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
      }

      return event;
    }
  },

  fix: function( event ) {
    if ( event[ jQuery.expando ] ) {
      return event;
    }

    // Create a writable copy of the event object and normalize some properties
    var i, prop, copy,
      type = event.type,
      originalEvent = event,
      fixHook = this.fixHooks[ type ];

    if ( !fixHook ) {
      this.fixHooks[ type ] = fixHook =
        rmouseEvent.test( type ) ? this.mouseHooks :
        rkeyEvent.test( type ) ? this.keyHooks :
        {};
    }
    copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

    event = new jQuery.Event( originalEvent );

    i = copy.length;
    while ( i-- ) {
      prop = copy[ i ];
      event[ prop ] = originalEvent[ prop ];
    }

    // Support: Cordova 2.5 (WebKit) (#13255)
    // All events should have a target; Cordova deviceready doesn't
    if ( !event.target ) {
      event.target = document;
    }

    // Support: Safari 6.0+, Chrome<28
    // Target should not be a text node (#504, #13143)
    if ( event.target.nodeType === 3 ) {
      event.target = event.target.parentNode;
    }

    return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
  },

  special: {
    load: {
      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },
    focus: {
      // Fire native event if possible so blur/focus sequence is correct
      trigger: function() {
        if ( this !== safeActiveElement() && this.focus ) {
          this.focus();
          return false;
        }
      },
      delegateType: "focusin"
    },
    blur: {
      trigger: function() {
        if ( this === safeActiveElement() && this.blur ) {
          this.blur();
          return false;
        }
      },
      delegateType: "focusout"
    },
    click: {
      // For checkbox, fire native event so checked state will be right
      trigger: function() {
        if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
          this.click();
          return false;
        }
      },

      // For cross-browser consistency, don't fire native .click() on links
      _default: function( event ) {
        return jQuery.nodeName( event.target, "a" );
      }
    },

    beforeunload: {
      postDispatch: function( event ) {

        // Support: Firefox 20+
        // Firefox doesn't alert if the returnValue field is not set.
        if ( event.result !== undefined && event.originalEvent ) {
          event.originalEvent.returnValue = event.result;
        }
      }
    }
  },

  simulate: function( type, elem, event, bubble ) {
    // Piggyback on a donor event to simulate a different one.
    // Fake originalEvent to avoid donor's stopPropagation, but if the
    // simulated event prevents default then we do the same on the donor.
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      {
        type: type,
        isSimulated: true,
        originalEvent: {}
      }
    );
    if ( bubble ) {
      jQuery.event.trigger( e, null, elem );
    } else {
      jQuery.event.dispatch.call( elem, e );
    }
    if ( e.isDefaultPrevented() ) {
      event.preventDefault();
    }
  }
};

jQuery.removeEvent = function( elem, type, handle ) {
  if ( elem.removeEventListener ) {
    elem.removeEventListener( type, handle, false );
  }
};

jQuery.Event = function( src, props ) {
  // Allow instantiation without the 'new' keyword
  if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = src.defaultPrevented ||
        src.defaultPrevented === undefined &&
        // Support: Android<4.0
        src.returnValue === false ?
      returnTrue :
      returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    jQuery.extend( this, props );
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || jQuery.now();

  // Mark it as fixed
  this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse,

  preventDefault: function() {
    var e = this.originalEvent;

    this.isDefaultPrevented = returnTrue;

    if ( e && e.preventDefault ) {
      e.preventDefault();
    }
  },
  stopPropagation: function() {
    var e = this.originalEvent;

    this.isPropagationStopped = returnTrue;

    if ( e && e.stopPropagation ) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function() {
    var e = this.originalEvent;

    this.isImmediatePropagationStopped = returnTrue;

    if ( e && e.stopImmediatePropagation ) {
      e.stopImmediatePropagation();
    }

    this.stopPropagation();
  }
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
}, function( orig, fix ) {
  jQuery.event.special[ orig ] = {
    delegateType: fix,
    bindType: fix,

    handle: function( event ) {
      var ret,
        target = this,
        related = event.relatedTarget,
        handleObj = event.handleObj;

      // For mousenter/leave call the handler if related is outside the target.
      // NB: No relatedTarget if the mouse left/entered the browser window
      if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply( this, arguments );
        event.type = fix;
      }
      return ret;
    }
  };
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
  jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

    // Attach a single capturing handler on the document while someone wants focusin/focusout
    var handler = function( event ) {
        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
      };

    jQuery.event.special[ fix ] = {
      setup: function() {
        var doc = this.ownerDocument || this,
          attaches = data_priv.access( doc, fix );

        if ( !attaches ) {
          doc.addEventListener( orig, handler, true );
        }
        data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
      },
      teardown: function() {
        var doc = this.ownerDocument || this,
          attaches = data_priv.access( doc, fix ) - 1;

        if ( !attaches ) {
          doc.removeEventListener( orig, handler, true );
          data_priv.remove( doc, fix );

        } else {
          data_priv.access( doc, fix, attaches );
        }
      }
    };
  });
}

jQuery.fn.extend({

  on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
    var origFn, type;

    // Types can be a map of types/handlers
    if ( typeof types === "object" ) {
      // ( types-Object, selector, data )
      if ( typeof selector !== "string" ) {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for ( type in types ) {
        this.on( type, selector, data, types[ type ], one );
      }
      return this;
    }

    if ( data == null && fn == null ) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if ( fn == null ) {
      if ( typeof selector === "string" ) {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if ( fn === false ) {
      fn = returnFalse;
    } else if ( !fn ) {
      return this;
    }

    if ( one === 1 ) {
      origFn = fn;
      fn = function( event ) {
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
      };
      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    }
    return this.each( function() {
      jQuery.event.add( this, types, fn, data, selector );
    });
  },
  one: function( types, selector, data, fn ) {
    return this.on( types, selector, data, fn, 1 );
  },
  off: function( types, selector, fn ) {
    var handleObj, type;
    if ( types && types.preventDefault && types.handleObj ) {
      // ( event )  dispatched jQuery.Event
      handleObj = types.handleObj;
      jQuery( types.delegateTarget ).off(
        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if ( typeof types === "object" ) {
      // ( types-object [, selector] )
      for ( type in types ) {
        this.off( type, selector, types[ type ] );
      }
      return this;
    }
    if ( selector === false || typeof selector === "function" ) {
      // ( types [, fn] )
      fn = selector;
      selector = undefined;
    }
    if ( fn === false ) {
      fn = returnFalse;
    }
    return this.each(function() {
      jQuery.event.remove( this, types, fn, selector );
    });
  },

  trigger: function( type, data ) {
    return this.each(function() {
      jQuery.event.trigger( type, data, this );
    });
  },
  triggerHandler: function( type, data ) {
    var elem = this[0];
    if ( elem ) {
      return jQuery.event.trigger( type, data, elem, true );
    }
  }
});


var
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
  rtagName = /<([\w:]+)/,
  rhtml = /<|&#?\w+;/,
  rnoInnerhtml = /<(?:script|style|link)/i,
  // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  rscriptType = /^$|\/(?:java|ecma)script/i,
  rscriptTypeMasked = /^true\/(.*)/,
  rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

  // We have to close these tags to support XHTML (#13200)
  wrapMap = {

    // Support: IE9
    option: [ 1, "<select multiple='multiple'>", "</select>" ],

    thead: [ 1, "<table>", "</table>" ],
    col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

    _default: [ 0, "", "" ]
  };

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
  return jQuery.nodeName( elem, "table" ) &&
    jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

    elem.getElementsByTagName("tbody")[0] ||
      elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
    elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
  elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
  return elem;
}
function restoreScript( elem ) {
  var match = rscriptTypeMasked.exec( elem.type );

  if ( match ) {
    elem.type = match[ 1 ];
  } else {
    elem.removeAttribute("type");
  }

  return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
  var i = 0,
    l = elems.length;

  for ( ; i < l; i++ ) {
    data_priv.set(
      elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
    );
  }
}

function cloneCopyEvent( src, dest ) {
  var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

  if ( dest.nodeType !== 1 ) {
    return;
  }

  // 1. Copy private data: events, handlers, etc.
  if ( data_priv.hasData( src ) ) {
    pdataOld = data_priv.access( src );
    pdataCur = data_priv.set( dest, pdataOld );
    events = pdataOld.events;

    if ( events ) {
      delete pdataCur.handle;
      pdataCur.events = {};

      for ( type in events ) {
        for ( i = 0, l = events[ type ].length; i < l; i++ ) {
          jQuery.event.add( dest, type, events[ type ][ i ] );
        }
      }
    }
  }

  // 2. Copy user data
  if ( data_user.hasData( src ) ) {
    udataOld = data_user.access( src );
    udataCur = jQuery.extend( {}, udataOld );

    data_user.set( dest, udataCur );
  }
}

function getAll( context, tag ) {
  var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
      context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
      [];

  return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
    jQuery.merge( [ context ], ret ) :
    ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
  var nodeName = dest.nodeName.toLowerCase();

  // Fails to persist the checked state of a cloned checkbox or radio button.
  if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
    dest.checked = src.checked;

  // Fails to return the selected option to the default selected state when cloning options
  } else if ( nodeName === "input" || nodeName === "textarea" ) {
    dest.defaultValue = src.defaultValue;
  }
}

jQuery.extend({
  clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    var i, l, srcElements, destElements,
      clone = elem.cloneNode( true ),
      inPage = jQuery.contains( elem.ownerDocument, elem );

    // Fix IE cloning issues
    if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
        !jQuery.isXMLDoc( elem ) ) {

      // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
      destElements = getAll( clone );
      srcElements = getAll( elem );

      for ( i = 0, l = srcElements.length; i < l; i++ ) {
        fixInput( srcElements[ i ], destElements[ i ] );
      }
    }

    // Copy the events from the original to the clone
    if ( dataAndEvents ) {
      if ( deepDataAndEvents ) {
        srcElements = srcElements || getAll( elem );
        destElements = destElements || getAll( clone );

        for ( i = 0, l = srcElements.length; i < l; i++ ) {
          cloneCopyEvent( srcElements[ i ], destElements[ i ] );
        }
      } else {
        cloneCopyEvent( elem, clone );
      }
    }

    // Preserve script evaluation history
    destElements = getAll( clone, "script" );
    if ( destElements.length > 0 ) {
      setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
    }

    // Return the cloned set
    return clone;
  },

  buildFragment: function( elems, context, scripts, selection ) {
    var elem, tmp, tag, wrap, contains, j,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i = 0,
      l = elems.length;

    for ( ; i < l; i++ ) {
      elem = elems[ i ];

      if ( elem || elem === 0 ) {

        // Add nodes directly
        if ( jQuery.type( elem ) === "object" ) {
          // Support: QtWebKit, PhantomJS
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

        // Convert non-html into a text node
        } else if ( !rhtml.test( elem ) ) {
          nodes.push( context.createTextNode( elem ) );

        // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild( context.createElement("div") );

          // Deserialize a standard representation
          tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
          wrap = wrapMap[ tag ] || wrapMap._default;

          if (Xut.IBooks.Enabled) {
              try {
                  tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
              } catch (e) {
                  console.log(wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2])
              }
          } else {
              tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
          }

          // Descend through wrappers to the right content
          j = wrap[ 0 ];
          while ( j-- ) {
            tmp = tmp.lastChild;
          }

          // Support: QtWebKit, PhantomJS
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge( nodes, tmp.childNodes );

          // Remember the top-level container
          tmp = fragment.firstChild;

          // Ensure the created nodes are orphaned (#12392)
          tmp.textContent = "";
        }
      }
    }

    // Remove wrapper from fragment
    fragment.textContent = "";

    i = 0;
    while ( (elem = nodes[ i++ ]) ) {

      // #4087 - If origin and destination elements are the same, and this is
      // that element, do not do anything
      if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
        continue;
      }

      contains = jQuery.contains( elem.ownerDocument, elem );

      // Append to fragment
      tmp = getAll( fragment.appendChild( elem ), "script" );

      // Preserve script evaluation history
      if ( contains ) {
        setGlobalEval( tmp );
      }

      // Capture executables
      if ( scripts ) {
        j = 0;
        while ( (elem = tmp[ j++ ]) ) {
          if ( rscriptType.test( elem.type || "" ) ) {
            scripts.push( elem );
          }
        }
      }
    }

    return fragment;
  },

  cleanData: function( elems ) {
    var data, elem, type, key,
      special = jQuery.event.special,
      i = 0;

    for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
      if ( jQuery.acceptData( elem ) ) {
        key = elem[ data_priv.expando ];

        if ( key && (data = data_priv.cache[ key ]) ) {
          if ( data.events ) {
            for ( type in data.events ) {
              if ( special[ type ] ) {
                jQuery.event.remove( elem, type );

              // This is a shortcut to avoid jQuery.event.remove's overhead
              } else {
                jQuery.removeEvent( elem, type, data.handle );
              }
            }
          }
          if ( data_priv.cache[ key ] ) {
            // Discard any remaining `private` data
            delete data_priv.cache[ key ];
          }
        }
      }
      // Discard any remaining `user` data
      delete data_user.cache[ elem[ data_user.expando ] ];
    }
  }
});

jQuery.fn.extend({
  text: function( value ) {
    return access( this, function( value ) {
      return value === undefined ?
        jQuery.text( this ) :
        this.empty().each(function() {
          if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
            this.textContent = value;
          }
        });
    }, null, value, arguments.length );
  },

  append: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
        var target = manipulationTarget( this, elem );
        target.appendChild( elem );
      }
    });
  },

  prepend: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
        var target = manipulationTarget( this, elem );
        target.insertBefore( elem, target.firstChild );
      }
    });
  },

  before: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.parentNode ) {
        this.parentNode.insertBefore( elem, this );
      }
    });
  },

  after: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.parentNode ) {
        this.parentNode.insertBefore( elem, this.nextSibling );
      }
    });
  },

  remove: function( selector, keepData /* Internal Use Only */ ) {
    var elem,
      elems = selector ? jQuery.filter( selector, this ) : this,
      i = 0;

    for ( ; (elem = elems[i]) != null; i++ ) {
      if ( !keepData && elem.nodeType === 1 ) {
        jQuery.cleanData( getAll( elem ) );
      }

      if ( elem.parentNode ) {
        if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
          setGlobalEval( getAll( elem, "script" ) );
        }
        elem.parentNode.removeChild( elem );
      }
    }

    return this;
  },

  empty: function() {
    var elem,
      i = 0;

    for ( ; (elem = this[i]) != null; i++ ) {
      if ( elem.nodeType === 1 ) {

        // Prevent memory leaks
        jQuery.cleanData( getAll( elem, false ) );

        // Remove any remaining nodes
        elem.textContent = "";
      }
    }

    return this;
  },

  clone: function( dataAndEvents, deepDataAndEvents ) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map(function() {
      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    });
  },

  html: function( value ) {
    return access( this, function( value ) {
      var elem = this[ 0 ] || {},
        i = 0,
        l = this.length;

      if ( value === undefined && elem.nodeType === 1 ) {
        return elem.innerHTML;
      }

      // See if we can take a shortcut and just use innerHTML
      if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
        !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

        value = value.replace( rxhtmlTag, "<$1></$2>" );

        try {
          for ( ; i < l; i++ ) {
            elem = this[ i ] || {};

            // Remove element nodes and prevent memory leaks
            if ( elem.nodeType === 1 ) {
              jQuery.cleanData( getAll( elem, false ) );
              elem.innerHTML = value;
            }
          }

          elem = 0;

        // If using innerHTML throws an exception, use the fallback method
        } catch( e ) {}
      }

      if ( elem ) {
        this.empty().append( value );
      }
    }, null, value, arguments.length );
  },

  replaceWith: function() {
    var arg = arguments[ 0 ];

    // Make the changes, replacing each context element with the new content
    this.domManip( arguments, function( elem ) {
      arg = this.parentNode;

      jQuery.cleanData( getAll( this ) );

      if ( arg ) {
        arg.replaceChild( elem, this );
      }
    });

    // Force removal if there was no new content (e.g., from empty arguments)
    return arg && (arg.length || arg.nodeType) ? this : this.remove();
  },

  detach: function( selector ) {
    return this.remove( selector, true );
  },

  domManip: function( args, callback ) {

    // Flatten any nested arrays
    args = concat.apply( [], args );

    var fragment, first, scripts, hasScripts, node, doc,
      i = 0,
      l = this.length,
      set = this,
      iNoClone = l - 1,
      value = args[ 0 ],
      isFunction = jQuery.isFunction( value );

    // We can't cloneNode fragments that contain checked, in WebKit
    if ( isFunction ||
        ( l > 1 && typeof value === "string" &&
          !support.checkClone && rchecked.test( value ) ) ) {
      return this.each(function( index ) {
        var self = set.eq( index );
        if ( isFunction ) {
          args[ 0 ] = value.call( this, index, self.html() );
        }
        self.domManip( args, callback );
      });
    }

    if ( l ) {
      fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
      first = fragment.firstChild;

      if ( fragment.childNodes.length === 1 ) {
        fragment = first;
      }

      if ( first ) {
        scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
        hasScripts = scripts.length;

        // Use the original fragment for the last item instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).
        for ( ; i < l; i++ ) {
          node = fragment;

          if ( i !== iNoClone ) {
            node = jQuery.clone( node, true, true );

            // Keep references to cloned scripts for later restoration
            if ( hasScripts ) {
              // Support: QtWebKit
              // jQuery.merge because push.apply(_, arraylike) throws
              jQuery.merge( scripts, getAll( node, "script" ) );
            }
          }

          callback.call( this[ i ], node, i );
        }

        if ( hasScripts ) {
          doc = scripts[ scripts.length - 1 ].ownerDocument;

          // Reenable scripts
          jQuery.map( scripts, restoreScript );

          // Evaluate executable scripts on first document insertion
          for ( i = 0; i < hasScripts; i++ ) {
            node = scripts[ i ];
            if ( rscriptType.test( node.type || "" ) &&
              !data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

              if ( node.src ) {
                // Optional AJAX dependency, but won't run scripts if not present
                if ( jQuery._evalUrl ) {
                  jQuery._evalUrl( node.src );
                }
              } else {
                jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
              }
            }
          }
        }
      }
    }

    return this;
  }
});

jQuery.each({
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function( name, original ) {
  jQuery.fn[ name ] = function( selector ) {
    var elems,
      ret = [],
      insert = jQuery( selector ),
      last = insert.length - 1,
      i = 0;

    for ( ; i <= last; i++ ) {
      elems = i === last ? this : this.clone( true );
      jQuery( insert[ i ] )[ original ]( elems );

      // Support: QtWebKit
      // .get() because push.apply(_, arraylike) throws
      push.apply( ret, elems.get() );
    }

    return this.pushStack( ret );
  };
});


var iframe,
  elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
  var style,
    elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

    // getDefaultComputedStyle might be reliably used only on attached element
    display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

      // Use of this method is a temporary fix (more like optimization) until something better comes along,
      // since it was removed from specification and supported only in FF
      style.display : jQuery.css( elem[ 0 ], "display" );

  // We don't have any data stored on the element,
  // so use "detach" method as fast way to get rid of the element
  elem.detach();

  return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
  var doc = document,
    display = elemdisplay[ nodeName ];

  if ( !display ) {
    display = actualDisplay( nodeName, doc );

    // If the simple way fails, read from inside an iframe
    if ( display === "none" || !display ) {

      // Use the already-created iframe if possible
      iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

      // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
      doc = iframe[ 0 ].contentDocument;

      // Support: IE
      doc.write();
      doc.close();

      display = actualDisplay( nodeName, doc );
      iframe.detach();
    }

    // Store the correct default display
    elemdisplay[ nodeName ] = display;
  }

  return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    if ( elem.ownerDocument.defaultView.opener ) {
      return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
    }

    return window.getComputedStyle( elem, null );
  };



function curCSS( elem, name, computed ) {
  var width, minWidth, maxWidth, ret,
    style = elem.style;

  computed = computed || getStyles( elem );

  // Support: IE9
  // getPropertyValue is only needed for .css('filter') (#12537)
  if ( computed ) {
    ret = computed.getPropertyValue( name ) || computed[ name ];
  }

  if ( computed ) {

    if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
      ret = jQuery.style( elem, name );
    }

    // Support: iOS < 6
    // A tribute to the "awesome hack by Dean Edwards"
    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
    if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

      // Remember the original values
      width = style.width;
      minWidth = style.minWidth;
      maxWidth = style.maxWidth;

      // Put in the new values to get a computed value out
      style.minWidth = style.maxWidth = style.width = ret;
      ret = computed.width;

      // Revert the changed values
      style.width = width;
      style.minWidth = minWidth;
      style.maxWidth = maxWidth;
    }
  }

  return ret !== undefined ?
    // Support: IE
    // IE returns zIndex value as an integer.
    ret + "" :
    ret;
}


function addGetHookIf( conditionFn, hookFn ) {
  // Define the hook, we'll check on the first run if it's really needed.
  return {
    get: function() {
      if ( conditionFn() ) {
        // Hook not needed (or it's not possible to use it due
        // to missing dependency), remove it.
        delete this.get;
        return;
      }

      // Hook needed; redefine it so that the support test is not executed again.
      return (this.get = hookFn).apply( this, arguments );
    }
  };
}


(function() {
  var pixelPositionVal, boxSizingReliableVal,
    docElem = document.documentElement,
    container = document.createElement( "div" ),
    div = document.createElement( "div" );

  if ( !div.style ) {
    return;
  }

  // Support: IE9-11+
  // Style of cloned element affects source element cloned (#8908)
  div.style.backgroundClip = "content-box";
  div.cloneNode( true ).style.backgroundClip = "";
  support.clearCloneStyle = div.style.backgroundClip === "content-box";

  container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
    "position:absolute";
  container.appendChild( div );

  // Executing both pixelPosition & boxSizingReliable tests require only one layout
  // so they're executed at the same time to save the second computation.
  function computePixelPositionAndBoxSizingReliable() {
    div.style.cssText =
      // Support: Firefox<29, Android 2.3
      // Vendor-prefix box-sizing
      "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
      "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
      "border:1px;padding:1px;width:4px;position:absolute";
    div.innerHTML = "";
    docElem.appendChild( container );

    var divStyle = window.getComputedStyle( div, null );
    pixelPositionVal = divStyle.top !== "1%";
    boxSizingReliableVal = divStyle.width === "4px";

    docElem.removeChild( container );
  }

  // Support: node.js jsdom
  // Don't assume that getComputedStyle is a property of the global object
  if ( window.getComputedStyle ) {
    jQuery.extend( support, {
      pixelPosition: function() {

        // This test is executed only once but we still do memoizing
        // since we can use the boxSizingReliable pre-computing.
        // No need to check if the test was already performed, though.
        computePixelPositionAndBoxSizingReliable();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        if ( boxSizingReliableVal == null ) {
          computePixelPositionAndBoxSizingReliable();
        }
        return boxSizingReliableVal;
      },
      reliableMarginRight: function() {

        // Support: Android 2.3
        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. (#3333)
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        // This support function is only executed once so no memoizing is needed.
        var ret,
          marginDiv = div.appendChild( document.createElement( "div" ) );

        // Reset CSS: box-sizing; display; margin; border; padding
        marginDiv.style.cssText = div.style.cssText =
          // Support: Firefox<29, Android 2.3
          // Vendor-prefix box-sizing
          "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
          "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
        marginDiv.style.marginRight = marginDiv.style.width = "0";
        div.style.width = "1px";
        docElem.appendChild( container );

        ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

        docElem.removeChild( container );
        div.removeChild( marginDiv );

        return ret;
      }
    });
  }
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
  var ret, name,
    old = {};

  // Remember the old values, and insert the new ones
  for ( name in options ) {
    old[ name ] = elem.style[ name ];
    elem.style[ name ] = options[ name ];
  }

  ret = callback.apply( elem, args || [] );

  // Revert the old values
  for ( name in options ) {
    elem.style[ name ] = old[ name ];
  }

  return ret;
};


var
  // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
  rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

  cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  },

  cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

  // Shortcut for names that are not vendor prefixed
  if ( name in style ) {
    return name;
  }

  // Check for vendor prefixed names
  var capName = name[0].toUpperCase() + name.slice(1),
    origName = name,
    i = cssPrefixes.length;

  while ( i-- ) {
    name = cssPrefixes[ i ] + capName;
    if ( name in style ) {
      return name;
    }
  }

  return origName;
}

function setPositiveNumber( elem, value, subtract ) {
  var matches = rnumsplit.exec( value );
  return matches ?
    // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
    value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
  var i = extra === ( isBorderBox ? "border" : "content" ) ?
    // If we already have the right measurement, avoid augmentation
    4 :
    // Otherwise initialize for horizontal or vertical properties
    name === "width" ? 1 : 0,

    val = 0;

  for ( ; i < 4; i += 2 ) {
    // Both box models exclude margin, so add it if we want it
    if ( extra === "margin" ) {
      val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
    }

    if ( isBorderBox ) {
      // border-box includes padding, so remove it if we want content
      if ( extra === "content" ) {
        val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
      }

      // At this point, extra isn't border nor margin, so remove border
      if ( extra !== "margin" ) {
        val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
      }
    } else {
      // At this point, extra isn't content, so add padding
      val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

      // At this point, extra isn't content nor padding, so add border
      if ( extra !== "padding" ) {
        val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
      }
    }
  }

  return val;
}

function getWidthOrHeight( elem, name, extra ) {

  // Start with offset property, which is equivalent to the border-box value
  var valueIsBorderBox = true,
    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    styles = getStyles( elem ),
    isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  // Some non-html elements return undefined for offsetWidth, so check for null/undefined
  // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
  // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
  if ( val <= 0 || val == null ) {
    // Fall back to computed then uncomputed css if necessary
    val = curCSS( elem, name, styles );
    if ( val < 0 || val == null ) {
      val = elem.style[ name ];
    }

    // Computed unit is not pixels. Stop here and return.
    if ( rnumnonpx.test(val) ) {
      return val;
    }

    // Check for style in case a browser which returns unreliable values
    // for getComputedStyle silently falls back to the reliable elem.style
    valueIsBorderBox = isBorderBox &&
      ( support.boxSizingReliable() || val === elem.style[ name ] );

    // Normalize "", auto, and prepare for extra
    val = parseFloat( val ) || 0;
  }

  // Use the active box-sizing model to add/subtract irrelevant styles
  return ( val +
    augmentWidthOrHeight(
      elem,
      name,
      extra || ( isBorderBox ? "border" : "content" ),
      valueIsBorderBox,
      styles
    )
  ) + "px";
}

function showHide( elements, show ) {
  var display, elem, hidden,
    values = [],
    index = 0,
    length = elements.length;

  for ( ; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
      continue;
    }

    values[ index ] = data_priv.get( elem, "olddisplay" );
    display = elem.style.display;
    if ( show ) {
      // Reset the inline display of this element to learn if it is
      // being hidden by cascaded rules or not
      if ( !values[ index ] && display === "none" ) {
        elem.style.display = "";
      }

      // Set elements which have been overridden with display: none
      // in a stylesheet to whatever the default browser style is
      // for such an element
      if ( elem.style.display === "" && isHidden( elem ) ) {
        values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
      }
    } else {
      hidden = isHidden( elem );

      if ( display !== "none" || !hidden ) {
        data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
      }
    }
  }

  // Set the display of most of the elements in a second loop
  // to avoid the constant reflow
  for ( index = 0; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
      continue;
    }
    if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
      elem.style.display = show ? values[ index ] || "" : "none";
    }
  }

  return elements;
}

jQuery.extend({

  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function( elem, computed ) {
        if ( computed ) {

          // We should always get a number back from opacity
          var ret = curCSS( elem, "opacity" );
          return ret === "" ? "1" : ret;
        }
      }
    }
  },

  // Don't automatically add "px" to these possibly-unitless properties
  cssNumber: {
    "columnCount": true,
    "fillOpacity": true,
    "flexGrow": true,
    "flexShrink": true,
    "fontWeight": true,
    "lineHeight": true,
    "opacity": true,
    "order": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },

  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {
    "float": "cssFloat"
  },

  // Get and set the style property on a DOM Node
  style: function( elem, name, value, extra ) {

    // Don't set styles on text and comment nodes
    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
      return;
    }

    // Make sure that we're working with the right name
    var ret, type, hooks,
      origName = jQuery.camelCase( name ),
      style = elem.style;

    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

    // Gets hook for the prefixed version, then unprefixed version
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // Check if we're setting a value
    if ( value !== undefined ) {
      type = typeof value;

      // Convert "+=" or "-=" to relative numbers (#7345)
      if ( type === "string" && (ret = rrelNum.exec( value )) ) {
        value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
        // Fixes bug #9237
        type = "number";
      }

      // Make sure that null and NaN values aren't set (#7116)
      if ( value == null || value !== value ) {
        return;
      }

      // If a number, add 'px' to the (except for certain CSS properties)
      if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
        value += "px";
      }

      // Support: IE9-11+
      // background-* props affect original clone's values
      if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
        style[ name ] = "inherit";
      }

      // If a hook was provided, use that value, otherwise just set the specified value
      if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
        style[ name ] = value;
      }

    } else {
      // If a hook was provided get the non-computed value from there
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
        return ret;
      }

      // Otherwise just get the value from the style object
      return style[ name ];
    }
  },

  css: function( elem, name, extra, styles ) {
    var val, num, hooks,
      origName = jQuery.camelCase( name );

    // Make sure that we're working with the right name
    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

    // Try prefixed name followed by the unprefixed name
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // If a hook was provided get the computed value from there
    if ( hooks && "get" in hooks ) {
      val = hooks.get( elem, true, extra );
    }

    // Otherwise, if a way to get the computed value exists, use that
    if ( val === undefined ) {
      val = curCSS( elem, name, styles );
    }

    // Convert "normal" to computed value
    if ( val === "normal" && name in cssNormalTransform ) {
      val = cssNormalTransform[ name ];
    }

    // Make numeric if forced or a qualifier was provided and val looks numeric
    if ( extra === "" || extra ) {
      num = parseFloat( val );
      return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
    }
    return val;
  }
});

jQuery.each([ "height", "width" ], function( i, name ) {
  jQuery.cssHooks[ name ] = {
    get: function( elem, computed, extra ) {
      if ( computed ) {

        // Certain elements can have dimension info if we invisibly show them
        // but it must have a current display style that would benefit
        return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
          jQuery.swap( elem, cssShow, function() {
            return getWidthOrHeight( elem, name, extra );
          }) :
          getWidthOrHeight( elem, name, extra );
      }
    },

    set: function( elem, value, extra ) {
      var styles = extra && getStyles( elem );
      return setPositiveNumber( elem, value, extra ?
        augmentWidthOrHeight(
          elem,
          name,
          extra,
          jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
          styles
        ) : 0
      );
    }
  };
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
  function( elem, computed ) {
    if ( computed ) {
      return jQuery.swap( elem, { "display": "inline-block" },
        curCSS, [ elem, "marginRight" ] );
    }
  }
);

// These hooks are used by animate to expand properties
jQuery.each({
  margin: "",
  padding: "",
  border: "Width"
}, function( prefix, suffix ) {
  jQuery.cssHooks[ prefix + suffix ] = {
    expand: function( value ) {
      var i = 0,
        expanded = {},

        // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [ value ];

      for ( ; i < 4; i++ ) {
        expanded[ prefix + cssExpand[ i ] + suffix ] =
          parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
      }

      return expanded;
    }
  };

  if ( !rmargin.test( prefix ) ) {
    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  }
});

jQuery.fn.extend({
  css: function( name, value ) {
    return access( this, function( elem, name, value ) {
      var styles, len,
        map = {},
        i = 0;

      if ( jQuery.isArray( name ) ) {
        styles = getStyles( elem );
        len = name.length;

        for ( ; i < len; i++ ) {
          map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
        }

        return map;
      }

      return value !== undefined ?
        jQuery.style( elem, name, value ) :
        jQuery.css( elem, name );
    }, name, value, arguments.length > 1 );
  },
  show: function() {
    return showHide( this, true );
  },
  hide: function() {
    return showHide( this );
  },
  toggle: function( state ) {
    if ( typeof state === "boolean" ) {
      return state ? this.show() : this.hide();
    }

    return this.each(function() {
      if ( isHidden( this ) ) {
        jQuery( this ).show();
      } else {
        jQuery( this ).hide();
      }
    });
  }
});


function Tween( elem, options, prop, end, easing ) {
  return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
  constructor: Tween,
  init: function( elem, options, prop, end, easing, unit ) {
    this.elem = elem;
    this.prop = prop;
    this.easing = easing || "swing";
    this.options = options;
    this.start = this.now = this.cur();
    this.end = end;
    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  },
  cur: function() {
    var hooks = Tween.propHooks[ this.prop ];

    return hooks && hooks.get ?
      hooks.get( this ) :
      Tween.propHooks._default.get( this );
  },
  run: function( percent ) {
    var eased,
      hooks = Tween.propHooks[ this.prop ];

    if ( this.options.duration ) {
      this.pos = eased = jQuery.easing[ this.easing ](
        percent, this.options.duration * percent, 0, 1, this.options.duration
      );
    } else {
      this.pos = eased = percent;
    }
    this.now = ( this.end - this.start ) * eased + this.start;

    if ( this.options.step ) {
      this.options.step.call( this.elem, this.now, this );
    }

    if ( hooks && hooks.set ) {
      hooks.set( this );
    } else {
      Tween.propHooks._default.set( this );
    }
    return this;
  }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
  _default: {
    get: function( tween ) {
      var result;

      if ( tween.elem[ tween.prop ] != null &&
        (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
        return tween.elem[ tween.prop ];
      }

      // Passing an empty string as a 3rd parameter to .css will automatically
      // attempt a parseFloat and fallback to a string if the parse fails.
      // Simple values such as "10px" are parsed to Float;
      // complex values such as "rotate(1rad)" are returned as-is.
      result = jQuery.css( tween.elem, tween.prop, "" );
      // Empty strings, null, undefined and "auto" are converted to 0.
      return !result || result === "auto" ? 0 : result;
    },
    set: function( tween ) {
      // Use step hook for back compat.
      // Use cssHook if its there.
      // Use .style if available and use plain properties where available.
      if ( jQuery.fx.step[ tween.prop ] ) {
        jQuery.fx.step[ tween.prop ]( tween );
      } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
        jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
      } else {
        tween.elem[ tween.prop ] = tween.now;
      }
    }
  }
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  set: function( tween ) {
    if ( tween.elem.nodeType && tween.elem.parentNode ) {
      tween.elem[ tween.prop ] = tween.now;
    }
  }
};

jQuery.easing = {
  linear: function( p ) {
    return p;
  },
  swing: function( p ) {
    return 0.5 - Math.cos( p * Math.PI ) / 2;
  }
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
  fxNow, timerId,
  rfxtypes = /^(?:toggle|show|hide)$/,
  rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
  rrun = /queueHooks$/,
  animationPrefilters = [ defaultPrefilter ],
  tweeners = {
    "*": [ function( prop, value ) {
      var tween = this.createTween( prop, value ),
        target = tween.cur(),
        parts = rfxnum.exec( value ),
        unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

        // Starting value computation is required for potential unit mismatches
        start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
          rfxnum.exec( jQuery.css( tween.elem, prop ) ),
        scale = 1,
        maxIterations = 20;

      if ( start && start[ 3 ] !== unit ) {
        // Trust units reported by jQuery.css
        unit = unit || start[ 3 ];

        // Make sure we update the tween properties later on
        parts = parts || [];

        // Iteratively approximate from a nonzero starting point
        start = +target || 1;

        do {
          // If previous iteration zeroed out, double until we get *something*.
          // Use string for doubling so we don't accidentally see scale as unchanged below
          scale = scale || ".5";

          // Adjust and apply
          start = start / scale;
          jQuery.style( tween.elem, prop, start + unit );

        // Update scale, tolerating zero or NaN from tween.cur(),
        // break the loop if scale is unchanged or perfect, or if we've just had enough
        } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
      }

      // Update tween properties
      if ( parts ) {
        start = tween.start = +start || +target || 0;
        tween.unit = unit;
        // If a +=/-= token was provided, we're doing a relative animation
        tween.end = parts[ 1 ] ?
          start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
          +parts[ 2 ];
      }

      return tween;
    } ]
  };

// Animations created synchronously will run synchronously
function createFxNow() {
  setTimeout(function() {
    fxNow = undefined;
  });
  return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
  var which,
    i = 0,
    attrs = { height: type };

  // If we include width, step value is 1 to do all cssExpand values,
  // otherwise step value is 2 to skip over Left and Right
  includeWidth = includeWidth ? 1 : 0;
  for ( ; i < 4 ; i += 2 - includeWidth ) {
    which = cssExpand[ i ];
    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  }

  if ( includeWidth ) {
    attrs.opacity = attrs.width = type;
  }

  return attrs;
}

function createTween( value, prop, animation ) {
  var tween,
    collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
    index = 0,
    length = collection.length;
  for ( ; index < length; index++ ) {
    if ( (tween = collection[ index ].call( animation, prop, value )) ) {

      // We're done with this property
      return tween;
    }
  }
}

function defaultPrefilter( elem, props, opts ) {
  /* jshint validthis: true */
  var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
    anim = this,
    orig = {},
    style = elem.style,
    hidden = elem.nodeType && isHidden( elem ),
    dataShow = data_priv.get( elem, "fxshow" );

  // Handle queue: false promises
  if ( !opts.queue ) {
    hooks = jQuery._queueHooks( elem, "fx" );
    if ( hooks.unqueued == null ) {
      hooks.unqueued = 0;
      oldfire = hooks.empty.fire;
      hooks.empty.fire = function() {
        if ( !hooks.unqueued ) {
          oldfire();
        }
      };
    }
    hooks.unqueued++;

    anim.always(function() {
      // Ensure the complete handler is called before this completes
      anim.always(function() {
        hooks.unqueued--;
        if ( !jQuery.queue( elem, "fx" ).length ) {
          hooks.empty.fire();
        }
      });
    });
  }

  // Height/width overflow pass
  if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
    // Make sure that nothing sneaks out
    // Record all 3 overflow attributes because IE9-10 do not
    // change the overflow attribute when overflowX and
    // overflowY are set to the same value
    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

    // Set display property to inline-block for height/width
    // animations on inline elements that are having width/height animated
    display = jQuery.css( elem, "display" );

    // Test default display if display is currently "none"
    checkDisplay = display === "none" ?
      data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

    if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
      style.display = "inline-block";
    }
  }

  if ( opts.overflow ) {
    style.overflow = "hidden";
    anim.always(function() {
      style.overflow = opts.overflow[ 0 ];
      style.overflowX = opts.overflow[ 1 ];
      style.overflowY = opts.overflow[ 2 ];
    });
  }

  // show/hide pass
  for ( prop in props ) {
    value = props[ prop ];
    if ( rfxtypes.exec( value ) ) {
      delete props[ prop ];
      toggle = toggle || value === "toggle";
      if ( value === ( hidden ? "hide" : "show" ) ) {

        // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
        if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
          hidden = true;
        } else {
          continue;
        }
      }
      orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

    // Any non-fx value stops us from restoring the original display value
    } else {
      display = undefined;
    }
  }

  if ( !jQuery.isEmptyObject( orig ) ) {
    if ( dataShow ) {
      if ( "hidden" in dataShow ) {
        hidden = dataShow.hidden;
      }
    } else {
      dataShow = data_priv.access( elem, "fxshow", {} );
    }

    // Store state if its toggle - enables .stop().toggle() to "reverse"
    if ( toggle ) {
      dataShow.hidden = !hidden;
    }
    if ( hidden ) {
      jQuery( elem ).show();
    } else {
      anim.done(function() {
        jQuery( elem ).hide();
      });
    }
    anim.done(function() {
      var prop;

      data_priv.remove( elem, "fxshow" );
      for ( prop in orig ) {
        jQuery.style( elem, prop, orig[ prop ] );
      }
    });
    for ( prop in orig ) {
      tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

      if ( !( prop in dataShow ) ) {
        dataShow[ prop ] = tween.start;
        if ( hidden ) {
          tween.end = tween.start;
          tween.start = prop === "width" || prop === "height" ? 1 : 0;
        }
      }
    }

  // If this is a noop like .hide().hide(), restore an overwritten display value
  } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
    style.display = display;
  }
}

function propFilter( props, specialEasing ) {
  var index, name, easing, value, hooks;

  // camelCase, specialEasing and expand cssHook pass
  for ( index in props ) {
    name = jQuery.camelCase( index );
    easing = specialEasing[ name ];
    value = props[ index ];
    if ( jQuery.isArray( value ) ) {
      easing = value[ 1 ];
      value = props[ index ] = value[ 0 ];
    }

    if ( index !== name ) {
      props[ name ] = value;
      delete props[ index ];
    }

    hooks = jQuery.cssHooks[ name ];
    if ( hooks && "expand" in hooks ) {
      value = hooks.expand( value );
      delete props[ name ];

      // Not quite $.extend, this won't overwrite existing keys.
      // Reusing 'index' because we have the correct "name"
      for ( index in value ) {
        if ( !( index in props ) ) {
          props[ index ] = value[ index ];
          specialEasing[ index ] = easing;
        }
      }
    } else {
      specialEasing[ name ] = easing;
    }
  }
}

function Animation( elem, properties, options ) {
  var result,
    stopped,
    index = 0,
    length = animationPrefilters.length,
    deferred = jQuery.Deferred().always( function() {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
    tick = function() {
      if ( stopped ) {
        return false;
      }
      var currentTime = fxNow || createFxNow(),
        remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
        // Support: Android 2.3
        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
        temp = remaining / animation.duration || 0,
        percent = 1 - temp,
        index = 0,
        length = animation.tweens.length;

      for ( ; index < length ; index++ ) {
        animation.tweens[ index ].run( percent );
      }

      deferred.notifyWith( elem, [ animation, percent, remaining ]);

      if ( percent < 1 && length ) {
        return remaining;
      } else {
        deferred.resolveWith( elem, [ animation ] );
        return false;
      }
    },
    animation = deferred.promise({
      elem: elem,
      props: jQuery.extend( {}, properties ),
      opts: jQuery.extend( true, { specialEasing: {} }, options ),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function( prop, end ) {
        var tween = jQuery.Tween( elem, animation.opts, prop, end,
            animation.opts.specialEasing[ prop ] || animation.opts.easing );
        animation.tweens.push( tween );
        return tween;
      },
      stop: function( gotoEnd ) {
        var index = 0,
          // If we are going to the end, we want to run all the tweens
          // otherwise we skip this part
          length = gotoEnd ? animation.tweens.length : 0;
        if ( stopped ) {
          return this;
        }
        stopped = true;
        for ( ; index < length ; index++ ) {
          animation.tweens[ index ].run( 1 );
        }

        // Resolve when we played the last frame; otherwise, reject
        if ( gotoEnd ) {
          deferred.resolveWith( elem, [ animation, gotoEnd ] );
        } else {
          deferred.rejectWith( elem, [ animation, gotoEnd ] );
        }
        return this;
      }
    }),
    props = animation.props;

  propFilter( props, animation.opts.specialEasing );

  for ( ; index < length ; index++ ) {
    result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
    if ( result ) {
      return result;
    }
  }

  jQuery.map( props, createTween, animation );

  if ( jQuery.isFunction( animation.opts.start ) ) {
    animation.opts.start.call( elem, animation );
  }

  jQuery.fx.timer(
    jQuery.extend( tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    })
  );

  // attach callbacks from options
  return animation.progress( animation.opts.progress )
    .done( animation.opts.done, animation.opts.complete )
    .fail( animation.opts.fail )
    .always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

  tweener: function( props, callback ) {
    if ( jQuery.isFunction( props ) ) {
      callback = props;
      props = [ "*" ];
    } else {
      props = props.split(" ");
    }

    var prop,
      index = 0,
      length = props.length;

    for ( ; index < length ; index++ ) {
      prop = props[ index ];
      tweeners[ prop ] = tweeners[ prop ] || [];
      tweeners[ prop ].unshift( callback );
    }
  },

  prefilter: function( callback, prepend ) {
    if ( prepend ) {
      animationPrefilters.unshift( callback );
    } else {
      animationPrefilters.push( callback );
    }
  }
});

jQuery.speed = function( speed, easing, fn ) {
  var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    complete: fn || !fn && easing ||
      jQuery.isFunction( speed ) && speed,
    duration: speed,
    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
  };

  opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
    opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

  // Normalize opt.queue - true/undefined/null -> "fx"
  if ( opt.queue == null || opt.queue === true ) {
    opt.queue = "fx";
  }

  // Queueing
  opt.old = opt.complete;

  opt.complete = function() {
    if ( jQuery.isFunction( opt.old ) ) {
      opt.old.call( this );
    }

    if ( opt.queue ) {
      jQuery.dequeue( this, opt.queue );
    }
  };

  return opt;
};

jQuery.fn.extend({
  fadeTo: function( speed, to, easing, callback ) {

    // Show any hidden elements after setting opacity to 0
    return this.filter( isHidden ).css( "opacity", 0 ).show()

      // Animate to the value specified
      .end().animate({ opacity: to }, speed, easing, callback );
  },
  animate: function( prop, speed, easing, callback ) {
    var empty = jQuery.isEmptyObject( prop ),
      optall = jQuery.speed( speed, easing, callback ),
      doAnimation = function() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation( this, jQuery.extend( {}, prop ), optall );

        // Empty animations, or finishing resolves immediately
        if ( empty || data_priv.get( this, "finish" ) ) {
          anim.stop( true );
        }
      };
      doAnimation.finish = doAnimation;

    return empty || optall.queue === false ?
      this.each( doAnimation ) :
      this.queue( optall.queue, doAnimation );
  },
  stop: function( type, clearQueue, gotoEnd ) {
    var stopQueue = function( hooks ) {
      var stop = hooks.stop;
      delete hooks.stop;
      stop( gotoEnd );
    };

    if ( typeof type !== "string" ) {
      gotoEnd = clearQueue;
      clearQueue = type;
      type = undefined;
    }
    if ( clearQueue && type !== false ) {
      this.queue( type || "fx", [] );
    }

    return this.each(function() {
      var dequeue = true,
        index = type != null && type + "queueHooks",
        timers = jQuery.timers,
        data = data_priv.get( this );

      if ( index ) {
        if ( data[ index ] && data[ index ].stop ) {
          stopQueue( data[ index ] );
        }
      } else {
        for ( index in data ) {
          if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
            stopQueue( data[ index ] );
          }
        }
      }

      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
          timers[ index ].anim.stop( gotoEnd );
          dequeue = false;
          timers.splice( index, 1 );
        }
      }

      // Start the next in the queue if the last step wasn't forced.
      // Timers currently will call their complete callbacks, which
      // will dequeue but only if they were gotoEnd.
      if ( dequeue || !gotoEnd ) {
        jQuery.dequeue( this, type );
      }
    });
  },
  finish: function( type ) {
    if ( type !== false ) {
      type = type || "fx";
    }
    return this.each(function() {
      var index,
        data = data_priv.get( this ),
        queue = data[ type + "queue" ],
        hooks = data[ type + "queueHooks" ],
        timers = jQuery.timers,
        length = queue ? queue.length : 0;

      // Enable finishing flag on private data
      data.finish = true;

      // Empty the queue first
      jQuery.queue( this, type, [] );

      if ( hooks && hooks.stop ) {
        hooks.stop.call( this, true );
      }

      // Look for any active animations, and finish them
      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
          timers[ index ].anim.stop( true );
          timers.splice( index, 1 );
        }
      }

      // Look for any animations in the old queue and finish them
      for ( index = 0; index < length; index++ ) {
        if ( queue[ index ] && queue[ index ].finish ) {
          queue[ index ].finish.call( this );
        }
      }

      // Turn off finishing flag
      delete data.finish;
    });
  }
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
  var cssFn = jQuery.fn[ name ];
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return speed == null || typeof speed === "boolean" ?
      cssFn.apply( this, arguments ) :
      this.animate( genFx( name, true ), speed, easing, callback );
  };
});

// Generate shortcuts for custom animations
jQuery.each({
  slideDown: genFx("show"),
  slideUp: genFx("hide"),
  slideToggle: genFx("toggle"),
  fadeIn: { opacity: "show" },
  fadeOut: { opacity: "hide" },
  fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return this.animate( props, speed, easing, callback );
  };
});

jQuery.timers = [];
jQuery.fx.tick = function() {
  var timer,
    i = 0,
    timers = jQuery.timers;

  fxNow = jQuery.now();

  for ( ; i < timers.length; i++ ) {
    timer = timers[ i ];
    // Checks the timer has not already been removed
    if ( !timer() && timers[ i ] === timer ) {
      timers.splice( i--, 1 );
    }
  }

  if ( !timers.length ) {
    jQuery.fx.stop();
  }
  fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
  jQuery.timers.push( timer );
  if ( timer() ) {
    jQuery.fx.start();
  } else {
    jQuery.timers.pop();
  }
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
  if ( !timerId ) {
    timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
  }
};

jQuery.fx.stop = function() {
  clearInterval( timerId );
  timerId = null;
};

jQuery.fx.speeds = {
  slow: 600,
  fast: 200,
  // Default speed
  _default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
  time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  type = type || "fx";

  return this.queue( type, function( next, hooks ) {
    var timeout = setTimeout( next, time );
    hooks.stop = function() {
      clearTimeout( timeout );
    };
  });
};


(function() {
  var input = document.createElement( "input" ),
    select = document.createElement( "select" ),
    opt = select.appendChild( document.createElement( "option" ) );

  input.type = "checkbox";

  // Support: iOS<=5.1, Android<=4.2+
  // Default value for a checkbox should be "on"
  support.checkOn = input.value !== "";

  // Support: IE<=11+
  // Must access selectedIndex to make default options select
  support.optSelected = opt.selected;

  // Support: Android<=2.3
  // Options inside disabled selects are incorrectly marked as disabled
  select.disabled = true;
  support.optDisabled = !opt.disabled;

  // Support: IE<=11+
  // An input loses its value after becoming a radio
  input = document.createElement( "input" );
  input.value = "t";
  input.type = "radio";
  support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
  attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
  attr: function( name, value ) {
    return access( this, jQuery.attr, name, value, arguments.length > 1 );
  },

  removeAttr: function( name ) {
    return this.each(function() {
      jQuery.removeAttr( this, name );
    });
  }
});

jQuery.extend({
  attr: function( elem, name, value ) {
    var hooks, ret,
      nType = elem.nodeType;

    // don't get/set attributes on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    // Fallback to prop when attributes are not supported
    if ( typeof elem.getAttribute === strundefined ) {
      return jQuery.prop( elem, name, value );
    }

    // All attributes are lowercase
    // Grab necessary hook if one is defined
    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
      name = name.toLowerCase();
      hooks = jQuery.attrHooks[ name ] ||
        ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
    }

    if ( value !== undefined ) {

      if ( value === null ) {
        jQuery.removeAttr( elem, name );

      } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        elem.setAttribute( name, value + "" );
        return value;
      }

    } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
      return ret;

    } else {
      ret = jQuery.find.attr( elem, name );

      // Non-existent attributes return null, we normalize to undefined
      return ret == null ?
        undefined :
        ret;
    }
  },

  removeAttr: function( elem, value ) {
    var name, propName,
      i = 0,
      attrNames = value && value.match( rnotwhite );

    if ( attrNames && elem.nodeType === 1 ) {
      while ( (name = attrNames[i++]) ) {
        propName = jQuery.propFix[ name ] || name;

        // Boolean attributes get special treatment (#10870)
        if ( jQuery.expr.match.bool.test( name ) ) {
          // Set corresponding property to false
          elem[ propName ] = false;
        }

        elem.removeAttribute( name );
      }
    }
  },

  attrHooks: {
    type: {
      set: function( elem, value ) {
        if ( !support.radioValue && value === "radio" &&
          jQuery.nodeName( elem, "input" ) ) {
          var val = elem.value;
          elem.setAttribute( "type", value );
          if ( val ) {
            elem.value = val;
          }
          return value;
        }
      }
    }
  }
});

// Hooks for boolean attributes
boolHook = {
  set: function( elem, value, name ) {
    if ( value === false ) {
      // Remove boolean attributes when set to false
      jQuery.removeAttr( elem, name );
    } else {
      elem.setAttribute( name, name );
    }
    return name;
  }
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
  var getter = attrHandle[ name ] || jQuery.find.attr;

  attrHandle[ name ] = function( elem, name, isXML ) {
    var ret, handle;
    if ( !isXML ) {
      // Avoid an infinite loop by temporarily removing this function from the getter
      handle = attrHandle[ name ];
      attrHandle[ name ] = ret;
      ret = getter( elem, name, isXML ) != null ?
        name.toLowerCase() :
        null;
      attrHandle[ name ] = handle;
    }
    return ret;
  };
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
  prop: function( name, value ) {
    return access( this, jQuery.prop, name, value, arguments.length > 1 );
  },

  removeProp: function( name ) {
    return this.each(function() {
      delete this[ jQuery.propFix[ name ] || name ];
    });
  }
});

jQuery.extend({
  propFix: {
    "for": "htmlFor",
    "class": "className"
  },

  prop: function( elem, name, value ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // Don't get/set properties on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    if ( notxml ) {
      // Fix name and attach hooks
      name = jQuery.propFix[ name ] || name;
      hooks = jQuery.propHooks[ name ];
    }

    if ( value !== undefined ) {
      return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
        ret :
        ( elem[ name ] = value );

    } else {
      return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
        ret :
        elem[ name ];
    }
  },

  propHooks: {
    tabIndex: {
      get: function( elem ) {
        return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
          elem.tabIndex :
          -1;
      }
    }
  }
});

if ( !support.optSelected ) {
  jQuery.propHooks.selected = {
    get: function( elem ) {
      var parent = elem.parentNode;
      if ( parent && parent.parentNode ) {
        parent.parentNode.selectedIndex;
      }
      return null;
    }
  };
}

jQuery.each([
  "tabIndex",
  "readOnly",
  "maxLength",
  "cellSpacing",
  "cellPadding",
  "rowSpan",
  "colSpan",
  "useMap",
  "frameBorder",
  "contentEditable"
], function() {
  jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
  addClass: function( value ) {
    var classes, elem, cur, clazz, j, finalValue,
      proceed = typeof value === "string" && value,
      i = 0,
      len = this.length;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).addClass( value.call( this, j, this.className ) );
      });
    }

    if ( proceed ) {
      // The disjunction here is for better compressibility (see removeClass)
      classes = ( value || "" ).match( rnotwhite ) || [];

      for ( ; i < len; i++ ) {
        elem = this[ i ];
        cur = elem.nodeType === 1 && ( elem.className ?
          ( " " + elem.className + " " ).replace( rclass, " " ) :
          " "
        );

        if ( cur ) {
          j = 0;
          while ( (clazz = classes[j++]) ) {
            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
              cur += clazz + " ";
            }
          }

          // only assign if different to avoid unneeded rendering.
          finalValue = jQuery.trim( cur );
          if ( elem.className !== finalValue ) {
            elem.className = finalValue;
          }
        }
      }
    }

    return this;
  },

  removeClass: function( value ) {
    var classes, elem, cur, clazz, j, finalValue,
      proceed = arguments.length === 0 || typeof value === "string" && value,
      i = 0,
      len = this.length;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).removeClass( value.call( this, j, this.className ) );
      });
    }
    if ( proceed ) {
      classes = ( value || "" ).match( rnotwhite ) || [];

      for ( ; i < len; i++ ) {
        elem = this[ i ];
        // This expression is here for better compressibility (see addClass)
        cur = elem.nodeType === 1 && ( elem.className ?
          ( " " + elem.className + " " ).replace( rclass, " " ) :
          ""
        );

        if ( cur ) {
          j = 0;
          while ( (clazz = classes[j++]) ) {
            // Remove *all* instances
            while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
              cur = cur.replace( " " + clazz + " ", " " );
            }
          }

          // Only assign if different to avoid unneeded rendering.
          finalValue = value ? jQuery.trim( cur ) : "";
          if ( elem.className !== finalValue ) {
            elem.className = finalValue;
          }
        }
      }
    }

    return this;
  },

  toggleClass: function( value, stateVal ) {
    var type = typeof value;

    if ( typeof stateVal === "boolean" && type === "string" ) {
      return stateVal ? this.addClass( value ) : this.removeClass( value );
    }

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( i ) {
        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
      });
    }

    return this.each(function() {
      if ( type === "string" ) {
        // Toggle individual class names
        var className,
          i = 0,
          self = jQuery( this ),
          classNames = value.match( rnotwhite ) || [];

        while ( (className = classNames[ i++ ]) ) {
          // Check each className given, space separated list
          if ( self.hasClass( className ) ) {
            self.removeClass( className );
          } else {
            self.addClass( className );
          }
        }

      // Toggle whole class name
      } else if ( type === strundefined || type === "boolean" ) {
        if ( this.className ) {
          // store className if set
          data_priv.set( this, "__className__", this.className );
        }

        // If the element has a class name or if we're passed `false`,
        // then remove the whole classname (if there was one, the above saved it).
        // Otherwise bring back whatever was previously saved (if anything),
        // falling back to the empty string if nothing was stored.
        this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
      }
    });
  },

  hasClass: function( selector ) {
    var className = " " + selector + " ",
      i = 0,
      l = this.length;
    for ( ; i < l; i++ ) {
      if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
        return true;
      }
    }

    return false;
  }
});




var rreturn = /\r/g;

jQuery.fn.extend({
  val: function( value ) {
    var hooks, ret, isFunction,
      elem = this[0];

    if ( !arguments.length ) {
      if ( elem ) {
        hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

        if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
          return ret;
        }

        ret = elem.value;

        return typeof ret === "string" ?
          // Handle most common string cases
          ret.replace(rreturn, "") :
          // Handle cases where value is null/undef or number
          ret == null ? "" : ret;
      }

      return;
    }

    isFunction = jQuery.isFunction( value );

    return this.each(function( i ) {
      var val;

      if ( this.nodeType !== 1 ) {
        return;
      }

      if ( isFunction ) {
        val = value.call( this, i, jQuery( this ).val() );
      } else {
        val = value;
      }

      // Treat null/undefined as ""; convert numbers to string
      if ( val == null ) {
        val = "";

      } else if ( typeof val === "number" ) {
        val += "";

      } else if ( jQuery.isArray( val ) ) {
        val = jQuery.map( val, function( value ) {
          return value == null ? "" : value + "";
        });
      }

      hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

      // If set returns undefined, fall back to normal setting
      if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
        this.value = val;
      }
    });
  }
});

jQuery.extend({
  valHooks: {
    option: {
      get: function( elem ) {
        var val = jQuery.find.attr( elem, "value" );
        return val != null ?
          val :
          // Support: IE10-11+
          // option.text throws exceptions (#14686, #14858)
          jQuery.trim( jQuery.text( elem ) );
      }
    },
    select: {
      get: function( elem ) {
        var value, option,
          options = elem.options,
          index = elem.selectedIndex,
          one = elem.type === "select-one" || index < 0,
          values = one ? null : [],
          max = one ? index + 1 : options.length,
          i = index < 0 ?
            max :
            one ? index : 0;

        // Loop through all the selected options
        for ( ; i < max; i++ ) {
          option = options[ i ];

          // IE6-9 doesn't update selected after form reset (#2551)
          if ( ( option.selected || i === index ) &&
              // Don't return options that are disabled or in a disabled optgroup
              ( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
              ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

            // Get the specific value for the option
            value = jQuery( option ).val();

            // We don't need an array for one selects
            if ( one ) {
              return value;
            }

            // Multi-Selects return an array
            values.push( value );
          }
        }

        return values;
      },

      set: function( elem, value ) {
        var optionSet, option,
          options = elem.options,
          values = jQuery.makeArray( value ),
          i = options.length;

        while ( i-- ) {
          option = options[ i ];
          if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
            optionSet = true;
          }
        }

        // Force browsers to behave consistently when non-matching value is set
        if ( !optionSet ) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  }
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
  jQuery.valHooks[ this ] = {
    set: function( elem, value ) {
      if ( jQuery.isArray( value ) ) {
        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
      }
    }
  };
  if ( !support.checkOn ) {
    jQuery.valHooks[ this ].get = function( elem ) {
      return elem.getAttribute("value") === null ? "on" : elem.value;
    };
  }
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

  // Handle event binding
  jQuery.fn[ name ] = function( data, fn ) {
    return arguments.length > 0 ?
      this.on( name, null, data, fn ) :
      this.trigger( name );
  };
});

jQuery.fn.extend({
  hover: function( fnOver, fnOut ) {
    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  },

  bind: function( types, data, fn ) {
    return this.on( types, null, data, fn );
  },
  unbind: function( types, fn ) {
    return this.off( types, null, fn );
  },

  delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
  },
  undelegate: function( selector, types, fn ) {
    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
  }
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
  return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
  var xml, tmp;
  if ( !data || typeof data !== "string" ) {
    return null;
  }

  // Support: IE9
  try {
    tmp = new DOMParser();
    xml = tmp.parseFromString( data, "text/xml" );
  } catch ( e ) {
    xml = undefined;
  }

  if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
    jQuery.error( "Invalid XML: " + data );
  }
  return xml;
};


var
  rhash = /#.*$/,
  rts = /([?&])_=[^&]*/,
  rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  rnoContent = /^(?:GET|HEAD)$/,
  rprotocol = /^\/\//,
  rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},

  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat( "*" ),

  // Document location
  ajaxLocation = window.location.href,

  // Segment location into parts
  ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

  // dataTypeExpression is optional and defaults to "*"
  return function( dataTypeExpression, func ) {

    if ( typeof dataTypeExpression !== "string" ) {
      func = dataTypeExpression;
      dataTypeExpression = "*";
    }

    var dataType,
      i = 0,
      dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

    if ( jQuery.isFunction( func ) ) {
      // For each dataType in the dataTypeExpression
      while ( (dataType = dataTypes[i++]) ) {
        // Prepend if requested
        if ( dataType[0] === "+" ) {
          dataType = dataType.slice( 1 ) || "*";
          (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

        // Otherwise append
        } else {
          (structure[ dataType ] = structure[ dataType ] || []).push( func );
        }
      }
    }
  };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  var inspected = {},
    seekingTransport = ( structure === transports );

  function inspect( dataType ) {
    var selected;
    inspected[ dataType ] = true;
    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
      var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
      if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
        options.dataTypes.unshift( dataTypeOrTransport );
        inspect( dataTypeOrTransport );
        return false;
      } else if ( seekingTransport ) {
        return !( selected = dataTypeOrTransport );
      }
    });
    return selected;
  }

  return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
  var key, deep,
    flatOptions = jQuery.ajaxSettings.flatOptions || {};

  for ( key in src ) {
    if ( src[ key ] !== undefined ) {
      ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
    }
  }
  if ( deep ) {
    jQuery.extend( true, target, deep );
  }

  return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

  var ct, type, finalDataType, firstDataType,
    contents = s.contents,
    dataTypes = s.dataTypes;

  // Remove auto dataType and get content-type in the process
  while ( dataTypes[ 0 ] === "*" ) {
    dataTypes.shift();
    if ( ct === undefined ) {
      ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
    }
  }

  // Check if we're dealing with a known content-type
  if ( ct ) {
    for ( type in contents ) {
      if ( contents[ type ] && contents[ type ].test( ct ) ) {
        dataTypes.unshift( type );
        break;
      }
    }
  }

  // Check to see if we have a response for the expected dataType
  if ( dataTypes[ 0 ] in responses ) {
    finalDataType = dataTypes[ 0 ];
  } else {
    // Try convertible dataTypes
    for ( type in responses ) {
      if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
        finalDataType = type;
        break;
      }
      if ( !firstDataType ) {
        firstDataType = type;
      }
    }
    // Or just use first one
    finalDataType = finalDataType || firstDataType;
  }

  // If we found a dataType
  // We add the dataType to the list if needed
  // and return the corresponding response
  if ( finalDataType ) {
    if ( finalDataType !== dataTypes[ 0 ] ) {
      dataTypes.unshift( finalDataType );
    }
    return responses[ finalDataType ];
  }
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
  var conv2, current, conv, tmp, prev,
    converters = {},
    // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice();

  // Create converters map with lowercased keys
  if ( dataTypes[ 1 ] ) {
    for ( conv in s.converters ) {
      converters[ conv.toLowerCase() ] = s.converters[ conv ];
    }
  }

  current = dataTypes.shift();

  // Convert to each sequential dataType
  while ( current ) {

    if ( s.responseFields[ current ] ) {
      jqXHR[ s.responseFields[ current ] ] = response;
    }

    // Apply the dataFilter if provided
    if ( !prev && isSuccess && s.dataFilter ) {
      response = s.dataFilter( response, s.dataType );
    }

    prev = current;
    current = dataTypes.shift();

    if ( current ) {

    // There's only work to do if current dataType is non-auto
      if ( current === "*" ) {

        current = prev;

      // Convert response if prev dataType is non-auto and differs from current
      } else if ( prev !== "*" && prev !== current ) {

        // Seek a direct converter
        conv = converters[ prev + " " + current ] || converters[ "* " + current ];

        // If none found, seek a pair
        if ( !conv ) {
          for ( conv2 in converters ) {

            // If conv2 outputs current
            tmp = conv2.split( " " );
            if ( tmp[ 1 ] === current ) {

              // If prev can be converted to accepted input
              conv = converters[ prev + " " + tmp[ 0 ] ] ||
                converters[ "* " + tmp[ 0 ] ];
              if ( conv ) {
                // Condense equivalence converters
                if ( conv === true ) {
                  conv = converters[ conv2 ];

                // Otherwise, insert the intermediate dataType
                } else if ( converters[ conv2 ] !== true ) {
                  current = tmp[ 0 ];
                  dataTypes.unshift( tmp[ 1 ] );
                }
                break;
              }
            }
          }
        }

        // Apply converter (if not an equivalence)
        if ( conv !== true ) {

          // Unless errors are allowed to bubble, catch and return them
          if ( conv && s[ "throws" ] ) {
            response = conv( response );
          } else {
            try {
              response = conv( response );
            } catch ( e ) {
              return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
            }
          }
        }
      }
    }
  }

  return { state: "success", data: response };
}

jQuery.extend({

  // Counter for holding the number of active queries
  active: 0,

  // Last-Modified header cache for next request
  lastModified: {},
  etag: {},

  ajaxSettings: {
    url: ajaxLocation,
    type: "GET",
    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
    global: true,
    processData: true,
    async: true,
    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
    /*
    timeout: 0,
    data: null,
    dataType: null,
    username: null,
    password: null,
    cache: null,
    throws: false,
    traditional: false,
    headers: {},
    */

    accepts: {
      "*": allTypes,
      text: "text/plain",
      html: "text/html",
      xml: "application/xml, text/xml",
      json: "application/json, text/javascript"
    },

    contents: {
      xml: /xml/,
      html: /html/,
      json: /json/
    },

    responseFields: {
      xml: "responseXML",
      text: "responseText",
      json: "responseJSON"
    },

    // Data converters
    // Keys separate source (or catchall "*") and destination types with a single space
    converters: {

      // Convert anything to text
      "* text": String,

      // Text to html (true = no transformation)
      "text html": true,

      // Evaluate text as a json expression
      "text json": jQuery.parseJSON,

      // Parse text as xml
      "text xml": jQuery.parseXML
    },

    // For options that shouldn't be deep extended:
    // you can add your own custom options here if
    // and when you create one that shouldn't be
    // deep extended (see ajaxExtend)
    flatOptions: {
      url: true,
      context: true
    }
  },

  // Creates a full fledged settings object into target
  // with both ajaxSettings and settings fields.
  // If target is omitted, writes into ajaxSettings.
  ajaxSetup: function( target, settings ) {
    return settings ?

      // Building a settings object
      ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

      // Extending ajaxSettings
      ajaxExtend( jQuery.ajaxSettings, target );
  },

  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  ajaxTransport: addToPrefiltersOrTransports( transports ),

  // Main method
  ajax: function( url, options ) {

    // If url is an object, simulate pre-1.5 signature
    if ( typeof url === "object" ) {
      options = url;
      url = undefined;
    }

    // Force options to be an object
    options = options || {};

    var transport,
      // URL without anti-cache param
      cacheURL,
      // Response headers
      responseHeadersString,
      responseHeaders,
      // timeout handle
      timeoutTimer,
      // Cross-domain detection vars
      parts,
      // To know if global events are to be dispatched
      fireGlobals,
      // Loop variable
      i,
      // Create the final options object
      s = jQuery.ajaxSetup( {}, options ),
      // Callbacks context
      callbackContext = s.context || s,
      // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
        jQuery( callbackContext ) :
        jQuery.event,
      // Deferreds
      deferred = jQuery.Deferred(),
      completeDeferred = jQuery.Callbacks("once memory"),
      // Status-dependent callbacks
      statusCode = s.statusCode || {},
      // Headers (they are sent all at once)
      requestHeaders = {},
      requestHeadersNames = {},
      // The jqXHR state
      state = 0,
      // Default abort message
      strAbort = "canceled",
      // Fake xhr
      jqXHR = {
        readyState: 0,

        // Builds headers hashtable if needed
        getResponseHeader: function( key ) {
          var match;
          if ( state === 2 ) {
            if ( !responseHeaders ) {
              responseHeaders = {};
              while ( (match = rheaders.exec( responseHeadersString )) ) {
                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
              }
            }
            match = responseHeaders[ key.toLowerCase() ];
          }
          return match == null ? null : match;
        },

        // Raw string
        getAllResponseHeaders: function() {
          return state === 2 ? responseHeadersString : null;
        },

        // Caches the header
        setRequestHeader: function( name, value ) {
          var lname = name.toLowerCase();
          if ( !state ) {
            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
            requestHeaders[ name ] = value;
          }
          return this;
        },

        // Overrides response content-type header
        overrideMimeType: function( type ) {
          if ( !state ) {
            s.mimeType = type;
          }
          return this;
        },

        // Status-dependent callbacks
        statusCode: function( map ) {
          var code;
          if ( map ) {
            if ( state < 2 ) {
              for ( code in map ) {
                // Lazy-add the new callback in a way that preserves old ones
                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
              }
            } else {
              // Execute the appropriate callbacks
              jqXHR.always( map[ jqXHR.status ] );
            }
          }
          return this;
        },

        // Cancel the request
        abort: function( statusText ) {
          var finalText = statusText || strAbort;
          if ( transport ) {
            transport.abort( finalText );
          }
          done( 0, finalText );
          return this;
        }
      };

    // Attach deferreds
    deferred.promise( jqXHR ).complete = completeDeferred.add;
    jqXHR.success = jqXHR.done;
    jqXHR.error = jqXHR.fail;

    // Remove hash character (#7531: and string promotion)
    // Add protocol if not provided (prefilters might expect it)
    // Handle falsy url in the settings object (#10093: consistency with old signature)
    // We also use the url parameter if available
    s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
      .replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

    // Alias method option to type as per ticket #12004
    s.type = options.method || options.type || s.method || s.type;

    // Extract dataTypes list
    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

    // A cross-domain request is in order when we have a protocol:host:port mismatch
    if ( s.crossDomain == null ) {
      parts = rurl.exec( s.url.toLowerCase() );
      s.crossDomain = !!( parts &&
        ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
          ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
      );
    }

    // Convert data if not already a string
    if ( s.data && s.processData && typeof s.data !== "string" ) {
      s.data = jQuery.param( s.data, s.traditional );
    }

    // Apply prefilters
    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    // If request was aborted inside a prefilter, stop there
    if ( state === 2 ) {
      return jqXHR;
    }

    // We can fire global events as of now if asked to
    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
    fireGlobals = jQuery.event && s.global;

    // Watch for a new set of requests
    if ( fireGlobals && jQuery.active++ === 0 ) {
      jQuery.event.trigger("ajaxStart");
    }

    // Uppercase the type
    s.type = s.type.toUpperCase();

    // Determine if request has content
    s.hasContent = !rnoContent.test( s.type );

    // Save the URL in case we're toying with the If-Modified-Since
    // and/or If-None-Match header later on
    cacheURL = s.url;

    // More options handling for requests with no content
    if ( !s.hasContent ) {

      // If data is available, append data to url
      if ( s.data ) {
        cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
        // #9682: remove data so that it's not used in an eventual retry
        delete s.data;
      }

      // Add anti-cache in url if needed
      if ( s.cache === false ) {
        s.url = rts.test( cacheURL ) ?

          // If there is already a '_' parameter, set its value
          cacheURL.replace( rts, "$1_=" + nonce++ ) :

          // Otherwise add one to the end
          cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
      }
    }

    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    if ( s.ifModified ) {
      if ( jQuery.lastModified[ cacheURL ] ) {
        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
      }
      if ( jQuery.etag[ cacheURL ] ) {
        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
      }
    }

    // Set the correct header, if data is being sent
    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
      jqXHR.setRequestHeader( "Content-Type", s.contentType );
    }

    // Set the Accepts header for the server, depending on the dataType
    jqXHR.setRequestHeader(
      "Accept",
      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
        s.accepts[ "*" ]
    );

    // Check for headers option
    for ( i in s.headers ) {
      jqXHR.setRequestHeader( i, s.headers[ i ] );
    }

    // Allow custom headers/mimetypes and early abort
    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
      // Abort if not done already and return
      return jqXHR.abort();
    }

    // Aborting is no longer a cancellation
    strAbort = "abort";

    // Install callbacks on deferreds
    for ( i in { success: 1, error: 1, complete: 1 } ) {
      jqXHR[ i ]( s[ i ] );
    }

    // Get transport
    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    // If no transport, we auto-abort
    if ( !transport ) {
      done( -1, "No Transport" );
    } else {
      jqXHR.readyState = 1;

      // Send global event
      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
      }
      // Timeout
      if ( s.async && s.timeout > 0 ) {
        timeoutTimer = setTimeout(function() {
          jqXHR.abort("timeout");
        }, s.timeout );
      }

      try {
        state = 1;
        transport.send( requestHeaders, done );
      } catch ( e ) {
        // Propagate exception as error if not done
        if ( state < 2 ) {
          done( -1, e );
        // Simply rethrow otherwise
        } else {
          throw e;
        }
      }
    }

    // Callback for when everything is done
    function done( status, nativeStatusText, responses, headers ) {
      var isSuccess, success, error, response, modified,
        statusText = nativeStatusText;

      // Called once
      if ( state === 2 ) {
        return;
      }

      // State is "done" now
      state = 2;

      // Clear timeout if it exists
      if ( timeoutTimer ) {
        clearTimeout( timeoutTimer );
      }

      // Dereference transport for early garbage collection
      // (no matter how long the jqXHR object will be used)
      transport = undefined;

      // Cache response headers
      responseHeadersString = headers || "";

      // Set readyState
      jqXHR.readyState = status > 0 ? 4 : 0;

      // Determine if successful
      isSuccess = status >= 200 && status < 300 || status === 304;

      // Get response data
      if ( responses ) {
        response = ajaxHandleResponses( s, jqXHR, responses );
      }

      // Convert no matter what (that way responseXXX fields are always set)
      response = ajaxConvert( s, response, jqXHR, isSuccess );

      // If successful, handle type chaining
      if ( isSuccess ) {

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
          modified = jqXHR.getResponseHeader("Last-Modified");
          if ( modified ) {
            jQuery.lastModified[ cacheURL ] = modified;
          }
          modified = jqXHR.getResponseHeader("etag");
          if ( modified ) {
            jQuery.etag[ cacheURL ] = modified;
          }
        }

        // if no content
        if ( status === 204 || s.type === "HEAD" ) {
          statusText = "nocontent";

        // if not modified
        } else if ( status === 304 ) {
          statusText = "notmodified";

        // If we have data, let's convert it
        } else {
          statusText = response.state;
          success = response.data;
          error = response.error;
          isSuccess = !error;
        }
      } else {
        // Extract error from statusText and normalize for non-aborts
        error = statusText;
        if ( status || !statusText ) {
          statusText = "error";
          if ( status < 0 ) {
            status = 0;
          }
        }
      }

      // Set data for the fake xhr object
      jqXHR.status = status;
      jqXHR.statusText = ( nativeStatusText || statusText ) + "";

      // Success/Error
      if ( isSuccess ) {
        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
      } else {
        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
      }

      // Status-dependent callbacks
      jqXHR.statusCode( statusCode );
      statusCode = undefined;

      if ( fireGlobals ) {
        globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
          [ jqXHR, s, isSuccess ? success : error ] );
      }

      // Complete
      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
        // Handle the global AJAX counter
        if ( !( --jQuery.active ) ) {
          jQuery.event.trigger("ajaxStop");
        }
      }
    }

    return jqXHR;
  },

  getJSON: function( url, data, callback ) {
    return jQuery.get( url, data, callback, "json" );
  },

  getScript: function( url, callback ) {
    return jQuery.get( url, undefined, callback, "script" );
  }
});

jQuery.each( [ "get", "post" ], function( i, method ) {
  jQuery[ method ] = function( url, data, callback, type ) {
    // Shift arguments if data argument was omitted
    if ( jQuery.isFunction( data ) ) {
      type = type || callback;
      callback = data;
      data = undefined;
    }

    return jQuery.ajax({
      url: url,
      type: method,
      dataType: type,
      data: data,
      success: callback
    });
  };
});


jQuery._evalUrl = function( url ) {
  return jQuery.ajax({
    url: url,
    type: "GET",
    dataType: "script",
    async: false,
    global: false,
    "throws": true
  });
};


jQuery.fn.extend({
  wrapAll: function( html ) {
    var wrap;

    if ( jQuery.isFunction( html ) ) {
      return this.each(function( i ) {
        jQuery( this ).wrapAll( html.call(this, i) );
      });
    }

    if ( this[ 0 ] ) {

      // The elements to wrap the target around
      wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

      if ( this[ 0 ].parentNode ) {
        wrap.insertBefore( this[ 0 ] );
      }

      wrap.map(function() {
        var elem = this;

        while ( elem.firstElementChild ) {
          elem = elem.firstElementChild;
        }

        return elem;
      }).append( this );
    }

    return this;
  },

  wrapInner: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function( i ) {
        jQuery( this ).wrapInner( html.call(this, i) );
      });
    }

    return this.each(function() {
      var self = jQuery( this ),
        contents = self.contents();

      if ( contents.length ) {
        contents.wrapAll( html );

      } else {
        self.append( html );
      }
    });
  },

  wrap: function( html ) {
    var isFunction = jQuery.isFunction( html );

    return this.each(function( i ) {
      jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
    });
  },

  unwrap: function() {
    return this.parent().each(function() {
      if ( !jQuery.nodeName( this, "body" ) ) {
        jQuery( this ).replaceWith( this.childNodes );
      }
    }).end();
  }
});


jQuery.expr.filters.hidden = function( elem ) {
  // Support: Opera <= 12.12
  // Opera reports offsetWidths and offsetHeights less than zero on some elements
  return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
  return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
  rbracket = /\[\]$/,
  rCRLF = /\r?\n/g,
  rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
  var name;

  if ( jQuery.isArray( obj ) ) {
    // Serialize array item.
    jQuery.each( obj, function( i, v ) {
      if ( traditional || rbracket.test( prefix ) ) {
        // Treat each array item as a scalar.
        add( prefix, v );

      } else {
        // Item is non-scalar (array or object), encode its numeric index.
        buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
      }
    });

  } else if ( !traditional && jQuery.type( obj ) === "object" ) {
    // Serialize object item.
    for ( name in obj ) {
      buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    }

  } else {
    // Serialize scalar item.
    add( prefix, obj );
  }
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
  var prefix,
    s = [],
    add = function( key, value ) {
      // If value is a function, invoke it and return its value
      value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
      s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
    };

  // Set traditional to true for jQuery <= 1.3.2 behavior.
  if ( traditional === undefined ) {
    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
  }

  // If an array was passed in, assume that it is an array of form elements.
  if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
    // Serialize the form elements
    jQuery.each( a, function() {
      add( this.name, this.value );
    });

  } else {
    // If traditional, encode the "old" way (the way 1.3.2 or older
    // did it), otherwise encode params recursively.
    for ( prefix in a ) {
      buildParams( prefix, a[ prefix ], traditional, add );
    }
  }

  // Return the resulting serialization
  return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
  serialize: function() {
    return jQuery.param( this.serializeArray() );
  },
  serializeArray: function() {
    return this.map(function() {
      // Can add propHook for "elements" to filter or add form elements
      var elements = jQuery.prop( this, "elements" );
      return elements ? jQuery.makeArray( elements ) : this;
    })
    .filter(function() {
      var type = this.type;

      // Use .is( ":disabled" ) so that fieldset[disabled] works
      return this.name && !jQuery( this ).is( ":disabled" ) &&
        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
        ( this.checked || !rcheckableType.test( type ) );
    })
    .map(function( i, elem ) {
      var val = jQuery( this ).val();

      return val == null ?
        null :
        jQuery.isArray( val ) ?
          jQuery.map( val, function( val ) {
            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          }) :
          { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    }).get();
  }
});


jQuery.ajaxSettings.xhr = function() {
  try {
    return new XMLHttpRequest();
  } catch( e ) {}
};

var xhrId = 0,
  xhrCallbacks = {},
  xhrSuccessStatus = {
    // file protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE9
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
  xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
  window.attachEvent( "onunload", function() {
    for ( var key in xhrCallbacks ) {
      xhrCallbacks[ key ]();
    }
  });
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
  var callback;

  // Cross domain only allowed if supported through XMLHttpRequest
  if ( support.cors || xhrSupported && !options.crossDomain ) {
    return {
      send: function( headers, complete ) {
        var i,
          xhr = options.xhr(),
          id = ++xhrId;

        xhr.open( options.type, options.url, options.async, options.username, options.password );

        // Apply custom fields if provided
        if ( options.xhrFields ) {
          for ( i in options.xhrFields ) {
            xhr[ i ] = options.xhrFields[ i ];
          }
        }

        // Override mime type if needed
        if ( options.mimeType && xhr.overrideMimeType ) {
          xhr.overrideMimeType( options.mimeType );
        }

        // X-Requested-With header
        // For cross-domain requests, seeing as conditions for a preflight are
        // akin to a jigsaw puzzle, we simply never set it to be sure.
        // (it can always be set on a per-request basis or even using ajaxSetup)
        // For same-domain requests, won't change header if already provided.
        if ( !options.crossDomain && !headers["X-Requested-With"] ) {
          headers["X-Requested-With"] = "XMLHttpRequest";
        }

        // Set headers
        for ( i in headers ) {
          xhr.setRequestHeader( i, headers[ i ] );
        }

        // Callback
        callback = function( type ) {
          return function() {
            if ( callback ) {
              delete xhrCallbacks[ id ];
              callback = xhr.onload = xhr.onerror = null;

              if ( type === "abort" ) {
                xhr.abort();
              } else if ( type === "error" ) {
                complete(
                  // file: protocol always yields status 0; see #8605, #14207
                  xhr.status,
                  xhr.statusText
                );
              } else {
                complete(
                  xhrSuccessStatus[ xhr.status ] || xhr.status,
                  xhr.statusText,
                  // Support: IE9
                  // Accessing binary-data responseText throws an exception
                  // (#11426)
                  typeof xhr.responseText === "string" ? {
                    text: xhr.responseText
                  } : undefined,
                  xhr.getAllResponseHeaders()
                );
              }
            }
          };
        };

        // Listen to events
        xhr.onload = callback();
        xhr.onerror = callback("error");

        // Create the abort callback
        callback = xhrCallbacks[ id ] = callback("abort");

        try {
          // Do send the request (this may raise an exception)
          xhr.send( options.hasContent && options.data || null );
        } catch ( e ) {
          // #14683: Only rethrow if this hasn't been notified as an error yet
          if ( callback ) {
            throw e;
          }
        }
      },

      abort: function() {
        if ( callback ) {
          callback();
        }
      }
    };
  }
});




// Install script dataType
jQuery.ajaxSetup({
  accepts: {
    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
  },
  contents: {
    script: /(?:java|ecma)script/
  },
  converters: {
    "text script": function( text ) {
      jQuery.globalEval( text );
      return text;
    }
  }
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
  if ( s.cache === undefined ) {
    s.cache = false;
  }
  if ( s.crossDomain ) {
    s.type = "GET";
  }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
  // This transport only deals with cross domain requests
  if ( s.crossDomain ) {
    var script, callback;
    return {
      send: function( _, complete ) {
        script = jQuery("<script>").prop({
          async: true,
          charset: s.scriptCharset,
          src: s.url
        }).on(
          "load error",
          callback = function( evt ) {
            script.remove();
            callback = null;
            if ( evt ) {
              complete( evt.type === "error" ? 404 : 200, evt.type );
            }
          }
        );
        document.head.appendChild( script[ 0 ] );
      },
      abort: function() {
        if ( callback ) {
          callback();
        }
      }
    };
  }
});




var oldCallbacks = [],
  rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
  jsonp: "callback",
  jsonpCallback: function() {
    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
    this[ callback ] = true;
    return callback;
  }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  var callbackName, overwritten, responseContainer,
    jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
      "url" :
      typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
    );

  // Handle iff the expected data type is "jsonp" or we have a parameter to set
  if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

    // Get callback name, remembering preexisting value associated with it
    callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
      s.jsonpCallback() :
      s.jsonpCallback;

    // Insert callback into url or form data
    if ( jsonProp ) {
      s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
    } else if ( s.jsonp !== false ) {
      s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
    }

    // Use data converter to retrieve json after script execution
    s.converters["script json"] = function() {
      if ( !responseContainer ) {
        jQuery.error( callbackName + " was not called" );
      }
      return responseContainer[ 0 ];
    };

    // force json dataType
    s.dataTypes[ 0 ] = "json";

    // Install callback
    overwritten = window[ callbackName ];
    window[ callbackName ] = function() {
      responseContainer = arguments;
    };

    // Clean-up function (fires after converters)
    jqXHR.always(function() {
      // Restore preexisting value
      window[ callbackName ] = overwritten;

      // Save back as free
      if ( s[ callbackName ] ) {
        // make sure that re-using the options doesn't screw things around
        s.jsonpCallback = originalSettings.jsonpCallback;

        // save the callback name for future use
        oldCallbacks.push( callbackName );
      }

      // Call if it was a function and we have a response
      if ( responseContainer && jQuery.isFunction( overwritten ) ) {
        overwritten( responseContainer[ 0 ] );
      }

      responseContainer = overwritten = undefined;
    });

    // Delegate to script
    return "script";
  }
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
  if ( !data || typeof data !== "string" ) {
    return null;
  }
  if ( typeof context === "boolean" ) {
    keepScripts = context;
    context = false;
  }
  context = context || document;

  var parsed = rsingleTag.exec( data ),
    scripts = !keepScripts && [];

  // Single tag
  if ( parsed ) {
    return [ context.createElement( parsed[1] ) ];
  }

  parsed = jQuery.buildFragment( [ data ], context, scripts );

  if ( scripts && scripts.length ) {
    jQuery( scripts ).remove();
  }

  return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
  if ( typeof url !== "string" && _load ) {
    return _load.apply( this, arguments );
  }

  var selector, type, response,
    self = this,
    off = url.indexOf(" ");

  if ( off >= 0 ) {
    selector = jQuery.trim( url.slice( off ) );
    url = url.slice( 0, off );
  }

  // If it's a function
  if ( jQuery.isFunction( params ) ) {

    // We assume that it's the callback
    callback = params;
    params = undefined;

  // Otherwise, build a param string
  } else if ( params && typeof params === "object" ) {
    type = "POST";
  }

  // If we have elements to modify, make the request
  if ( self.length > 0 ) {
    jQuery.ajax({
      url: url,

      // if "type" variable is undefined, then "GET" method will be used
      type: type,
      dataType: "html",
      data: params
    }).done(function( responseText ) {

      // Save response for use in complete callback
      response = arguments;

      self.html( selector ?

        // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

        // Otherwise use the full result
        responseText );

    }).complete( callback && function( jqXHR, status ) {
      self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
    });
  }

  return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
  jQuery.fn[ type ] = function( fn ) {
    return this.on( type, fn );
  };
});




jQuery.expr.filters.animated = function( elem ) {
  return jQuery.grep(jQuery.timers, function( fn ) {
    return elem === fn.elem;
  }).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
  return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
  setOffset: function( elem, options, i ) {
    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
      position = jQuery.css( elem, "position" ),
      curElem = jQuery( elem ),
      props = {};

    // Set position first, in-case top/left are set even on static elem
    if ( position === "static" ) {
      elem.style.position = "relative";
    }

    curOffset = curElem.offset();
    curCSSTop = jQuery.css( elem, "top" );
    curCSSLeft = jQuery.css( elem, "left" );
    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
      ( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

    // Need to be able to calculate position if either
    // top or left is auto and position is either absolute or fixed
    if ( calculatePosition ) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;

    } else {
      curTop = parseFloat( curCSSTop ) || 0;
      curLeft = parseFloat( curCSSLeft ) || 0;
    }

    if ( jQuery.isFunction( options ) ) {
      options = options.call( elem, i, curOffset );
    }

    if ( options.top != null ) {
      props.top = ( options.top - curOffset.top ) + curTop;
    }
    if ( options.left != null ) {
      props.left = ( options.left - curOffset.left ) + curLeft;
    }

    if ( "using" in options ) {
      options.using.call( elem, props );

    } else {
      curElem.css( props );
    }
  }
};

jQuery.fn.extend({
  offset: function( options ) {
    if ( arguments.length ) {
      return options === undefined ?
        this :
        this.each(function( i ) {
          jQuery.offset.setOffset( this, options, i );
        });
    }

    var docElem, win,
      elem = this[ 0 ],
      box = { top: 0, left: 0 },
      doc = elem && elem.ownerDocument;

    if ( !doc ) {
      return;
    }

    docElem = doc.documentElement;

    // Make sure it's not a disconnected DOM node
    if ( !jQuery.contains( docElem, elem ) ) {
      return box;
    }

    // Support: BlackBerry 5, iOS 3 (original iPhone)
    // If we don't have gBCR, just use 0,0 rather than error
    if ( typeof elem.getBoundingClientRect !== strundefined ) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow( doc );
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  },

  position: function() {
    if ( !this[ 0 ] ) {
      return;
    }

    var offsetParent, offset,
      elem = this[ 0 ],
      parentOffset = { top: 0, left: 0 };

    // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
    if ( jQuery.css( elem, "position" ) === "fixed" ) {
      // Assume getBoundingClientRect is there when computed position is fixed
      offset = elem.getBoundingClientRect();

    } else {
      // Get *real* offsetParent
      offsetParent = this.offsetParent();

      // Get correct offsets
      offset = this.offset();
      if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
        parentOffset = offsetParent.offset();
      }

      // Add offsetParent borders
      parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
      parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
    }

    // Subtract parent offsets and element margins
    return {
      top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
      left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
    };
  },

  offsetParent: function() {
    return this.map(function() {
      var offsetParent = this.offsetParent || docElem;

      while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
        offsetParent = offsetParent.offsetParent;
      }

      return offsetParent || docElem;
    });
  }
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  var top = "pageYOffset" === prop;

  jQuery.fn[ method ] = function( val ) {
    return access( this, function( elem, method, val ) {
      var win = getWindow( elem );

      if ( val === undefined ) {
        return win ? win[ prop ] : elem[ method ];
      }

      if ( win ) {
        win.scrollTo(
          !top ? val : window.pageXOffset,
          top ? val : window.pageYOffset
        );

      } else {
        elem[ method ] = val;
      }
    }, method, val, arguments.length, null );
  };
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
  jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
    function( elem, computed ) {
      if ( computed ) {
        computed = curCSS( elem, prop );
        // If curCSS returns percentage, fallback to offset
        return rnumnonpx.test( computed ) ?
          jQuery( elem ).position()[ prop ] + "px" :
          computed;
      }
    }
  );
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
    // Margin is only for outerHeight, outerWidth
    jQuery.fn[ funcName ] = function( margin, value ) {
      var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

      return access( this, function( elem, type, value ) {
        var doc;

        if ( jQuery.isWindow( elem ) ) {
          // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
          // isn't a whole lot we can do. See pull request at this URL for discussion:
          // https://github.com/jquery/jquery/pull/764
          return elem.document.documentElement[ "client" + name ];
        }

        // Get document width or height
        if ( elem.nodeType === 9 ) {
          doc = elem.documentElement;

          // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
          // whichever is greatest
          return Math.max(
            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
            elem.body[ "offset" + name ], doc[ "offset" + name ],
            doc[ "client" + name ]
          );
        }

        return value === undefined ?
          // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css( elem, type, extra ) :

          // Set width or height on the element
          jQuery.style( elem, type, value, extra );
      }, type, chainable ? margin : undefined, chainable, null );
    };
  });
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
  return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
  define( "jquery", [], function() {
    return jQuery;
  });
}




var
  // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,

  // Map over the $ in case of overwrite
  _$ = window.$;

jQuery.noConflict = function( deep ) {
  if ( window.$ === jQuery ) {
    window.$ = _$;
  }

  if ( deep && window.jQuery === jQuery ) {
    window.jQuery = _jQuery;
  }

  return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
  window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  //use the faster Date.now if available.
  var getTime = (Date.now || function() {
    return new Date().getTime();
  });

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = value == null ? _.identity : lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : getTime();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = getTime();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = getTime();
      var later = function() {
        var last = getTime() - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

//vjs.Component.prototype.dispose
// 为了减少体积，移除了字幕组件
// 修改了一处代码:line to 1630
/**
 * @fileoverview Main function src.
 */

// HTML5 Shiv. Must be in <head> to support older browsers.
document.createElement('video');
document.createElement('audio');
//document.createElement('track');

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 *
 * **ALIASES** videojs, _V_ (deprecated)
 *
 * The `vjs` function can be used to initialize or retrieve a player.
 *
 *     var myPlayer = vjs('my_video_id');
 *
 * @param  {String|Element} id      Video element or video element ID
 * @param  {Object=} options        Optional options object for config/settings
 * @param  {Function=} ready        Optional ready callback
 * @return {vjs.Player}             A player instance
 * @namespace
 */
var vjs = function(id, options, ready){
  var tag; // Element of ID

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (vjs.players[id]) {
      return vjs.players[id];

    // Otherwise get element for ID
    } else {
      tag = vjs.el(id);
    }

  // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  if (!tag || !tag.nodeName) { // re: nodeName, could be a box div also
    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
  }

  // Element may have a player attr referring to an already created player instance.
  // If not, set up a new player and return the instance.
  return tag['player'] || new vjs.Player(tag, options, ready);
};

// Extended name, also available externally, window.videojs
var videojs = window['videojs'] = vjs;

// CDN Version. Used to target right flash swf.
vjs.CDN_VERSION = '4.10';
vjs.ACCESS_PROTOCOL = ('https:' == document.location.protocol ? 'https://' : 'http://');

/**
 * Global Player instance options, surfaced from vjs.Player.prototype.options_
 * vjs.options = vjs.Player.prototype.options_
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 */
vjs.options = {
  // Default order of fallback technology
  'techOrder': ['html5','flash'],
  // techOrder: ['flash','html5'],

  'html5': {},
  'flash': {},

  // Default of web browser is 300x150. Should rely on source width/height.
  'width': 300,
  'height': 150,
  // defaultVolume: 0.85,
  'defaultVolume': 0.00, // The freakin seaguls are driving me crazy!

  // default playback rates
  //'playbackRates': [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // default inactivity timeout
  'inactivityTimeout': 2000,

  // Included control sets
  'children': {
    'mediaLoader': {},
    'loadingSpinner': {},
    'controlBar': {},
    'errorDisplay': {}
  },

  'language': document.getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

  // locales and their language translations
  'languages': {},

  // Default message to show when a video cannot be played.
  'notSupportedMessage': 'No compatible source was found for this video.'
};

// Set CDN Version of swf
// The added (+) blocks the replace from changing this 4.10 string
if (vjs.CDN_VERSION !== 'GENERATED'+'_CDN_VSN') {
  videojs.options['flash']['swf'] = vjs.ACCESS_PROTOCOL + 'vjs.zencdn.net/'+vjs.CDN_VERSION+'/video-js.swf';
}

/**
 * Utility function for adding languages to the default options. Useful for
 * amending multiple language support at runtime.
 *
 * Example: vjs.addLanguage('es', {'Hello':'Hola'});
 *
 * @param  {String} code The language code or dictionary property
 * @param  {Object} data The data values to be translated
 * @return {Object} The resulting global languages dictionary object
 */
vjs.addLanguage = function(code, data){
  if(vjs.options['languages'][code] !== undefined) {
    vjs.options['languages'][code] = vjs.util.mergeOptions(vjs.options['languages'][code], data);
  } else {
    vjs.options['languages'][code] = data;
  }
  return vjs.options['languages'];
};

/**
 * Global player list
 * @type {Object}
 */
vjs.players = {};

/**
 * Core Object/Class for objects that use inheritance + contstructors
 *
 * To create a class that can be subclassed itself, extend the CoreObject class.
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * The constructor can be defined through the init property of an object argument.
 *
 *     var Animal = CoreObject.extend({
 *       init: function(name, sound){
 *         this.name = name;
 *       }
 *     });
 *
 * Other methods and properties can be added the same way, or directly to the
 * prototype.
 *
 *    var Animal = CoreObject.extend({
 *       init: function(name){
 *         this.name = name;
 *       },
 *       getName: function(){
 *         return this.name;
 *       },
 *       sound: '...'
 *    });
 *
 *    Animal.prototype.makeSound = function(){
 *      alert(this.sound);
 *    };
 *
 * To create an instance of a class, use the create method.
 *
 *    var fluffy = Animal.create('Fluffy');
 *    fluffy.getName(); // -> Fluffy
 *
 * Methods and properties can be overridden in subclasses.
 *
 *     var Horse = Animal.extend({
 *       sound: 'Neighhhhh!'
 *     });
 *
 *     var horsey = Horse.create('Horsey');
 *     horsey.getName(); // -> Horsey
 *     horsey.makeSound(); // -> Alert: Neighhhhh!
 *
 * @class
 * @constructor
 */
vjs.CoreObject = vjs['CoreObject'] = function(){};
// Manually exporting vjs['CoreObject'] here for Closure Compiler
// because of the use of the extend/create class methods
// If we didn't do this, those functions would get flattend to something like
// `a = ...` and `this.prototype` would refer to the global object instead of
// CoreObject

/**
 * Create a new object that inherits from this Object
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * @param {Object} props Functions and properties to be applied to the
 *                       new object's prototype
 * @return {vjs.CoreObject} An object that inherits from CoreObject
 * @this {*}
 */
vjs.CoreObject.extend = function(props){
  var init, subObj;

  props = props || {};
  // Set up the constructor using the supplied init method
  // or using the init of the parent object
  // Make sure to check the unobfuscated version for external libs
  init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function(){};
  // In Resig's simple class inheritance (previously used) the constructor
  //  is a function that calls `this.init.apply(arguments)`
  // However that would prevent us from using `ParentObject.call(this);`
  //  in a Child constuctor because the `this` in `this.init`
  //  would still refer to the Child and cause an inifinite loop.
  // We would instead have to do
  //    `ParentObject.prototype.init.apply(this, argumnents);`
  //  Bleh. We're not creating a _super() function, so it's good to keep
  //  the parent constructor reference simple.
  subObj = function(){
    init.apply(this, arguments);
  };

  // Inherit from this object's prototype
  subObj.prototype = vjs.obj.create(this.prototype);
  // Reset the constructor property for subObj otherwise
  // instances of subObj would have the constructor of the parent Object
  subObj.prototype.constructor = subObj;

  // Make the class extendable
  subObj.extend = vjs.CoreObject.extend;
  // Make a function for creating instances
  subObj.create = vjs.CoreObject.create;

  // Extend subObj's prototype with functions and other properties from props
  for (var name in props) {
    if (props.hasOwnProperty(name)) {
      subObj.prototype[name] = props[name];
    }
  }

  return subObj;
};

/**
 * Create a new instace of this Object class
 *
 *     var myAnimal = Animal.create();
 *
 * @return {vjs.CoreObject} An instance of a CoreObject subclass
 * @this {*}
 */
vjs.CoreObject.create = function(){
  // Create a new object that inherits from this object's prototype
  var inst = vjs.obj.create(this.prototype);

  // Apply this constructor function to the new object
  this.apply(inst, arguments);

  // Return the new object
  return inst;
};
/**
 * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 */

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 * @param  {Element|Object}   elem Element or object to bind listeners to
 * @param  {String|Array}   type Type of event to bind to.
 * @param  {Function} fn   Event listener.
 * @private
 */
vjs.on = function(elem, type, fn){
  if (vjs.obj.isArray(type)) {
    return _handleMultipleEvents(vjs.on, elem, type, fn);
  }

  var data = vjs.getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) data.handlers = {};

  if (!data.handlers[type]) data.handlers[type] = [];

  if (!fn.guid) fn.guid = vjs.guid++;

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event){

      if (data.disabled) return;
      event = vjs.fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            handlersCopy[m].call(elem, event);
          }
        }
      }
    };
  }

  if (data.handlers[type].length == 1) {
    if (elem.addEventListener) {
      elem.addEventListener(type, data.dispatcher, false);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
};

/**
 * Removes event listeners from an element
 * @param  {Element|Object}   elem Object to remove listeners from
 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
 * @private
 */
vjs.off = function(elem, type, fn) {
  // Don't want to add a cache object through getData if not needed
  if (!vjs.hasData(elem)) return;

  var data = vjs.getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) { return; }

  if (vjs.obj.isArray(type)) {
    return _handleMultipleEvents(vjs.off, elem, type, fn);
  }

  // Utility function
  var removeType = function(t){
     data.handlers[t] = [];
     vjs.cleanUpEvents(elem,t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) removeType(t);
    return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) return;

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  vjs.cleanUpEvents(elem, type);
};

/**
 * Clean up the listener cache and dispatchers
 * @param  {Element|Object} elem Element to clean up
 * @param  {String} type Type of event to clean up
 * @private
 */
vjs.cleanUpEvents = function(elem, type) {
  var data = vjs.getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (vjs.isEmpty(data.handlers)) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;

    // data.handlers = null;
    // data.dispatcher = null;
    // data.disabled = null;
  }

  // Finally remove the expando if there is no data left
  if (vjs.isEmpty(data)) {
    vjs.removeData(elem);
  }
};

/**
 * Fix a native event to have standard property values
 * @param  {Object} event Event object to fix
 * @return {Object}
 * @private
 */
vjs.fixEvent = function(event) {

  function returnTrue() { return true; }
  function returnFalse() { return false; }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || window.event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key == 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document;
    }

    // Handle which other element the event is related to
    event.relatedTarget = event.fromElement === event.target ?
      event.toElement :
      event.fromElement;

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      event.isDefaultPrevented = returnTrue;
      event.defaultPrevented = true;
    };

    event.isDefaultPrevented = returnFalse;
    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX != null) {
      var doc = document.documentElement, body = document.body;

      event.pageX = event.clientX +
        (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
        (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY +
        (doc && doc.scrollTop || body && body.scrollTop || 0) -
        (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button != null) {
      event.button = (event.button & 1 ? 0 :
        (event.button & 4 ? 1 :
          (event.button & 2 ? 2 : 0)));
    }
  }

  // Returns fixed-up instance
  return event;
};

/**
 * Trigger an event for an element
 * @param  {Element|Object}      elem  Element to trigger an event on
 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
 * @private
 */
vjs.trigger = function(elem, event) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasData first.
  var elemData = (vjs.hasData(elem)) ? vjs.getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
      // type = event.type || event,
      // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type:event, target:elem };
  }
  // Normalizes the event properties.
  event = vjs.fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
    // recursively calls this function to bubble the event up the DOM.
    if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
    vjs.trigger(parent, event);

  // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = vjs.getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
  /* Original version of js ninja events wasn't complete.
   * We've since updated to the latest version, but keeping this around
   * for now just in case.
   */
  // // Added in attion to book. Book code was broke.
  // event = typeof event === 'object' ?
  //   event[vjs.expando] ?
  //     event :
  //     new vjs.Event(type, event) :
  //   new vjs.Event(type);

  // event.type = type;
  // if (handler) {
  //   handler.call(elem, event);
  // }

  // // Clean up the event in case it is being reused
  // event.result = undefined;
  // event.target = elem;
};

/**
 * Trigger a listener only once for an event
 * @param  {Element|Object}   elem Element or object to
 * @param  {String|Array}   type
 * @param  {Function} fn
 * @private
 */
vjs.one = function(elem, type, fn) {
  if (vjs.obj.isArray(type)) {
    return _handleMultipleEvents(vjs.one, elem, type, fn);
  }
  var func = function(){
    vjs.off(elem, type, func);
    fn.apply(this, arguments);
  };
  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || vjs.guid++;
  vjs.on(elem, type, func);
};

/**
 * Loops through an array of event types and calls the requested method for each type.
 * @param  {Function} fn   The event method we want to use.
 * @param  {Element|Object} elem Element or object to bind listeners to
 * @param  {String}   type Type of event to bind to.
 * @param  {Function} callback   Event listener.
 * @private
 */
function _handleMultipleEvents(fn, elem, type, callback) {
  vjs.arr.forEach(type, function(type) {
    fn(elem, type, callback); //Call the event method for each one of the types
  });
}
var hasOwnProp = Object.prototype.hasOwnProperty;

/**
 * Creates an element and applies properties.
 * @param  {String=} tagName    Name of tag to be created.
 * @param  {Object=} properties Element properties to be applied.
 * @return {Element}
 * @private
 */
vjs.createEl = function(tagName, properties){
  var el;

  tagName = tagName || 'div';
  properties = properties || {};

  el = document.createElement(tagName);

  vjs.obj.each(properties, function(propName, val){
    // Not remembering why we were checking for dash
    // but using setAttribute means you have to use getAttribute

    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
    // The additional check for "role" is because the default method for adding attributes does not
    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
    if (propName.indexOf('aria-') !== -1 || propName == 'role') {
     el.setAttribute(propName, val);
    } else {
     el[propName] = val;
    }
  });

  return el;
};

/**
 * Uppercase the first letter of a string
 * @param  {String} string String to be uppercased
 * @return {String}
 * @private
 */
vjs.capitalize = function(string){
  return string.charAt(0).toUpperCase() + string.slice(1);
};

/**
 * Object functions container
 * @type {Object}
 * @private
 */
vjs.obj = {};

/**
 * Object.create shim for prototypal inheritance
 *
 * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
 *
 * @function
 * @param  {Object}   obj Object to use as prototype
 * @private
 */
vjs.obj.create = Object.create || function(obj){
  //Create a new function called 'F' which is just an empty object.
  function F() {}

  //the prototype of the 'F' function should point to the
  //parameter of the anonymous function.
  F.prototype = obj;

  //create a new constructor function based off of the 'F' function.
  return new F();
};

/**
 * Loop through each property in an object and call a function
 * whose arguments are (key,value)
 * @param  {Object}   obj Object of properties
 * @param  {Function} fn  Function to be called on each property.
 * @this {*}
 * @private
 */
vjs.obj.each = function(obj, fn, context){
  for (var key in obj) {
    if (hasOwnProp.call(obj, key)) {
      fn.call(context || this, key, obj[key]);
    }
  }
};

/**
 * Merge two objects together and return the original.
 * @param  {Object} obj1
 * @param  {Object} obj2
 * @return {Object}
 * @private
 */
vjs.obj.merge = function(obj1, obj2){
  if (!obj2) { return obj1; }
  for (var key in obj2){
    if (hasOwnProp.call(obj2, key)) {
      obj1[key] = obj2[key];
    }
  }
  return obj1;
};

/**
 * Merge two objects, and merge any properties that are objects
 * instead of just overwriting one. Uses to merge options hashes
 * where deeper default settings are important.
 * @param  {Object} obj1 Object to override
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object. Obj1 and Obj2 will be untouched.
 * @private
 */
vjs.obj.deepMerge = function(obj1, obj2){
  var key, val1, val2;

  // make a copy of obj1 so we're not ovewriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = vjs.obj.copy(obj1);

  for (key in obj2){
    if (hasOwnProp.call(obj2, key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
        obj1[key] = vjs.obj.deepMerge(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
};

/**
 * Make a copy of the supplied object
 * @param  {Object} obj Object to copy
 * @return {Object}     Copy of object
 * @private
 */
vjs.obj.copy = function(obj){
  return vjs.obj.merge({}, obj);
};

/**
 * Check if an object is plain, and not a dom node or any object sub-instance
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
vjs.obj.isPlain = function(obj){
  return !!obj
    && typeof obj === 'object'
    && obj.toString() === '[object Object]'
    && obj.constructor === Object;
};

/**
 * Check if an object is Array
*  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
vjs.obj.isArray = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
};

/**
 * Check to see whether the input is NaN or not.
 * NaN is the only JavaScript construct that isn't equal to itself
 * @param {Number} num Number to check
 * @return {Boolean} True if NaN, false otherwise
 * @private
 */
vjs.isNaN = function(num) {
  return num !== num;
};

/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
   It also stores a unique id on the function so it can be easily removed from events
 * @param  {*}   context The object to bind as scope
 * @param  {Function} fn      The function to be bound to a scope
 * @param  {Number=}   uid     An optional unique ID for the function to be set
 * @return {Function}
 * @private
 */
vjs.bind = function(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) { fn.guid = vjs.guid++; }

  // Create the new function that changes the context
  var ret = function() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  ret.guid = (uid) ? uid + '_' + fn.guid : fn.guid;

  return ret;
};

/**
 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
 * Ex. Event listneres are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 * @type {Object}
 * @private
 */
vjs.cache = {};

/**
 * Unique ID for an element or function
 * @type {Number}
 * @private
 */
vjs.guid = 1;

/**
 * Unique attribute name to store an element's guid in
 * @type {String}
 * @constant
 * @private
 */
vjs.expando = 'vdata' + (new Date()).getTime();

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
vjs.getData = function(el){
  var id = el[vjs.expando];
  if (!id) {
    id = el[vjs.expando] = vjs.guid++;
    vjs.cache[id] = {};
  }
  return vjs.cache[id];
};

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
vjs.hasData = function(el){
  var id = el[vjs.expando];
  return !(!id || vjs.isEmpty(vjs.cache[id]));
};

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 * @param  {Element} el Remove data for an element
 * @private
 */
vjs.removeData = function(el){
  var id = el[vjs.expando];
  if (!id) { return; }
  // Remove all stored data
  // Changed to = null
  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
  // vjs.cache[id] = null;
  delete vjs.cache[id];

  // Remove the expando property from the DOM node
  try {
    delete el[vjs.expando];
  } catch(e) {
    if (el.removeAttribute) {
      el.removeAttribute(vjs.expando);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[vjs.expando] = null;
    }
  }
};

/**
 * Check if an object is empty
 * @param  {Object}  obj The object to check for emptiness
 * @return {Boolean}
 * @private
 */
vjs.isEmpty = function(obj) {
  for (var prop in obj) {
    // Inlude null properties as empty.
    if (obj[prop] !== null) {
      return false;
    }
  }
  return true;
};

/**
 * Check if an element has a CSS class
 * @param {Element} element Element to check
 * @param {String} classToCheck Classname to check
 * @private
 */
vjs.hasClass = function(element, classToCheck){
  return ((' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1);
};


/**
 * Add a CSS class name to an element
 * @param {Element} element    Element to add class name to
 * @param {String} classToAdd Classname to add
 * @private
 */
vjs.addClass = function(element, classToAdd){
  if (!vjs.hasClass(element, classToAdd)) {
    element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
  }
};

/**
 * Remove a CSS class name from an element
 * @param {Element} element    Element to remove from class name
 * @param {String} classToAdd Classname to remove
 * @private
 */
vjs.removeClass = function(element, classToRemove){
  var classNames, i;

  if (!vjs.hasClass(element, classToRemove)) {return;}

  classNames = element.className.split(' ');

  // no arr.indexOf in ie8, and we don't want to add a big shim
  for (i = classNames.length - 1; i >= 0; i--) {
    if (classNames[i] === classToRemove) {
      classNames.splice(i,1);
    }
  }

  element.className = classNames.join(' ');
};

/**
 * Element for testing browser HTML5 video capabilities
 * @type {Element}
 * @constant
 * @private
 */
vjs.TEST_VID = vjs.createEl('video');

/**
 * Useragent for browser testing.
 * @type {String}
 * @constant
 * @private
 */
vjs.USER_AGENT = navigator.userAgent;

/**
 * Device is an iPhone
 * @type {Boolean}
 * @constant
 * @private
 */
vjs.IS_IPHONE = (/iPhone/i).test(vjs.USER_AGENT);
vjs.IS_IPAD = (/iPad/i).test(vjs.USER_AGENT);
vjs.IS_IPOD = (/iPod/i).test(vjs.USER_AGENT);
vjs.IS_IOS = vjs.IS_IPHONE || vjs.IS_IPAD || vjs.IS_IPOD;

vjs.IOS_VERSION = (function(){
  var match = vjs.USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) { return match[1]; }
})();

vjs.IS_ANDROID = (/Android/i).test(vjs.USER_AGENT);
vjs.ANDROID_VERSION = (function() {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = vjs.USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
    major,
    minor;

  if (!match) {
    return null;
  }

  major = match[1] && parseFloat(match[1]);
  minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  } else {
    return null;
  }
})();
// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
vjs.IS_OLD_ANDROID = vjs.IS_ANDROID && (/webkit/i).test(vjs.USER_AGENT) && vjs.ANDROID_VERSION < 2.3;

vjs.IS_FIREFOX = (/Firefox/i).test(vjs.USER_AGENT);
vjs.IS_CHROME = (/Chrome/i).test(vjs.USER_AGENT);

vjs.TOUCH_ENABLED = !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch);
vjs.BACKGROUND_SIZE_SUPPORTED = 'backgroundSize' in vjs.TEST_VID.style;

/**
 * Apply attributes to an HTML element.
 * @param  {Element} el         Target element.
 * @param  {Object=} attributes Element attributes to be applied.
 * @private
 */
vjs.setElementAttributes = function(el, attributes){
  vjs.obj.each(attributes, function(attrName, attrValue) {
    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, (attrValue === true ? '' : attrValue));
    }
  });
};

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributs are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 * @param  {Element} tag Element from which to get tag attributes
 * @return {Object}
 * @private
 */
vjs.getElementAttributes = function(tag){
  var obj, knownBooleans, attrs, attrName, attrVal;

  obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  knownBooleans = ','+'autoplay,controls,loop,muted,default'+',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      attrName = attrs[i].name;
      attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(','+attrName+',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = (attrVal !== null) ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
};

/**
 * Get the computed style value for an element
 * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
 * @param  {Element} el        Element to get style value for
 * @param  {String} strCssRule Style name
 * @return {String}            Style value
 * @private
 */
vjs.getComputedDimension = function(el, strCssRule){
  var strValue = '';
  if(document.defaultView && document.defaultView.getComputedStyle){
    strValue = document.defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);

  } else if(el.currentStyle){
    // IE8 Width/Height support
    strValue = el['client'+strCssRule.substr(0,1).toUpperCase() + strCssRule.substr(1)] + 'px';
  }
  return strValue;
};

/**
 * Insert an element as the first child node of another
 * @param  {Element} child   Element to insert
 * @param  {[type]} parent Element to insert child into
 * @private
 */
vjs.insertFirst = function(child, parent){
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
};

/**
 * Object to hold browser support information
 * @type {Object}
 * @private
 */
vjs.browser = {};

/**
 * Shorthand for document.getElementById()
 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
 * @param  {String} id  Element ID
 * @return {Element}    Element with supplied ID
 * @private
 */
vjs.el = function(id){
  if (id.indexOf('#') === 0) {
    id = id.slice(1);
  }

  return document.getElementById(id);
};

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 * @param  {Number} seconds Number of seconds to be turned into a string
 * @param  {Number} guide   Number (in seconds) to model the string after
 * @return {String}         Time formatted as H:MM:SS or M:SS
 * @private
 */
vjs.formatTime = function(seconds, guide) {
  // Default to using seconds as guide
  guide = guide || seconds;
  var s = Math.floor(seconds % 60),
      m = Math.floor(seconds / 60 % 60),
      h = Math.floor(seconds / 3600),
      gm = Math.floor(guide / 60 % 60),
      gh = Math.floor(guide / 3600);

  // handle invalid times
  if (isNaN(seconds) || seconds === Infinity) {
    // '-' is false for all relational operators (e.g. <, >=) so this setting
    // will add the minimum number of fields specified by the guide
    h = m = s = '-';
  }

  // Check if we need to show hours
  h = (h > 0 || gh > 0) ? h + ':' : '';

  // If hours are showing, we may need to add a leading zero.
  // Always show at least one digit of minutes.
  m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';

  // Check if leading zero is need for seconds
  s = (s < 10) ? '0' + s : s;

  return h + m + s;
};

// Attempt to block the ability to select text while dragging controls
vjs.blockTextSelection = function(){
  document.body.focus();
  document.onselectstart = function () { return false; };
};
// Turn off text selection blocking
vjs.unblockTextSelection = function(){ document.onselectstart = function () { return true; }; };

/**
 * Trim whitespace from the ends of a string.
 * @param  {String} string String to trim
 * @return {String}        Trimmed string
 * @private
 */
vjs.trim = function(str){
  return (str+'').replace(/^\s+|\s+$/g, '');
};

/**
 * Should round off a number to a decimal place
 * @param  {Number} num Number to round
 * @param  {Number} dec Number of decimal places to round to
 * @return {Number}     Rounded number
 * @private
 */
vjs.round = function(num, dec) {
  if (!dec) { dec = 0; }
  return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
};

/**
 * Should create a fake TimeRange object
 * Mimics an HTML5 time range instance, which has functions that
 * return the start and end times for a range
 * TimeRanges are returned by the buffered() method
 * @param  {Number} start Start time in seconds
 * @param  {Number} end   End time in seconds
 * @return {Object}       Fake TimeRange object
 * @private
 */
vjs.createTimeRange = function(start, end){
  return {
    length: 1,
    start: function() { return start; },
    end: function() { return end; }
  };
};


/**
 * Add to local storage (may removeable)
 * @private
 */
vjs.setLocalStorage = function(key, value){
  try {
    // IE was throwing errors referencing the var anywhere without this
    var localStorage = window.localStorage || false;
    if (!localStorage) { return; }
    localStorage[key] = value;
  } catch(e) {
    if (e.code == 22 || e.code == 1014) { // Webkit == 22 / Firefox == 1014
      vjs.log('LocalStorage Full (VideoJS)', e);
    } else {
      if (e.code == 18) {
        vjs.log('LocalStorage not allowed (VideoJS)', e);
      } else {
        vjs.log('LocalStorage Error (VideoJS)', e);
      }
    }
  }
};

/**
 * Get abosolute version of relative URL. Used to tell flash correct URL.
 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 * @param  {String} url URL to make absolute
 * @return {String}     Absolute URL
 * @private
 */
vjs.getAbsoluteURL = function(url){

  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    url = vjs.createEl('div', {
      innerHTML: '<a href="'+url+'">x</a>'
    }).firstChild.href;
  }

  return url;
};


/**
 * Resolve and parse the elements of a URL
 * @param  {String} url The url to parse
 * @return {Object}     An object of url details
 */
vjs.parseUrl = function(url) {
  var div, a, addToBody, props, details;

  props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  a = vjs.createEl('a', { href: url });

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  addToBody = (a.host === '' && a.protocol !== 'file:');
  if (addToBody) {
    div = vjs.createEl('div');
    div.innerHTML = '<a href="'+url+'"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    document.body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  if (addToBody) {
    document.body.removeChild(div);
  }

  return details;
};

/**
 * Log messags to the console and history based on the type of message
 *
 * @param  {String} type The type of message, or `null` for `log`
 * @param  {[type]} args The args to be passed to the log
 * @private
 */
function _logType(type, args){
  var argsArray, noop, console;

  // convert args to an array to get array functions
  argsArray = Array.prototype.slice.call(args);
  // if there's no console then don't try to output messages
  // they will still be stored in vjs.log.history
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  noop = function(){};
  console = window['console'] || {
    'log': noop,
    'warn': noop,
    'error': noop
  };

  if (type) {
    // add the type to the front of the message
    argsArray.unshift(type.toUpperCase()+':');
  } else {
    // default to log with no prefix
    type = 'log';
  }

  // add to history
  vjs.log.history.push(argsArray);

  // add console prefix after adding to history
  argsArray.unshift('VIDEOJS:');

  // call appropriate log function
  if (console[type].apply) {
    console[type].apply(console, argsArray);
  } else {
    // ie8 doesn't allow error.apply, but it will just join() the array anyway
    console[type](argsArray.join(' '));
  }
}

/**
 * Log plain debug messages
 */
vjs.log = function(){
  _logType(null, arguments);
};

/**
 * Keep a history of log messages
 * @type {Array}
 */
vjs.log.history = [];

/**
 * Log error messages
 */
vjs.log.error = function(){
  _logType('error', arguments);
};

/**
 * Log warning messages
 */
vjs.log.warn = function(){
  _logType('warn', arguments);
};

// Offset Left
// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
vjs.findPosition = function(el) {
  var box, docEl, body, clientLeft, scrollLeft, left, clientTop, scrollTop, top;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  docEl = document.documentElement;
  body = document.body;

  clientLeft = docEl.clientLeft || body.clientLeft || 0;
  scrollLeft = window.pageXOffset || body.scrollLeft;
  left = box.left + scrollLeft - clientLeft;

  clientTop = docEl.clientTop || body.clientTop || 0;
  scrollTop = window.pageYOffset || body.scrollTop;
  top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: vjs.round(left),
    top: vjs.round(top)
  };
};

/**
 * Array functions container
 * @type {Object}
 * @private
 */
vjs.arr = {};

/*
 * Loops through an array and runs a function for each item inside it.
 * @param  {Array}    array       The array
 * @param  {Function} callback    The function to be run for each item
 * @param  {*}        thisArg     The `this` binding of callback
 * @returns {Array}               The array
 * @private
 */
vjs.arr.forEach = function(array, callback, thisArg) {
  if (vjs.obj.isArray(array) && callback instanceof Function) {
    for (var i = 0, len = array.length; i < len; ++i) {
      callback.call(thisArg || vjs, array[i], i, array);
    }
  }

  return array;
};
/**
 * Utility functions namespace
 * @namespace
 * @type {Object}
 */
vjs.util = {};

/**
 * Merge two options objects, recursively merging any plain object properties as
 * well.  Previously `deepMerge`
 *
 * @param  {Object} obj1 Object to override values in
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object -- obj1 and obj2 will be untouched
 */
vjs.util.mergeOptions = function(obj1, obj2){
  var key, val1, val2;

  // make a copy of obj1 so we're not overwriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = vjs.obj.copy(obj1);

  for (key in obj2){
    if (obj2.hasOwnProperty(key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
        obj1[key] = vjs.util.mergeOptions(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
};/**
 * @fileoverview Player Component - Base class for all UI objects
 *
 */

/**
 * Base UI Component class
 *
 * Components are embeddable UI objects that are represented by both a
 * javascript object and an element in the DOM. They can be children of other
 * components, and can have many children themselves.
 *
 *     // adding a button to the player
 *     var button = player.addChild('button');
 *     button.el(); // -> button element
 *
 *     <div class="video-js">
 *       <div class="vjs-button">Button</div>
 *     </div>
 *
 * Components are also event emitters.
 *
 *     button.on('click', function(){
 *       console.log('Button Clicked!');
 *     });
 *
 *     button.trigger('customevent');
 *
 * @param {Object} player  Main Player
 * @param {Object=} options
 * @class
 * @constructor
 * @extends vjs.CoreObject
 */
vjs.Component = vjs.CoreObject.extend({
  /**
   * the constructor function for the class
   *
   * @constructor
   */
  init: function(player, options, ready){
    this.player_ = player;

    // Make a copy of prototype.options_ to protect against overriding global defaults
    this.options_ = vjs.obj.copy(this.options_);

    // Updated options with supplied options
    options = this.options(options);

    // Get ID from options or options element if one is supplied
    this.id_ = options['id'] || (options['el'] && options['el']['id']);

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      this.id_ = ((player.id && player.id()) || 'no_player') + '_component_' + vjs.guid++;
    }

    this.name_ = options['name'] || null;

    // Create element if one wasn't provided in options
    this.el_ = options['el'] || this.createEl();

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    this.initChildren();

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }
});

/**
 * Dispose of the component and all child components
 */
vjs.Component.prototype.dispose = function(){
  this.trigger({ type: 'dispose', 'bubbles': false });

  // Dispose all children.
  if (this.children_) {
    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i].dispose) {
        this.children_[i].dispose();
      }
    }
  }

  // Delete child references
  this.children_ = null;
  this.childIndex_ = null;
  this.childNameIndex_ = null;

  // Remove all event listeners.
  this.off();

  // Remove element from DOM
  if (this.el_.parentNode) {
    this.el_.parentNode.removeChild(this.el_);
  }

  vjs.removeData(this.el_);
  //防止IE报错：modify 278500368@qq.com
  if(vjs.IS_CHROME){
    this.el_ = null;
  }

};

/**
 * Reference to main player instance
 *
 * @type {vjs.Player}
 * @private
 */
vjs.Component.prototype.player_ = true;

/**
 * Return the component's player
 *
 * @return {vjs.Player}
 */
vjs.Component.prototype.player = function(){
  return this.player_;
};

/**
 * The component's options object
 *
 * @type {Object}
 * @private
 */
vjs.Component.prototype.options_;

/**
 * Deep merge of options objects
 *
 * Whenever a property is an object on both options objects
 * the two properties will be merged using vjs.obj.deepMerge.
 *
 * This is used for merging options for child components. We
 * want it to be easy to override individual options on a child
 * component without having to rewrite all the other default options.
 *
 *     Parent.prototype.options_ = {
 *       children: {
 *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
 *         'childTwo': {},
 *         'childThree': {}
 *       }
 *     }
 *     newOptions = {
 *       children: {
 *         'childOne': { 'foo': 'baz', 'abc': '123' }
 *         'childTwo': null,
 *         'childFour': {}
 *       }
 *     }
 *
 *     this.options(newOptions);
 *
 * RESULT
 *
 *     {
 *       children: {
 *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
 *         'childTwo': null, // Disabled. Won't be initialized.
 *         'childThree': {},
 *         'childFour': {}
 *       }
 *     }
 *
 * @param  {Object} obj Object of new option values
 * @return {Object}     A NEW object of this.options_ and obj merged
 */
vjs.Component.prototype.options = function(obj){
  if (obj === undefined) return this.options_;

  return this.options_ = vjs.util.mergeOptions(this.options_, obj);
};

/**
 * The DOM element for the component
 *
 * @type {Element}
 * @private
 */
vjs.Component.prototype.el_;

/**
 * Create the component's DOM element
 *
 * @param  {String=} tagName  Element's node type. e.g. 'div'
 * @param  {Object=} attributes An object of element attributes that should be set on the element
 * @return {Element}
 */
vjs.Component.prototype.createEl = function(tagName, attributes){
  return vjs.createEl(tagName, attributes);
};

vjs.Component.prototype.localize = function(string){
  var lang = this.player_.language(),
      languages = this.player_.languages();
  if (languages && languages[lang] && languages[lang][string]) {
    return languages[lang][string];
  }
  return string;
};

/**
 * Get the component's DOM element
 *
 *     var domEl = myComponent.el();
 *
 * @return {Element}
 */
vjs.Component.prototype.el = function(){
  return this.el_;
};

/**
 * An optional element where, if defined, children will be inserted instead of
 * directly in `el_`
 *
 * @type {Element}
 * @private
 */
vjs.Component.prototype.contentEl_;

/**
 * Return the component's DOM element for embedding content.
 * Will either be el_ or a new element defined in createEl.
 *
 * @return {Element}
 */
vjs.Component.prototype.contentEl = function(){
  return this.contentEl_ || this.el_;
};

/**
 * The ID for the component
 *
 * @type {String}
 * @private
 */
vjs.Component.prototype.id_;

/**
 * Get the component's ID
 *
 *     var id = myComponent.id();
 *
 * @return {String}
 */
vjs.Component.prototype.id = function(){
  return this.id_;
};

/**
 * The name for the component. Often used to reference the component.
 *
 * @type {String}
 * @private
 */
vjs.Component.prototype.name_;

/**
 * Get the component's name. The name is often used to reference the component.
 *
 *     var name = myComponent.name();
 *
 * @return {String}
 */
vjs.Component.prototype.name = function(){
  return this.name_;
};

/**
 * Array of child components
 *
 * @type {Array}
 * @private
 */
vjs.Component.prototype.children_;

/**
 * Get an array of all child components
 *
 *     var kids = myComponent.children();
 *
 * @return {Array} The children
 */
vjs.Component.prototype.children = function(){
  return this.children_;
};

/**
 * Object of child components by ID
 *
 * @type {Object}
 * @private
 */
vjs.Component.prototype.childIndex_;

/**
 * Returns a child component with the provided ID
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.getChildById = function(id){
  return this.childIndex_[id];
};

/**
 * Object of child components by name
 *
 * @type {Object}
 * @private
 */
vjs.Component.prototype.childNameIndex_;

/**
 * Returns a child component with the provided name
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.getChild = function(name){
  return this.childNameIndex_[name];
};

/**
 * Adds a child component inside this component
 *
 *     myComponent.el();
 *     // -> <div class='my-component'></div>
 *     myComonent.children();
 *     // [empty array]
 *
 *     var myButton = myComponent.addChild('MyButton');
 *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
 *     // -> myButton === myComonent.children()[0];
 *
 * Pass in options for child constructors and options for children of the child
 *
 *     var myButton = myComponent.addChild('MyButton', {
 *       text: 'Press Me',
 *       children: {
 *         buttonChildExample: {
 *           buttonChildOption: true
 *         }
 *       }
 *     });
 *
 * @param {String|vjs.Component} child The class name or instance of a child to add
 * @param {Object=} options Options, including options to be passed to children of the child.
 * @return {vjs.Component} The child component (created by this process if a string was used)
 * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
 */
vjs.Component.prototype.addChild = function(child, options){
  var component, componentClass, componentName;

  // If child is a string, create new component with options
  if (typeof child === 'string') {
    componentName = child;

    // Make sure options is at least an empty object to protect against errors
    options = options || {};

    // If no componentClass in options, assume componentClass is the name lowercased
    // (e.g. playButton)
    componentClass = options['componentClass'] || vjs.capitalize(componentName);

    // Set name through options
    options['name'] = componentName;

    // Create a new object & element for this controls set
    // If there's no .player_, this is a player
    // Closure Compiler throws an 'incomplete alias' warning if we use the vjs variable directly.
    // Every class should be exported, so this should never be a problem here.
    component = new window['videojs'][componentClass](this.player_ || this, options);

  // child is a component instance
  } else {
    component = child;
  }

  this.children_.push(component);

  if (typeof component.id === 'function') {
    this.childIndex_[component.id()] = component;
  }

  // If a name wasn't used to create the component, check if we can use the
  // name function of the component
  componentName = componentName || (component.name && component.name());

  if (componentName) {
    this.childNameIndex_[componentName] = component;
  }

  // Add the UI object's element to the container div (box)
  // Having an element is not required
  if (typeof component['el'] === 'function' && component['el']()) {
    this.contentEl().appendChild(component['el']());
  }

  // Return so it can stored on parent object if desired.
  return component;
};

/**
 * Remove a child component from this component's list of children, and the
 * child component's element from this component's element
 *
 * @param  {vjs.Component} component Component to remove
 */
vjs.Component.prototype.removeChild = function(component){
  if (typeof component === 'string') {
    component = this.getChild(component);
  }

  if (!component || !this.children_) return;

  var childFound = false;
  for (var i = this.children_.length - 1; i >= 0; i--) {
    if (this.children_[i] === component) {
      childFound = true;
      this.children_.splice(i,1);
      break;
    }
  }

  if (!childFound) return;

  this.childIndex_[component.id] = null;
  this.childNameIndex_[component.name] = null;

  var compEl = component.el();
  if (compEl && compEl.parentNode === this.contentEl()) {
    this.contentEl().removeChild(component.el());
  }
};

/**
 * Add and initialize default child components from options
 *
 *     // when an instance of MyComponent is created, all children in options
 *     // will be added to the instance by their name strings and options
 *     MyComponent.prototype.options_.children = {
 *       myChildComponent: {
 *         myChildOption: true
 *       }
 *     }
 *
 *     // Or when creating the component
 *     var myComp = new MyComponent(player, {
 *       children: {
 *         myChildComponent: {
 *           myChildOption: true
 *         }
 *       }
 *     });
 *
 * The children option can also be an Array of child names or
 * child options objects (that also include a 'name' key).
 *
 *     var myComp = new MyComponent(player, {
 *       children: [
 *         'button',
 *         {
 *           name: 'button',
 *           someOtherOption: true
 *         }
 *       ]
 *     });
 *
 */
vjs.Component.prototype.initChildren = function(){
  var parent, parentOptions, children, child, name, opts, handleAdd;

  parent = this;
  parentOptions = parent.options();
  children = parentOptions['children'];

  if (children) {
    handleAdd = function(name, opts){
      // Allow options for children to be set at the parent options
      // e.g. videojs(id, { controlBar: false });
      // instead of videojs(id, { children: { controlBar: false });
      if (parentOptions[name] !== undefined) {
        opts = parentOptions[name];
      }

      // Allow for disabling default components
      // e.g. vjs.options['children']['posterImage'] = false
      if (opts === false) return;

      // Create and add the child component.
      // Add a direct reference to the child by name on the parent instance.
      // If two of the same component are used, different names should be supplied
      // for each
      parent[name] = parent.addChild(name, opts);
    };

    // Allow for an array of children details to passed in the options
    if (vjs.obj.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        child = children[i];

        if (typeof child == 'string') {
          // ['myComponent']
          name = child;
          opts = {};
        } else {
          // [{ name: 'myComponent', otherOption: true }]
          name = child.name;
          opts = child;
        }

        handleAdd(name, opts);
      }
    } else {
      vjs.obj.each(children, handleAdd);
    }
  }
};

/**
 * Allows sub components to stack CSS class names
 *
 * @return {String} The constructed class name
 */
vjs.Component.prototype.buildCSSClass = function(){
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
};

/* Events
============================================================================= */

/**
 * Add an event listener to this component's element
 *
 *     var myFunc = function(){
 *       var myComponent = this;
 *       // Do something when the event is fired
 *     };
 *
 *     myComponent.on('eventType', myFunc);
 *
 * The context of myFunc will be myComponent unless previously bound.
 *
 * Alternatively, you can add a listener to another element or component.
 *
 *     myComponent.on(otherElement, 'eventName', myFunc);
 *     myComponent.on(otherComponent, 'eventName', myFunc);
 *
 * The benefit of using this over `vjs.on(otherElement, 'eventName', myFunc)`
 * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
 * will be automatically cleaned up when either component is diposed.
 * It will also bind myComponent as the context of myFunc.
 *
 * **NOTE**: When using this on elements in the page other than window
 * and document (both permanent), if you remove the element from the DOM
 * you need to call `vjs.trigger(el, 'dispose')` on it to clean up
 * references to it and allow the browser to garbage collect it.
 *
 * @param  {String|vjs.Component} first   The event type or other component
 * @param  {Function|String}      second  The event handler or event type
 * @param  {Function}             third   The event handler
 * @return {vjs.Component}        self
 */
vjs.Component.prototype.on = function(first, second, third){
  var target, type, fn, removeOnDispose, cleanRemover, thisComponent;

  if (typeof first === 'string' || vjs.obj.isArray(first)) {
    vjs.on(this.el_, first, vjs.bind(this, second));

  // Targeting another component or element
  } else {
    target = first;
    type = second;
    fn = vjs.bind(this, third);
    thisComponent = this;

    // When this component is disposed, remove the listener from the other component
    removeOnDispose = function(){
      thisComponent.off(target, type, fn);
    };
    // Use the same function ID so we can remove it later it using the ID
    // of the original listener
    removeOnDispose.guid = fn.guid;
    this.on('dispose', removeOnDispose);

    // If the other component is disposed first we need to clean the reference
    // to the other component in this component's removeOnDispose listener
    // Otherwise we create a memory leak.
    cleanRemover = function(){
      thisComponent.off('dispose', removeOnDispose);
    };
    // Add the same function ID so we can easily remove it later
    cleanRemover.guid = fn.guid;

    // Check if this is a DOM node
    if (first.nodeName) {
      // Add the listener to the other element
      vjs.on(target, type, fn);
      vjs.on(target, 'dispose', cleanRemover);

    // Should be a component
    // Not using `instanceof vjs.Component` because it makes mock players difficult
    } else if (typeof first.on === 'function') {
      // Add the listener to the other component
      target.on(type, fn);
      target.on('dispose', cleanRemover);
    }
  }

  return this;
};

/**
 * Remove an event listener from this component's element
 *
 *     myComponent.off('eventType', myFunc);
 *
 * If myFunc is excluded, ALL listeners for the event type will be removed.
 * If eventType is excluded, ALL listeners will be removed from the component.
 *
 * Alternatively you can use `off` to remove listeners that were added to other
 * elements or components using `myComponent.on(otherComponent...`.
 * In this case both the event type and listener function are REQUIRED.
 *
 *     myComponent.off(otherElement, 'eventType', myFunc);
 *     myComponent.off(otherComponent, 'eventType', myFunc);
 *
 * @param  {String=|vjs.Component}  first  The event type or other component
 * @param  {Function=|String}       second The listener function or event type
 * @param  {Function=}              third  The listener for other component
 * @return {vjs.Component}
 */
vjs.Component.prototype.off = function(first, second, third){
  var target, otherComponent, type, fn, otherEl;

  if (!first || typeof first === 'string' || vjs.obj.isArray(first)) {
    vjs.off(this.el_, first, second);
  } else {
    target = first;
    type = second;
    // Ensure there's at least a guid, even if the function hasn't been used
    fn = vjs.bind(this, third);

    // Remove the dispose listener on this component,
    // which was given the same guid as the event listener
    this.off('dispose', fn);

    if (first.nodeName) {
      // Remove the listener
      vjs.off(target, type, fn);
      // Remove the listener for cleaning the dispose listener
      vjs.off(target, 'dispose', fn);
    } else {
      target.off(type, fn);
      target.off('dispose', fn);
    }
  }

  return this;
};

/**
 * Add an event listener to be triggered only once and then removed
 *
 *     myComponent.one('eventName', myFunc);
 *
 * Alternatively you can add a listener to another element or component
 * that will be triggered only once.
 *
 *     myComponent.one(otherElement, 'eventName', myFunc);
 *     myComponent.one(otherComponent, 'eventName', myFunc);
 *
 * @param  {String|vjs.Component}  first   The event type or other component
 * @param  {Function|String}       second  The listener function or event type
 * @param  {Function=}             third   The listener function for other component
 * @return {vjs.Component}
 */
vjs.Component.prototype.one = function(first, second, third) {
  var target, type, fn, thisComponent, newFunc;

  if (typeof first === 'string' || vjs.obj.isArray(first)) {
    vjs.one(this.el_, first, vjs.bind(this, second));
  } else {
    target = first;
    type = second;
    fn = vjs.bind(this, third);
    thisComponent = this;

    newFunc = function(){
      thisComponent.off(target, type, newFunc);
      fn.apply(this, arguments);
    };
    // Keep the same function ID so we can remove it later
    newFunc.guid = fn.guid;

    this.on(target, type, newFunc);
  }

  return this;
};

/**
 * Trigger an event on an element
 *
 *     myComponent.trigger('eventName');
 *     myComponent.trigger({'type':'eventName'});
 *
 * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
 * @return {vjs.Component}       self
 */
vjs.Component.prototype.trigger = function(event){
  vjs.trigger(this.el_, event);
  return this;
};

/* Ready
================================================================================ */
/**
 * Is the component loaded
 * This can mean different things depending on the component.
 *
 * @private
 * @type {Boolean}
 */
vjs.Component.prototype.isReady_;

/**
 * Trigger ready as soon as initialization is finished
 *
 * Allows for delaying ready. Override on a sub class prototype.
 * If you set this.isReadyOnInitFinish_ it will affect all components.
 * Specially used when waiting for the Flash player to asynchrnously load.
 *
 * @type {Boolean}
 * @private
 */
vjs.Component.prototype.isReadyOnInitFinish_ = true;

/**
 * List of ready listeners
 *
 * @type {Array}
 * @private
 */
vjs.Component.prototype.readyQueue_;

/**
 * Bind a listener to the component's ready state
 *
 * Different from event listeners in that if the ready event has already happend
 * it will trigger the function immediately.
 *
 * @param  {Function} fn Ready listener
 * @return {vjs.Component}
 */
vjs.Component.prototype.ready = function(fn){
  if (fn) {
    if (this.isReady_) {
      fn.call(this);
    } else {
      if (this.readyQueue_ === undefined) {
        this.readyQueue_ = [];
      }
      this.readyQueue_.push(fn);
    }
  }
  return this;
};

/**
 * Trigger the ready listeners
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.triggerReady = function(){
  this.isReady_ = true;

  var readyQueue = this.readyQueue_;

  if (readyQueue && readyQueue.length > 0) {

    for (var i = 0, j = readyQueue.length; i < j; i++) {
      readyQueue[i].call(this);
    }

    // Reset Ready Queue
    this.readyQueue_ = [];

    // Allow for using event listeners also, in case you want to do something everytime a source is ready.
    this.trigger('ready');
  }
};

/* Display
============================================================================= */

/**
 * Check if a component's element has a CSS class name
 *
 * @param {String} classToCheck Classname to check
 * @return {vjs.Component}
 */
vjs.Component.prototype.hasClass = function(classToCheck){
  return vjs.hasClass(this.el_, classToCheck);
};

/**
 * Add a CSS class name to the component's element
 *
 * @param {String} classToAdd Classname to add
 * @return {vjs.Component}
 */
vjs.Component.prototype.addClass = function(classToAdd){
  vjs.addClass(this.el_, classToAdd);
  return this;
};

/**
 * Remove a CSS class name from the component's element
 *
 * @param {String} classToRemove Classname to remove
 * @return {vjs.Component}
 */
vjs.Component.prototype.removeClass = function(classToRemove){
  vjs.removeClass(this.el_, classToRemove);
  return this;
};

/**
 * Show the component element if hidden
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.show = function(){
  this.el_.style.display = 'block';
  return this;
};

/**
 * Hide the component element if currently showing
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.hide = function(){
  this.el_.style.display = 'none';
  return this;
};

/**
 * Lock an item in its visible state
 * To be used with fadeIn/fadeOut.
 *
 * @return {vjs.Component}
 * @private
 */
vjs.Component.prototype.lockShowing = function(){
  this.addClass('vjs-lock-showing');
  return this;
};

/**
 * Unlock an item to be hidden
 * To be used with fadeIn/fadeOut.
 *
 * @return {vjs.Component}
 * @private
 */
vjs.Component.prototype.unlockShowing = function(){
  this.removeClass('vjs-lock-showing');
  return this;
};

/**
 * Disable component by making it unshowable
 *
 * Currently private because we're movign towards more css-based states.
 * @private
 */
vjs.Component.prototype.disable = function(){
  this.hide();
  this.show = function(){};
};

/**
 * Set or get the width of the component (CSS values)
 *
 * Setting the video tag dimension values only works with values in pixels.
 * Percent values will not work.
 * Some percents can be used, but width()/height() will return the number + %,
 * not the actual computed width/height.
 *
 * @param  {Number|String=} num   Optional width number
 * @param  {Boolean} skipListeners Skip the 'resize' event trigger
 * @return {vjs.Component} This component, when setting the width
 * @return {Number|String} The width, when getting
 */
vjs.Component.prototype.width = function(num, skipListeners){
  return this.dimension('width', num, skipListeners);
};

/**
 * Get or set the height of the component (CSS values)
 *
 * Setting the video tag dimension values only works with values in pixels.
 * Percent values will not work.
 * Some percents can be used, but width()/height() will return the number + %,
 * not the actual computed width/height.
 *
 * @param  {Number|String=} num     New component height
 * @param  {Boolean=} skipListeners Skip the resize event trigger
 * @return {vjs.Component} This component, when setting the height
 * @return {Number|String} The height, when getting
 */
vjs.Component.prototype.height = function(num, skipListeners){
  return this.dimension('height', num, skipListeners);
};

/**
 * Set both width and height at the same time
 *
 * @param  {Number|String} width
 * @param  {Number|String} height
 * @return {vjs.Component} The component
 */
vjs.Component.prototype.dimensions = function(width, height){
  // Skip resize listeners on width for optimization
  return this.width(width, true).height(height);
};

/**
 * Get or set width or height
 *
 * This is the shared code for the width() and height() methods.
 * All for an integer, integer + 'px' or integer + '%';
 *
 * Known issue: Hidden elements officially have a width of 0. We're defaulting
 * to the style.width value and falling back to computedStyle which has the
 * hidden element issue. Info, but probably not an efficient fix:
 * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
 *
 * @param  {String} widthOrHeight  'width' or 'height'
 * @param  {Number|String=} num     New dimension
 * @param  {Boolean=} skipListeners Skip resize event trigger
 * @return {vjs.Component} The component if a dimension was set
 * @return {Number|String} The dimension if nothing was set
 * @private
 */
vjs.Component.prototype.dimension = function(widthOrHeight, num, skipListeners){
  if (num !== undefined) {
    if (num === null || vjs.isNaN(num)) {
      num = 0;
    }

    // Check if using css width/height (% or px) and adjust
    if ((''+num).indexOf('%') !== -1 || (''+num).indexOf('px') !== -1) {
      this.el_.style[widthOrHeight] = num;
    } else if (num === 'auto') {
      this.el_.style[widthOrHeight] = '';
    } else {
      this.el_.style[widthOrHeight] = num+'px';
    }

    // skipListeners allows us to avoid triggering the resize event when setting both width and height
    if (!skipListeners) { this.trigger('resize'); }

    // Return component
    return this;
  }

  // Not setting a value, so getting it
  // Make sure element exists
  if (!this.el_) return 0;

  // Get dimension value from style
  var val = this.el_.style[widthOrHeight];
  var pxIndex = val.indexOf('px');
  if (pxIndex !== -1) {
    // Return the pixel value with no 'px'
    return parseInt(val.slice(0,pxIndex), 10);

  // No px so using % or no style was set, so falling back to offsetWidth/height
  // If component has display:none, offset will return 0
  // TODO: handle display:none and no dimension style using px
  } else {

    return parseInt(this.el_['offset'+vjs.capitalize(widthOrHeight)], 10);

    // ComputedStyle version.
    // Only difference is if the element is hidden it will return
    // the percent value (e.g. '100%'')
    // instead of zero like offsetWidth returns.
    // var val = vjs.getComputedStyleValue(this.el_, widthOrHeight);
    // var pxIndex = val.indexOf('px');

    // if (pxIndex !== -1) {
    //   return val.slice(0, pxIndex);
    // } else {
    //   return val;
    // }
  }
};

/**
 * Fired when the width and/or height of the component changes
 * @event resize
 */
vjs.Component.prototype.onResize;

/**
 * Emit 'tap' events when touch events are supported
 *
 * This is used to support toggling the controls through a tap on the video.
 *
 * We're requireing them to be enabled because otherwise every component would
 * have this extra overhead unnecessarily, on mobile devices where extra
 * overhead is especially bad.
 * @private
 */
vjs.Component.prototype.emitTapEvents = function(){
  var touchStart, firstTouch, touchTime, couldBeTap, noTap,
      xdiff, ydiff, touchDistance, tapMovementThreshold;

  // Track the start time so we can determine how long the touch lasted
  touchStart = 0;
  firstTouch = null;

  // Maximum movement allowed during a touch event to still be considered a tap
  tapMovementThreshold = 22;

  this.on('touchstart', function(event) {
    // If more than one finger, don't consider treating this as a click
    if (event.touches.length === 1) {
      firstTouch = event.touches[0];
      // Record start time so we can detect a tap vs. "touch and hold"
      touchStart = new Date().getTime();
      // Reset couldBeTap tracking
      couldBeTap = true;
    }
  });

  this.on('touchmove', function(event) {
    // If more than one finger, don't consider treating this as a click
    if (event.touches.length > 1) {
      couldBeTap = false;
    } else if (firstTouch) {
      // Some devices will throw touchmoves for all but the slightest of taps.
      // So, if we moved only a small distance, this could still be a tap
      xdiff = event.touches[0].pageX - firstTouch.pageX;
      ydiff = event.touches[0].pageY - firstTouch.pageY;
      touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
      if (touchDistance > tapMovementThreshold) {
        couldBeTap = false;
      }
    }
  });

  noTap = function(){
    couldBeTap = false;
  };
  // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
  this.on('touchleave', noTap);
  this.on('touchcancel', noTap);

  // When the touch ends, measure how long it took and trigger the appropriate
  // event
  this.on('touchend', function(event) {
    firstTouch = null;
    // Proceed only if the touchmove/leave/cancel event didn't happen
    if (couldBeTap === true) {
      // Measure how long the touch lasted
      touchTime = new Date().getTime() - touchStart;
      // The touch needs to be quick in order to consider it a tap
      if (touchTime < 250) {
        event.preventDefault(); // Don't let browser turn this into a click
        this.trigger('tap');
        // It may be good to copy the touchend event object and change the
        // type to tap, if the other event properties aren't exact after
        // vjs.fixEvent runs (e.g. event.target)
      }
    }
  });
};

/**
 * Report user touch activity when touch events occur
 *
 * User activity is used to determine when controls should show/hide. It's
 * relatively simple when it comes to mouse events, because any mouse event
 * should show the controls. So we capture mouse events that bubble up to the
 * player and report activity when that happens.
 *
 * With touch events it isn't as easy. We can't rely on touch events at the
 * player level, because a tap (touchstart + touchend) on the video itself on
 * mobile devices is meant to turn controls off (and on). User activity is
 * checked asynchronously, so what could happen is a tap event on the video
 * turns the controls off, then the touchend event bubbles up to the player,
 * which if it reported user activity, would turn the controls right back on.
 * (We also don't want to completely block touch events from bubbling up)
 *
 * Also a touchmove, touch+hold, and anything other than a tap is not supposed
 * to turn the controls back on on a mobile device.
 *
 * Here we're setting the default component behavior to report user activity
 * whenever touch events happen, and this can be turned off by components that
 * want touch events to act differently.
 */
vjs.Component.prototype.enableTouchActivity = function() {
  var report, touchHolding, touchEnd;

  // Don't continue if the root player doesn't support reporting user activity
  if (!this.player().reportUserActivity) {
    return;
  }

  // listener for reporting that the user is active
  report = vjs.bind(this.player(), this.player().reportUserActivity);

  this.on('touchstart', function() {
    report();
    // For as long as the they are touching the device or have their mouse down,
    // we consider them active even if they're not moving their finger or mouse.
    // So we want to continue to update that they are active
    clearInterval(touchHolding);
    // report at the same interval as activityCheck
    touchHolding = setInterval(report, 250);
  });

  touchEnd = function(event) {
    report();
    // stop the interval that maintains activity if the touch is holding
    clearInterval(touchHolding);
  };

  this.on('touchmove', report);
  this.on('touchend', touchEnd);
  this.on('touchcancel', touchEnd);
};

/* Button - Base class for all buttons
================================================================================ */
/**
 * Base class for all buttons
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */
vjs.Button = vjs.Component.extend({
  /**
   * @constructor
   * @inheritDoc
   */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    this.emitTapEvents();

    this.on('tap', this.onClick);
    this.on('click', this.onClick);
    this.on('focus', this.onFocus);
    this.on('blur', this.onBlur);
  }
});

vjs.Button.prototype.createEl = function(type, props){
  var el;

  // Add standard Aria and Tabindex info
  props = vjs.obj.merge({
    className: this.buildCSSClass(),
    'role': 'button',
    'aria-live': 'polite', // let the screen reader user know that the text of the button may change
    tabIndex: 0
  }, props);

  el = vjs.Component.prototype.createEl.call(this, type, props);

  // if innerHTML hasn't been overridden (bigPlayButton), add content elements
  if (!props.innerHTML) {
    this.contentEl_ = vjs.createEl('div', {
      className: 'vjs-control-content'
    });

    this.controlText_ = vjs.createEl('span', {
      className: 'vjs-control-text',
      innerHTML: this.localize(this.buttonText) || 'Need Text'
    });

    this.contentEl_.appendChild(this.controlText_);
    el.appendChild(this.contentEl_);
  }

  return el;
};

vjs.Button.prototype.buildCSSClass = function(){
  // TODO: Change vjs-control to vjs-button?
  return 'vjs-control ' + vjs.Component.prototype.buildCSSClass.call(this);
};

  // Click - Override with specific functionality for button
vjs.Button.prototype.onClick = function(){};

  // Focus - Add keyboard functionality to element
vjs.Button.prototype.onFocus = function(){
  vjs.on(document, 'keydown', vjs.bind(this, this.onKeyPress));
};

  // KeyPress (document level) - Trigger click when keys are pressed
vjs.Button.prototype.onKeyPress = function(event){
  // Check for space bar (32) or enter (13) keys
  if (event.which == 32 || event.which == 13) {
    event.preventDefault();
    this.onClick();
  }
};

// Blur - Remove keyboard triggers
vjs.Button.prototype.onBlur = function(){
  vjs.off(document, 'keydown', vjs.bind(this, this.onKeyPress));
};
/* Slider
================================================================================ */
/**
 * The base functionality for sliders like the volume bar and seek bar
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.Slider = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    // Set property names to bar and handle to match with the child Slider class is looking for
    this.bar = this.getChild(this.options_['barName']);
    this.handle = this.getChild(this.options_['handleName']);

    this.on('mousedown', this.onMouseDown);
    this.on('touchstart', this.onMouseDown);
    this.on('focus', this.onFocus);
    this.on('blur', this.onBlur);
    this.on('click', this.onClick);

    this.on(player, 'controlsvisible', this.update);
    this.on(player, this.playerEvent, this.update);

    this.boundEvents = {};
    this.boundEvents.move = vjs.bind(this, this.onMouseMove);
    this.boundEvents.end = vjs.bind(this, this.onMouseUp);
  }
});

vjs.Slider.prototype.dispose = function() {
  vjs.off(document, 'mousemove', this.boundEvents.move, false);
  vjs.off(document, 'mouseup', this.boundEvents.end, false);
  vjs.off(document, 'touchmove', this.boundEvents.move, false);
  vjs.off(document, 'touchend', this.boundEvents.end, false);

  vjs.off(document, 'keyup', vjs.bind(this, this.onKeyPress));

  vjs.Component.prototype.dispose.call(this);
};

vjs.Slider.prototype.createEl = function(type, props) {
  props = props || {};
  // Add the slider element class to all sub classes
  props.className = props.className + ' vjs-slider';
  props = vjs.obj.merge({
    'role': 'slider',
    'aria-valuenow': 0,
    'aria-valuemin': 0,
    'aria-valuemax': 100,
    tabIndex: 0
  }, props);

  return vjs.Component.prototype.createEl.call(this, type, props);
};

vjs.Slider.prototype.onMouseDown = function(event){
  event.preventDefault();
  vjs.blockTextSelection();
  this.addClass('vjs-sliding');

  vjs.on(document, 'mousemove', this.boundEvents.move);
  vjs.on(document, 'mouseup', this.boundEvents.end);
  vjs.on(document, 'touchmove', this.boundEvents.move);
  vjs.on(document, 'touchend', this.boundEvents.end);

  this.onMouseMove(event);
};

// To be overridden by a subclass
vjs.Slider.prototype.onMouseMove = function(){};

vjs.Slider.prototype.onMouseUp = function() {
  vjs.unblockTextSelection();
  this.removeClass('vjs-sliding');

  vjs.off(document, 'mousemove', this.boundEvents.move, false);
  vjs.off(document, 'mouseup', this.boundEvents.end, false);
  vjs.off(document, 'touchmove', this.boundEvents.move, false);
  vjs.off(document, 'touchend', this.boundEvents.end, false);

  this.update();
};

vjs.Slider.prototype.update = function(){
  // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
  // execution stack. The player is destroyed before then update will cause an error
  if (!this.el_) return;

  // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
  // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
  // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();

  var barProgress,
      progress = this.getPercent(),
      handle = this.handle,
      bar = this.bar;

  // Protect against no duration and other division issues
  if (isNaN(progress)) { progress = 0; }

  barProgress = progress;

  // If there is a handle, we need to account for the handle in our calculation for progress bar
  // so that it doesn't fall short of or extend past the handle.
  if (handle) {

    var box = this.el_,
        boxWidth = box.offsetWidth,

        handleWidth = handle.el().offsetWidth,

        // The width of the handle in percent of the containing box
        // In IE, widths may not be ready yet causing NaN
        handlePercent = (handleWidth) ? handleWidth / boxWidth : 0,

        // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
        // There is a margin of half the handle's width on both sides.
        boxAdjustedPercent = 1 - handlePercent,

        // Adjust the progress that we'll use to set widths to the new adjusted box width
        adjustedProgress = progress * boxAdjustedPercent;

    // The bar does reach the left side, so we need to account for this in the bar's width
    barProgress = adjustedProgress + (handlePercent / 2);

    // Move the handle from the left based on the adjected progress
    handle.el().style.left = vjs.round(adjustedProgress * 100, 2) + '%';
  }

  // Set the new bar width
  if (bar) {
    bar.el().style.width = vjs.round(barProgress * 100, 2) + '%';
  }
};

vjs.Slider.prototype.calculateDistance = function(event){
  var el, box, boxX, boxY, boxW, boxH, handle, pageX, pageY;

  el = this.el_;
  box = vjs.findPosition(el);
  boxW = boxH = el.offsetWidth;
  handle = this.handle;

  if (this.options()['vertical']) {
    boxY = box.top;

    if (event.changedTouches) {
      pageY = event.changedTouches[0].pageY;
    } else {
      pageY = event.pageY;
    }

    if (handle) {
      var handleH = handle.el().offsetHeight;
      // Adjusted X and Width, so handle doesn't go outside the bar
      boxY = boxY + (handleH / 2);
      boxH = boxH - handleH;
    }

    // Percent that the click is through the adjusted area
    return Math.max(0, Math.min(1, ((boxY - pageY) + boxH) / boxH));

  } else {
    boxX = box.left;

    if (event.changedTouches) {
      pageX = event.changedTouches[0].pageX;
    } else {
      pageX = event.pageX;
    }

    if (handle) {
      var handleW = handle.el().offsetWidth;

      // Adjusted X and Width, so handle doesn't go outside the bar
      boxX = boxX + (handleW / 2);
      boxW = boxW - handleW;
    }

    // Percent that the click is through the adjusted area
    return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
  }
};

vjs.Slider.prototype.onFocus = function(){
  vjs.on(document, 'keyup', vjs.bind(this, this.onKeyPress));
};

vjs.Slider.prototype.onKeyPress = function(event){
  if (event.which == 37 || event.which == 40) { // Left and Down Arrows
    event.preventDefault();
    this.stepBack();
  } else if (event.which == 38 || event.which == 39) { // Up and Right Arrows
    event.preventDefault();
    this.stepForward();
  }
};

vjs.Slider.prototype.onBlur = function(){
  vjs.off(document, 'keyup', vjs.bind(this, this.onKeyPress));
};

/**
 * Listener for click events on slider, used to prevent clicks
 *   from bubbling up to parent elements like button menus.
 * @param  {Object} event Event object
 */
vjs.Slider.prototype.onClick = function(event){
  event.stopImmediatePropagation();
  event.preventDefault();
};

/**
 * SeekBar Behavior includes play progress bar, and seek handle
 * Needed so it can determine seek position based on handle position/size
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.SliderHandle = vjs.Component.extend();

/**
 * Default value of the slider
 *
 * @type {Number}
 * @private
 */
vjs.SliderHandle.prototype.defaultValue = 0;

/** @inheritDoc */
vjs.SliderHandle.prototype.createEl = function(type, props) {
  props = props || {};
  // Add the slider element class to all sub classes
  props.className = props.className + ' vjs-slider-handle';
  props = vjs.obj.merge({
    innerHTML: '<span class="vjs-control-text">'+this.defaultValue+'</span>'
  }, props);

  return vjs.Component.prototype.createEl.call(this, 'div', props);
};


/**
 * Custom MediaError to mimic the HTML5 MediaError
 * @param {Number} code The media error code
 */
vjs.MediaError = function(code){
  if (typeof code === 'number') {
    this.code = code;
  } else if (typeof code === 'string') {
    // default code is zero, so this is a custom error
    this.message = code;
  } else if (typeof code === 'object') { // object
    vjs.obj.merge(this, code);
  }

  if (!this.message) {
    this.message = vjs.MediaError.defaultMessages[this.code] || '';
  }
};

/**
 * The error code that refers two one of the defined
 * MediaError types
 * @type {Number}
 */
vjs.MediaError.prototype.code = 0;

/**
 * An optional message to be shown with the error.
 * Message is not part of the HTML5 video spec
 * but allows for more informative custom errors.
 * @type {String}
 */
vjs.MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins
 * to allow even more detail about the error.
 * For example the HLS plugin might provide the specific
 * HTTP status code that was returned when the error
 * occurred, then allowing a custom error overlay
 * to display more information.
 * @type {[type]}
 */
vjs.MediaError.prototype.status = null;

vjs.MediaError.errorTypes = [
  'MEDIA_ERR_CUSTOM',            // = 0
  'MEDIA_ERR_ABORTED',           // = 1
  'MEDIA_ERR_NETWORK',           // = 2
  'MEDIA_ERR_DECODE',            // = 3
  'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
  'MEDIA_ERR_ENCRYPTED'          // = 5
];

vjs.MediaError.defaultMessages = {
  1: 'You aborted the video playback',
  2: 'A network error caused the video download to fail part-way.',
  3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
  4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The video is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < vjs.MediaError.errorTypes.length; errNum++) {
  vjs.MediaError[vjs.MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  vjs.MediaError.prototype[vjs.MediaError.errorTypes[errNum]] = errNum;
}
(function(){
  var apiMap, specApi, browserApi, i;

  /**
   * Store the browser-specifc methods for the fullscreen API
   * @type {Object|undefined}
   * @private
   */
  vjs.browser.fullscreenAPI;

  // browser API methods
  // map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
  apiMap = [
    // Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
    [
      'requestFullscreen',
      'exitFullscreen',
      'fullscreenElement',
      'fullscreenEnabled',
      'fullscreenchange',
      'fullscreenerror'
    ],
    // WebKit
    [
      'webkitRequestFullscreen',
      'webkitExitFullscreen',
      'webkitFullscreenElement',
      'webkitFullscreenEnabled',
      'webkitfullscreenchange',
      'webkitfullscreenerror'
    ],
    // Old WebKit (Safari 5.1)
    [
      'webkitRequestFullScreen',
      'webkitCancelFullScreen',
      'webkitCurrentFullScreenElement',
      'webkitCancelFullScreen',
      'webkitfullscreenchange',
      'webkitfullscreenerror'
    ],
    // Mozilla
    [
      'mozRequestFullScreen',
      'mozCancelFullScreen',
      'mozFullScreenElement',
      'mozFullScreenEnabled',
      'mozfullscreenchange',
      'mozfullscreenerror'
    ],
    // Microsoft
    [
      'msRequestFullscreen',
      'msExitFullscreen',
      'msFullscreenElement',
      'msFullscreenEnabled',
      'MSFullscreenChange',
      'MSFullscreenError'
    ]
  ];

  specApi = apiMap[0];

  // determine the supported set of functions
  for (i=0; i<apiMap.length; i++) {
    // check for exitFullscreen function
    if (apiMap[i][1] in document) {
      browserApi = apiMap[i];
      break;
    }
  }

  // map the browser API names to the spec API names
  // or leave vjs.browser.fullscreenAPI undefined
  if (browserApi) {
    vjs.browser.fullscreenAPI = {};

    for (i=0; i<browserApi.length; i++) {
      vjs.browser.fullscreenAPI[specApi[i]] = browserApi[i];
    }
  }

})();
/**
 * An instance of the `vjs.Player` class is created when any of the Video.js setup methods are used to initialize a video.
 *
 * ```js
 * var myPlayer = videojs('example_video_1');
 * ```
 *
 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
 *
 * ```html
 * <video id="example_video_1" data-setup='{}' controls>
 *   <source src="my-source.mp4" type="video/mp4">
 * </video>
 * ```
 *
 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
 *
 * @class
 * @extends vjs.Component
 */
vjs.Player = vjs.Component.extend({

  /**
   * player's constructor function
   *
   * @constructs
   * @method init
   * @param {Element} tag        The original video tag used for configuring options
   * @param {Object=} options    Player options
   * @param {Function=} ready    Ready callback function
   */
  init: function(tag, options, ready){
    this.tag = tag; // Store the original tag used to set options

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + vjs.guid++;

    // Store the tag attributes used to restore html5 element
    this.tagAttributes = tag && vjs.getElementAttributes(tag);

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = vjs.obj.merge(this.getTagSettings(tag), options);

    // Update Current Language
    this.language_ = options['language'] || vjs.options['language'];

    // Update Supported Languages
    this.languages_ = options['languages'] || vjs.options['languages'];

    // Cache for video property values.
    this.cache_ = {};

    // Set controls
    this.controls_ = !!options['controls'];
    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // Set isAudio based on whether or not an audio tag was used
    this.isAudio(this.tag.nodeName.toLowerCase() === 'audio');

    // Run base component initializing with new options.
    // Builds the element through createEl()
    // Inits and embeds any child components in opts
    vjs.Component.call(this, this, options, ready);

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (this.controls()) {
      this.addClass('vjs-controls-enabled');
    } else {
      this.addClass('vjs-controls-disabled');
    }

    if (this.isAudio()) {
      this.addClass('vjs-audio');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (vjs.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // Make player easily findable by ID
    vjs.players[this.id_] = this;

    if (options['plugins']) {
      vjs.obj.each(options['plugins'], function(key, val){
        this[key](val);
      }, this);
    }

    this.listenForUserActivity();
  }
});

/**
 * The players's stored language code
 *
 * @type {String}
 * @private
 */
vjs.Player.prototype.language_;

/**
 * The player's language code
 * @param  {String} languageCode  The locale string
 * @return {String}             The locale string when getting
 * @return {vjs.Player}         self, when setting
 */
vjs.Player.prototype.language = function (languageCode) {
  if (languageCode === undefined) {
    return this.language_;
  }

  this.language_ = languageCode;
  return this;
};

/**
 * The players's stored language dictionary
 *
 * @type {Object}
 * @private
 */
vjs.Player.prototype.languages_;

vjs.Player.prototype.languages = function(){
  return this.languages_;
};

/**
 * Player instance options, surfaced using vjs.options
 * vjs.options = vjs.Player.prototype.options_
 * Make changes in vjs.options, not here.
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 * @private
 */
vjs.Player.prototype.options_ = vjs.options;

/**
 * Destroys the video player and does any necessary cleanup
 *
 *     myPlayer.dispose();
 *
 * This is especially helpful if you are dynamically adding and removing videos
 * to/from the DOM.
 */
vjs.Player.prototype.dispose = function(){
  this.trigger('dispose');
  // prevent dispose from being called twice
  this.off('dispose');

  // Kill reference to this player
  vjs.players[this.id_] = null;
  if (this.tag && this.tag['player']) { this.tag['player'] = null; }
  if (this.el_ && this.el_['player']) { this.el_['player'] = null; }

  if (this.tech) { this.tech.dispose(); }

  // Component dispose
  vjs.Component.prototype.dispose.call(this);
};

vjs.Player.prototype.getTagSettings = function(tag){
  var tagOptions,
      dataSetup,
      options = {
        'sources': []
        //'tracks': []
      };

  tagOptions = vjs.getElementAttributes(tag);
  dataSetup = tagOptions['data-setup'];

  // Check if data-setup attr exists.
  if (dataSetup !== null){
    // Parse options JSON
    // If empty string, make it a parsable json object.
    vjs.obj.merge(tagOptions, vjs.JSON.parse(dataSetup || '{}'));
  }

  vjs.obj.merge(options, tagOptions);

  // Get tag children settings
  if (tag.hasChildNodes()) {
    var children, child, childName, i, j;

    children = tag.childNodes;

    for (i=0,j=children.length; i<j; i++) {
      child = children[i];
      // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
      childName = child.nodeName.toLowerCase();
      if (childName === 'source') {
        options['sources'].push(vjs.getElementAttributes(child));
      }
    }
  }

  return options;
};

vjs.Player.prototype.createEl = function(){
  var
    el = this.el_ = vjs.Component.prototype.createEl.call(this, 'div'),
    tag = this.tag,
    attrs;

  // Remove width/height attrs from tag so CSS can make it 100% width/height
  tag.removeAttribute('width');
  tag.removeAttribute('height');
  // Empty video tag tracks so the built-in player doesn't use them also.
  // This may not be fast enough to stop HTML5 browsers from reading the tags
  // so we'll need to turn off any default tracks if we're manually doing
  // captions and subtitles. videoElement.textTracks
  if (tag.hasChildNodes()) {
    var nodes, nodesLength, i, node, nodeName, removeNodes;

    nodes = tag.childNodes;
    nodesLength = nodes.length;
    removeNodes = [];

    while (nodesLength--) {
      node = nodes[nodesLength];
      nodeName = node.nodeName.toLowerCase();
      if (nodeName === 'track') {
        removeNodes.push(node);
      }
    }

    for (i=0; i<removeNodes.length; i++) {
      tag.removeChild(removeNodes[i]);
    }
  }

  // Copy over all the attributes from the tag, including ID and class
  // ID will now reference player box, not the video tag
  attrs = vjs.getElementAttributes(tag);
  vjs.obj.each(attrs, function(attr) {
    // workaround so we don't totally break IE7
    // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
    if (attr == 'class') {
      el.className = attrs[attr];
    } else {
      el.setAttribute(attr, attrs[attr]);
    }
  });

  // Update tag id/class for use as HTML5 playback tech
  // Might think we should do this after embedding in container so .vjs-tech class
  // doesn't flash 100% width/height, but class only applies with .video-js parent
  tag.id += '_html5_api';
  tag.className = 'vjs-tech';

  // Make player findable on elements
  tag['player'] = el['player'] = this;
  // Default state of video is paused
  this.addClass('vjs-paused');

  // Make box use width/height of tag, or rely on default implementation
  // Enforce with CSS since width/height attrs don't work on divs
  this.width(this.options_['width'], true); // (true) Skip resize listener on load
  this.height(this.options_['height'], true);

  // vjs.insertFirst seems to cause the networkState to flicker from 3 to 2, so
  // keep track of the original for later so we can know if the source originally failed
  tag.initNetworkState_ = tag.networkState;

  // Wrap video tag in div (el/box) container
  if (tag.parentNode) {
    tag.parentNode.insertBefore(el, tag);
  }
  vjs.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

  // The event listeners need to be added before the children are added
  // in the component init because the tech (loaded with mediaLoader) may
  // fire events, like loadstart, that these events need to capture.
  // Long term it might be better to expose a way to do this in component.init
  // like component.initEventListeners() that runs between el creation and
  // adding children
  this.el_ = el;
  this.on('loadstart', this.onLoadStart);
  this.on('waiting', this.onWaiting);
  this.on(['canplay', 'canplaythrough', 'playing', 'ended'], this.onWaitEnd);
  this.on('seeking', this.onSeeking);
  this.on('seeked', this.onSeeked);
  this.on('ended', this.onEnded);
  this.on('play', this.onPlay);
  this.on('firstplay', this.onFirstPlay);
  this.on('pause', this.onPause);
  this.on('progress', this.onProgress);
  this.on('durationchange', this.onDurationChange);
  this.on('fullscreenchange', this.onFullscreenChange);

  return el;
};

// /* Media Technology (tech)
// ================================================================================ */
// Load/Create an instance of playback technlogy including element and API methods
// And append playback element in player div.
vjs.Player.prototype.loadTech = function(techName, source){

  // Pause and remove current playback technology
  if (this.tech) {
    this.unloadTech();
  }

  // get rid of the HTML5 video tag as soon as we are using another tech
  if (techName !== 'Html5' && this.tag) {
    vjs.Html5.disposeMediaElement(this.tag);
    this.tag = null;
  }

  this.techName = techName;

  // Turn off API access because we're loading a new tech that might load asynchronously
  this.isReady_ = false;

  var techReady = function(){
    this.player_.triggerReady();
  };

  // Grab tech-specific options from player options and add source and parent element to use.
  var techOptions = vjs.obj.merge({ 'source': source, 'parentEl': this.el_ }, this.options_[techName.toLowerCase()]);

  if (source) {
    this.currentType_ = source.type;
    if (source.src == this.cache_.src && this.cache_.currentTime > 0) {
      techOptions['startTime'] = this.cache_.currentTime;
    }

    this.cache_.src = source.src;
  }

  // Initialize tech instance
  this.tech = new window['videojs'][techName](this, techOptions);

  this.tech.ready(techReady);
};

vjs.Player.prototype.unloadTech = function(){
  this.isReady_ = false;

  this.tech.dispose();

  this.tech = false;
};

// There's many issues around changing the size of a Flash (or other plugin) object.
// First is a plugin reload issue in Firefox that has been around for 11 years: https://bugzilla.mozilla.org/show_bug.cgi?id=90268
// Then with the new fullscreen API, Mozilla and webkit browsers will reload the flash object after going to fullscreen.
// To get around this, we're unloading the tech, caching source and currentTime values, and reloading the tech once the plugin is resized.
// reloadTech: function(betweenFn){
//   vjs.log('unloadingTech')
//   this.unloadTech();
//   vjs.log('unloadedTech')
//   if (betweenFn) { betweenFn.call(); }
//   vjs.log('LoadingTech')
//   this.loadTech(this.techName, { src: this.cache_.src })
//   vjs.log('loadedTech')
// },

// /* Player event handlers (how the player reacts to certain events)
// ================================================================================ */

/**
 * Fired when the user agent begins looking for media data
 * @event loadstart
 */
vjs.Player.prototype.onLoadStart = function() {
  // TODO: Update to use `emptied` event instead. See #1277.

  // reset the error state
  this.error(null);

  // If it's already playing we want to trigger a firstplay event now.
  // The firstplay event relies on both the play and loadstart events
  // which can happen in any order for a new source
  if (!this.paused()) {
    this.trigger('firstplay');
  } else {
    // reset the hasStarted state
    this.hasStarted(false);
    this.one('play', function(){
      this.hasStarted(true);
    });
  }
};

vjs.Player.prototype.hasStarted_ = false;

vjs.Player.prototype.hasStarted = function(hasStarted){
  if (hasStarted !== undefined) {
    // only update if this is a new value
    if (this.hasStarted_ !== hasStarted) {
      this.hasStarted_ = hasStarted;
      if (hasStarted) {
        this.addClass('vjs-has-started');
        // trigger the firstplay event if this newly has played
        this.trigger('firstplay');
      } else {
        this.removeClass('vjs-has-started');
      }
    }
    return this;
  }
  return this.hasStarted_;
};

/**
 * Fired when the player has initial duration and dimension information
 * @event loadedmetadata
 */
vjs.Player.prototype.onLoadedMetaData;

/**
 * Fired when the player has downloaded data at the current playback position
 * @event loadeddata
 */
vjs.Player.prototype.onLoadedData;

/**
 * Fired when the player has finished downloading the source data
 * @event loadedalldata
 */
vjs.Player.prototype.onLoadedAllData;

/**
 * Fired whenever the media begins or resumes playback
 * @event play
 */
vjs.Player.prototype.onPlay = function(){
  this.removeClass('vjs-paused');
  this.addClass('vjs-playing');
};

/**
 * Fired whenever the media begins wating
 * @event waiting
 */
vjs.Player.prototype.onWaiting = function(){
  this.addClass('vjs-waiting');
};

/**
 * A handler for events that signal that waiting has eneded
 * which is not consistent between browsers. See #1351
 * @private
 */
vjs.Player.prototype.onWaitEnd = function(){
  this.removeClass('vjs-waiting');
};

/**
 * Fired whenever the player is jumping to a new time
 * @event seeking
 */
vjs.Player.prototype.onSeeking = function(){
  this.addClass('vjs-seeking');
};

/**
 * Fired when the player has finished jumping to a new time
 * @event seeked
 */
vjs.Player.prototype.onSeeked = function(){
  this.removeClass('vjs-seeking');
};

/**
 * Fired the first time a video is played
 *
 * Not part of the HLS spec, and we're not sure if this is the best
 * implementation yet, so use sparingly. If you don't have a reason to
 * prevent playback, use `myPlayer.one('play');` instead.
 *
 * @event firstplay
 */
vjs.Player.prototype.onFirstPlay = function(){
    //If the first starttime attribute is specified
    //then we will start at the given offset in seconds
    if(this.options_['starttime']){
      this.currentTime(this.options_['starttime']);
    }

    this.addClass('vjs-has-started');
};

/**
 * Fired whenever the media has been paused
 * @event pause
 */
vjs.Player.prototype.onPause = function(){
  this.removeClass('vjs-playing');
  this.addClass('vjs-paused');
};

/**
 * Fired when the current playback position has changed
 *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 * @event timeupdate
 */
vjs.Player.prototype.onTimeUpdate;

/**
 * Fired while the user agent is downloading media data
 * @event progress
 */
vjs.Player.prototype.onProgress = function(){
  // Add custom event for when source is finished downloading.
  if (this.bufferedPercent() == 1) {
    this.trigger('loadedalldata');
  }
};

/**
 * Fired when the end of the media resource is reached (currentTime == duration)
 * @event ended
 */
vjs.Player.prototype.onEnded = function(){
  if (this.options_['loop']) {
    this.currentTime(0);
    this.play();
  } else if (!this.paused()) {
    this.pause();
  }
};

/**
 * Fired when the duration of the media resource is first known or changed
 * @event durationchange
 */
vjs.Player.prototype.onDurationChange = function(){
  // Allows for cacheing value instead of asking player each time.
  // We need to get the techGet response and check for a value so we don't
  // accidentally cause the stack to blow up.
  var duration = this.techGet('duration');
  if (duration) {
    if (duration < 0) {
      duration = Infinity;
    }
    this.duration(duration);
    // Determine if the stream is live and propagate styles down to UI.
    if (duration === Infinity) {
      this.addClass('vjs-live');
    } else {
      this.removeClass('vjs-live');
    }
  }
};

/**
 * Fired when the volume changes
 * @event volumechange
 */
vjs.Player.prototype.onVolumeChange;

/**
 * Fired when the player switches in or out of fullscreen mode
 * @event fullscreenchange
 */
vjs.Player.prototype.onFullscreenChange = function() {
  if (this.isFullscreen()) {
    this.addClass('vjs-fullscreen');
  } else {
    this.removeClass('vjs-fullscreen');
  }
};

// /* Player API
// ================================================================================ */

/**
 * Object for cached values.
 * @private
 */
vjs.Player.prototype.cache_;

vjs.Player.prototype.getCache = function(){
  return this.cache_;
};

// Pass values to the playback tech
vjs.Player.prototype.techCall = function(method, arg){
  // If it's not ready yet, call method when it is
  if (this.tech && !this.tech.isReady_) {
    this.tech.ready(function(){
      this[method](arg);
    });

  // Otherwise call method now
  } else {
    try {
      this.tech[method](arg);
    } catch(e) {
      vjs.log(e);
      throw e;
    }
  }
};

// Get calls can't wait for the tech, and sometimes don't need to.
vjs.Player.prototype.techGet = function(method){
  if (this.tech && this.tech.isReady_) {

    // Flash likes to die and reload when you hide or reposition it.
    // In these cases the object methods go away and we get errors.
    // When that happens we'll catch the errors and inform tech that it's not ready any more.
    try {
      return this.tech[method]();
    } catch(e) {
      // When building additional tech libs, an expected method may not be defined yet
      if (this.tech[method] === undefined) {
        vjs.log('Video.js: ' + method + ' method not defined for '+this.techName+' playback technology.', e);
      } else {
        // When a method isn't available on the object it throws a TypeError
        if (e.name == 'TypeError') {
          vjs.log('Video.js: ' + method + ' unavailable on '+this.techName+' playback technology element.', e);
          this.tech.isReady_ = false;
        } else {
          vjs.log(e);
        }
      }
      throw e;
    }
  }

  return;
};

/**
 * start media playback
 *
 *     myPlayer.play();
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.play = function(){
  this.techCall('play');
  return this;
};

/**
 * Pause the video playback
 *
 *     myPlayer.pause();
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.pause = function(){
  this.techCall('pause');
  return this;
};

/**
 * Check if the player is paused
 *
 *     var isPaused = myPlayer.paused();
 *     var isPlaying = !myPlayer.paused();
 *
 * @return {Boolean} false if the media is currently playing, or true otherwise
 */
vjs.Player.prototype.paused = function(){
  // The initial state of paused should be true (in Safari it's actually false)
  return (this.techGet('paused') === false) ? false : true;
};

/**
 * Get or set the current time (in seconds)
 *
 *     // get
 *     var whereYouAt = myPlayer.currentTime();
 *
 *     // set
 *     myPlayer.currentTime(120); // 2 minutes into the video
 *
 * @param  {Number|String=} seconds The time to seek to
 * @return {Number}        The time in seconds, when not setting
 * @return {vjs.Player}    self, when the current time is set
 */
vjs.Player.prototype.currentTime = function(seconds){
  if (seconds !== undefined) {

    this.techCall('setCurrentTime', seconds);

    return this;
  }

  // cache last currentTime and return. default to 0 seconds
  //
  // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
  // currentTime when scrubbing, but may not provide much performace benefit afterall.
  // Should be tested. Also something has to read the actual current time or the cache will
  // never get updated.
  return this.cache_.currentTime = (this.techGet('currentTime') || 0);
};

/**
 * Get the length in time of the video in seconds
 *
 *     var lengthOfVideo = myPlayer.duration();
 *
 * **NOTE**: The video must have started loading before the duration can be
 * known, and in the case of Flash, may not be known until the video starts
 * playing.
 *
 * @return {Number} The duration of the video in seconds
 */
vjs.Player.prototype.duration = function(seconds){
  if (seconds !== undefined) {

    // cache the last set value for optimiized scrubbing (esp. Flash)
    this.cache_.duration = parseFloat(seconds);

    return this;
  }

  if (this.cache_.duration === undefined) {
    this.onDurationChange();
  }

  return this.cache_.duration || 0;
};

/**
 * Calculates how much time is left.
 *
 *     var timeLeft = myPlayer.remainingTime();
 *
 * Not a native video element function, but useful
 * @return {Number} The time remaining in seconds
 */
vjs.Player.prototype.remainingTime = function(){
  return this.duration() - this.currentTime();
};

// http://dev.w3.org/html5/spec/video.html#dom-media-buffered
// Buffered returns a timerange object.
// Kind of like an array of portions of the video that have been downloaded.

/**
 * Get a TimeRange object with the times of the video that have been downloaded
 *
 * If you just want the percent of the video that's been downloaded,
 * use bufferedPercent.
 *
 *     // Number of different ranges of time have been buffered. Usually 1.
 *     numberOfRanges = bufferedTimeRange.length,
 *
 *     // Time in seconds when the first range starts. Usually 0.
 *     firstRangeStart = bufferedTimeRange.start(0),
 *
 *     // Time in seconds when the first range ends
 *     firstRangeEnd = bufferedTimeRange.end(0),
 *
 *     // Length in seconds of the first time range
 *     firstRangeLength = firstRangeEnd - firstRangeStart;
 *
 * @return {Object} A mock TimeRange object (following HTML spec)
 */
vjs.Player.prototype.buffered = function(){
  var buffered = this.techGet('buffered');

  if (!buffered || !buffered.length) {
    buffered = vjs.createTimeRange(0,0);
  }

  return buffered;
};

/**
 * Get the percent (as a decimal) of the video that's been downloaded
 *
 *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
 *
 * 0 means none, 1 means all.
 * (This method isn't in the HTML5 spec, but it's very convenient)
 *
 * @return {Number} A decimal between 0 and 1 representing the percent
 */
vjs.Player.prototype.bufferedPercent = function(){
  var duration = this.duration(),
      buffered = this.buffered(),
      bufferedDuration = 0,
      start, end;

  if (!duration) {
    return 0;
  }

  for (var i=0; i<buffered.length; i++){
    start = buffered.start(i);
    end   = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
};

/**
 * Get the ending time of the last buffered time range
 *
 * This is used in the progress bar to encapsulate all time ranges.
 * @return {Number} The end of the last buffered time range
 */
vjs.Player.prototype.bufferedEnd = function(){
  var buffered = this.buffered(),
      duration = this.duration(),
      end = buffered.end(buffered.length-1);

  if (end > duration) {
    end = duration;
  }

  return end;
};

/**
 * Get or set the current volume of the media
 *
 *     // get
 *     var howLoudIsIt = myPlayer.volume();
 *
 *     // set
 *     myPlayer.volume(0.5); // Set volume to half
 *
 * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
 *
 * @param  {Number} percentAsDecimal The new volume as a decimal percent
 * @return {Number}                  The current volume, when getting
 * @return {vjs.Player}              self, when setting
 */
vjs.Player.prototype.volume = function(percentAsDecimal){
  var vol;

  if (percentAsDecimal !== undefined) {
    vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
    this.cache_.volume = vol;
    this.techCall('setVolume', vol);
    vjs.setLocalStorage('volume', vol);
    return this;
  }

  // Default to 1 when returning current volume.
  vol = parseFloat(this.techGet('volume'));
  return (isNaN(vol)) ? 1 : vol;
};


/**
 * Get the current muted state, or turn mute on or off
 *
 *     // get
 *     var isVolumeMuted = myPlayer.muted();
 *
 *     // set
 *     myPlayer.muted(true); // mute the volume
 *
 * @param  {Boolean=} muted True to mute, false to unmute
 * @return {Boolean} True if mute is on, false if not, when getting
 * @return {vjs.Player} self, when setting mute
 */
vjs.Player.prototype.muted = function(muted){
  if (muted !== undefined) {
    this.techCall('setMuted', muted);
    return this;
  }
  return this.techGet('muted') || false; // Default to false
};

// Check if current tech can support native fullscreen
// (e.g. with built in controls lik iOS, so not our flash swf)
vjs.Player.prototype.supportsFullScreen = function(){
  return this.techGet('supportsFullScreen') || false;
};

/**
 * is the player in fullscreen
 * @type {Boolean}
 * @private
 */
vjs.Player.prototype.isFullscreen_ = false;

/**
 * Check if the player is in fullscreen mode
 *
 *     // get
 *     var fullscreenOrNot = myPlayer.isFullscreen();
 *
 *     // set
 *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
 *
 * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
 * property and instead document.fullscreenElement is used. But isFullscreen is
 * still a valuable property for internal player workings.
 *
 * @param  {Boolean=} isFS Update the player's fullscreen state
 * @return {Boolean} true if fullscreen, false if not
 * @return {vjs.Player} self, when setting
 */
vjs.Player.prototype.isFullscreen = function(isFS){
  if (isFS !== undefined) {
    this.isFullscreen_ = !!isFS;
    return this;
  }
  return this.isFullscreen_;
};

/**
 * Old naming for isFullscreen()
 * @deprecated for lowercase 's' version
 */
vjs.Player.prototype.isFullScreen = function(isFS){
  vjs.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
  return this.isFullscreen(isFS);
};

/**
 * Increase the size of the video to full screen
 *
 *     myPlayer.requestFullscreen();
 *
 * In some browsers, full screen is not supported natively, so it enters
 * "full window mode", where the video fills the browser window.
 * In browsers and devices that support native full screen, sometimes the
 * browser's default controls will be shown, and not the Video.js custom skin.
 * This includes most mobile devices (iOS, Android) and older versions of
 * Safari.
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.requestFullscreen = function(){
  var fsApi = vjs.browser.fullscreenAPI;

  this.isFullscreen(true);

  if (fsApi) {
    // the browser supports going fullscreen at the element level so we can
    // take the controls fullscreen as well as the video

    // Trigger fullscreenchange event after change
    // We have to specifically add this each time, and remove
    // when cancelling fullscreen. Otherwise if there's multiple
    // players on a page, they would all be reacting to the same fullscreen
    // events
    vjs.on(document, fsApi['fullscreenchange'], vjs.bind(this, function(e){
      this.isFullscreen(document[fsApi.fullscreenElement]);

      // If cancelling fullscreen, remove event listener.
      if (this.isFullscreen() === false) {
        vjs.off(document, fsApi['fullscreenchange'], arguments.callee);
      }

      this.trigger('fullscreenchange');
    }));

    this.el_[fsApi.requestFullscreen]();

  } else if (this.tech.supportsFullScreen()) {
    // we can't take the video.js controls fullscreen but we can go fullscreen
    // with native controls
    this.techCall('enterFullScreen');
  } else {
    // fullscreen isn't supported so we'll just stretch the video element to
    // fill the viewport
    this.enterFullWindow();
    this.trigger('fullscreenchange');
  }

  return this;
};

/**
 * Old naming for requestFullscreen
 * @deprecated for lower case 's' version
 */
vjs.Player.prototype.requestFullScreen = function(){
  vjs.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
  return this.requestFullscreen();
};


/**
 * Return the video to its normal size after having been in full screen mode
 *
 *     myPlayer.exitFullscreen();
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.exitFullscreen = function(){
  var fsApi = vjs.browser.fullscreenAPI;
  this.isFullscreen(false);

  // Check for browser element fullscreen support
  if (fsApi) {
    document[fsApi.exitFullscreen]();
  } else if (this.tech.supportsFullScreen()) {
   this.techCall('exitFullScreen');
  } else {
   this.exitFullWindow();
   this.trigger('fullscreenchange');
  }

  return this;
};

/**
 * Old naming for exitFullscreen
 * @deprecated for exitFullscreen
 */
vjs.Player.prototype.cancelFullScreen = function(){
  vjs.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
  return this.exitFullscreen();
};

// When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
vjs.Player.prototype.enterFullWindow = function(){
  this.isFullWindow = true;

  // Storing original doc overflow value to return to when fullscreen is off
  this.docOrigOverflow = document.documentElement.style.overflow;

  // Add listener for esc key to exit fullscreen
  vjs.on(document, 'keydown', vjs.bind(this, this.fullWindowOnEscKey));

  // Hide any scroll bars
  document.documentElement.style.overflow = 'hidden';

  // Apply fullscreen styles
  vjs.addClass(document.body, 'vjs-full-window');

  this.trigger('enterFullWindow');
};
vjs.Player.prototype.fullWindowOnEscKey = function(event){
  if (event.keyCode === 27) {
    if (this.isFullscreen() === true) {
      this.exitFullscreen();
    } else {
      this.exitFullWindow();
    }
  }
};

vjs.Player.prototype.exitFullWindow = function(){
  this.isFullWindow = false;
  vjs.off(document, 'keydown', this.fullWindowOnEscKey);

  // Unhide scroll bars.
  document.documentElement.style.overflow = this.docOrigOverflow;

  // Remove fullscreen styles
  vjs.removeClass(document.body, 'vjs-full-window');

  // this.positionAll();
  this.trigger('exitFullWindow');
};

vjs.Player.prototype.selectSource = function(sources){

  // Loop through each playback technology in the options order
  for (var i=0,j=this.options_['techOrder'];i<j.length;i++) {
    var techName = vjs.capitalize(j[i]),
        tech = window['videojs'][techName];

    // Check if the current tech is defined before continuing
    if (!tech) {
      vjs.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      continue;
    }

    // Check if the browser supports this technology
    if (tech.isSupported()) {
      // Loop through each source object
      for (var a=0,b=sources;a<b.length;a++) {
        var source = b[a];

        // Check if source can be played with this technology
        if (tech['canPlaySource'](source)) {
          return { source: source, tech: techName };
        }
      }
    }
  }

  return false;
};

/**
 * The source function updates the video source
 *
 * There are three types of variables you can pass as the argument.
 *
 * **URL String**: A URL to the the video file. Use this method if you are sure
 * the current playback technology (HTML5/Flash) can support the source you
 * provide. Currently only MP4 files can be used in both HTML5 and Flash.
 *
 *     myPlayer.src("http://www.example.com/path/to/video.mp4");
 *
 * **Source Object (or element):** A javascript object containing information
 * about the source file. Use this method if you want the player to determine if
 * it can support the file using the type information.
 *
 *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
 *
 * **Array of Source Objects:** To provide multiple versions of the source so
 * that it can be played using HTML5 across browsers you can use an array of
 * source objects. Video.js will detect which version is supported and load that
 * file.
 *
 *     myPlayer.src([
 *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
 *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
 *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
 *     ]);
 *
 * @param  {String|Object|Array=} source The source URL, object, or array of sources
 * @return {String} The current video source when getting
 * @return {String} The player when setting
 */
vjs.Player.prototype.src = function(source){
  if (source === undefined) {
    return this.techGet('src');
  }

  // case: Array of source objects to choose from and pick the best to play
  if (vjs.obj.isArray(source)) {
    this.sourceList_(source);

  // case: URL String (http://myvideo...)
  } else if (typeof source === 'string') {
    // create a source object from the string
    this.src({ src: source });

  // case: Source object { src: '', type: '' ... }
  } else if (source instanceof Object) {
    // check if the source has a type and the loaded tech cannot play the source
    // if there's no type we'll just try the current tech
    if (source.type && !window['videojs'][this.techName]['canPlaySource'](source)) {
      // create a source list with the current source and send through
      // the tech loop to check for a compatible technology
      this.sourceList_([source]);
    } else {
      this.cache_.src = source.src;
      this.currentType_ = source.type || '';

      // wait until the tech is ready to set the source
      this.ready(function(){
        this.techCall('src', source.src);

        if (this.options_['preload'] == 'auto') {
          this.load();
        }

        if (this.options_['autoplay']) {
          this.play();
        }
      });
    }
  }

  return this;
};

/**
 * Handle an array of source objects
 * @param  {[type]} sources Array of source objects
 * @private
 */
vjs.Player.prototype.sourceList_ = function(sources){
  var sourceTech = this.selectSource(sources),
      errorTimeout;

  if (sourceTech) {
    if (sourceTech.tech === this.techName) {
      // if this technology is already loaded, set the source
      this.src(sourceTech.source);
    } else {
      // load this technology with the chosen source
      this.loadTech(sourceTech.tech, sourceTech.source);
    }
  } else {
    // We need to wrap this in a timeout to give folks a chance to add error event handlers
    errorTimeout = setTimeout(vjs.bind(this, function() {
      this.error({ code: 4, message: this.localize(this.options()['notSupportedMessage']) });
    }), 0);

    // we could not find an appropriate tech, but let's still notify the delegate that this is it
    // this needs a better comment about why this is needed
    this.triggerReady();

    this.on('dispose', function() {
      clearTimeout(errorTimeout);
    });
  }
};

/**
 * Begin loading the src data.
 * @return {vjs.Player} Returns the player
 */
vjs.Player.prototype.load = function(){
  this.techCall('load');
  return this;
};

/**
 * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
 * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
 * @return {String} The current source
 */
vjs.Player.prototype.currentSrc = function(){
  return this.techGet('currentSrc') || this.cache_.src || '';
};

/**
 * Get the current source type e.g. video/mp4
 * This can allow you rebuild the current source object so that you could load the same
 * source and tech later
 * @return {String} The source MIME type
 */
vjs.Player.prototype.currentType = function(){
    return this.currentType_ || '';
};

/**
 * Get or set the preload attribute.
 * @return {String} The preload attribute value when getting
 * @return {vjs.Player} Returns the player when setting
 */
vjs.Player.prototype.preload = function(value){
  if (value !== undefined) {
    this.techCall('setPreload', value);
    this.options_['preload'] = value;
    return this;
  }
  return this.techGet('preload');
};

/**
 * Get or set the autoplay attribute.
 * @return {String} The autoplay attribute value when getting
 * @return {vjs.Player} Returns the player when setting
 */
vjs.Player.prototype.autoplay = function(value){
  if (value !== undefined) {
    this.techCall('setAutoplay', value);
    this.options_['autoplay'] = value;
    return this;
  }
  return this.techGet('autoplay', value);
};

/**
 * Get or set the loop attribute on the video element.
 * @return {String} The loop attribute value when getting
 * @return {vjs.Player} Returns the player when setting
 */
vjs.Player.prototype.loop = function(value){
  if (value !== undefined) {
    this.techCall('setLoop', value);
    this.options_['loop'] = value;
    return this;
  }
  return this.techGet('loop');
};



/**
 * Whether or not the controls are showing
 * @type {Boolean}
 * @private
 */
vjs.Player.prototype.controls_;

/**
 * Get or set whether or not the controls are showing.
 * @param  {Boolean} controls Set controls to showing or not
 * @return {Boolean}    Controls are showing
 */
vjs.Player.prototype.controls = function(bool){
  if (bool !== undefined) {
    bool = !!bool; // force boolean
    // Don't trigger a change event unless it actually changed
    if (this.controls_ !== bool) {
      this.controls_ = bool;
      if (bool) {
        this.removeClass('vjs-controls-disabled');
        this.addClass('vjs-controls-enabled');
        this.trigger('controlsenabled');
      } else {
        this.removeClass('vjs-controls-enabled');
        this.addClass('vjs-controls-disabled');
        this.trigger('controlsdisabled');
      }
    }
    return this;
  }
  return this.controls_;
};

vjs.Player.prototype.usingNativeControls_;

/**
 * Toggle native controls on/off. Native controls are the controls built into
 * devices (e.g. default iPhone controls), Flash, or other techs
 * (e.g. Vimeo Controls)
 *
 * **This should only be set by the current tech, because only the tech knows
 * if it can support native controls**
 *
 * @param  {Boolean} bool    True signals that native controls are on
 * @return {vjs.Player}      Returns the player
 * @private
 */
vjs.Player.prototype.usingNativeControls = function(bool){
  if (bool !== undefined) {
    bool = !!bool; // force boolean
    // Don't trigger a change event unless it actually changed
    if (this.usingNativeControls_ !== bool) {
      this.usingNativeControls_ = bool;
      if (bool) {
        this.addClass('vjs-using-native-controls');

        /**
         * player is using the native device controls
         *
         * @event usingnativecontrols
         * @memberof vjs.Player
         * @instance
         * @private
         */
        this.trigger('usingnativecontrols');
      } else {
        this.removeClass('vjs-using-native-controls');

        /**
         * player is using the custom HTML controls
         *
         * @event usingcustomcontrols
         * @memberof vjs.Player
         * @instance
         * @private
         */
        this.trigger('usingcustomcontrols');
      }
    }
    return this;
  }
  return this.usingNativeControls_;
};

/**
 * Store the current media error
 * @type {Object}
 * @private
 */
vjs.Player.prototype.error_ = null;

/**
 * Set or get the current MediaError
 * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
 * @return {vjs.MediaError|null}     when getting
 * @return {vjs.Player}              when setting
 */
vjs.Player.prototype.error = function(err){
  if (err === undefined) {
    return this.error_;
  }

  // restoring to default
  if (err === null) {
    this.error_ = err;
    this.removeClass('vjs-error');
    return this;
  }

  // error instance
  if (err instanceof vjs.MediaError) {
    this.error_ = err;
  } else {
    this.error_ = new vjs.MediaError(err);
  }

  // fire an error event on the player
  this.trigger('error');

  // add the vjs-error classname to the player
  this.addClass('vjs-error');

  // log the name of the error type and any message
  // ie8 just logs "[object object]" if you just log the error object
  vjs.log.error('(CODE:'+this.error_.code+' '+vjs.MediaError.errorTypes[this.error_.code]+')', this.error_.message, this.error_);

  return this;
};

/**
 * Returns whether or not the player is in the "ended" state.
 * @return {Boolean} True if the player is in the ended state, false if not.
 */
vjs.Player.prototype.ended = function(){ return this.techGet('ended'); };

/**
 * Returns whether or not the player is in the "seeking" state.
 * @return {Boolean} True if the player is in the seeking state, false if not.
 */
vjs.Player.prototype.seeking = function(){ return this.techGet('seeking'); };

// When the player is first initialized, trigger activity so components
// like the control bar show themselves if needed
vjs.Player.prototype.userActivity_ = true;
vjs.Player.prototype.reportUserActivity = function(event){
  this.userActivity_ = true;
};

vjs.Player.prototype.userActive_ = true;
vjs.Player.prototype.userActive = function(bool){
  if (bool !== undefined) {
    bool = !!bool;
    if (bool !== this.userActive_) {
      this.userActive_ = bool;
      if (bool) {
        // If the user was inactive and is now active we want to reset the
        // inactivity timer
        this.userActivity_ = true;
        this.removeClass('vjs-user-inactive');
        this.addClass('vjs-user-active');
        this.trigger('useractive');
      } else {
        // We're switching the state to inactive manually, so erase any other
        // activity
        this.userActivity_ = false;

        // Chrome/Safari/IE have bugs where when you change the cursor it can
        // trigger a mousemove event. This causes an issue when you're hiding
        // the cursor when the user is inactive, and a mousemove signals user
        // activity. Making it impossible to go into inactive mode. Specifically
        // this happens in fullscreen when we really need to hide the cursor.
        //
        // When this gets resolved in ALL browsers it can be removed
        // https://code.google.com/p/chromium/issues/detail?id=103041
        if(this.tech) {
          this.tech.one('mousemove', function(e){
            e.stopPropagation();
            e.preventDefault();
          });
        }

        this.removeClass('vjs-user-active');
        this.addClass('vjs-user-inactive');
        this.trigger('userinactive');
      }
    }
    return this;
  }
  return this.userActive_;
};

vjs.Player.prototype.listenForUserActivity = function(){
  var onActivity, onMouseMove, onMouseDown, mouseInProgress, onMouseUp,
      activityCheck, inactivityTimeout, lastMoveX, lastMoveY;

  onActivity = vjs.bind(this, this.reportUserActivity);

  onMouseMove = function(e) {
    // #1068 - Prevent mousemove spamming
    // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
    if(e.screenX != lastMoveX || e.screenY != lastMoveY) {
      lastMoveX = e.screenX;
      lastMoveY = e.screenY;
      onActivity();
    }
  };

  onMouseDown = function() {
    onActivity();
    // For as long as the they are touching the device or have their mouse down,
    // we consider them active even if they're not moving their finger or mouse.
    // So we want to continue to update that they are active
    clearInterval(mouseInProgress);
    // Setting userActivity=true now and setting the interval to the same time
    // as the activityCheck interval (250) should ensure we never miss the
    // next activityCheck
    mouseInProgress = setInterval(onActivity, 250);
  };

  onMouseUp = function(event) {
    onActivity();
    // Stop the interval that maintains activity if the mouse/touch is down
    clearInterval(mouseInProgress);
  };

  // Any mouse movement will be considered user activity
  this.on('mousedown', onMouseDown);
  this.on('mousemove', onMouseMove);
  this.on('mouseup', onMouseUp);

  // Listen for keyboard navigation
  // Shouldn't need to use inProgress interval because of key repeat
  this.on('keydown', onActivity);
  this.on('keyup', onActivity);

  // Run an interval every 250 milliseconds instead of stuffing everything into
  // the mousemove/touchmove function itself, to prevent performance degradation.
  // `this.reportUserActivity` simply sets this.userActivity_ to true, which
  // then gets picked up by this loop
  // http://ejohn.org/blog/learning-from-twitter/
  activityCheck = setInterval(vjs.bind(this, function() {
    // Check to see if mouse/touch activity has happened
    if (this.userActivity_) {
      // Reset the activity tracker
      this.userActivity_ = false;

      // If the user state was inactive, set the state to active
      this.userActive(true);

      // Clear any existing inactivity timeout to start the timer over
      clearTimeout(inactivityTimeout);

      var timeout = this.options()['inactivityTimeout'];
      if (timeout > 0) {
          // In <timeout> milliseconds, if no more activity has occurred the
          // user will be considered inactive
          inactivityTimeout = setTimeout(vjs.bind(this, function () {
              // Protect against the case where the inactivityTimeout can trigger just
              // before the next user activity is picked up by the activityCheck loop
              // causing a flicker
              if (!this.userActivity_) {
                  this.userActive(false);
              }
          }), timeout);
      }
    }
  }), 250);

  // Clean up the intervals when we kill the player
  this.on('dispose', function(){
    clearInterval(activityCheck);
    clearTimeout(inactivityTimeout);
  });
};

/**
 * Gets or sets the current playback rate.
 * @param  {Boolean} rate   New playback rate to set.
 * @return {Number}         Returns the new playback rate when setting
 * @return {Number}         Returns the current playback rate when getting
 */
vjs.Player.prototype.playbackRate = function(rate) {
  if (rate !== undefined) {
    this.techCall('setPlaybackRate', rate);
    return this;
  }

  if (this.tech && this.tech['featuresPlaybackRate']) {
    return this.techGet('playbackRate');
  } else {
    return 1.0;
  }

};

/**
 * Store the current audio state
 * @type {Boolean}
 * @private
 */
vjs.Player.prototype.isAudio_ = false;

/**
 * Gets or sets the audio flag
 *
 * @param  {Boolean} bool    True signals that this is an audio player.
 * @return {Boolean}         Returns true if player is audio, false if not when getting
 * @return {vjs.Player}      Returns the player if setting
 * @private
 */
vjs.Player.prototype.isAudio = function(bool) {
  if (bool !== undefined) {
    this.isAudio_ = !!bool;
    return this;
  }

  return this.isAudio_;
};

// Methods to add support for
// networkState: function(){ return this.techCall('networkState'); },
// readyState: function(){ return this.techCall('readyState'); },
// initialTime: function(){ return this.techCall('initialTime'); },
// startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
// played: function(){ return this.techCall('played'); },
// seekable: function(){ return this.techCall('seekable'); },
// videoTracks: function(){ return this.techCall('videoTracks'); },
// audioTracks: function(){ return this.techCall('audioTracks'); },
// videoWidth: function(){ return this.techCall('videoWidth'); },
// videoHeight: function(){ return this.techCall('videoHeight'); },
// defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
// mediaGroup: function(){ return this.techCall('mediaGroup'); },
// controller: function(){ return this.techCall('controller'); },
// defaultMuted: function(){ return this.techCall('defaultMuted'); }

// TODO
// currentSrcList: the array of sources including other formats and bitrates
// playList: array of source lists in order of playback
/**
 * Container of main controls
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 * @extends vjs.Component
 */
vjs.ControlBar = vjs.Component.extend();

vjs.ControlBar.prototype.options_ = {
  loadEvent: 'play',
  children: {
    'playToggle': {},
    'progressControl': {},
    'fullscreenToggle': {},
    'volumeControl': {},
    'muteToggle': {},
    'playbackRateMenuButton': {}
  }
};

vjs.ControlBar.prototype.createEl = function(){
  return vjs.createEl('div', {
    className: 'vjs-control-bar'
  });
};

/**
 * Button to toggle between play and pause
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */
vjs.PlayToggle = vjs.Button.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Button.call(this, player, options);

    this.on(player, 'play', this.onPlay);
    this.on(player, 'pause', this.onPause);
  }
});

vjs.PlayToggle.prototype.buttonText = 'Play';

vjs.PlayToggle.prototype.buildCSSClass = function(){
  return 'vjs-play-control ' + vjs.Button.prototype.buildCSSClass.call(this);
};

// OnClick - Toggle between play and pause
vjs.PlayToggle.prototype.onClick = function(){
  if (this.player_.paused()) {
    this.player_.play();
  } else {
    this.player_.pause();
  }
};

  // OnPlay - Add the vjs-playing class to the element so it can change appearance
vjs.PlayToggle.prototype.onPlay = function(){
  this.removeClass('vjs-paused');
  this.addClass('vjs-playing');
  this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
};

  // OnPause - Add the vjs-paused class to the element so it can change appearance
vjs.PlayToggle.prototype.onPause = function(){
  this.removeClass('vjs-playing');
  this.addClass('vjs-paused');
  this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
};


/**
 * Toggle fullscreen video
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @extends vjs.Button
 */
vjs.FullscreenToggle = vjs.Button.extend({
  /**
   * @constructor
   * @memberof vjs.FullscreenToggle
   * @instance
   */
  init: function(player, options){
    vjs.Button.call(this, player, options);
  }
});

vjs.FullscreenToggle.prototype.buttonText = 'Fullscreen';

vjs.FullscreenToggle.prototype.buildCSSClass = function(){
  return 'vjs-fullscreen-control ' + vjs.Button.prototype.buildCSSClass.call(this);
};

vjs.FullscreenToggle.prototype.onClick = function(){
  // if (!this.player_.isFullscreen()) {
  //   this.player_.requestFullscreen();
  //   this.controlText_.innerHTML = this.localize('Non-Fullscreen');
  // } else {
  //   this.player_.exitFullscreen();
  //   this.controlText_.innerHTML = this.localize('Fullscreen');
  // }
};
/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.ProgressControl = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
  }
});

vjs.ProgressControl.prototype.options_ = {
  children: {
    'seekBar': {}
  }
};

vjs.ProgressControl.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-progress-control vjs-control'
  });
};

/**
 * Seek Bar and holder for the progress bars
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.SeekBar = vjs.Slider.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Slider.call(this, player, options);
    this.on(player, 'timeupdate', this.updateARIAAttributes);
    player.ready(vjs.bind(this, this.updateARIAAttributes));
  }
});

vjs.SeekBar.prototype.options_ = {
  children: {
    'loadProgressBar': {},
    'playProgressBar': {},
    'seekHandle': {}
  },
  'barName': 'playProgressBar',
  'handleName': 'seekHandle'
};

vjs.SeekBar.prototype.playerEvent = 'timeupdate';

vjs.SeekBar.prototype.createEl = function(){
  return vjs.Slider.prototype.createEl.call(this, 'div', {
    className: 'vjs-progress-holder',
    'aria-label': 'video progress bar'
  });
};

vjs.SeekBar.prototype.updateARIAAttributes = function(){
    // Allows for smooth scrubbing, when player can't keep up.
    var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
    this.el_.setAttribute('aria-valuenow',vjs.round(this.getPercent()*100, 2)); // machine readable value of progress bar (percentage complete)
    this.el_.setAttribute('aria-valuetext',vjs.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)
};

vjs.SeekBar.prototype.getPercent = function(){
  return this.player_.currentTime() / this.player_.duration();
};

vjs.SeekBar.prototype.onMouseDown = function(event){
  vjs.Slider.prototype.onMouseDown.call(this, event);

  this.player_.scrubbing = true;

  this.videoWasPlaying = !this.player_.paused();
  this.player_.pause();
};

vjs.SeekBar.prototype.onMouseMove = function(event){
  var newTime = this.calculateDistance(event) * this.player_.duration();

  // Don't let video end while scrubbing.
  if (newTime == this.player_.duration()) { newTime = newTime - 0.1; }

  // Set new time (tell player to seek to new time)
  this.player_.currentTime(newTime);
};

vjs.SeekBar.prototype.onMouseUp = function(event){
  vjs.Slider.prototype.onMouseUp.call(this, event);

  this.player_.scrubbing = false;
  if (this.videoWasPlaying) {
    this.player_.play();
  }
};

vjs.SeekBar.prototype.stepForward = function(){
  this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
};

vjs.SeekBar.prototype.stepBack = function(){
  this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users
};

/**
 * Shows load progress
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.LoadProgressBar = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
    this.on(player, 'progress', this.update);
  }
});

vjs.LoadProgressBar.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-load-progress',
    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
  });
};

vjs.LoadProgressBar.prototype.update = function(){
  var i, start, end, part,
      buffered = this.player_.buffered(),
      duration = this.player_.duration(),
      bufferedEnd = this.player_.bufferedEnd(),
      children = this.el_.children,
      // get the percent width of a time compared to the total end
      percentify = function (time, end){
        var percent = (time / end) || 0; // no NaN
        return (percent * 100) + '%';
      };

  // update the width of the progress bar
  this.el_.style.width = percentify(bufferedEnd, duration);

  // add child elements to represent the individual buffered time ranges
  for (i = 0; i < buffered.length; i++) {
    start = buffered.start(i),
    end = buffered.end(i),
    part = children[i];

    if (!part) {
      part = this.el_.appendChild(vjs.createEl())
    };

    // set the percent based on the width of the progress bar (bufferedEnd)
    part.style.left = percentify(start, bufferedEnd);
    part.style.width = percentify(end - start, bufferedEnd);
  };

  // remove unused buffered range elements
  for (i = children.length; i > buffered.length; i--) {
    this.el_.removeChild(children[i-1]);
  }
};

/**
 * Shows play progress
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.PlayProgressBar = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
  }
});

vjs.PlayProgressBar.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-play-progress',
    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
  });
};

/**
 * The Seek Handle shows the current position of the playhead during playback,
 * and can be dragged to adjust the playhead.
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.SeekHandle = vjs.SliderHandle.extend({
  init: function(player, options) {
    vjs.SliderHandle.call(this, player, options);
    this.on(player, 'timeupdate', this.updateContent);
  }
});

/**
 * The default value for the handle content, which may be read by screen readers
 *
 * @type {String}
 * @private
 */
vjs.SeekHandle.prototype.defaultValue = '00:00';

/** @inheritDoc */
vjs.SeekHandle.prototype.createEl = function() {
  return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
    className: 'vjs-seek-handle',
    'aria-live': 'off'
  });
};

vjs.SeekHandle.prototype.updateContent = function() {
  var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
  this.el_.innerHTML = '<span class="vjs-control-text">' + vjs.formatTime(time, this.player_.duration()) + '</span>';
};
/**
 * The component for controlling the volume level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.VolumeControl = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    // hide volume controls when they're not supported by the current tech
    if (player.tech && player.tech['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function(){
      if (player.tech['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }
});

vjs.VolumeControl.prototype.options_ = {
  children: {
    'volumeBar': {}
  }
};

vjs.VolumeControl.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-volume-control vjs-control'
  });
};

/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.VolumeBar = vjs.Slider.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Slider.call(this, player, options);
    this.on(player, 'volumechange', this.updateARIAAttributes);
    player.ready(vjs.bind(this, this.updateARIAAttributes));
  }
});

vjs.VolumeBar.prototype.updateARIAAttributes = function(){
  // Current value of volume bar as a percentage
  this.el_.setAttribute('aria-valuenow',vjs.round(this.player_.volume()*100, 2));
  this.el_.setAttribute('aria-valuetext',vjs.round(this.player_.volume()*100, 2)+'%');
};

vjs.VolumeBar.prototype.options_ = {
  children: {
    'volumeLevel': {},
    'volumeHandle': {}
  },
  'barName': 'volumeLevel',
  'handleName': 'volumeHandle'
};

vjs.VolumeBar.prototype.playerEvent = 'volumechange';

vjs.VolumeBar.prototype.createEl = function(){
  return vjs.Slider.prototype.createEl.call(this, 'div', {
    className: 'vjs-volume-bar',
    'aria-label': 'volume level'
  });
};

vjs.VolumeBar.prototype.onMouseMove = function(event) {
  if (this.player_.muted()) {
    this.player_.muted(false);
  }

  this.player_.volume(this.calculateDistance(event));
};

vjs.VolumeBar.prototype.getPercent = function(){
  if (this.player_.muted()) {
    return 0;
  } else {
    return this.player_.volume();
  }
};

vjs.VolumeBar.prototype.stepForward = function(){
  this.player_.volume(this.player_.volume() + 0.1);
};

vjs.VolumeBar.prototype.stepBack = function(){
  this.player_.volume(this.player_.volume() - 0.1);
};

/**
 * Shows volume level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.VolumeLevel = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
  }
});

vjs.VolumeLevel.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-volume-level',
    innerHTML: '<span class="vjs-control-text"></span>'
  });
};

/**
 * The volume handle can be dragged to adjust the volume level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
 vjs.VolumeHandle = vjs.SliderHandle.extend();

 vjs.VolumeHandle.prototype.defaultValue = '00:00';

 /** @inheritDoc */
 vjs.VolumeHandle.prototype.createEl = function(){
   return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
     className: 'vjs-volume-handle'
   });
 };
/**
 * A button component for muting the audio
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.MuteToggle = vjs.Button.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Button.call(this, player, options);

    this.on(player, 'volumechange', this.update);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }

    this.on(player, 'loadstart', function(){
      if (player.tech['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }
});

vjs.MuteToggle.prototype.createEl = function(){
  return vjs.Button.prototype.createEl.call(this, 'div', {
    className: 'vjs-mute-control vjs-control',
    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
  });
};

vjs.MuteToggle.prototype.onClick = function(){
  this.player_.muted( this.player_.muted() ? false : true );
};

vjs.MuteToggle.prototype.update = function(){
  var vol = this.player_.volume(),
      level = 3;

  if (vol === 0 || this.player_.muted()) {
    level = 0;
  } else if (vol < 0.33) {
    level = 1;
  } else if (vol < 0.67) {
    level = 2;
  }

  // Don't rewrite the button text if the actual text doesn't change.
  // This causes unnecessary and confusing information for screen reader users.
  // This check is needed because this function gets called every time the volume level is changed.
  if(this.player_.muted()){
      if(this.el_.children[0].children[0].innerHTML!=this.localize('Unmute')){
          this.el_.children[0].children[0].innerHTML = this.localize('Unmute'); // change the button text to "Unmute"
      }
  } else {
      if(this.el_.children[0].children[0].innerHTML!=this.localize('Mute')){
          this.el_.children[0].children[0].innerHTML = this.localize('Mute'); // change the button text to "Mute"
      }
  }

  /* TODO improve muted icon classes */
  for (var i = 0; i < 4; i++) {
    vjs.removeClass(this.el_, 'vjs-vol-'+i);
  }
  vjs.addClass(this.el_, 'vjs-vol-'+level);
};

/* Loading Spinner
================================================================================ */
/**
 * Loading spinner for waiting events
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */
vjs.LoadingSpinner = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    // MOVING DISPLAY HANDLING TO CSS

    // player.on('canplay', vjs.bind(this, this.hide));
    // player.on('canplaythrough', vjs.bind(this, this.hide));
    // player.on('playing', vjs.bind(this, this.hide));
    // player.on('seeking', vjs.bind(this, this.show));

    // in some browsers seeking does not trigger the 'playing' event,
    // so we also need to trap 'seeked' if we are going to set a
    // 'seeking' event
    // player.on('seeked', vjs.bind(this, this.hide));

    // player.on('ended', vjs.bind(this, this.hide));

    // Not showing spinner on stalled any more. Browsers may stall and then not trigger any events that would remove the spinner.
    // Checked in Chrome 16 and Safari 5.1.2. http://help.videojs.com/discussions/problems/883-why-is-the-download-progress-showing
    // player.on('stalled', vjs.bind(this, this.show));

    // player.on('waiting', vjs.bind(this, this.show));
  }
});

vjs.LoadingSpinner.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-loading-spinner'
  });
};

/**
 * Display that an error has occurred making the video unplayable
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.ErrorDisplay = vjs.Component.extend({
  init: function(player, options){
    vjs.Component.call(this, player, options);

    this.update();
    this.on(player, 'error', this.update);
  }
});

vjs.ErrorDisplay.prototype.createEl = function(){
  var el = vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-error-display'
  });

  this.contentEl_ = vjs.createEl('div');
  el.appendChild(this.contentEl_);

  return el;
};

vjs.ErrorDisplay.prototype.update = function(){
  if (this.player().error()) {
    this.contentEl_.innerHTML = this.localize(this.player().error().message);
  }
};
/**
 * @fileoverview Media Technology Controller - Base class for media playback
 * technology controllers like Flash and HTML5
 */

/**
 * Base class for media (HTML5 Video, Flash) controllers
 * @param {vjs.Player|Object} player  Central player instance
 * @param {Object=} options Options object
 * @constructor
 */
vjs.MediaTechController = vjs.Component.extend({
  /** @constructor */
  init: function(player, options, ready){
    options = options || {};
    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;
    vjs.Component.call(this, player, options, ready);

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!this['featuresProgressEvents']) {
      this.manualProgressOn();
    }

    // Manually track timeudpates in cases where the browser/flash player doesn't report it.
    if (!this['featuresTimeupdateEvents']) {
      this.manualTimeUpdatesOn();
    }

    this.initControlsListeners();
  }
});

/**
 * Set up click and touch listeners for the playback element
 * On desktops, a click on the video itself will toggle playback,
 * on a mobile device a click on the video toggles controls.
 * (toggling controls is done by toggling the user state between active and
 * inactive)
 *
 * A tap can signal that a user has become active, or has become inactive
 * e.g. a quick tap on an iPhone movie should reveal the controls. Another
 * quick tap should hide them again (signaling the user is in an inactive
 * viewing state)
 *
 * In addition to this, we still want the user to be considered inactive after
 * a few seconds of inactivity.
 *
 * Note: the only part of iOS interaction we can't mimic with this setup
 * is a touch and hold on the video element counting as activity in order to
 * keep the controls showing, but that shouldn't be an issue. A touch and hold on
 * any controls will still keep the user active
 */
vjs.MediaTechController.prototype.initControlsListeners = function(){
  var player, activateControls;

  player = this.player();

  activateControls = function(){
    if (player.controls() && !player.usingNativeControls()) {
      this.addControlsListeners();
    }
  };

  // Set up event listeners once the tech is ready and has an element to apply
  // listeners to
  this.ready(activateControls);
  this.on(player, 'controlsenabled', activateControls);
  this.on(player, 'controlsdisabled', this.removeControlsListeners);

  // if we're loading the playback object after it has started loading or playing the
  // video (often with autoplay on) then the loadstart event has already fired and we
  // need to fire it manually because many things rely on it.
  // Long term we might consider how we would do this for other events like 'canplay'
  // that may also have fired.
  this.ready(function(){
    if (this.networkState && this.networkState() > 0) {
      this.player().trigger('loadstart');
    }
  });
};

vjs.MediaTechController.prototype.addControlsListeners = function(){
  var userWasActive;

  // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
  // trigger mousedown/up.
  // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
  // Any touch events are set to block the mousedown event from happening
  this.on('mousedown', this.onClick);

  // If the controls were hidden we don't want that to change without a tap event
  // so we'll check if the controls were already showing before reporting user
  // activity
  this.on('touchstart', function(event) {
    userWasActive = this.player_.userActive();
  });

  this.on('touchmove', function(event) {
    if (userWasActive){
      this.player().reportUserActivity();
    }
  });

  this.on('touchend', function(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  });

  // Turn on component tap events
  this.emitTapEvents();

  // The tap listener needs to come after the touchend listener because the tap
  // listener cancels out any reportedUserActivity when setting userActive(false)
  this.on('tap', this.onTap);
};

/**
 * Remove the listeners used for click and tap controls. This is needed for
 * toggling to controls disabled, where a tap/touch should do nothing.
 */
vjs.MediaTechController.prototype.removeControlsListeners = function(){
  // We don't want to just use `this.off()` because there might be other needed
  // listeners added by techs that extend this.
  this.off('tap');
  this.off('touchstart');
  this.off('touchmove');
  this.off('touchleave');
  this.off('touchcancel');
  this.off('touchend');
  this.off('click');
  this.off('mousedown');
};

/**
 * Handle a click on the media element. By default will play/pause the media.
 */
vjs.MediaTechController.prototype.onClick = function(event){
  // We're using mousedown to detect clicks thanks to Flash, but mousedown
  // will also be triggered with right-clicks, so we need to prevent that
  if (event.button !== 0) return;

  // When controls are disabled a click should not toggle playback because
  // the click is considered a control
  if (this.player().controls()) {
    if (this.player().paused()) {
      this.player().play();
    } else {
      this.player().pause();
    }
  }
};

/**
 * Handle a tap on the media element. By default it will toggle the user
 * activity state, which hides and shows the controls.
 */
vjs.MediaTechController.prototype.onTap = function(){
  this.player().userActive(!this.player().userActive());
};

/* Fallbacks for unsupported event types
================================================================================ */
// Manually trigger progress events based on changes to the buffered amount
// Many flash players and older HTML5 browsers don't send progress or progress-like events
vjs.MediaTechController.prototype.manualProgressOn = function(){
  this.manualProgress = true;

  // Trigger progress watching when a source begins loading
  this.trackProgress();
};

vjs.MediaTechController.prototype.manualProgressOff = function(){
  this.manualProgress = false;
  this.stopTrackingProgress();
};

vjs.MediaTechController.prototype.trackProgress = function(){

  this.progressInterval = setInterval(vjs.bind(this, function(){
    // Don't trigger unless buffered amount is greater than last time

    var bufferedPercent = this.player().bufferedPercent();

    if (this.bufferedPercent_ != bufferedPercent) {
      this.player().trigger('progress');
    }

    this.bufferedPercent_ = bufferedPercent;

    if (bufferedPercent === 1) {
      this.stopTrackingProgress();
    }
  }), 500);
};
vjs.MediaTechController.prototype.stopTrackingProgress = function(){ clearInterval(this.progressInterval); };

/*! Time Tracking -------------------------------------------------------------- */
vjs.MediaTechController.prototype.manualTimeUpdatesOn = function(){
  var player = this.player_;

  this.manualTimeUpdates = true;

  this.on(player, 'play', this.trackCurrentTime);
  this.on(player, 'pause', this.stopTrackingCurrentTime);
  // timeupdate is also called by .currentTime whenever current time is set

  // Watch for native timeupdate event
  this.one('timeupdate', function(){
    // Update known progress support for this playback technology
    this['featuresTimeupdateEvents'] = true;
    // Turn off manual progress tracking
    this.manualTimeUpdatesOff();
  });
};

vjs.MediaTechController.prototype.manualTimeUpdatesOff = function(){
  this.manualTimeUpdates = false;
  this.stopTrackingCurrentTime();
  this.off('play', this.trackCurrentTime);
  this.off('pause', this.stopTrackingCurrentTime);
};

vjs.MediaTechController.prototype.trackCurrentTime = function(){
  if (this.currentTimeInterval) { this.stopTrackingCurrentTime(); }
  this.currentTimeInterval = setInterval(vjs.bind(this, function(){
    this.player().trigger('timeupdate');
  }), 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
};

// Turn off play progress tracking (when paused or dragging)
vjs.MediaTechController.prototype.stopTrackingCurrentTime = function(){
  clearInterval(this.currentTimeInterval);

  // #1002 - if the video ends right before the next timeupdate would happen,
  // the progress bar won't make it all the way to the end
  this.player().trigger('timeupdate');
};

vjs.MediaTechController.prototype.dispose = function() {
  // Turn off any manual progress or timeupdate tracking
  if (this.manualProgress) { this.manualProgressOff(); }

  if (this.manualTimeUpdates) { this.manualTimeUpdatesOff(); }

  vjs.Component.prototype.dispose.call(this);
};

vjs.MediaTechController.prototype.setCurrentTime = function() {
  // improve the accuracy of manual timeupdates
  if (this.manualTimeUpdates) { this.player().trigger('timeupdate'); }
};

/**
 * Provide a default setPoster method for techs
 *
 */

vjs.MediaTechController.prototype['featuresVolumeControl'] = true;

// Resizing plugins using request fullscreen reloads the plugin
vjs.MediaTechController.prototype['featuresFullscreenResize'] = false;
vjs.MediaTechController.prototype['featuresPlaybackRate'] = false;

// Optional events that we can manually mimic with timers
// currently not triggered by video-js-swf
vjs.MediaTechController.prototype['featuresProgressEvents'] = false;
vjs.MediaTechController.prototype['featuresTimeupdateEvents'] = false;

vjs.media = {};
/**
 * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
 */

/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */
vjs.Html5 = vjs.MediaTechController.extend({
  /** @constructor */
  init: function(player, options, ready){
    // volume cannot be changed from 1 on iOS
    this['featuresVolumeControl'] = vjs.Html5.canControlVolume();

    // just in case; or is it excessively...
    this['featuresPlaybackRate'] = vjs.Html5.canControlPlaybackRate();

    // In iOS, if you move a video element in the DOM, it breaks video playback.
    this['movingMediaElementInDOM'] = !vjs.IS_IOS;

    // HTML video is able to automatically resize when going to fullscreen
    this['featuresFullscreenResize'] = true;

    // HTML video supports progress events
    this['featuresProgressEvents'] = true;

    vjs.MediaTechController.call(this, player, options, ready);
    this.setupTriggers();

    var source = options['source'];

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (this.el_.currentSrc !== source.src) || (player.tag && player.tag.initNetworkState_ === 3)) {
      this.el_.src = source.src;
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if (vjs.TOUCH_ENABLED && player.options()['nativeControlsForTouch'] === true) {
      this.useNativeControls();
    }

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    player.ready(function(){
      if (this.tag && this.options_['autoplay'] && this.paused()) {
        this.play();
      }
    });

    this.triggerReady();
  }
});

vjs.Html5.prototype.dispose = function(){
  vjs.Html5.disposeMediaElement(this.el_);
  vjs.MediaTechController.prototype.dispose.call(this);
};

vjs.Html5.prototype.createEl = function(){
  var player = this.player_,
      // If possible, reuse original tag for HTML5 playback technology element
      el = player.tag,
      newEl,
      clone;

  // Check if this browser supports moving the element into the box.
  // On the iPhone video will break if you move the element,
  // So we have to create a brand new element.
  if (!el || this['movingMediaElementInDOM'] === false) {

    // If the original tag is still there, clone and remove it.
    if (el) {
      clone = el.cloneNode(false);
      vjs.Html5.disposeMediaElement(el);
      el = clone;
      player.tag = null;
    } else {
      el = vjs.createEl('video');
      vjs.setElementAttributes(el,
        vjs.obj.merge(player.tagAttributes || {}, {
          id:player.id() + '_html5_api',
          'class':'vjs-tech'
        })
      );
    }
    // associate the player with the new tag
    el['player'] = player;

    vjs.insertFirst(el, player.el());
  }

  // Update specific tag settings, in case they were overridden
  var settingsAttrs = ['autoplay','preload','loop','muted'];
  for (var i = settingsAttrs.length - 1; i >= 0; i--) {
    var attr = settingsAttrs[i];
    var overwriteAttrs = {};
    if (typeof player.options_[attr] !== 'undefined') {
      overwriteAttrs[attr] = player.options_[attr];
    }
    vjs.setElementAttributes(el, overwriteAttrs);
  }

  return el;
  // jenniisawesome = true;
};

// Make video events trigger player events
// May seem verbose here, but makes other APIs possible.
// Triggers removed using this.off when disposed
vjs.Html5.prototype.setupTriggers = function(){
  for (var i = vjs.Html5.Events.length - 1; i >= 0; i--) {
    this.on(vjs.Html5.Events[i], this.eventHandler);
  }
};

vjs.Html5.prototype.eventHandler = function(evt){
  // In the case of an error on the video element, set the error prop
  // on the player and let the player handle triggering the event. On
  // some platforms, error events fire that do not cause the error
  // property on the video element to be set. See #1465 for an example.
  if (evt.type == 'error' && this.error()) {
    this.player().error(this.error().code);

  // in some cases we pass the event directly to the player
  } else {
    // No need for media events to bubble up.
    evt.bubbles = false;

    this.player().trigger(evt);
  }
};

vjs.Html5.prototype.useNativeControls = function(){
  var tech, player, controlsOn, controlsOff, cleanUp;

  tech = this;
  player = this.player();

  // If the player controls are enabled turn on the native controls
  tech.setControls(player.controls());

  // Update the native controls when player controls state is updated
  controlsOn = function(){
    tech.setControls(true);
  };
  controlsOff = function(){
    tech.setControls(false);
  };
  player.on('controlsenabled', controlsOn);
  player.on('controlsdisabled', controlsOff);

  // Clean up when not using native controls anymore
  cleanUp = function(){
    player.off('controlsenabled', controlsOn);
    player.off('controlsdisabled', controlsOff);
  };
  tech.on('dispose', cleanUp);
  player.on('usingcustomcontrols', cleanUp);

  // Update the state of the player to using native controls
  player.usingNativeControls(true);
};


vjs.Html5.prototype.play = function(){ this.el_.play(); };
vjs.Html5.prototype.pause = function(){ this.el_.pause(); };
vjs.Html5.prototype.paused = function(){ return this.el_.paused; };

vjs.Html5.prototype.currentTime = function(){ return this.el_.currentTime; };
vjs.Html5.prototype.setCurrentTime = function(seconds){
  try {
    this.el_.currentTime = seconds;
  } catch(e) {
    vjs.log(e, 'Video is not ready. (Video.js)');
    // this.warning(VideoJS.warnings.videoNotReady);
  }
};

vjs.Html5.prototype.duration = function(){ return this.el_.duration || 0; };
vjs.Html5.prototype.buffered = function(){ return this.el_.buffered; };

vjs.Html5.prototype.volume = function(){ return this.el_.volume; };
vjs.Html5.prototype.setVolume = function(percentAsDecimal){ this.el_.volume = percentAsDecimal; };
vjs.Html5.prototype.muted = function(){ return this.el_.muted; };
vjs.Html5.prototype.setMuted = function(muted){ this.el_.muted = muted; };

vjs.Html5.prototype.width = function(){ return this.el_.offsetWidth; };
vjs.Html5.prototype.height = function(){ return this.el_.offsetHeight; };

vjs.Html5.prototype.supportsFullScreen = function(){
  if (typeof this.el_.webkitEnterFullScreen == 'function') {

    // Seems to be broken in Chromium/Chrome && Safari in Leopard
    if (/Android/.test(vjs.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(vjs.USER_AGENT)) {
      return true;
    }
  }
  return false;
};

vjs.Html5.prototype.enterFullScreen = function(){
  var video = this.el_;

  if ('webkitDisplayingFullscreen' in video) {
    this.one('webkitbeginfullscreen', function() {
      this.player_.isFullscreen(true);

      this.one('webkitendfullscreen', function() {
        this.player_.isFullscreen(false);
        this.player_.trigger('fullscreenchange');
      });

      this.player_.trigger('fullscreenchange');
    });
  }

  if (video.paused && video.networkState <= video.HAVE_METADATA) {
    // attempt to prime the video element for programmatic access
    // this isn't necessary on the desktop but shouldn't hurt
    this.el_.play();

    // playing and pausing synchronously during the transition to fullscreen
    // can get iOS ~6.1 devices into a play/pause loop
    setTimeout(function(){
      video.pause();
      video.webkitEnterFullScreen();
    }, 0);
  } else {
    video.webkitEnterFullScreen();
  }
};
vjs.Html5.prototype.exitFullScreen = function(){
  this.el_.webkitExitFullScreen();
};
vjs.Html5.prototype.src = function(src) {
  if (src === undefined) {
    return this.el_.src;
  } else {
    this.el_.src = src;
  }
};
vjs.Html5.prototype.load = function(){ this.el_.load(); };
vjs.Html5.prototype.currentSrc = function(){ return this.el_.currentSrc; };

vjs.Html5.prototype.preload = function(){ return this.el_.preload; };
vjs.Html5.prototype.setPreload = function(val){ this.el_.preload = val; };

vjs.Html5.prototype.autoplay = function(){ return this.el_.autoplay; };
vjs.Html5.prototype.setAutoplay = function(val){ this.el_.autoplay = val; };

vjs.Html5.prototype.controls = function(){ return this.el_.controls; };
vjs.Html5.prototype.setControls = function(val){ this.el_.controls = !!val; };

vjs.Html5.prototype.loop = function(){ return this.el_.loop; };
vjs.Html5.prototype.setLoop = function(val){ this.el_.loop = val; };

vjs.Html5.prototype.error = function(){ return this.el_.error; };
vjs.Html5.prototype.seeking = function(){ return this.el_.seeking; };
vjs.Html5.prototype.ended = function(){ return this.el_.ended; };
vjs.Html5.prototype.defaultMuted = function(){ return this.el_.defaultMuted; };

vjs.Html5.prototype.playbackRate = function(){ return this.el_.playbackRate; };
vjs.Html5.prototype.setPlaybackRate = function(val){ this.el_.playbackRate = val; };

vjs.Html5.prototype.networkState = function(){ return this.el_.networkState; };

/* HTML5 Support Testing ---------------------------------------------------- */

vjs.Html5.isSupported = function(){
  // ie9 with no Media Player is a LIAR! (#984)
  try {
    vjs.TEST_VID['volume'] = 0.5;
  } catch (e) {
    return false;
  }

  return !!vjs.TEST_VID.canPlayType;
};

vjs.Html5.canPlaySource = function(srcObj){
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return !!vjs.TEST_VID.canPlayType(srcObj.type);
  } catch(e) {
    return '';
  }
  // TODO: Check Type
  // If no Type, check ext
  // Check Media Type
};

vjs.Html5.canControlVolume = function(){
  var volume =  vjs.TEST_VID.volume;
  vjs.TEST_VID.volume = (volume / 2) + 0.1;
  return volume !== vjs.TEST_VID.volume;
};

vjs.Html5.canControlPlaybackRate = function(){
  var playbackRate =  vjs.TEST_VID.playbackRate;
  vjs.TEST_VID.playbackRate = (playbackRate / 2) + 0.1;
  return playbackRate !== vjs.TEST_VID.playbackRate;
};

// HTML5 Feature detection and Device Fixes --------------------------------- //
(function() {
  var canPlayType,
      mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i,
      mp4RE = /^video\/mp4/i;

  vjs.Html5.patchCanPlayType = function() {
    // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
    if (vjs.ANDROID_VERSION >= 4.0) {
      if (!canPlayType) {
        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
      }

      vjs.TEST_VID.constructor.prototype.canPlayType = function(type) {
        if (type && mpegurlRE.test(type)) {
          return 'maybe';
        }
        return canPlayType.call(this, type);
      };
    }

    // Override Android 2.2 and less canPlayType method which is broken
    if (vjs.IS_OLD_ANDROID) {
      if (!canPlayType) {
        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
      }

      vjs.TEST_VID.constructor.prototype.canPlayType = function(type){
        if (type && mp4RE.test(type)) {
          return 'maybe';
        }
        return canPlayType.call(this, type);
      };
    }
  };

  vjs.Html5.unpatchCanPlayType = function() {
    var r = vjs.TEST_VID.constructor.prototype.canPlayType;
    vjs.TEST_VID.constructor.prototype.canPlayType = canPlayType;
    canPlayType = null;
    return r;
  };

  // by default, patch the video element
  vjs.Html5.patchCanPlayType();
})();

// List of all HTML5 events (various uses).
vjs.Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');

vjs.Html5.disposeMediaElement = function(el){
  if (!el) { return; }

  el['player'] = null;

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while(el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function() {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};
/**
 * @fileoverview VideoJS-SWF - Custom Flash Player with HTML5-ish API
 * https://github.com/zencoder/video-js-swf
 * Not using setupTriggers. Using global onEvent func to distribute events
 */

/**
 * Flash Media Controller - Wrapper for fallback SWF API
 *
 * @param {vjs.Player} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */
vjs.Flash = vjs.MediaTechController.extend({
  /** @constructor */
  init: function(player, options, ready){
    vjs.MediaTechController.call(this, player, options, ready);

    var source = options['source'],

        // Which element to embed in
        parentEl = options['parentEl'],

        // Create a temporary element to be replaced by swf object
        placeHolder = this.el_ = vjs.createEl('div', { id: player.id() + '_temp_flash' }),

        // Generate ID for swf object
        objId = player.id()+'_flash_api',

        // Store player options in local var for optimization
        // TODO: switch to using player methods instead of options
        // e.g. player.autoplay();
        playerOptions = player.options_,

        // Merge default flashvars with ones passed in to init
        flashVars = vjs.obj.merge({

          // SWF Callback Functions
          'readyFunction': 'videojs.Flash.onReady',
          'eventProxyFunction': 'videojs.Flash.onEvent',
          'errorEventProxyFunction': 'videojs.Flash.onError',

          // Player Settings
          'autoplay': playerOptions.autoplay,
          'preload': playerOptions.preload,
          'loop': playerOptions.loop,
          'muted': playerOptions.muted

        }, options['flashVars']),

        // Merge default parames with ones passed in
        params = vjs.obj.merge({
          'wmode': 'opaque', // Opaque is needed to overlay controls, but can affect playback performance
          'bgcolor': '#000000' // Using bgcolor prevents a white flash when the object is loading
        }, options['params']),

        // Merge default attributes with ones passed in
        attributes = vjs.obj.merge({
          'id': objId,
          'name': objId, // Both ID and Name needed or swf to identifty itself
          'class': 'vjs-tech'
        }, options['attributes'])
    ;

    // If source was supplied pass as a flash var.
    if (source) {
      if (source.type && vjs.Flash.isStreamingType(source.type)) {
        var parts = vjs.Flash.streamToParts(source.src);
        flashVars['rtmpConnection'] = encodeURIComponent(parts.connection);
        flashVars['rtmpStream'] = encodeURIComponent(parts.stream);
      }
      else {
        flashVars['src'] = encodeURIComponent(vjs.getAbsoluteURL(source.src));
      }
    }

    // Add placeholder to player div
    vjs.insertFirst(placeHolder, parentEl);

    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers
    // This allows resetting the playhead when we catch the reload
    if (options['startTime']) {
      this.ready(function(){
        this.load();
        this.play();
        this['currentTime'](options['startTime']);
      });
    }

    // firefox doesn't bubble mousemove events to parent. videojs/video-js-swf#37
    // bugzilla bug: https://bugzilla.mozilla.org/show_bug.cgi?id=836786
    if (vjs.IS_FIREFOX) {
      this.ready(function(){
        this.on('mousemove', function(){
          // since it's a custom event, don't bubble higher than the player
          this.player().trigger({ 'type':'mousemove', 'bubbles': false });
        });
      });
    }

    // native click events on the SWF aren't triggered on IE11, Win8.1RT
    // use stageclick events triggered from inside the SWF instead
    player.on('stageclick', player.reportUserActivity);

    this.el_ = vjs.Flash.embed(options['swf'], placeHolder, flashVars, params, attributes);
  }
});

vjs.Flash.prototype.dispose = function(){
  vjs.MediaTechController.prototype.dispose.call(this);
};

vjs.Flash.prototype.play = function(){
  this.el_.vjs_play();
};

vjs.Flash.prototype.pause = function(){
  this.el_.vjs_pause();
};

vjs.Flash.prototype.src = function(src){
  if (src === undefined) {
    return this['currentSrc']();
  }

  if (vjs.Flash.isStreamingSrc(src)) {
    src = vjs.Flash.streamToParts(src);
    this.setRtmpConnection(src.connection);
    this.setRtmpStream(src.stream);
  } else {
    // Make sure source URL is abosolute.
    src = vjs.getAbsoluteURL(src);
    this.el_.vjs_src(src);
  }

  // Currently the SWF doesn't autoplay if you load a source later.
  // e.g. Load player w/ no source, wait 2s, set src.
  if (this.player_.autoplay()) {
    var tech = this;
    setTimeout(function(){ tech.play(); }, 0);
  }
};

vjs.Flash.prototype['setCurrentTime'] = function(time){
  this.lastSeekTarget_ = time;
  this.el_.vjs_setProperty('currentTime', time);
  vjs.MediaTechController.prototype.setCurrentTime.call(this);
};

vjs.Flash.prototype['currentTime'] = function(time){
  // when seeking make the reported time keep up with the requested time
  // by reading the time we're seeking to
  if (this.seeking()) {
    return this.lastSeekTarget_ || 0;
  }
  return this.el_.vjs_getProperty('currentTime');
};

vjs.Flash.prototype['currentSrc'] = function(){
  var src = this.el_.vjs_getProperty('currentSrc');
  // no src, check and see if RTMP
  if (src == null) {
    var connection = this['rtmpConnection'](),
        stream = this['rtmpStream']();

    if (connection && stream) {
      src = vjs.Flash.streamFromParts(connection, stream);
    }
  }
  return src;
};

vjs.Flash.prototype.load = function(){
  this.el_.vjs_load();
};

vjs.Flash.prototype.buffered = function(){
  return vjs.createTimeRange(0, this.el_.vjs_getProperty('buffered'));
};

vjs.Flash.prototype.supportsFullScreen = function(){
  return false; // Flash does not allow fullscreen through javascript
};

vjs.Flash.prototype.enterFullScreen = function(){
  return false;
};

(function(){
  // Create setters and getters for attributes
  var api = vjs.Flash.prototype,
    readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(','),
    readOnly = 'error,networkState,readyState,seeking,initialTime,duration,startOffsetTime,paused,played,seekable,ended,videoTracks,audioTracks,videoWidth,videoHeight,textTracks'.split(','),
    // Overridden: buffered, currentTime, currentSrc
    i;

  function createSetter(attr){
    var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);
    api['set'+attrUpper] = function(val){ return this.el_.vjs_setProperty(attr, val); };
  };
  function createGetter(attr) {
    api[attr] = function(){ return this.el_.vjs_getProperty(attr); };
  };

  // Create getter and setters for all read/write attributes
  for (i = 0; i < readWrite.length; i++) {
    createGetter(readWrite[i]);
    createSetter(readWrite[i]);
  }

  // Create getters for read-only attributes
  for (i = 0; i < readOnly.length; i++) {
    createGetter(readOnly[i]);
  }
})();

/* Flash Support Testing -------------------------------------------------------- */

vjs.Flash.isSupported = function(){
  return vjs.Flash.version()[0] >= 10;
  // return swfobject.hasFlashPlayerVersion('10');
};

vjs.Flash.canPlaySource = function(srcObj){
  var type;

  if (!srcObj.type) {
    return '';
  }

  type = srcObj.type.replace(/;.*/,'').toLowerCase();
  if (type in vjs.Flash.formats || type in vjs.Flash.streamingFormats) {
    return 'maybe';
  }
};

vjs.Flash.formats = {
  'video/flv': 'FLV',
  'video/x-flv': 'FLV',
  'video/mp4': 'MP4',
  'video/m4v': 'MP4'
};

vjs.Flash.streamingFormats = {
  'rtmp/mp4': 'MP4',
  'rtmp/flv': 'FLV'
};

vjs.Flash['onReady'] = function(currSwf){
  var el, player;

  el = vjs.el(currSwf);

  // get player from the player div property
  player = el && el.parentNode && el.parentNode['player'];

  // if there is no el or player then the tech has been disposed
  // and the tech element was removed from the player div
  if (player) {
    // reference player on tech element
    el['player'] = player;
    // check that the flash object is really ready
    vjs.Flash['checkReady'](player.tech);
  }
};

// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.
// If it's not ready, we set a timeout to check again shortly.
vjs.Flash['checkReady'] = function(tech){
  // stop worrying if the tech has been disposed
  if (!tech.el()) {
    return;
  }

  // check if API property exists
  if (tech.el().vjs_getProperty) {
    // tell tech it's ready
    tech.triggerReady();
  } else {
    // wait longer
    setTimeout(function(){
      vjs.Flash['checkReady'](tech);
    }, 50);
  }
};

// Trigger events from the swf on the player
vjs.Flash['onEvent'] = function(swfID, eventName){
  var player = vjs.el(swfID)['player'];
  player.trigger(eventName);
};

// Log errors from the swf
vjs.Flash['onError'] = function(swfID, err){
  var player = vjs.el(swfID)['player'];
  var msg = 'FLASH: '+err;

  if (err == 'srcnotfound') {
    player.error({ code: 4, message: msg });

  // errors we haven't categorized into the media errors
  } else {
    player.error(msg);
  }
};

// Flash Version Check
vjs.Flash.version = function(){
  var version = '0,0,0';

  // IE
  try {
    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

  // other browsers
  } catch(e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin){
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch(err) {}
  }
  return version.split(',');
};

// Flash embedding method. Only used in non-iframe mode
vjs.Flash.embed = function(swf, placeHolder, flashVars, params, attributes){
  var code = vjs.Flash.getEmbedCode(swf, flashVars, params, attributes),

      // Get element by embedding code and retrieving created element
      obj = vjs.createEl('div', { innerHTML: code }).childNodes[0],

      par = placeHolder.parentNode
  ;

  placeHolder.parentNode.replaceChild(obj, placeHolder);

  // IE6 seems to have an issue where it won't initialize the swf object after injecting it.
  // This is a dumb fix
  var newObj = par.childNodes[0];
  setTimeout(function(){
    newObj.style.display = 'block';
  }, 1000);

  return obj;

};

vjs.Flash.getEmbedCode = function(swf, flashVars, params, attributes){

  var objTag = '<object type="application/x-shockwave-flash"',
      flashVarsString = '',
      paramsString = '',
      attrsString = '';

  // Convert flash vars to string
  if (flashVars) {
    vjs.obj.each(flashVars, function(key, val){
      flashVarsString += (key + '=' + val + '&amp;');
    });
  }

  // Add swf, flashVars, and other default params
  params = vjs.obj.merge({
    'movie': swf,
    'flashvars': flashVarsString,
    'allowScriptAccess': 'always', // Required to talk to swf
    'allowNetworking': 'all' // All should be default, but having security issues.
  }, params);

  // Create param tags string
  vjs.obj.each(params, function(key, val){
    paramsString += '<param name="'+key+'" value="'+val+'" />';
  });

  attributes = vjs.obj.merge({
    // Add swf to attributes (need both for IE and Others to work)
    'data': swf,

    // Default to 100% width/height
    'width': '100%',
    'height': '100%'

  }, attributes);

  // Create Attributes string
  vjs.obj.each(attributes, function(key, val){
    attrsString += (key + '="' + val + '" ');
  });

  return objTag + attrsString + '>' + paramsString + '</object>';
};

vjs.Flash.streamFromParts = function(connection, stream) {
  return connection + '&' + stream;
};

vjs.Flash.streamToParts = function(src) {
  var parts = {
    connection: '',
    stream: ''
  };

  if (! src) {
    return parts;
  }

  // Look for the normal URL separator we expect, '&'.
  // If found, we split the URL into two pieces around the
  // first '&'.
  var connEnd = src.indexOf('&');
  var streamBegin;
  if (connEnd !== -1) {
    streamBegin = connEnd + 1;
  }
  else {
    // If there's not a '&', we use the last '/' as the delimiter.
    connEnd = streamBegin = src.lastIndexOf('/') + 1;
    if (connEnd === 0) {
      // really, there's not a '/'?
      connEnd = streamBegin = src.length;
    }
  }
  parts.connection = src.substring(0, connEnd);
  parts.stream = src.substring(streamBegin, src.length);

  return parts;
};

vjs.Flash.isStreamingType = function(srcType) {
  return srcType in vjs.Flash.streamingFormats;
};

// RTMP has four variations, any string starting
// with one of these protocols should be valid
vjs.Flash.RTMP_RE = /^rtmp[set]?:\/\//i;

vjs.Flash.isStreamingSrc = function(src) {
  return vjs.Flash.RTMP_RE.test(src);
};

/**
 * The Media Loader is the component that decides which playback technology to load
 * when the player is initialized.
 *
 * @constructor
 */
vjs.MediaLoader = vjs.Component.extend({
  /** @constructor */
  init: function(player, options, ready){
    vjs.Component.call(this, player, options, ready);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.
    if (!player.options_['sources'] || player.options_['sources'].length === 0) {
      for (var i=0,j=player.options_['techOrder']; i<j.length; i++) {
        var techName = vjs.capitalize(j[i]),
            tech = window['videojs'][techName];

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech(techName);
          break;
        }
      }
    } else {
      // // Loop through playback technologies (HTML5, Flash) and check for support.
      // // Then load the best source.
      // // A few assumptions here:
      // //   All playback technologies respect preload false.
      player.src(player.options_['sources']);
    }
  }
});


/**
 * Javascript JSON implementation
 * (Parse Method Only)
 * https://github.com/douglascrockford/JSON-js/blob/master/json2.js
 * Only using for parse method when parsing data-setup attribute JSON.
 * @suppress {undefinedVars}
 * @namespace
 * @private
 */
vjs.JSON;

if (typeof window.JSON !== 'undefined' && typeof window.JSON.parse === 'function') {
  vjs.JSON = window.JSON;
} else {
  vjs.JSON = {};
}

/*!
 * Audio5js: HTML5 Audio Compatibility Layer
 * https://github.com/zohararad/audio5js
 * License MIT (c) Zohar Arad 2013
 */
;(function ($win, ns, factory) {
  "use strict";
  /*global define */
  /*global swfobject */

  if (typeof (module) !== 'undefined' && module.exports) { // CommonJS
    module.exports = factory(ns, $win);
  } else if (typeof (define) === 'function' && define.amd) { // AMD
    define(function () {
      return factory(ns, $win);
    });
  } else { // <script>
    $win[ns] = factory(ns, $win);
  }

}(window, 'Audio5js', function (ns, $win) {

  "use strict";

  var ActiveXObject = $win.ActiveXObject;

  /**
   * AudioError Class
   * @param {String} message error message
   * @constructor
   */
  function AudioError(message) {
    this.message = message;
  }

  AudioError.prototype = new Error();

  /**
   * Clones an object
   * @param obj object to clone
   * @return {Object} cloned object
   */
  function cloneObject(obj) {
    var clone = {}, i;
    for (i in obj) {
      if (typeof (obj[i]) === "object") {
        clone[i] = cloneObject(obj[i]);
      } else {
        clone[i] = obj[i];
      }
    }
    return clone;
  }

  /**
   * Extend an object with a mixin
   * @param {Object} target target object to extend
   * @param {Object} mixin object to mix into target
   * @return {*} extended object
   */
  var extend = function (target, mixin) {
    var name, m = cloneObject(mixin);
    for (name in m) {
      if (m.hasOwnProperty(name)) {
        target[name] = m[name];
      }
    }
    return target;
  };

  /**
   * Extend an object's prototype with a mixin
   * @param {Object} target target object to extend
   * @param {Object} mixin object to mix into target
   * @return {*} extended object
   */
  var include = function (target, mixin) {
    return extend(target.prototype, mixin);
  };

  var Pubsub = {
    /**
     * Subscribe to event on a channel
     * @param {String} evt name of channel / event to subscribe
     * @param {Function} fn the callback to execute on message publishing
     * @param {Object} ctx the context in which the callback should be executed
     */
    on: function (evt, fn, ctx) {
      this.subscribe(evt, fn, ctx, false);
    },
    /**
     * Subscribe to a one-time event on a channel
     * @param {String} evt name of channel / event to subscribe
     * @param {Function} fn the callback to execute on message publishing
     * @param {Object} ctx the context in which the callback should be executed
     */
    one: function(evt, fn, ctx) {
      this.subscribe(evt, fn, ctx, true);
    },
    /**
     * Unsubscribe from an event on a channel
     * @param {String} evt name of channel / event to unsubscribe
     * @param {Function} fn the callback used when subscribing to the event
     */
    off: function (evt, fn) {
      if (this.channels[evt] === undefined) { return; }
      var i, l;
      for (i = 0, l = this.channels[evt].length; i  < l; i++) {
        var sub = this.channels[evt][i].fn;
        if (sub === fn) {
          this.channels[evt].splice(i, 1);
          break;
        }
      }
    },
    /**
     * Add event subscription to channel. Called by `on` and `one`
     * @param {String} evt name of channel / event to subscribe
     * @param {Function} fn the callback to execute on message publishing
     * @param {Object} ctx the context in which the callback should be executed
     * @param {Boolean} once indicate if event should be triggered once or not
     */
    subscribe: function (evt, fn, ctx, once) {
      if (this.channels === undefined) {
        this.channels = {};
      }
      this.channels[evt] = this.channels[evt] || [];
      this.channels[evt].push({fn: fn, ctx: ctx, once: (once || false)});
    },
    /**
     * Publish a message on a channel. Accepts **args** after event name
     * @param {String} evt name of channel / event to trigger
     */
    trigger: function (evt) {
      if (this.channels && this.channels.hasOwnProperty(evt)) {
        var args = Array.prototype.slice.call(arguments, 1);
        var a = [];
        while(this.channels[evt].length > 0) {
          var sub = this.channels[evt].shift();
          if (typeof (sub.fn) === 'function') {
            sub.fn.apply(sub.ctx, args);
          }
          if ( !sub.once ){
            a.push(sub);
          }
        }
        this.channels[evt] = a;
      }
    }
  };

  var util = {
    /**
     * Flash embed code string with cross-browser support.
     */
  flash_embed_code: function (id, swf_location, ts) {
      var prefix;
      var s = '<param name="movie" value="' + swf_location + '?playerInstance=window.' + ns + '_flash.instances[\'' + id + '\']&datetime=' + ts + '"/>' +
        '<param name="wmode" value="transparent"/>' +
        '<param name="allowscriptaccess" value="always" />' +
        '</object>';
      if (ActiveXObject) {
        prefix = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="1" height="1" id="' + id + '">';
      } else {
        prefix = '<object type="application/x-shockwave-flash" data="' + swf_location + '?playerInstance=window.' + ns + '_flash.instances[\'' + id + '\']&datetime=' + ts + '" width="1" height="1" id="' + id + '" >';
      }
      return prefix + s;
    },
    /**
     * Check if browser supports audio mime type.
     * @param {String} mime_type audio mime type to check
     * @return {Boolean} whether browser supports passed audio mime type
     */
    can_play: function (mime_type) {
      var a = document.createElement('audio');
      var mime_str;
      switch (mime_type) {
        case 'mp3':
          mime_str = 'audio/mpeg;';
          break;
        case 'vorbis':
          mime_str = 'audio/ogg; codecs="vorbis"';
          break;
        case 'opus':
          mime_str = 'audio/ogg; codecs="opus"';
          break;
        case 'webm':
          mime_str = 'audio/webm; codecs="vorbis"';
          break;
        case 'mp4':
          mime_str = 'audio/mp4; codecs="mp4a.40.5"';
          break;
        case 'wav':
          mime_str = 'audio/wav; codecs="1"';
          break;
      }
      if (mime_str !== undefined) {
        if (mime_type === 'mp3' && navigator.userAgent.match(/Android/i) && navigator.userAgent.match(/Firefox/i)) {
          return true;
        }
        try {
          return !!a.canPlayType && a.canPlayType(mime_str) !== '';
        } catch (e) {
          return false;
        }
      }
      return false;
    },
    /**
     * Boolean flag indicating whether the browser has Flash installed or not
     */
    has_flash: (function () {
      var r = false;
      if (navigator.plugins && navigator.plugins.length && navigator.plugins['Shockwave Flash']) {
        r = true;
      } else if (navigator.mimeTypes && navigator.mimeTypes.length) {
        var mimeType = navigator.mimeTypes['application/x-shockwave-flash'];
        r = mimeType && mimeType.enabledPlugin;
      } else {
        try {
          var ax = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
          r = typeof (ax) === 'object';
        } catch (e) {}
      }
      return r;
    }()),
    /**
     * Embed Flash MP3 player SWF to DOM
     * @param {String} swf_location location of MP3 player SWF
     * @param {String} id swf unique ID used for resolving callbacks from ExternalInterface to Javascript
     */
    embedFlash: function (swf_location, id) {
      var d = document.createElement('div');
      d.style.position = 'absolute';
      d.style.width = '1px';
      d.style.height = '1px';
      d.style.top = '1px';
      document.body.appendChild(d);
      if(typeof($win.swfobject) === 'object'){
        var fv = {
          playerInstance: 'window.'+ ns + '_flash.instances[\''+id+'\']'
        };
        var params = {
          allowscriptaccess: 'always',
          wmode: 'transparent'
        };
        d.innerHTML = '<div id="'+id+'"></div>';
        swfobject.embedSWF(swf_location + '?ts='+(new Date().getTime() + Math.random()), id, "1", "1", "9.0.0", null, fv, params);
      } else {
        var ts = new Date().getTime() + Math.random(); // Ensure swf is not pulled from cache
        d.innerHTML = this.flash_embed_code(id, swf_location, ts);
      }
      return document.getElementById(id);
    },
    /**
     * Formats seconds into a time string hh:mm:ss.
     * @param {Number} seconds seconds to format as string
     * @return {String} formatted time string
     */
    formatTime: function (seconds) {
      var hours = parseInt(seconds / 3600, 10) % 24;
      var minutes = parseInt(seconds / 60, 10) % 60;
      var secs = parseInt(seconds % 60, 10);
      var result, fragment = (minutes < 10 ? "0" + minutes : minutes) + ":" + (secs  < 10 ? "0" + secs : secs);
      if (hours > 0) {
        result = (hours < 10 ? "0" + hours : hours) + ":" + fragment;
      } else {
        result = fragment;
      }
      return result;
    }
  };

  util.use_flash = util.can_play('mp3');

  var Audio5js, FlashAudioPlayer, HTML5AudioPlayer;

  /**
   * Common audio attributes object. Mixed into audio players.
   * @type {Object}
   */
  var AudioAttributes = {
    playing: false, /** {Boolean} player playback state  */
    vol: 1, /** {Float} audio volume */
    duration: 0, /** {Float} audio duration (sec) */
    position: 0, /** {Float} audio position (sec) */
    load_percent: 0, /** {Float} audio file load percent (%) */
    seekable: false, /** {Boolean} is loaded audio seekable */
    ready: null /** {Boolean} is loaded audio seekable */
  };

  /**
   * Global object holding flash-based player instances.
   * Used to create a bridge between Flash's ExternalInterface calls and FlashAudioPlayer instances
   * @type {Object}
   */
  var globalAudio5Flash = $win[ns + '_flash'] = $win[ns + '_flash'] || {
    instances: { }, /** FlashAudioPlayer instance hash */
    count: 0 /** FlashAudioPlayer instance count */
  };

  /**
   * Flash MP3 Audio Player Class
   * @constructor
   */
  FlashAudioPlayer = function () {
    if (util.use_flash && !util.has_flash) {
      throw new Error('Flash Plugin Missing');
    }
  };

  FlashAudioPlayer.prototype = {
    /**
     * Initialize the player
     * @param {String} swf_src path to audio player SWF file
     */
    init: function (swf_src) {
      globalAudio5Flash.count += 1;
      this.id = ns + globalAudio5Flash.count;
      globalAudio5Flash.instances[this.id] = this;
      this.embed(swf_src);
    },
    /**
     * Embed audio player SWF in page and assign reference to audio instance variable
     * @param {String} swf_src path to audio player SWF file
     */
    embed: function (swf_src) {
      util.embedFlash(swf_src, this.id);
    },
    /**
     * ExternalInterface callback indicating SWF is ready
     */
    eiReady: function () {
      this.audio = document.getElementById(this.id);
      this.trigger('ready');
    },
    /**
     * ExternalInterface audio load started callback. Fires when audio starts loading.
     */
    eiLoadStart: function(){
      this.trigger('loadstart');
    },
    /**
     * ExternalInterface audio metadata loaded callback. Fires when audio ID3 tags have been loaded.
     */
    eiLoadedMetadata: function(){
      this.trigger('loadedmetadata');
    },
    /**
     * ExternalInterface audio can play callback. Fires when audio can be played.
     */
    eiCanPlay: function () {
      this.trigger('canplay');
    },
    /**
     * ExternalInterface timeupdate callback. Fires as long as playhead position is updated (audio is being played).
     * @param {Float} position audio playback position (sec)
     * @param {Float} duration audio total duration (sec)
     * @param {Boolean} seekable is audio seekable or not (download or streaming)
     */
    eiTimeUpdate: function (position, duration, seekable) {
      this.position = position;
      this.duration = duration;
      this.seekable = seekable;
      this.trigger('timeupdate', position, (this.seekable ? duration : null));
    },
    /**
     * ExternalInterface download progress callback. Fires as long as audio file is downloaded by browser.
     * @param {Float} percent audio download percent
     * @param {Float} duration audio total duration (sec)
     * * @param {Boolean} seekable is audio seekable or not (download or streaming)
     */
    eiProgress: function (percent, duration, seekable) {
      this.load_percent = percent;
      this.duration = duration;
      this.seekable = seekable;
      this.trigger('progress', percent);
    },
    /**
     * ExternalInterface audio load error callback.
     * @param {String} msg error message
     */
    eiLoadError: function (msg) {
      this.trigger('error', msg);
    },
    /**
     * ExternalInterface audio play callback. Fires when audio starts playing.
     */
    eiPlay: function () {
      this.playing = true;
      this.trigger('play');
      this.trigger('playing');
    },
    /**
     * ExternalInterface audio pause callback. Fires when audio is paused.
     */
    eiPause: function () {
      this.playing = false;
      this.trigger('pause');
    },
    /**
     * ExternalInterface audio ended callback. Fires when audio playback ended.
     */
    eiEnded: function () {
      this.pause();
      this.trigger('ended');
    },
    /**
     * ExternalInterface audio seeking callback. Fires when audio is being seeked.
     */
    eiSeeking: function(){
      this.trigger('seeking');
    },
    /**
     * ExternalInterface audio seeked callback. Fires when audio has been seeked.
     */
    eiSeeked: function(){
      this.trigger('seeked');
    },
    /**
     * Resets audio position and parameters. Invoked once audio is loaded.
     */
    reset: function () {
      this.seekable = false;
      this.duration = 0;
      this.position = 0;
      this.load_percent = 0;
    },
    /**
     * Load audio from url.
     * @param {String} url URL of audio to load
     */
    load: function (url) {
      this.reset();
      this.audio.load(url);
    },
    /**
     * Play audio
     */
    play: function () {
      this.audio.pplay();
    },
    /**
     * Pause audio
     */
    pause: function () {
      this.audio.ppause();
    },
    /**
     * Get / Set audio volume
     * @param {Float} v audio volume to set between 0 - 1.
     * @return {Float} current audio volume
     */
    volume: function (v) {
      if (v !== undefined && !isNaN(parseInt(v, 10))) {
        this.audio.setVolume(v);
        this.vol = v;
      } else {
        return this.vol;
      }
    },
    /**
     * Seek audio to position
     * @param {Float} position audio position in seconds to seek to.
     */
    seek: function (position) {
      try {
        this.audio.seekTo(position);
        this.position = position;
      } catch (e) {}
    },
    /**
     * Destroy audio object and remove from DOM
     */
    destroyAudio: function() {
      if(this.audio){
        this.pause();
        this.audio.parentNode.removeChild(this.audio);
        delete globalAudio5Flash.instances[this.id];
        delete this.audio;
      }
    }
  };

  include(FlashAudioPlayer, Pubsub);
  include(FlashAudioPlayer, AudioAttributes);

  /**
   * HTML5 Audio Player
   * @constructor
   */
  HTML5AudioPlayer = function () {};

  HTML5AudioPlayer.prototype = {
    /**
     * Initialize the player instance
     */
    init: function () {
      this.trigger('ready');
    },
    /**
     * Create new audio instance
     */
    createAudio: function(){
      this.audio = new Audio();
      this.audio.autoplay = false;
      this.audio.preload = 'auto';
      this.audio.autobuffer = true;
      this.bindEvents();
    },
    /**
     * Destroy current audio instance
     */
    destroyAudio: function(){
      if(this.audio){
        this.pause();
        this.unbindEvents();
        try {
          this.audio.setAttribute('src', '');
        } finally {
          delete this.audio;
        }
      }
    },
    /**
     * Sets up audio event listeners once so adding / removing event listeners is always done
     * on the same callbacks.
     */
    setupEventListeners: function(){
      this.listeners = {
        loadstart: this.onLoadStart.bind(this),
        canplay: this.onLoad.bind(this),
        loadedmetadata: this.onLoadedMetadata.bind(this),
        play: this.onPlay.bind(this),
        playing: this.onPlaying.bind(this),
        pause: this.onPause.bind(this),
        ended: this.onEnded.bind(this),
        error: this.onError.bind(this),
        timeupdate: this.onTimeUpdate.bind(this),
        seeking: this.onSeeking.bind(this),
        seeked: this.onSeeked.bind(this)
      };
    },
    /**
     * Bind DOM events to Audio object
     */
    bindEvents: function() {
      if(this.listeners === undefined){
        this.setupEventListeners();
      }
      this.audio.addEventListener('loadstart', this.listeners.loadstart, false);
      this.audio.addEventListener('canplay', this.listeners.canplay, false);
      this.audio.addEventListener('loadedmetadata', this.listeners.loadedmetadata, false);
      this.audio.addEventListener('play', this.listeners.play, false);
      this.audio.addEventListener('playing', this.listeners.playing, false);
      this.audio.addEventListener('pause', this.listeners.pause, false);
      this.audio.addEventListener('ended', this.listeners.ended, false);
      this.audio.addEventListener('error', this.listeners.error, false);
      this.audio.addEventListener('timeupdate', this.listeners.timeupdate, false);
      this.audio.addEventListener('seeking', this.listeners.seeking, false);
      this.audio.addEventListener('seeked', this.listeners.seeked, false);
    },
    /**
     * Unbind DOM events from Audio object
     */
    unbindEvents: function() {
      this.audio.removeEventListener('loadstart', this.listeners.loadstart);
      this.audio.removeEventListener('canplay', this.listeners.canplay);
      this.audio.removeEventListener('loadedmetadata', this.listeners.loadedmetadata);
      this.audio.removeEventListener('play', this.listeners.play);
      this.audio.removeEventListener('playing', this.listeners.playing);
      this.audio.removeEventListener('pause', this.listeners.pause);
      this.audio.removeEventListener('ended', this.listeners.ended);
      this.audio.removeEventListener('error', this.listeners.error);
      this.audio.removeEventListener('timeupdate', this.listeners.timeupdate);
      this.audio.removeEventListener('seeking', this.listeners.seeking);
      this.audio.removeEventListener('seeked', this.listeners.seeked);
    },
    /**
     * Audio load start event handler. Triggered when audio starts loading
     */
    onLoadStart: function(){
      this.trigger('loadstart');
    },
    /**
     * Audio canplay event handler. Triggered when audio is loaded and can be played.
     * Resets player parameters and starts audio download progress timer.
     */
    onLoad: function () {
      if(!this.audio){
        return setTimeout(this.onLoad.bind(this), 100);
      }
      this.seekable = this.audio.seekable && this.audio.seekable.length > 0;
      if (this.seekable) {
        this.timer = setInterval(this.onProgress.bind(this), 250);
      }
      this.trigger('canplay');
    },
    /**
     * Audio ID3 load event handler. Triggered when ID3 metadata is loaded.
     */
    onLoadedMetadata: function(){
      this.trigger('loadedmetadata');
    },
    /**
     * Audio play event handler. Triggered when audio starts playing.
     */
    onPlay: function () {
      this.playing = true;
      this.trigger('play');
    },
    /**
     * Audio play event handler. Triggered when audio starts playing.
     */
    onPlaying: function () {
      this.playing = true;
      this.trigger('playing');
    },
    /**
     * Audio pause event handler. Triggered when audio is paused.
     */
    onPause: function () {
      this.playing = false;
      this.trigger('pause');
    },
    /**
     * Audio ended event handler. Triggered when audio playback has ended.
     */
    onEnded: function () {
      this.playing = false;
      this.trigger('ended');
    },
    /**
     * Audio timeupdate event handler. Triggered as long as playhead position is updated (audio is being played).
     */
    onTimeUpdate: function () {
      if (this.audio && this.playing) {
        try{
          this.position = this.audio.currentTime;
          this.duration = this.audio.duration === Infinity ? null : this.audio.duration;
        } catch (e){}
        this.trigger('timeupdate', this.position, this.duration);
      }
    },
    /**
     * Audio download progress timer callback. Check audio's download percentage.
     * Called periodically as soon as the audio loads and can be played.
     * Cancelled when audio has fully download or when a new audio file has been loaded to the player.
     */
    onProgress: function () {
      if (this.audio && this.audio.buffered !== null && this.audio.buffered.length) {
        this.duration = this.audio.duration === Infinity ? null : this.audio.duration;
        this.load_percent = parseInt(((this.audio.buffered.end(this.audio.buffered.length - 1) / this.duration) * 100), 10);
        this.trigger('progress', this.load_percent);
        if (this.load_percent >= 100) {
          this.clearLoadProgress();
        }
      }
    },
    /**
     * Audio error event handler
     * @param e error event
     */
    onError: function (e) {
      this.trigger('error', e);
    },
    /**
     * Audio seeking event handler. Triggered when audio seek starts.
     */
    onSeeking: function(){
      this.trigger('seeking');
    },
    /**
     * Audio seeked event handler. Triggered when audio has been seeked.
     */
    onSeeked: function(){
      this.trigger('seeked');
    },
    /**
     * Clears periodical audio download progress callback.
     */
    clearLoadProgress: function () {
      if (this.timer !== undefined) {
        clearInterval(this.timer);
        delete this.timer;
      }
    },
    /**
     * Resets audio position and parameters.
     */
    reset: function () {
      this.clearLoadProgress();
      this.seekable = false;
      this.duration = 0;
      this.position = 0;
      this.load_percent = 0;
    },
    /**
     * Load audio from url.
     * @param {String} url URL of audio to load
     */
    load: function (url) {
      this.reset();
      this.trigger('pause');
      //this.destroyAudio();
      if(this.audio === undefined){
        this.createAudio();
      }
      this.audio.setAttribute('src', url);
      this.audio.load();
    },
    /**
     * Play audio
     */
    play: function () {
      if(this.audio) {
        this.audio.play();
      }
    },
    /**
     * Pause audio
     */
    pause: function () {
      if(this.audio) {
        this.audio.pause();
      }
    },
    /**
     * Get / Set audio volume
     * @param {Float} v audio volume to set between 0 - 1.
     * @return {Float} current audio volume
     */
    volume: function (v) {
      if (v !== undefined && !isNaN(parseInt(v, 10))) {
        var vol = v < 0 ? 0 : Math.min(1, v);
        this.audio.volume = vol;
        this.vol = vol;
      } else {
        return this.vol;
      }
    },
    /**
     * Seek audio to position
     * @param {Float} position audio position in seconds to seek to.
     */
    seek: function (position) {
      var playing = this.playing;
      this.position = position;
      this.audio.currentTime = position;
      if (playing) {
        this.play();
      } else {
        if (this.audio.buffered !== null && this.audio.buffered.length) {
          this.trigger('timeupdate', this.position, this.duration);
        }
      }
    }
  };

  include(HTML5AudioPlayer, Pubsub);
  include(HTML5AudioPlayer, AudioAttributes);

  /**
   * Default settings object
   * @type {Object}
   */
  var settings = {
    /**
     * {String} path to Flash audio player SWF file
     */
    swf_path: '/swf/audiojs.swf',
    /**
     * {Boolean} flag indicating whether to throw errors to the page or trigger an error event
     */
    throw_errors: true,
    /**
     * {Boolean} flag indicating whether to format player duration and position to hh:mm:ss or pass as raw seconds
     */
    format_time: true,
    /**
     * {Array} list of codecs to try and use when initializing the player. Used to selectively initialize the internal audio player based on codec support
     */
    codecs: ['mp3']
  };

  /**
   * Audio5js Audio Player
   * @param {Object} s player settings object
   * @constructor
   */
  Audio5js = function (s) {
    s = s || {};
    var k;
    for (k in settings) {
      if (settings.hasOwnProperty(k) && !s.hasOwnProperty(k)) {
        s[k] = settings[k];
      }
    }
    this.init(s);
  };

  /**
   * Check if browser can play a given audio mime type.
   * @param {String} mime_type audio mime type to check.
   * @return {Boolean} is audio mime type supported by browser or not
   */
  Audio5js.can_play = function (mime_type) {
    return util.can_play(mime_type);
  };

  Audio5js.prototype = {
    /**
     * Initialize player instance.
     * @param {Object} s player settings object
     */
    init: function (s) {
      this.ready = false;
      this.settings = s;
      this.audio = this.getPlayer();
      this.bindAudioEvents();
      if (this.settings.use_flash) {
        this.audio.init(s.swf_path);
      } else {
        this.audio.init();
      }
    },
    /**
     * Gets a new audio player instance based on codec support as defined in settings.codecs array.
     * Defaults to MP3 player either HTML or Flash based.
     * @return {FlashAudioPlayer,HTML5AudioPlayer} audio player instance
     */
    getPlayer: function () {
      var i, l, player, codec;
      if(this.settings.use_flash){
        player = new FlashAudioPlayer();
        this.settings.player = {
          engine: 'flash',
          codec: 'mp3'
        };
      } else {
        for (i = 0, l = this.settings.codecs.length; i < l; i++) {
          codec = this.settings.codecs[i];
          if (Audio5js.can_play(codec)) {
            player = new HTML5AudioPlayer();
            this.settings.use_flash = false;
            this.settings.player = {
              engine: 'html',
              codec: codec
            };
            break;
          }
        }
        if (player === undefined) {
          // here we double check for mp3 support instead of defaulting to Flash in case user overrode the settings.codecs array with an empty array.
          this.settings.use_flash = !Audio5js.can_play('mp3');
          player = this.settings.use_flash ? new FlashAudioPlayer() : new HTML5AudioPlayer();
          this.settings.player = {
            engine: (this.settings.use_flash ? 'flash' : 'html'),
            codec: 'mp3'
          };
        }
      }
      return player;
    },
    /**
     * Bind events from audio object to internal callbacks
     */
    bindAudioEvents: function () {
      this.audio.on('ready', this.onReady, this);
      this.audio.on('loadstart', this.onLoadStart, this);
      this.audio.on('loadedmetadata', this.onLoadedMetadata, this);
      this.audio.on('play', this.onPlay, this);
      this.audio.on('pause', this.onPause, this);
      this.audio.on('ended', this.onEnded, this);
      this.audio.on('canplay', this.onCanPlay, this);
      this.audio.on('timeupdate', this.onTimeUpdate, this);
      this.audio.on('progress', this.onProgress, this);
      this.audio.on('error', this.onError, this);
      this.audio.on('seeking', this.onSeeking, this);
      this.audio.on('seeked', this.onSeeked, this);
    },
    /**
     * Bind events from audio object to internal callbacks
     */
    unbindAudioEvents: function () {
      this.audio.off('ready', this.onReady);
      this.audio.off('loadstart', this.onLoadStart);
      this.audio.off('loadedmetadata', this.onLoadedMetadata);
      this.audio.off('play', this.onPlay);
      this.audio.off('pause', this.onPause);
      this.audio.off('ended', this.onEnded);
      this.audio.off('canplay', this.onCanPlay);
      this.audio.off('timeupdate', this.onTimeUpdate);
      this.audio.off('progress', this.onProgress);
      this.audio.off('error', this.onError);
      this.audio.off('seeking', this.onSeeking);
      this.audio.off('seeked', this.onSeeked);
    },
    /**
     * Load audio from URL
     * @param {String} url URL of audio to load
     */
    load: function (url) {
      var that = this,
          f = function(u){
            that.audio.load(u);
            that.trigger('load');
          };

      if(this.ready){
        f(url);
      } else {
        this.on('ready', f);
      }
    },
    /**
     * Play audio
     */
    play: function () {
      if(!this.playing){
        this.audio.play();
      }
    },
    /**
     * Pause audio
     */
    pause: function () {
      if(this.playing){
        this.audio.pause();
      }
    },
    /**
     * Toggle audio play / pause
     */
    playPause: function () {
      this[this.playing ? 'pause' : 'play']();
    },
    /**
     * Get / Set audio volume
     * @param {Float} v audio volume to set between 0 - 1.
     * @return {Float} current audio volume
     */
    volume: function (v) {
      if (v !== undefined && !isNaN(parseInt(v, 10))) {
        this.audio.volume(v);
        this.vol = v;
      } else {
        return this.vol;
      }
    },
    /**
     * Seek audio to position
     * @param {Float} position audio position in seconds to seek to.
     */
    seek: function (position) {
      this.audio.seek(position);
      this.position = position;
    },
    /**
     * Destroy audio object and remove from DOM
     */
    destroy: function() {
      this.unbindAudioEvents();
      this.audio.destroyAudio();
    },
    /**
     * Callback for audio ready event. Indicates audio is ready for playback.
     * Looks for ready callback in settings object and invokes it in the context of player instance
     */
    onReady: function () {
      this.ready = true;
      if (typeof (this.settings.ready) === 'function') {
        this.settings.ready.call(this, this.settings.player);
      }
      this.trigger('ready');
    },
    /**
     * Audio load start event handler
     */
    onLoadStart: function(){
      this.trigger('loadstart');
    },
    /**
     * Audio metadata loaded event handler
     */
    onLoadedMetadata: function(){
      this.trigger('loadedmetadata');
    },
    /**
     * Audio play event handler
     */
    onPlay: function () {
      this.playing = true;
      this.trigger('play');
    },
    /**
     * Audio pause event handler
     */
    onPause: function () {
      this.playing = false;
      this.trigger('pause');
    },
    /**
     * Playback end event handler
     */
    onEnded: function () {
      this.playing = false;
      this.trigger('ended');
    },
    /**
     * Audio error event handler
     */
    onError: function () {
      var error = new AudioError('Audio Error. Failed to Load Audio');
      if (this.settings.throw_errors) {
        throw error;
      } else {
        this.trigger('error', error);
      }
    },
    /**
     * Audio canplay event handler. Triggered when enough audio has been loaded to by played.
     */
    onCanPlay: function () {
      this.trigger('canplay');
    },
    /**
     * Audio seeking event handler
     */
    onSeeking: function(){
      this.trigger('seeking');
    },
    /**
     * Audio seeked event handler
     */
    onSeeked: function(){
      this.trigger('seeked');
    },
    /**
     * Playback time update event handler
     * @param {Float} position play head position (sec)
     * @param {Float} duration audio duration (sec)
     */
    onTimeUpdate: function (position, duration) {
      this.position = this.settings.format_time ? util.formatTime(position) : position;
      if (this.duration !== duration) {
        this.duration = this.settings.format_time && duration !== null ? util.formatTime(duration) : duration;
      }
      this.trigger('timeupdate', this.position, this.duration);
    },
    /**
     * Audio download progress event handler
     * @param {Float} loaded audio download percent
     */
    onProgress: function (loaded) {
      this.duration = this.audio.duration;
      this.load_percent = loaded;
      this.trigger('progress', loaded);
    }
  };

  include(Audio5js, Pubsub);
  include(Audio5js, AudioAttributes);

  return Audio5js;

}));

/*! iScroll v5.1.1 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */
;(function (window, document, Math) {
var rAF = window.requestAnimationFrame	||
	window.webkitRequestAnimationFrame	||
	window.mozRequestAnimationFrame		||
	window.oRequestAnimationFrame		||
	window.msRequestAnimationFrame		||
	function (callback) { window.setTimeout(callback, 1000 / 60); };

var utils = (function () {
	var me = {};

	var _elementStyle = document.createElement('div').style;
	var _vendor = (function () {
		var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			transform,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			transform = vendors[i] + 'ransform';
			if ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);
		}

		return false;
	})();

	function _prefixStyle (style) {
		if ( _vendor === false ) return false;
		if ( _vendor === '' ) return style;
		return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
	}

	me.getTime = Date.now || function getTime () { return new Date().getTime(); };

	me.extend = function (target, obj) {
		for ( var i in obj ) {
			target[i] = obj[i];
		}
	};

	me.addEvent = function (el, type, fn, capture) {
		el.addEventListener(type, fn, !!capture);
	};

	me.removeEvent = function (el, type, fn, capture) {
		el.removeEventListener(type, fn, !!capture);
	};

	me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
		var distance = current - start,
			speed = Math.abs(distance) / time,
			destination,
			duration;

		deceleration = deceleration === undefined ? 0.0006 : deceleration;

		destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );
		duration = speed / deceleration;

		if ( destination < lowerMargin ) {
			destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;
			distance = Math.abs(destination - current);
			duration = distance / speed;
		} else if ( destination > 0 ) {
			destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;
			distance = Math.abs(current) + destination;
			duration = distance / speed;
		}

		return {
			destination: Math.round(destination),
			duration: duration
		};
	};

	var _transform = _prefixStyle('transform');

	me.extend(me, {
		hasTransform: _transform !== false,
		hasPerspective: _prefixStyle('perspective') in _elementStyle,
		hasTouch: 'ontouchstart' in window,
		hasPointer: navigator.msPointerEnabled,
		hasTransition: _prefixStyle('transition') in _elementStyle
	});

	// This should find all Android browsers lower than build 535.19 (both stock browser and webview)
	me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !(/Chrome\/\d/.test(window.navigator.appVersion));

	me.extend(me.style = {}, {
		transform: _transform,
		transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
		transitionDuration: _prefixStyle('transitionDuration'),
		transitionDelay: _prefixStyle('transitionDelay'),
		transformOrigin: _prefixStyle('transformOrigin')
	});

	me.hasClass = function (e, c) {
		var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
		return re.test(e.className);
	};

	me.addClass = function (e, c) {
		if ( me.hasClass(e, c) ) {
			return;
		}

		var newclass = e.className.split(' ');
		newclass.push(c);
		e.className = newclass.join(' ');
	};

	me.removeClass = function (e, c) {
		if ( !me.hasClass(e, c) ) {
			return;
		}

		var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
		e.className = e.className.replace(re, ' ');
	};

	me.offset = function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;

		// jshint -W084
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		// jshint +W084

		return {
			left: left,
			top: top
		};
	};

	me.preventDefaultException = function (el, exceptions) {
		for ( var i in exceptions ) {
			if ( exceptions[i].test(el[i]) ) {
				return true;
			}
		}

		return false;
	};

	me.extend(me.eventType = {}, {
		touchstart: 1,
		touchmove: 1,
		touchend: 1,

		mousedown: 2,
		mousemove: 2,
		mouseup: 2,

		MSPointerDown: 3,
		MSPointerMove: 3,
		MSPointerUp: 3
	});

	me.extend(me.ease = {}, {
		quadratic: {
			style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
			fn: function (k) {
				return k * ( 2 - k );
			}
		},
		circular: {
			style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',	// Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
			fn: function (k) {
				return Math.sqrt( 1 - ( --k * k ) );
			}
		},
		back: {
			style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
			fn: function (k) {
				var b = 4;
				return ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;
			}
		},
		bounce: {
			style: '',
			fn: function (k) {
				if ( ( k /= 1 ) < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k;
				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
				}
			}
		},
		elastic: {
			style: '',
			fn: function (k) {
				var f = 0.22,
					e = 0.4;

				if ( k === 0 ) { return 0; }
				if ( k == 1 ) { return 1; }

				return ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );
			}
		}
	});

	me.tap = function (e, eventName) {
		var ev = document.createEvent('Event');
		ev.initEvent(eventName, true, true);
		ev.pageX = e.pageX;
		ev.pageY = e.pageY;
		e.target.dispatchEvent(ev);
	};

	me.click = function (e) {
		var target = e.target,
			ev;

		if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {
			ev = document.createEvent('MouseEvents');
			ev.initMouseEvent('click', true, true, e.view, 1,
				target.screenX, target.screenY, target.clientX, target.clientY,
				e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
				0, null);

			ev._constructed = true;
			target.dispatchEvent(ev);
		}
	};

	return me;
})();

function IScroll (el, options) {
	this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
	this.scroller = this.wrapper.children[0];
	this.scrollerStyle = this.scroller.style;		// cache style for better performance

	this.options = {

		resizeScrollbars: true,

		mouseWheelSpeed: 20,

		snapThreshold: 0.334,

// INSERT POINT: OPTIONS

		startX: 0,
		startY: 0,
		scrollY: true,
		directionLockThreshold: 5,
		momentum: true,

		bounce: true,
		bounceTime: 600,
		bounceEasing: '',

		preventDefault: true,
		preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|TSPAN)$/ },

		HWCompositing: true,
		useTransition: true,
		useTransform: true
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	// Normalize options
	this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

	this.options.useTransition = utils.hasTransition && this.options.useTransition;
	this.options.useTransform = utils.hasTransform && this.options.useTransform;

	this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
	this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

	// If you want eventPassthrough I have to lock one of the axes
	this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
	this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

	// With eventPassthrough we also need lockDirection mechanism
	this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
	this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

	this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

	this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

	if ( this.options.tap === true ) {
		this.options.tap = 'tap';
	}

	if ( this.options.shrinkScrollbars == 'scale' ) {
		this.options.useTransition = false;
	}

	this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

	if ( this.options.probeType == 3 ) {
		this.options.useTransition = false;	}

// INSERT POINT: NORMALIZATION

	// Some defaults
	this.x = 0;
	this.y = 0;
	this.directionX = 0;
	this.directionY = 0;
	this._events = {};

// INSERT POINT: DEFAULTS

	this._init();
	this.refresh();

	this.scrollTo(this.options.startX, this.options.startY);
	this.enable();
}

IScroll.prototype = {
	version: '5.1.1',

	_init: function () {
		this._initEvents();

		if ( this.options.scrollbars || this.options.indicators ) {
			this._initIndicators();
		}

		if ( this.options.mouseWheel ) {
			this._initWheel();
		}

		if ( this.options.snap ) {
			this._initSnap();
		}

		if ( this.options.keyBindings ) {
			this._initKeys();
		}

// INSERT POINT: _init

	},

	destroy: function () {
		this._initEvents(true);

		this._execEvent('destroy');
	},

	_transitionEnd: function (e) {
		if ( e.target != this.scroller || !this.isInTransition ) {
			return;
		}

		this._transitionTime();
		if ( !this.resetPosition(this.options.bounceTime) ) {
			this.isInTransition = false;
			this._execEvent('scrollEnd',e);
		}
	},

	_start: function (e) {
		// React to left mouse button only
		if ( utils.eventType[e.type] != 1 ) {
			if ( e.button !== 0 ) {
				return;
			}
		}


		if ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {
			return;
		}

		if ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		if(this.options.stopPropagation){
			e.stopPropagation();
		}

		var point = e.touches ? e.touches[0] : e,
			pos;

		this.initiated	= utils.eventType[e.type];
		this.moved		= false;
		this.distX		= 0;
		this.distY		= 0;
		this.directionX = 0;
		this.directionY = 0;
		this.directionLocked = 0;

		this._transitionTime();

		this.startTime = utils.getTime();

		if ( this.options.useTransition && this.isInTransition ) {
			this.isInTransition = false;
			pos = this.getComputedPosition();
			this._translate(Math.round(pos.x), Math.round(pos.y));
			this._execEvent('scrollEnd',e);
		} else if ( !this.options.useTransition && this.isAnimating ) {
			this.isAnimating = false;
			this._execEvent('scrollEnd',e);
		}

		this.startX    = this.x;
		this.startY    = this.y;
		this.absStartX = this.x;
		this.absStartY = this.y;
		this.pointX    = point.pageX;
		this.pointY    = point.pageY;

		this._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault ) {	// increases performance on Android? TODO: check!
			e.preventDefault();
		}

		var point		= e.touches ? e.touches[0] : e,
			deltaX		= point.pageX - this.pointX,
			deltaY		= point.pageY - this.pointY,
			timestamp	= utils.getTime(),
			newX, newY,
			absDistX, absDistY;

		this.pointX		= point.pageX;
		this.pointY		= point.pageY;

		this.distX		+= deltaX;
		this.distY		+= deltaY;
		absDistX		= Math.abs(this.distX);
		absDistY		= Math.abs(this.distY);

		// We need to move at least 10 pixels for the scrolling to initiate
		if ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {
			return;
		}

		// If you are scrolling in one direction lock the other
		if ( !this.directionLocked && !this.options.freeScroll ) {
			if ( absDistX > absDistY + this.options.directionLockThreshold ) {
				this.directionLocked = 'h';		// lock horizontally
			} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
				this.directionLocked = 'v';		// lock vertically
			} else {
				this.directionLocked = 'n';		// no lock
			}
		}

		if ( this.directionLocked == 'h' ) {
			if ( this.options.eventPassthrough == 'vertical' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'horizontal' ) {
				this.initiated = false;
				return;
			}

			deltaY = 0;
		} else if ( this.directionLocked == 'v' ) {
			if ( this.options.eventPassthrough == 'horizontal' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'vertical' ) {
				this.initiated = false;
				return;
			}

			deltaX = 0;
		}

		deltaX = this.hasHorizontalScroll ? deltaX : 0;
		deltaY = this.hasVerticalScroll ? deltaY : 0;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		// Slow down if outside of the boundaries
		if ( newX > 0 || newX < this.maxScrollX ) {
			newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
		}
		if ( newY > 0 || newY < this.maxScrollY ) {
			newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
		}

		this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if ( !this.moved ) {
			this._execEvent('scrollStart');
		}

		this.moved = true;

		this._translate(newX, newY);

/* REPLACE START: _move */
		if ( timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.startX = this.x;
			this.startY = this.y;

			if ( this.options.probeType == 1 ) {
				this._execEvent('scroll',e);
			}
		}

		if ( this.options.probeType > 1 ) {
			this._execEvent('scroll',e);
		}
/* REPLACE END: _move */

	},

	_end: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.changedTouches ? e.changedTouches[0] : e,
			momentumX,
			momentumY,
			duration = utils.getTime() - this.startTime,
			newX = Math.round(this.x),
			newY = Math.round(this.y),
			distanceX = Math.abs(newX - this.startX),
			distanceY = Math.abs(newY - this.startY),
			time = 0,
			easing = '';

		this.isInTransition = 0;
		this.initiated = 0;
		this.endTime = utils.getTime();

		// reset if we are outside of the boundaries
		if ( this.resetPosition(this.options.bounceTime) ) {
			return;
		}

		this.scrollTo(newX, newY);	// ensures that the last position is rounded

		// we scrolled less than 10 pixels
		if ( !this.moved ) {
			if ( this.options.tap ) {
				utils.tap(e, this.options.tap);
			}

			if ( this.options.click ) {
				utils.click(e);
			}

			this._execEvent('scrollCancel');
			return;
		}

		if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {
			this._execEvent('flick');
			return;
		}

		// start momentum animation if needed
		if ( this.options.momentum && duration < 300 ) {
			momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
			momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
			newX = momentumX.destination;
			newY = momentumY.destination;
			time = Math.max(momentumX.duration, momentumY.duration);
			this.isInTransition = 1;
		}


		if ( this.options.snap ) {
			var snap = this._nearestSnap(newX, newY);
			this.currentPage = snap;
			time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(newX - snap.x), 1000),
						Math.min(Math.abs(newY - snap.y), 1000)
					), 300);
			newX = snap.x;
			newY = snap.y;

			this.directionX = 0;
			this.directionY = 0;
			easing = this.options.bounceEasing;
		}

// INSERT POINT: _end

		if ( newX != this.x || newY != this.y ) {
			// change easing function when scroller goes out of the boundaries
			if ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {
				easing = utils.ease.quadratic;
			}

			this.scrollTo(newX, newY, time, easing);
			return;
		}

		this._execEvent('scrollEnd',e);
	},

	_resize: function () {
		var that = this;

		clearTimeout(this.resizeTimeout);

		this.resizeTimeout = setTimeout(function () {
			that.refresh();
		}, this.options.resizePolling);
	},

	resetPosition: function (time) {
		var x = this.x,
			y = this.y;

		time = time || 0;

		if ( !this.hasHorizontalScroll || this.x > 0 ) {
			x = 0;
		} else if ( this.x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( !this.hasVerticalScroll || this.y > 0 ) {
			y = 0;
		} else if ( this.y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		if ( x == this.x && y == this.y ) {
			return false;
		}

		this.scrollTo(x, y, time, this.options.bounceEasing);

		return true;
	},

	disable: function () {
		this.enabled = false;
	},

	enable: function () {
		this.enabled = true;
	},

	refresh: function () {
		var rf = this.wrapper.offsetHeight;		// Force reflow

		this.wrapperWidth	= this.wrapper.clientWidth;
		this.wrapperHeight	= this.wrapper.clientHeight;

/* REPLACE START: refresh */

		this.scrollerWidth	= this.scroller.offsetWidth;
		this.scrollerHeight	= this.scroller.offsetHeight;

		this.maxScrollX		= this.wrapperWidth - this.scrollerWidth;
		this.maxScrollY		= this.wrapperHeight - this.scrollerHeight;

/* REPLACE END: refresh */

		this.hasHorizontalScroll	= this.options.scrollX && this.maxScrollX < 0;
		this.hasVerticalScroll		= this.options.scrollY && this.maxScrollY < 0;

		if ( !this.hasHorizontalScroll ) {
			this.maxScrollX = 0;
			this.scrollerWidth = this.wrapperWidth;
		}

		if ( !this.hasVerticalScroll ) {
			this.maxScrollY = 0;
			this.scrollerHeight = this.wrapperHeight;
		}

		this.endTime = 0;
		this.directionX = 0;
		this.directionY = 0;

		this.wrapperOffset = utils.offset(this.wrapper);

		this._execEvent('refresh');

		this.resetPosition();

// INSERT POINT: _refresh

	},

	on: function (type, fn) {
		if ( !this._events[type] ) {
			this._events[type] = [];
		}

		this._events[type].push(fn);
	},

	off: function (type, fn) {
		if ( !this._events[type] ) {
			return;
		}

		var index = this._events[type].indexOf(fn);

		if ( index > -1 ) {
			this._events[type].splice(index, 1);
		}
	},

	_execEvent: function (type,e) {
		if ( !this._events[type] ) {
			return;
		}

		var i = 0,
			l = this._events[type].length;

		if ( !l ) {
			return;
		}

		for ( ; i < l; i++ ) {
			this._events[type][i].apply(this, [].slice.call(arguments, 1));
		}
	},

	scrollBy: function (x, y, time, easing) {
		x = this.x + x;
		y = this.y + y;
		time = time || 0;

		this.scrollTo(x, y, time, easing);
	},

	scrollTo: function (x, y, time, easing) {
		easing = easing || utils.ease.circular;

		this.isInTransition = this.options.useTransition && time > 0;

		if ( !time || (this.options.useTransition && easing.style) ) {
			this._transitionTimingFunction(easing.style);
			this._transitionTime(time);
			this._translate(x, y);
		} else {
			this._animate(x, y, time, easing.fn);
		}
	},

	scrollToElement: function (el, time, offsetX, offsetY, easing) {
		el = el.nodeType ? el : this.scroller.querySelector(el);

		if ( !el ) {
			return;
		}

		var pos = utils.offset(el);

		pos.left -= this.wrapperOffset.left;
		pos.top  -= this.wrapperOffset.top;

		// if offsetX/Y are true we center the element to the screen
		if ( offsetX === true ) {
			offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
		}
		if ( offsetY === true ) {
			offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
		}

		pos.left -= offsetX || 0;
		pos.top  -= offsetY || 0;

		pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
		pos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;

		time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;

		this.scrollTo(pos.left, pos.top, time, easing);
	},

	_transitionTime: function (time) {
		time = time || 0;

		this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
		}


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTime(time);
			}
		}


// INSERT POINT: _transitionTime

	},

	_transitionTimingFunction: function (easing) {
		this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTimingFunction(easing);
			}
		}


// INSERT POINT: _transitionTimingFunction

	},

	_translate: function (x, y) {
		if ( this.options.useTransform ) {

/* REPLACE START: _translate */

			this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

/* REPLACE END: _translate */

		} else {
			x = Math.round(x);
			y = Math.round(y);
			this.scrollerStyle.left = x + 'px';
			this.scrollerStyle.top = y + 'px';
		}

		this.x = x;
		this.y = y;


	if ( this.indicators ) {
		for ( var i = this.indicators.length; i--; ) {
			this.indicators[i].updatePosition();
		}
	}


// INSERT POINT: _translate

	},

	_initEvents: function (remove) {
		var eventType = remove ? utils.removeEvent : utils.addEvent,
			target = this.options.bindToWrapper ? this.wrapper : window;

		eventType(window, 'orientationchange', this);
		eventType(window, 'resize', this);

		if ( this.options.click ) {
			eventType(this.wrapper, 'click', this, true);
		}

		if ( !this.options.disableMouse ) {
			eventType(this.wrapper, 'mousedown', this);
			eventType(target, 'mousemove', this);
			eventType(target, 'mousecancel', this);
			eventType(target, 'mouseup', this);
		}

		if ( utils.hasPointer && !this.options.disablePointer ) {
			eventType(this.wrapper, 'MSPointerDown', this);
			eventType(target, 'MSPointerMove', this);
			eventType(target, 'MSPointerCancel', this);
			eventType(target, 'MSPointerUp', this);
		}

		if ( utils.hasTouch && !this.options.disableTouch ) {
			eventType(this.wrapper, 'touchstart', this);
			eventType(target, 'touchmove', this);
			eventType(target, 'touchcancel', this);
			eventType(target, 'touchend', this);
		}

		eventType(this.scroller, 'transitionend', this);
		eventType(this.scroller, 'webkitTransitionEnd', this);
		eventType(this.scroller, 'oTransitionEnd', this);
		eventType(this.scroller, 'MSTransitionEnd', this);
	},

	getComputedPosition: function () {
		var matrix = window.getComputedStyle(this.scroller, null),
			x, y;

		if ( this.options.useTransform ) {
			matrix = matrix[utils.style.transform].split(')')[0].split(', ');
			x = +(matrix[12] || matrix[4]);
			y = +(matrix[13] || matrix[5]);
		} else {
			x = +matrix.left.replace(/[^-\d.]/g, '');
			y = +matrix.top.replace(/[^-\d.]/g, '');
		}

		return { x: x, y: y };
	},

	_initIndicators: function () {
		var interactive = this.options.interactiveScrollbars,
			customStyle = typeof this.options.scrollbars != 'string',
			indicators = [],
			indicator;

		var that = this;

		this.indicators = [];

		if ( this.options.scrollbars ) {
			// Vertical scrollbar
			if ( this.options.scrollY ) {
				indicator = {
					el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenX: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}

			// Horizontal scrollbar
			if ( this.options.scrollX ) {
				indicator = {
					el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenY: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}
		}

		if ( this.options.indicators ) {
			// TODO: check concat compatibility
			indicators = indicators.concat(this.options.indicators);
		}

		for ( var i = indicators.length; i--; ) {
			this.indicators.push( new Indicator(this, indicators[i]) );
		}

		// TODO: check if we can use array.map (wide compatibility and performance issues)
		function _indicatorsMap (fn) {
			for ( var i = that.indicators.length; i--; ) {
				fn.call(that.indicators[i]);
			}
		}

		if ( this.options.fadeScrollbars ) {
			this.on('scrollEnd', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollCancel', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1);
				});
			});

			this.on('beforeScrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1, true);
				});
			});
		}


		this.on('refresh', function () {
			_indicatorsMap(function () {
				this.refresh();
			});
		});

		this.on('destroy', function () {
			_indicatorsMap(function () {
				this.destroy();
			});

			delete this.indicators;
		});
	},

	_initWheel: function () {
		utils.addEvent(this.wrapper, 'wheel', this);
		utils.addEvent(this.wrapper, 'mousewheel', this);
		utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

		this.on('destroy', function () {
			utils.removeEvent(this.wrapper, 'wheel', this);
			utils.removeEvent(this.wrapper, 'mousewheel', this);
			utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
		});
	},

	_wheel: function (e) {
		if ( !this.enabled ) {
			return;
		}

		e.preventDefault();
		e.stopPropagation();

		var wheelDeltaX, wheelDeltaY,
			newX, newY,
			that = this;

		if ( this.wheelTimeout === undefined ) {
			that._execEvent('scrollStart');
		}

		// Execute the scrollEnd event after 400ms the wheel stopped scrolling
		clearTimeout(this.wheelTimeout);
		this.wheelTimeout = setTimeout(function () {
			that._execEvent('scrollEnd',e);
			that.wheelTimeout = undefined;
		}, 400);

		if ( 'deltaX' in e ) {
			wheelDeltaX = -e.deltaX;
			wheelDeltaY = -e.deltaY;
		} else if ( 'wheelDeltaX' in e ) {
			wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
			wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
		} else if ( 'wheelDelta' in e ) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
		} else if ( 'detail' in e ) {
			wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
		} else {
			return;
		}

		wheelDeltaX *= this.options.invertWheelDirection;
		wheelDeltaY *= this.options.invertWheelDirection;

		if ( !this.hasVerticalScroll ) {
			wheelDeltaX = wheelDeltaY;
			wheelDeltaY = 0;
		}

		if ( this.options.snap ) {
			newX = this.currentPage.pageX;
			newY = this.currentPage.pageY;

			if ( wheelDeltaX > 0 ) {
				newX--;
			} else if ( wheelDeltaX < 0 ) {
				newX++;
			}

			if ( wheelDeltaY > 0 ) {
				newY--;
			} else if ( wheelDeltaY < 0 ) {
				newY++;
			}

			this.goToPage(newX, newY);

			return;
		}

		newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
		newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

		if ( newX > 0 ) {
			newX = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
		}

		if ( newY > 0 ) {
			newY = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
		}

		this.scrollTo(newX, newY, 0);

		if ( this.options.probeType > 1 ) {
			this._execEvent('scroll',e);
		}

// INSERT POINT: _wheel
	},

	_initSnap: function () {
		this.currentPage = {};

		if ( typeof this.options.snap == 'string' ) {
			this.options.snap = this.scroller.querySelectorAll(this.options.snap);
		}

		this.on('refresh', function () {
			var i = 0, l,
				m = 0, n,
				cx, cy,
				x = 0, y,
				stepX = this.options.snapStepX || this.wrapperWidth,
				stepY = this.options.snapStepY || this.wrapperHeight,
				el;

			this.pages = [];

			if ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {
				return;
			}

			if ( this.options.snap === true ) {
				cx = Math.round( stepX / 2 );
				cy = Math.round( stepY / 2 );

				while ( x > -this.scrollerWidth ) {
					this.pages[i] = [];
					l = 0;
					y = 0;

					while ( y > -this.scrollerHeight ) {
						this.pages[i][l] = {
							x: Math.max(x, this.maxScrollX),
							y: Math.max(y, this.maxScrollY),
							width: stepX,
							height: stepY,
							cx: x - cx,
							cy: y - cy
						};

						y -= stepY;
						l++;
					}

					x -= stepX;
					i++;
				}
			} else {
				el = this.options.snap;
				l = el.length;
				n = -1;

				for ( ; i < l; i++ ) {
					if ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {
						m = 0;
						n++;
					}

					if ( !this.pages[m] ) {
						this.pages[m] = [];
					}

					x = Math.max(-el[i].offsetLeft, this.maxScrollX);
					y = Math.max(-el[i].offsetTop, this.maxScrollY);
					cx = x - Math.round(el[i].offsetWidth / 2);
					cy = y - Math.round(el[i].offsetHeight / 2);

					this.pages[m][n] = {
						x: x,
						y: y,
						width: el[i].offsetWidth,
						height: el[i].offsetHeight,
						cx: cx,
						cy: cy
					};

					if ( x > this.maxScrollX ) {
						m++;
					}
				}
			}

			this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

			// Update snap threshold if needed
			if ( this.options.snapThreshold % 1 === 0 ) {
				this.snapThresholdX = this.options.snapThreshold;
				this.snapThresholdY = this.options.snapThreshold;
			} else {
				this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
				this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
			}
		});

		this.on('flick', function () {
			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.x - this.startX), 1000),
						Math.min(Math.abs(this.y - this.startY), 1000)
					), 300);

			this.goToPage(
				this.currentPage.pageX + this.directionX,
				this.currentPage.pageY + this.directionY,
				time
			);
		});
	},

	_nearestSnap: function (x, y) {
		if ( !this.pages.length ) {
			return { x: 0, y: 0, pageX: 0, pageY: 0 };
		}

		var i = 0,
			l = this.pages.length,
			m = 0;

		// Check if we exceeded the snap threshold
		if ( Math.abs(x - this.absStartX) < this.snapThresholdX &&
			Math.abs(y - this.absStartY) < this.snapThresholdY ) {
			return this.currentPage;
		}

		if ( x > 0 ) {
			x = 0;
		} else if ( x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( y > 0 ) {
			y = 0;
		} else if ( y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		for ( ; i < l; i++ ) {
			if ( x >= this.pages[i][0].cx ) {
				x = this.pages[i][0].x;
				break;
			}
		}

		l = this.pages[i].length;

		for ( ; m < l; m++ ) {
			if ( y >= this.pages[0][m].cy ) {
				y = this.pages[0][m].y;
				break;
			}
		}

		if ( i == this.currentPage.pageX ) {
			i += this.directionX;

			if ( i < 0 ) {
				i = 0;
			} else if ( i >= this.pages.length ) {
				i = this.pages.length - 1;
			}

			x = this.pages[i][0].x;
		}

		if ( m == this.currentPage.pageY ) {
			m += this.directionY;

			if ( m < 0 ) {
				m = 0;
			} else if ( m >= this.pages[0].length ) {
				m = this.pages[0].length - 1;
			}

			y = this.pages[0][m].y;
		}

		return {
			x: x,
			y: y,
			pageX: i,
			pageY: m
		};
	},

	goToPage: function (x, y, time, easing) {
		easing = easing || this.options.bounceEasing;

		if ( x >= this.pages.length ) {
			x = this.pages.length - 1;
		} else if ( x < 0 ) {
			x = 0;
		}

		if ( y >= this.pages[x].length ) {
			y = this.pages[x].length - 1;
		} else if ( y < 0 ) {
			y = 0;
		}

		var posX = this.pages[x][y].x,
			posY = this.pages[x][y].y;

		time = time === undefined ? this.options.snapSpeed || Math.max(
			Math.max(
				Math.min(Math.abs(posX - this.x), 1000),
				Math.min(Math.abs(posY - this.y), 1000)
			), 300) : time;

		this.currentPage = {
			x: posX,
			y: posY,
			pageX: x,
			pageY: y
		};
        this._execEvent('scrollEnd',{});
		this.scrollTo(posX, posY, time, easing);
	},

	next: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x++;

		if ( x >= this.pages.length && this.hasVerticalScroll ) {
			x = 0;
			y++;
		}

		this.goToPage(x, y, time, easing);
	},

	prev: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x--;

		if ( x < 0 && this.hasVerticalScroll ) {
			x = 0;
			y--;
		}

		this.goToPage(x, y, time, easing);
	},

	_initKeys: function (e) {
		// default key bindings
		var keys = {
			pageUp: 33,
			pageDown: 34,
			end: 35,
			home: 36,
			left: 37,
			up: 38,
			right: 39,
			down: 40
		};
		var i;

		// if you give me characters I give you keycode
		if ( typeof this.options.keyBindings == 'object' ) {
			for ( i in this.options.keyBindings ) {
				if ( typeof this.options.keyBindings[i] == 'string' ) {
					this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
				}
			}
		} else {
			this.options.keyBindings = {};
		}

		for ( i in keys ) {
			this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
		}

		utils.addEvent(window, 'keydown', this);

		this.on('destroy', function () {
			utils.removeEvent(window, 'keydown', this);
		});
	},

	_key: function (e) {
		if ( !this.enabled ) {
			return;
		}

		var snap = this.options.snap,	// we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			newY = snap ? this.currentPage.pageY : this.y,
			now = utils.getTime(),
			prevTime = this.keyTime || 0,
			acceleration = 0.250,
			pos;

		if ( this.options.useTransition && this.isInTransition ) {
			pos = this.getComputedPosition();

			this._translate(Math.round(pos.x), Math.round(pos.y));
			this.isInTransition = false;
		}

		this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

		switch ( e.keyCode ) {
			case this.options.keyBindings.pageUp:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX += snap ? 1 : this.wrapperWidth;
				} else {
					newY += snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.pageDown:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX -= snap ? 1 : this.wrapperWidth;
				} else {
					newY -= snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.end:
				newX = snap ? this.pages.length-1 : this.maxScrollX;
				newY = snap ? this.pages[0].length-1 : this.maxScrollY;
				break;
			case this.options.keyBindings.home:
				newX = 0;
				newY = 0;
				break;
			case this.options.keyBindings.left:
				newX += snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.up:
				newY += snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.right:
				newX -= snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.down:
				newY -= snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			default:
				return;
		}

		if ( snap ) {
			this.goToPage(newX, newY);
			return;
		}

		if ( newX > 0 ) {
			newX = 0;
			this.keyAcceleration = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
			this.keyAcceleration = 0;
		}

		if ( newY > 0 ) {
			newY = 0;
			this.keyAcceleration = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
			this.keyAcceleration = 0;
		}

		this.scrollTo(newX, newY, 0);

		this.keyTime = now;
	},

	_animate: function (destX, destY, duration, easingFn) {
		var that = this,
			startX = this.x,
			startY = this.y,
			startTime = utils.getTime(),
			destTime = startTime + duration;

		function step () {
			var now = utils.getTime(),
				newX, newY,
				easing;

			if ( now >= destTime ) {
				that.isAnimating = false;
				that._translate(destX, destY);

				if ( !that.resetPosition(that.options.bounceTime) ) {
					that._execEvent('scrollEnd',{});
				}

				return;
			}

			now = ( now - startTime ) / duration;
			easing = easingFn(now);
			newX = ( destX - startX ) * easing + startX;
			newY = ( destY - startY ) * easing + startY;
			that._translate(newX, newY);

			if ( that.isAnimating ) {
				rAF(step);
			}

			if ( that.options.probeType == 3 ) {
				that._execEvent('scroll',{});
			}
		}

		this.isAnimating = true;
		step();
	},

	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			case 'orientationchange':
			case 'resize':
				this._resize();
				break;
			case 'transitionend':
			case 'webkitTransitionEnd':
			case 'oTransitionEnd':
			case 'MSTransitionEnd':
				this._transitionEnd(e);
				break;
			case 'wheel':
			case 'DOMMouseScroll':
			case 'mousewheel':
				this._wheel(e);
				break;
			case 'keydown':
				this._key(e);
				break;
			case 'click':
				if ( !e._constructed ) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
		}
	}
};
function createDefaultScrollbar (direction, interactive, type) {
	var scrollbar = document.createElement('div'),
		indicator = document.createElement('div');

	if ( type === true ) {
		scrollbar.style.cssText = 'position:absolute;z-index:9999';
		indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
	}

	indicator.className = 'iScrollIndicator';

	if ( direction == 'h' ) {
		if ( type === true ) {
			scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
			indicator.style.height = '100%';
		}
		scrollbar.className = 'iScrollHorizontalScrollbar';
	} else {
		if ( type === true ) {
			scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
			indicator.style.width = '100%';
		}
		scrollbar.className = 'iScrollVerticalScrollbar';
	}

	scrollbar.style.cssText += ';overflow:hidden';

	if ( !interactive ) {
		scrollbar.style.pointerEvents = 'none';
	}

	scrollbar.appendChild(indicator);

	return scrollbar;
}

function Indicator (scroller, options) {
	this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
	this.wrapperStyle = this.wrapper.style;
	this.indicator = this.wrapper.children[0];
	this.indicatorStyle = this.indicator.style;
	this.scroller = scroller;

	this.options = {
		listenX: true,
		listenY: true,
		interactive: false,
		resize: true,
		defaultScrollbars: false,
		shrink: false,
		fade: false,
		speedRatioX: 0,
		speedRatioY: 0
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	this.sizeRatioX = 1;
	this.sizeRatioY = 1;
	this.maxPosX = 0;
	this.maxPosY = 0;

	if ( this.options.interactive ) {
		if ( !this.options.disableTouch ) {
			utils.addEvent(this.indicator, 'touchstart', this);
			utils.addEvent(window, 'touchend', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(this.indicator, 'MSPointerDown', this);
			utils.addEvent(window, 'MSPointerUp', this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(this.indicator, 'mousedown', this);
			utils.addEvent(window, 'mouseup', this);
		}
	}

	if ( this.options.fade ) {
		this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
		this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
		this.wrapperStyle.opacity = '0';
	}
}

Indicator.prototype = {
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
		}
	},

	destroy: function () {
		if ( this.options.interactive ) {
			utils.removeEvent(this.indicator, 'touchstart', this);
			utils.removeEvent(this.indicator, 'MSPointerDown', this);
			utils.removeEvent(this.indicator, 'mousedown', this);

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, 'MSPointerMove', this);
			utils.removeEvent(window, 'mousemove', this);

			utils.removeEvent(window, 'touchend', this);
			utils.removeEvent(window, 'MSPointerUp', this);
			utils.removeEvent(window, 'mouseup', this);
		}

		if ( this.options.defaultScrollbars ) {
			this.wrapper.parentNode.removeChild(this.wrapper);
		}
	},

	_start: function (e) {
		var point = e.touches ? e.touches[0] : e;

		e.preventDefault();
		e.stopPropagation();

		this.transitionTime();

		this.initiated = true;
		this.moved = false;
		this.lastPointX	= point.pageX;
		this.lastPointY	= point.pageY;

		this.startTime	= utils.getTime();

		if ( !this.options.disableTouch ) {
			utils.addEvent(window, 'touchmove', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(window, 'MSPointerMove', this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(window, 'mousemove', this);
		}

		this.scroller._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		var point = e.touches ? e.touches[0] : e,
			deltaX, deltaY,
			newX, newY,
			timestamp = utils.getTime();


		if ( !this.moved ) {
			this.scroller._execEvent('scrollStart');
		}

		this.moved = true;

		deltaX = point.pageX - this.lastPointX;
		this.lastPointX = point.pageX;

		deltaY = point.pageY - this.lastPointY;
		this.lastPointY = point.pageY;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		this._pos(newX, newY);


		if ( this.scroller.options.probeType == 1 && timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.scroller._execEvent('scroll',e);
		} else if ( this.scroller.options.probeType > 1 ) {
			this.scroller._execEvent('scroll',e);
		}


// INSERT POINT: indicator._move

		e.preventDefault();
		e.stopPropagation();
	},

	_end: function (e) {
		if ( !this.initiated ) {
			return;
		}

		this.initiated = false;

		e.preventDefault();
		e.stopPropagation();

		utils.removeEvent(window, 'touchmove', this);
		utils.removeEvent(window, 'MSPointerMove', this);
		utils.removeEvent(window, 'mousemove', this);

		if ( this.scroller.options.snap ) {
			var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.scroller.x - snap.x), 1000),
						Math.min(Math.abs(this.scroller.y - snap.y), 1000)
					), 300);

			if ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {
				this.scroller.directionX = 0;
				this.scroller.directionY = 0;
				this.scroller.currentPage = snap;
				this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
			}
		}

		if ( this.moved ) {
			this.scroller._execEvent('scrollEnd',e);
		}
	},

	transitionTime: function (time) {
		time = time || 0;
		this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
		}
	},

	transitionTimingFunction: function (easing) {
		this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
	},

	refresh: function () {
		this.transitionTime();

		if ( this.options.listenX && !this.options.listenY ) {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
		} else if ( this.options.listenY && !this.options.listenX ) {
			this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
		} else {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
		}

		if ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {
			utils.addClass(this.wrapper, 'iScrollBothScrollbars');
			utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '8px';
				} else {
					this.wrapper.style.bottom = '8px';
				}
			}
		} else {
			utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
			utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '2px';
				} else {
					this.wrapper.style.bottom = '2px';
				}
			}
		}

		var r = this.wrapper.offsetHeight;	// force refresh

		if ( this.options.listenX ) {
			this.wrapperWidth = this.wrapper.clientWidth;
			if ( this.options.resize ) {
				this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
				this.indicatorStyle.width = this.indicatorWidth + 'px';
			} else {
				this.indicatorWidth = this.indicator.clientWidth;
			}

			this.maxPosX = this.wrapperWidth - this.indicatorWidth;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryX = -this.indicatorWidth + 8;
				this.maxBoundaryX = this.wrapperWidth - 8;
			} else {
				this.minBoundaryX = 0;
				this.maxBoundaryX = this.maxPosX;
			}

			this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
		}

		if ( this.options.listenY ) {
			this.wrapperHeight = this.wrapper.clientHeight;
			if ( this.options.resize ) {
				this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
				this.indicatorStyle.height = this.indicatorHeight + 'px';
			} else {
				this.indicatorHeight = this.indicator.clientHeight;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryY = -this.indicatorHeight + 8;
				this.maxBoundaryY = this.wrapperHeight - 8;
			} else {
				this.minBoundaryY = 0;
				this.maxBoundaryY = this.maxPosY;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;
			this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
		}

		this.updatePosition();
	},

	updatePosition: function () {
		var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

		if ( !this.options.ignoreBoundaries ) {
			if ( x < this.minBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth + x, 8);
					this.indicatorStyle.width = this.width + 'px';
				}
				x = this.minBoundaryX;
			} else if ( x > this.maxBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
					this.indicatorStyle.width = this.width + 'px';
					x = this.maxPosX + this.indicatorWidth - this.width;
				} else {
					x = this.maxBoundaryX;
				}
			} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {
				this.width = this.indicatorWidth;
				this.indicatorStyle.width = this.width + 'px';
			}

			if ( y < this.minBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight + y * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
				}
				y = this.minBoundaryY;
			} else if ( y > this.maxBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
					y = this.maxPosY + this.indicatorHeight - this.height;
				} else {
					y = this.maxBoundaryY;
				}
			} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {
				this.height = this.indicatorHeight;
				this.indicatorStyle.height = this.height + 'px';
			}
		}

		this.x = x;
		this.y = y;

		if ( this.scroller.options.useTransform ) {
			this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
		} else {
			this.indicatorStyle.left = x + 'px';
			this.indicatorStyle.top = y + 'px';
		}
	},

	_pos: function (x, y) {
		if ( x < 0 ) {
			x = 0;
		} else if ( x > this.maxPosX ) {
			x = this.maxPosX;
		}

		if ( y < 0 ) {
			y = 0;
		} else if ( y > this.maxPosY ) {
			y = this.maxPosY;
		}

		x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
		y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

		this.scroller.scrollTo(x, y);
	},

	fade: function (val, hold) {
		if ( hold && !this.visible ) {
			return;
		}

		clearTimeout(this.fadeTimeout);
		this.fadeTimeout = null;

		var time = val ? 250 : 500,
			delay = val ? 0 : 300;

		val = val ? '1' : '0';

		this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

		this.fadeTimeout = setTimeout((function (val) {
			this.wrapperStyle.opacity = val;
			this.visible = +val;
		}).bind(this, val), delay);
	}
};

IScroll.utils = utils;

if ( typeof module != 'undefined' && module.exports ) {
	module.exports = IScroll;
} else {
	window.iScroll = IScroll;
}

})(window, document, Math);
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    var pixiContext  = manager.options.pixiContext;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    // 小包装的处理句柄，用来为manager启动状态和作用域
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            if(pixiContext){
                self.handler(ev.originalEvent);
            }else{
                self.handler(ev);
            }
        }
    };

    if (pixiContext) {
        pixiContext.mousedown = pixiContext.touchstart = function(ev){
            manager.options.returnStart(ev.originalEvent);
            self.domHandler(ev)
        }
        pixiContext.mousemove = pixiContext.touchmove = function(ev){
            manager.options.returnMove(ev.originalEvent);
            self.domHandler(ev)
        }
        pixiContext.mouseup   = pixiContext.touchend = this.domHandler
    } else {
        this.init();
    }
}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     * 开始绑定事件
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        //move up事件绑到window上面
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * 用个这Manager构造器创建一个输入类型的管理
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput; //移动手机端
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput; //桌面
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * 处理输入事件
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    //触发点数量
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    //输入的顺序
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    //取布尔值
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    // 计算缩放、旋转等
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    //运行识别器
    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * 扩展数据和一些有用的属性如缩放、旋转、速度等
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    // 多点判断
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';


/**
 * 鼠标输入，桌面PC
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    //用来禁止TouchMouse事件
    this.allow = true; // used by Input.TouchMouse to disable mouse events
    //鼠标按下的状态
    this.pressed = false; // mousedown state
    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        //定义的事件类型
        // mousedown: 1
        // mousemove: 2
        // mouseup: 4
        var eventType = MOUSE_INPUT_MAP[ev.type];


        // on start we want to have the left mouse button down
        // 开始我们按下鼠标左键
        if (eventType & INPUT_START && ev.button === 0) {
            //按下标记
            this.pressed = true;
        }

        //如果是移动事件，并且不是左键触发  
        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        // 如果鼠标不是通过按下触发的，算错误的处理，直接返回
        if (!this.pressed || !this.allow) {
            return;
        }

        //如果是up事件
        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * 识别器流程
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * 每一个识别器都要需要继承基类
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        // 拷贝一份新的输入对象
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});


/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    //配置手势识别器参数
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * 如果DOM事件被触发设置设置DOM事件
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    //存在on回调
    //swipe [callback1,callback2...]
    //tap [callback1,callback2...]
    this.handlers = {};

    this.session = {};

    //存放手势对象
    this.recognizers = [];

    this.element = element;

    //创建一个输入环境的实例对象
    //绑定事件与增加处理的句柄回调函数
    this.input = createInputInstance(this);

    //用于处理元素对touchAction的属性的支持
    if (!this.options.pixiContext) {
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
    }

    //默认初始化手势
    each(options.recognizers, function(item) {
        //构建手势对象，增加到手势容器里面
        var recognizer = this.add(new (item[0])(item[1]));
        //如果有合并的手势处理
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction && this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];
            // find out if we are allowed try to recognize the input for this one.
            // 果我们允许尝试识别的输入，找到它
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * 通过手势的事件名得到手势对象
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        // 如果存在指定手势，删除
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        //加入管理队列
        this.recognizers.push(recognizer);
        recognizer.manager = this;

        //更新touchAction属性
        this.touchAction && this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction && this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');
//苗苗学
//嵌套iframe都不加载cordove
if (!Xut.plat.isBrowser && !MMXCONFIG) {
//IOS
if (Xut.plat.isIOS) {


    // Platform: ios
    // 91157c2e1bf3eb098c7e2ab31404e895ccb0df2a
    /*
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
     */
    ;
    (function() {
      var PLATFORM_VERSION_BUILD_LABEL = '3.7.0';
      // file: src/scripts/require.js

      /*jshint -W079 */
      /*jshint -W020 */

      var require,
        define;

      (function() {
        var modules = {},
          // Stack of moduleIds currently being built.
          requireStack = [],
          // Map of module ID -> index into requireStack of modules currently being built.
          inProgressModules = {},
          SEPARATOR = ".";



        function build(module) {
          var factory = module.factory,
            localRequire = function(id) {
              var resultantId = id;
              //Its a relative path, so lop off the last portion and add the id (minus "./")
              if (id.charAt(0) === ".") {
                resultantId = module.id.slice(0, module.id.lastIndexOf(SEPARATOR)) + SEPARATOR + id.slice(2);
              }
              return require(resultantId);
            };
          module.exports = {};
          delete module.factory;
          factory(localRequire, module.exports, module);
          return module.exports;
        }

        require = function(id) {
          if (!modules[id]) {
            throw "module " + id + " not found";
          } else if (id in inProgressModules) {
            var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;
            throw "Cycle in require graph: " + cycle;
          }
          if (modules[id].factory) {
            try {
              inProgressModules[id] = requireStack.length;
              requireStack.push(id);
              return build(modules[id]);
            } finally {
              delete inProgressModules[id];
              requireStack.pop();
            }
          }
          return modules[id].exports;
        };

        define = function(id, factory) {
          if (modules[id]) {
            throw "module " + id + " already defined";
          }

          modules[id] = {
            id: id,
            factory: factory
          };
        };

        define.remove = function(id) {
          delete modules[id];
        };

        define.moduleMap = modules;
      })();

      //Export for use in node
      if (typeof module === "object" && typeof require === "function") {
        module.exports.require = require;
        module.exports.define = define;
      }

      // file: src/cordova.js
      define("cordova", function(require, exports, module) {


        var channel = require('cordova/channel');
        var platform = require('cordova/platform');

        /**
         * Intercept calls to addEventListener + removeEventListener and handle deviceready,
         * resume, and pause events.
         */
        var m_document_addEventListener = document.addEventListener;
        var m_document_removeEventListener = document.removeEventListener;
        var m_window_addEventListener = window.addEventListener;
        var m_window_removeEventListener = window.removeEventListener;

        /**
         * Houses custom event handlers to intercept on document + window event listeners.
         */
        var documentEventHandlers = {},
          windowEventHandlers = {};

        document.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if (typeof documentEventHandlers[e] != 'undefined') {
            documentEventHandlers[e].subscribe(handler);
          } else {
            m_document_addEventListener.call(document, evt, handler, capture);
          }
        };

        window.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if (typeof windowEventHandlers[e] != 'undefined') {
            windowEventHandlers[e].subscribe(handler);
          } else {
            m_window_addEventListener.call(window, evt, handler, capture);
          }
        };

        document.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if (typeof documentEventHandlers[e] != "undefined") {
            documentEventHandlers[e].unsubscribe(handler);
          } else {
            m_document_removeEventListener.call(document, evt, handler, capture);
          }
        };

        window.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if (typeof windowEventHandlers[e] != "undefined") {
            windowEventHandlers[e].unsubscribe(handler);
          } else {
            m_window_removeEventListener.call(window, evt, handler, capture);
          }
        };

        function createEvent(type, data) {
          var event = document.createEvent('Events');
          event.initEvent(type, false, false);
          if (data) {
            for (var i in data) {
              if (data.hasOwnProperty(i)) {
                event[i] = data[i];
              }
            }
          }
          return event;
        }


        var cordova = {
          define: define,
          require: require,
          version: PLATFORM_VERSION_BUILD_LABEL,
          platformVersion: PLATFORM_VERSION_BUILD_LABEL,
          platformId: platform.id,
          /**
           * Methods to add/remove your own addEventListener hijacking on document + window.
           */
          addWindowEventHandler: function(event) {
            return (windowEventHandlers[event] = channel.create(event));
          },
          addStickyDocumentEventHandler: function(event) {
            return (documentEventHandlers[event] = channel.createSticky(event));
          },
          addDocumentEventHandler: function(event) {
            return (documentEventHandlers[event] = channel.create(event));
          },
          removeWindowEventHandler: function(event) {
            delete windowEventHandlers[event];
          },
          removeDocumentEventHandler: function(event) {
            delete documentEventHandlers[event];
          },
          /**
           * Retrieve original event handlers that were replaced by Cordova
           *
           * @return object
           */
          getOriginalHandlers: function() {
            return {
              'document': {
                'addEventListener': m_document_addEventListener,
                'removeEventListener': m_document_removeEventListener
              },
              'window': {
                'addEventListener': m_window_addEventListener,
                'removeEventListener': m_window_removeEventListener
              }
            };
          },
          /**
           * Method to fire event from native code
           * bNoDetach is required for events which cause an exception which needs to be caught in native code
           */
          fireDocumentEvent: function(type, data, bNoDetach) {
            var evt = createEvent(type, data);
            if (typeof documentEventHandlers[type] != 'undefined') {
              if (bNoDetach) {
                documentEventHandlers[type].fire(evt);
              } else {
                setTimeout(function() {
                  // Fire deviceready on listeners that were registered before cordova.js was loaded.
                  if (type == 'deviceready') {
                    document.dispatchEvent(evt);
                  }
                  documentEventHandlers[type].fire(evt);
                }, 0);
              }
            } else {
              document.dispatchEvent(evt);
            }
          },
          fireWindowEvent: function(type, data) {
            var evt = createEvent(type, data);
            if (typeof windowEventHandlers[type] != 'undefined') {
              setTimeout(function() {
                windowEventHandlers[type].fire(evt);
              }, 0);
            } else {
              window.dispatchEvent(evt);
            }
          },

          /**
           * Plugin callback mechanism.
           */
          // Randomize the starting callbackId to avoid collisions after refreshing or navigating.
          // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.
          callbackId: Math.floor(Math.random() * 2000000000),
          callbacks: {},
          callbackStatus: {
            NO_RESULT: 0,
            OK: 1,
            CLASS_NOT_FOUND_EXCEPTION: 2,
            ILLEGAL_ACCESS_EXCEPTION: 3,
            INSTANTIATION_EXCEPTION: 4,
            MALFORMED_URL_EXCEPTION: 5,
            IO_EXCEPTION: 6,
            INVALID_ACTION: 7,
            JSON_EXCEPTION: 8,
            ERROR: 9
          },

          /**
           * Called by native code when returning successful result from an action.
           */
          callbackSuccess: function(callbackId, args) {
            cordova.callbackFromNative(callbackId, true, args.status, [args.message], args.keepCallback);
          },

          /**
           * Called by native code when returning error result from an action.
           */
          callbackError: function(callbackId, args) {
            // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.
            // Derive success from status.
            cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);
          },

          /**
           * Called by native code when returning the result from an action.
           */
          callbackFromNative: function(callbackId, isSuccess, status, args, keepCallback) {
            try {
              var callback = cordova.callbacks[callbackId];
              if (callback) {
                if (isSuccess && status == cordova.callbackStatus.OK) {
                  callback.success && callback.success.apply(null, args);
                } else {
                  callback.fail && callback.fail.apply(null, args);
                }

                // Clear callback if not expecting any more results
                if (!keepCallback) {
                  delete cordova.callbacks[callbackId];
                }
              }
            } catch (err) {
              var msg = "Error in " + (isSuccess ? "Success" : "Error") + " callbackId: " + callbackId + " : " + err;
              console && console.log && console.log(msg);
              cordova.fireWindowEvent("cordovacallbackerror", {
                'message': msg
              });
              throw err;
            }
          },
          addConstructor: function(func) {
            channel.onCordovaReady.subscribe(function() {
              try {
                func();
              } catch (e) {
                console.log("Failed to run constructor: " + e);
              }
            });
          }
        };


        module.exports = cordova;

      });

      // file: src/common/argscheck.js
      define("cordova/argscheck", function(require, exports, module) {

        var exec = require('cordova/exec');
        var utils = require('cordova/utils');

        var moduleExports = module.exports;

        var typeMap = {
          'A': 'Array',
          'D': 'Date',
          'N': 'Number',
          'S': 'String',
          'F': 'Function',
          'O': 'Object'
        };

        function extractParamName(callee, argIndex) {
          return (/.*?\((.*?)\)/).exec(callee)[1].split(', ')[argIndex];
        }

        function checkArgs(spec, functionName, args, opt_callee) {
          if (!moduleExports.enableChecks) {
            return;
          }
          var errMsg = null;
          var typeName;
          for (var i = 0; i < spec.length; ++i) {
            var c = spec.charAt(i),
              cUpper = c.toUpperCase(),
              arg = args[i];
            // Asterix means allow anything.
            if (c == '*') {
              continue;
            }
            typeName = utils.typeName(arg);
            if ((arg === null || arg === undefined) && c == cUpper) {
              continue;
            }
            if (typeName != typeMap[cUpper]) {
              errMsg = 'Expected ' + typeMap[cUpper];
              break;
            }
          }
          if (errMsg) {
            errMsg += ', but got ' + typeName + '.';
            errMsg = 'Wrong type for parameter "' + extractParamName(opt_callee || args.callee, i) + '" of ' + functionName + ': ' + errMsg;
            // Don't log when running unit tests.
            if (typeof jasmine == 'undefined') {
              console.error(errMsg);
            }
            throw TypeError(errMsg);
          }
        }

        function getValue(value, defaultValue) {
          return value === undefined ? defaultValue : value;
        }

        moduleExports.checkArgs = checkArgs;
        moduleExports.getValue = getValue;
        moduleExports.enableChecks = true;


      });

      // file: src/common/base64.js
      define("cordova/base64", function(require, exports, module) {

        var base64 = exports;

        base64.fromArrayBuffer = function(arrayBuffer) {
          var array = new Uint8Array(arrayBuffer);
          return uint8ToBase64(array);
        };

        base64.toArrayBuffer = function(str) {
          var decodedStr = typeof atob != 'undefined' ? atob(str) : new Buffer(str, 'base64').toString('binary');
          var arrayBuffer = new ArrayBuffer(decodedStr.length);
          var array = new Uint8Array(arrayBuffer);
          for (var i = 0, len = decodedStr.length; i < len; i++) {
            array[i] = decodedStr.charCodeAt(i);
          }
          return arrayBuffer;
        };

        //------------------------------------------------------------------------------

        /* This code is based on the performance tests at http://jsperf.com/b64tests
         * This 12-bit-at-a-time algorithm was the best performing version on all
         * platforms tested.
         */

        var b64_6bit = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var b64_12bit;

        var b64_12bitTable = function() {
          b64_12bit = [];
          for (var i = 0; i < 64; i++) {
            for (var j = 0; j < 64; j++) {
              b64_12bit[i * 64 + j] = b64_6bit[i] + b64_6bit[j];
            }
          }
          b64_12bitTable = function() {
            return b64_12bit;
          };
          return b64_12bit;
        };

        function uint8ToBase64(rawData) {
          var numBytes = rawData.byteLength;
          var output = "";
          var segment;
          var table = b64_12bitTable();
          for (var i = 0; i < numBytes - 2; i += 3) {
            segment = (rawData[i] << 16) + (rawData[i + 1] << 8) + rawData[i + 2];
            output += table[segment >> 12];
            output += table[segment & 0xfff];
          }
          if (numBytes - i == 2) {
            segment = (rawData[i] << 16) + (rawData[i + 1] << 8);
            output += table[segment >> 12];
            output += b64_6bit[(segment & 0xfff) >> 6];
            output += '=';
          } else if (numBytes - i == 1) {
            segment = (rawData[i] << 16);
            output += table[segment >> 12];
            output += '==';
          }
          return output;
        }

      });

      // file: src/common/builder.js
      define("cordova/builder", function(require, exports, module) {

        var utils = require('cordova/utils');

        function each(objects, func, context) {
          for (var prop in objects) {
            if (objects.hasOwnProperty(prop)) {
              func.apply(context, [objects[prop], prop]);
            }
          }
        }

        function clobber(obj, key, value) {
          exports.replaceHookForTesting(obj, key);
          obj[key] = value;
          // Getters can only be overridden by getters.
          if (obj[key] !== value) {
            utils.defineGetter(obj, key, function() {
              return value;
            });
          }
        }

        function assignOrWrapInDeprecateGetter(obj, key, value, message) {
          if (message) {
            utils.defineGetter(obj, key, function() {
              console.log(message);
              delete obj[key];
              clobber(obj, key, value);
              return value;
            });
          } else {
            clobber(obj, key, value);
          }
        }

        function include(parent, objects, clobber, merge) {
          each(objects, function(obj, key) {
            try {
              var result = obj.path ? require(obj.path) : {};

              if (clobber) {
                // Clobber if it doesn't exist.
                if (typeof parent[key] === 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else if (typeof obj.path !== 'undefined') {
                  // If merging, merge properties onto parent, otherwise, clobber.
                  if (merge) {
                    recursiveMerge(parent[key], result);
                  } else {
                    assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                  }
                }
                result = parent[key];
              } else {
                // Overwrite if not currently defined.
                if (typeof parent[key] == 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else {
                  // Set result to what already exists, so we can build children into it if they exist.
                  result = parent[key];
                }
              }

              if (obj.children) {
                include(result, obj.children, clobber, merge);
              }
            } catch (e) {
              utils.alert('Exception building Cordova JS globals: ' + e + ' for key "' + key + '"');
            }
          });
        }

        /**
         * Merge properties from one object onto another recursively.  Properties from
         * the src object will overwrite existing target property.
         *
         * @param target Object to merge properties into.
         * @param src Object to merge properties from.
         */
        function recursiveMerge(target, src) {
          for (var prop in src) {
            if (src.hasOwnProperty(prop)) {
              if (target.prototype && target.prototype.constructor === target) {
                // If the target object is a constructor override off prototype.
                clobber(target.prototype, prop, src[prop]);
              } else {
                if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {
                  recursiveMerge(target[prop], src[prop]);
                } else {
                  clobber(target, prop, src[prop]);
                }
              }
            }
          }
        }

        exports.buildIntoButDoNotClobber = function(objects, target) {
          include(target, objects, false, false);
        };
        exports.buildIntoAndClobber = function(objects, target) {
          include(target, objects, true, false);
        };
        exports.buildIntoAndMerge = function(objects, target) {
          include(target, objects, true, true);
        };
        exports.recursiveMerge = recursiveMerge;
        exports.assignOrWrapInDeprecateGetter = assignOrWrapInDeprecateGetter;
        exports.replaceHookForTesting = function() {};

      });

      // file: src/common/channel.js
      define("cordova/channel", function(require, exports, module) {

        var utils = require('cordova/utils'),
          nextGuid = 1;

        /**
         * Custom pub-sub "channel" that can have functions subscribed to it
         * This object is used to define and control firing of events for
         * cordova initialization, as well as for custom events thereafter.
         *
         * The order of events during page load and Cordova startup is as follows:
         *
         * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.
         * onNativeReady*              Internal event that indicates the Cordova native side is ready.
         * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.
         * onDeviceReady*              User event fired to indicate that Cordova is ready
         * onResume                    User event fired to indicate a start/resume lifecycle event
         * onPause                     User event fired to indicate a pause lifecycle event
         * onDestroy*                  Internal event fired when app is being destroyed (User should use window.onunload event, not this one).
         *
         * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.
         * All listeners that subscribe after the event is fired will be executed right away.
         *
         * The only Cordova events that user code should register for are:
         *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript
         *      pause                 App has moved to background
         *      resume                App has returned to foreground
         *
         * Listeners can be registered as:
         *      document.addEventListener("deviceready", myDeviceReadyListener, false);
         *      document.addEventListener("resume", myResumeListener, false);
         *      document.addEventListener("pause", myPauseListener, false);
         *
         * The DOM lifecycle events should be used for saving and restoring state
         *      window.onload
         *      window.onunload
         *
         */

        /**
         * Channel
         * @constructor
         * @param type  String the channel name
         */
        var Channel = function(type, sticky) {
            this.type = type;
            // Map of guid -> function.
            this.handlers = {};
            // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
            this.state = sticky ? 1 : 0;
            // Used in sticky mode to remember args passed to fire().
            this.fireArgs = null;
            // Used by onHasSubscribersChange to know if there are any listeners.
            this.numHandlers = 0;
            // Function that is called when the first listener is subscribed, or when
            // the last listener is unsubscribed.
            this.onHasSubscribersChange = null;
          },
          channel = {
            /**
             * Calls the provided function only after all of the channels specified
             * have been fired. All channels must be sticky channels.
             */
            join: function(h, c) {
              var len = c.length,
                i = len,
                f = function() {
                  if (!(--i)) h();
                };
              for (var j = 0; j < len; j++) {
                if (c[j].state === 0) {
                  throw Error('Can only use join with sticky channels.');
                }
                c[j].subscribe(f);
              }
              if (!len) h();
            },
            create: function(type) {
              return channel[type] = new Channel(type, false);
            },
            createSticky: function(type) {
              return channel[type] = new Channel(type, true);
            },

            /**
             * cordova Channels that must fire before "deviceready" is fired.
             */
            deviceReadyChannelsArray: [],
            deviceReadyChannelsMap: {},

            /**
             * Indicate that a feature needs to be initialized before it is ready to be used.
             * This holds up Cordova's "deviceready" event until the feature has been initialized
             * and Cordova.initComplete(feature) is called.
             *
             * @param feature {String}     The unique feature name
             */
            waitForInitialization: function(feature) {
              if (feature) {
                var c = channel[feature] || this.createSticky(feature);
                this.deviceReadyChannelsMap[feature] = c;
                this.deviceReadyChannelsArray.push(c);
              }
            },

            /**
             * Indicate that initialization code has completed and the feature is ready to be used.
             *
             * @param feature {String}     The unique feature name
             */
            initializationComplete: function(feature) {
              var c = this.deviceReadyChannelsMap[feature];
              if (c) {
                c.fire();
              }
            }
          };

        function forceFunction(f) {
          if (typeof f != 'function') throw "Function required as first argument!";
        }

        /**
         * Subscribes the given function to the channel. Any time that
         * Channel.fire is called so too will the function.
         * Optionally specify an execution context for the function
         * and a guid that can be used to stop subscribing to the channel.
         * Returns the guid.
         */
        Channel.prototype.subscribe = function(f, c) {
          // need a function to call
          forceFunction(f);
          if (this.state == 2) {
            f.apply(c || this, this.fireArgs);
            return;
          }

          var func = f,
            guid = f.observer_guid;
          if (typeof c == "object") {
            func = utils.close(c, f);
          }

          if (!guid) {
            // first time any channel has seen this subscriber
            guid = '' + nextGuid++;
          }
          func.observer_guid = guid;
          f.observer_guid = guid;

          // Don't add the same handler more than once.
          if (!this.handlers[guid]) {
            this.handlers[guid] = func;
            this.numHandlers++;
            if (this.numHandlers == 1) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Unsubscribes the function with the given guid from the channel.
         */
        Channel.prototype.unsubscribe = function(f) {
          // need a function to unsubscribe
          forceFunction(f);

          var guid = f.observer_guid,
            handler = this.handlers[guid];
          if (handler) {
            delete this.handlers[guid];
            this.numHandlers--;
            if (this.numHandlers === 0) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Calls all functions subscribed to this channel.
         */
        Channel.prototype.fire = function(e) {
          var fail = false,
            fireArgs = Array.prototype.slice.call(arguments);
          // Apply stickiness.
          if (this.state == 1) {
            this.state = 2;
            this.fireArgs = fireArgs;
          }
          if (this.numHandlers) {
            // Copy the values first so that it is safe to modify it from within
            // callbacks.
            var toCall = [];
            for (var item in this.handlers) {
              toCall.push(this.handlers[item]);
            }
            for (var i = 0; i < toCall.length; ++i) {
              toCall[i].apply(this, fireArgs);
            }
            if (this.state == 2 && this.numHandlers) {
              this.numHandlers = 0;
              this.handlers = {};
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };


        // defining them here so they are ready super fast!
        // DOM event that is received when the web page is loaded and parsed.
        channel.createSticky('onDOMContentLoaded');

        // Event to indicate the Cordova native side is ready.
        channel.createSticky('onNativeReady');

        // Event to indicate that all Cordova JavaScript objects have been created
        // and it's time to run plugin constructors.
        channel.createSticky('onCordovaReady');

        // Event to indicate that all automatically loaded JS plugins are loaded and ready.
        // FIXME remove this
        channel.createSticky('onPluginsReady');

        // Event to indicate that Cordova is ready
        channel.createSticky('onDeviceReady');

        // Event to indicate a resume lifecycle event
        channel.create('onResume');

        // Event to indicate a pause lifecycle event
        channel.create('onPause');

        // Event to indicate a destroy lifecycle event
        channel.createSticky('onDestroy');

        // Channels that must fire before "deviceready" is fired.
        channel.waitForInitialization('onCordovaReady');
        channel.waitForInitialization('onDOMContentLoaded');

        module.exports = channel;

      });

      // file: src/ios/exec.js
      define("cordova/exec", function(require, exports, module) {

        /**
         * Creates a gap bridge iframe used to notify the native code about queued
         * commands.
         */
        var cordova = require('cordova'),
          channel = require('cordova/channel'),
          utils = require('cordova/utils'),
          base64 = require('cordova/base64'),
          // XHR mode does not work on iOS 4.2.
          // XHR mode's main advantage is working around a bug in -webkit-scroll, which
          // doesn't exist only on iOS 5.x devices.
          // IFRAME_NAV is the fastest.
          // IFRAME_HASH could be made to enable synchronous bridge calls if we wanted this feature.
          jsToNativeModes = {
            IFRAME_NAV: 0,
            XHR_NO_PAYLOAD: 1,
            XHR_WITH_PAYLOAD: 2,
            XHR_OPTIONAL_PAYLOAD: 3,
            IFRAME_HASH_NO_PAYLOAD: 4,
            // Bundling the payload turns out to be slower. Probably since it has to be URI encoded / decoded.
            IFRAME_HASH_WITH_PAYLOAD: 5,
            WK_WEBVIEW_BINDING: 6
          },
          bridgeMode,
          execIframe,
          execHashIframe,
          hashToggle = 1,
          execXhr,
          requestCount = 0,
          vcHeaderValue = null,
          commandQueue = [], // Contains pending JS->Native messages.
          isInContextOfEvalJs = 0;

        function createExecIframe(src, unloadListener) {
          var iframe = document.createElement("iframe");
          iframe.style.display = 'none';
          // Both the unload listener and the src must be set before adding the iframe
          // to the document in order to avoid race conditions. Callbacks from native
          // can happen within the appendChild() call!
          iframe.onunload = unloadListener;
          iframe.src = src;
          document.body.appendChild(iframe);
          return iframe;
        }

        function createHashIframe() {
          var ret = createExecIframe('about:blank');
          // Hash changes don't work on about:blank, so switch it to file:///.
          ret.contentWindow.history.replaceState(null, null, 'file:///#');
          return ret;
        }

        function shouldBundleCommandJson() {
          if (bridgeMode === jsToNativeModes.XHR_WITH_PAYLOAD) {
            return true;
          }
          if (bridgeMode === jsToNativeModes.XHR_OPTIONAL_PAYLOAD) {
            var payloadLength = 0;
            for (var i = 0; i < commandQueue.length; ++i) {
              payloadLength += commandQueue[i].length;
            }
            // The value here was determined using the benchmark within CordovaLibApp on an iPad 3.
            return payloadLength < 4500;
          }
          return false;
        }

        function massageArgsJsToNative(args) {
          if (!args || utils.typeName(args) != 'Array') {
            return args;
          }
          var ret = [];
          args.forEach(function(arg, i) {
            if (utils.typeName(arg) == 'ArrayBuffer') {
              ret.push({
                'CDVType': 'ArrayBuffer',
                'data': base64.fromArrayBuffer(arg)
              });
            } else {
              ret.push(arg);
            }
          });
          return ret;
        }

        function massageMessageNativeToJs(message) {
          if (message.CDVType == 'ArrayBuffer') {
            var stringToArrayBuffer = function(str) {
              var ret = new Uint8Array(str.length);
              for (var i = 0; i < str.length; i++) {
                ret[i] = str.charCodeAt(i);
              }
              return ret.buffer;
            };
            var base64ToArrayBuffer = function(b64) {
              return stringToArrayBuffer(atob(b64));
            };
            message = base64ToArrayBuffer(message.data);
          }
          return message;
        }

        function convertMessageToArgsNativeToJs(message) {
          var args = [];
          if (!message || !message.hasOwnProperty('CDVType')) {
            args.push(message);
          } else if (message.CDVType == 'MultiPart') {
            message.messages.forEach(function(e) {
              args.push(massageMessageNativeToJs(e));
            });
          } else {
            args.push(massageMessageNativeToJs(message));
          }
          return args;
        }

        function iOSExec() {
          if (bridgeMode === undefined) {
            bridgeMode = jsToNativeModes.IFRAME_NAV;
          }

          if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.cordova && window.webkit.messageHandlers.cordova.postMessage) {
            bridgeMode = jsToNativeModes.WK_WEBVIEW_BINDING;
          }

          var successCallback, failCallback, service, action, actionArgs, splitCommand;
          var callbackId = null;
          if (typeof arguments[0] !== "string") {
            // FORMAT ONE
            successCallback = arguments[0];
            failCallback = arguments[1];
            service = arguments[2];
            action = arguments[3];
            actionArgs = arguments[4];

            // Since we need to maintain backwards compatibility, we have to pass
            // an invalid callbackId even if no callback was provided since plugins
            // will be expecting it. The Cordova.exec() implementation allocates
            // an invalid callbackId and passes it even if no callbacks were given.
            callbackId = 'INVALID';
          } else {
            // FORMAT TWO, REMOVED
            try {
              splitCommand = arguments[0].split(".");
              action = splitCommand.pop();
              service = splitCommand.join(".");
              actionArgs = Array.prototype.splice.call(arguments, 1);

              console.log('The old format of this exec call has been removed (deprecated since 2.1). Change to: ' +
                "cordova.exec(null, null, \"" + service + "\", \"" + action + "\"," + JSON.stringify(actionArgs) + ");"
              );
              return;
            } catch (e) {}
          }

          // If actionArgs is not provided, default to an empty array
          actionArgs = actionArgs || [];

          // Register the callbacks and add the callbackId to the positional
          // arguments if given.
          if (successCallback || failCallback) {
            callbackId = service + cordova.callbackId++;
            cordova.callbacks[callbackId] = {
              success: successCallback,
              fail: failCallback
            };
          }

          actionArgs = massageArgsJsToNative(actionArgs);

          var command = [callbackId, service, action, actionArgs];

          // Stringify and queue the command. We stringify to command now to
          // effectively clone the command arguments in case they are mutated before
          // the command is executed.
          commandQueue.push(JSON.stringify(command));

          if (bridgeMode === jsToNativeModes.WK_WEBVIEW_BINDING) {
            window.webkit.messageHandlers.cordova.postMessage(command);
          } else {
            // If we're in the context of a stringByEvaluatingJavaScriptFromString call,
            // then the queue will be flushed when it returns; no need for a poke.
            // Also, if there is already a command in the queue, then we've already
            // poked the native side, so there is no reason to do so again.
            if (!isInContextOfEvalJs && commandQueue.length == 1) {
              switch (bridgeMode) {
                case jsToNativeModes.XHR_NO_PAYLOAD:
                case jsToNativeModes.XHR_WITH_PAYLOAD:
                case jsToNativeModes.XHR_OPTIONAL_PAYLOAD:
                  pokeNativeViaXhr();
                  break;
                default: // iframe-based.
                  pokeNativeViaIframe();
              }
            }
          }
        }

        function pokeNativeViaXhr() {
          // This prevents sending an XHR when there is already one being sent.
          // This should happen only in rare circumstances (refer to unit tests).
          if (execXhr && execXhr.readyState != 4) {
            execXhr = null;
          }
          // Re-using the XHR improves exec() performance by about 10%.
          execXhr = execXhr || new XMLHttpRequest();
          // Changing this to a GET will make the XHR reach the URIProtocol on 4.2.
          // For some reason it still doesn't work though...
          // Add a timestamp to the query param to prevent caching.
          execXhr.open('HEAD', "/!gap_exec?" + (+new Date()), true);
          if (!vcHeaderValue) {
            vcHeaderValue = /.*\((.*)\)$/.exec(navigator.userAgent)[1];
          }
          execXhr.setRequestHeader('vc', vcHeaderValue);
          execXhr.setRequestHeader('rc', ++requestCount);
          if (shouldBundleCommandJson()) {
            execXhr.setRequestHeader('cmds', iOSExec.nativeFetchMessages());
          }
          execXhr.send(null);
        }

        function onIframeUnload() {
          execIframe = null;
          setTimeout(pokeNativeViaIframe, 0);
        }

        function pokeNativeViaIframe() {
          // CB-5488 - Don't attempt to create iframe before document.body is available.
          if (!document.body) {
            setTimeout(pokeNativeViaIframe);
            return;
          }
          if (bridgeMode === jsToNativeModes.IFRAME_HASH_NO_PAYLOAD || bridgeMode === jsToNativeModes.IFRAME_HASH_WITH_PAYLOAD) {
            // TODO: This bridge mode doesn't properly support being removed from the DOM (CB-7735)
            execHashIframe = execHashIframe || createHashIframe();
            // Check if they've removed it from the DOM, and put it back if so.
            if (!execHashIframe.contentWindow) {
              execHashIframe = createHashIframe();
            }
            // The delegate method is called only when the hash changes, so toggle it back and forth.
            hashToggle = hashToggle ^ 3;
            var hashValue = '%0' + hashToggle;
            if (bridgeMode === jsToNativeModes.IFRAME_HASH_WITH_PAYLOAD) {
              hashValue += iOSExec.nativeFetchMessages();
            }
            execHashIframe.contentWindow.location.hash = hashValue;
          } else {
            // Check if they've removed it from the DOM, and put it back if so.
            if (execIframe && execIframe.contentWindow) {
              // Listen for unload, since it can happen (CB-7735) that the iframe gets
              // removed from the DOM before it gets a chance to poke the native side.
              execIframe.contentWindow.onunload = onIframeUnload;
              execIframe.src = 'gap://ready';
            } else {
              execIframe = createExecIframe('gap://ready', onIframeUnload);
            }
          }
        }

        iOSExec.jsToNativeModes = jsToNativeModes;

        iOSExec.setJsToNativeBridgeMode = function(mode) {
          // Remove the iFrame since it may be no longer required, and its existence
          // can trigger browser bugs.
          // https://issues.apache.org/jira/browse/CB-593
          if (execIframe) {
            execIframe.parentNode.removeChild(execIframe);
            execIframe = null;
          }
          bridgeMode = mode;
        };

        iOSExec.nativeFetchMessages = function() {
          // Stop listing for window detatch once native side confirms poke.
          if (execIframe && execIframe.contentWindow) {
            execIframe.contentWindow.onunload = null;
          }
          // Each entry in commandQueue is a JSON string already.
          if (!commandQueue.length) {
            return '';
          }
          var json = '[' + commandQueue.join(',') + ']';
          commandQueue.length = 0;
          return json;
        };

        iOSExec.nativeCallback = function(callbackId, status, message, keepCallback) {
          return iOSExec.nativeEvalAndFetch(function() {
            var success = status === 0 || status === 1;
            var args = convertMessageToArgsNativeToJs(message);
            cordova.callbackFromNative(callbackId, success, status, args, keepCallback);
          });
        };

        iOSExec.nativeEvalAndFetch = function(func) {
          // This shouldn't be nested, but better to be safe.
          isInContextOfEvalJs++;
          try {
            func();
            return iOSExec.nativeFetchMessages();
          } finally {
            isInContextOfEvalJs--;
          }
        };

        module.exports = iOSExec;

      });

      // file: src/common/exec/proxy.js
      define("cordova/exec/proxy", function(require, exports, module) {


        // internal map of proxy function
        var CommandProxyMap = {};

        module.exports = {

          // example: cordova.commandProxy.add("Accelerometer",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);
          add: function(id, proxyObj) {
            console.log("adding proxy for " + id);
            CommandProxyMap[id] = proxyObj;
            return proxyObj;
          },

          // cordova.commandProxy.remove("Accelerometer");
          remove: function(id) {
            var proxy = CommandProxyMap[id];
            delete CommandProxyMap[id];
            CommandProxyMap[id] = null;
            return proxy;
          },

          get: function(service, action) {
            return (CommandProxyMap[service] ? CommandProxyMap[service][action] : null);
          }
        };
      });

      // file: src/common/init.js
      define("cordova/init", function(require, exports, module) {

        var channel = require('cordova/channel');
        var cordova = require('cordova');
        var modulemapper = require('cordova/modulemapper');
        var platform = require('cordova/platform');
        var pluginloader = require('cordova/pluginloader');
        var utils = require('cordova/utils');

        var platformInitChannelsArray = [channel.onNativeReady, channel.onPluginsReady];

        function logUnfiredChannels(arr) {
          for (var i = 0; i < arr.length; ++i) {
            if (arr[i].state != 2) {
              console.log('Channel not fired: ' + arr[i].type);
            }
          }
        }

        window.setTimeout(function() {
          if (channel.onDeviceReady.state != 2) {
            console.log('deviceready has not fired after 5 seconds.');
            logUnfiredChannels(platformInitChannelsArray);
            logUnfiredChannels(channel.deviceReadyChannelsArray);
          }
        }, 5000);

        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        function replaceNavigator(origNavigator) {
          var CordovaNavigator = function() {};
          CordovaNavigator.prototype = origNavigator;
          var newNavigator = new CordovaNavigator();
          // This work-around really only applies to new APIs that are newer than Function.bind.
          // Without it, APIs such as getGamepads() break.
          if (CordovaNavigator.bind) {
            for (var key in origNavigator) {
              if (typeof origNavigator[key] == 'function') {
                newNavigator[key] = origNavigator[key].bind(origNavigator);
              } else {
                (function(k) {
                  utils.defineGetterSetter(newNavigator, key, function() {
                    return origNavigator[k];
                  });
                })(key);
              }
            }
          }
          return newNavigator;
        }

        if (window.navigator) {
          window.navigator = replaceNavigator(window.navigator);
        }

        if (!window.console) {
          window.console = {
            log: function() {}
          };
        }
        if (!window.console.warn) {
          window.console.warn = function(msg) {
            this.log("warn: " + msg);
          };
        }

        // Register pause, resume and deviceready channels as events on document.
        channel.onPause = cordova.addDocumentEventHandler('pause');
        channel.onResume = cordova.addDocumentEventHandler('resume');
        channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

        // Listen for DOMContentLoaded and notify our channel subscribers.
        if (document.readyState == 'complete' || document.readyState == 'interactive') {
          channel.onDOMContentLoaded.fire();
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            channel.onDOMContentLoaded.fire();
          }, false);
        }

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if (window._nativeReady) {
          channel.onNativeReady.fire();
        }

        modulemapper.clobbers('cordova', 'cordova');
        modulemapper.clobbers('cordova/exec', 'cordova.exec');
        modulemapper.clobbers('cordova/exec', 'Cordova.exec');

        // Call the platform-specific initialization.
        platform.bootstrap && platform.bootstrap();

        // Wrap in a setTimeout to support the use-case of having plugin JS appended to cordova.js.
        // The delay allows the attached modules to be defined before the plugin loader looks for them.
        setTimeout(function() {
          pluginloader.load(function() {
            channel.onPluginsReady.fire();
          });
        }, 0);

        /**
         * Create all cordova objects once native side is ready.
         */
        channel.join(function() {
          modulemapper.mapModules(window);

          platform.initialize && platform.initialize();

          // Fire event to notify that all objects are created
          channel.onCordovaReady.fire();

          // Fire onDeviceReady event once page has fully loaded, all
          // constructors have run and cordova info has been received from native
          // side.
          channel.join(function() {
            require('cordova').fireDocumentEvent('deviceready');
          }, channel.deviceReadyChannelsArray);

        }, platformInitChannelsArray);


      });

      // file: src/common/init_b.js
      define("cordova/init_b", function(require, exports, module) {

        var channel = require('cordova/channel');
        var cordova = require('cordova');
        var platform = require('cordova/platform');
        var utils = require('cordova/utils');

        var platformInitChannelsArray = [channel.onDOMContentLoaded, channel.onNativeReady];

        // setting exec
        cordova.exec = require('cordova/exec');

        function logUnfiredChannels(arr) {
          for (var i = 0; i < arr.length; ++i) {
            if (arr[i].state != 2) {
              console.log('Channel not fired: ' + arr[i].type);
            }
          }
        }

        window.setTimeout(function() {
          if (channel.onDeviceReady.state != 2) {
            console.log('deviceready has not fired after 5 seconds.');
            logUnfiredChannels(platformInitChannelsArray);
            logUnfiredChannels(channel.deviceReadyChannelsArray);
          }
        }, 5000);

        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        function replaceNavigator(origNavigator) {
          var CordovaNavigator = function() {};
          CordovaNavigator.prototype = origNavigator;
          var newNavigator = new CordovaNavigator();
          // This work-around really only applies to new APIs that are newer than Function.bind.
          // Without it, APIs such as getGamepads() break.
          if (CordovaNavigator.bind) {
            for (var key in origNavigator) {
              if (typeof origNavigator[key] == 'function') {
                newNavigator[key] = origNavigator[key].bind(origNavigator);
              } else {
                (function(k) {
                  utils.defineGetterSetter(newNavigator, key, function() {
                    return origNavigator[k];
                  });
                })(key);
              }
            }
          }
          return newNavigator;
        }
        if (window.navigator) {
          window.navigator = replaceNavigator(window.navigator);
        }

        if (!window.console) {
          window.console = {
            log: function() {}
          };
        }
        if (!window.console.warn) {
          window.console.warn = function(msg) {
            this.log("warn: " + msg);
          };
        }

        // Register pause, resume and deviceready channels as events on document.
        channel.onPause = cordova.addDocumentEventHandler('pause');
        channel.onResume = cordova.addDocumentEventHandler('resume');
        channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

        // Listen for DOMContentLoaded and notify our channel subscribers.
        if (document.readyState == 'complete' || document.readyState == 'interactive') {
          channel.onDOMContentLoaded.fire();
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            channel.onDOMContentLoaded.fire();
          }, false);
        }

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if (window._nativeReady) {
          channel.onNativeReady.fire();
        }

        // Call the platform-specific initialization.
        platform.bootstrap && platform.bootstrap();

        /**
         * Create all cordova objects once native side is ready.
         */
        channel.join(function() {

          platform.initialize && platform.initialize();

          // Fire event to notify that all objects are created
          channel.onCordovaReady.fire();

          // Fire onDeviceReady event once page has fully loaded, all
          // constructors have run and cordova info has been received from native
          // side.
          channel.join(function() {
            require('cordova').fireDocumentEvent('deviceready');
          }, channel.deviceReadyChannelsArray);

        }, platformInitChannelsArray);

      });

      // file: src/common/modulemapper.js
      define("cordova/modulemapper", function(require, exports, module) {

        var builder = require('cordova/builder'),
          moduleMap = define.moduleMap,
          symbolList,
          deprecationMap;

        exports.reset = function() {
          symbolList = [];
          deprecationMap = {};
        };

        function addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {
          if (!(moduleName in moduleMap)) {
            throw new Error('Module ' + moduleName + ' does not exist.');
          }
          symbolList.push(strategy, moduleName, symbolPath);
          if (opt_deprecationMessage) {
            deprecationMap[symbolPath] = opt_deprecationMessage;
          }
        }

        // Note: Android 2.3 does have Function.bind().
        exports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('c', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('m', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('d', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.runs = function(moduleName) {
          addEntry('r', moduleName, null);
        };

        function prepareNamespace(symbolPath, context) {
          if (!symbolPath) {
            return context;
          }
          var parts = symbolPath.split('.');
          var cur = context;
          for (var i = 0, part; part = parts[i]; ++i) {
            cur = cur[part] = cur[part] || {};
          }
          return cur;
        }

        exports.mapModules = function(context) {
          var origSymbols = {};
          context.CDV_origSymbols = origSymbols;
          for (var i = 0, len = symbolList.length; i < len; i += 3) {
            var strategy = symbolList[i];
            var moduleName = symbolList[i + 1];
            var module = require(moduleName);
            // <runs/>
            if (strategy == 'r') {
              continue;
            }
            var symbolPath = symbolList[i + 2];
            var lastDot = symbolPath.lastIndexOf('.');
            var namespace = symbolPath.substr(0, lastDot);
            var lastName = symbolPath.substr(lastDot + 1);

            var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;
            var parentObj = prepareNamespace(namespace, context);
            var target = parentObj[lastName];

            if (strategy == 'm' && target) {
              builder.recursiveMerge(target, module);
            } else if ((strategy == 'd' && !target) || (strategy != 'd')) {
              if (!(symbolPath in origSymbols)) {
                origSymbols[symbolPath] = target;
              }
              builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);
            }
          }
        };

        exports.getOriginalSymbol = function(context, symbolPath) {
          var origSymbols = context.CDV_origSymbols;
          if (origSymbols && (symbolPath in origSymbols)) {
            return origSymbols[symbolPath];
          }
          var parts = symbolPath.split('.');
          var obj = context;
          for (var i = 0; i < parts.length; ++i) {
            obj = obj && obj[parts[i]];
          }
          return obj;
        };

        exports.reset();


      });

      // file: src/ios/platform.js
      define("cordova/platform", function(require, exports, module) {

        module.exports = {
          id: 'ios',
          bootstrap: function() {
            require('cordova/channel').onNativeReady.fire();
          }
        };


      });

      // file: src/common/pluginloader.js
      define("cordova/pluginloader", function(require, exports, module) {

        var modulemapper = require('cordova/modulemapper');
        var urlutil = require('cordova/urlutil');

        // Helper function to inject a <script> tag.
        // Exported for testing.
        exports.injectScript = function(url, onload, onerror) {
          var script = document.createElement("script");
          // onload fires even when script fails loads with an error.
          script.onload = onload;
          // onerror fires for malformed URLs.
          script.onerror = onerror;
          script.src = url;
          document.head.appendChild(script);
        };

        function injectIfNecessary(id, url, onload, onerror) {
          onerror = onerror || onload;
          if (id in define.moduleMap) {
            onload();
          } else {
            exports.injectScript(url, function() {
              if (id in define.moduleMap) {
                onload();
              } else {
                onerror();
              }
            }, onerror);
          }
        }

        function onScriptLoadingComplete(moduleList, finishPluginLoading) {
          // Loop through all the plugins and then through their clobbers and merges.
          for (var i = 0, module; module = moduleList[i]; i++) {
            if (module.clobbers && module.clobbers.length) {
              for (var j = 0; j < module.clobbers.length; j++) {
                modulemapper.clobbers(module.id, module.clobbers[j]);
              }
            }

            if (module.merges && module.merges.length) {
              for (var k = 0; k < module.merges.length; k++) {
                modulemapper.merges(module.id, module.merges[k]);
              }
            }

            // Finally, if runs is truthy we want to simply require() the module.
            if (module.runs) {
              modulemapper.runs(module.id);
            }
          }

          finishPluginLoading();
        }

        // Handler for the cordova_plugins.js content.
        // See plugman's plugin_loader.js for the details of this object.
        // This function is only called if the really is a plugins array that isn't empty.
        // Otherwise the onerror response handler will just call finishPluginLoading().
        function handlePluginsObject(path, moduleList, finishPluginLoading) {
          // Now inject the scripts.
          var scriptCounter = moduleList.length;

          if (!scriptCounter) {
            finishPluginLoading();
            return;
          }

          function scriptLoadedCallback() {
            if (!--scriptCounter) {
              onScriptLoadingComplete(moduleList, finishPluginLoading);
            }
          }

          for (var i = 0; i < moduleList.length; i++) {
            injectIfNecessary(moduleList[i].id, path + moduleList[i].file, scriptLoadedCallback);
          }
        }

        function findCordovaPath() {
          var path = null;
          var scripts = document.getElementsByTagName('script');
          var term = '/cordova.js';
          for (var n = scripts.length - 1; n > -1; n--) {
            var src = scripts[n].src.replace(/\?.*$/, ''); // Strip any query param (CB-6007).
            if (src.indexOf(term) == (src.length - term.length)) {
              path = src.substring(0, src.length - term.length) + '/';
              break;
            }
          }
          return path;
        }

        // Tries to load all plugins' js-modules.
        // This is an async process, but onDeviceReady is blocked on onPluginsReady.
        // onPluginsReady is fired when there are no plugins to load, or they are all done.
        exports.load = function(callback) {
          var pathPrefix = findCordovaPath();
          if (pathPrefix === null) {
            console.log('Could not find cordova.js script tag. Plugin loading may fail.');
            pathPrefix = '';
          }
          injectIfNecessary('cordova/plugin_list', pathPrefix + 'cordova_plugins.js', function() {
            var moduleList = require("cordova/plugin_list");
            handlePluginsObject(pathPrefix, moduleList, callback);
          }, callback);
        };


      });

      // file: src/common/urlutil.js
      define("cordova/urlutil", function(require, exports, module) {


        /**
         * For already absolute URLs, returns what is passed in.
         * For relative URLs, converts them to absolute ones.
         */
        exports.makeAbsolute = function makeAbsolute(url) {
          var anchorEl = document.createElement('a');
          anchorEl.href = url;
          return anchorEl.href;
        };


      });

      // file: src/common/utils.js
      define("cordova/utils", function(require, exports, module) {

        var utils = exports;

        /**
         * Defines a property getter / setter for obj[key].
         */
        utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {
          if (Object.defineProperty) {
            var desc = {
              get: getFunc,
              configurable: true
            };
            if (opt_setFunc) {
              desc.set = opt_setFunc;
            }
            Object.defineProperty(obj, key, desc);
          } else {
            obj.__defineGetter__(key, getFunc);
            if (opt_setFunc) {
              obj.__defineSetter__(key, opt_setFunc);
            }
          }
        };

        /**
         * Defines a property getter for obj[key].
         */
        utils.defineGetter = utils.defineGetterSetter;

        utils.arrayIndexOf = function(a, item) {
          if (a.indexOf) {
            return a.indexOf(item);
          }
          var len = a.length;
          for (var i = 0; i < len; ++i) {
            if (a[i] == item) {
              return i;
            }
          }
          return -1;
        };

        /**
         * Returns whether the item was found in the array.
         */
        utils.arrayRemove = function(a, item) {
          var index = utils.arrayIndexOf(a, item);
          if (index != -1) {
            a.splice(index, 1);
          }
          return index != -1;
        };

        utils.typeName = function(val) {
          return Object.prototype.toString.call(val).slice(8, -1);
        };

        /**
         * Returns an indication of whether the argument is an array or not
         */
        utils.isArray = function(a) {
          return utils.typeName(a) == 'Array';
        };

        /**
         * Returns an indication of whether the argument is a Date or not
         */
        utils.isDate = function(d) {
          return utils.typeName(d) == 'Date';
        };

        /**
         * Does a deep clone of the object.
         */
        utils.clone = function(obj) {
          if (!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {
            return obj;
          }

          var retVal, i;

          if (utils.isArray(obj)) {
            retVal = [];
            for (i = 0; i < obj.length; ++i) {
              retVal.push(utils.clone(obj[i]));
            }
            return retVal;
          }

          retVal = {};
          for (i in obj) {
            if (!(i in retVal) || retVal[i] != obj[i]) {
              retVal[i] = utils.clone(obj[i]);
            }
          }
          return retVal;
        };

        /**
         * Returns a wrapped version of the function
         */
        utils.close = function(context, func, params) {
          if (typeof params == 'undefined') {
            return function() {
              return func.apply(context, arguments);
            };
          } else {
            return function() {
              return func.apply(context, params);
            };
          }
        };

        /**
         * Create a UUID
         */
        utils.createUUID = function() {
          return UUIDcreatePart(4) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(6);
        };

        /**
         * Extends a child object from a parent object using classical inheritance
         * pattern.
         */
        utils.extend = (function() {
          // proxy used to establish prototype chain
          var F = function() {};
          // extend Child from Parent
          return function(Child, Parent) {
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.__super__ = Parent.prototype;
            Child.prototype.constructor = Child;
          };
        }());

        /**
         * Alerts a message in any available way: alert or console.log.
         */
        utils.alert = function(msg) {
          if (window.alert) {
            window.alert(msg);
          } else if (console && console.log) {
            console.log(msg);
          }
        };


        //------------------------------------------------------------------------------
        function UUIDcreatePart(length) {
          var uuidpart = "";
          for (var i = 0; i < length; i++) {
            var uuidchar = parseInt((Math.random() * 256), 10).toString(16);
            if (uuidchar.length == 1) {
              uuidchar = "0" + uuidchar;
            }
            uuidpart += uuidchar;
          }
          return uuidpart;
        }


      });

/************************日志插件**********************/

    define("org.apache.cordova.console-via-logger", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      //------------------------------------------------------------------------------

      var logger = require("cordova/plugin/logger");
      var utils  = require("cordova/utils");

      //------------------------------------------------------------------------------
      // object that we're exporting
      //------------------------------------------------------------------------------
      var console = module.exports;

      //------------------------------------------------------------------------------
      // copy of the original console object
      //------------------------------------------------------------------------------
      var WinConsole = window.console;

      //------------------------------------------------------------------------------
      // whether to use the logger
      //------------------------------------------------------------------------------
      var UseLogger = false;

      //------------------------------------------------------------------------------
      // Timers
      //------------------------------------------------------------------------------
      var Timers = {};

      //------------------------------------------------------------------------------
      // used for unimplemented methods
      //------------------------------------------------------------------------------
      function noop() {}

      //------------------------------------------------------------------------------
      // used for unimplemented methods
      //------------------------------------------------------------------------------
      console.useLogger = function (value) {
          if (arguments.length) UseLogger = !!value;

          if (UseLogger) {
              if (logger.useConsole()) {
                  throw new Error("console and logger are too intertwingly");
              }
          }

          return UseLogger;
      };

      //------------------------------------------------------------------------------
      console.log = function() {
          if (logger.useConsole()) return;
          logger.log.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.error = function() {
          if (logger.useConsole()) return;
          logger.error.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.warn = function() {
          if (logger.useConsole()) return;
          logger.warn.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.info = function() {
          if (logger.useConsole()) return;
          logger.info.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.debug = function() {
          if (logger.useConsole()) return;
          logger.debug.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.assert = function(expression) {
          if (expression) return;

          var message = logger.format.apply(logger.format, [].slice.call(arguments, 1));
          console.log("ASSERT: " + message);
      };

      //------------------------------------------------------------------------------
      console.clear = function() {};

      //------------------------------------------------------------------------------
      console.dir = function(object) {
          console.log("%o", object);
      };

      //------------------------------------------------------------------------------
      console.dirxml = function(node) {
          console.log(node.innerHTML);
      };

      //------------------------------------------------------------------------------
      console.trace = noop;

      //------------------------------------------------------------------------------
      console.group = console.log;

      //------------------------------------------------------------------------------
      console.groupCollapsed = console.log;

      //------------------------------------------------------------------------------
      console.groupEnd = noop;

      //------------------------------------------------------------------------------
      console.time = function(name) {
          Timers[name] = new Date().valueOf();
      };

      //------------------------------------------------------------------------------
      console.timeEnd = function(name) {
          var timeStart = Timers[name];
          if (!timeStart) {
              console.warn("unknown timer: " + name);
              return;
          }

          var timeElapsed = new Date().valueOf() - timeStart;
          console.log(name + ": " + timeElapsed + "ms");
      };

      //------------------------------------------------------------------------------
      console.timeStamp = noop;

      //------------------------------------------------------------------------------
      console.profile = noop;

      //------------------------------------------------------------------------------
      console.profileEnd = noop;

      //------------------------------------------------------------------------------
      console.count = noop;

      //------------------------------------------------------------------------------
      console.exception = console.log;

      //------------------------------------------------------------------------------
      console.table = function(data, columns) {
          console.log("%o", data);
      };

      //------------------------------------------------------------------------------
      // return a new function that calls both functions passed as args
      //------------------------------------------------------------------------------
      function wrappedOrigCall(orgFunc, newFunc) {
          return function() {
              var args = [].slice.call(arguments);
              try { orgFunc.apply(WinConsole, args); } catch (e) {}
              try { newFunc.apply(console,    args); } catch (e) {}
          };
      }

      //------------------------------------------------------------------------------
      // For every function that exists in the original console object, that
      // also exists in the new console object, wrap the new console method
      // with one that calls both
      //------------------------------------------------------------------------------
      for (var key in console) {
          if (typeof WinConsole[key] == "function") {
              console[key] = wrappedOrigCall(WinConsole[key], console[key]);
          }
      }

    });

    define("cordova/plugin/logger", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      //------------------------------------------------------------------------------
      // The logger module exports the following properties/functions:
      //
      // LOG                          - constant for the level LOG
      // ERROR                        - constant for the level ERROR
      // WARN                         - constant for the level WARN
      // INFO                         - constant for the level INFO
      // DEBUG                        - constant for the level DEBUG
      // logLevel()                   - returns current log level
      // logLevel(value)              - sets and returns a new log level
      // useConsole()                 - returns whether logger is using console
      // useConsole(value)            - sets and returns whether logger is using console
      // log(message,...)             - logs a message at level LOG
      // error(message,...)           - logs a message at level ERROR
      // warn(message,...)            - logs a message at level WARN
      // info(message,...)            - logs a message at level INFO
      // debug(message,...)           - logs a message at level DEBUG
      // logLevel(level,message,...)  - logs a message specified level
      //
      //------------------------------------------------------------------------------

      var logger = exports;

      var exec    = require('cordova/exec');
      var utils   = require('cordova/utils');

      var UseConsole   = false;
      var UseLogger    = true;
      var Queued       = [];
      var DeviceReady  = false;
      var CurrentLevel;

      var originalConsole = console;

      /**
       * Logging levels
       */

      var Levels = [
          "LOG",
          "ERROR",
          "WARN",
          "INFO",
          "DEBUG"
      ];

      /*
       * add the logging levels to the logger object and
       * to a separate levelsMap object for testing
       */

      var LevelsMap = {};
      for (var i=0; i<Levels.length; i++) {
          var level = Levels[i];
          LevelsMap[level] = i;
          logger[level]    = level;
      }

      CurrentLevel = LevelsMap.WARN;

      /**
       * Getter/Setter for the logging level
       *
       * Returns the current logging level.
       *
       * When a value is passed, sets the logging level to that value.
       * The values should be one of the following constants:
       *    logger.LOG
       *    logger.ERROR
       *    logger.WARN
       *    logger.INFO
       *    logger.DEBUG
       *
       * The value used determines which messages get printed.  The logging
       * values above are in order, and only messages logged at the logging
       * level or above will actually be displayed to the user.  E.g., the
       * default level is WARN, so only messages logged with LOG, ERROR, or
       * WARN will be displayed; INFO and DEBUG messages will be ignored.
       */
      logger.level = function (value) {
          if (arguments.length) {
              if (LevelsMap[value] === null) {
                  throw new Error("invalid logging level: " + value);
              }
              CurrentLevel = LevelsMap[value];
          }

          return Levels[CurrentLevel];
      };

      /**
       * Getter/Setter for the useConsole functionality
       *
       * When useConsole is true, the logger will log via the
       * browser 'console' object.
       */
      logger.useConsole = function (value) {
          if (arguments.length) UseConsole = !!value;

          if (UseConsole) {
              if (typeof console == "undefined") {
                  throw new Error("global console object is not defined");
              }

              if (typeof console.log != "function") {
                  throw new Error("global console object does not have a log function");
              }

              if (typeof console.useLogger == "function") {
                  if (console.useLogger()) {
                      throw new Error("console and logger are too intertwingly");
                  }
              }
          }

          return UseConsole;
      };

      /**
       * Getter/Setter for the useLogger functionality
       *
       * When useLogger is true, the logger will log via the
       * native Logger plugin.
       */
      logger.useLogger = function (value) {
          // Enforce boolean
          if (arguments.length) UseLogger = !!value;
          return UseLogger;
      };

      /**
       * Logs a message at the LOG level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.log   = function(message) { logWithArgs("LOG",   arguments); };

      /**
       * Logs a message at the ERROR level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.error = function(message) { logWithArgs("ERROR", arguments); };

      /**
       * Logs a message at the WARN level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.warn  = function(message) { logWithArgs("WARN",  arguments); };

      /**
       * Logs a message at the INFO level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.info  = function(message) { logWithArgs("INFO",  arguments); };

      /**
       * Logs a message at the DEBUG level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.debug = function(message) { logWithArgs("DEBUG", arguments); };

      // log at the specified level with args
      function logWithArgs(level, args) {
          args = [level].concat([].slice.call(args));
          logger.logLevel.apply(logger, args);
      }

      // return the correct formatString for an object
      function formatStringForMessage(message) {
          return (typeof message === "string") ? "" : "%o";
      }

      /**
       * Logs a message at the specified level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.logLevel = function(level /* , ... */) {
          // format the message with the parameters
          var formatArgs = [].slice.call(arguments, 1);
          var fmtString = formatStringForMessage(formatArgs[0]);
          if (fmtString.length > 0){
              formatArgs.unshift(fmtString); // add formatString
          }

          var message    = logger.format.apply(logger.format, formatArgs);

          if (LevelsMap[level] === null) {
              throw new Error("invalid logging level: " + level);
          }

          if (LevelsMap[level] > CurrentLevel) return;

          // queue the message if not yet at deviceready
          if (!DeviceReady && !UseConsole) {
              Queued.push([level, message]);
              return;
          }

          // Log using the native logger if that is enabled
          if (UseLogger) {
              exec(null, null, "Console", "logLevel", [level, message]);
          }

          // Log using the console if that is enabled
          if (UseConsole) {
              // make sure console is not using logger
              if (console.useLogger()) {
                  throw new Error("console and logger are too intertwingly");
              }

              // log to the console
              switch (level) {
                  case logger.LOG:   originalConsole.log(message); break;
                  case logger.ERROR: originalConsole.log("ERROR: " + message); break;
                  case logger.WARN:  originalConsole.log("WARN: "  + message); break;
                  case logger.INFO:  originalConsole.log("INFO: "  + message); break;
                  case logger.DEBUG: originalConsole.log("DEBUG: " + message); break;
              }
          }
      };


      /**
       * Formats a string and arguments following it ala console.log()
       *
       * Any remaining arguments will be appended to the formatted string.
       *
       * for rationale, see FireBug's Console API:
       *    http://getfirebug.com/wiki/index.php/Console_API
       */
      logger.format = function(formatString, args) {
          return __format(arguments[0], [].slice.call(arguments,1)).join(' ');
      };


      //------------------------------------------------------------------------------
      /**
       * Formats a string and arguments following it ala vsprintf()
       *
       * format chars:
       *   %j - format arg as JSON
       *   %o - format arg as JSON
       *   %c - format arg as ''
       *   %% - replace with '%'
       * any other char following % will format it's
       * arg via toString().
       *
       * Returns an array containing the formatted string and any remaining
       * arguments.
       */
      function __format(formatString, args) {
          if (formatString === null || formatString === undefined) return [""];
          if (arguments.length == 1) return [formatString.toString()];

          if (typeof formatString != "string")
              formatString = formatString.toString();

          var pattern = /(.*?)%(.)(.*)/;
          var rest    = formatString;
          var result  = [];

          while (args.length) {
              var match = pattern.exec(rest);
              if (!match) break;

              var arg   = args.shift();
              rest = match[3];
              result.push(match[1]);

              if (match[2] == '%') {
                  result.push('%');
                  args.unshift(arg);
                  continue;
              }

              result.push(__formatted(arg, match[2]));
          }

          result.push(rest);

          var remainingArgs = [].slice.call(args);
          remainingArgs.unshift(result.join(''));
          return remainingArgs;
      }

      function __formatted(object, formatChar) {

          try {
              switch(formatChar) {
                  case 'j':
                  case 'o': return JSON.stringify(object);
                  case 'c': return '';
              }
          }
          catch (e) {
              return "error JSON.stringify()ing argument: " + e;
          }

          if ((object === null) || (object === undefined)) {
              return Object.prototype.toString.call(object);
          }

          return object.toString();
      }


      //------------------------------------------------------------------------------
      // when deviceready fires, log queued messages
      logger.__onDeviceReady = function() {
          if (DeviceReady) return;

          DeviceReady = true;

          for (var i=0; i<Queued.length; i++) {
              var messageArgs = Queued[i];
              logger.logLevel(messageArgs[0], messageArgs[1]);
          }

          Queued = null;
      };

      // add a deviceready event to log queued messages
      document.addEventListener("deviceready", logger.__onDeviceReady, false);

    });

  /**************音频插件****************/
    define("org.apache.cordova.media.Media", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      var argscheck = require('cordova/argscheck'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec');

      var mediaObjects = {};

      /**
       * This class provides access to the device media, interfaces to both sound and video
       *
       * @constructor
       * @param src                   The file name or url to play
       * @param successCallback       The callback to be called when the file is done playing or recording.
       *                                  successCallback()
       * @param errorCallback         The callback to be called if there is an error.
       *                                  errorCallback(int errorCode) - OPTIONAL
       * @param statusCallback        The callback to be called when media status has changed.
       *                                  statusCallback(int statusCode) - OPTIONAL
       */
      var Media = function(src, successCallback, errorCallback, statusCallback) {
          argscheck.checkArgs('SFFF', 'Media', arguments);
          this.id = utils.createUUID();
          mediaObjects[this.id] = this;
          this.src = src;
          this.successCallback = successCallback;
          this.errorCallback = errorCallback;
          this.statusCallback = statusCallback;
          this._duration = -1;
          this._position = -1;
          exec(null, this.errorCallback, "Media", "create", [this.id, this.src]);
      };

      // Media messages
      Media.MEDIA_STATE = 1;
      Media.MEDIA_DURATION = 2;
      Media.MEDIA_POSITION = 3;
      Media.MEDIA_ERROR = 9;

      // Media states
      Media.MEDIA_NONE = 0;
      Media.MEDIA_STARTING = 1;
      Media.MEDIA_RUNNING = 2;
      Media.MEDIA_PAUSED = 3;
      Media.MEDIA_STOPPED = 4;
      Media.MEDIA_MSG = ["None", "Starting", "Running", "Paused", "Stopped"];

      // "static" function to return existing objs.
      Media.get = function(id) {
          return mediaObjects[id];
      };

      /**
       * Start or resume playing audio file.
       */
      Media.prototype.play = function(options) {
          exec(null, null, "Media", "startPlayingAudio", [this.id, this.src, options]);
      };

      /**
       * Stop playing audio file.
       */
      Media.prototype.stop = function() {
          var me = this;
          exec(function() {
              me._position = 0;
          }, this.errorCallback, "Media", "stopPlayingAudio", [this.id]);
      };

      /**
       * Seek or jump to a new time in the track..
       */
      Media.prototype.seekTo = function(milliseconds) {
          var me = this;
          exec(function(p) {
              me._position = p;
          }, this.errorCallback, "Media", "seekToAudio", [this.id, milliseconds]);
      };

      /**
       * Pause playing audio file.
       */
      Media.prototype.pause = function() {
          exec(null, this.errorCallback, "Media", "pausePlayingAudio", [this.id]);
      };

      /**
       * Get duration of an audio file.
       * The duration is only set for audio that is playing, paused or stopped.
       *
       * @return      duration or -1 if not known.
       */
      Media.prototype.getDuration = function() {
          return this._duration;
      };

      /**
       * Get position of audio.
       */
      Media.prototype.getCurrentPosition = function(success, fail) {
          var me = this;
          exec(function(p) {
              me._position = p;
              success(p);
          }, fail, "Media", "getCurrentPositionAudio", [this.id]);
      };

      /**
       * Start recording audio file.
       */
      Media.prototype.startRecord = function() {
          exec(null, this.errorCallback, "Media", "startRecordingAudio", [this.id, this.src]);
      };

      /**
       * Stop recording audio file.
       */
      Media.prototype.stopRecord = function() {
          exec(null, this.errorCallback, "Media", "stopRecordingAudio", [this.id]);
      };

      /**
       * Release the resources.
       */
      Media.prototype.release = function() {
          exec(null, this.errorCallback, "Media", "release", [this.id]);
      };

      /**
       * Adjust the volume.
       */
      Media.prototype.setVolume = function(volume) {
          exec(null, null, "Media", "setVolume", [this.id, volume]);
      };

      /**
       * Audio has status update.
       * PRIVATE
       *
       * @param id            The media object id (string)
       * @param msgType       The 'type' of update this is
       * @param value         Use of value is determined by the msgType
       */
      Media.onStatus = function(id, msgType, value) {

          var media = mediaObjects[id];

          if(media) {
              switch(msgType) {
                  case Media.MEDIA_STATE :
                      media.statusCallback && media.statusCallback(value);
                      if(value == Media.MEDIA_STOPPED) {
                          media.successCallback && media.successCallback();
                      }
                      break;
                  case Media.MEDIA_DURATION :
                      media._duration = value;
                      break;
                  case Media.MEDIA_ERROR :
                      media.errorCallback && media.errorCallback(value);
                      break;
                  case Media.MEDIA_POSITION :
                      media._position = Number(value);
                      break;
                  default :
                      console.error && console.error("Unhandled Media.onStatus :: " + msgType);
                      break;
              }
          }
          else {
              console.error && console.error("Received Media.onStatus callback for unknown media :: " + id);
          }

      };

      module.exports = Media;

    });

    define("org.apache.cordova.media.MediaError", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      /**
       * This class contains information about any Media errors.
      */
      /*
       According to :: http://dev.w3.org/html5/spec-author-view/video.html#mediaerror
       We should never be creating these objects, we should just implement the interface
       which has 1 property for an instance, 'code'

       instead of doing :
          errorCallbackFunction( new MediaError(3,'msg') );
      we should simply use a literal :
          errorCallbackFunction( {'code':3} );
       */

       var _MediaError = window.MediaError;


      if(!_MediaError) {
          window.MediaError = _MediaError = function(code, msg) {
              this.code = (typeof code != 'undefined') ? code : null;
              this.message = msg || ""; // message is NON-standard! do not use!
          };
      }

      _MediaError.MEDIA_ERR_NONE_ACTIVE    = _MediaError.MEDIA_ERR_NONE_ACTIVE    || 0;
      _MediaError.MEDIA_ERR_ABORTED        = _MediaError.MEDIA_ERR_ABORTED        || 1;
      _MediaError.MEDIA_ERR_NETWORK        = _MediaError.MEDIA_ERR_NETWORK        || 2;
      _MediaError.MEDIA_ERR_DECODE         = _MediaError.MEDIA_ERR_DECODE         || 3;
      _MediaError.MEDIA_ERR_NONE_SUPPORTED = _MediaError.MEDIA_ERR_NONE_SUPPORTED || 4;
      // TODO: MediaError.MEDIA_ERR_NONE_SUPPORTED is legacy, the W3 spec now defines it as below.
      // as defined by http://dev.w3.org/html5/spec-author-view/video.html#error-codes
      _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 4;

      module.exports = _MediaError;

      });

    //插件列表
    define("cordova/plugin_list", function(require, exports, module) {
        module.exports = [];
    });
    

//*****************************************************************
      window.cordova = require('cordova');
      // file: src/scripts/bootstrap.js

      require('cordova/init');

      window.console = require('org.apache.cordova.console-via-logger');
      window.Media = require('org.apache.cordova.media.Media');

    })();

} else if(Xut.plat.isAndroid){
      
    	// commit 71223711fb1591b1255d871140d959fd9095f0c3

    // File generated at :: Mon Jan 21 2013 13:45:08 GMT-0800 (PST)

    /*
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
     
         http://www.apache.org/licenses/LICENSE-2.0
     
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
    */

    ;(function() {

    // file: lib/scripts/require.js

    var require,
        define;

    (function () {
        var modules = {};
        // Stack of moduleIds currently being built.
        var requireStack = [];
        // Map of module ID -> index into requireStack of modules currently being built.
        var inProgressModules = {};

        function build(module) {
            var factory = module.factory;
            module.exports = {};
            delete module.factory;
            factory(require, module.exports, module);
            return module.exports;
        }

        require = function (id) {
            if (!modules[id]) {
                throw "module " + id + " not found";
            } else if (id in inProgressModules) {
                var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;
                throw "Cycle in require graph: " + cycle;
            }
            if (modules[id].factory) {
                try {
                    inProgressModules[id] = requireStack.length;
                    requireStack.push(id);
                    return build(modules[id]);
                } finally {
                    delete inProgressModules[id];
                    requireStack.pop();
                }
            }
            return modules[id].exports;
        };

        define = function (id, factory) {
            if (modules[id]) {
                throw "module " + id + " already defined";
            }

            modules[id] = {
                id: id,
                factory: factory
            };
        };

        define.remove = function (id) {
            delete modules[id];
        };

        define.moduleMap = modules;
    })();

    //Export for use in node
    if (typeof module === "object" && typeof require === "function") {
        module.exports.require = require;
        module.exports.define = define;
    }

    // file: lib/cordova.js
    define("cordova", function(require, exports, module) {


    var channel = require('cordova/channel');

    /**
     * Listen for DOMContentLoaded and notify our channel subscribers.
     */
    document.addEventListener('DOMContentLoaded', function() {
        channel.onDOMContentLoaded.fire();
    }, false);
    if (document.readyState == 'complete' || document.readyState == 'interactive') {
        channel.onDOMContentLoaded.fire();
    }

    /**
     * Intercept calls to addEventListener + removeEventListener and handle deviceready,
     * resume, and pause events.
     */
    var m_document_addEventListener = document.addEventListener;
    var m_document_removeEventListener = document.removeEventListener;
    var m_window_addEventListener = window.addEventListener;
    var m_window_removeEventListener = window.removeEventListener;

    /**
     * Houses custom event handlers to intercept on document + window event listeners.
     */
    var documentEventHandlers = {},
        windowEventHandlers = {};

    document.addEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        if (typeof documentEventHandlers[e] != 'undefined') {
            documentEventHandlers[e].subscribe(handler);
        } else {
            m_document_addEventListener.call(document, evt, handler, capture);
        }
    };

    window.addEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        if (typeof windowEventHandlers[e] != 'undefined') {
            windowEventHandlers[e].subscribe(handler);
        } else {
            m_window_addEventListener.call(window, evt, handler, capture);
        }
    };

    document.removeEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        // If unsubscribing from an event that is handled by a plugin
        if (typeof documentEventHandlers[e] != "undefined") {
            documentEventHandlers[e].unsubscribe(handler);
        } else {
            m_document_removeEventListener.call(document, evt, handler, capture);
        }
    };

    window.removeEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        // If unsubscribing from an event that is handled by a plugin
        if (typeof windowEventHandlers[e] != "undefined") {
            windowEventHandlers[e].unsubscribe(handler);
        } else {
            m_window_removeEventListener.call(window, evt, handler, capture);
        }
    };

    function createEvent(type, data) {
        var event = document.createEvent('Events');
        event.initEvent(type, false, false);
        if (data) {
            for (var i in data) {
                if (data.hasOwnProperty(i)) {
                    event[i] = data[i];
                }
            }
        }
        return event;
    }

    if(typeof window.console === "undefined") {
        window.console = {
            log:function(){}
        };
    }

    var cordova = {
        define:define,
        require:require,
        /**
         * Methods to add/remove your own addEventListener hijacking on document + window.
         */
        addWindowEventHandler:function(event) {
            return (windowEventHandlers[event] = channel.create(event));
        },
        addStickyDocumentEventHandler:function(event) {
            return (documentEventHandlers[event] = channel.createSticky(event));
        },
        addDocumentEventHandler:function(event) {
            return (documentEventHandlers[event] = channel.create(event));
        },
        removeWindowEventHandler:function(event) {
            delete windowEventHandlers[event];
        },
        removeDocumentEventHandler:function(event) {
            delete documentEventHandlers[event];
        },
        /**
         * Retrieve original event handlers that were replaced by Cordova
         *
         * @return object
         */
        getOriginalHandlers: function() {
            return {'document': {'addEventListener': m_document_addEventListener, 'removeEventListener': m_document_removeEventListener},
            'window': {'addEventListener': m_window_addEventListener, 'removeEventListener': m_window_removeEventListener}};
        },
        /**
         * Method to fire event from native code
         * bNoDetach is required for events which cause an exception which needs to be caught in native code
         */
        fireDocumentEvent: function(type, data, bNoDetach) {
            var evt = createEvent(type, data);
            if (typeof documentEventHandlers[type] != 'undefined') {
                if( bNoDetach ) {
                  documentEventHandlers[type].fire(evt);
                }
                else {
                  setTimeout(function() {
                      documentEventHandlers[type].fire(evt);
                  }, 0);
                }
            } else {
                document.dispatchEvent(evt);
            }
        },
        fireWindowEvent: function(type, data) {
            var evt = createEvent(type,data);
            if (typeof windowEventHandlers[type] != 'undefined') {
                setTimeout(function() {
                    windowEventHandlers[type].fire(evt);
                }, 0);
            } else {
                window.dispatchEvent(evt);
            }
        },

        /**
         * Plugin callback mechanism.
         */
        // Randomize the starting callbackId to avoid collisions after refreshing or navigating.
        // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.
        callbackId: Math.floor(Math.random() * 2000000000),
        callbacks:  {},
        callbackStatus: {
            NO_RESULT: 0,
            OK: 1,
            CLASS_NOT_FOUND_EXCEPTION: 2,
            ILLEGAL_ACCESS_EXCEPTION: 3,
            INSTANTIATION_EXCEPTION: 4,
            MALFORMED_URL_EXCEPTION: 5,
            IO_EXCEPTION: 6,
            INVALID_ACTION: 7,
            JSON_EXCEPTION: 8,
            ERROR: 9
        },

        /**
         * Called by native code when returning successful result from an action.
         */
        callbackSuccess: function(callbackId, args) {
            try {
                cordova.callbackFromNative(callbackId, true, args.status, args.message, args.keepCallback);
            } catch (e) {
                console.log("Error in error callback: " + callbackId + " = "+e);
            }
        },

        /**
         * Called by native code when returning error result from an action.
         */
        callbackError: function(callbackId, args) {
            // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.
            // Derive success from status.
            try {
                cordova.callbackFromNative(callbackId, false, args.status, args.message, args.keepCallback);
            } catch (e) {
                console.log("Error in error callback: " + callbackId + " = "+e);
            }
        },

        /**
         * Called by native code when returning the result from an action.
         */
        callbackFromNative: function(callbackId, success, status, message, keepCallback) {
            var callback = cordova.callbacks[callbackId];
            if (callback) {
                if (success && status == cordova.callbackStatus.OK) {
                    callback.success && callback.success(message);
                } else if (!success) {
                    callback.fail && callback.fail(message);
                }

                // Clear callback if not expecting any more results
                if (!keepCallback) {
                    delete cordova.callbacks[callbackId];
                }
            }
        },
        addConstructor: function(func) {
            channel.onCordovaReady.subscribe(function() {
                try {
                    func();
                } catch(e) {
                    console.log("Failed to run constructor: " + e);
                }
            });
        }
    };

    // Register pause, resume and deviceready channels as events on document.
    channel.onPause = cordova.addDocumentEventHandler('pause');
    channel.onResume = cordova.addDocumentEventHandler('resume');
    channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

    module.exports = cordova;

    });

    // file: lib/common/argscheck.js
    define("cordova/argscheck", function(require, exports, module) {

    var exec = require('cordova/exec');
    var utils = require('cordova/utils');

    var moduleExports = module.exports;

    var typeMap = {
        'A': 'Array',
        'D': 'Date',
        'N': 'Number',
        'S': 'String',
        'F': 'Function',
        'O': 'Object'
    };

    function extractParamName(callee, argIndex) {
      return (/.*?\((.*?)\)/).exec(callee)[1].split(', ')[argIndex];
    }

    function checkArgs(spec, functionName, args, opt_callee) {
        if (!moduleExports.enableChecks) {
            return;
        }
        var errMsg = null;
        var typeName;
        for (var i = 0; i < spec.length; ++i) {
            var c = spec.charAt(i),
                cUpper = c.toUpperCase(),
                arg = args[i];
            // Asterix means allow anything.
            if (c == '*') {
                continue;
            }
            typeName = utils.typeName(arg);
            if ((arg === null || arg === undefined) && c == cUpper) {
                continue;
            }
            if (typeName != typeMap[cUpper]) {
                errMsg = 'Expected ' + typeMap[cUpper];
                break;
            }
        }
        if (errMsg) {
            errMsg += ', but got ' + typeName + '.';
            errMsg = 'Wrong type for parameter "' + extractParamName(opt_callee || args.callee, i) + '" of ' + functionName + ': ' + errMsg;
            // Don't log when running jake test.
            if (typeof jasmine == 'undefined') {
                console.error(errMsg);
            }
            throw TypeError(errMsg);
        }
    }

    function getValue(value, defaultValue) {
        return value === undefined ? defaultValue : value;
    }

    moduleExports.checkArgs = checkArgs;
    moduleExports.getValue = getValue;
    moduleExports.enableChecks = true;


    });

    // file: lib/common/builder.js
    define("cordova/builder", function(require, exports, module) {

    var utils = require('cordova/utils');

    function each(objects, func, context) {
        for (var prop in objects) {
            if (objects.hasOwnProperty(prop)) {
                func.apply(context, [objects[prop], prop]);
            }
        }
    }

    function clobber(obj, key, value) {
        obj[key] = value;
        // Getters can only be overridden by getters.
        if (obj[key] !== value) {
            utils.defineGetter(obj, key, function() {
                return value;
            });
        }
    }

    function assignOrWrapInDeprecateGetter(obj, key, value, message) {
        if (message) {
            utils.defineGetter(obj, key, function() {
                console.log(message);
                delete obj[key];
                clobber(obj, key, value);
                return value;
            });
        } else {
            clobber(obj, key, value);
        }
    }

    function include(parent, objects, clobber, merge) {
        each(objects, function (obj, key) {
            try {
              var result = obj.path ? require(obj.path) : {};

              if (clobber) {
                  // Clobber if it doesn't exist.
                  if (typeof parent[key] === 'undefined') {
                      assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                  } else if (typeof obj.path !== 'undefined') {
                      // If merging, merge properties onto parent, otherwise, clobber.
                      if (merge) {
                          recursiveMerge(parent[key], result);
                      } else {
                          assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                      }
                  }
                  result = parent[key];
              } else {
                // Overwrite if not currently defined.
                if (typeof parent[key] == 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else {
                  // Set result to what already exists, so we can build children into it if they exist.
                  result = parent[key];
                }
              }

              if (obj.children) {
                include(result, obj.children, clobber, merge);
              }
            } catch(e) {
              utils.alert('Exception building cordova JS globals: ' + e + ' for key "' + key + '"');
            }
        });
    }

    /**
     * Merge properties from one object onto another recursively.  Properties from
     * the src object will overwrite existing target property.
     *
     * @param target Object to merge properties into.
     * @param src Object to merge properties from.
     */
    function recursiveMerge(target, src) {
        for (var prop in src) {
            if (src.hasOwnProperty(prop)) {
                if (target.prototype && target.prototype.constructor === target) {
                    // If the target object is a constructor override off prototype.
                    clobber(target.prototype, prop, src[prop]);
                } else {
                    if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {
                        recursiveMerge(target[prop], src[prop]);
                    } else {
                        clobber(target, prop, src[prop]);
                    }
                }
            }
        }
    }

    module.exports = {
        buildIntoButDoNotClobber: function(objects, target) {
            include(target, objects, false, false);
        },
        buildIntoAndClobber: function(objects, target) {
            include(target, objects, true, false);
        },
        buildIntoAndMerge: function(objects, target) {
            include(target, objects, true, true);
        },
        recursiveMerge: recursiveMerge,
        assignOrWrapInDeprecateGetter: assignOrWrapInDeprecateGetter
    };

    });

    // file: lib/common/channel.js
    define("cordova/channel", function(require, exports, module) {

    var utils = require('cordova/utils'),
        nextGuid = 1;

    /**
     * Custom pub-sub "channel" that can have functions subscribed to it
     * This object is used to define and control firing of events for
     * cordova initialization, as well as for custom events thereafter.
     *
     * The order of events during page load and Cordova startup is as follows:
     *
     * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.
     * onNativeReady*              Internal event that indicates the Cordova native side is ready.
     * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.
     * onCordovaInfoReady*         Internal event fired when device properties are available.
     * onCordovaConnectionReady*   Internal event fired when the connection property has been set.
     * onDeviceReady*              User event fired to indicate that Cordova is ready
     * onResume                    User event fired to indicate a start/resume lifecycle event
     * onPause                     User event fired to indicate a pause lifecycle event
     * onDestroy*                  Internal event fired when app is being destroyed (User should use window.onunload event, not this one).
     *
     * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.
     * All listeners that subscribe after the event is fired will be executed right away.
     *
     * The only Cordova events that user code should register for are:
     *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript
     *      pause                 App has moved to background
     *      resume                App has returned to foreground
     *
     * Listeners can be registered as:
     *      document.addEventListener("deviceready", myDeviceReadyListener, false);
     *      document.addEventListener("resume", myResumeListener, false);
     *      document.addEventListener("pause", myPauseListener, false);
     *
     * The DOM lifecycle events should be used for saving and restoring state
     *      window.onload
     *      window.onunload
     *
     */

    /**
     * Channel
     * @constructor
     * @param type  String the channel name
     */
    var Channel = function(type, sticky) {
        this.type = type;
        // Map of guid -> function.
        this.handlers = {};
        // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
        this.state = sticky ? 1 : 0;
        // Used in sticky mode to remember args passed to fire().
        this.fireArgs = null;
        // Used by onHasSubscribersChange to know if there are any listeners.
        this.numHandlers = 0;
        // Function that is called when the first listener is subscribed, or when
        // the last listener is unsubscribed.
        this.onHasSubscribersChange = null;
    },
        channel = {
            /**
             * Calls the provided function only after all of the channels specified
             * have been fired. All channels must be sticky channels.
             */
            join: function(h, c) {
                var len = c.length,
                    i = len,
                    f = function() {
                        if (!(--i)) h();
                    };
                for (var j=0; j<len; j++) {
                    if (c[j].state === 0) {
                        throw Error('Can only use join with sticky channels.');
                    }
                    c[j].subscribe(f);
                }
                if (!len) h();
            },
            create: function(type) {
                return channel[type] = new Channel(type, false);
            },
            createSticky: function(type) {
                return channel[type] = new Channel(type, true);
            },

            /**
             * cordova Channels that must fire before "deviceready" is fired.
             */
            deviceReadyChannelsArray: [],
            deviceReadyChannelsMap: {},

            /**
             * Indicate that a feature needs to be initialized before it is ready to be used.
             * This holds up Cordova's "deviceready" event until the feature has been initialized
             * and Cordova.initComplete(feature) is called.
             *
             * @param feature {String}     The unique feature name
             */
            waitForInitialization: function(feature) {
                if (feature) {
                    var c = channel[feature] || this.createSticky(feature);
                    this.deviceReadyChannelsMap[feature] = c;
                    this.deviceReadyChannelsArray.push(c);
                }
            },

            /**
             * Indicate that initialization code has completed and the feature is ready to be used.
             *
             * @param feature {String}     The unique feature name
             */
            initializationComplete: function(feature) {
                var c = this.deviceReadyChannelsMap[feature];
                if (c) {
                    c.fire();
                }
            }
        };

    function forceFunction(f) {
        if (typeof f != 'function') throw "Function required as first argument!";
    }

    /**
     * Subscribes the given function to the channel. Any time that
     * Channel.fire is called so too will the function.
     * Optionally specify an execution context for the function
     * and a guid that can be used to stop subscribing to the channel.
     * Returns the guid.
     */
    Channel.prototype.subscribe = function(f, c) {
        // need a function to call
        forceFunction(f);
        if (this.state == 2) {
            f.apply(c || this, this.fireArgs);
            return;
        }

        var func = f,
            guid = f.observer_guid;
        if (typeof c == "object") { func = utils.close(c, f); }

        if (!guid) {
            // first time any channel has seen this subscriber
            guid = '' + nextGuid++;
        }
        func.observer_guid = guid;
        f.observer_guid = guid;

        // Don't add the same handler more than once.
        if (!this.handlers[guid]) {
            this.handlers[guid] = func;
            this.numHandlers++;
            if (this.numHandlers == 1) {
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };

    /**
     * Unsubscribes the function with the given guid from the channel.
     */
    Channel.prototype.unsubscribe = function(f) {
        // need a function to unsubscribe
        forceFunction(f);

        var guid = f.observer_guid,
            handler = this.handlers[guid];
        if (handler) {
            delete this.handlers[guid];
            this.numHandlers--;
            if (this.numHandlers === 0) {
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };

    /**
     * Calls all functions subscribed to this channel.
     */
    Channel.prototype.fire = function(e) {
        var fail = false,
            fireArgs = Array.prototype.slice.call(arguments);
        // Apply stickiness.
        if (this.state == 1) {
            this.state = 2;
            this.fireArgs = fireArgs;
        }
        if (this.numHandlers) {
            // Copy the values first so that it is safe to modify it from within
            // callbacks.
            var toCall = [];
            for (var item in this.handlers) {
                toCall.push(this.handlers[item]);
            }
            for (var i = 0; i < toCall.length; ++i) {
                toCall[i].apply(this, fireArgs);
            }
            if (this.state == 2 && this.numHandlers) {
                this.numHandlers = 0;
                this.handlers = {};
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };


    // defining them here so they are ready super fast!
    // DOM event that is received when the web page is loaded and parsed.
    channel.createSticky('onDOMContentLoaded');

    // Event to indicate the Cordova native side is ready.
    channel.createSticky('onNativeReady');

    // Event to indicate that all Cordova JavaScript objects have been created
    // and it's time to run plugin constructors.
    channel.createSticky('onCordovaReady');

    // Event to indicate that device properties are available
    channel.createSticky('onCordovaInfoReady');

    // Event to indicate that the connection property has been set.
    channel.createSticky('onCordovaConnectionReady');

    // Event to indicate that Cordova is ready
    channel.createSticky('onDeviceReady');

    // Event to indicate a resume lifecycle event
    channel.create('onResume');

    // Event to indicate a pause lifecycle event
    channel.create('onPause');

    // Event to indicate a destroy lifecycle event
    channel.createSticky('onDestroy');

    // Channels that must fire before "deviceready" is fired.
    channel.waitForInitialization('onCordovaReady');
    channel.waitForInitialization('onCordovaConnectionReady');

    module.exports = channel;

    });

    // file: lib/common/commandProxy.js
    define("cordova/commandProxy", function(require, exports, module) {


    // internal map of proxy function
    var CommandProxyMap = {};

    module.exports = {

        // example: cordova.commandProxy.add("Accelerometer",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);
        add:function(id,proxyObj) {
            console.log("adding proxy for " + id);
            CommandProxyMap[id] = proxyObj;
            return proxyObj;
        },

        // cordova.commandProxy.remove("Accelerometer");
        remove:function(id) {
            var proxy = CommandProxyMap[id];
            delete CommandProxyMap[id];
            CommandProxyMap[id] = null;
            return proxy;
        },

        get:function(service,action) {
            return ( CommandProxyMap[service] ? CommandProxyMap[service][action] : null );
        }
    };
    });

    // file: lib/common/common.js
    define("cordova/common", function(require, exports, module) {

    module.exports = {
        defaults: {
            cordova: {
                path: 'cordova',
                children: {
                    exec: {
                        path: 'cordova/exec'
                    },
                    logger: {
                        path: 'cordova/plugin/logger'
                    }
                }
            },
            Cordova: {
                children: {
                    exec: {
                        path: 'cordova/exec'
                    }
                }
            },
            open : {
                path: 'cordova/plugin/InAppBrowser'
            },
            navigator: {
                children: {
                    notification: {
                        path: 'cordova/plugin/notification'
                    },
                    accelerometer: {
                        path: 'cordova/plugin/accelerometer'
                    },
                    battery: {
                        path: 'cordova/plugin/battery'
                    },
                    camera:{
                        path: 'cordova/plugin/Camera'
                    },
                    compass:{
                        path: 'cordova/plugin/compass'
                    },
                    contacts: {
                        path: 'cordova/plugin/contacts'
                    },
                    device:{
                        children:{
                            capture: {
                                path: 'cordova/plugin/capture'
                            }
                        }
                    },
                    geolocation: {
                        path: 'cordova/plugin/geolocation'
                    },
                    globalization: {
                        path: 'cordova/plugin/globalization'
                    },
                    network: {
                        children: {
                            connection: {
                                path: 'cordova/plugin/network',
                                deprecated: 'navigator.network.connection is deprecated. Use navigator.connection instead.'
                            }
                        }
                    },
                    splashscreen: {
                        path: 'cordova/plugin/splashscreen'
                    }
                }
            },
            Acceleration: {
                path: 'cordova/plugin/Acceleration'
            },
            Camera:{
                path: 'cordova/plugin/CameraConstants'
            },
            CameraPopoverOptions: {
                path: 'cordova/plugin/CameraPopoverOptions'
            },
            CaptureError: {
                path: 'cordova/plugin/CaptureError'
            },
            CaptureAudioOptions:{
                path: 'cordova/plugin/CaptureAudioOptions'
            },
            CaptureImageOptions: {
                path: 'cordova/plugin/CaptureImageOptions'
            },
            CaptureVideoOptions: {
                path: 'cordova/plugin/CaptureVideoOptions'
            },
            CompassHeading:{
                path: 'cordova/plugin/CompassHeading'
            },
            CompassError:{
                path: 'cordova/plugin/CompassError'
            },
            ConfigurationData: {
                path: 'cordova/plugin/ConfigurationData'
            },
            Connection: {
                path: 'cordova/plugin/Connection'
            },
            Contact: {
                path: 'cordova/plugin/Contact'
            },
            ContactAddress: {
                path: 'cordova/plugin/ContactAddress'
            },
            ContactError: {
                path: 'cordova/plugin/ContactError'
            },
            ContactField: {
                path: 'cordova/plugin/ContactField'
            },
            ContactFindOptions: {
                path: 'cordova/plugin/ContactFindOptions'
            },
            ContactName: {
                path: 'cordova/plugin/ContactName'
            },
            ContactOrganization: {
                path: 'cordova/plugin/ContactOrganization'
            },
            Coordinates: {
                path: 'cordova/plugin/Coordinates'
            },
            device: {
                path: 'cordova/plugin/device'
            },
            GlobalizationError: {
                path: 'cordova/plugin/GlobalizationError'
            },
            Media: {
                path: 'cordova/plugin/Media'
            },
            MediaError: {
                path: 'cordova/plugin/MediaError'
            },
            MediaFile: {
                path: 'cordova/plugin/MediaFile'
            },
            MediaFileData:{
                path: 'cordova/plugin/MediaFileData'
            },
            Position: {
                path: 'cordova/plugin/Position'
            },
            PositionError: {
                path: 'cordova/plugin/PositionError'
            },
            ProgressEvent: {
                path: 'cordova/plugin/ProgressEvent'
            }
        },
        clobbers: {
            navigator: {
                children: {
                    connection: {
                        path: 'cordova/plugin/network'
                    }
                }
            }
        }
    };

    });

    // file: lib/android/exec.js
    define("cordova/exec", function(require, exports, module) {

    /**
     * Execute a cordova command.  It is up to the native side whether this action
     * is synchronous or asynchronous.  The native side can return:
     *      Synchronous: PluginResult object as a JSON string
     *      Asynchronous: Empty string ""
     * If async, the native side will cordova.callbackSuccess or cordova.callbackError,
     * depending upon the result of the action.
     *
     * @param {Function} success    The success callback
     * @param {Function} fail       The fail callback
     * @param {String} service      The name of the service to use
     * @param {String} action       Action to be run in cordova
     * @param {String[]} [args]     Zero or more arguments to pass to the method
     */
    var cordova = require('cordova'),
        nativeApiProvider = require('cordova/plugin/android/nativeapiprovider'),
        utils = require('cordova/utils'),
        jsToNativeModes = {
            PROMPT: 0,
            JS_OBJECT: 1,
            // This mode is currently for benchmarking purposes only. It must be enabled
            // on the native side through the ENABLE_LOCATION_CHANGE_EXEC_MODE
            // constant within CordovaWebViewClient.java before it will work.
            LOCATION_CHANGE: 2
        },
        nativeToJsModes = {
            // Polls for messages using the JS->Native bridge.
            POLLING: 0,
            // For LOAD_URL to be viable, it would need to have a work-around for
            // the bug where the soft-keyboard gets dismissed when a message is sent.
            LOAD_URL: 1,
            // For the ONLINE_EVENT to be viable, it would need to intercept all event
            // listeners (both through addEventListener and window.ononline) as well
            // as set the navigator property itself.
            ONLINE_EVENT: 2,
            // Uses reflection to access private APIs of the WebView that can send JS
            // to be executed.
            // Requires Android 3.2.4 or above.
            PRIVATE_API: 3
        },
        jsToNativeBridgeMode,  // Set lazily.
        nativeToJsBridgeMode = nativeToJsModes.ONLINE_EVENT,
        pollEnabled = false,
        messagesFromNative = [];

    function androidExec(success, fail, service, action, args) {
        // Set default bridge modes if they have not already been set.
        // By default, we use the failsafe, since addJavascriptInterface breaks too often
        if (jsToNativeBridgeMode === undefined) {
            androidExec.setJsToNativeBridgeMode(jsToNativeModes.JS_OBJECT);
        }

        // Process any ArrayBuffers in the args into a string.
        for (var i = 0; i < args.length; i++) {
            if (utils.typeName(args[i]) == 'ArrayBuffer') {
                args[i] = window.btoa(String.fromCharCode.apply(null, new Uint8Array(args[i])));
            }
        }

        var callbackId = service + cordova.callbackId++,
            argsJson = JSON.stringify(args),
            returnValue;

        // TODO: Returning the payload of a synchronous call was deprecated in 2.2.0.
        // Remove it after 6 months.
        function captureReturnValue(value) {
            returnValue = value;
            success && success(value);
        }

        cordova.callbacks[callbackId] = {success:captureReturnValue, fail:fail};

        if (jsToNativeBridgeMode == jsToNativeModes.LOCATION_CHANGE) {
            window.location = 'http://cdv_exec/' + service + '#' + action + '#' + callbackId + '#' + argsJson;
        } else {
            var messages = nativeApiProvider.get().exec(service, action, callbackId, argsJson);
            androidExec.processMessages(messages);
        }
        if (cordova.callbacks[callbackId]) {
            if (success || fail) {
                cordova.callbacks[callbackId].success = success;
            } else {
                delete cordova.callbacks[callbackId];
            }
        }
        return returnValue;
    }

    function pollOnce() {
        var msg = nativeApiProvider.get().retrieveJsMessages();
        androidExec.processMessages(msg);
    }

    function pollingTimerFunc() {
        if (pollEnabled) {
            pollOnce();
            setTimeout(pollingTimerFunc, 50);
        }
    }

    function hookOnlineApis() {
        function proxyEvent(e) {
            cordova.fireWindowEvent(e.type);
        }
        // The network module takes care of firing online and offline events.
        // It currently fires them only on document though, so we bridge them
        // to window here (while first listening for exec()-releated online/offline
        // events).
        window.addEventListener('online', pollOnce, false);
        window.addEventListener('offline', pollOnce, false);
        cordova.addWindowEventHandler('online');
        cordova.addWindowEventHandler('offline');
        document.addEventListener('online', proxyEvent, false);
        document.addEventListener('offline', proxyEvent, false);
    }

    hookOnlineApis();

    androidExec.jsToNativeModes = jsToNativeModes;
    androidExec.nativeToJsModes = nativeToJsModes;

    androidExec.setJsToNativeBridgeMode = function(mode) {
        if (mode == jsToNativeModes.JS_OBJECT && !window._cordovaNative) {
            console.log('Falling back on PROMPT mode since _cordovaNative is missing.');
            mode = jsToNativeModes.PROMPT;
        }
        nativeApiProvider.setPreferPrompt(mode == jsToNativeModes.PROMPT);
        jsToNativeBridgeMode = mode;
    };

    androidExec.setNativeToJsBridgeMode = function(mode) {
        if (mode == nativeToJsBridgeMode) {
            return;
        }
        if (nativeToJsBridgeMode == nativeToJsModes.POLLING) {
            pollEnabled = false;
        }

        nativeToJsBridgeMode = mode;
        // Tell the native side to switch modes.
        nativeApiProvider.get().setNativeToJsBridgeMode(mode);

        if (mode == nativeToJsModes.POLLING) {
            pollEnabled = true;
            setTimeout(pollingTimerFunc, 1);
        }
    };

    // Processes a single message, as encoded by NativeToJsMessageQueue.java.
    function processMessage(message) {
        try {
            var firstChar = message.charAt(0);
            if (firstChar == 'J') {
                eval(message.slice(1));
            } else if (firstChar == 'S' || firstChar == 'F') {
                var success = firstChar == 'S';
                var keepCallback = message.charAt(1) == '1';
                var spaceIdx = message.indexOf(' ', 2);
                var status = +message.slice(2, spaceIdx);
                var nextSpaceIdx = message.indexOf(' ', spaceIdx + 1);
                var callbackId = message.slice(spaceIdx + 1, nextSpaceIdx);
                var payloadKind = message.charAt(nextSpaceIdx + 1);
                var payload;
                if (payloadKind == 's') {
                    payload = message.slice(nextSpaceIdx + 2);
                } else if (payloadKind == 't') {
                    payload = true;
                } else if (payloadKind == 'f') {
                    payload = false;
                } else if (payloadKind == 'N') {
                    payload = null;
                } else if (payloadKind == 'n') {
                    payload = +message.slice(nextSpaceIdx + 2);
                } else if (payloadKind == 'A') {
                    var data = message.slice(nextSpaceIdx + 2);
                    var bytes = window.atob(data);
                    var arraybuffer = new Uint8Array(bytes.length);
                    for (var i = 0; i < bytes.length; i++) {
                        arraybuffer[i] = bytes.charCodeAt(i);
                    }
                    payload = arraybuffer.buffer;
                } else {
                    payload = JSON.parse(message.slice(nextSpaceIdx + 1));
                }
                cordova.callbackFromNative(callbackId, success, status, payload, keepCallback);
            } else {
                console.log("processMessage failed: invalid message:" + message);
            }
        } catch (e) {
            console.log("processMessage failed: Message: " + message);
            console.log("processMessage failed: Error: " + e);
            console.log("processMessage failed: Stack: " + e.stack);
        }
    }

    // This is called from the NativeToJsMessageQueue.java.
    androidExec.processMessages = function(messages) {
        if (messages) {
            messagesFromNative.push(messages);
            while (messagesFromNative.length) {
                messages = messagesFromNative.shift();
                // The Java side can send a * message to indicate that it
                // still has messages waiting to be retrieved.
                // TODO(agrieve): This is currently disabled on the Java side
                // since it breaks returning the result in exec of synchronous
                // plugins. Once we remove this ability, we can remove this comment.
                if (messages == '*') {
                    window.setTimeout(pollOnce, 0);
                    continue;
                }

                var spaceIdx = messages.indexOf(' ');
                var msgLen = +messages.slice(0, spaceIdx);
                var message = messages.substr(spaceIdx + 1, msgLen);
                messages = messages.slice(spaceIdx + msgLen + 1);
                // Put the remaining messages back into queue in case an exec()
                // is made by the callback.
                if (messages) {
                    messagesFromNative.unshift(messages);
                }

                if (message) {
                    processMessage(message);
                }
            }
        }
    };

    module.exports = androidExec;

    });

    // file: lib/common/modulemapper.js
    define("cordova/modulemapper", function(require, exports, module) {

    var builder = require('cordova/builder'),
        moduleMap = define.moduleMap,
        symbolList,
        deprecationMap;

    exports.reset = function() {
        symbolList = [];
        deprecationMap = {};
    };

    function addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {
        if (!(moduleName in moduleMap)) {
            throw new Error('Module ' + moduleName + ' does not exist.');
        }
        symbolList.push(strategy, moduleName, symbolPath);
        if (opt_deprecationMessage) {
            deprecationMap[symbolPath] = opt_deprecationMessage;
        }
    }

    // Note: Android 2.3 does have Function.bind().
    exports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('c', moduleName, symbolPath, opt_deprecationMessage);
    };

    exports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('m', moduleName, symbolPath, opt_deprecationMessage);
    };

    exports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('d', moduleName, symbolPath, opt_deprecationMessage);
    };

    function prepareNamespace(symbolPath, context) {
        if (!symbolPath) {
            return context;
        }
        var parts = symbolPath.split('.');
        var cur = context;
        for (var i = 0, part; part = parts[i]; ++i) {
            cur[part] = cur[part] || {};
        }
        return cur[parts[i-1]];
    }

    exports.mapModules = function(context) {
        var origSymbols = {};
        context.CDV_origSymbols = origSymbols;
        for (var i = 0, len = symbolList.length; i < len; i += 3) {
            var strategy = symbolList[i];
            var moduleName = symbolList[i + 1];
            var symbolPath = symbolList[i + 2];
            var lastDot = symbolPath.lastIndexOf('.');
            var namespace = symbolPath.substr(0, lastDot);
            var lastName = symbolPath.substr(lastDot + 1);

            var module = require(moduleName);
            var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;
            var parentObj = prepareNamespace(namespace, context);
            var target = parentObj[lastName];

            if (strategy == 'm' && target) {
                builder.recursiveMerge(target, module);
            } else if ((strategy == 'd' && !target) || (strategy != 'd')) {
                if (target) {
                    origSymbols[symbolPath] = target;
                }
                builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);
            }
        }
    };

    exports.getOriginalSymbol = function(context, symbolPath) {
        var origSymbols = context.CDV_origSymbols;
        if (origSymbols && (symbolPath in origSymbols)) {
            return origSymbols[symbolPath];
        }
        var parts = symbolPath.split('.');
        var obj = context;
        for (var i = 0; i < parts.length; ++i) {
            obj = obj && obj[parts[i]];
        }
        return obj;
    };

    exports.loadMatchingModules = function(matchingRegExp) {
        for (var k in moduleMap) {
            if (matchingRegExp.exec(k)) {
                require(k);
            }
        }
    };

    exports.reset();


    });

    // file: lib/android/platform.js
    define("cordova/platform", function(require, exports, module) {

    module.exports = {
        id: "android",
        initialize:function() {
            var channel = require("cordova/channel"),
                cordova = require('cordova'),
                exec = require('cordova/exec'),
                modulemapper = require('cordova/modulemapper');

            modulemapper.loadMatchingModules(/cordova.*\/symbols$/);
            modulemapper.mapModules(window);

            // Inject a listener for the backbutton on the document.
            var backButtonChannel = cordova.addDocumentEventHandler('backbutton');
            backButtonChannel.onHasSubscribersChange = function() {
                // If we just attached the first handler or detached the last handler,
                // let native know we need to override the back button.
                exec(null, null, "App", "overrideBackbutton", [this.numHandlers == 1]);
            };

            // Add hardware MENU and SEARCH button handlers
            cordova.addDocumentEventHandler('menubutton');
            cordova.addDocumentEventHandler('searchbutton');

            // Figure out if we need to shim-in localStorage and WebSQL
            // support from the native side.
            var storage = require('cordova/plugin/android/storage');

            // First patch WebSQL if necessary
            if (typeof window.openDatabase == 'undefined') {
                // Not defined, create an openDatabase function for all to use!
                window.openDatabase = storage.openDatabase;
            } else {
                // Defined, but some Android devices will throw a SECURITY_ERR -
                // so we wrap the whole thing in a try-catch and shim in our own
                // if the device has Android bug 16175.
                var originalOpenDatabase = window.openDatabase;
                window.openDatabase = function(name, version, desc, size) {
                    var db = null;
                    try {
                        db = originalOpenDatabase(name, version, desc, size);
                    }
                    catch (ex) {
                        if (ex.code === 18) {
                            db = null;
                        } else {
                            throw ex;
                        }
                    }

                    if (db === null) {
                        return storage.openDatabase(name, version, desc, size);
                    }
                    else {
                        return db;
                    }

                };
            }

            // Patch localStorage if necessary
            if (typeof window.localStorage == 'undefined' || window.localStorage === null) {
                window.localStorage = new storage.CupcakeLocalStorage();
            }

            // Let native code know we are all done on the JS side.
            // Native code will then un-hide the WebView.
            channel.join(function() {
                exec(null, null, "App", "show", []);
            }, [channel.onCordovaReady]);
        },
        clobbers: {
            navigator: {
                children: {
                    app:{
                        path: "cordova/plugin/android/app"
                    }
                }
            },
            File: { // exists natively on Android WebView, override
                path: "cordova/plugin/File"
            },
            FileReader: { // exists natively on Android WebView, override
                path: "cordova/plugin/FileReader"
            },
            FileError: { //exists natively on Android WebView on Android 4.x
                path: "cordova/plugin/FileError"
            },
            MediaError: { // exists natively on Android WebView on Android 4.x
                path: "cordova/plugin/MediaError"
            },
            open: {
                path: "cordova/plugin/InAppBrowser"
            }
        },
        merges: {
            device: {
                path: 'cordova/plugin/android/device'
            },
            navigator: {
                children: {
                    notification: {
                        path: 'cordova/plugin/android/notification'
                    }
                }
            }
        }
    };

    });

    // file: lib/common/plugin/Acceleration.js
    define("cordova/plugin/Acceleration", function(require, exports, module) {

    var Acceleration = function(x, y, z, timestamp) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.timestamp = timestamp || (new Date()).getTime();
    };

    module.exports = Acceleration;

    });

    // file: lib/common/plugin/Camera.js
    define("cordova/plugin/Camera", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        Camera = require('cordova/plugin/CameraConstants');

    var cameraExport = {};

    // Tack on the Camera Constants to the base camera plugin.
    for (var key in Camera) {
        cameraExport[key] = Camera[key];
    }

    /**
     * Gets a picture from source defined by "options.sourceType", and returns the
     * image as defined by the "options.destinationType" option.

     * The defaults are sourceType=CAMERA and destinationType=FILE_URI.
     *
     * @param {Function} successCallback
     * @param {Function} errorCallback
     * @param {Object} options
     */
    cameraExport.getPicture = function(successCallback, errorCallback, options) {
        argscheck.checkArgs('fFO', 'Camera.getPicture', arguments);
        options = options || {};
        var getValue = argscheck.getValue;

        var quality = getValue(options.quality, 50);
        var destinationType = getValue(options.destinationType, Camera.DestinationType.FILE_URI);
        var sourceType = getValue(options.sourceType, Camera.PictureSourceType.CAMERA);
        var targetWidth = getValue(options.targetWidth, -1);
        var targetHeight = getValue(options.targetHeight, -1);
        var encodingType = getValue(options.encodingType, Camera.EncodingType.JPEG);
        var mediaType = getValue(options.mediaType, Camera.MediaType.PICTURE);
        var allowEdit = !!options.allowEdit;
        var correctOrientation = !!options.correctOrientation;
        var saveToPhotoAlbum = !!options.saveToPhotoAlbum;
        var popoverOptions = getValue(options.popoverOptions, null);

        var args = [quality, destinationType, sourceType, targetWidth, targetHeight, encodingType,
                    mediaType, allowEdit, correctOrientation, saveToPhotoAlbum, popoverOptions];

        exec(successCallback, errorCallback, "Camera", "takePicture", args);
    };

    cameraExport.cleanup = function(successCallback, errorCallback) {
        exec(successCallback, errorCallback, "Camera", "cleanup", []);
    };

    module.exports = cameraExport;

    });

    // file: lib/common/plugin/CameraConstants.js
    define("cordova/plugin/CameraConstants", function(require, exports, module) {

    module.exports = {
      DestinationType:{
        DATA_URL: 0,         // Return base64 encoded string
        FILE_URI: 1,         // Return file uri (content://media/external/images/media/2 for Android)
        NATIVE_URI: 2        // Return native uri (eg. asset-library://... for iOS)
      },
      EncodingType:{
        JPEG: 0,             // Return JPEG encoded image
        PNG: 1               // Return PNG encoded image
      },
      MediaType:{
        PICTURE: 0,          // allow selection of still pictures only. DEFAULT. Will return format specified via DestinationType
        VIDEO: 1,            // allow selection of video only, ONLY RETURNS URL
        ALLMEDIA : 2         // allow selection from all media types
      },
      PictureSourceType:{
        PHOTOLIBRARY : 0,    // Choose image from picture library (same as SAVEDPHOTOALBUM for Android)
        CAMERA : 1,          // Take picture from camera
        SAVEDPHOTOALBUM : 2  // Choose image from picture library (same as PHOTOLIBRARY for Android)
      },
      PopoverArrowDirection:{
          ARROW_UP : 1,        // matches iOS UIPopoverArrowDirection constants to specify arrow location on popover
          ARROW_DOWN : 2,
          ARROW_LEFT : 4,
          ARROW_RIGHT : 8,
          ARROW_ANY : 15
      }
    };

    });

    // file: lib/common/plugin/CameraPopoverOptions.js
    define("cordova/plugin/CameraPopoverOptions", function(require, exports, module) {

    var Camera = require('cordova/plugin/CameraConstants');

    /**
     * Encapsulates options for iOS Popover image picker
     */
    var CameraPopoverOptions = function(x,y,width,height,arrowDir){
        // information of rectangle that popover should be anchored to
        this.x = x || 0;
        this.y = y || 32;
        this.width = width || 320;
        this.height = height || 480;
        // The direction of the popover arrow
        this.arrowDir = arrowDir || Camera.PopoverArrowDirection.ARROW_ANY;
    };

    module.exports = CameraPopoverOptions;

    });

    // file: lib/common/plugin/CaptureAudioOptions.js
    define("cordova/plugin/CaptureAudioOptions", function(require, exports, module) {

    /**
     * Encapsulates all audio capture operation configuration options.
     */
    var CaptureAudioOptions = function(){
        // Upper limit of sound clips user can record. Value must be equal or greater than 1.
        this.limit = 1;
        // Maximum duration of a single sound clip in seconds.
        this.duration = 0;
        // The selected audio mode. Must match with one of the elements in supportedAudioModes array.
        this.mode = null;
    };

    module.exports = CaptureAudioOptions;

    });

    // file: lib/common/plugin/CaptureError.js
    define("cordova/plugin/CaptureError", function(require, exports, module) {

    /**
     * The CaptureError interface encapsulates all errors in the Capture API.
     */
    var CaptureError = function(c) {
       this.code = c || null;
    };

    // Camera or microphone failed to capture image or sound.
    CaptureError.CAPTURE_INTERNAL_ERR = 0;
    // Camera application or audio capture application is currently serving other capture request.
    CaptureError.CAPTURE_APPLICATION_BUSY = 1;
    // Invalid use of the API (e.g. limit parameter has value less than one).
    CaptureError.CAPTURE_INVALID_ARGUMENT = 2;
    // User exited camera application or audio capture application before capturing anything.
    CaptureError.CAPTURE_NO_MEDIA_FILES = 3;
    // The requested capture operation is not supported.
    CaptureError.CAPTURE_NOT_SUPPORTED = 20;

    module.exports = CaptureError;

    });

    // file: lib/common/plugin/CaptureImageOptions.js
    define("cordova/plugin/CaptureImageOptions", function(require, exports, module) {

    /**
     * Encapsulates all image capture operation configuration options.
     */
    var CaptureImageOptions = function(){
        // Upper limit of images user can take. Value must be equal or greater than 1.
        this.limit = 1;
        // The selected image mode. Must match with one of the elements in supportedImageModes array.
        this.mode = null;
    };

    module.exports = CaptureImageOptions;

    });

    // file: lib/common/plugin/CaptureVideoOptions.js
    define("cordova/plugin/CaptureVideoOptions", function(require, exports, module) {

    /**
     * Encapsulates all video capture operation configuration options.
     */
    var CaptureVideoOptions = function(){
        // Upper limit of videos user can record. Value must be equal or greater than 1.
        this.limit = 1;
        // Maximum duration of a single video clip in seconds.
        this.duration = 0;
        // The selected video mode. Must match with one of the elements in supportedVideoModes array.
        this.mode = null;
    };

    module.exports = CaptureVideoOptions;

    });

    // file: lib/common/plugin/CompassError.js
    define("cordova/plugin/CompassError", function(require, exports, module) {

    /**
     *  CompassError.
     *  An error code assigned by an implementation when an error has occurred
     * @constructor
     */
    var CompassError = function(err) {
        this.code = (err !== undefined ? err : null);
    };

    CompassError.COMPASS_INTERNAL_ERR = 0;
    CompassError.COMPASS_NOT_SUPPORTED = 20;

    module.exports = CompassError;

    });

    // file: lib/common/plugin/CompassHeading.js
    define("cordova/plugin/CompassHeading", function(require, exports, module) {

    var CompassHeading = function(magneticHeading, trueHeading, headingAccuracy, timestamp) {
      this.magneticHeading = magneticHeading || null;
      this.trueHeading = trueHeading || null;
      this.headingAccuracy = headingAccuracy || null;
      this.timestamp = timestamp || new Date().getTime();
    };

    module.exports = CompassHeading;

    });

    // file: lib/common/plugin/ConfigurationData.js
    define("cordova/plugin/ConfigurationData", function(require, exports, module) {

    /**
     * Encapsulates a set of parameters that the capture device supports.
     */
    function ConfigurationData() {
        // The ASCII-encoded string in lower case representing the media type.
        this.type = null;
        // The height attribute represents height of the image or video in pixels.
        // In the case of a sound clip this attribute has value 0.
        this.height = 0;
        // The width attribute represents width of the image or video in pixels.
        // In the case of a sound clip this attribute has value 0
        this.width = 0;
    }

    module.exports = ConfigurationData;

    });

    // file: lib/common/plugin/Connection.js
    define("cordova/plugin/Connection", function(require, exports, module) {

    /**
     * Network status
     */
    module.exports = {
            UNKNOWN: "unknown",
            ETHERNET: "ethernet",
            WIFI: "wifi",
            CELL_2G: "2g",
            CELL_3G: "3g",
            CELL_4G: "4g",
            NONE: "none"
    };

    });

    // file: lib/common/plugin/Contact.js
    define("cordova/plugin/Contact", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        ContactError = require('cordova/plugin/ContactError'),
        utils = require('cordova/utils');

    /**
    * Converts primitives into Complex Object
    * Currently only used for Date fields
    */
    function convertIn(contact) {
        var value = contact.birthday;
        try {
          contact.birthday = new Date(parseFloat(value));
        } catch (exception){
          console.log("Cordova Contact convertIn error: exception creating date.");
        }
        return contact;
    }

    /**
    * Converts Complex objects into primitives
    * Only conversion at present is for Dates.
    **/

    function convertOut(contact) {
        var value = contact.birthday;
        if (value !== null) {
            // try to make it a Date object if it is not already
            if (!utils.isDate(value)){
                try {
                    value = new Date(value);
                } catch(exception){
                    value = null;
                }
            }
            if (utils.isDate(value)){
                value = value.valueOf(); // convert to milliseconds
            }
            contact.birthday = value;
        }
        return contact;
    }

    /**
    * Contains information about a single contact.
    * @constructor
    * @param {DOMString} id unique identifier
    * @param {DOMString} displayName
    * @param {ContactName} name
    * @param {DOMString} nickname
    * @param {Array.<ContactField>} phoneNumbers array of phone numbers
    * @param {Array.<ContactField>} emails array of email addresses
    * @param {Array.<ContactAddress>} addresses array of addresses
    * @param {Array.<ContactField>} ims instant messaging user ids
    * @param {Array.<ContactOrganization>} organizations
    * @param {DOMString} birthday contact's birthday
    * @param {DOMString} note user notes about contact
    * @param {Array.<ContactField>} photos
    * @param {Array.<ContactField>} categories
    * @param {Array.<ContactField>} urls contact's web sites
    */
    var Contact = function (id, displayName, name, nickname, phoneNumbers, emails, addresses,
        ims, organizations, birthday, note, photos, categories, urls) {
        this.id = id || null;
        this.rawId = null;
        this.displayName = displayName || null;
        this.name = name || null; // ContactName
        this.nickname = nickname || null;
        this.phoneNumbers = phoneNumbers || null; // ContactField[]
        this.emails = emails || null; // ContactField[]
        this.addresses = addresses || null; // ContactAddress[]
        this.ims = ims || null; // ContactField[]
        this.organizations = organizations || null; // ContactOrganization[]
        this.birthday = birthday || null;
        this.note = note || null;
        this.photos = photos || null; // ContactField[]
        this.categories = categories || null; // ContactField[]
        this.urls = urls || null; // ContactField[]
    };

    /**
    * Removes contact from device storage.
    * @param successCB success callback
    * @param errorCB error callback
    */
    Contact.prototype.remove = function(successCB, errorCB) {
        argscheck.checkArgs('FF', 'Contact.remove', arguments);
        var fail = errorCB && function(code) {
            errorCB(new ContactError(code));
        };
        if (this.id === null) {
            fail(ContactError.UNKNOWN_ERROR);
        }
        else {
            exec(successCB, fail, "Contacts", "remove", [this.id]);
        }
    };

    /**
    * Creates a deep copy of this Contact.
    * With the contact ID set to null.
    * @return copy of this Contact
    */
    Contact.prototype.clone = function() {
        var clonedContact = utils.clone(this);
        clonedContact.id = null;
        clonedContact.rawId = null;

        function nullIds(arr) {
            if (arr) {
                for (var i = 0; i < arr.length; ++i) {
                    arr[i].id = null;
                }
            }
        }

        // Loop through and clear out any id's in phones, emails, etc.
        nullIds(clonedContact.phoneNumbers);
        nullIds(clonedContact.emails);
        nullIds(clonedContact.addresses);
        nullIds(clonedContact.ims);
        nullIds(clonedContact.organizations);
        nullIds(clonedContact.categories);
        nullIds(clonedContact.photos);
        nullIds(clonedContact.urls);
        return clonedContact;
    };

    /**
    * Persists contact to device storage.
    * @param successCB success callback
    * @param errorCB error callback
    */
    Contact.prototype.save = function(successCB, errorCB) {
        argscheck.checkArgs('FFO', 'Contact.save', arguments);
        var fail = errorCB && function(code) {
            errorCB(new ContactError(code));
        };
        var success = function(result) {
            if (result) {
                if (successCB) {
                    var fullContact = require('cordova/plugin/contacts').create(result);
                    successCB(convertIn(fullContact));
                }
            }
            else {
                // no Entry object returned
                fail(ContactError.UNKNOWN_ERROR);
            }
        };
        var dupContact = convertOut(utils.clone(this));
        exec(success, fail, "Contacts", "save", [dupContact]);
    };


    module.exports = Contact;

    });

    // file: lib/common/plugin/ContactAddress.js
    define("cordova/plugin/ContactAddress", function(require, exports, module) {

    /**
    * Contact address.
    * @constructor
    * @param {DOMString} id unique identifier, should only be set by native code
    * @param formatted // NOTE: not a W3C standard
    * @param streetAddress
    * @param locality
    * @param region
    * @param postalCode
    * @param country
    */

    var ContactAddress = function(pref, type, formatted, streetAddress, locality, region, postalCode, country) {
        this.id = null;
        this.pref = (typeof pref != 'undefined' ? pref : false);
        this.type = type || null;
        this.formatted = formatted || null;
        this.streetAddress = streetAddress || null;
        this.locality = locality || null;
        this.region = region || null;
        this.postalCode = postalCode || null;
        this.country = country || null;
    };

    module.exports = ContactAddress;

    });

    // file: lib/common/plugin/ContactError.js
    define("cordova/plugin/ContactError", function(require, exports, module) {

    /**
     *  ContactError.
     *  An error code assigned by an implementation when an error has occurred
     * @constructor
     */
    var ContactError = function(err) {
        this.code = (typeof err != 'undefined' ? err : null);
    };

    /**
     * Error codes
     */
    ContactError.UNKNOWN_ERROR = 0;
    ContactError.INVALID_ARGUMENT_ERROR = 1;
    ContactError.TIMEOUT_ERROR = 2;
    ContactError.PENDING_OPERATION_ERROR = 3;
    ContactError.IO_ERROR = 4;
    ContactError.NOT_SUPPORTED_ERROR = 5;
    ContactError.PERMISSION_DENIED_ERROR = 20;

    module.exports = ContactError;

    });

    // file: lib/common/plugin/ContactField.js
    define("cordova/plugin/ContactField", function(require, exports, module) {

    /**
    * Generic contact field.
    * @constructor
    * @param {DOMString} id unique identifier, should only be set by native code // NOTE: not a W3C standard
    * @param type
    * @param value
    * @param pref
    */
    var ContactField = function(type, value, pref) {
        this.id = null;
        this.type = (type && type.toString()) || null;
        this.value = (value && value.toString()) || null;
        this.pref = (typeof pref != 'undefined' ? pref : false);
    };

    module.exports = ContactField;

    });

    // file: lib/common/plugin/ContactFindOptions.js
    define("cordova/plugin/ContactFindOptions", function(require, exports, module) {

    /**
     * ContactFindOptions.
     * @constructor
     * @param filter used to match contacts against
     * @param multiple boolean used to determine if more than one contact should be returned
     */

    var ContactFindOptions = function(filter, multiple) {
        this.filter = filter || '';
        this.multiple = (typeof multiple != 'undefined' ? multiple : false);
    };

    module.exports = ContactFindOptions;

    });

    // file: lib/common/plugin/ContactName.js
    define("cordova/plugin/ContactName", function(require, exports, module) {

    /**
    * Contact name.
    * @constructor
    * @param formatted // NOTE: not part of W3C standard
    * @param familyName
    * @param givenName
    * @param middle
    * @param prefix
    * @param suffix
    */
    var ContactName = function(formatted, familyName, givenName, middle, prefix, suffix) {
        this.formatted = formatted || null;
        this.familyName = familyName || null;
        this.givenName = givenName || null;
        this.middleName = middle || null;
        this.honorificPrefix = prefix || null;
        this.honorificSuffix = suffix || null;
    };

    module.exports = ContactName;

    });

    // file: lib/common/plugin/ContactOrganization.js
    define("cordova/plugin/ContactOrganization", function(require, exports, module) {

    /**
    * Contact organization.
    * @constructor
    * @param {DOMString} id unique identifier, should only be set by native code // NOTE: not a W3C standard
    * @param name
    * @param dept
    * @param title
    * @param startDate
    * @param endDate
    * @param location
    * @param desc
    */

    var ContactOrganization = function(pref, type, name, dept, title) {
        this.id = null;
        this.pref = (typeof pref != 'undefined' ? pref : false);
        this.type = type || null;
        this.name = name || null;
        this.department = dept || null;
        this.title = title || null;
    };

    module.exports = ContactOrganization;

    });

    // file: lib/common/plugin/Coordinates.js
    define("cordova/plugin/Coordinates", function(require, exports, module) {

    /**
     * This class contains position information.
     * @param {Object} lat
     * @param {Object} lng
     * @param {Object} alt
     * @param {Object} acc
     * @param {Object} head
     * @param {Object} vel
     * @param {Object} altacc
     * @constructor
     */
    var Coordinates = function(lat, lng, alt, acc, head, vel, altacc) {
        /**
         * The latitude of the position.
         */
        this.latitude = lat;
        /**
         * The longitude of the position,
         */
        this.longitude = lng;
        /**
         * The accuracy of the position.
         */
        this.accuracy = acc;
        /**
         * The altitude of the position.
         */
        this.altitude = (alt !== undefined ? alt : null);
        /**
         * The direction the device is moving at the position.
         */
        this.heading = (head !== undefined ? head : null);
        /**
         * The velocity with which the device is moving at the position.
         */
        this.speed = (vel !== undefined ? vel : null);

        if (this.speed === 0 || this.speed === null) {
            this.heading = NaN;
        }

        /**
         * The altitude accuracy of the position.
         */
        this.altitudeAccuracy = (altacc !== undefined) ? altacc : null;
    };

    module.exports = Coordinates;

    });

    // file: lib/common/plugin/DirectoryEntry.js
    define("cordova/plugin/DirectoryEntry", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        Entry = require('cordova/plugin/Entry'),
        FileError = require('cordova/plugin/FileError'),
        DirectoryReader = require('cordova/plugin/DirectoryReader');

    /**
     * An interface representing a directory on the file system.
     *
     * {boolean} isFile always false (readonly)
     * {boolean} isDirectory always true (readonly)
     * {DOMString} name of the directory, excluding the path leading to it (readonly)
     * {DOMString} fullPath the absolute full path to the directory (readonly)
     * TODO: implement this!!! {FileSystem} filesystem on which the directory resides (readonly)
     */
    var DirectoryEntry = function(name, fullPath) {
         DirectoryEntry.__super__.constructor.call(this, false, true, name, fullPath);
    };

    utils.extend(DirectoryEntry, Entry);

    /**
     * Creates a new DirectoryReader to read entries from this directory
     */
    DirectoryEntry.prototype.createReader = function() {
        return new DirectoryReader(this.fullPath);
    };

    /**
     * Creates or looks up a directory
     *
     * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a directory
     * @param {Flags} options to create or exclusively create the directory
     * @param {Function} successCallback is called with the new entry
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryEntry.prototype.getDirectory = function(path, options, successCallback, errorCallback) {
        argscheck.checkArgs('sOFF', 'DirectoryEntry.getDirectory', arguments);
        var win = successCallback && function(result) {
            var entry = new DirectoryEntry(result.name, result.fullPath);
            successCallback(entry);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getDirectory", [this.fullPath, path, options]);
    };

    /**
     * Deletes a directory and all of it's contents
     *
     * @param {Function} successCallback is called with no parameters
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryEntry.prototype.removeRecursively = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'DirectoryEntry.removeRecursively', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(successCallback, fail, "File", "removeRecursively", [this.fullPath]);
    };

    /**
     * Creates or looks up a file
     *
     * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a file
     * @param {Flags} options to create or exclusively create the file
     * @param {Function} successCallback is called with the new entry
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryEntry.prototype.getFile = function(path, options, successCallback, errorCallback) {
        argscheck.checkArgs('sOFF', 'DirectoryEntry.getFile', arguments);
        var win = successCallback && function(result) {
            var FileEntry = require('cordova/plugin/FileEntry');
            var entry = new FileEntry(result.name, result.fullPath);
            successCallback(entry);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getFile", [this.fullPath, path, options]);
    };

    module.exports = DirectoryEntry;

    });

    // file: lib/common/plugin/DirectoryReader.js
    define("cordova/plugin/DirectoryReader", function(require, exports, module) {

    var exec = require('cordova/exec'),
        FileError = require('cordova/plugin/FileError') ;

    /**
     * An interface that lists the files and directories in a directory.
     */
    function DirectoryReader(path) {
        this.path = path || null;
    }

    /**
     * Returns a list of entries from a directory.
     *
     * @param {Function} successCallback is called with a list of entries
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryReader.prototype.readEntries = function(successCallback, errorCallback) {
        var win = typeof successCallback !== 'function' ? null : function(result) {
            var retVal = [];
            for (var i=0; i<result.length; i++) {
                var entry = null;
                if (result[i].isDirectory) {
                    entry = new (require('cordova/plugin/DirectoryEntry'))();
                }
                else if (result[i].isFile) {
                    entry = new (require('cordova/plugin/FileEntry'))();
                }
                entry.isDirectory = result[i].isDirectory;
                entry.isFile = result[i].isFile;
                entry.name = result[i].name;
                entry.fullPath = result[i].fullPath;
                retVal.push(entry);
            }
            successCallback(retVal);
        };
        var fail = typeof errorCallback !== 'function' ? null : function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "readEntries", [this.path]);
    };

    module.exports = DirectoryReader;

    });

    // file: lib/common/plugin/Entry.js
    define("cordova/plugin/Entry", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        FileError = require('cordova/plugin/FileError'),
        Metadata = require('cordova/plugin/Metadata');

    /**
     * Represents a file or directory on the local file system.
     *
     * @param isFile
     *            {boolean} true if Entry is a file (readonly)
     * @param isDirectory
     *            {boolean} true if Entry is a directory (readonly)
     * @param name
     *            {DOMString} name of the file or directory, excluding the path
     *            leading to it (readonly)
     * @param fullPath
     *            {DOMString} the absolute full path to the file or directory
     *            (readonly)
     */
    function Entry(isFile, isDirectory, name, fullPath, fileSystem) {
        this.isFile = !!isFile;
        this.isDirectory = !!isDirectory;
        this.name = name || '';
        this.fullPath = fullPath || '';
        this.filesystem = fileSystem || null;
    }

    /**
     * Look up the metadata of the entry.
     *
     * @param successCallback
     *            {Function} is called with a Metadata object
     * @param errorCallback
     *            {Function} is called with a FileError
     */
    Entry.prototype.getMetadata = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'Entry.getMetadata', arguments);
        var success = successCallback && function(lastModified) {
            var metadata = new Metadata(lastModified);
            successCallback(metadata);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };

        exec(success, fail, "File", "getMetadata", [this.fullPath]);
    };

    /**
     * Set the metadata of the entry.
     *
     * @param successCallback
     *            {Function} is called with a Metadata object
     * @param errorCallback
     *            {Function} is called with a FileError
     * @param metadataObject
     *            {Object} keys and values to set
     */
    Entry.prototype.setMetadata = function(successCallback, errorCallback, metadataObject) {
        argscheck.checkArgs('FFO', 'Entry.setMetadata', arguments);
        exec(successCallback, errorCallback, "File", "setMetadata", [this.fullPath, metadataObject]);
    };

    /**
     * Move a file or directory to a new location.
     *
     * @param parent
     *            {DirectoryEntry} the directory to which to move this entry
     * @param newName
     *            {DOMString} new name of the entry, defaults to the current name
     * @param successCallback
     *            {Function} called with the new DirectoryEntry object
     * @param errorCallback
     *            {Function} called with a FileError
     */
    Entry.prototype.moveTo = function(parent, newName, successCallback, errorCallback) {
        argscheck.checkArgs('oSFF', 'Entry.moveTo', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        // source path
        var srcPath = this.fullPath,
            // entry name
            name = newName || this.name,
            success = function(entry) {
                if (entry) {
                    if (successCallback) {
                        // create appropriate Entry object
                        var result = (entry.isDirectory) ? new (require('cordova/plugin/DirectoryEntry'))(entry.name, entry.fullPath) : new (require('cordova/plugin/FileEntry'))(entry.name, entry.fullPath);
                        successCallback(result);
                    }
                }
                else {
                    // no Entry object returned
                    fail && fail(FileError.NOT_FOUND_ERR);
                }
            };

        // copy
        exec(success, fail, "File", "moveTo", [srcPath, parent.fullPath, name]);
    };

    /**
     * Copy a directory to a different location.
     *
     * @param parent
     *            {DirectoryEntry} the directory to which to copy the entry
     * @param newName
     *            {DOMString} new name of the entry, defaults to the current name
     * @param successCallback
     *            {Function} called with the new Entry object
     * @param errorCallback
     *            {Function} called with a FileError
     */
    Entry.prototype.copyTo = function(parent, newName, successCallback, errorCallback) {
        argscheck.checkArgs('oSFF', 'Entry.copyTo', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };

            // source path
        var srcPath = this.fullPath,
            // entry name
            name = newName || this.name,
            // success callback
            success = function(entry) {
                if (entry) {
                    if (successCallback) {
                        // create appropriate Entry object
                        var result = (entry.isDirectory) ? new (require('cordova/plugin/DirectoryEntry'))(entry.name, entry.fullPath) : new (require('cordova/plugin/FileEntry'))(entry.name, entry.fullPath);
                        successCallback(result);
                    }
                }
                else {
                    // no Entry object returned
                    fail && fail(FileError.NOT_FOUND_ERR);
                }
            };

        // copy
        exec(success, fail, "File", "copyTo", [srcPath, parent.fullPath, name]);
    };

    /**
     * Return a URL that can be used to identify this entry.
     */
    Entry.prototype.toURL = function() {
        // fullPath attribute contains the full URL
        return this.fullPath;
    };

    /**
     * Returns a URI that can be used to identify this entry.
     *
     * @param {DOMString} mimeType for a FileEntry, the mime type to be used to interpret the file, when loaded through this URI.
     * @return uri
     */
    Entry.prototype.toURI = function(mimeType) {
        console.log("DEPRECATED: Update your code to use 'toURL'");
        // fullPath attribute contains the full URI
        return this.toURL();
    };

    /**
     * Remove a file or directory. It is an error to attempt to delete a
     * directory that is not empty. It is an error to attempt to delete a
     * root directory of a file system.
     *
     * @param successCallback {Function} called with no parameters
     * @param errorCallback {Function} called with a FileError
     */
    Entry.prototype.remove = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'Entry.remove', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(successCallback, fail, "File", "remove", [this.fullPath]);
    };

    /**
     * Look up the parent DirectoryEntry of this entry.
     *
     * @param successCallback {Function} called with the parent DirectoryEntry object
     * @param errorCallback {Function} called with a FileError
     */
    Entry.prototype.getParent = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'Entry.getParent', arguments);
        var win = successCallback && function(result) {
            var DirectoryEntry = require('cordova/plugin/DirectoryEntry');
            var entry = new DirectoryEntry(result.name, result.fullPath);
            successCallback(entry);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getParent", [this.fullPath]);
    };

    module.exports = Entry;

    });

    // file: lib/common/plugin/File.js
    define("cordova/plugin/File", function(require, exports, module) {

    /**
     * Constructor.
     * name {DOMString} name of the file, without path information
     * fullPath {DOMString} the full path of the file, including the name
     * type {DOMString} mime type
     * lastModifiedDate {Date} last modified date
     * size {Number} size of the file in bytes
     */

    var File = function(name, fullPath, type, lastModifiedDate, size){
        this.name = name || '';
        this.fullPath = fullPath || null;
        this.type = type || null;
        this.lastModifiedDate = lastModifiedDate || null;
        this.size = size || 0;

        // These store the absolute start and end for slicing the file.
        this.start = 0;
        this.end = this.size;
    };

    /**
     * Returns a "slice" of the file. Since Cordova Files don't contain the actual
     * content, this really returns a File with adjusted start and end.
     * Slices of slices are supported.
     * start {Number} The index at which to start the slice (inclusive).
     * end {Number} The index at which to end the slice (exclusive).
     */
    File.prototype.slice = function(start, end) {
        var size = this.end - this.start;
        var newStart = 0;
        var newEnd = size;
        if (arguments.length) {
            if (start < 0) {
                newStart = Math.max(size + start, 0);
            } else {
                newStart = Math.min(size, start);
            }
        }

        if (arguments.length >= 2) {
            if (end < 0) {
                newEnd = Math.max(size + end, 0);
            } else {
                newEnd = Math.min(end, size);
            }
        }

        var newFile = new File(this.name, this.fullPath, this.type, this.lastModifiedData, this.size);
        newFile.start = this.start + newStart;
        newFile.end = this.start + newEnd;
        return newFile;
    };


    module.exports = File;

    });

    // file: lib/common/plugin/FileEntry.js
    define("cordova/plugin/FileEntry", function(require, exports, module) {

    var utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        Entry = require('cordova/plugin/Entry'),
        FileWriter = require('cordova/plugin/FileWriter'),
        File = require('cordova/plugin/File'),
        FileError = require('cordova/plugin/FileError');

    /**
     * An interface representing a file on the file system.
     *
     * {boolean} isFile always true (readonly)
     * {boolean} isDirectory always false (readonly)
     * {DOMString} name of the file, excluding the path leading to it (readonly)
     * {DOMString} fullPath the absolute full path to the file (readonly)
     * {FileSystem} filesystem on which the file resides (readonly)
     */
    var FileEntry = function(name, fullPath) {
         FileEntry.__super__.constructor.apply(this, [true, false, name, fullPath]);
    };

    utils.extend(FileEntry, Entry);

    /**
     * Creates a new FileWriter associated with the file that this FileEntry represents.
     *
     * @param {Function} successCallback is called with the new FileWriter
     * @param {Function} errorCallback is called with a FileError
     */
    FileEntry.prototype.createWriter = function(successCallback, errorCallback) {
        this.file(function(filePointer) {
            var writer = new FileWriter(filePointer);

            if (writer.fileName === null || writer.fileName === "") {
                errorCallback && errorCallback(new FileError(FileError.INVALID_STATE_ERR));
            } else {
                successCallback && successCallback(writer);
            }
        }, errorCallback);
    };

    /**
     * Returns a File that represents the current state of the file that this FileEntry represents.
     *
     * @param {Function} successCallback is called with the new File object
     * @param {Function} errorCallback is called with a FileError
     */
    FileEntry.prototype.file = function(successCallback, errorCallback) {
        var win = successCallback && function(f) {
            var file = new File(f.name, f.fullPath, f.type, f.lastModifiedDate, f.size);
            successCallback(file);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getFileMetadata", [this.fullPath]);
    };


    module.exports = FileEntry;

    });

    // file: lib/common/plugin/FileError.js
    define("cordova/plugin/FileError", function(require, exports, module) {

    /**
     * FileError
     */
    function FileError(error) {
      this.code = error || null;
    }

    // File error codes
    // Found in DOMException
    FileError.NOT_FOUND_ERR = 1;
    FileError.SECURITY_ERR = 2;
    FileError.ABORT_ERR = 3;

    // Added by File API specification
    FileError.NOT_READABLE_ERR = 4;
    FileError.ENCODING_ERR = 5;
    FileError.NO_MODIFICATION_ALLOWED_ERR = 6;
    FileError.INVALID_STATE_ERR = 7;
    FileError.SYNTAX_ERR = 8;
    FileError.INVALID_MODIFICATION_ERR = 9;
    FileError.QUOTA_EXCEEDED_ERR = 10;
    FileError.TYPE_MISMATCH_ERR = 11;
    FileError.PATH_EXISTS_ERR = 12;

    module.exports = FileError;

    });

    // file: lib/common/plugin/FileReader.js
    define("cordova/plugin/FileReader", function(require, exports, module) {

    var exec = require('cordova/exec'),
        modulemapper = require('cordova/modulemapper'),
        utils = require('cordova/utils'),
        File = require('cordova/plugin/File'),
        FileError = require('cordova/plugin/FileError'),
        ProgressEvent = require('cordova/plugin/ProgressEvent'),
        origFileReader = modulemapper.getOriginalSymbol(this, 'FileReader');

    /**
     * This class reads the mobile device file system.
     *
     * For Android:
     *      The root directory is the root of the file system.
     *      To read from the SD card, the file name is "sdcard/my_file.txt"
     * @constructor
     */
    var FileReader = function() {
        this._readyState = 0;
        this._error = null;
        this._result = null;
        this._fileName = '';
        this._realReader = origFileReader ? new origFileReader() : {};
    };

    // States
    FileReader.EMPTY = 0;
    FileReader.LOADING = 1;
    FileReader.DONE = 2;

    utils.defineGetter(FileReader.prototype, 'readyState', function() {
        return this._fileName ? this._readyState : this._realReader.readyState;
    });

    utils.defineGetter(FileReader.prototype, 'error', function() {
        return this._fileName ? this._error: this._realReader.error;
    });

    utils.defineGetter(FileReader.prototype, 'result', function() {
        return this._fileName ? this._result: this._realReader.result;
    });

    function defineEvent(eventName) {
        utils.defineGetterSetter(FileReader.prototype, eventName, function() {
            return this._realReader[eventName] || null;
        }, function(value) {
            this._realReader[eventName] = value;
        });
    }
    defineEvent('onloadstart');    // When the read starts.
    defineEvent('onprogress');     // While reading (and decoding) file or fileBlob data, and reporting partial file data (progress.loaded/progress.total)
    defineEvent('onload');         // When the read has successfully completed.
    defineEvent('onerror');        // When the read has failed (see errors).
    defineEvent('onloadend');      // When the request has completed (either in success or failure).
    defineEvent('onabort');        // When the read has been aborted. For instance, by invoking the abort() method.

    function initRead(reader, file) {
        // Already loading something
        if (reader.readyState == FileReader.LOADING) {
          throw new FileError(FileError.INVALID_STATE_ERR);
        }

        reader._result = null;
        reader._error = null;
        reader._readyState = FileReader.LOADING;

        if (typeof file == 'string') {
            // Deprecated in Cordova 2.4.
            console.warning('Using a string argument with FileReader.readAs functions is deprecated.');
            reader._fileName = file;
        } else if (typeof file.fullPath == 'string') {
            reader._fileName = file.fullPath;
        } else {
            reader._fileName = '';
            return true;
        }

        reader.onloadstart && reader.onloadstart(new ProgressEvent("loadstart", {target:reader}));
    }

    /**
     * Abort reading file.
     */
    FileReader.prototype.abort = function() {
        if (origFileReader && !this._fileName) {
            return this._realReader.abort();
        }
        this._result = null;

        if (this._readyState == FileReader.DONE || this._readyState == FileReader.EMPTY) {
          return;
        }

        this._readyState = FileReader.DONE;

        // If abort callback
        if (typeof this.onabort === 'function') {
            this.onabort(new ProgressEvent('abort', {target:this}));
        }
        // If load end callback
        if (typeof this.onloadend === 'function') {
            this.onloadend(new ProgressEvent('loadend', {target:this}));
        }
    };

    /**
     * Read text file.
     *
     * @param file          {File} File object containing file properties
     * @param encoding      [Optional] (see http://www.iana.org/assignments/character-sets)
     */
    FileReader.prototype.readAsText = function(file, encoding) {
        if (initRead(this, file)) {
            return this._realReader.readAsText(file, encoding);
        }

        // Default encoding is UTF-8
        var enc = encoding ? encoding : "UTF-8";
        var me = this;
        var execArgs = [this._fileName, enc];

        // Maybe add slice parameters.
        if (file.end < file.size) {
            execArgs.push(file.start, file.end);
        } else if (file.start > 0) {
            execArgs.push(file.start);
        }

        // Read file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // Save result
                me._result = r;

                // If onload callback
                if (typeof me.onload === "function") {
                    me.onload(new ProgressEvent("load", {target:me}));
                }

                // DONE state
                me._readyState = FileReader.DONE;

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // DONE state
                me._readyState = FileReader.DONE;

                // null result
                me._result = null;

                // Save error
                me._error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {target:me}));
                }

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            }, "File", "readAsText", execArgs);
    };


    /**
     * Read file and return data as a base64 encoded data url.
     * A data url is of the form:
     *      data:[<mediatype>][;base64],<data>
     *
     * @param file          {File} File object containing file properties
     */
    FileReader.prototype.readAsDataURL = function(file) {
        if (initRead(this, file)) {
            return this._realReader.readAsDataURL(file);
        }

        var me = this;
        var execArgs = [this._fileName];

        // Maybe add slice parameters.
        if (file.end < file.size) {
            execArgs.push(file.start, file.end);
        } else if (file.start > 0) {
            execArgs.push(file.start);
        }

        // Read file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // DONE state
                me._readyState = FileReader.DONE;

                // Save result
                me._result = r;

                // If onload callback
                if (typeof me.onload === "function") {
                    me.onload(new ProgressEvent("load", {target:me}));
                }

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // DONE state
                me._readyState = FileReader.DONE;

                me._result = null;

                // Save error
                me._error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {target:me}));
                }

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            }, "File", "readAsDataURL", execArgs);
    };

    /**
     * Read file and return data as a binary data.
     *
     * @param file          {File} File object containing file properties
     */
    FileReader.prototype.readAsBinaryString = function(file) {
        if (initRead(this, file)) {
            return this._realReader.readAsBinaryString(file);
        }
        // TODO - Can't return binary data to browser.
        console.log('method "readAsBinaryString" is not supported at this time.');
        this.abort();
    };

    /**
     * Read file and return data as a binary data.
     *
     * @param file          {File} File object containing file properties
     */
    FileReader.prototype.readAsArrayBuffer = function(file) {
        if (initRead(this, file)) {
            return this._realReader.readAsArrayBuffer(file);
        }
        // TODO - Can't return binary data to browser.
        console.log('This method is not supported at this time.');
        this.abort();
    };

    module.exports = FileReader;

    });

    // file: lib/common/plugin/FileSystem.js
    define("cordova/plugin/FileSystem", function(require, exports, module) {

    var DirectoryEntry = require('cordova/plugin/DirectoryEntry');

    /**
     * An interface representing a file system
     *
     * @constructor
     * {DOMString} name the unique name of the file system (readonly)
     * {DirectoryEntry} root directory of the file system (readonly)
     */
    var FileSystem = function(name, root) {
        this.name = name || null;
        if (root) {
            this.root = new DirectoryEntry(root.name, root.fullPath);
        }
    };

    module.exports = FileSystem;

    });

    // file: lib/common/plugin/FileTransfer.js
    define("cordova/plugin/FileTransfer", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        FileTransferError = require('cordova/plugin/FileTransferError'),
        ProgressEvent = require('cordova/plugin/ProgressEvent');

    function newProgressEvent(result) {
        var pe = new ProgressEvent();
        pe.lengthComputable = result.lengthComputable;
        pe.loaded = result.loaded;
        pe.total = result.total;
        return pe;
    }

    var idCounter = 0;

    /**
     * FileTransfer uploads a file to a remote server.
     * @constructor
     */
    var FileTransfer = function() {
        this._id = ++idCounter;
        this.onprogress = null; // optional callback
    };

    /**
    * Given an absolute file path, uploads a file on the device to a remote server
    * using a multipart HTTP request.
    * @param filePath {String}           Full path of the file on the device
    * @param server {String}             URL of the server to receive the file
    * @param successCallback (Function}  Callback to be invoked when upload has completed
    * @param errorCallback {Function}    Callback to be invoked upon error
    * @param options {FileUploadOptions} Optional parameters such as file name and mimetype
    * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false
    */
    FileTransfer.prototype.upload = function(filePath, server, successCallback, errorCallback, options, trustAllHosts) {
        argscheck.checkArgs('ssFFO*', 'FileTransfer.upload', arguments);
        // check for options
        var fileKey = null;
        var fileName = null;
        var mimeType = null;
        var params = null;
        var chunkedMode = true;
        var headers = null;
        if (options) {
            fileKey = options.fileKey;
            fileName = options.fileName;
            mimeType = options.mimeType;
            headers = options.headers;
            if (options.chunkedMode !== null || typeof options.chunkedMode != "undefined") {
                chunkedMode = options.chunkedMode;
            }
            if (options.params) {
                params = options.params;
            }
            else {
                params = {};
            }
        }

        var fail = errorCallback && function(e) {
            var error = new FileTransferError(e.code, e.source, e.target, e.http_status);
            errorCallback(error);
        };

        var self = this;
        var win = function(result) {
            if (typeof result.lengthComputable != "undefined") {
                if (self.onprogress) {
                    self.onprogress(newProgressEvent(result));
                }
            } else {
                successCallback && successCallback(result);
            }
        };
        exec(win, fail, 'FileTransfer', 'upload', [filePath, server, fileKey, fileName, mimeType, params, trustAllHosts, chunkedMode, headers, this._id]);
    };

    /**
     * Downloads a file form a given URL and saves it to the specified directory.
     * @param source {String}          URL of the server to receive the file
     * @param target {String}         Full path of the file on the device
     * @param successCallback (Function}  Callback to be invoked when upload has completed
     * @param errorCallback {Function}    Callback to be invoked upon error
     * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false
     */
    FileTransfer.prototype.download = function(source, target, successCallback, errorCallback, trustAllHosts) {
        argscheck.checkArgs('ssFF*', 'FileTransfer.download', arguments);
        var self = this;
        var win = function(result) {
            if (typeof result.lengthComputable != "undefined") {
                if (self.onprogress) {
                    return self.onprogress(newProgressEvent(result));
                }
            } else if (successCallback) {
                var entry = null;
                if (result.isDirectory) {
                    entry = new (require('cordova/plugin/DirectoryEntry'))();
                }
                else if (result.isFile) {
                    entry = new (require('cordova/plugin/FileEntry'))();
                }
                entry.isDirectory = result.isDirectory;
                entry.isFile = result.isFile;
                entry.name = result.name;
                entry.fullPath = result.fullPath;
                successCallback(entry);
            }
        };

        var fail = errorCallback && function(e) {
            var error = new FileTransferError(e.code, e.source, e.target, e.http_status);
            errorCallback(error);
        };

        exec(win, fail, 'FileTransfer', 'download', [source, target, trustAllHosts, this._id]);
    };

    /**
     * Aborts the ongoing file transfer on this object
     * @param successCallback {Function}  Callback to be invoked upon success
     * @param errorCallback {Function}    Callback to be invoked upon error
     */
    FileTransfer.prototype.abort = function(successCallback, errorCallback) {
        exec(successCallback, errorCallback, 'FileTransfer', 'abort', [this._id]);
    };

    module.exports = FileTransfer;

    });

    // file: lib/common/plugin/FileTransferError.js
    define("cordova/plugin/FileTransferError", function(require, exports, module) {

    /**
     * FileTransferError
     * @constructor
     */
    var FileTransferError = function(code, source, target, status) {
        this.code = code || null;
        this.source = source || null;
        this.target = target || null;
        this.http_status = status || null;
    };

    FileTransferError.FILE_NOT_FOUND_ERR = 1;
    FileTransferError.INVALID_URL_ERR = 2;
    FileTransferError.CONNECTION_ERR = 3;
    FileTransferError.ABORT_ERR = 4;

    module.exports = FileTransferError;

    });

    // file: lib/common/plugin/FileUploadOptions.js
    define("cordova/plugin/FileUploadOptions", function(require, exports, module) {

    /**
     * Options to customize the HTTP request used to upload files.
     * @constructor
     * @param fileKey {String}   Name of file request parameter.
     * @param fileName {String}  Filename to be used by the server. Defaults to image.jpg.
     * @param mimeType {String}  Mimetype of the uploaded file. Defaults to image/jpeg.
     * @param params {Object}    Object with key: value params to send to the server.
     * @param headers {Object}   Keys are header names, values are header values. Multiple
     *                           headers of the same name are not supported.
     */
    var FileUploadOptions = function(fileKey, fileName, mimeType, params, headers) {
        this.fileKey = fileKey || null;
        this.fileName = fileName || null;
        this.mimeType = mimeType || null;
        this.params = params || null;
        this.headers = headers || null;
    };

    module.exports = FileUploadOptions;

    });

    // file: lib/common/plugin/FileUploadResult.js
    define("cordova/plugin/FileUploadResult", function(require, exports, module) {

    /**
     * FileUploadResult
     * @constructor
     */
    var FileUploadResult = function() {
        this.bytesSent = 0;
        this.responseCode = null;
        this.response = null;
    };

    module.exports = FileUploadResult;

    });

    // file: lib/common/plugin/FileWriter.js
    define("cordova/plugin/FileWriter", function(require, exports, module) {

    var exec = require('cordova/exec'),
        FileError = require('cordova/plugin/FileError'),
        ProgressEvent = require('cordova/plugin/ProgressEvent');

    /**
     * This class writes to the mobile device file system.
     *
     * For Android:
     *      The root directory is the root of the file system.
     *      To write to the SD card, the file name is "sdcard/my_file.txt"
     *
     * @constructor
     * @param file {File} File object containing file properties
     * @param append if true write to the end of the file, otherwise overwrite the file
     */
    var FileWriter = function(file) {
        this.fileName = "";
        this.length = 0;
        if (file) {
            this.fileName = file.fullPath || file;
            this.length = file.size || 0;
        }
        // default is to write at the beginning of the file
        this.position = 0;

        this.readyState = 0; // EMPTY

        this.result = null;

        // Error
        this.error = null;

        // Event handlers
        this.onwritestart = null;   // When writing starts
        this.onprogress = null;     // While writing the file, and reporting partial file data
        this.onwrite = null;        // When the write has successfully completed.
        this.onwriteend = null;     // When the request has completed (either in success or failure).
        this.onabort = null;        // When the write has been aborted. For instance, by invoking the abort() method.
        this.onerror = null;        // When the write has failed (see errors).
    };

    // States
    FileWriter.INIT = 0;
    FileWriter.WRITING = 1;
    FileWriter.DONE = 2;

    /**
     * Abort writing file.
     */
    FileWriter.prototype.abort = function() {
        // check for invalid state
        if (this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        // set error
        this.error = new FileError(FileError.ABORT_ERR);

        this.readyState = FileWriter.DONE;

        // If abort callback
        if (typeof this.onabort === "function") {
            this.onabort(new ProgressEvent("abort", {"target":this}));
        }

        // If write end callback
        if (typeof this.onwriteend === "function") {
            this.onwriteend(new ProgressEvent("writeend", {"target":this}));
        }
    };

    /**
     * Writes data to the file
     *
     * @param text to be written
     */
    FileWriter.prototype.write = function(text) {
        // Throw an exception if we are already writing a file
        if (this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        // WRITING state
        this.readyState = FileWriter.WRITING;

        var me = this;

        // If onwritestart callback
        if (typeof me.onwritestart === "function") {
            me.onwritestart(new ProgressEvent("writestart", {"target":me}));
        }

        // Write file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // position always increases by bytes written because file would be extended
                me.position += r;
                // The length of the file is now where we are done writing.

                me.length = me.position;

                // DONE state
                me.readyState = FileWriter.DONE;

                // If onwrite callback
                if (typeof me.onwrite === "function") {
                    me.onwrite(new ProgressEvent("write", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // DONE state
                me.readyState = FileWriter.DONE;

                // Save error
                me.error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            }, "File", "write", [this.fileName, text, this.position]);
    };

    /**
     * Moves the file pointer to the location specified.
     *
     * If the offset is a negative number the position of the file
     * pointer is rewound.  If the offset is greater than the file
     * size the position is set to the end of the file.
     *
     * @param offset is the location to move the file pointer to.
     */
    FileWriter.prototype.seek = function(offset) {
        // Throw an exception if we are already writing a file
        if (this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        if (!offset && offset !== 0) {
            return;
        }

        // See back from end of file.
        if (offset < 0) {
            this.position = Math.max(offset + this.length, 0);
        }
        // Offset is bigger than file size so set position
        // to the end of the file.
        else if (offset > this.length) {
            this.position = this.length;
        }
        // Offset is between 0 and file size so set the position
        // to start writing.
        else {
            this.position = offset;
        }
    };

    /**
     * Truncates the file to the size specified.
     *
     * @param size to chop the file at.
     */
    FileWriter.prototype.truncate = function(size) {
        // Throw an exception if we are already writing a file
        if (this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        // WRITING state
        this.readyState = FileWriter.WRITING;

        var me = this;

        // If onwritestart callback
        if (typeof me.onwritestart === "function") {
            me.onwritestart(new ProgressEvent("writestart", {"target":this}));
        }

        // Write file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // DONE state
                me.readyState = FileWriter.DONE;

                // Update the length of the file
                me.length = r;
                me.position = Math.min(me.position, r);

                // If onwrite callback
                if (typeof me.onwrite === "function") {
                    me.onwrite(new ProgressEvent("write", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // DONE state
                me.readyState = FileWriter.DONE;

                // Save error
                me.error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            }, "File", "truncate", [this.fileName, size]);
    };

    module.exports = FileWriter;

    });

    // file: lib/common/plugin/Flags.js
    define("cordova/plugin/Flags", function(require, exports, module) {

    /**
     * Supplies arguments to methods that lookup or create files and directories.
     *
     * @param create
     *            {boolean} file or directory if it doesn't exist
     * @param exclusive
     *            {boolean} used with create; if true the command will fail if
     *            target path exists
     */
    function Flags(create, exclusive) {
        this.create = create || false;
        this.exclusive = exclusive || false;
    }

    module.exports = Flags;

    });

    // file: lib/common/plugin/GlobalizationError.js
    define("cordova/plugin/GlobalizationError", function(require, exports, module) {


    /**
     * Globalization error object
     *
     * @constructor
     * @param code
     * @param message
     */
    var GlobalizationError = function(code, message) {
        this.code = code || null;
        this.message = message || '';
    };

    // Globalization error codes
    GlobalizationError.UNKNOWN_ERROR = 0;
    GlobalizationError.FORMATTING_ERROR = 1;
    GlobalizationError.PARSING_ERROR = 2;
    GlobalizationError.PATTERN_ERROR = 3;

    module.exports = GlobalizationError;

    });

    // file: lib/common/plugin/InAppBrowser.js
    define("cordova/plugin/InAppBrowser", function(require, exports, module) {

    var exec = require('cordova/exec');
    var channel = require('cordova/channel');

    function InAppBrowser() {
       this.channels = {
            'loadstart': channel.create('loadstart'),
            'loadstop' : channel.create('loadstop'),
            'exit' : channel.create('exit')
       };
    }

    InAppBrowser.prototype = {
        _eventHandler: function (event) {
            if (event.type in this.channels) {
                this.channels[event.type].fire(event);
            }
        },
        close: function (eventname) {
            exec(null, null, "InAppBrowser", "close", []);
        },
        addEventListener: function (eventname,f) {
            if (eventname in this.channels) {
                this.channels[eventname].subscribe(f);
            }
        },
        removeEventListener: function(eventname, f) {
            if (eventname in this.channels) {
                this.channels[eventname].unsubscribe(f);
            }
        }
    };

    module.exports = function(strUrl, strWindowName, strWindowFeatures) {
        var iab = new InAppBrowser();
        var cb = function(eventname) {
           iab._eventHandler(eventname);
        };
        exec(cb, null, "InAppBrowser", "open", [strUrl, strWindowName, strWindowFeatures]);
        return iab;
    };

    //Export the original open so it can be used if needed
    module.exports._orig = window.open;

    });

    // file: lib/common/plugin/LocalFileSystem.js
    define("cordova/plugin/LocalFileSystem", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Represents a local file system.
     */
    var LocalFileSystem = function() {

    };

    LocalFileSystem.TEMPORARY = 0; //temporary, with no guarantee of persistence
    LocalFileSystem.PERSISTENT = 1; //persistent

    module.exports = LocalFileSystem;

    });

    // file: lib/common/plugin/Media.js
    define("cordova/plugin/Media", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec');

    var mediaObjects = {};

    /**
     * This class provides access to the device media, interfaces to both sound and video
     *
     * @constructor
     * @param src                   The file name or url to play
     * @param successCallback       The callback to be called when the file is done playing or recording.
     *                                  successCallback()
     * @param errorCallback         The callback to be called if there is an error.
     *                                  errorCallback(int errorCode) - OPTIONAL
     * @param statusCallback        The callback to be called when media status has changed.
     *                                  statusCallback(int statusCode) - OPTIONAL
     */
    var Media = function(src, successCallback, errorCallback, statusCallback) {
        argscheck.checkArgs('SFFF', 'Media', arguments);
        this.id = utils.createUUID();
        mediaObjects[this.id] = this;
        this.src = src;
        this.successCallback = successCallback;
        this.errorCallback = errorCallback;
        this.statusCallback = statusCallback;
        this._duration = -1;
        this._position = -1;
        exec(null, this.errorCallback, "Media", "create", [this.id, this.src]);
    };

    // Media messages
    Media.MEDIA_STATE = 1;
    Media.MEDIA_DURATION = 2;
    Media.MEDIA_POSITION = 3;
    Media.MEDIA_ERROR = 9;

    // Media states
    Media.MEDIA_NONE = 0;
    Media.MEDIA_STARTING = 1;
    Media.MEDIA_RUNNING = 2;
    Media.MEDIA_PAUSED = 3;
    Media.MEDIA_STOPPED = 4;
    Media.MEDIA_MSG = ["None", "Starting", "Running", "Paused", "Stopped"];

    // "static" function to return existing objs.
    Media.get = function(id) {
        return mediaObjects[id];
    };

    /**
     * Start or resume playing audio file.
     */
    Media.prototype.play = function(options) {
        exec(null, null, "Media", "startPlayingAudio", [this.id, this.src, options]);
    };

    /**
     * Stop playing audio file.
     */
    Media.prototype.stop = function() {
        var me = this;
        exec(function() {
            me._position = 0;
        }, this.errorCallback, "Media", "stopPlayingAudio", [this.id]);
    };

    /**
     * Seek or jump to a new time in the track..
     */
    Media.prototype.seekTo = function(milliseconds) {
        var me = this;
        exec(function(p) {
            me._position = p;
        }, this.errorCallback, "Media", "seekToAudio", [this.id, milliseconds]);
    };

    /**
     * Pause playing audio file.
     */
    Media.prototype.pause = function() {
        exec(null, this.errorCallback, "Media", "pausePlayingAudio", [this.id]);
    };

    /**
     * Get duration of an audio file.
     * The duration is only set for audio that is playing, paused or stopped.
     *
     * @return      duration or -1 if not known.
     */
    Media.prototype.getDuration = function() {
        return this._duration;
    };

    /**
     * Get position of audio.
     */
    Media.prototype.getCurrentPosition = function(success, fail) {
        var me = this;
        exec(function(p) {
            me._position = p;
            success(p);
        }, fail, "Media", "getCurrentPositionAudio", [this.id]);
    };

    /**
     * Start recording audio file.
     */
    Media.prototype.startRecord = function() {
        exec(null, this.errorCallback, "Media", "startRecordingAudio", [this.id, this.src]);
    };

    /**
     * Stop recording audio file.
     */
    Media.prototype.stopRecord = function() {
        exec(null, this.errorCallback, "Media", "stopRecordingAudio", [this.id]);
    };

    /**
     * Release the resources.
     */
    Media.prototype.release = function() {
        exec(null, this.errorCallback, "Media", "release", [this.id]);
    };

    /**
     * Adjust the volume.
     */
    Media.prototype.setVolume = function(volume) {
        exec(null, null, "Media", "setVolume", [this.id, volume]);
    };

    /**
     * Audio has status update.
     * PRIVATE
     *
     * @param id            The media object id (string)
     * @param msgType       The 'type' of update this is
     * @param value         Use of value is determined by the msgType
     */
    Media.onStatus = function(id, msgType, value) {

        var media = mediaObjects[id];

        if(media) {
            switch(msgType) {
                case Media.MEDIA_STATE :
                    media.statusCallback && media.statusCallback(value);
                    if(value == Media.MEDIA_STOPPED) {
                        media.successCallback && media.successCallback();
                    }
                    break;
                case Media.MEDIA_DURATION :
                    media._duration = value;
                    break;
                case Media.MEDIA_ERROR :
                    media.errorCallback && media.errorCallback(value);
                    break;
                case Media.MEDIA_POSITION :
                    media._position = Number(value);
                    break;
                default :
                    console.error && console.error("Unhandled Media.onStatus :: " + msgType);
                    break;
            }
        }
        else {
             console.error && console.error("Received Media.onStatus callback for unknown media :: " + id);
        }

    };

    module.exports = Media;

    });

    // file: lib/common/plugin/MediaError.js
    define("cordova/plugin/MediaError", function(require, exports, module) {

    /**
     * This class contains information about any Media errors.
    */
    /*
     According to :: http://dev.w3.org/html5/spec-author-view/video.html#mediaerror
     We should never be creating these objects, we should just implement the interface
     which has 1 property for an instance, 'code'

     instead of doing :
        errorCallbackFunction( new MediaError(3,'msg') );
    we should simply use a literal :
        errorCallbackFunction( {'code':3} );
     */

     var _MediaError = window.MediaError;


    if(!_MediaError) {
        window.MediaError = _MediaError = function(code, msg) {
            this.code = (typeof code != 'undefined') ? code : null;
            this.message = msg || ""; // message is NON-standard! do not use!
        };
    }

    _MediaError.MEDIA_ERR_NONE_ACTIVE    = _MediaError.MEDIA_ERR_NONE_ACTIVE    || 0;
    _MediaError.MEDIA_ERR_ABORTED        = _MediaError.MEDIA_ERR_ABORTED        || 1;
    _MediaError.MEDIA_ERR_NETWORK        = _MediaError.MEDIA_ERR_NETWORK        || 2;
    _MediaError.MEDIA_ERR_DECODE         = _MediaError.MEDIA_ERR_DECODE         || 3;
    _MediaError.MEDIA_ERR_NONE_SUPPORTED = _MediaError.MEDIA_ERR_NONE_SUPPORTED || 4;
    // TODO: MediaError.MEDIA_ERR_NONE_SUPPORTED is legacy, the W3 spec now defines it as below.
    // as defined by http://dev.w3.org/html5/spec-author-view/video.html#error-codes
    _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 4;

    module.exports = _MediaError;

    });

    // file: lib/common/plugin/MediaFile.js
    define("cordova/plugin/MediaFile", function(require, exports, module) {

    var utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        File = require('cordova/plugin/File'),
        CaptureError = require('cordova/plugin/CaptureError');
    /**
     * Represents a single file.
     *
     * name {DOMString} name of the file, without path information
     * fullPath {DOMString} the full path of the file, including the name
     * type {DOMString} mime type
     * lastModifiedDate {Date} last modified date
     * size {Number} size of the file in bytes
     */
    var MediaFile = function(name, fullPath, type, lastModifiedDate, size){
        MediaFile.__super__.constructor.apply(this, arguments);
    };

    utils.extend(MediaFile, File);

    /**
     * Request capture format data for a specific file and type
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     */
    MediaFile.prototype.getFormatData = function(successCallback, errorCallback) {
        if (typeof this.fullPath === "undefined" || this.fullPath === null) {
            errorCallback(new CaptureError(CaptureError.CAPTURE_INVALID_ARGUMENT));
        } else {
            exec(successCallback, errorCallback, "Capture", "getFormatData", [this.fullPath, this.type]);
        }
    };

    module.exports = MediaFile;

    });

    // file: lib/common/plugin/MediaFileData.js
    define("cordova/plugin/MediaFileData", function(require, exports, module) {

    /**
     * MediaFileData encapsulates format information of a media file.
     *
     * @param {DOMString} codecs
     * @param {long} bitrate
     * @param {long} height
     * @param {long} width
     * @param {float} duration
     */
    var MediaFileData = function(codecs, bitrate, height, width, duration){
        this.codecs = codecs || null;
        this.bitrate = bitrate || 0;
        this.height = height || 0;
        this.width = width || 0;
        this.duration = duration || 0;
    };

    module.exports = MediaFileData;

    });

    // file: lib/common/plugin/Metadata.js
    define("cordova/plugin/Metadata", function(require, exports, module) {

    /**
     * Information about the state of the file or directory
     *
     * {Date} modificationTime (readonly)
     */
    var Metadata = function(time) {
        this.modificationTime = (typeof time != 'undefined'?new Date(time):null);
    };

    module.exports = Metadata;

    });

    // file: lib/common/plugin/Position.js
    define("cordova/plugin/Position", function(require, exports, module) {

    var Coordinates = require('cordova/plugin/Coordinates');

    var Position = function(coords, timestamp) {
        if (coords) {
            this.coords = new Coordinates(coords.latitude, coords.longitude, coords.altitude, coords.accuracy, coords.heading, coords.velocity, coords.altitudeAccuracy);
        } else {
            this.coords = new Coordinates();
        }
        this.timestamp = (timestamp !== undefined) ? timestamp : new Date();
    };

    module.exports = Position;

    });

    // file: lib/common/plugin/PositionError.js
    define("cordova/plugin/PositionError", function(require, exports, module) {

    /**
     * Position error object
     *
     * @constructor
     * @param code
     * @param message
     */
    var PositionError = function(code, message) {
        this.code = code || null;
        this.message = message || '';
    };

    PositionError.PERMISSION_DENIED = 1;
    PositionError.POSITION_UNAVAILABLE = 2;
    PositionError.TIMEOUT = 3;

    module.exports = PositionError;

    });

    // file: lib/common/plugin/ProgressEvent.js
    define("cordova/plugin/ProgressEvent", function(require, exports, module) {

    // If ProgressEvent exists in global context, use it already, otherwise use our own polyfill
    // Feature test: See if we can instantiate a native ProgressEvent;
    // if so, use that approach,
    // otherwise fill-in with our own implementation.
    //
    // NOTE: right now we always fill in with our own. Down the road would be nice if we can use whatever is native in the webview.
    var ProgressEvent = (function() {
        /*
        var createEvent = function(data) {
            var event = document.createEvent('Events');
            event.initEvent('ProgressEvent', false, false);
            if (data) {
                for (var i in data) {
                    if (data.hasOwnProperty(i)) {
                        event[i] = data[i];
                    }
                }
                if (data.target) {
                    // TODO: cannot call <some_custom_object>.dispatchEvent
                    // need to first figure out how to implement EventTarget
                }
            }
            return event;
        };
        try {
            var ev = createEvent({type:"abort",target:document});
            return function ProgressEvent(type, data) {
                data.type = type;
                return createEvent(data);
            };
        } catch(e){
        */
            return function ProgressEvent(type, dict) {
                this.type = type;
                this.bubbles = false;
                this.cancelBubble = false;
                this.cancelable = false;
                this.lengthComputable = false;
                this.loaded = dict && dict.loaded ? dict.loaded : 0;
                this.total = dict && dict.total ? dict.total : 0;
                this.target = dict && dict.target ? dict.target : null;
            };
        //}
    })();

    module.exports = ProgressEvent;

    });

    // file: lib/common/plugin/accelerometer.js
    define("cordova/plugin/accelerometer", function(require, exports, module) {

    /**
     * This class provides access to device accelerometer data.
     * @constructor
     */
    var argscheck = require('cordova/argscheck'),
        utils = require("cordova/utils"),
        exec = require("cordova/exec"),
        Acceleration = require('cordova/plugin/Acceleration');

    // Is the accel sensor running?
    var running = false;

    // Keeps reference to watchAcceleration calls.
    var timers = {};

    // Array of listeners; used to keep track of when we should call start and stop.
    var listeners = [];

    // Last returned acceleration object from native
    var accel = null;

    // Tells native to start.
    function start() {
        exec(function(a) {
            var tempListeners = listeners.slice(0);
            accel = new Acceleration(a.x, a.y, a.z, a.timestamp);
            for (var i = 0, l = tempListeners.length; i < l; i++) {
                tempListeners[i].win(accel);
            }
        }, function(e) {
            var tempListeners = listeners.slice(0);
            for (var i = 0, l = tempListeners.length; i < l; i++) {
                tempListeners[i].fail(e);
            }
        }, "Accelerometer", "start", []);
        running = true;
    }

    // Tells native to stop.
    function stop() {
        exec(null, null, "Accelerometer", "stop", []);
        running = false;
    }

    // Adds a callback pair to the listeners array
    function createCallbackPair(win, fail) {
        return {win:win, fail:fail};
    }

    // Removes a win/fail listener pair from the listeners array
    function removeListeners(l) {
        var idx = listeners.indexOf(l);
        if (idx > -1) {
            listeners.splice(idx, 1);
            if (listeners.length === 0) {
                stop();
            }
        }
    }

    var accelerometer = {
        /**
         * Asynchronously acquires the current acceleration.
         *
         * @param {Function} successCallback    The function to call when the acceleration data is available
         * @param {Function} errorCallback      The function to call when there is an error getting the acceleration data. (OPTIONAL)
         * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL)
         */
        getCurrentAcceleration: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'accelerometer.getCurrentAcceleration', arguments);

            var p;
            var win = function(a) {
                removeListeners(p);
                successCallback(a);
            };
            var fail = function(e) {
                removeListeners(p);
                errorCallback && errorCallback(e);
            };

            p = createCallbackPair(win, fail);
            listeners.push(p);

            if (!running) {
                start();
            }
        },

        /**
         * Asynchronously acquires the acceleration repeatedly at a given interval.
         *
         * @param {Function} successCallback    The function to call each time the acceleration data is available
         * @param {Function} errorCallback      The function to call when there is an error getting the acceleration data. (OPTIONAL)
         * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL)
         * @return String                       The watch id that must be passed to #clearWatch to stop watching.
         */
        watchAcceleration: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'accelerometer.watchAcceleration', arguments);
            // Default interval (10 sec)
            var frequency = (options && options.frequency && typeof options.frequency == 'number') ? options.frequency : 10000;

            // Keep reference to watch id, and report accel readings as often as defined in frequency
            var id = utils.createUUID();

            var p = createCallbackPair(function(){}, function(e) {
                removeListeners(p);
                errorCallback && errorCallback(e);
            });
            listeners.push(p);

            timers[id] = {
                timer:window.setInterval(function() {
                    if (accel) {
                        successCallback(accel);
                    }
                }, frequency),
                listeners:p
            };

            if (running) {
                // If we're already running then immediately invoke the success callback
                // but only if we have retrieved a value, sample code does not check for null ...
                if (accel) {
                    successCallback(accel);
                }
            } else {
                start();
            }

            return id;
        },

        /**
         * Clears the specified accelerometer watch.
         *
         * @param {String} id       The id of the watch returned from #watchAcceleration.
         */
        clearWatch: function(id) {
            // Stop javascript timer & remove from timer list
            if (id && timers[id]) {
                window.clearInterval(timers[id].timer);
                removeListeners(timers[id].listeners);
                delete timers[id];
            }
        }
    };

    module.exports = accelerometer;

    });

    // file: lib/android/plugin/android/app.js
    define("cordova/plugin/android/app", function(require, exports, module) {

    var exec = require('cordova/exec');

    module.exports = {
      /**
       * Clear the resource cache.
       */
      clearCache:function() {
        exec(null, null, "App", "clearCache", []);
      },

      /**
       * Load the url into the webview or into new browser instance.
       *
       * @param url           The URL to load
       * @param props         Properties that can be passed in to the activity:
       *      wait: int                           => wait msec before loading URL
       *      loadingDialog: "Title,Message"      => display a native loading dialog
       *      loadUrlTimeoutValue: int            => time in msec to wait before triggering a timeout error
       *      clearHistory: boolean              => clear webview history (default=false)
       *      openExternal: boolean              => open in a new browser (default=false)
       *
       * Example:
       *      navigator.app.loadUrl("http://server/myapp/index.html", {wait:2000, loadingDialog:"Wait,Loading App", loadUrlTimeoutValue: 60000});
       */
      loadUrl:function(url, props) {
        exec(null, null, "App", "loadUrl", [url, props]);
      },

      /**
       * Cancel loadUrl that is waiting to be loaded.
       */
      cancelLoadUrl:function() {
        exec(null, null, "App", "cancelLoadUrl", []);
      },

      /**
       * Clear web history in this web view.
       * Instead of BACK button loading the previous web page, it will exit the app.
       */
      clearHistory:function() {
        exec(null, null, "App", "clearHistory", []);
      },

      /**
       * Go to previous page displayed.
       * This is the same as pressing the backbutton on Android device.
       */
      backHistory:function() {
        exec(null, null, "App", "backHistory", []);
      },

      /**
       * Override the default behavior of the Android back button.
       * If overridden, when the back button is pressed, the "backKeyDown" JavaScript event will be fired.
       *
       * Note: The user should not have to call this method.  Instead, when the user
       *       registers for the "backbutton" event, this is automatically done.
       *
       * @param override        T=override, F=cancel override
       */
      overrideBackbutton:function(override) {
        exec(null, null, "App", "overrideBackbutton", [override]);
      },

      /**
       * Exit and terminate the application.
       */
      exitApp:function() {
        return exec(null, null, "App", "exitApp", []);
      }
    };

    });

    // file: lib/android/plugin/android/device.js
    define("cordova/plugin/android/device", function(require, exports, module) {

    var channel = require('cordova/channel'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        app = require('cordova/plugin/android/app');

    module.exports = {
        /*
         * DEPRECATED
         * This is only for Android.
         *
         * You must explicitly override the back button.
         */
        overrideBackButton:function() {
            console.log("Device.overrideBackButton() is deprecated.  Use App.overrideBackbutton(true).");
            app.overrideBackbutton(true);
        },

        /*
         * DEPRECATED
         * This is only for Android.
         *
         * This resets the back button to the default behavior
         */
        resetBackButton:function() {
            console.log("Device.resetBackButton() is deprecated.  Use App.overrideBackbutton(false).");
            app.overrideBackbutton(false);
        },

        /*
         * DEPRECATED
         * This is only for Android.
         *
         * This terminates the activity!
         */
        exitApp:function() {
            console.log("Device.exitApp() is deprecated.  Use App.exitApp().");
            app.exitApp();
        }
    };

    });

    // file: lib/android/plugin/android/nativeapiprovider.js
    define("cordova/plugin/android/nativeapiprovider", function(require, exports, module) {

    var nativeApi = this._cordovaNative || require('cordova/plugin/android/promptbasednativeapi');
    var currentApi = nativeApi;

    module.exports = {
        get: function() { return currentApi; },
        setPreferPrompt: function(value) {
            currentApi = value ? require('cordova/plugin/android/promptbasednativeapi') : nativeApi;
        },
        // Used only by tests.
        set: function(value) {
            currentApi = value;
        }
    };

    });

    // file: lib/android/plugin/android/notification.js
    define("cordova/plugin/android/notification", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Provides Android enhanced notification API.
     */
    module.exports = {
        activityStart : function(title, message) {
            // If title and message not specified then mimic Android behavior of
            // using default strings.
            if (typeof title === "undefined" && typeof message == "undefined") {
                title = "Busy";
                message = 'Please wait...';
            }

            exec(null, null, 'Notification', 'activityStart', [ title, message ]);
        },

        /**
         * Close an activity dialog
         */
        activityStop : function() {
            exec(null, null, 'Notification', 'activityStop', []);
        },

        /**
         * Display a progress dialog with progress bar that goes from 0 to 100.
         *
         * @param {String}
         *            title Title of the progress dialog.
         * @param {String}
         *            message Message to display in the dialog.
         */
        progressStart : function(title, message) {
            exec(null, null, 'Notification', 'progressStart', [ title, message ]);
        },

        /**
         * Close the progress dialog.
         */
        progressStop : function() {
            exec(null, null, 'Notification', 'progressStop', []);
        },

        /**
         * Set the progress dialog value.
         *
         * @param {Number}
         *            value 0-100
         */
        progressValue : function(value) {
            exec(null, null, 'Notification', 'progressValue', [ value ]);
        }
    };

    });

    // file: lib/android/plugin/android/promptbasednativeapi.js
    define("cordova/plugin/android/promptbasednativeapi", function(require, exports, module) {

    module.exports = {
        exec: function(service, action, callbackId, argsJson) {
            return prompt(argsJson, 'gap:'+JSON.stringify([service, action, callbackId]));
        },
        setNativeToJsBridgeMode: function(value) {
            prompt(value, 'gap_bridge_mode:');
        },
        retrieveJsMessages: function() {
            return prompt('', 'gap_poll:');
        }
    };

    });

    // file: lib/android/plugin/android/storage.js
    define("cordova/plugin/android/storage", function(require, exports, module) {

    var utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        channel = require('cordova/channel');

    var queryQueue = {};

    /**
     * SQL result set object
     * PRIVATE METHOD
     * @constructor
     */
    var DroidDB_Rows = function() {
        this.resultSet = [];    // results array
        this.length = 0;        // number of rows
    };

    /**
     * Get item from SQL result set
     *
     * @param row           The row number to return
     * @return              The row object
     */
    DroidDB_Rows.prototype.item = function(row) {
        return this.resultSet[row];
    };

    /**
     * SQL result set that is returned to user.
     * PRIVATE METHOD
     * @constructor
     */
    var DroidDB_Result = function() {
        this.rows = new DroidDB_Rows();
    };

    /**
     * Callback from native code when query is complete.
     * PRIVATE METHOD
     *
     * @param id   Query id
     */
    function completeQuery(id, data) {
        var query = queryQueue[id];
        if (query) {
            try {
                delete queryQueue[id];

                // Get transaction
                var tx = query.tx;

                // If transaction hasn't failed
                // Note: We ignore all query results if previous query
                //       in the same transaction failed.
                if (tx && tx.queryList[id]) {

                    // Save query results
                    var r = new DroidDB_Result();
                    r.rows.resultSet = data;
                    r.rows.length = data.length;
                    try {
                        if (typeof query.successCallback === 'function') {
                            query.successCallback(query.tx, r);
                        }
                    } catch (ex) {
                        console.log("executeSql error calling user success callback: "+ex);
                    }

                    tx.queryComplete(id);
                }
            } catch (e) {
                console.log("executeSql error: "+e);
            }
        }
    }

    /**
     * Callback from native code when query fails
     * PRIVATE METHOD
     *
     * @param reason            Error message
     * @param id                Query id
     */
    function failQuery(reason, id) {
        var query = queryQueue[id];
        if (query) {
            try {
                delete queryQueue[id];

                // Get transaction
                var tx = query.tx;

                // If transaction hasn't failed
                // Note: We ignore all query results if previous query
                //       in the same transaction failed.
                if (tx && tx.queryList[id]) {
                    tx.queryList = {};

                    try {
                        if (typeof query.errorCallback === 'function') {
                            query.errorCallback(query.tx, reason);
                        }
                    } catch (ex) {
                        console.log("executeSql error calling user error callback: "+ex);
                    }

                    tx.queryFailed(id, reason);
                }

            } catch (e) {
                console.log("executeSql error: "+e);
            }
        }
    }

    /**
     * SQL query object
     * PRIVATE METHOD
     *
     * @constructor
     * @param tx                The transaction object that this query belongs to
     */
    var DroidDB_Query = function(tx) {

        // Set the id of the query
        this.id = utils.createUUID();

        // Add this query to the queue
        queryQueue[this.id] = this;

        // Init result
        this.resultSet = [];

        // Set transaction that this query belongs to
        this.tx = tx;

        // Add this query to transaction list
        this.tx.queryList[this.id] = this;

        // Callbacks
        this.successCallback = null;
        this.errorCallback = null;

    };

    /**
     * Transaction object
     * PRIVATE METHOD
     * @constructor
     */
    var DroidDB_Tx = function() {

        // Set the id of the transaction
        this.id = utils.createUUID();

        // Callbacks
        this.successCallback = null;
        this.errorCallback = null;

        // Query list
        this.queryList = {};
    };

    /**
     * Mark query in transaction as complete.
     * If all queries are complete, call the user's transaction success callback.
     *
     * @param id                Query id
     */
    DroidDB_Tx.prototype.queryComplete = function(id) {
        delete this.queryList[id];

        // If no more outstanding queries, then fire transaction success
        if (this.successCallback) {
            var count = 0;
            var i;
            for (i in this.queryList) {
                if (this.queryList.hasOwnProperty(i)) {
                    count++;
                }
            }
            if (count === 0) {
                try {
                    this.successCallback();
                } catch(e) {
                    console.log("Transaction error calling user success callback: " + e);
                }
            }
        }
    };

    /**
     * Mark query in transaction as failed.
     *
     * @param id                Query id
     * @param reason            Error message
     */
    DroidDB_Tx.prototype.queryFailed = function(id, reason) {

        // The sql queries in this transaction have already been run, since
        // we really don't have a real transaction implemented in native code.
        // However, the user callbacks for the remaining sql queries in transaction
        // will not be called.
        this.queryList = {};

        if (this.errorCallback) {
            try {
                this.errorCallback(reason);
            } catch(e) {
                console.log("Transaction error calling user error callback: " + e);
            }
        }
    };

    /**
     * Execute SQL statement
     *
     * @param sql                   SQL statement to execute
     * @param params                Statement parameters
     * @param successCallback       Success callback
     * @param errorCallback         Error callback
     */
    DroidDB_Tx.prototype.executeSql = function(sql, params, successCallback, errorCallback) {

        // Init params array
        if (typeof params === 'undefined') {
            params = [];
        }

        // Create query and add to queue
        var query = new DroidDB_Query(this);
        queryQueue[query.id] = query;

        // Save callbacks
        query.successCallback = successCallback;
        query.errorCallback = errorCallback;

        // Call native code
        exec(null, null, "Storage", "executeSql", [sql, params, query.id]);
    };

    var DatabaseShell = function() {
    };

    /**
     * Start a transaction.
     * Does not support rollback in event of failure.
     *
     * @param process {Function}            The transaction function
     * @param successCallback {Function}
     * @param errorCallback {Function}
     */
    DatabaseShell.prototype.transaction = function(process, errorCallback, successCallback) {
        var tx = new DroidDB_Tx();
        tx.successCallback = successCallback;
        tx.errorCallback = errorCallback;
        try {
            process(tx);
        } catch (e) {
            console.log("Transaction error: "+e);
            if (tx.errorCallback) {
                try {
                    tx.errorCallback(e);
                } catch (ex) {
                    console.log("Transaction error calling user error callback: "+e);
                }
            }
        }
    };

    /**
     * Open database
     *
     * @param name              Database name
     * @param version           Database version
     * @param display_name      Database display name
     * @param size              Database size in bytes
     * @return                  Database object
     */
    var DroidDB_openDatabase = function(name, version, display_name, size) {
        exec(null, null, "Storage", "openDatabase", [name, version, display_name, size]);
        var db = new DatabaseShell();
        return db;
    };

    /**
     * For browsers with no localStorage we emulate it with SQLite. Follows the w3c api.
     * TODO: Do similar for sessionStorage.
     * @constructor
     */
    var CupcakeLocalStorage = function() {
        channel.waitForInitialization("cupcakeStorage");

        try {

          this.db = openDatabase('localStorage', '1.0', 'localStorage', 2621440);
          var storage = {};
          this.length = 0;
          function setLength (length) {
            this.length = length;
            localStorage.length = length;
          }
          this.db.transaction(
            function (transaction) {
                var i;
              transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
              transaction.executeSql('SELECT * FROM storage', [], function(tx, result) {
                for(var i = 0; i < result.rows.length; i++) {
                  storage[result.rows.item(i).id] =  result.rows.item(i).body;
                }
                setLength(result.rows.length);
                channel.initializationComplete("cupcakeStorage");
              });

            },
            function (err) {
              utils.alert(err.message);
            }
          );
          this.setItem = function(key, val) {
            if (typeof(storage[key])=='undefined') {
              this.length++;
            }
            storage[key] = val;
            this.db.transaction(
              function (transaction) {
                transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                transaction.executeSql('REPLACE INTO storage (id, body) values(?,?)', [key,val]);
              }
            );
          };
          this.getItem = function(key) {
            return storage[key];
          };
          this.removeItem = function(key) {
            delete storage[key];
            this.length--;
            this.db.transaction(
              function (transaction) {
                transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                transaction.executeSql('DELETE FROM storage where id=?', [key]);
              }
            );
          };
          this.clear = function() {
            storage = {};
            this.length = 0;
            this.db.transaction(
              function (transaction) {
                transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                transaction.executeSql('DELETE FROM storage', []);
              }
            );
          };
          this.key = function(index) {
            var i = 0;
            for (var j in storage) {
              if (i==index) {
                return j;
              } else {
                i++;
              }
            }
            return null;
          };

        } catch(e) {
              utils.alert("Database error "+e+".");
            return;
        }
    };

    module.exports = {
      openDatabase:DroidDB_openDatabase,
      CupcakeLocalStorage:CupcakeLocalStorage,
      failQuery:failQuery,
      completeQuery:completeQuery
    };

    });

    // file: lib/common/plugin/battery.js
    define("cordova/plugin/battery", function(require, exports, module) {

    /**
     * This class contains information about the current battery status.
     * @constructor
     */
    var cordova = require('cordova'),
        exec = require('cordova/exec');

    function handlers() {
      return battery.channels.batterystatus.numHandlers +
             battery.channels.batterylow.numHandlers +
             battery.channels.batterycritical.numHandlers;
    }

    var Battery = function() {
        this._level = null;
        this._isPlugged = null;
        // Create new event handlers on the window (returns a channel instance)
        this.channels = {
          batterystatus:cordova.addWindowEventHandler("batterystatus"),
          batterylow:cordova.addWindowEventHandler("batterylow"),
          batterycritical:cordova.addWindowEventHandler("batterycritical")
        };
        for (var key in this.channels) {
            this.channels[key].onHasSubscribersChange = Battery.onHasSubscribersChange;
        }
    };
    /**
     * Event handlers for when callbacks get registered for the battery.
     * Keep track of how many handlers we have so we can start and stop the native battery listener
     * appropriately (and hopefully save on battery life!).
     */
    Battery.onHasSubscribersChange = function() {
      // If we just registered the first handler, make sure native listener is started.
      if (this.numHandlers === 1 && handlers() === 1) {
          exec(battery._status, battery._error, "Battery", "start", []);
      } else if (handlers() === 0) {
          exec(null, null, "Battery", "stop", []);
      }
    };

    /**
     * Callback for battery status
     *
     * @param {Object} info            keys: level, isPlugged
     */
    Battery.prototype._status = function(info) {
        if (info) {
            var me = battery;
        var level = info.level;
            if (me._level !== level || me._isPlugged !== info.isPlugged) {
                // Fire batterystatus event
                cordova.fireWindowEvent("batterystatus", info);

                // Fire low battery event
                if (level === 20 || level === 5) {
                    if (level === 20) {
                        cordova.fireWindowEvent("batterylow", info);
                    }
                    else {
                        cordova.fireWindowEvent("batterycritical", info);
                    }
                }
            }
            me._level = level;
            me._isPlugged = info.isPlugged;
        }
    };

    /**
     * Error callback for battery start
     */
    Battery.prototype._error = function(e) {
        console.log("Error initializing Battery: " + e);
    };

    var battery = new Battery();

    module.exports = battery;

    });

    // file: lib/common/plugin/capture.js
    define("cordova/plugin/capture", function(require, exports, module) {

    var exec = require('cordova/exec'),
        MediaFile = require('cordova/plugin/MediaFile');

    /**
     * Launches a capture of different types.
     *
     * @param (DOMString} type
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureVideoOptions} options
     */
    function _capture(type, successCallback, errorCallback, options) {
        var win = function(pluginResult) {
            var mediaFiles = [];
            var i;
            for (i = 0; i < pluginResult.length; i++) {
                var mediaFile = new MediaFile();
                mediaFile.name = pluginResult[i].name;
                mediaFile.fullPath = pluginResult[i].fullPath;
                mediaFile.type = pluginResult[i].type;
                mediaFile.lastModifiedDate = pluginResult[i].lastModifiedDate;
                mediaFile.size = pluginResult[i].size;
                mediaFiles.push(mediaFile);
            }
            successCallback(mediaFiles);
        };
        exec(win, errorCallback, "Capture", type, [options]);
    }
    /**
     * The Capture interface exposes an interface to the camera and microphone of the hosting device.
     */
    function Capture() {
        this.supportedAudioModes = [];
        this.supportedImageModes = [];
        this.supportedVideoModes = [];
    }

    /**
     * Launch audio recorder application for recording audio clip(s).
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureAudioOptions} options
     */
    Capture.prototype.captureAudio = function(successCallback, errorCallback, options){
        _capture("captureAudio", successCallback, errorCallback, options);
    };

    /**
     * Launch camera application for taking image(s).
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureImageOptions} options
     */
    Capture.prototype.captureImage = function(successCallback, errorCallback, options){
        _capture("captureImage", successCallback, errorCallback, options);
    };

    /**
     * Launch device camera application for recording video(s).
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureVideoOptions} options
     */
    Capture.prototype.captureVideo = function(successCallback, errorCallback, options){
        _capture("captureVideo", successCallback, errorCallback, options);
    };


    module.exports = new Capture();

    });

    // file: lib/common/plugin/compass.js
    define("cordova/plugin/compass", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        utils = require('cordova/utils'),
        CompassHeading = require('cordova/plugin/CompassHeading'),
        CompassError = require('cordova/plugin/CompassError'),
        timers = {},
        compass = {
            /**
             * Asynchronously acquires the current heading.
             * @param {Function} successCallback The function to call when the heading
             * data is available
             * @param {Function} errorCallback The function to call when there is an error
             * getting the heading data.
             * @param {CompassOptions} options The options for getting the heading data (not used).
             */
            getCurrentHeading:function(successCallback, errorCallback, options) {
                argscheck.checkArgs('fFO', 'compass.getCurrentHeading', arguments);

                var win = function(result) {
                    var ch = new CompassHeading(result.magneticHeading, result.trueHeading, result.headingAccuracy, result.timestamp);
                    successCallback(ch);
                };
                var fail = errorCallback && function(code) {
                    var ce = new CompassError(code);
                    errorCallback(ce);
                };

                // Get heading
                exec(win, fail, "Compass", "getHeading", [options]);
            },

            /**
             * Asynchronously acquires the heading repeatedly at a given interval.
             * @param {Function} successCallback The function to call each time the heading
             * data is available
             * @param {Function} errorCallback The function to call when there is an error
             * getting the heading data.
             * @param {HeadingOptions} options The options for getting the heading data
             * such as timeout and the frequency of the watch. For iOS, filter parameter
             * specifies to watch via a distance filter rather than time.
             */
            watchHeading:function(successCallback, errorCallback, options) {
                argscheck.checkArgs('fFO', 'compass.watchHeading', arguments);
                // Default interval (100 msec)
                var frequency = (options !== undefined && options.frequency !== undefined) ? options.frequency : 100;
                var filter = (options !== undefined && options.filter !== undefined) ? options.filter : 0;

                var id = utils.createUUID();
                if (filter > 0) {
                    // is an iOS request for watch by filter, no timer needed
                    timers[id] = "iOS";
                    compass.getCurrentHeading(successCallback, errorCallback, options);
                } else {
                    // Start watch timer to get headings
                    timers[id] = window.setInterval(function() {
                        compass.getCurrentHeading(successCallback, errorCallback);
                    }, frequency);
                }

                return id;
            },

            /**
             * Clears the specified heading watch.
             * @param {String} watchId The ID of the watch returned from #watchHeading.
             */
            clearWatch:function(id) {
                // Stop javascript timer & remove from timer list
                if (id && timers[id]) {
                    if (timers[id] != "iOS") {
                        clearInterval(timers[id]);
                    } else {
                        // is iOS watch by filter so call into device to stop
                        exec(null, null, "Compass", "stopHeading", []);
                    }
                    delete timers[id];
                }
            }
        };

    module.exports = compass;

    });

    // file: lib/common/plugin/console-via-logger.js
    define("cordova/plugin/console-via-logger", function(require, exports, module) {

    //------------------------------------------------------------------------------

    var logger = require("cordova/plugin/logger");
    var utils  = require("cordova/utils");

    //------------------------------------------------------------------------------
    // object that we're exporting
    //------------------------------------------------------------------------------
    var console = module.exports;

    //------------------------------------------------------------------------------
    // copy of the original console object
    //------------------------------------------------------------------------------
    var WinConsole = window.console;

    //------------------------------------------------------------------------------
    // whether to use the logger
    //------------------------------------------------------------------------------
    var UseLogger = false;

    //------------------------------------------------------------------------------
    // Timers
    //------------------------------------------------------------------------------
    var Timers = {};

    //------------------------------------------------------------------------------
    // used for unimplemented methods
    //------------------------------------------------------------------------------
    function noop() {}

    //------------------------------------------------------------------------------
    // used for unimplemented methods
    //------------------------------------------------------------------------------
    console.useLogger = function (value) {
        if (arguments.length) UseLogger = !!value;

        if (UseLogger) {
            if (logger.useConsole()) {
                throw new Error("console and logger are too intertwingly");
            }
        }

        return UseLogger;
    };

    //------------------------------------------------------------------------------
    console.log = function() {
        if (logger.useConsole()) return;
        logger.log.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.error = function() {
        if (logger.useConsole()) return;
        logger.error.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.warn = function() {
        if (logger.useConsole()) return;
        logger.warn.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.info = function() {
        if (logger.useConsole()) return;
        logger.info.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.debug = function() {
        if (logger.useConsole()) return;
        logger.debug.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.assert = function(expression) {
        if (expression) return;

        var message = utils.vformat(arguments[1], [].slice.call(arguments, 2));
        console.log("ASSERT: " + message);
    };

    //------------------------------------------------------------------------------
    console.clear = function() {};

    //------------------------------------------------------------------------------
    console.dir = function(object) {
        console.log("%o", object);
    };

    //------------------------------------------------------------------------------
    console.dirxml = function(node) {
        console.log(node.innerHTML);
    };

    //------------------------------------------------------------------------------
    console.trace = noop;

    //------------------------------------------------------------------------------
    console.group = console.log;

    //------------------------------------------------------------------------------
    console.groupCollapsed = console.log;

    //------------------------------------------------------------------------------
    console.groupEnd = noop;

    //------------------------------------------------------------------------------
    console.time = function(name) {
        Timers[name] = new Date().valueOf();
    };

    //------------------------------------------------------------------------------
    console.timeEnd = function(name) {
        var timeStart = Timers[name];
        if (!timeStart) {
            console.warn("unknown timer: " + name);
            return;
        }

        var timeElapsed = new Date().valueOf() - timeStart;
        console.log(name + ": " + timeElapsed + "ms");
    };

    //------------------------------------------------------------------------------
    console.timeStamp = noop;

    //------------------------------------------------------------------------------
    console.profile = noop;

    //------------------------------------------------------------------------------
    console.profileEnd = noop;

    //------------------------------------------------------------------------------
    console.count = noop;

    //------------------------------------------------------------------------------
    console.exception = console.log;

    //------------------------------------------------------------------------------
    console.table = function(data, columns) {
        console.log("%o", data);
    };

    //------------------------------------------------------------------------------
    // return a new function that calls both functions passed as args
    //------------------------------------------------------------------------------
    function wrappedOrigCall(orgFunc, newFunc) {
        return function() {
            var args = [].slice.call(arguments);
            try { orgFunc.apply(WinConsole, args); } catch (e) {}
            try { newFunc.apply(console,    args); } catch (e) {}
        };
    }

    //------------------------------------------------------------------------------
    // For every function that exists in the original console object, that
    // also exists in the new console object, wrap the new console method
    // with one that calls both
    //------------------------------------------------------------------------------
    for (var key in console) {
        if (typeof WinConsole[key] == "function") {
            console[key] = wrappedOrigCall(WinConsole[key], console[key]);
        }
    }

    });

    // file: lib/common/plugin/contacts.js
    define("cordova/plugin/contacts", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        ContactError = require('cordova/plugin/ContactError'),
        utils = require('cordova/utils'),
        Contact = require('cordova/plugin/Contact');

    /**
    * Represents a group of Contacts.
    * @constructor
    */
    var contacts = {
        /**
         * Returns an array of Contacts matching the search criteria.
         * @param fields that should be searched
         * @param successCB success callback
         * @param errorCB error callback
         * @param {ContactFindOptions} options that can be applied to contact searching
         * @return array of Contacts matching search criteria
         */
        find:function(fields, successCB, errorCB, options) {
            argscheck.checkArgs('afFO', 'contacts.find', arguments);
            if (!fields.length) {
                errorCB && errorCB(new ContactError(ContactError.INVALID_ARGUMENT_ERROR));
            } else {
                var win = function(result) {
                    var cs = [];
                    for (var i = 0, l = result.length; i < l; i++) {
                        cs.push(contacts.create(result[i]));
                    }
                    successCB(cs);
                };
                exec(win, errorCB, "Contacts", "search", [fields, options]);
            }
        },

        /**
         * This function creates a new contact, but it does not persist the contact
         * to device storage. To persist the contact to device storage, invoke
         * contact.save().
         * @param properties an object whose properties will be examined to create a new Contact
         * @returns new Contact object
         */
        create:function(properties) {
            argscheck.checkArgs('O', 'contacts.create', arguments);
            var contact = new Contact();
            for (var i in properties) {
                if (typeof contact[i] !== 'undefined' && properties.hasOwnProperty(i)) {
                    contact[i] = properties[i];
                }
            }
            return contact;
        }
    };

    module.exports = contacts;

    });

    // file: lib/common/plugin/device.js
    define("cordova/plugin/device", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        channel = require('cordova/channel'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec');

    // Tell cordova channel to wait on the CordovaInfoReady event
    channel.waitForInitialization('onCordovaInfoReady');

    /**
     * This represents the mobile device, and provides properties for inspecting the model, version, UUID of the
     * phone, etc.
     * @constructor
     */
    function Device() {
        this.available = false;
        this.platform = null;
        this.version = null;
        this.name = null;
        this.uuid = null;
        this.cordova = null;
        this.model = null;

        var me = this;

        channel.onCordovaReady.subscribe(function() {
            me.getInfo(function(info) {
                me.available = true;
                me.platform = info.platform;
                me.version = info.version;
                me.name = info.name;
                me.uuid = info.uuid;
                me.cordova = info.cordova;
                me.model = info.model;
                channel.onCordovaInfoReady.fire();
            },function(e) {
                me.available = false;
                utils.alert("[ERROR] Error initializing Cordova: " + e);
            });
        });
    }

    /**
     * Get device info
     *
     * @param {Function} successCallback The function to call when the heading data is available
     * @param {Function} errorCallback The function to call when there is an error getting the heading data. (OPTIONAL)
     */
    Device.prototype.getInfo = function(successCallback, errorCallback) {
        argscheck.checkArgs('fF', 'Device.getInfo', arguments);
        exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);
    };

    module.exports = new Device();

    });

    // file: lib/common/plugin/echo.js
    define("cordova/plugin/echo", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Sends the given message through exec() to the Echo plugin, which sends it back to the successCallback.
     * @param successCallback  invoked with a FileSystem object
     * @param errorCallback  invoked if error occurs retrieving file system
     * @param message  The string to be echoed.
     * @param forceAsync  Whether to force an async return value (for testing native->js bridge).
     */
    module.exports = function(successCallback, errorCallback, message, forceAsync) {
        var action = forceAsync ? 'echoAsync' : 'echo';
        if (!forceAsync && message.constructor == ArrayBuffer) {
            action = 'echoArrayBuffer';
        }
        exec(successCallback, errorCallback, "Echo", action, [message]);
    };


    });

    // file: lib/android/plugin/file/symbols.js
    define("cordova/plugin/file/symbols", function(require, exports, module) {


    var modulemapper = require('cordova/modulemapper'),
        symbolshelper = require('cordova/plugin/file/symbolshelper');

    symbolshelper(modulemapper.clobbers);

    });

    // file: lib/common/plugin/file/symbolshelper.js
    define("cordova/plugin/file/symbolshelper", function(require, exports, module) {

    module.exports = function(exportFunc) {
        exportFunc('cordova/plugin/DirectoryEntry', 'DirectoryEntry');
        exportFunc('cordova/plugin/DirectoryReader', 'DirectoryReader');
        exportFunc('cordova/plugin/Entry', 'Entry');
        exportFunc('cordova/plugin/File', 'File');
        exportFunc('cordova/plugin/FileEntry', 'FileEntry');
        exportFunc('cordova/plugin/FileError', 'FileError');
        exportFunc('cordova/plugin/FileReader', 'FileReader');
        exportFunc('cordova/plugin/FileSystem', 'FileSystem');
        exportFunc('cordova/plugin/FileTransfer', 'FileTransfer');
        exportFunc('cordova/plugin/FileTransferError', 'FileTransferError');
        exportFunc('cordova/plugin/FileUploadOptions', 'FileUploadOptions');
        exportFunc('cordova/plugin/FileUploadResult', 'FileUploadResult');
        exportFunc('cordova/plugin/FileWriter', 'FileWriter');
        exportFunc('cordova/plugin/Flags', 'Flags');
        exportFunc('cordova/plugin/LocalFileSystem', 'LocalFileSystem');
        exportFunc('cordova/plugin/Metadata', 'Metadata');
        exportFunc('cordova/plugin/requestFileSystem', 'requestFileSystem');
        exportFunc('cordova/plugin/resolveLocalFileSystemURI', 'resolveLocalFileSystemURI');
    };

    });

    // file: lib/common/plugin/geolocation.js
    define("cordova/plugin/geolocation", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        PositionError = require('cordova/plugin/PositionError'),
        Position = require('cordova/plugin/Position');

    var timers = {};   // list of timers in use

    // Returns default params, overrides if provided with values
    function parseParameters(options) {
        var opt = {
            maximumAge: 0,
            enableHighAccuracy: false,
            timeout: Infinity
        };

        if (options) {
            if (options.maximumAge !== undefined && !isNaN(options.maximumAge) && options.maximumAge > 0) {
                opt.maximumAge = options.maximumAge;
            }
            if (options.enableHighAccuracy !== undefined) {
                opt.enableHighAccuracy = options.enableHighAccuracy;
            }
            if (options.timeout !== undefined && !isNaN(options.timeout)) {
                if (options.timeout < 0) {
                    opt.timeout = 0;
                } else {
                    opt.timeout = options.timeout;
                }
            }
        }

        return opt;
    }

    // Returns a timeout failure, closed over a specified timeout value and error callback.
    function createTimeout(errorCallback, timeout) {
        var t = setTimeout(function() {
            clearTimeout(t);
            t = null;
            errorCallback({
                code:PositionError.TIMEOUT,
                message:"Position retrieval timed out."
            });
        }, timeout);
        return t;
    }

    var geolocation = {
        lastPosition:null, // reference to last known (cached) position returned
        /**
       * Asynchronously acquires the current position.
       *
       * @param {Function} successCallback    The function to call when the position data is available
       * @param {Function} errorCallback      The function to call when there is an error getting the heading position. (OPTIONAL)
       * @param {PositionOptions} options     The options for getting the position data. (OPTIONAL)
       */
        getCurrentPosition:function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);
            options = parseParameters(options);

            // Timer var that will fire an error callback if no position is retrieved from native
            // before the "timeout" param provided expires
            var timeoutTimer = {timer:null};

            var win = function(p) {
                clearTimeout(timeoutTimer.timer);
                if (!(timeoutTimer.timer)) {
                    // Timeout already happened, or native fired error callback for
                    // this geo request.
                    // Don't continue with success callback.
                    return;
                }
                var pos = new Position(
                    {
                        latitude:p.latitude,
                        longitude:p.longitude,
                        altitude:p.altitude,
                        accuracy:p.accuracy,
                        heading:p.heading,
                        velocity:p.velocity,
                        altitudeAccuracy:p.altitudeAccuracy
                    },
                    (p.timestamp === undefined ? new Date() : ((p.timestamp instanceof Date) ? p.timestamp : new Date(p.timestamp)))
                );
                geolocation.lastPosition = pos;
                successCallback(pos);
            };
            var fail = function(e) {
                clearTimeout(timeoutTimer.timer);
                timeoutTimer.timer = null;
                var err = new PositionError(e.code, e.message);
                if (errorCallback) {
                    errorCallback(err);
                }
            };

            // Check our cached position, if its timestamp difference with current time is less than the maximumAge, then just
            // fire the success callback with the cached position.
            if (geolocation.lastPosition && options.maximumAge && (((new Date()).getTime() - geolocation.lastPosition.timestamp.getTime()) <= options.maximumAge)) {
                successCallback(geolocation.lastPosition);
            // If the cached position check failed and the timeout was set to 0, error out with a TIMEOUT error object.
            } else if (options.timeout === 0) {
                fail({
                    code:PositionError.TIMEOUT,
                    message:"timeout value in PositionOptions set to 0 and no cached Position object available, or cached Position object's age exceeds provided PositionOptions' maximumAge parameter."
                });
            // Otherwise we have to call into native to retrieve a position.
            } else {
                if (options.timeout !== Infinity) {
                    // If the timeout value was not set to Infinity (default), then
                    // set up a timeout function that will fire the error callback
                    // if no successful position was retrieved before timeout expired.
                    timeoutTimer.timer = createTimeout(fail, options.timeout);
                } else {
                    // This is here so the check in the win function doesn't mess stuff up
                    // may seem weird but this guarantees timeoutTimer is
                    // always truthy before we call into native
                    timeoutTimer.timer = true;
                }
                exec(win, fail, "Geolocation", "getLocation", [options.enableHighAccuracy, options.maximumAge]);
            }
            return timeoutTimer;
        },
        /**
         * Asynchronously watches the geolocation for changes to geolocation.  When a change occurs,
         * the successCallback is called with the new location.
         *
         * @param {Function} successCallback    The function to call each time the location data is available
         * @param {Function} errorCallback      The function to call when there is an error getting the location data. (OPTIONAL)
         * @param {PositionOptions} options     The options for getting the location data such as frequency. (OPTIONAL)
         * @return String                       The watch id that must be passed to #clearWatch to stop watching.
         */
        watchPosition:function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);
            options = parseParameters(options);

            var id = utils.createUUID();

            // Tell device to get a position ASAP, and also retrieve a reference to the timeout timer generated in getCurrentPosition
            timers[id] = geolocation.getCurrentPosition(successCallback, errorCallback, options);

            var fail = function(e) {
                clearTimeout(timers[id].timer);
                var err = new PositionError(e.code, e.message);
                if (errorCallback) {
                    errorCallback(err);
                }
            };

            var win = function(p) {
                clearTimeout(timers[id].timer);
                if (options.timeout !== Infinity) {
                    timers[id].timer = createTimeout(fail, options.timeout);
                }
                var pos = new Position(
                    {
                        latitude:p.latitude,
                        longitude:p.longitude,
                        altitude:p.altitude,
                        accuracy:p.accuracy,
                        heading:p.heading,
                        velocity:p.velocity,
                        altitudeAccuracy:p.altitudeAccuracy
                    },
                    (p.timestamp === undefined ? new Date() : ((p.timestamp instanceof Date) ? p.timestamp : new Date(p.timestamp)))
                );
                geolocation.lastPosition = pos;
                successCallback(pos);
            };

            exec(win, fail, "Geolocation", "addWatch", [id, options.enableHighAccuracy]);

            return id;
        },
        /**
         * Clears the specified heading watch.
         *
         * @param {String} id       The ID of the watch returned from #watchPosition
         */
        clearWatch:function(id) {
            if (id && timers[id] !== undefined) {
                clearTimeout(timers[id].timer);
                timers[id].timer = false;
                exec(null, null, "Geolocation", "clearWatch", [id]);
            }
        }
    };

    module.exports = geolocation;

    });

    // file: lib/common/plugin/globalization.js
    define("cordova/plugin/globalization", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        GlobalizationError = require('cordova/plugin/GlobalizationError');

    var globalization = {

    /**
    * Returns the string identifier for the client's current language.
    * It returns the language identifier string to the successCB callback with a
    * properties object as a parameter. If there is an error getting the language,
    * then the errorCB callback is invoked.
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.value {String}: The language identifier
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getPreferredLanguage(function (language) {alert('language:' + language.value + '\n');},
    *                                function () {});
    */
    getPreferredLanguage:function(successCB, failureCB) {
        argscheck.checkArgs('fF', 'Globalization.getPreferredLanguage', arguments);
        exec(successCB, failureCB, "Globalization","getPreferredLanguage", []);
    },

    /**
    * Returns the string identifier for the client's current locale setting.
    * It returns the locale identifier string to the successCB callback with a
    * properties object as a parameter. If there is an error getting the locale,
    * then the errorCB callback is invoked.
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.value {String}: The locale identifier
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getLocaleName(function (locale) {alert('locale:' + locale.value + '\n');},
    *                                function () {});
    */
    getLocaleName:function(successCB, failureCB) {
        argscheck.checkArgs('fF', 'Globalization.getLocaleName', arguments);
        exec(successCB, failureCB, "Globalization","getLocaleName", []);
    },


    /**
    * Returns a date formatted as a string according to the client's user preferences and
    * calendar using the time zone of the client. It returns the formatted date string to the
    * successCB callback with a properties object as a parameter. If there is an error
    * formatting the date, then the errorCB callback is invoked.
    *
    * The defaults are: formatLenght="short" and selector="date and time"
    *
    * @param {Date} date
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            formatLength {String}: 'short', 'medium', 'long', or 'full'
    *            selector {String}: 'date', 'time', or 'date and time'
    *
    * @return Object.value {String}: The localized date string
    *
    * @error GlobalizationError.FORMATTING_ERROR
    *
    * Example
    *    globalization.dateToString(new Date(),
    *                function (date) {alert('date:' + date.value + '\n');},
    *                function (errorCode) {alert(errorCode);},
    *                {formatLength:'short'});
    */
    dateToString:function(date, successCB, failureCB, options) {
        argscheck.checkArgs('dfFO', 'Globalization.dateToString', arguments);
        var dateValue = date.valueOf();
        exec(successCB, failureCB, "Globalization", "dateToString", [{"date": dateValue, "options": options}]);
    },


    /**
    * Parses a date formatted as a string according to the client's user
    * preferences and calendar using the time zone of the client and returns
    * the corresponding date object. It returns the date to the successCB
    * callback with a properties object as a parameter. If there is an error
    * parsing the date string, then the errorCB callback is invoked.
    *
    * The defaults are: formatLength="short" and selector="date and time"
    *
    * @param {String} dateString
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            formatLength {String}: 'short', 'medium', 'long', or 'full'
    *            selector {String}: 'date', 'time', or 'date and time'
    *
    * @return    Object.year {Number}: The four digit year
    *            Object.month {Number}: The month from (0 - 11)
    *            Object.day {Number}: The day from (1 - 31)
    *            Object.hour {Number}: The hour from (0 - 23)
    *            Object.minute {Number}: The minute from (0 - 59)
    *            Object.second {Number}: The second from (0 - 59)
    *            Object.millisecond {Number}: The milliseconds (from 0 - 999),
    *                                        not available on all platforms
    *
    * @error GlobalizationError.PARSING_ERROR
    *
    * Example
    *    globalization.stringToDate('4/11/2011',
    *                function (date) { alert('Month:' + date.month + '\n' +
    *                    'Day:' + date.day + '\n' +
    *                    'Year:' + date.year + '\n');},
    *                function (errorCode) {alert(errorCode);},
    *                {selector:'date'});
    */
    stringToDate:function(dateString, successCB, failureCB, options) {
        argscheck.checkArgs('sfFO', 'Globalization.stringToDate', arguments);
        exec(successCB, failureCB, "Globalization", "stringToDate", [{"dateString": dateString, "options": options}]);
    },


    /**
    * Returns a pattern string for formatting and parsing dates according to the client's
    * user preferences. It returns the pattern to the successCB callback with a
    * properties object as a parameter. If there is an error obtaining the pattern,
    * then the errorCB callback is invoked.
    *
    * The defaults are: formatLength="short" and selector="date and time"
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            formatLength {String}: 'short', 'medium', 'long', or 'full'
    *            selector {String}: 'date', 'time', or 'date and time'
    *
    * @return    Object.pattern {String}: The date and time pattern for formatting and parsing dates.
    *                                    The patterns follow Unicode Technical Standard #35
    *                                    http://unicode.org/reports/tr35/tr35-4.html
    *            Object.timezone {String}: The abbreviated name of the time zone on the client
    *            Object.utc_offset {Number}: The current difference in seconds between the client's
    *                                        time zone and coordinated universal time.
    *            Object.dst_offset {Number}: The current daylight saving time offset in seconds
    *                                        between the client's non-daylight saving's time zone
    *                                        and the client's daylight saving's time zone.
    *
    * @error GlobalizationError.PATTERN_ERROR
    *
    * Example
    *    globalization.getDatePattern(
    *                function (date) {alert('pattern:' + date.pattern + '\n');},
    *                function () {},
    *                {formatLength:'short'});
    */
    getDatePattern:function(successCB, failureCB, options) {
        argscheck.checkArgs('fFO', 'Globalization.getDatePattern', arguments);
        exec(successCB, failureCB, "Globalization", "getDatePattern", [{"options": options}]);
    },


    /**
    * Returns an array of either the names of the months or days of the week
    * according to the client's user preferences and calendar. It returns the array of names to the
    * successCB callback with a properties object as a parameter. If there is an error obtaining the
    * names, then the errorCB callback is invoked.
    *
    * The defaults are: type="wide" and item="months"
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'narrow' or 'wide'
    *            item {String}: 'months', or 'days'
    *
    * @return Object.value {Array{String}}: The array of names starting from either
    *                                        the first month in the year or the
    *                                        first day of the week.
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getDateNames(function (names) {
    *        for(var i = 0; i < names.value.length; i++) {
    *            alert('Month:' + names.value[i] + '\n');}},
    *        function () {});
    */
    getDateNames:function(successCB, failureCB, options) {
        argscheck.checkArgs('fFO', 'Globalization.getDateNames', arguments);
        exec(successCB, failureCB, "Globalization", "getDateNames", [{"options": options}]);
    },

    /**
    * Returns whether daylight savings time is in effect for a given date using the client's
    * time zone and calendar. It returns whether or not daylight savings time is in effect
    * to the successCB callback with a properties object as a parameter. If there is an error
    * reading the date, then the errorCB callback is invoked.
    *
    * @param {Date} date
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.dst {Boolean}: The value "true" indicates that daylight savings time is
    *                                in effect for the given date and "false" indicate that it is not.
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.isDayLightSavingsTime(new Date(),
    *                function (date) {alert('dst:' + date.dst + '\n');}
    *                function () {});
    */
    isDayLightSavingsTime:function(date, successCB, failureCB) {
        argscheck.checkArgs('dfF', 'Globalization.isDayLightSavingsTime', arguments);
        var dateValue = date.valueOf();
        exec(successCB, failureCB, "Globalization", "isDayLightSavingsTime", [{"date": dateValue}]);
    },

    /**
    * Returns the first day of the week according to the client's user preferences and calendar.
    * The days of the week are numbered starting from 1 where 1 is considered to be Sunday.
    * It returns the day to the successCB callback with a properties object as a parameter.
    * If there is an error obtaining the pattern, then the errorCB callback is invoked.
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.value {Number}: The number of the first day of the week.
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getFirstDayOfWeek(function (day)
    *                { alert('Day:' + day.value + '\n');},
    *                function () {});
    */
    getFirstDayOfWeek:function(successCB, failureCB) {
        argscheck.checkArgs('fF', 'Globalization.getFirstDayOfWeek', arguments);
        exec(successCB, failureCB, "Globalization", "getFirstDayOfWeek", []);
    },


    /**
    * Returns a number formatted as a string according to the client's user preferences.
    * It returns the formatted number string to the successCB callback with a properties object as a
    * parameter. If there is an error formatting the number, then the errorCB callback is invoked.
    *
    * The defaults are: type="decimal"
    *
    * @param {Number} number
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'decimal', "percent", or 'currency'
    *
    * @return Object.value {String}: The formatted number string.
    *
    * @error GlobalizationError.FORMATTING_ERROR
    *
    * Example
    *    globalization.numberToString(3.25,
    *                function (number) {alert('number:' + number.value + '\n');},
    *                function () {},
    *                {type:'decimal'});
    */
    numberToString:function(number, successCB, failureCB, options) {
        argscheck.checkArgs('nfFO', 'Globalization.numberToString', arguments);
        exec(successCB, failureCB, "Globalization", "numberToString", [{"number": number, "options": options}]);
    },

    /**
    * Parses a number formatted as a string according to the client's user preferences and
    * returns the corresponding number. It returns the number to the successCB callback with a
    * properties object as a parameter. If there is an error parsing the number string, then
    * the errorCB callback is invoked.
    *
    * The defaults are: type="decimal"
    *
    * @param {String} numberString
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'decimal', "percent", or 'currency'
    *
    * @return Object.value {Number}: The parsed number.
    *
    * @error GlobalizationError.PARSING_ERROR
    *
    * Example
    *    globalization.stringToNumber('1234.56',
    *                function (number) {alert('Number:' + number.value + '\n');},
    *                function () { alert('Error parsing number');});
    */
    stringToNumber:function(numberString, successCB, failureCB, options) {
        argscheck.checkArgs('sfFO', 'Globalization.stringToNumber', arguments);
        exec(successCB, failureCB, "Globalization", "stringToNumber", [{"numberString": numberString, "options": options}]);
    },

    /**
    * Returns a pattern string for formatting and parsing numbers according to the client's user
    * preferences. It returns the pattern to the successCB callback with a properties object as a
    * parameter. If there is an error obtaining the pattern, then the errorCB callback is invoked.
    *
    * The defaults are: type="decimal"
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'decimal', "percent", or 'currency'
    *
    * @return    Object.pattern {String}: The number pattern for formatting and parsing numbers.
    *                                    The patterns follow Unicode Technical Standard #35.
    *                                    http://unicode.org/reports/tr35/tr35-4.html
    *            Object.symbol {String}: The symbol to be used when formatting and parsing
    *                                    e.g., percent or currency symbol.
    *            Object.fraction {Number}: The number of fractional digits to use when parsing and
    *                                    formatting numbers.
    *            Object.rounding {Number}: The rounding increment to use when parsing and formatting.
    *            Object.positive {String}: The symbol to use for positive numbers when parsing and formatting.
    *            Object.negative: {String}: The symbol to use for negative numbers when parsing and formatting.
    *            Object.decimal: {String}: The decimal symbol to use for parsing and formatting.
    *            Object.grouping: {String}: The grouping symbol to use for parsing and formatting.
    *
    * @error GlobalizationError.PATTERN_ERROR
    *
    * Example
    *    globalization.getNumberPattern(
    *                function (pattern) {alert('Pattern:' + pattern.pattern + '\n');},
    *                function () {});
    */
    getNumberPattern:function(successCB, failureCB, options) {
        argscheck.checkArgs('fFO', 'Globalization.getNumberPattern', arguments);
        exec(successCB, failureCB, "Globalization", "getNumberPattern", [{"options": options}]);
    },

    /**
    * Returns a pattern string for formatting and parsing currency values according to the client's
    * user preferences and ISO 4217 currency code. It returns the pattern to the successCB callback with a
    * properties object as a parameter. If there is an error obtaining the pattern, then the errorCB
    * callback is invoked.
    *
    * @param {String} currencyCode
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return    Object.pattern {String}: The currency pattern for formatting and parsing currency values.
    *                                    The patterns follow Unicode Technical Standard #35
    *                                    http://unicode.org/reports/tr35/tr35-4.html
    *            Object.code {String}: The ISO 4217 currency code for the pattern.
    *            Object.fraction {Number}: The number of fractional digits to use when parsing and
    *                                    formatting currency.
    *            Object.rounding {Number}: The rounding increment to use when parsing and formatting.
    *            Object.decimal: {String}: The decimal symbol to use for parsing and formatting.
    *            Object.grouping: {String}: The grouping symbol to use for parsing and formatting.
    *
    * @error GlobalizationError.FORMATTING_ERROR
    *
    * Example
    *    globalization.getCurrencyPattern('EUR',
    *                function (currency) {alert('Pattern:' + currency.pattern + '\n');}
    *                function () {});
    */
    getCurrencyPattern:function(currencyCode, successCB, failureCB) {
        argscheck.checkArgs('sfF', 'Globalization.getCurrencyPattern', arguments);
        exec(successCB, failureCB, "Globalization", "getCurrencyPattern", [{"currencyCode": currencyCode}]);
    }

    };

    module.exports = globalization;

    });

    // file: lib/common/plugin/logger.js
    define("cordova/plugin/logger", function(require, exports, module) {

    //------------------------------------------------------------------------------
    // The logger module exports the following properties/functions:
    //
    // LOG                          - constant for the level LOG
    // ERROR                        - constant for the level ERROR
    // WARN                         - constant for the level WARN
    // INFO                         - constant for the level INFO
    // DEBUG                        - constant for the level DEBUG
    // logLevel()                   - returns current log level
    // logLevel(value)              - sets and returns a new log level
    // useConsole()                 - returns whether logger is using console
    // useConsole(value)            - sets and returns whether logger is using console
    // log(message,...)             - logs a message at level LOG
    // error(message,...)           - logs a message at level ERROR
    // warn(message,...)            - logs a message at level WARN
    // info(message,...)            - logs a message at level INFO
    // debug(message,...)           - logs a message at level DEBUG
    // logLevel(level,message,...)  - logs a message specified level
    //
    //------------------------------------------------------------------------------

    var logger = exports;

    var exec    = require('cordova/exec');
    var utils   = require('cordova/utils');

    var UseConsole   = true;
    var Queued       = [];
    var DeviceReady  = false;
    var CurrentLevel;

    /**
     * Logging levels
     */

    var Levels = [
        "LOG",
        "ERROR",
        "WARN",
        "INFO",
        "DEBUG"
    ];

    /*
     * add the logging levels to the logger object and
     * to a separate levelsMap object for testing
     */

    var LevelsMap = {};
    for (var i=0; i<Levels.length; i++) {
        var level = Levels[i];
        LevelsMap[level] = i;
        logger[level]    = level;
    }

    CurrentLevel = LevelsMap.WARN;

    /**
     * Getter/Setter for the logging level
     *
     * Returns the current logging level.
     *
     * When a value is passed, sets the logging level to that value.
     * The values should be one of the following constants:
     *    logger.LOG
     *    logger.ERROR
     *    logger.WARN
     *    logger.INFO
     *    logger.DEBUG
     *
     * The value used determines which messages get printed.  The logging
     * values above are in order, and only messages logged at the logging
     * level or above will actually be displayed to the user.  E.g., the
     * default level is WARN, so only messages logged with LOG, ERROR, or
     * WARN will be displayed; INFO and DEBUG messages will be ignored.
     */
    logger.level = function (value) {
        if (arguments.length) {
            if (LevelsMap[value] === null) {
                throw new Error("invalid logging level: " + value);
            }
            CurrentLevel = LevelsMap[value];
        }

        return Levels[CurrentLevel];
    };

    /**
     * Getter/Setter for the useConsole functionality
     *
     * When useConsole is true, the logger will log via the
     * browser 'console' object.  Otherwise, it will use the
     * native Logger plugin.
     */
    logger.useConsole = function (value) {
        if (arguments.length) UseConsole = !!value;

        if (UseConsole) {
            if (typeof console == "undefined") {
                throw new Error("global console object is not defined");
            }

            if (typeof console.log != "function") {
                throw new Error("global console object does not have a log function");
            }

            if (typeof console.useLogger == "function") {
                if (console.useLogger()) {
                    throw new Error("console and logger are too intertwingly");
                }
            }
        }

        return UseConsole;
    };

    /**
     * Logs a message at the LOG level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.log   = function(message) { logWithArgs("LOG",   arguments); };

    /**
     * Logs a message at the ERROR level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.error = function(message) { logWithArgs("ERROR", arguments); };

    /**
     * Logs a message at the WARN level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.warn  = function(message) { logWithArgs("WARN",  arguments); };

    /**
     * Logs a message at the INFO level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.info  = function(message) { logWithArgs("INFO",  arguments); };

    /**
     * Logs a message at the DEBUG level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.debug = function(message) { logWithArgs("DEBUG", arguments); };

    // log at the specified level with args
    function logWithArgs(level, args) {
        args = [level].concat([].slice.call(args));
        logger.logLevel.apply(logger, args);
    }

    /**
     * Logs a message at the specified level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.logLevel = function(level, message /* , ... */) {
        // format the message with the parameters
        var formatArgs = [].slice.call(arguments, 2);
        message    = utils.vformat(message, formatArgs);

        if (LevelsMap[level] === null) {
            throw new Error("invalid logging level: " + level);
        }

        if (LevelsMap[level] > CurrentLevel) return;

        // queue the message if not yet at deviceready
        if (!DeviceReady && !UseConsole) {
            Queued.push([level, message]);
            return;
        }

        // if not using the console, use the native logger
        if (!UseConsole) {
            exec(null, null, "Logger", "logLevel", [level, message]);
            return;
        }

        // make sure console is not using logger
        if (console.__usingCordovaLogger) {
            throw new Error("console and logger are too intertwingly");
        }

        // log to the console
        switch (level) {
            case logger.LOG:   console.log(message); break;
            case logger.ERROR: console.log("ERROR: " + message); break;
            case logger.WARN:  console.log("WARN: "  + message); break;
            case logger.INFO:  console.log("INFO: "  + message); break;
            case logger.DEBUG: console.log("DEBUG: " + message); break;
        }
    };

    // when deviceready fires, log queued messages
    logger.__onDeviceReady = function() {
        if (DeviceReady) return;

        DeviceReady = true;

        for (var i=0; i<Queued.length; i++) {
            var messageArgs = Queued[i];
            logger.logLevel(messageArgs[0], messageArgs[1]);
        }

        Queued = null;
    };

    // add a deviceready event to log queued messages
    document.addEventListener("deviceready", logger.__onDeviceReady, false);

    });

    // file: lib/common/plugin/network.js
    define("cordova/plugin/network", function(require, exports, module) {

    var exec = require('cordova/exec'),
        cordova = require('cordova'),
        channel = require('cordova/channel'),
        utils = require('cordova/utils');

    // Link the onLine property with the Cordova-supplied network info.
    // This works because we clobber the naviagtor object with our own
    // object in bootstrap.js.
    if (typeof navigator != 'undefined') {
        utils.defineGetter(navigator, 'onLine', function() {
            return this.connection.type != 'none';
        });
    }

    function NetworkConnection() {
        this.type = 'unknown';
    }

    /**
     * Get connection info
     *
     * @param {Function} successCallback The function to call when the Connection data is available
     * @param {Function} errorCallback The function to call when there is an error getting the Connection data. (OPTIONAL)
     */
    NetworkConnection.prototype.getInfo = function(successCallback, errorCallback) {
        exec(successCallback, errorCallback, "NetworkStatus", "getConnectionInfo", []);
    };

    var me = new NetworkConnection();
    var timerId = null;
    var timeout = 500;

    channel.onCordovaReady.subscribe(function() {
        me.getInfo(function(info) {
            me.type = info;
            if (info === "none") {
                // set a timer if still offline at the end of timer send the offline event
                timerId = setTimeout(function(){
                    cordova.fireDocumentEvent("offline");
                    timerId = null;
                }, timeout);
            } else {
                // If there is a current offline event pending clear it
                if (timerId !== null) {
                    clearTimeout(timerId);
                    timerId = null;
                }
                cordova.fireDocumentEvent("online");
            }

            // should only fire this once
            if (channel.onCordovaConnectionReady.state !== 2) {
                channel.onCordovaConnectionReady.fire();
            }
        },
        function (e) {
            // If we can't get the network info we should still tell Cordova
            // to fire the deviceready event.
            if (channel.onCordovaConnectionReady.state !== 2) {
                channel.onCordovaConnectionReady.fire();
            }
            console.log("Error initializing Network Connection: " + e);
        });
    });

    module.exports = me;

    });

    // file: lib/common/plugin/notification.js
    define("cordova/plugin/notification", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Provides access to notifications on the device.
     */

    module.exports = {

        /**
         * Open a native alert dialog, with a customizable title and button text.
         *
         * @param {String} message              Message to print in the body of the alert
         * @param {Function} completeCallback   The callback that is called when user clicks on a button.
         * @param {String} title                Title of the alert dialog (default: Alert)
         * @param {String} buttonLabel          Label of the close button (default: OK)
         */
        alert: function(message, completeCallback, title, buttonLabel) {
            var _title = (title || "Alert");
            var _buttonLabel = (buttonLabel || "OK");
            exec(completeCallback, null, "Notification", "alert", [message, _title, _buttonLabel]);
        },

        /**
         * Open a native confirm dialog, with a customizable title and button text.
         * The result that the user selects is returned to the result callback.
         *
         * @param {String} message              Message to print in the body of the alert
         * @param {Function} resultCallback     The callback that is called when user clicks on a button.
         * @param {String} title                Title of the alert dialog (default: Confirm)
         * @param {String} buttonLabels         Comma separated list of the labels of the buttons (default: 'OK,Cancel')
         */
        confirm: function(message, resultCallback, title, buttonLabels) {
            var _title = (title || "Confirm");
            var _buttonLabels = (buttonLabels || "OK,Cancel");
            exec(resultCallback, null, "Notification", "confirm", [message, _title, _buttonLabels]);
        },

        /**
         * Causes the device to vibrate.
         *
         * @param {Integer} mills       The number of milliseconds to vibrate for.
         */
        vibrate: function(mills) {
            exec(null, null, "Notification", "vibrate", [mills]);
        },

        /**
         * Causes the device to beep.
         * On Android, the default notification ringtone is played "count" times.
         *
         * @param {Integer} count       The number of beeps.
         */
        beep: function(count) {
            exec(null, null, "Notification", "beep", [count]);
        }
    };

    });

    // file: lib/common/plugin/requestFileSystem.js
    define("cordova/plugin/requestFileSystem", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        FileError = require('cordova/plugin/FileError'),
        FileSystem = require('cordova/plugin/FileSystem'),
        exec = require('cordova/exec');

    /**
     * Request a file system in which to store application data.
     * @param type  local file system type
     * @param size  indicates how much storage space, in bytes, the application expects to need
     * @param successCallback  invoked with a FileSystem object
     * @param errorCallback  invoked if error occurs retrieving file system
     */
    var requestFileSystem = function(type, size, successCallback, errorCallback) {
        argscheck.checkArgs('nnFF', 'requestFileSystem', arguments);
        var fail = function(code) {
            errorCallback && errorCallback(new FileError(code));
        };

        if (type < 0 || type > 3) {
            fail(FileError.SYNTAX_ERR);
        } else {
            // if successful, return a FileSystem object
            var success = function(file_system) {
                if (file_system) {
                    if (successCallback) {
                        // grab the name and root from the file system object
                        var result = new FileSystem(file_system.name, file_system.root);
                        successCallback(result);
                    }
                }
                else {
                    // no FileSystem object returned
                    fail(FileError.NOT_FOUND_ERR);
                }
            };
            exec(success, fail, "File", "requestFileSystem", [type, size]);
        }
    };

    module.exports = requestFileSystem;

    });

    // file: lib/common/plugin/resolveLocalFileSystemURI.js
    define("cordova/plugin/resolveLocalFileSystemURI", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        DirectoryEntry = require('cordova/plugin/DirectoryEntry'),
        FileEntry = require('cordova/plugin/FileEntry'),
        FileError = require('cordova/plugin/FileError'),
        exec = require('cordova/exec');

    /**
     * Look up file system Entry referred to by local URI.
     * @param {DOMString} uri  URI referring to a local file or directory
     * @param successCallback  invoked with Entry object corresponding to URI
     * @param errorCallback    invoked if error occurs retrieving file system entry
     */
    module.exports = function(uri, successCallback, errorCallback) {
        argscheck.checkArgs('sFF', 'resolveLocalFileSystemURI', arguments);
        // error callback
        var fail = function(error) {
            errorCallback && errorCallback(new FileError(error));
        };
        // sanity check for 'not:valid:filename'
        if(!uri || uri.split(":").length > 2) {
            setTimeout( function() {
                fail(FileError.ENCODING_ERR);
            },0);
            return;
        }
        // if successful, return either a file or directory entry
        var success = function(entry) {
            var result;
            if (entry) {
                if (successCallback) {
                    // create appropriate Entry object
                    result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath) : new FileEntry(entry.name, entry.fullPath);
                    successCallback(result);
                }
            }
            else {
                // no Entry object returned
                fail(FileError.NOT_FOUND_ERR);
            }
        };

        exec(success, fail, "File", "resolveLocalFileSystemURI", [uri]);
    };

    });

    // file: lib/common/plugin/splashscreen.js
    define("cordova/plugin/splashscreen", function(require, exports, module) {

    var exec = require('cordova/exec');

    var splashscreen = {
        show:function() {
            exec(null, null, "SplashScreen", "show", []);
        },
        hide:function() {
            exec(null, null, "SplashScreen", "hide", []);
        }
    };

    module.exports = splashscreen;

    });

    // file: lib/common/utils.js
    define("cordova/utils", function(require, exports, module) {

    var utils = exports;

    /**
     * Defines a property getter / setter for obj[key].
     */
    utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {
        if (Object.defineProperty) {
            var desc = {
                get: getFunc,
                configurable: true
            };
            if (opt_setFunc) {
                desc.set = opt_setFunc;
            }
            Object.defineProperty(obj, key, desc);
        } else {
            obj.__defineGetter__(key, getFunc);
            if (opt_setFunc) {
                obj.__defineSetter__(key, opt_setFunc);
            }
        }
    };

    /**
     * Defines a property getter for obj[key].
     */
    utils.defineGetter = utils.defineGetterSetter;

    utils.arrayIndexOf = function(a, item) {
        if (a.indexOf) {
            return a.indexOf(item);
        }
        var len = a.length;
        for (var i = 0; i < len; ++i) {
            if (a[i] == item) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Returns whether the item was found in the array.
     */
    utils.arrayRemove = function(a, item) {
        var index = utils.arrayIndexOf(a, item);
        if (index != -1) {
            a.splice(index, 1);
        }
        return index != -1;
    };

    utils.typeName = function(val) {
        return Object.prototype.toString.call(val).slice(8, -1);
    };

    /**
     * Returns an indication of whether the argument is an array or not
     */
    utils.isArray = function(a) {
        return utils.typeName(a) == 'Array';
    };

    /**
     * Returns an indication of whether the argument is a Date or not
     */
    utils.isDate = function(d) {
        return utils.typeName(d) == 'Date';
    };

    /**
     * Does a deep clone of the object.
     */
    utils.clone = function(obj) {
        if(!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {
            return obj;
        }

        var retVal, i;

        if(utils.isArray(obj)){
            retVal = [];
            for(i = 0; i < obj.length; ++i){
                retVal.push(utils.clone(obj[i]));
            }
            return retVal;
        }

        retVal = {};
        for(i in obj){
            if(!(i in retVal) || retVal[i] != obj[i]) {
                retVal[i] = utils.clone(obj[i]);
            }
        }
        return retVal;
    };

    /**
     * Returns a wrapped version of the function
     */
    utils.close = function(context, func, params) {
        if (typeof params == 'undefined') {
            return function() {
                return func.apply(context, arguments);
            };
        } else {
            return function() {
                return func.apply(context, params);
            };
        }
    };

    /**
     * Create a UUID
     */
    utils.createUUID = function() {
        return UUIDcreatePart(4) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(6);
    };

    /**
     * Extends a child object from a parent object using classical inheritance
     * pattern.
     */
    utils.extend = (function() {
        // proxy used to establish prototype chain
        var F = function() {};
        // extend Child from Parent
        return function(Child, Parent) {
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.__super__ = Parent.prototype;
            Child.prototype.constructor = Child;
        };
    }());

    /**
     * Alerts a message in any available way: alert or console.log.
     */
    utils.alert = function(msg) {
        if (window.alert) {
            window.alert(msg);
        } else if (console && console.log) {
            console.log(msg);
        }
    };

    /**
     * Formats a string and arguments following it ala sprintf()
     *
     * see utils.vformat() for more information
     */
    utils.format = function(formatString /* ,... */) {
        var args = [].slice.call(arguments, 1);
        return utils.vformat(formatString, args);
    };

    /**
     * Formats a string and arguments following it ala vsprintf()
     *
     * format chars:
     *   %j - format arg as JSON
     *   %o - format arg as JSON
     *   %c - format arg as ''
     *   %% - replace with '%'
     * any other char following % will format it's
     * arg via toString().
     *
     * for rationale, see FireBug's Console API:
     *    http://getfirebug.com/wiki/index.php/Console_API
     */
    utils.vformat = function(formatString, args) {
        if (formatString === null || formatString === undefined) return "";
        if (arguments.length == 1) return formatString.toString();
        if (typeof formatString != "string") return formatString.toString();

        var pattern = /(.*?)%(.)(.*)/;
        var rest    = formatString;
        var result  = [];

        while (args.length) {
            var arg   = args.shift();
            var match = pattern.exec(rest);

            if (!match) break;

            rest = match[3];

            result.push(match[1]);

            if (match[2] == '%') {
                result.push('%');
                args.unshift(arg);
                continue;
            }

            result.push(formatted(arg, match[2]));
        }

        result.push(rest);

        return result.join('');
    };

    //------------------------------------------------------------------------------
    function UUIDcreatePart(length) {
        var uuidpart = "";
        for (var i=0; i<length; i++) {
            var uuidchar = parseInt((Math.random() * 256), 10).toString(16);
            if (uuidchar.length == 1) {
                uuidchar = "0" + uuidchar;
            }
            uuidpart += uuidchar;
        }
        return uuidpart;
    }

    //------------------------------------------------------------------------------
    function formatted(object, formatChar) {

        try {
            switch(formatChar) {
                case 'j':
                case 'o': return JSON.stringify(object);
                case 'c': return '';
            }
        }
        catch (e) {
            return "error JSON.stringify()ing argument: " + e;
        }

        if ((object === null) || (object === undefined)) {
            return Object.prototype.toString.call(object);
        }

        return object.toString();
    }

    });


    window.cordova = require('cordova');

    // file: lib/scripts/bootstrap.js

    (function (context) {
        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        if (context.navigator) {
            var CordovaNavigator = function() {};
            CordovaNavigator.prototype = context.navigator;
            context.navigator = new CordovaNavigator();
        }

        var channel = require("cordova/channel"),
            _self = {
                boot: function () {
                    /**
                     * Create all cordova objects once page has fully loaded and native side is ready.
                     */
                    channel.join(function() {
                        var builder = require('cordova/builder'),
                            base = require('cordova/common'),
                            platform = require('cordova/platform');

                        // Drop the common globals into the window object, but be nice and don't overwrite anything.
                        builder.buildIntoButDoNotClobber(base.defaults, context);
                        builder.buildIntoAndClobber(base.clobbers, context);
                        builder.buildIntoAndMerge(base.merges, context);

                        builder.buildIntoButDoNotClobber(platform.defaults, context);
                        builder.buildIntoAndClobber(platform.clobbers, context);
                        builder.buildIntoAndMerge(platform.merges, context);

                        // Call the platform-specific initialization
                        platform.initialize();

                        // Fire event to notify that all objects are created
                        channel.onCordovaReady.fire();

                        // Fire onDeviceReady event once all constructors have run and
                        // cordova info has been received from native side.
                        channel.join(function() {
                            require('cordova').fireDocumentEvent('deviceready');
                        }, channel.deviceReadyChannelsArray);

                    }, [ channel.onDOMContentLoaded, channel.onNativeReady ]);
                }
            };

        // boot up once native side is ready
        channel.onNativeReady.subscribe(_self.boot);

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if (window._nativeReady) {
            channel.onNativeReady.fire();
        }

    }(window));


    })();
    var PhoneGap = cordova;

  }
}

/**
 *     readAssetsFilePlugin.js
 *     readAssetsFilePlugin PhoneGap plugin (Android)
 *
 *     Created by Tanxiangjiang on 05/21/2013.
 */
Xut.Plugin.ReadAssetsFile = {

	readAssetsFileAction: function(path, successCallback, failureCallback) {
		if (GLOBALIFRAME) {
			//客户端插件调用
			if(CLIENTCONFIGT){
				return GLOBALCONTEXT.Xut.Plugin.ReadAssetsFile.readAssetsFileAction(path, successCallback, failureCallback)
			}
			//读库
			return GLOBALCONTEXT.ReadAssetsFile.readAssetsFileAction(path, successCallback, failureCallback);
		} else {
			//正常模式
			return cordova.exec(
				successCallback,
				failureCallback,
				'ReadAssetsFile',
				'readAssetsFileAction', [path]);
		}
	}

};
/**
 * Constructor
 */
Xut.Plugin.XXTEbookInit = {

	/**
	 * Play the passed in text as synthasized speech
	 *
	 * @param {DOMString} text
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	update: function(text, successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "update", [text]);
	},

	/**
	 * Starts up the XXTEbookInit Service
	 * @param {string} databaseName
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	startup: function(databaseName,successCallback, errorCallback) {
		if (GLOBALIFRAME) {
			return successCallback();
		} else {
			return cordova.exec(successCallback, errorCallback, "XxtebookInit", "startup", [databaseName]);
		}
	},

	/**
	 * Finds out if the language is currently supported by the XXTEbookInit service.
	 *
	 * @param {DOMSting} lang
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	getInfo: function(text, successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getInfo", [text]);
	},

	/**
	 * Finds out the current language of the XXTEbookInit service.
	 *
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	getChapter: function(chapterId, successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getChapter", [chapterId]);
	},



	getPercent: function(successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getPercent", []);
	}

};
/*
 * PhoneGap is available under *either* the terms of the modified BSD license *or* the
 * MIT License (2008). See http://opensource.org/licenses/alphabetical for full text.
 *
 * Copyright (c) 2005-2010, Nitobi Software Inc.
 * Copyright (c) 2011, IBM Corporation
 */

Xut.Plugin.WebView = {
	open: function(url, left, top, height, width, mode) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.WebView.open(url, left, top, height, width, mode);
		} else {
			return cordova.exec(null, null, "WebView", "open", [url, left, top, height, width, mode]);
		}
	},
	close: function() {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.WebView.close();
		} else {
			return cordova.exec(null, null, "WebView", "close", []);
		}
	},
	flag: function(successCallback) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.WebView.flag(successCallback);
		} else {
			return cordova.exec(successCallback, null, "WebView", "flag", []);
		}
	}
};
Xut.Plugin.VideoPlayer = {
    play: function(successCallback, errorCallback, videoname, type, left, top, height, width) {
        if (GLOBALIFRAME) {
             return GLOBALCONTEXT.VideoPlayer.play(successCallback, errorCallback, videoname, 0, left, top, height, width);
        } else {
            if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
                var config = {
                    paramA: videoname, //传入地址
                    paramB: type, //传入类型 0-本地 1-网络
                    paramC: left, //上下左右表示视频的位置
                    paramD: top,
                    paramE: height,
                    paramF: width
                };
                return cordova.exec(successCallback, errorCallback, 'VideoPlayer', 'play', [config]);
            } else {
                var param = new Array();
                param[0] = videoname;
                param[1] = type;
                param[2] = left;
                param[3] = top;
                param[4] = height;
                param[5] = width;
                return cordova.exec(successCallback, errorCallback, "VideoPlayer", "play", param);


            }
        }
    },

    close: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.close(successCallback);
        } else {
            return cordova.exec(successCallback, null, "VideoPlayer", "close", []);
        }
    },

    flag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALIFRAME.VideoPlayer.flag(successCallback);
        } else {
            return cordova.exec(successCallback, null, "VideoPlayer", "flag", []);
        }
    },

    errorFlag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.errorFlag(successCallback);
        } else {
            return cordova.exec(successCallback, null, 'VideoPlayer', 'errorFlag', []);
        }
    },

    pauseFlag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.pauseFlag(successCallback);
        } else {
            return cordova.exec(successCallback, null, 'VideoPlayer', 'pauseFlag', []);
        }
    },

    windowFlag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.windowFlag(successCallback);
        } else {
            return cordova.exec(successCallback, null, "VideoPlayer", "windowFlag", []);
        }
    },

    init: function(successCallback, infilename, outfilename) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.init(successCallback, infilename, outfilename);
        } else {
            return cordova.exec(successCallback, null, 'VideoPlayer', 'init', [infilename, outfilename]);
        }
    }
};
/**
 *     AppToAppPlugin.js
 *     AppToApp PhoneGap plugin (Android)
 *
 *     Created by Tanxiangjiang on 06/11/2012.
 */
Xut.Plugin.OpenApp = {

	openAppAction: function(appName, successCallback, failureCallback) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.OpenApp.openAppAction(appName, successCallback, failureCallback);
		} else {
			return cordova.exec(
				successCallback,
				failureCallback,
				'OpenApp',
				'openAppAction', [appName]);
		}
	}

};
/**
 *  tabletPlugin.js
 *  tablet PhoneGap plugin (Android)
 *
 *  Created by Tanxiangjiang on 06/16/2012
 */
Xut.Plugin.Tablet = {

  paintPath: function(successCallback, failureCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.paintPath(successCallback, failureCallback);
    } else {
      return cordova.exec(
        successCallback,
        failureCallback,
        'Tablet',
        'paintPath', []);
    }
  },

  openAction: function(path, filename, BitmapWidth, BitmapHeight, left, top, height, weight, successCallback, failureCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.openAction(path, filename, BitmapWidth, BitmapHeight, left, top, height, weight, successCallback, failureCallback);
    } else {
      return cordova.exec(successCallback,
        failureCallback,
        'Tablet',
        'openAction', [path, filename, BitmapWidth, BitmapHeight, left, top, height, weight]);
    }
  },

  closeAction: function(successCallback, failureCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.closeAction(successCallback, failureCallback);
    } else {
      return cordova.exec(successCallback,
        failureCallback,
        'Tablet',
        'closeAction', []);
    }
  }

};
/**
 * 	aptestPlugin.js
 * 	aptestPlugin PhoneGap plugin (IOS)
 *
 * 	Created by YangQingming on 2013-07-01.
 * 	appInfo  1:hide ; 0:show
 */
Xut.Plugin.statusbarPlugin = {
	setStatus: function(successfullCallback, failedCallback, appInfo) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.XXT.plugins.statusbarPlugin.setStatus(successfullCallback, failedCallback, appInfo);
		} else {
			return cordova.exec(successfullCallback, failedCallback, 'statusbarSet', 'set', [appInfo]);
		}
	}
};

/**
 *  iap.js
 *  iap PhoneGap plugin (IOS)
 *
 *  Created by YangQingming on 2013-07-01.
 **/

Xut.Plugin.iapPlugin = {
    restore: function(successfullCallback, failedCallback, appInfo) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.iapPlugin.restore(successfullCallback, failedCallback, appInfo);
        } else {
            return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'restoreGood', [appInfo]);
        }
    },

    buyGood: function(successfullCallback, failedCallback, appInfo) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.iapPlugin.buyGood(successfullCallback, failedCallback, appInfo);
        } else {
            return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'buyIAP', [appInfo]);
        }
    },

    selectInfo: function(successfullCallback, failedCallback, appInfo) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.iapPlugin.selectInfo(successfullCallback, failedCallback, appInfo);
        } else {
            return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'selectInfo', [appInfo]);
        }
    }
};



/**
 *  AppStoreLink.js
 *  AppStoreLink PhoneGap plugin (IOS)
 *
 *  Created by HuXi on 2014-05-29.
 **/

Xut.Plugin.appStoreLinkPlugin = {
	callProductView: function(successfullCallback, failedCallback, appId) {
	    if (GLOBALIFRAME) {
	        return GLOBALCONTEXT.appStoreLinkPlugin.callProductView(successfullCallback, failedCallback, appId);
	    } else {
	        return  cordova.exec(successfullCallback, failedCallback, "AppStoreLink", "callProductView", [appId]);
	    }
	}
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

Xut.Plugin.DownloadPlugin = {

     download: function(successfullCallback, failedCallback, json) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'download', [json]);
     },

     pause: function(successfullCallback, failedCallback, url) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'pause', [url]);
     },

     downloadContinue: function(successfullCallback, failedCallback, json) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'downloadContinue', [json]);
     },

     back: function(successfullCallback, failedCallback) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'back', []);
     }
}
//txt文本插件
Xut.Plugin.bookManagerPlugins = {
	getAppOpenWay: function(successfullCallback, failedCallback) {
		return cordova.exec(successfullCallback, failedCallback, 'XxtebookManager', 'getAppOpenWay', []);
	},
	pause: function(successfullCallback, failedCallback) {

		return cordova.exec(successfullCallback, failedCallback, 'XxtebookManager', 'pause', []);
	}
}
/**
 * 	unzipPlugin.js
 * 	Unzip PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 18/6/2013.
 */

Xut.Plugin.UnzipPlugin = {
	storageAction: function(json, successCallback, failureCallback) {
		return cordova.exec(successCallback, failureCallback, 'UnzipPlugin', 'storageAction', [json]);
	}
}
/**
 * 	readPlugin.js
 * 	Read PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 18/6/2013.
 */

     Xut.Plugin.ReadPlugin = {
         loadAction: function(id, type, successCallback, failureCallback) {
             return cordova.exec(successCallback, failureCallback, 'ReadPlugin', 'loadAction', [id, type]);
         }
     };



/**
 * 	deletePlugin.js
 * 	delete PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 4/8/2013.
 *  Last-Modified  11:03 4/8/2013
 */
Xut.Plugin.DeletePlugin = {
	deleteAction: function(successCallback, failureCallback, id) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.DeletePlugin.deleteAction(directory, successCallback, failureCallback);
		} else {
			return cordova.exec(successCallback, failureCallback, 'DeletePlugin', 'deleteAction', [id]);
		}
	}
}

/*!
 * VERSION: 0.14.8
 * DATE: 2016-07-18
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Requires TweenLite and CSSPlugin version 1.17.0 or later (TweenMax contains both TweenLite and CSSPlugin). ThrowPropsPlugin is required for momentum-based continuation of movement after the mouse/touch is released (ThrowPropsPlugin is a membership benefit of Club GreenSock - http://greensock.com/club/).
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("utils.Draggable", ["events.EventDispatcher","TweenLite","plugins.CSSPlugin"], function(EventDispatcher, TweenLite, CSSPlugin) {

		var _tempVarsXY = {css:{}}, //speed optimization - we reuse the same vars object for x/y TweenLite.set() calls to minimize garbage collection tasks and improve performance.
			_tempVarsX = {css:{}},
			_tempVarsY = {css:{}},
			_tempVarsRotation = {css:{}},
			_globals = _gsScope._gsDefine.globals,
			_tempEvent = {}, //for populating with pageX/pageY in old versions of IE
			_doc = document,
			_docElement = _doc.documentElement || {},
			_createElement = function(type) {
				return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_emptyArray = [],
			_emptyFunc = function() { return false; },
			_RAD2DEG = 180 / Math.PI,
			_max = 999999999999999,
			_getTime = Date.now || function() {return new Date().getTime();},
			_isOldIE = !!(!_doc.addEventListener && _doc.all),
			_placeholderDiv = _doc.createElement("div"),
			_renderQueue = [],
			_lookup = {}, //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
			_lookupCount = 0,
			_clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
			_dragCount = 0, //total number of elements currently being dragged
			_prefix,
			_isMultiTouching,
			_isAndroid = (navigator.userAgent.toLowerCase().indexOf("android") !== -1), //Android handles touch events in an odd way and it's virtually impossible to "feature test" so we resort to UA sniffing
			_lastDragTime = 0,
			_temp1 = {}, // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.
			_windowProxy = {}, //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				if (typeof(a) === "string") {
					a = TweenLite.selector(a);
				}
				if (!a || a.nodeType) { //if it's not an array, wrap it in one.
					return [a];
				}
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_copy = function(obj) {
				var copy = {}, p;
				for (p in obj) {
					copy[p] = obj[p];
				}
				return copy;
			},
			ThrowPropsPlugin,

			_renderQueueTick = function() {
				var i = _renderQueue.length;
				while (--i > -1) {
					_renderQueue[i]();
				}
			},
			_addToRenderQueue = function(func) {
				_renderQueue.push(func);
				if (_renderQueue.length === 1) {
					TweenLite.ticker.addEventListener("tick", _renderQueueTick, this, false, 1);
				}
			},
			_removeFromRenderQueue = function(func) {
				var i = _renderQueue.length;
				while (--i > -1) {
					if (_renderQueue[i] === func) {
						_renderQueue.splice(i, 1);
					}
				}
				TweenLite.to(_renderQueueTimeout, 0, {overwrite:"all", delay:15, onComplete:_renderQueueTimeout}); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
			},
			_renderQueueTimeout = function() {
				if (!_renderQueue.length) {
					TweenLite.ticker.removeEventListener("tick", _renderQueueTick);
				}
			},

			_extend = function(obj, defaults) {
				var p;
				for (p in defaults) {
					if (obj[p] === undefined) {
						obj[p] = defaults[p];
					}
				}
				return obj;
			},
			_getDocScrollTop = function() {
				return (window.pageYOffset != null) ? window.pageYOffset : (_doc.scrollTop != null) ? _doc.scrollTop : _docElement.scrollTop || _doc.body.scrollTop || 0;
			},
			_getDocScrollLeft = function() {
				return (window.pageXOffset != null) ? window.pageXOffset : (_doc.scrollLeft != null) ? _doc.scrollLeft : _docElement.scrollLeft || _doc.body.scrollLeft || 0;
			},
			_addScrollListener = function(e, callback) {
				_addListener(e, "scroll", callback);
				if (!_isRoot(e.parentNode)) {
					_addScrollListener(e.parentNode, callback);
				}
			},
			_removeScrollListener = function(e, callback) {
				_removeListener(e, "scroll", callback);
				if (!_isRoot(e.parentNode)) {
					_removeScrollListener(e.parentNode, callback);
				}
			},
			_isRoot = function (e) {
				return !!(!e || e === _docElement || e === _doc || e === _doc.body || e === window || !e.nodeType || !e.parentNode);
			},
			_getMaxScroll = function(element, axis) {
				var dim = (axis === "x") ? "Width" : "Height",
					scroll = "scroll" + dim,
					client = "client" + dim,
					body = _doc.body;
				return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], body[scroll]) - (window["inner" + dim] || _docElement[client] || body[client]) : element[scroll] - element[client]);
			},
			_recordMaxScrolls = function(e) { //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
				var isRoot = _isRoot(e),
					x = _getMaxScroll(e, "x"),
					y = _getMaxScroll(e, "y");
				if (isRoot) {
					e = _windowProxy;
				} else {
					_recordMaxScrolls(e.parentNode);
				}
				e._gsMaxScrollX = x;
				e._gsMaxScrollY = y;
				e._gsScrollX = e.scrollLeft || 0;
				e._gsScrollY = e.scrollTop || 0;
			},

			//just used for IE8 and earlier to normalize events and populate pageX/pageY
			_populateIEEvent = function(e, preventDefault) {
				e = e || window.event;
				_tempEvent.pageX = e.clientX + _doc.body.scrollLeft + _docElement.scrollLeft;
				_tempEvent.pageY = e.clientY + _doc.body.scrollTop + _docElement.scrollTop;
				if (preventDefault) {
					e.returnValue = false;
				}
				return _tempEvent;
			},

			//grabs the first element it finds (and we include the window as an element), so if it's selector text, it'll feed that value to TweenLite.selector, if it's a jQuery object or some other selector engine's result, it'll grab the first one, and same for an array. If the value doesn't contain a DOM element, it'll just return null.
			_unwrapElement = function(value) {
				if (!value) {
					return value;
				}
				if (typeof(value) === "string") {
					value = TweenLite.selector(value);
				}
				if (value.length && value !== window && value[0] && value[0].style && !value.nodeType) {
					value = value[0];
				}
				return (value === window || (value.nodeType && value.style)) ? value : null;
			},

			_checkPrefix = function(e, p) {
				var s = e.style,
					capped, i, a;
				if (s[p] === undefined) {
					a = ["O","Moz","ms","Ms","Webkit"];
					i = 5;
					capped = p.charAt(0).toUpperCase() + p.substr(1);
					while (--i > -1 && s[a[i]+capped] === undefined) { }
					if (i < 0) {
						return "";
					}
					_prefix = (i === 3) ? "ms" : a[i];
					p = _prefix + capped;
				}
				return p;
			},

			_setStyle = function(e, p, value) {
				var s = e.style;
				if (!s) {
					return;
				}
				if (s[p] === undefined) {
					p = _checkPrefix(e, p);
				}
				if (value == null) {
					if (s.removeProperty) {
						s.removeProperty(p.replace(/([A-Z])/g, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				} else if (s[p] !== undefined) {
					s[p] = value;
				}
			},

			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : _emptyFunc,
			_horizExp = /(?:Left|Right|Width)/i,
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || !sfx) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					pix;
				if (neg) {
					v = -v;
				}
				if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position", true) + ";line-height:0;";
					if (sfx === "%" || !node.appendChild) {
						node = t.parentNode || _doc.body;
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = function(t, p) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", true) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, true);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), (v + "").replace(_suffixExp, "")) || 0);
			},

			_getStyle = function(element, prop, keepUnits) {
				var rv = (element._gsTransform || {})[prop],
					cs;
				if (rv || rv === 0) {
					return rv;
				} else if (element.style[prop]) {
					rv = element.style[prop];
				} else if ((cs = _getComputedStyle(element))) {
					rv = cs.getPropertyValue(prop.replace(/([A-Z])/g, "-$1").toLowerCase());
					rv = (rv || cs.length) ? rv : cs[prop]; //Opera behaves VERY strangely - length is usually 0 and cs[prop] is the only way to get accurate results EXCEPT when checking for -o-transform which only works with cs.getPropertyValue()!
				} else if (element.currentStyle) {
					rv = element.currentStyle[prop];
				}
				if (rv === "auto" && (prop === "top" || prop === "left")) {
					rv = _calculateOffset(element, prop);
				}
				return keepUnits ? rv : parseFloat(rv) || 0;
			},

			_dispatchEvent = function(instance, type, callbackName) {
				var vars = instance.vars,
					callback = vars[callbackName],
					listeners = instance._listeners[type];
				if (typeof(callback) === "function") {
					callback.apply(vars[callbackName + "Scope"] || vars.callbackScope || instance, vars[callbackName + "Params"] || [instance.pointerEvent]);
				}
				if (listeners) {
					instance.dispatchEvent(type);
				}
			},
			_getBounds = function(obj, context) { //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
				var e = _unwrapElement(obj),
					top, left, offset;
				if (!e) {
					if (obj.left !== undefined) {
						offset = _getOffsetTransformOrigin(context); //the bounds should be relative to the origin
						return {left: obj.left - offset.x, top: obj.top - offset.y, width: obj.width, height: obj.height};
					}
					left = obj.min || obj.minX || obj.minRotation || 0;
					top = obj.min || obj.minY || 0;
					return {left:left, top:top, width:(obj.max || obj.maxX || obj.maxRotation || 0) - left, height:(obj.max || obj.maxY || 0) - top};
				}
				return _getElementBounds(e, context);
			},

			_svgBorderFactor,
			_svgBorderScales,
			_svgScrollOffset,
			_hasBorderBug,
			_hasReparentBug,//some browsers, like Chrome 49, alter the offsetTop/offsetLeft/offsetParent of elements when a non-identity transform is applied.
			_setEnvironmentVariables = function() { //some browsers factor the border into the SVG coordinate space, some don't (like Firefox). Some apply transforms to them, some don't. We feature-detect here so we know how to handle the border(s). We can't do this immediately - we must wait for the document.body to exist.
				if (!_doc.createElementNS) {
					_svgBorderFactor = 0;
					_svgBorderScales = false;
					return;
				}
				var div = _createElement("div"),
					svg = _doc.createElementNS("http://www.w3.org/2000/svg", "svg"),
					wrapper = _createElement("div"),
					style = div.style,
					parent = _doc.body || _docElement,
					matrix, e1, point, oldValue;
				if (_doc.body && _transformProp) {
					style.position = "absolute";
					parent.appendChild(wrapper);
					wrapper.appendChild(div);
					oldValue = div.offsetParent;
					wrapper.style[_transformProp] = "rotate(1deg)";
					_hasReparentBug = (div.offsetParent === oldValue);
					wrapper.style.position = "absolute";
					style.height = "10px";
					oldValue = div.offsetTop;
					wrapper.style.border = "5px solid red";
					_hasBorderBug = (oldValue !== div.offsetTop); //some browsers, like Firefox 38, cause the offsetTop/Left to be affected by a parent's border.
					parent.removeChild(wrapper);
				}
				style = svg.style;
				svg.setAttributeNS(null, "width", "400px");
				svg.setAttributeNS(null, "height", "400px");
				svg.setAttributeNS(null, "viewBox", "0 0 400 400");
				style.display = "block";
				style.boxSizing = "border-box";
				style.border = "0px solid red";
				style.transform = "none";
				// in some browsers (like certain flavors of Android), the getScreenCTM() matrix is contaminated by the scroll position. We can run some logic here to detect that condition, but we ended up not needing this because we found another workaround using getBoundingClientRect().
				div.style.cssText = "width:100px;height:100px;overflow:scroll;-ms-overflow-style:none;";
				parent.appendChild(div);
				div.appendChild(svg);
				point = svg.createSVGPoint().matrixTransform(svg.getScreenCTM());
				e1 = point.y;
				div.scrollTop = 100;
				point.x = point.y = 0;
				point = point.matrixTransform(svg.getScreenCTM());
				_svgScrollOffset = (e1 - point.y < 100.1) ? 0 : e1 - point.y - 150;
				div.removeChild(svg);
				parent.removeChild(div);
				// -- end _svgScrollOffset calculation.
				parent.appendChild(svg);
				matrix = svg.getScreenCTM();
				e1 = matrix.e;
				style.border = "50px solid red";
				matrix = svg.getScreenCTM();
				if (e1 === 0 && matrix.e === 0 && matrix.f === 0 && matrix.a === 1) { //Opera has a bunch of bugs - it doesn't adjust the x/y of the matrix, nor does it scale when box-sizing is border-box but it does so elsewhere; to get the correct behavior we set _svgBorderScales to true.
					_svgBorderFactor = 1;
					_svgBorderScales = true;
				} else {
					_svgBorderFactor = (e1 !== matrix.e) ? 1 : 0;
					_svgBorderScales = (matrix.a !== 1);
				}
				parent.removeChild(svg);
			},

			_supports3D = (_checkPrefix(_tempDiv, "perspective") !== ""),

			// start matrix and point conversion methods...
			_transformOriginProp = _checkPrefix(_tempDiv, "transformOrigin").replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
			_transformProp = _checkPrefix(_tempDiv, "transform"),
			_transformPropCSS = _transformProp.replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
			_point1 = {}, //we reuse _point1 and _point2 objects inside matrix and point conversion methods to conserve memory and minimize garbage collection tasks.
			_point2 = {},
			_SVGElement = window.SVGElement,
			_isSVG = function(e) {
				return !!(_SVGElement && typeof(e.getBBox) === "function" && e.getCTM && (!e.parentNode || (e.parentNode.getBBox && e.parentNode.getCTM)));
			},
			_isIE10orBelow = (((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(navigator.userAgent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(navigator.userAgent)) && parseFloat( RegExp.$1 ) < 11), //Ideally we'd avoid user agent sniffing, but there doesn't seem to be a way to feature-detect and sense a border-related bug that only affects IE10 and IE9.
			_tempTransforms = [],
			_tempElements = [],
			_getSVGOffsets = function(e) { //SVG elements don't always report offsetTop/offsetLeft/offsetParent at all (I'm looking at you, Firefox 29 and Android), so we have to do some work to manufacture those values. You can pass any SVG element and it'll spit back an object with offsetTop, offsetLeft, offsetParent, scaleX, and scaleY properties. We need the scaleX and scaleY to handle the way SVG can resize itself based on the container.
				if (!e.getBoundingClientRect || !e.parentNode || !_transformProp) {
					return {offsetTop:0, offsetLeft:0, scaleX:1, scaleY:1, offsetParent:_docElement};
				}
				if (Draggable.cacheSVGData !== false && e._gsCache && e._gsCache.lastUpdate === TweenLite.ticker.frame) { //performance optimization. Assume that if the offsets are requested again on the same tick, we can just feed back the values we already calculated (no need to keep recalculating until another tick elapses).
					return e._gsCache;
				}
				var curElement = e,
					cache = _cache(e),
					eRect, parentRect, offsetParent, cs, m, i, point1, point2, borderWidth, borderHeight, width, height;
				cache.lastUpdate = TweenLite.ticker.frame;
				if (e.getBBox && !cache.isSVGRoot) { //if it's a nested/child SVG element, we must find the parent SVG canvas and measure the offset from there.
					curElement = e.parentNode;
					eRect = e.getBBox();
					while (curElement && (curElement.nodeName + "").toLowerCase() !== "svg") {
						curElement = curElement.parentNode;
					}
					cs = _getSVGOffsets(curElement);
					cache.offsetTop = eRect.y * cs.scaleY;
					cache.offsetLeft = eRect.x * cs.scaleX;
					cache.scaleX = cs.scaleX;
					cache.scaleY = cs.scaleY;
					cache.offsetParent = curElement || _docElement;
					return cache;
				}
				//only root SVG elements continue here...
				offsetParent = cache.offsetParent;
				if (offsetParent === _doc.body) {
					offsetParent = _docElement; //avoids problems with margins/padding on the body
				}
				//walk up the ancestors and record any non-identity transforms (and reset them to "none") until we reach the offsetParent. We must do this so that the getBoundingClientRect() is accurate for measuring the offsetTop/offsetLeft. We'll revert the values later...
				_tempElements.length = _tempTransforms.length = 0;
				while (curElement) {
					m = _getStyle(curElement, _transformProp, true);
					if (m !== "matrix(1, 0, 0, 1, 0, 0)" && m !== "none" && m !== "translate3d(0px, 0px, 0px)") {
						_tempElements.push(curElement);
						_tempTransforms.push(curElement.style[_transformProp]);
						curElement.style[_transformProp] = "none";
					}
					if (curElement === offsetParent) {
						break;
					}
					curElement = curElement.parentNode;
				}
				parentRect = offsetParent.getBoundingClientRect();
				m = e.getScreenCTM();
				point2 = e.createSVGPoint();
				point1 = point2.matrixTransform(m);
				point2.x = point2.y = 10;
				point2 = point2.matrixTransform(m);
				cache.scaleX = (point2.x - point1.x) / 10;
				cache.scaleY = (point2.y - point1.y) / 10;
				if (_svgBorderFactor === undefined) {
					_setEnvironmentVariables();
				}
				if (cache.borderBox && !_svgBorderScales && e.getAttribute("width")) { //some browsers (like Safari) don't properly scale the matrix to accommodate the border when box-sizing is border-box, so we must calculate it here...
					cs = _getComputedStyle(e) || {};
					borderWidth = (parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth)) || 0;
					borderHeight = (parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth)) || 0;
					width = parseFloat(cs.width) || 0;
					height = parseFloat(cs.height) || 0;
					cache.scaleX *= (width - borderWidth) / width;
					cache.scaleY *= (height - borderHeight) / height;
				}
				if (_svgScrollOffset) { //some browsers (like Chrome for Android) have bugs in the way getScreenCTM() is reported (it doesn't factor in scroll position), so we must revert to a more expensive technique for calculating offsetTop/Left.
					eRect = e.getBoundingClientRect();
					cache.offsetLeft = eRect.left - parentRect.left;
					cache.offsetTop = eRect.top - parentRect.top;
				} else {
					cache.offsetLeft = point1.x - parentRect.left;
					cache.offsetTop = point1.y - parentRect.top;
				}
				cache.offsetParent = offsetParent;
				i = _tempElements.length;
				while (--i > -1) {
					_tempElements[i].style[_transformProp] = _tempTransforms[i];
				}
				return cache;
			},
			_getOffsetTransformOrigin = function(e, decoratee) { //returns the x/y position of the transformOrigin of the element, in its own local coordinate system (pixels), offset from the top left corner.
				decoratee = decoratee || {};
				if (!e || e === _docElement || !e.parentNode || e === window) {
					return {x:0, y:0};
				}
				var cs = _getComputedStyle(e),
					v = (_transformOriginProp && cs) ? cs.getPropertyValue(_transformOriginProp) : "50% 50%",
					a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];
				if (y === "center" || y == null) {
					y = "50%";
				}
				if (x === "center" || isNaN(parseFloat(x))) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				if (e.getBBox && _isSVG(e)) { //SVG elements must be handled in a special way because their origins are calculated from the top left.
					if (!e._gsTransform) {
						TweenLite.set(e, {x:"+=0", overwrite:false}); //forces creation of the _gsTransform where we store all the transform components including xOrigin and yOrigin for SVG elements, as of GSAP 1.15.0 which also takes care of calculating the origin from the upper left corner of the SVG canvas.
						if (e._gsTransform.xOrigin === undefined) {
							console.log("Draggable requires at least GSAP 1.17.0");
						}
					}
					v = e.getBBox();
					decoratee.x = (e._gsTransform.xOrigin - v.x);
					decoratee.y = (e._gsTransform.yOrigin - v.y);
				} else {
					if (e.getBBox && (x + y).indexOf("%") !== -1) { //Firefox doesn't report offsetWidth/height on <svg> elements.
						e = e.getBBox();
						e = {offsetWidth: e.width, offsetHeight: e.height};
					}
					decoratee.x = ((x.indexOf("%") !== -1) ? e.offsetWidth * parseFloat(x) / 100 : parseFloat(x));
					decoratee.y = ((y.indexOf("%") !== -1) ? e.offsetHeight * parseFloat(y) / 100 : parseFloat(y));

				}
				return decoratee;
			},
			_cache = function(e) { //computes some important values and stores them in a _gsCache object attached to the element itself so that we can optimize performance
				if (Draggable.cacheSVGData !== false && e._gsCache && e._gsCache.lastUpdate === TweenLite.ticker.frame) { //performance optimization. Assume that if the offsets are requested again on the same tick, we can just feed back the values we already calculated (no need to keep recalculating until another tick elapses).
					return e._gsCache;
				}
				var cache = e._gsCache = e._gsCache || {},
					cs = _getComputedStyle(e),
					isSVG = (e.getBBox && _isSVG(e)),
					isSVGRoot = ((e.nodeName + "").toLowerCase() === "svg"),
					curSVG;
				cache.isSVG = isSVG;
				cache.isSVGRoot = isSVGRoot;
				cache.borderBox = (cs.boxSizing === "border-box");
				cache.computedStyle = cs;
				if (isSVGRoot) { //some browsers don't report parentNode on SVG elements.
					curSVG = e.parentNode || _docElement;
					curSVG.insertBefore(_tempDiv, e);
					cache.offsetParent = _tempDiv.offsetParent || _docElement; //in some cases, Firefox still reports offsetParent as null.
					curSVG.removeChild(_tempDiv);
				} else if (isSVG) {
					curSVG = e.parentNode;
					while (curSVG && (curSVG.nodeName + "").toLowerCase() !== "svg") { //offsetParent is always the SVG canvas for SVG elements.
						curSVG = curSVG.parentNode;
					}
					cache.offsetParent = curSVG;
				} else {
					cache.offsetParent = e.offsetParent;
				}
				return cache;
			},
			_getOffset2DMatrix = function(e, offsetOrigin, parentOffsetOrigin, zeroOrigin) {
				if (e === window || !e || !e.style || !e.parentNode) {
					return [1,0,0,1,0,0];
				}
				var cache = e._gsCache || _cache(e),
					parent = e.parentNode,
					parentCache = parent._gsCache || _cache(parent),
					cs = cache.computedStyle,
					parentOffsetParent = cache.isSVG ? parentCache.offsetParent : parent.offsetParent,
					m, isRoot, offsets, rect, t, sx, sy, offsetX, offsetY, parentRect, borderTop, borderLeft, borderTranslateX, borderTranslateY;
				m = (cache.isSVG && (e.style[_transformProp] + "").indexOf("matrix") !== -1) ? e.style[_transformProp] : cs ? cs.getPropertyValue(_transformPropCSS) : e.currentStyle ? e.currentStyle[_transformProp] : "1,0,0,1,0,0"; //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values

				if (e.getBBox && (e.getAttribute("transform") + "").indexOf("matrix") !== -1) { //SVG can store transform data in its "transform" attribute instead of the CSS, so look for that here (only accept matrix()).
					m = e.getAttribute("transform");
				}
				m = (m + "").match(/(?:\-|\.|\b)(\d|\.|e\-)+/g) || [1,0,0,1,0,0];
				if (m.length > 6) {
					m = [m[0], m[1], m[4], m[5], m[12], m[13]];
				}
				if (zeroOrigin) {
					m[4] = m[5] = 0;
				} else if (cache.isSVG && (t = e._gsTransform) && (t.xOrigin || t.yOrigin)) {
					//SVGs handle origin very differently. Factor in GSAP's handling of origin values here:
					m[0] = parseFloat(m[0]);
					m[1] = parseFloat(m[1]);
					m[2] = parseFloat(m[2]);
					m[3] = parseFloat(m[3]);
					m[4] = parseFloat(m[4]) - (t.xOrigin - (t.xOrigin * m[0] + t.yOrigin * m[2]));
					m[5] = parseFloat(m[5]) - (t.yOrigin - (t.xOrigin * m[1] + t.yOrigin * m[3]));
				}
				if (offsetOrigin) {
					if (_svgBorderFactor === undefined) {
						_setEnvironmentVariables();
					}
					offsets = (cache.isSVG || cache.isSVGRoot) ? _getSVGOffsets(e) : e;
					if (cache.isSVG) { //don't just rely on "instanceof _SVGElement" because if the SVG is embedded via an object tag, it won't work (SVGElement is mapped to a different object))
						rect = e.getBBox();
						parentRect = (parentCache.isSVGRoot) ? {x:0, y:0} : parent.getBBox();
						offsets = {offsetLeft:rect.x - parentRect.x, offsetTop:rect.y - parentRect.y, offsetParent:cache.offsetParent};
					} else if (cache.isSVGRoot) {
						borderTop = parseInt(cs.borderTopWidth, 10) || 0;
						borderLeft = parseInt(cs.borderLeftWidth, 10) || 0;
						borderTranslateX = ((m[0] - _svgBorderFactor) * borderLeft + m[2] * borderTop);
						borderTranslateY = (m[1] * borderLeft + (m[3] - _svgBorderFactor) * borderTop);

						sx = offsetOrigin.x;
						sy = offsetOrigin.y;
						offsetX = (sx - (sx * m[0] + sy * m[2])); //accommodate the SVG root's transforms when the origin isn't in the top left.
						offsetY = (sy - (sx * m[1] + sy * m[3]));

						m[4] = parseFloat(m[4]) + offsetX;
						m[5] = parseFloat(m[5]) + offsetY;
						offsetOrigin.x -= offsetX;
						offsetOrigin.y -= offsetY;
						sx = offsets.scaleX;
						sy = offsets.scaleY;
						offsetOrigin.x *= sx;
						offsetOrigin.y *= sy;
						m[0] *= sx;
						m[1] *= sy;
						m[2] *= sx;
						m[3] *= sy;

						if (!_isIE10orBelow) {
							offsetOrigin.x += borderTranslateX;
							offsetOrigin.y += borderTranslateY;
						}
					} else if (!_hasBorderBug && e.offsetParent) {
						offsetOrigin.x += parseInt(_getStyle(e.offsetParent, "borderLeftWidth"), 10) || 0;
						offsetOrigin.y += parseInt(_getStyle(e.offsetParent, "borderTopWidth"), 10) || 0;
					}
					isRoot = (parent === _docElement || parent === _doc.body);
					m[4] = Number(m[4]) + offsetOrigin.x + (offsets.offsetLeft || 0) - parentOffsetOrigin.x - (isRoot ? 0 : parent.scrollLeft || 0);
					m[5] = Number(m[5]) + offsetOrigin.y + (offsets.offsetTop || 0) - parentOffsetOrigin.y - (isRoot ? 0 : parent.scrollTop || 0);
					if (parent && _getStyle(e, "position", cs) === "fixed") { //fixed position elements should factor in the scroll position of the document.
						m[4] += _getDocScrollLeft();
						m[5] += _getDocScrollTop();
					}
					if (parent && parent !== _docElement && parentOffsetParent === offsets.offsetParent && !parentCache.isSVG && (!_hasReparentBug || _getOffset2DMatrix(parent).join("") === "100100")) {
						offsets = (parentCache.isSVGRoot) ? _getSVGOffsets(parent) : parent;
						m[4] -= offsets.offsetLeft || 0;
						m[5] -= offsets.offsetTop || 0;
						if (!_hasBorderBug && parentCache.offsetParent && !cache.isSVG && !cache.isSVGRoot) {
							m[4] -= parseInt(_getStyle(parentCache.offsetParent, "borderLeftWidth"), 10) || 0;
							m[5] -= parseInt(_getStyle(parentCache.offsetParent, "borderTopWidth"), 10) || 0;
						}
					}
				}
				return m;
			},
			_getConcatenatedMatrix = function(e, invert) {
				if (!e || e === window || !e.parentNode) {
					return [1,0,0,1,0,0];
				}
				//note: we keep reusing _point1 and _point2 in order to minimize memory usage and garbage collection chores.
				var originOffset = _getOffsetTransformOrigin(e, _point1),
					parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, _point2),
					m = _getOffset2DMatrix(e, originOffset, parentOriginOffset),
					a, b, c, d, tx, ty, m2, determinant;
				while ((e = e.parentNode) && e.parentNode && e !== _docElement) {
					originOffset = parentOriginOffset;
					parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, (originOffset === _point1) ? _point2 : _point1);
					m2 = _getOffset2DMatrix(e, originOffset, parentOriginOffset);
					a = m[0];
					b = m[1];
					c = m[2];
					d = m[3];
					tx = m[4];
					ty = m[5];
					m[0] = a * m2[0] + b * m2[2];
					m[1] = a * m2[1] + b * m2[3];
					m[2] = c * m2[0] + d * m2[2];
					m[3] = c * m2[1] + d * m2[3];
					m[4] = tx * m2[0] + ty * m2[2] + m2[4];
					m[5] = tx * m2[1] + ty * m2[3] + m2[5];
				}
				if (invert) {
					a = m[0];
					b = m[1];
					c = m[2];
					d = m[3];
					tx = m[4];
					ty = m[5];
					determinant = (a * d - b * c);
					m[0] = d / determinant;
					m[1] = -b / determinant;
					m[2] = -c / determinant;
					m[3] = a / determinant;
					m[4] = (c * ty - d * tx) / determinant;
					m[5] = -(a * ty - b * tx) / determinant;
				}
				return m;
			},
			_localToGlobal = function(e, p, fromTopLeft, decoratee, zeroOrigin) {
				e = _unwrapElement(e);
				var m = _getConcatenatedMatrix(e, false, zeroOrigin),
					x = p.x,
					y = p.y;
				if (fromTopLeft) {
					_getOffsetTransformOrigin(e, p);
					x -= p.x;
					y -= p.y;
				}
				decoratee = (decoratee === true) ? p : decoratee || {};
				decoratee.x = x * m[0] + y * m[2] + m[4];
				decoratee.y = x * m[1] + y * m[3] + m[5];
				return decoratee;
			},
			_localizePoint = function(p, localToGlobal, globalToLocal) {
				var x = p.x * localToGlobal[0] + p.y * localToGlobal[2] + localToGlobal[4],
					y = p.x * localToGlobal[1] + p.y * localToGlobal[3] + localToGlobal[5];
				p.x = x * globalToLocal[0] + y * globalToLocal[2] + globalToLocal[4];
				p.y = x * globalToLocal[1] + y * globalToLocal[3] + globalToLocal[5];
				return p;
			},

			_getElementBounds = function(e, context, fromTopLeft) {
				if (!(e = _unwrapElement(e))) {
					return null;
				}
				context = _unwrapElement(context);
				var isSVG = (e.getBBox && _isSVG(e)),
					origin, left, right, top, bottom, mLocalToGlobal, mGlobalToLocal, p1, p2, p3, p4, bbox, width, height, cache, borderLeft, borderTop, viewBox, viewBoxX, viewBoxY, computedDimensions, cs;
				if (e === window) {
					top = _getDocScrollTop();
					left = _getDocScrollLeft();
					right = left + (_docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0);
					bottom = top + (((e.innerHeight || 0) - 20 < _docElement.clientHeight) ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.
				} else if (context === undefined || context === window) {
					return e.getBoundingClientRect();
				} else {
					origin = _getOffsetTransformOrigin(e);
					left = -origin.x;
					top = -origin.y;
					if (isSVG) {
						bbox = e.getBBox();
						width = bbox.width;
						height = bbox.height;
					} else if ((e.nodeName + "").toLowerCase() !== "svg" && e.offsetWidth) { //Chrome dropped support for "offsetWidth" on SVG elements
						width = e.offsetWidth;
						height = e.offsetHeight;
					} else {
						computedDimensions = _getComputedStyle(e);
						width = parseFloat(computedDimensions.width);
						height = parseFloat(computedDimensions.height);
					}
					right = left + width;
					bottom = top + height;
					if (e.nodeName.toLowerCase() === "svg" && !_isOldIE) { //root SVG elements are a special beast because they have 2 types of scaling - transforms on themselves as well as the stretching of the SVG canvas itself based on the outer size and the viewBox. If, for example, the SVG's viewbox is "0 0 100 100" but the CSS is set to width:200px; height:200px, that'd make it appear at 2x scale even though the element itself has no CSS transforms but the offsetWidth/offsetHeight are based on that css, not the viewBox so we need to adjust them accordingly.
						cache = _getSVGOffsets(e);
						cs = cache.computedStyle || {};
						viewBox = (e.getAttribute("viewBox") || "0 0").split(" ");
						viewBoxX = parseFloat(viewBox[0]);
						viewBoxY = parseFloat(viewBox[1]);
						borderLeft = parseFloat(cs.borderLeftWidth) || 0;
						borderTop = parseFloat(cs.borderTopWidth) || 0;
						right -= width - ((width - borderLeft) / cache.scaleX) - viewBoxX;
						bottom -= height - ((height - borderTop) / cache.scaleY) - viewBoxY;
						left -= borderLeft / cache.scaleX - viewBoxX;
						top -= borderTop / cache.scaleY - viewBoxY;
						if (computedDimensions) { //when we had to use computed styles, factor in the border now.
							right += (parseFloat(cs.borderRightWidth) + borderLeft) / cache.scaleX;
							bottom += (borderTop + parseFloat(cs.borderBottomWidth)) / cache.scaleY;
						}
					}
				}
				if (e === context) {
					return {left:left, top:top, width: right - left, height: bottom - top};
				}
				mLocalToGlobal = _getConcatenatedMatrix(e);
				mGlobalToLocal = _getConcatenatedMatrix(context, true);
				p1 = _localizePoint({x:left, y:top}, mLocalToGlobal, mGlobalToLocal);
				p2 = _localizePoint({x:right, y:top}, mLocalToGlobal, mGlobalToLocal);
				p3 = _localizePoint({x:right, y:bottom}, mLocalToGlobal, mGlobalToLocal);
				p4 = _localizePoint({x:left, y:bottom}, mLocalToGlobal, mGlobalToLocal);
				left = Math.min(p1.x, p2.x, p3.x, p4.x);
				top = Math.min(p1.y, p2.y, p3.y, p4.y);
				_temp1.x = _temp1.y = 0;
				if (fromTopLeft) {
					_getOffsetTransformOrigin(context, _temp1);
				}
				return {left:left + _temp1.x, top:top + _temp1.y, width:Math.max(p1.x, p2.x, p3.x, p4.x) - left, height:Math.max(p1.y, p2.y, p3.y, p4.y) - top};
			},
			// end matrix and point conversion methods



			_isArrayLike = function(e) {
				return (e && e.length && e[0] && ((e[0].nodeType && e[0].style && !e.nodeType) || (e[0].length && e[0][0]))) ? true : false; //could be an array of jQuery objects too, so accommodate that.
			},

			_flattenArray = function(a) {
				var result = [],
					l = a.length,
					i, e, j;
				for (i = 0; i < l; i++) {
					e = a[i];
					if (_isArrayLike(e)) {
						j = e.length;
						for (j = 0; j < e.length; j++) {
							result.push(e[j]);
						}
					} else if (e && e.length !== 0) {
						result.push(e);
					}
				}
				return result;
			},

			_isTouchDevice = (("ontouchstart" in _docElement) && ("orientation" in window)),
			_touchEventLookup = (function(types) { //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
				var standard = types.split(","),
					converted = ((_tempDiv.onpointerdown !== undefined) ? "pointerdown,pointermove,pointerup,pointercancel" : (_tempDiv.onmspointerdown !== undefined) ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
					obj = {},
					i = 8;
				while (--i > -1) {
					obj[standard[i]] = converted[i];
					obj[converted[i]] = standard[i];
				}
				return obj;
			}("touchstart,touchmove,touchend,touchcancel")),

			_addListener = function(element, type, func, capture) {
				if (element.addEventListener) {
					element.addEventListener(_touchEventLookup[type] || type, func, capture);
				} else if (element.attachEvent) {
					element.attachEvent("on" + type, func);
				}
			},

			_removeListener = function(element, type, func) {
				if (element.removeEventListener) {
					element.removeEventListener(_touchEventLookup[type] || type, func);
				} else if (element.detachEvent) {
					element.detachEvent("on" + type, func);
				}
			},

			_hasTouchID = function(list, ID) {
				var i = list.length;
				while (--i > -1) {
					if (list[i].identifier === ID) {
						return true;
					}
				}
				return false;
			},

			_onMultiTouchDocumentEnd = function(e) {
				_isMultiTouching = (e.touches && _dragCount < e.touches.length);
				_removeListener(e.target, "touchend", _onMultiTouchDocumentEnd);
			},

			_onMultiTouchDocument = function(e) {
				_isMultiTouching = (e.touches && _dragCount < e.touches.length);
				_addListener(e.target, "touchend", _onMultiTouchDocumentEnd);
			},

			_parseThrowProps = function(draggable, snap, max, min, factor, forceZeroVelocity) {
				var vars = {},
					a, i, l;
				if (snap) {
					if (factor !== 1 && snap instanceof Array) { //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
						vars.end = a = [];
						l = snap.length;
						for (i = 0; i < l; i++) {
							a[i] = snap[i] * factor;
						}
						max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.
						min -= 1.1;
					} else if (typeof(snap) === "function") {
						vars.end = function(value) {
							return snap.call(draggable, value) * factor; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
						};
					} else {
						vars.end = snap;
					}
				}
				if (max || max === 0) {
					vars.max = max;
				}
				if (min || min === 0) {
					vars.min = min;
				}
				if (forceZeroVelocity) {
					vars.velocity = 0;
				}
				return vars;
			},

			_isClickable = function(e) { //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
				var data;
				return (!e || !e.getAttribute || e.nodeName === "BODY") ? false : ((data = e.getAttribute("data-clickable")) === "true" || (data !== "false" && (e.onclick || _clickableTagExp.test(e.nodeName + "") || e.getAttribute("contentEditable") === "true"))) ? true : _isClickable(e.parentNode);
			},

			_setSelectable = function(elements, selectable) {
				var i = elements.length,
					e;
				while (--i > -1) {
					e = elements[i];
					e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;
					_setStyle(e, "userSelect", (selectable ? "text" : "none"));
				}
			},

			_addPaddingBR,
			_addPaddingLeft = (function() { //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
				var div = _doc.createElement("div"),
					child = _doc.createElement("div"),
					childStyle = child.style,
					parent = _doc.body || _tempDiv,
					val;
				childStyle.display = "inline-block";
				childStyle.position = "relative";
				div.style.cssText = child.innerHTML = "width:90px; height:40px; padding:10px; overflow:auto; visibility: hidden";
				div.appendChild(child);
				parent.appendChild(div);
				_addPaddingBR = (child.offsetHeight + 18 > div.scrollHeight); //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.
				childStyle.width = "100%";
				if (!_transformProp) {
					childStyle.paddingRight = "500px";
					val = div.scrollLeft = div.scrollWidth - div.clientWidth;
					childStyle.left = "-90px";
					val = (val !== div.scrollLeft);
				}
				parent.removeChild(div);
				return val;
			}()),




			//The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
			ScrollProxy = function(element, vars) {
				element = _unwrapElement(element);
				vars = vars || {};
				var content = _doc.createElement("div"),
					style = content.style,
					node = element.firstChild,
					offsetTop = 0,
					offsetLeft = 0,
					prevTop = element.scrollTop,
					prevLeft = element.scrollLeft,
					scrollWidth = element.scrollWidth,
					scrollHeight = element.scrollHeight,
					extraPadRight = 0,
					maxLeft = 0,
					maxTop = 0,
					elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;

				if (_supports3D && vars.force3D !== false) {
					transformStart = "translate3d(";
					transformEnd = "px,0px)";
				} else if (_transformProp) {
					transformStart = "translate(";
					transformEnd = "px)";
				}

				this.scrollTop = function(value, force) {
					if (!arguments.length) {
						return -this.top();
					}
					this.top(-value, force);
				};

				this.scrollLeft = function(value, force) {
					if (!arguments.length) {
						return -this.left();
					}
					this.left(-value, force);
				};

				this.left = function(value, force) {
					if (!arguments.length) {
						return -(element.scrollLeft + offsetLeft);
					}
					var dif = element.scrollLeft - prevLeft,
						oldOffset = offsetLeft;
					if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
						prevLeft = element.scrollLeft;
						TweenLite.killTweensOf(this, true, {left:1, scrollLeft:1});
						this.left(-prevLeft);
						if (vars.onKill) {
							vars.onKill();
						}
						return;
					}
					value = -value; //invert because scrolling works in the opposite direction
					if (value < 0) {
						offsetLeft = (value - 0.5) | 0;
						value = 0;
					} else if (value > maxLeft) {
						offsetLeft = (value - maxLeft) | 0;
						value = maxLeft;
					} else {
						offsetLeft = 0;
					}
					if (offsetLeft || oldOffset) {
						if (transformStart) {
							if (!this._suspendTransforms) {
								style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
							}
						} else {
							style.left = -offsetLeft + "px";
						}
						if (_addPaddingLeft && offsetLeft + extraPadRight >= 0) {
							style.paddingRight = offsetLeft + extraPadRight + "px";
						}
					}
					element.scrollLeft = value | 0;
					prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjsut the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
				};

				this.top = function(value, force) {
					if (!arguments.length) {
						return -(element.scrollTop + offsetTop);
					}
					var dif = element.scrollTop - prevTop,
						oldOffset = offsetTop;
					if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
						prevTop = element.scrollTop;
						TweenLite.killTweensOf(this, true, {top:1, scrollTop:1});
						this.top(-prevTop);
						if (vars.onKill) {
							vars.onKill();
						}
						return;
					}
					value = -value; //invert because scrolling works in the opposite direction
					if (value < 0) {
						offsetTop = (value - 0.5) | 0;
						value = 0;
					} else if (value > maxTop) {
						offsetTop = (value - maxTop) | 0;
						value = maxTop;
					} else {
						offsetTop = 0;
					}
					if (offsetTop || oldOffset) {
						if (transformStart) {
							if (!this._suspendTransforms) {
								style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
							}
						} else {
							style.top = -offsetTop + "px";
						}
					}
					element.scrollTop = value | 0;
					prevTop = element.scrollTop;
				};

				this.maxScrollTop = function() {
					return maxTop;
				};

				this.maxScrollLeft = function() {
					return maxLeft;
				};

				this.disable = function() {
					node = content.firstChild;
					while (node) {
						nextNode = node.nextSibling;
						element.appendChild(node);
						node = nextNode;
					}
					if (element === content.parentNode) { //in case disable() is called when it's already disabled.
						element.removeChild(content);
					}
				};

				this.enable = function() {
					node = element.firstChild;
					if (node === content) {
						return;
					}
					while (node) {
						nextNode = node.nextSibling;
						content.appendChild(node);
						node = nextNode;
					}
					element.appendChild(content);
					this.calibrate();
				};

				this.calibrate = function(force) {
					var widthMatches = (element.clientWidth === elementWidth),
						x, y;
					prevTop = element.scrollTop;
					prevLeft = element.scrollLeft;
					if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
						return; //no need to recalculate things if the width and height haven't changed.
					}
					if (offsetTop || offsetLeft) {
						x = this.left();
						y = this.top();
						this.left(-element.scrollLeft);
						this.top(-element.scrollTop);
					}
					//first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)
					if (!widthMatches || force) {
						style.display = "block";
						style.width = "auto";
						style.paddingRight = "0px";
						extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
						//if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.
						if (extraPadRight) {
							extraPadRight += _getStyle(element, "paddingLeft") + (_addPaddingBR ? _getStyle(element, "paddingRight") : 0);
						}
					}
					style.display = "inline-block";
					style.position = "relative";
					style.overflow = "visible";
					style.verticalAlign = "top";
					style.width = "100%";
					style.paddingRight = extraPadRight + "px";
					//some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error
					if (_addPaddingBR) {
						style.paddingBottom = _getStyle(element, "paddingBottom", true);
					}
					if (_isOldIE) {
						style.zoom = "1";
					}
					elementWidth = element.clientWidth;
					elementHeight = element.clientHeight;
					scrollWidth = element.scrollWidth;
					scrollHeight = element.scrollHeight;
					maxLeft = element.scrollWidth - elementWidth;
					maxTop = element.scrollHeight - elementHeight;
					contentHeight = content.offsetHeight;
					style.display = "block";
					if (x || y) {
						this.left(x);
						this.top(y);
					}
				};

				this.content = content;
				this.element = element;
				this._suspendTransforms = false;
				this.enable();
			},





			Draggable = function(target, vars) {
				EventDispatcher.call(this, target);
				target = _unwrapElement(target); //in case the target is a selector object or selector text
				if (!ThrowPropsPlugin) {
					ThrowPropsPlugin = _globals.com.greensock.plugins.ThrowPropsPlugin;
				}
				this.vars = vars = _copy(vars || {});
				this.target = target;
				this.x = this.y = this.rotation = 0;
				this.dragResistance = parseFloat(vars.dragResistance) || 0;
				this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
				this.lockAxis = vars.lockAxis;
				this.autoScroll = vars.autoScroll || 0;
				this.lockedAxis = null;
				this.allowEventDefault = !!vars.allowEventDefault;
				var type = (vars.type || (_isOldIE ? "top,left" : "x,y")).toLowerCase(),
					xyMode = (type.indexOf("x") !== -1 || type.indexOf("y") !== -1),
					rotationMode = (type.indexOf("rotation") !== -1),
					xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
					yProp = xyMode ? "y" : "top",
					allowX = (type.indexOf("x") !== -1 || type.indexOf("left") !== -1 || type === "scroll"),
					allowY = (type.indexOf("y") !== -1 || type.indexOf("top") !== -1 || type === "scroll"),
					minimumMovement = vars.minimumMovement || 2,
					self = this,
					triggers = _slice(vars.trigger || vars.handle || target),
					killProps = {},
					dragEndTime = 0,
					checkAutoScrollBounds = false,
					isClickable = vars.clickableTest || _isClickable,
					clickTime = 0,
					enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, maxX, minX, maxY, minY, tempVars, cssVars, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, isClicking, touchEventTarget, matrix, interrupted, startScrollTop, startScrollLeft, applyObj, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch,
					//this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
					render = function(suppressEvents) {
						if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
							var e = target,
								autoScrollFactor = self.autoScroll * 15, //multiplying by 15 just gives us a better "feel" speed-wise.
								parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;
							checkAutoScrollBounds = false;
							_windowProxy.scrollTop = ((window.pageYOffset != null) ? window.pageYOffset : (_docElement.scrollTop != null) ? _docElement.scrollTop : _doc.body.scrollTop);
							_windowProxy.scrollLeft = ((window.pageXOffset != null) ? window.pageXOffset : (_docElement.scrollLeft != null) ? _docElement.scrollLeft : _doc.body.scrollLeft);
							pointerX = self.pointerX - _windowProxy.scrollLeft;
							pointerY = self.pointerY - _windowProxy.scrollTop;
							while (e && !isRoot) { //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
								isRoot = _isRoot(e.parentNode);
								parent = isRoot ? _windowProxy : e.parentNode;
								rect = isRoot ? {bottom:Math.max(_docElement.clientHeight, window.innerHeight || 0), right: Math.max(_docElement.clientWidth, window.innerWidth || 0), left:0, top:0} : parent.getBoundingClientRect();
								changeX = changeY = 0;
								if (allowY) {
									gap = parent._gsMaxScrollY - parent.scrollTop;
									if (gap < 0) {
										changeY = gap;
									} else if (pointerY > rect.bottom - 40 && gap) {
										checkAutoScrollBounds = true;
										changeY = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.bottom - pointerY)) / 40)) | 0);
									} else if (pointerY < rect.top + 40 && parent.scrollTop) {
										checkAutoScrollBounds = true;
										changeY = -Math.min(parent.scrollTop, (autoScrollFactor * (1 - Math.max(0, (pointerY - rect.top)) / 40)) | 0);
									}
									if (changeY) {
										parent.scrollTop += changeY;
									}
								}
								if (allowX) {
									gap = parent._gsMaxScrollX - parent.scrollLeft;
									if (gap < 0) {
										changeX = gap;
									} else if (pointerX > rect.right - 40 && gap) {
										checkAutoScrollBounds = true;
										changeX = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.right - pointerX)) / 40)) | 0);
									} else if (pointerX < rect.left + 40 && parent.scrollLeft) {
										checkAutoScrollBounds = true;
										changeX = -Math.min(parent.scrollLeft, (autoScrollFactor * (1 - Math.max(0, (pointerX - rect.left)) / 40)) | 0);
									}
									if (changeX) {
										parent.scrollLeft += changeX;
									}
								}

								if (isRoot && (changeX || changeY)) {
									window.scrollTo(parent.scrollLeft, parent.scrollTop);
									setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
								}
								e = parent;
							}
						}
						if (dirty) {
							var x = self.x,
								y = self.y,
								min = 0.000001;
							if (x < min && x > -min) { //browsers don't handle super small decimals well.
								x = 0;
							}
							if (y < min && y > -min) {
								y = 0;
							}
							if (rotationMode) {
								applyObj.data.rotation = self.rotation = x;
								applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
							} else {
								if (scrollProxy) {
									if (allowY) {
										scrollProxy.top(y);
									}
									if (allowX) {
										scrollProxy.left(x);
									}
								} else if (xyMode) {
									if (allowY) {
										applyObj.data.y = y;
									}
									if (allowX) {
										applyObj.data.x = x;
									}
									applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
								} else {
									if (allowY) {
										target.style.top = y + "px";
									}
									if (allowX) {
										target.style.left = x + "px";
									}
								}
							}
							if (hasDragCallback && !suppressEvents && !isDispatching) {
								isDispatching = true; //in case onDrag has an update() call (avoid endless loop)
								_dispatchEvent(self, "drag", "onDrag");
								isDispatching = false;
							}
						}
						dirty = false;
					},

					//copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the ThrowPropsPlugin tween in an onUpdate to ensure things are synced and snapped.
					syncXY = function(skipOnUpdate, skipSnap) {
						var x = self.x,
							y = self.y,
							snappedValue;
						if (!target._gsTransform && (xyMode || rotationMode)) { //just in case the _gsTransform got wiped, like if the user called clearProps on the transform or something (very rare), doing an x tween forces a re-parsing of the transforms and population of the _gsTransform.
							TweenLite.set(target, {x:"+=0", overwrite:false});
						}
						if (xyMode) {
							self.y = target._gsTransform.y;
							self.x = target._gsTransform.x;
						} else if (rotationMode) {
							self.x = self.rotation = target._gsTransform.rotation;
						} else if (scrollProxy) {
							self.y = scrollProxy.top();
							self.x = scrollProxy.left();
						} else {
							self.y = parseInt(target.style.top, 10) || 0;
							self.x = parseInt(target.style.left, 10) || 0;
						}
						if ((snapX || snapY) && !skipSnap) {
							if (snapX) {
								snappedValue = snapX(self.x);
								if (snappedValue !== self.x) {
									self.x = snappedValue;
									if (rotationMode) {
										self.rotation = snappedValue;
									}
									dirty = true;
								}
							}
							if (snapY) {
								snappedValue = snapY(self.y);
								if (snappedValue !== self.y) {
									self.y = snappedValue;
								}
								dirty = true;
							}
						}
						if (dirty) {
							render(true);
						}
						if (!skipOnUpdate) {
							_dispatchEvent(self, "throwupdate", "onThrowUpdate");
						}
					},

					calculateBounds = function() {
						var bounds, targetBounds, snap, snapIsRaw;
						hasBounds = false;
						if (scrollProxy) {
							scrollProxy.calibrate();
							self.minX = minX = -scrollProxy.maxScrollLeft();
							self.minY = minY = -scrollProxy.maxScrollTop();
							self.maxX = maxX = self.maxY = maxY = 0;
							hasBounds = true;
						} else if (!!vars.bounds) {
							bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}
							if (rotationMode) {
								self.minX = minX = bounds.left;
								self.maxX = maxX = bounds.left + bounds.width;
								self.minY = minY = self.maxY = maxY = 0;
							} else if (vars.bounds.maxX !== undefined || vars.bounds.maxY !== undefined) {
								bounds = vars.bounds;
								self.minX = minX = bounds.minX;
								self.minY = minY = bounds.minY;
								self.maxX = maxX = bounds.maxX;
								self.maxY = maxY = bounds.maxY;
							} else {
								targetBounds = _getBounds(target, target.parentNode);
								self.minX = minX = _getStyle(target, xProp) + bounds.left - targetBounds.left;
								self.minY = minY = _getStyle(target, yProp) + bounds.top - targetBounds.top;
								self.maxX = maxX = minX + (bounds.width - targetBounds.width);
								self.maxY = maxY = minY + (bounds.height - targetBounds.height);
							}
							if (minX > maxX) {
								self.minX = maxX;
								self.maxX = maxX = minX;
								minX = self.minX;
							}
							if (minY > maxY) {
								self.minY = maxY;
								self.maxY = maxY = minY;
								minY = self.minY;
							}
							if (rotationMode) {
								self.minRotation = minX;
								self.maxRotation = maxX;
							}
							hasBounds = true;
						}
						if (vars.liveSnap) {
							snap = (vars.liveSnap === true) ? (vars.snap || {}) : vars.liveSnap;
							snapIsRaw = (snap instanceof Array || typeof(snap) === "function");
							if (rotationMode) {
								snapX = buildSnapFunc((snapIsRaw ? snap : snap.rotation), minX, maxX, 1);
								snapY = null;
							} else {
								if (allowX) {
									snapX = buildSnapFunc((snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft), minX, maxX, scrollProxy ? -1 : 1);
								}
								if (allowY) {
									snapY = buildSnapFunc((snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop), minY, maxY, scrollProxy ? -1 : 1);
								}
							}
						}

					},

					onThrowComplete = function() {
						self.isThrowing = false;
						_dispatchEvent(self, "throwcomplete", "onThrowComplete");
					},
					onThrowOverwrite = function() {
						self.isThrowing = false;
					},

					animate = function(throwProps, forceZeroVelocity) {
						var snap, snapIsRaw, tween, overshootTolerance;
						if (throwProps && ThrowPropsPlugin) {
							if (throwProps === true) {
								snap = vars.snap || {};
								snapIsRaw = (snap instanceof Array || typeof(snap) === "function");
								throwProps = {resistance:(vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)};
								if (rotationMode) {
									throwProps.rotation = _parseThrowProps(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
								} else {
									if (allowX) {
										throwProps[xProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "x"));
									}
									if (allowY) {
										throwProps[yProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "y"));
									}
								}
							}
							self.isThrowing = true;
							overshootTolerance = (!isNaN(vars.overshootTolerance)) ? vars.overshootTolerance : (vars.edgeResistance === 1) ? 0 : (1 - self.edgeResistance) + 0.2;
							self.tween = tween = ThrowPropsPlugin.to(scrollProxy || target, {throwProps:throwProps, ease:(vars.ease || _globals.Power3.easeOut), onComplete:onThrowComplete, onOverwrite:onThrowOverwrite, onUpdate:(vars.fastMode ? _dispatchEvent : syncXY), onUpdateParams:(vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : _emptyArray)}, (isNaN(vars.maxDuration) ? 2 : vars.maxDuration), (!isNaN(vars.minDuration) ? vars.minDuration : (overshootTolerance === 0) ? 0 : 0.5), overshootTolerance);
							if (!vars.fastMode) {
								//to populate the end values, we just scrub the tween to the end, record the values, and then jump back to the beginning.
								if (scrollProxy) {
									scrollProxy._suspendTransforms = true; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
								}
								tween.render(tween.duration(), true, true);
								syncXY(true, true);
								self.endX = self.x;
								self.endY = self.y;
								if (rotationMode) {
									self.endRotation = self.x;
								}
								tween.play(0);
								syncXY(true, true);
								if (scrollProxy) {
									scrollProxy._suspendTransforms = false;
								}
							}
						} else if (hasBounds) {
							self.applyBounds();
						}
					},

					updateMatrix = function(shiftStart) {
						var start = matrix || [1,0,0,1,0,0],
							a, b, c, d, tx, ty, determinant, pointerX, pointerY;
						matrix = _getConcatenatedMatrix(target.parentNode, true);
						if (shiftStart && self.isPressed && start.join(",") !== matrix.join(",")) { //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.
							a = start[0];
							b = start[1];
							c = start[2];
							d = start[3];
							tx = start[4];
							ty = start[5];
							determinant = (a * d - b * c);
							pointerX = startPointerX * (d / determinant) + startPointerY * (-c / determinant) + ((c * ty - d * tx) / determinant);
							pointerY = startPointerX * (-b / determinant) + startPointerY * (a / determinant) + (-(a * ty - b * tx) / determinant);
							startPointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
							startPointerX = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
						}
						if (!matrix[1] && !matrix[2] && matrix[0] == 1 && matrix[3] == 1 && matrix[4] == 0 && matrix[5] == 0) { //if there are no transforms, we can optimize performance by not factoring in the matrix
							matrix = null;
						}

					},

					recordStartPositions = function() {
						var edgeTolerance = 1 - self.edgeResistance;
						updateMatrix(false);
						if (matrix) {
							startPointerX = self.pointerX * matrix[0] + self.pointerY * matrix[2] + matrix[4]; //translate to local coordinate system
							startPointerY = self.pointerX * matrix[1] + self.pointerY * matrix[3] + matrix[5];
						}
						if (dirty) {
							setPointerPosition(self.pointerX, self.pointerY);
							render(true);
						}
						if (scrollProxy) {
							calculateBounds();
							startElementY = scrollProxy.top();
							startElementX = scrollProxy.left();
						} else {
							//if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
							if (isTweening()) {
								syncXY(true, true);
								calculateBounds();
							} else {
								self.applyBounds();
							}
							if (rotationMode) {
								rotationOrigin = _localToGlobal(target, {x:0, y:0});
								syncXY(true, true);
								startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)
								startElementY = self.y = Math.atan2(rotationOrigin.y - self.pointerY, self.pointerX - rotationOrigin.x) * _RAD2DEG;
							} else {
								startScrollTop = target.parentNode ? target.parentNode.scrollTop || 0 : 0;
								startScrollLeft = target.parentNode ? target.parentNode.scrollLeft || 0 : 0;
								startElementY = _getStyle(target, yProp); //record the starting top and left values so that we can just add the mouse's movement to them later.
								startElementX = _getStyle(target, xProp);
							}
						}
						if (hasBounds && edgeTolerance) {
							if (startElementX > maxX) {
								startElementX = maxX + (startElementX - maxX) / edgeTolerance;
							} else if (startElementX < minX) {
								startElementX = minX - (minX - startElementX) / edgeTolerance;
							}
							if (!rotationMode) {
								if (startElementY > maxY) {
									startElementY = maxY + (startElementY - maxY) / edgeTolerance;
								} else if (startElementY < minY) {
									startElementY = minY - (minY - startElementY) / edgeTolerance;
								}
							}
						}
					},

					isTweening = function() {
						return (self.tween && self.tween.isActive());
					},

					removePlaceholder = function() {
						if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) { //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.
							_placeholderDiv.parentNode.removeChild(_placeholderDiv);
						}
					},

					buildSnapFunc = function(snap, min, max, factor) {
						if (typeof(snap) === "function") {
							return function(n) {
								var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)
								return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : (n < min) ? min + (n - min) * edgeTolerance : n)) * factor;
							};
						}
						if (snap instanceof Array) {
							return function(n) {
								var i = snap.length,
									closest = 0,
									absDif = _max,
									val, dif;
								while (--i > -1) {
									val = snap[i];
									dif = val - n;
									if (dif < 0) {
										dif = -dif;
									}
									if (dif < absDif && val >= min && val <= max) {
										closest = i;
										absDif = dif;
									}
								}
								return snap[closest];
							};
						}
						return isNaN(snap) ? function(n) { return n; } : function() { return snap * factor; };
					},

					//called when the mouse is pressed (or touch starts)
					onPress = function(e) {
						var i;
						if (!enabled || self.isPressed || !e || ((e.type === "mousedown" || e.type === "pointerdown") && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type])) { //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.
							return;
						}
						interrupted = isTweening();
						self.pointerEvent = e;
						if (_touchEventLookup[e.type]) { //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
							touchEventTarget = (e.type.indexOf("touch") !== -1) ? (e.currentTarget || e.target) : _doc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".
							_addListener(touchEventTarget, "touchend", onRelease);
							_addListener(touchEventTarget, "touchmove", onMove);
							_addListener(touchEventTarget, "touchcancel", onRelease);
							_addListener(_doc, "touchstart", _onMultiTouchDocument);
						} else {
							touchEventTarget = null;
							_addListener(_doc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.
						}
						touchDragAxis = null;
						_addListener(_doc, "mouseup", onRelease);
						if (e && e.target) {
							_addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"
						}
						isClicking = (isClickable.call(self, e.target) && !vars.dragClickables);
						if (isClicking) {
							_addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.
							_dispatchEvent(self, "press", "onPress");
							_setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)
							return;
						}
						allowNativeTouchScrolling = (!touchEventTarget || allowX === allowY || scrollProxy || self.vars.allowNativeTouchScrolling === false) ? false : allowX ? "y" : "x";
						if (_isOldIE) {
							e = _populateIEEvent(e, true);
						} else if (!allowNativeTouchScrolling && !self.allowEventDefault) {
							e.preventDefault();
							if (e.preventManipulation) {
								e.preventManipulation();  //for some Microsoft browsers
							}
						}
						if (e.changedTouches) { //touch events store the data slightly differently
							e = touch = e.changedTouches[0];
							touchID = e.identifier;
						} else if (e.pointerId) {
							touchID = e.pointerId; //for some Microsoft browsers
						} else {
							touch = touchID = null;
						}
						_dragCount++;
						_addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)
						startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove
						startPointerX = self.pointerX = e.pageX;
						if (allowNativeTouchScrolling || self.autoScroll) {
							_recordMaxScrolls(target.parentNode);
						}
						if (target.parentNode && (scrollProxy || (self.autoScroll && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode)) && !target.getBBox) { //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
							_placeholderDiv.style.width = (target.parentNode.scrollWidth) + "px";
							target.parentNode.appendChild(_placeholderDiv);
						}
						recordStartPositions();
						if (self.tween) {
							self.tween.kill();
						}
						self.isThrowing = false;
						TweenLite.killTweensOf(scrollProxy || target, true, killProps); //in case the user tries to drag it before the last tween is done.
						if (scrollProxy) {
							TweenLite.killTweensOf(target, true, {scrollTo:1}); //just in case the original target's scroll position is being tweened somewhere else.
						}
						self.tween = self.lockedAxis = null;
						if (vars.zIndexBoost || (!rotationMode && !scrollProxy && vars.zIndexBoost !== false)) {
							target.style.zIndex = Draggable.zIndex++;
						}
						self.isPressed = true;
						hasDragCallback = !!(vars.onDrag || self._listeners.drag);
						if (!rotationMode) {
							i = triggers.length;
							while (--i > -1) {
								_setStyle(triggers[i], "cursor", vars.cursor || "move");
							}
						}
						_dispatchEvent(self, "press", "onPress");
					},

					//called every time the mouse/touch moves
					onMove = function(e) {
						var originalEvent = e,
							touches, pointerX, pointerY, i;
						if (!enabled || _isMultiTouching || !self.isPressed || !e) {
							return;
						}
						self.pointerEvent = e;
						touches = e.changedTouches;
						if (touches) { //touch events store the data slightly differently
							e = touches[0];
							if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
								i = touches.length;
								while (--i > -1 && (e = touches[i]).identifier !== touchID) {}
								if (i < 0) {
									return;
								}
							}
						} else if (e.pointerId && touchID && e.pointerId !== touchID) { //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
							return;
						}
						if (_isOldIE) {
							e = _populateIEEvent(e, true);
						} else {
							if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) { //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).
								pointerX = e.pageX;
								pointerY = e.pageY;
								if (matrix) {
									i = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
									pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
									pointerX = i;
								}
								touchDragAxis = (Math.abs(pointerX - startPointerX) > Math.abs(pointerY - startPointerY) && allowX) ? "x" : "y";
								if (self.vars.lockAxisOnTouchScroll !== false) {
									self.lockedAxis = (touchDragAxis === "x") ? "y" : "x";
									if (typeof(self.vars.onLockAxis) === "function") {
										self.vars.onLockAxis.call(self, originalEvent);
									}
								}
								if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
									onRelease(originalEvent);
									return;
								}
							}
							if (!self.allowEventDefault && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling !== touchDragAxis)) && originalEvent.cancelable !== false) {
								originalEvent.preventDefault();
								if (originalEvent.preventManipulation) { //for some Microsoft browsers
									originalEvent.preventManipulation();
								}
							}
						}
						if (self.autoScroll) {
							checkAutoScrollBounds = true;
						}
						setPointerPosition(e.pageX, e.pageY);
					},

					setPointerPosition = function(pointerX, pointerY) {
						var dragTolerance = 1 - self.dragResistance,
							edgeTolerance = 1 - self.edgeResistance,
							xChange, yChange, x, y, dif, temp;

						self.pointerX = pointerX;
						self.pointerY = pointerY;

						if (rotationMode) {
							y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
							dif = self.y - y;
							self.y = y;
							if (dif > 180) {
								startElementY -= 360;
							} else if (dif < -180) {
								startElementY += 360;
							}
							x = startElementX + (startElementY - y) * dragTolerance;

						} else {
							if (matrix) {
								temp = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
								pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
								pointerX = temp;
							}
							yChange = (pointerY - startPointerY);
							xChange = (pointerX - startPointerX);
							if (yChange < minimumMovement && yChange > -minimumMovement) {
								yChange = 0;
							}
							if (xChange < minimumMovement && xChange > -minimumMovement) {
								xChange = 0;
							}
							if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
								temp = self.lockedAxis;
								if (!temp) {
									self.lockedAxis = temp = (allowX && Math.abs(xChange) > Math.abs(yChange)) ? "y" : allowY ? "x" : null;
									if (temp && typeof(self.vars.onLockAxis) === "function") {
										self.vars.onLockAxis.call(self, self.pointerEvent);
									}
								}
								if (temp === "y") {
									yChange = 0;
								} else if (temp === "x") {
									xChange = 0;
								}
							}
							x = startElementX + xChange * dragTolerance;
							y = startElementY + yChange * dragTolerance;
						}

						if (snapX || snapY) {
							if (snapX) {
								x = snapX(x);
							}
							if (snapY) {
								y = snapY(y);
							}
						} else if (hasBounds) {
							if (x > maxX) {
								x = maxX + (x - maxX) * edgeTolerance;
							} else if (x < minX) {
								x = minX + (x - minX) * edgeTolerance;
							}
							if (!rotationMode) {
								if (y > maxY) {
									y = maxY + (y - maxY) * edgeTolerance;
								} else if (y < minY) {
									y = minY + (y - minY) * edgeTolerance;
								}
							}
						}
						if (!rotationMode) {
							x = Math.round(x); //helps work around an issue with some Win Touch devices
							y = Math.round(y);
						}
						if (self.x !== x || (self.y !== y && !rotationMode)) {
							if (rotationMode) {
								self.endRotation = self.x = self.endX = x;
							} else {
								if (allowY) {
									self.y = self.endY = y;
								}
								if (allowX) {
									self.x = self.endX = x;
								}
							}
							dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
							if (!self.isDragging && self.isPressed) {
								self.isDragging = true;
								_dispatchEvent(self, "dragstart", "onDragStart");
							}
						}
					},

					//called when the mouse/touch is released
					onRelease = function(e, force) {
						if (!enabled || !self.isPressed || (e && touchID != null && !force && ((e.pointerId && e.pointerId !== touchID) || (e.changedTouches && !_hasTouchID(e.changedTouches, touchID))))) {  //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
							return;
						}
						self.isPressed = false;
						var originalEvent = e,
							wasDragging = self.isDragging,
							placeholderDelayedCall = TweenLite.delayedCall(0.001, removePlaceholder),
							touches, i, syntheticEvent, eventTarget, syntheticClick;
						if (touchEventTarget) {
							_removeListener(touchEventTarget, "touchend", onRelease);
							_removeListener(touchEventTarget, "touchmove", onMove);
							_removeListener(touchEventTarget, "touchcancel", onRelease);
							_removeListener(_doc, "touchstart", _onMultiTouchDocument);
						} else {
							_removeListener(_doc, "mousemove", onMove);
						}
						_removeListener(_doc, "mouseup", onRelease);
						if (e && e.target) {
							_removeListener(e.target, "mouseup", onRelease);
						}
						dirty = false;
						if (isClicking) {
							if (e) {
								_removeListener(e.target, "change", onRelease);
							}
							_setSelectable(triggers, false);
							_dispatchEvent(self, "release", "onRelease");
							_dispatchEvent(self, "click", "onClick");
							isClicking = false;
							return;
						}
						_removeFromRenderQueue(render);
						if (!rotationMode) {
							i = triggers.length;
							while (--i > -1) {
								_setStyle(triggers[i], "cursor", vars.cursor || "move");
							}
						}
						if (wasDragging) {
							dragEndTime = _lastDragTime = _getTime();
							self.isDragging = false;
						}
						_dragCount--;
						if (e) {
							if (_isOldIE) {
								e = _populateIEEvent(e, false);
							}
							touches = e.changedTouches;
							if (touches) { //touch events store the data slightly differently
								e = touches[0];
								if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
									i = touches.length;
									while (--i > -1 && (e = touches[i]).identifier !== touchID) {}
									if (i < 0) {
										return;
									}
								}
							}
							self.pointerEvent = originalEvent;
							self.pointerX = e.pageX;
							self.pointerY = e.pageY;
						}
						if (originalEvent && !wasDragging) {
							if (interrupted && (vars.snap || vars.bounds)) { //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
								animate(vars.throwProps);
							}
							_dispatchEvent(self, "release", "onRelease");
							if (!_isAndroid || originalEvent.type !== "touchmove") { //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a "click".
								_dispatchEvent(self, "click", "onClick");
								eventTarget = originalEvent.target || originalEvent.srcElement || target; //old IE uses srcElement
								clickTime = _getTime();
								syntheticClick = function() { // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
									if (clickTime !== clickDispatch && self.enabled() && !self.isPressed) {
										if (eventTarget.click) { //some browsers (like mobile Safari) don't properly trigger the click event
											eventTarget.click();
										} else if (_doc.createEvent) {
											syntheticEvent = _doc.createEvent("MouseEvents");
											syntheticEvent.initMouseEvent("click", true, true, window, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
											eventTarget.dispatchEvent(syntheticEvent);
										}
									}
								};
								if (!_isAndroid) { //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.
									TweenLite.delayedCall(0.00001, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click.
								}
							}
						} else {
							animate(vars.throwProps); //will skip if throwProps isn't defined or ThrowPropsPlugin isn't loaded.
							if (!_isOldIE && !self.allowEventDefault && originalEvent && (vars.dragClickables || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling === touchDragAxis)) && originalEvent.cancelable !== false) {
								originalEvent.preventDefault();
								if (originalEvent.preventManipulation) {
									originalEvent.preventManipulation();  //for some Microsoft browsers
								}
							}
							_dispatchEvent(self, "release", "onRelease");
						}
						if (isTweening()) {
							placeholderDelayedCall.duration( self.tween.duration() ); //sync the timing so that the placeholder DIV gets
						}
						if (wasDragging) {
							_dispatchEvent(self, "dragend", "onDragEnd");
						}
						return true;
					},

					updateScroll = function(e) {
						if (e && self.isDragging) {
							var parent = e.target || e.srcElement || target.parentNode,
								deltaX = parent.scrollLeft - parent._gsScrollX,
								deltaY = parent.scrollTop - parent._gsScrollY;
							if (deltaX || deltaY) {
								if (matrix) {
									startPointerX -= deltaX * matrix[0] + deltaY * matrix[2];
									startPointerY -= deltaY * matrix[3] + deltaX * matrix[1];
								} else {
									startPointerX -= deltaX;
									startPointerY -= deltaY;
								}
								parent._gsScrollX += deltaX;
								parent._gsScrollY += deltaY;
								setPointerPosition(self.pointerX, self.pointerY);
							}
						}
					},

					onClick = function(e) { //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.
						var time = _getTime(),
							recentlyClicked = (time - clickTime < 40),
							recentlyDragged = (time - dragEndTime < 40),
							alreadyDispatched = (recentlyClicked && clickDispatch === clickTime),
							isModern = !!e.preventDefault,
							alreadyDispatchedTrusted = (recentlyClicked && trustedClickDispatch === clickTime),
							trusted = e.isTrusted || (e.isTrusted == null && recentlyClicked && alreadyDispatched); //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?
						if (isModern && (alreadyDispatched || (recentlyDragged && self.vars.suppressClickOnDrag !== false) )) {
							e.stopImmediatePropagation();
						}
						if (recentlyClicked && (!alreadyDispatched || (trusted !== alreadyDispatchedTrusted))) { //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)
							if (trusted && alreadyDispatched) {
								trustedClickDispatch = clickTime;
							}
							clickDispatch = clickTime;
							return;
						}
						if (self.isPressed || recentlyDragged || recentlyClicked) {
							if (!isModern) {
								e.returnValue = false;
							} else if (!trusted || !e.detail || !recentlyClicked) {
								e.preventDefault();
								if (e.preventManipulation) {
									e.preventManipulation();  //for some Microsoft browsers
								}
							}
						}
					};

				old = Draggable.get(this.target);
				if (old) {
					old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)
				}

				//give the user access to start/stop dragging...
				this.startDrag = function(e) {
					onPress(e);
					if (!self.isDragging) {
						self.isDragging = true;
						_dispatchEvent(self, "dragstart", "onDragStart");
					}
				};
				this.drag = onMove;
				this.endDrag = function(e) {
					onRelease(e, true);
				};
				this.timeSinceDrag = function() {
					return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
				};
				this.hitTest = function(target, threshold) {
					return Draggable.hitTest(self.target, target, threshold);
				};

				this.getDirection = function(from, diagonalThreshold) { //from can be "start" (default), "velocity", or an element
					var mode = (from === "velocity" && ThrowPropsPlugin) ? from : (typeof(from) === "object" && !rotationMode) ? "element" : "start",
						xChange, yChange, ratio, direction, r1, r2;
					if (mode === "element") {
						r1 = _parseRect(self.target);
						r2 = _parseRect(from);
					}
					xChange = (mode === "start") ? self.x - startElementX : (mode === "velocity") ? ThrowPropsPlugin.getVelocity(this.target, xProp) : (r1.left + r1.width / 2) - (r2.left + r2.width / 2);
					if (rotationMode) {
						return xChange < 0 ? "counter-clockwise" : "clockwise";
					} else {
						diagonalThreshold = diagonalThreshold || 2;
						yChange = (mode === "start") ? self.y - startElementY : (mode === "velocity") ? ThrowPropsPlugin.getVelocity(this.target, yProp) : (r1.top + r1.height / 2) - (r2.top + r2.height / 2);
						ratio = Math.abs(xChange / yChange);
						direction = (ratio < 1 / diagonalThreshold) ? "" : (xChange < 0) ? "left" : "right";
						if (ratio < diagonalThreshold) {
							if (direction !== "") {
								direction += "-";
							}
							direction += (yChange < 0) ? "up" : "down";
						}
					}
					return direction;
				};


				this.applyBounds = function(newBounds) {
					var x, y, forceZeroVelocity, e, parent, isRoot;
					if (newBounds && vars.bounds !== newBounds) {
						vars.bounds = newBounds;
						return self.update(true);
					}
					syncXY(true);
					calculateBounds();
					if (hasBounds) {
						x = self.x;
						y = self.y;
						if (x > maxX) {
							x = maxX;
						} else if (x < minX) {
							x = minX;
						}
						if (y > maxY) {
							y = maxY;
						} else if (y < minY) {
							y = minY;
						}
						if (self.x !== x || self.y !== y) {
							forceZeroVelocity = true;
							self.x = self.endX = x;
							if (rotationMode) {
								self.endRotation = x;
							} else {
								self.y = self.endY = y;
							}
							dirty = true;
							render(true);
							if (self.autoScroll && !self.isDragging) {
								_recordMaxScrolls(target.parentNode);
								e = target;
								_windowProxy.scrollTop = ((window.pageYOffset != null) ? window.pageYOffset : (_docElement.scrollTop != null) ? _docElement.scrollTop : _doc.body.scrollTop);
								_windowProxy.scrollLeft = ((window.pageXOffset != null) ? window.pageXOffset : (_docElement.scrollLeft != null) ? _docElement.scrollLeft : _doc.body.scrollLeft);
								while (e && !isRoot) { //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.
									isRoot = _isRoot(e.parentNode);
									parent = isRoot ? _windowProxy : e.parentNode;
									if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
										parent.scrollTop = parent._gsMaxScrollY;
									}
									if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
										parent.scrollLeft = parent._gsMaxScrollX;
									}
									e = parent;
								}
							}
						}
						if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
							animate(vars.throwProps, forceZeroVelocity);
						}
					}
					return self;
				};

				this.update = function(applyBounds, sticky, ignoreExternalChanges) {
					var x = self.x,
						y = self.y;
					updateMatrix(!sticky);
					if (applyBounds) {
						self.applyBounds();
					} else {
						if (dirty && ignoreExternalChanges) {
							render(true);
						}
						syncXY(true);
					}
					if (sticky) {
						setPointerPosition(self.pointerX, self.pointerY);
						if (dirty) {
							render(true);
						}
					}
					if (self.isPressed && !sticky && ((allowX && Math.abs(x - self.x) > 0.01) || (allowY && (Math.abs(y - self.y) > 0.01 && !rotationMode)))) {
						recordStartPositions();
					}
					if (self.autoScroll) {
						_recordMaxScrolls(target.parentNode);
						checkAutoScrollBounds = self.isDragging;
						render(true);
					}
					if (self.autoScroll) { //in case reparenting occurred.
						_removeScrollListener(target, updateScroll);
						_addScrollListener(target, updateScroll);
					}
					return self;
				};

				this.enable = function(type) {
					var id, i, trigger;
					if (type !== "soft") {
						i = triggers.length;
						while (--i > -1) {
							trigger = triggers[i];
							_addListener(trigger, "mousedown", onPress);
							_addListener(trigger, "touchstart", onPress);
							_addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.
							if (!rotationMode) {
								_setStyle(trigger, "cursor", vars.cursor || "move");
							}
							_setStyle(trigger, "touchCallout", "none");
							_setStyle(trigger, "touchAction", (allowX === allowY || scrollProxy) ? "none" : allowX ? "pan-y" : "pan-x");
						}
						_setSelectable(triggers, false);
					}
					_addScrollListener(target, updateScroll);
					enabled = true;
					if (ThrowPropsPlugin && type !== "soft") {
						ThrowPropsPlugin.track(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
					}
					if (scrollProxy) {
						scrollProxy.enable();
					}
					target._gsDragID = id = "d" + (_lookupCount++);
					_lookup[id] = this;
					if (scrollProxy) {
						scrollProxy.element._gsDragID = id;
					}
					TweenLite.set(target, {x:"+=0", overwrite:false}); //simply ensures that there's a _gsTransform on the element.
					applyObj = {
						t:target,
						data:_isOldIE ? cssVars : target._gsTransform,
						tween:{},
						setRatio:(_isOldIE ? function() { TweenLite.set(target, tempVars); } : CSSPlugin._internals.setTransformRatio || CSSPlugin._internals.set3DTransformRatio)
					};
					recordStartPositions();
					self.update(true);
					return self;
				};

				this.disable = function(type) {
					var dragging = self.isDragging,
						i, trigger;
					if (!rotationMode) {
						i = triggers.length;
						while (--i > -1) {
							_setStyle(triggers[i], "cursor", null);
						}
					}
					if (type !== "soft") {
						i = triggers.length;
						while (--i > -1) {
							trigger = triggers[i];
							_setStyle(trigger, "touchCallout", null);
							_setStyle(trigger, "touchAction", null);
							_removeListener(trigger, "mousedown", onPress);
							_removeListener(trigger, "touchstart", onPress);
							_removeListener(trigger, "click", onClick);
						}
						_setSelectable(triggers, true);
						if (touchEventTarget) {
							_removeListener(touchEventTarget, "touchcancel", onRelease);
							_removeListener(touchEventTarget, "touchend", onRelease);
							_removeListener(touchEventTarget, "touchmove", onMove);
						}
						_removeListener(_doc, "mouseup", onRelease);
						_removeListener(_doc, "mousemove", onMove);
					}
					_removeScrollListener(target, updateScroll);
					enabled = false;
					if (ThrowPropsPlugin && type !== "soft") {
						ThrowPropsPlugin.untrack(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
					}
					if (scrollProxy) {
						scrollProxy.disable();
					}
					_removeFromRenderQueue(render);
					self.isDragging = self.isPressed = isClicking = false;
					if (dragging) {
						_dispatchEvent(self, "dragend", "onDragEnd");
					}
					return self;
				};

				this.enabled = function(value, type) {
					return arguments.length ? (value ? self.enable(type) : self.disable(type)) : enabled;
				};

				this.kill = function() {
					self.isThrowing = false;
					TweenLite.killTweensOf(scrollProxy || target, true, killProps);
					self.disable();
					delete _lookup[target._gsDragID];
					return self;
				};

				if (type.indexOf("scroll") !== -1) {
					scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({onKill:function() { //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
						if (self.isPressed) {
							onRelease(null);
						}}}, vars));
					//a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)
					target.style.overflowY = (allowY && !_isTouchDevice) ? "auto" : "hidden";
					target.style.overflowX = (allowX && !_isTouchDevice) ? "auto" : "hidden";
					target = scrollProxy.content;
				}

				if (vars.force3D !== false) {
					TweenLite.set(target, {force3D:true}); //improve performance by forcing a GPU layer when possible
				}
				if (rotationMode) {
					killProps.rotation = 1;
				} else {
					if (allowX) {
						killProps[xProp] = 1;
					}
					if (allowY) {
						killProps[yProp] = 1;
					}
				}
				if (rotationMode) {
					tempVars = _tempVarsRotation;
					cssVars = tempVars.css;
					tempVars.overwrite = false;
				} else if (xyMode) {
					tempVars = (allowX && allowY) ? _tempVarsXY : allowX ? _tempVarsX : _tempVarsY;
					cssVars = tempVars.css;
					tempVars.overwrite = false;
				}

				this.enable();
			},
			p = Draggable.prototype = new EventDispatcher();

		p.constructor = Draggable;
		p.pointerX = p.pointerY = 0;
		p.isDragging = p.isPressed = false;
		Draggable.version = "0.14.8";
		Draggable.zIndex = 1000;

		_addListener(_doc, "touchcancel", function() {
			//some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.
		});
		_addListener(_doc, "contextmenu", function(e) {
			var p;
			for (p in _lookup) {
				if (_lookup[p].isPressed) {
					_lookup[p].endDrag();
				}
			}
		});

		Draggable.create = function(targets, vars) {
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets);
			}
			var a = (!targets || targets.length === 0) ? [] : _isArrayLike(targets) ? _flattenArray(targets) : [targets],
				i = a.length;
			while (--i > -1) {
				a[i] = new Draggable(a[i], vars);
			}
			return a;
		};

		Draggable.get = function(target) {
			return _lookup[(_unwrapElement(target) || {})._gsDragID];
		};

		Draggable.timeSinceDrag = function() {
			return (_getTime() - _lastDragTime) / 1000;
		};

		var _tempRect = {}, //reuse to reduce garbage collection tasks
			_oldIERect = function(e) { //IE8 doesn't support getBoundingClientRect(), so we use this as a backup.
				var top = 0,
					left = 0,
					width, height;
				e = _unwrapElement(e);
				width = e.offsetWidth;
				height = e.offsetHeight;
				while(e) {
					top += e.offsetTop;
					left += e.offsetLeft;
					e = e.offsetParent;
				}
				return {top: top, left: left, width: width, height: height};
			},
			_parseRect = function(e, undefined) { //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
				if (e === window) {
					_tempRect.left = _tempRect.top = 0;
					_tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0;
					_tempRect.height = _tempRect.bottom = ((e.innerHeight || 0) - 20 < _docElement.clientHeight) ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0;
					return _tempRect;
				}
				var r = (e.pageX !== undefined) ? {left:e.pageX - _getDocScrollLeft(), top:e.pageY - _getDocScrollTop(), right:e.pageX - _getDocScrollLeft() + 1, bottom:e.pageY - _getDocScrollTop() + 1} : (!e.nodeType && e.left !== undefined && e.top !== undefined) ? e : _isOldIE ? _oldIERect(e) : _unwrapElement(e).getBoundingClientRect();
				if (r.right === undefined && r.width !== undefined) {
					r.right = r.left + r.width;
					r.bottom = r.top + r.height;
				} else if (r.width === undefined) { //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.
					r = {width: r.right - r.left, height: r.bottom - r.top, right: r.right, left: r.left, bottom: r.bottom, top: r.top};
				}
				return r;
			};

		Draggable.hitTest = function(obj1, obj2, threshold) {
			if (obj1 === obj2) {
				return false;
			}
			var r1 = _parseRect(obj1),
				r2 = _parseRect(obj2),
				isOutside = (r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top),
				overlap, area, isRatio;
			if (isOutside || !threshold) {
				return !isOutside;
			}
			isRatio = ((threshold + "").indexOf("%") !== -1);
			threshold = parseFloat(threshold) || 0;
			overlap = {left:Math.max(r1.left, r2.left), top:Math.max(r1.top, r2.top)};
			overlap.width = Math.min(r1.right, r2.right) - overlap.left;
			overlap.height = Math.min(r1.bottom, r2.bottom) - overlap.top;
			if (overlap.width < 0 || overlap.height < 0) {
				return false;
			}
			if (isRatio) {
				threshold *= 0.01;
				area = overlap.width * overlap.height;
				return (area >= r1.width * r1.height * threshold || area >= r2.width * r2.height * threshold);
			}
			return (overlap.width > threshold && overlap.height > threshold);
		};

		_placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;";

		return Draggable;

	}, true);


}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
	"use strict";
	var getGlobal = function() {
		return (_gsScope.GreenSockGlobals || _gsScope)[name];
	};
	if (typeof(define) === "function" && define.amd) { //AMD
		define(["TweenLite", "CSSPlugin"], getGlobal);
	} else if (typeof(module) !== "undefined" && module.exports) { //node
		require("../TweenLite.js");
		require("../plugins/CSSPlugin.js");
		module.exports = getGlobal();
	}
}("Draggable"));
/*!
 * VERSION: 1.19.0
 * DATE: 2016-07-14
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
				}
				delete vars.cycle;
			},
			TweenMax = function(target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
			_blankArray = [];

		TweenMax.version = "1.19.0";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};
		
		p.updateTo = function(vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
								pt = this._firstPT, endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};
				
		p.render = function(time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime, 
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime;
			if (time >= totalDur - 0.0000001) { //to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
				
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - (this._cycle * cycleDuration);
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
				
			}
				
			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}
			
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}
			
			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};
		
//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
		
		TweenMax.to = function(target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		};
		
		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt && vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};
		
		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
		
		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
				
		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
		};
		
		TweenMax.set = function(target, vars) {
			return new TweenMax(target, 0, vars);
		};
		
		TweenMax.isTweening = function(target) {
			return (TweenLite.getTweensOf(target, true).length > 0);
		};
		
		var _getChildrenOf = function(timeline, includeTimelines) {
				var a = [],
					cnt = 0,
					tween = timeline._first;
				while (tween) {
					if (tween instanceof TweenLite) {
						a[cnt++] = tween;
					} else {
						if (includeTimelines) {
							a[cnt++] = tween;
						}
						a = a.concat(_getChildrenOf(tween, includeTimelines));
						cnt = a.length;
					}
					tween = tween._next;
				}
				return a;
			}, 
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
			};
		
		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens && delayedCalls && timelines),
				isDC, tween, i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};
		
		TweenMax.killChildTweensOf = function(parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function(pause, tweens, delayedCalls, timelines) {
			tweens = (tweens !== false);
			delayedCalls = (delayedCalls !== false);
			timelines = (timelines !== false);
			var a = getAllTweens(timelines),
				allTrue = (tweens && delayedCalls && timelines),
				i = a.length,
				isDC, tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);
				}
			}
		};
		
		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};
		
		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function(value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};
		
	
//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
		
		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};
		
		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};
		
		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function(value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};
		
		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};
		
		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};
		
		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};
		
		
		return TweenMax;
		
	}, true);








/*
 * ----------------------------------------------------------------
 * TimelineLite
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val.call(targets[i], i) : val[i % val.length];
				}
				delete vars.cycle;
			},
			_pauseCallback = _internals.pauseCallback = function() {},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.19.0";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce, pauseTween, curTime;
			if (time >= totalDur - 0.0000001) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0 || !this._duration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function() {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);








	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * TimelineMax
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {

		var TimelineMax = function(vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = _gsScope._gsDefine.globals,
			_easeNone = new Ease(null, null, 1, 0),
			p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.19.0";

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function(callback, position, params, scope) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function(callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function(position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function(position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false},
				Engine = (vars.repeat && _globals.TweenMax) || TweenLite,
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new Engine(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale );
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
					t._callback("onStart");
				}
			};
			return t;
		};

		p.tweenFromTo = function(fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], callbackScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused,
				prevCycle = this._cycle,
				tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
			if (time >= totalDur - 0.0000001) { //to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - (this._cycle * cycleDuration);
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					time = this._time;
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
				*/
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
					recTotalTime = this._totalTime,
					recCycle = this._cycle,
					recRawPrevTime = this._rawPrevTime,
					recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;
				this.render(prevTime, suppressEvents, (dur === 0));
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) { //in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0 || !this._totalDuration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p.getActive = function(nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
				all = this.getChildren(nested, tweens, timelines),
				cnt = 0,
				l = all.length,
				i, tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};


		p.getLabelAfter = function(time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function(time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function() {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		};


//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};

		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1 || !value) ? this : this.timeScale( this.totalDuration() / value );
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function(value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;

	}, true);
	




	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * BezierPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				if (c === d) { //if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
					c = d - (d - b) / 1000000;
				}
				if (a === b) { //if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
					b = a + (c - a) / 1000000;
				}
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors.
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = (a[j+1].da / _r2[j] + a[j].da / _r1[j]) || 0;
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.7",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._mod = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
								this._overwriteProps.push(p);
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._mod[p]) {
								val = this._mod[p](val, target);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (this._mod[p]) {
										val = this._mod[p](val, target); //for modProps
									}

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
					data.proxy.rotation = data.autoRotate.rotation || 0;
					cssp._overwriteProps.push("rotation");
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._mod = function(lookup) {
			var op = this._overwriteProps,
				i = op.length,
				val;
			while (--i > -1) {
				val = lookup[op[i]];
				if (val && typeof(val) === "function") {
					this._mod[op[i]] = val;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			a = this._autoRotate;
			if (a) {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i][2]]) {
						a.splice(i, 1);
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

	}());






	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * CSSPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function() {
				TweenPlugin.call(this, "css");
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_globals = _gsScope._gsDefine.globals,
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},
			p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.19.0";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_opacityExp = /opacity *= *([^)]*)/i,
			_opacityValExp = /opacity:([^;]*)/i,
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
			_rgbhslExp = /^(rgb|hsl)/,
			_capsExp = /([A-Z])/g,
			_camelExp = /-([a-z])/gi,
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },
			_horizExp = /(?:Left|Right|Width)/i,
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
			_complexExp = /[\s,\(]/i, //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
			_DEG2RAD = Math.PI / 180,
			_RAD2DEG = 180 / Math.PI,
			_forcePT = {},
			_doc = document,
			_createElement = function(type) {
				return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_tempImg = _createElement("img"),
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = navigator.userAgent,
			_autoRound,
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

			_isSafari,
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),
					a = _createElement("a");
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i+8, 1)) > 3));
				_isSafariLT6 = (_isSafari && (Number(_agent.substr(_agent.indexOf("Version/")+8, 1)) < 6));
				_isFirefox = (_agent.indexOf("Firefox") !== -1);
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
					_ieVers = parseFloat( RegExp.$1 );
				}
				if (!a) {
					return false;
				}
				a.style.cssText = "top:1px;opacity:.55;";
				return /^0.55/.test(a.style.opacity);
			}()),
			_getIEOpacity = function(v) {
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
				if (window.console) {
					console.log(s);
				}
			},
			_target, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
			_index, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params

			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {
				e = e || _tempDiv;
				var s = e.style,
					a, i;
				if (s[p] !== undefined) {
					return p;
				}
				p = p.charAt(0).toUpperCase() + p.substr(1);
				a = ["O","Moz","ms","Ms","Webkit"];
				i = 5;
				while (--i > -1 && s[a[i]+p] === undefined) { }
				if (i >= 0) {
					_prefix = (i === 3) ? "ms" : a[i];
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";
					return _prefix + p;
				}
				return null;
			},

			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},

			/**
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
			 *
			 * @param {!Object} t Target element whose style property you want to query
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
			 * @return {?string} The current property value
			 */
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc && t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
			},

			/**
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
			 * @param {!number} v Value
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels
			 */
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || !sfx) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					precise = (v === 1),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (precise) {
					v *= 100;
				}
				if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
					if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
						node = t.parentNode || _doc.body;
						cache = node._gsCache;
						time = TweenLite.ticker.frame;
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;
						}
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				if (precise) {
					pix /= 100;
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, cs);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
			},

			// @private returns at object containing ALL of the style properties in camelCase and their associated values.
			_getAllStyles = function(t, cs) {
				var s = {},
					i, tr, p;
				if ((cs = cs || _getComputedStyle(t, null))) {
					if ((i = cs.length)) {
						while (--i > -1) {
							p = cs[i];
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
							}
						}
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
						for (i in cs) {
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];
							}
						}
					}
				} else if ((cs = t.currentStyle || t.style)) {
					for (i in cs) {
						if (typeof(i) === "string" && s[i] === undefined) {
							s[i.replace(_camelExp, _camelFunc)] = cs[i];
						}
					}
				}
				if (!_supportsOpacity) {
					s.opacity = _getIEOpacity(t);
				}
				tr = _getTransform(t, cs, false);
				s.rotation = tr.rotation;
				s.skewX = tr.skewX;
				s.scaleX = tr.scaleX;
				s.scaleY = tr.scaleY;
				s.x = tr.x;
				s.y = tr.y;
				if (_supports3D) {
					s.z = tr.z;
					s.rotationX = tr.rotationX;
					s.rotationY = tr.rotationY;
					s.scaleZ = tr.scaleZ;
				}
				if (s.filters) {
					delete s.filters;
				}
				return s;
			},

			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {
				var difs = {},
					style = t.style,
					val, p, mpt;
				for (p in s2) {
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);
						}
					}
				}
				if (vars) {
					for (p in vars) { //copy properties (except className)
						if (p !== "className") {
							difs[p] = vars[p];
						}
					}
				}
				return {difs:difs, firstMPT:mpt};
			},
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

			/**
			 * @private Gets the width or height of an element
			 * @param {!Object} t Target element
			 * @param {!string} p Property name ("width" or "height")
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
			 * @return {number} Dimension (in pixels)
			 */
			_getDimension = function(t, p, cs) {
				if ((t.nodeName + "").toLowerCase() === "svg") { //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
					return (cs || _getComputedStyle(t))[p] || 0;
				} else if (t.getBBox && _isSVG(t)) {
					return t.getBBox()[p] || 0;
				}
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
					a = _dimensions[p],
					i = a.length;
				cs = cs || _getComputedStyle(t, null);
				while (--i > -1) {
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
				}
				return v;
			},

			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {
				if (v === "contain" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					return v + " ";
				}
				if (v == null || v === "") {
					v = "0 0";
				}
				var a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1],
					i;
				if (a.length > 3 && !recObj) { //multiple positions
					a = v.split(", ").join(",").split(",");
					v = [];
					for (i = 0; i < a.length; i++) {
						v.push(_parsePosition(a[i]));
					}
					return v.join(",");
				}
				if (y == null) {
					y = (x === "center") ? "50%" : "0";
				} else if (y === "center") {
					y = "50%";
				}
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
				if (recObj) {
					recObj.oxp = (x.indexOf("%") !== -1);
					recObj.oyp = (y.indexOf("%") !== -1);
					recObj.oxr = (x.charAt(1) === "=");
					recObj.oyr = (y.charAt(1) === "=");
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));
					recObj.v = v;
				}
				return recObj || v;
			},

			/**
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */
			_parseChange = function(e, b) {
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : (parseFloat(e) - parseFloat(b)) || 0;
			},

			/**
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value
			 */
			_parseVal = function(v, d) {
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
			},

			/**
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians
			 */
			_parseAngle = function(v, d, p, directionalEnd) {
				var min = 0.000001,
					cap, split, dif, result, isRelative;
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				if (v == null) {
					result = d;
				} else if (typeof(v) === "number") {
					result = v;
				} else {
					cap = 360;
					split = v.split("_");
					isRelative = (v.charAt(1) === "=");
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {
						if (directionalEnd) {
							directionalEnd[p] = d + dif;
						}
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					result = d + dif;
				}
				if (result < min && result > -min) {
					result = 0;
				}
				return result;
			},

			_colorLookup = {aqua:[0,255,255],
				lime:[0,255,0],
				silver:[192,192,192],
				black:[0,0,0],
				maroon:[128,0,0],
				teal:[0,128,128],
				blue:[0,0,255],
				navy:[0,0,128],
				white:[255,255,255],
				fuchsia:[255,0,255],
				olive:[128,128,0],
				yellow:[255,255,0],
				orange:[255,165,0],
				gray:[128,128,128],
				purple:[128,0,128],
				green:[0,128,0],
				red:[255,0,0],
				pink:[255,192,203],
				cyan:[0,255,255],
				transparent:[255,255,255,0]},

			_hue = function(h, m1, m2) {
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},

			/**
			 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
			 */
			_parseColor = CSSPlugin.parseColor = function(v, toHSL) {
				var a, r, g, b, h, s, l, max, min, d, wasHSL;
				if (!v) {
					a = _colorLookup.black;
				} else if (typeof(v) === "number") {
					a = [v >> 16, (v >> 8) & 255, v & 255];
				} else {
					if (v.charAt(v.length - 1) === ",") { //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
						v = v.substr(0, v.length - 1);
					}
					if (_colorLookup[v]) {
						a = _colorLookup[v];
					} else if (v.charAt(0) === "#") {
						if (v.length === 4) { //for shorthand like #9F0
							r = v.charAt(1);
							g = v.charAt(2);
							b = v.charAt(3);
							v = "#" + r + r + g + g + b + b;
						}
						v = parseInt(v.substr(1), 16);
						a = [v >> 16, (v >> 8) & 255, v & 255];
					} else if (v.substr(0, 3) === "hsl") {
						a = wasHSL = v.match(_numExp);
						if (!toHSL) {
							h = (Number(a[0]) % 360) / 360;
							s = Number(a[1]) / 100;
							l = Number(a[2]) / 100;
							g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
							r = l * 2 - g;
							if (a.length > 3) {
								a[3] = Number(v[3]);
							}
							a[0] = _hue(h + 1 / 3, r, g);
							a[1] = _hue(h, r, g);
							a[2] = _hue(h - 1 / 3, r, g);
						} else if (v.indexOf("=") !== -1) { //if relative values are found, just return the raw strings with the relative prefixes in place.
							return v.match(_relNumExp);
						}
					} else {
						a = v.match(_numExp) || _colorLookup.transparent;
					}
					a[0] = Number(a[0]);
					a[1] = Number(a[1]);
					a[2] = Number(a[2]);
					if (a.length > 3) {
						a[3] = Number(a[3]);
					}
				}
				if (toHSL && !wasHSL) {
					r = a[0] / 255;
					g = a[1] / 255;
					b = a[2] / 255;
					max = Math.max(r, g, b);
					min = Math.min(r, g, b);
					l = (max + min) / 2;
					if (max === min) {
						h = s = 0;
					} else {
						d = max - min;
						s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
						h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
						h *= 60;
					}
					a[0] = (h + 0.5) | 0;
					a[1] = (s * 100 + 0.5) | 0;
					a[2] = (l * 100 + 0.5) | 0;
				}
				return a;
			},
			_formatColors = function(s, toHSL) {
				var colors = s.match(_colorExp) || [],
					charIndex = 0,
					parsed = colors.length ? "" : s,
					i, color, temp;
				for (i = 0; i < colors.length; i++) {
					color = colors[i];
					temp = s.substr(charIndex, s.indexOf(color, charIndex)-charIndex);
					charIndex += temp.length + color.length;
					color = _parseColor(color, toHSL);
					if (color.length === 3) {
						color.push(1);
					}
					parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
				}
				return parsed + s.substr(charIndex);
			},
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp+")", "gi");

		CSSPlugin.colorStringFilter = function(a) {
			var combined = a[0] + a[1],
				toHSL;
			if (_colorExp.test(combined)) {
				toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!TweenLite.defaultStringFilter) {
			TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function
		 */
		var _getFormatter = function(dflt, clr, collapsible, multi) {
				if (dflt == null) {
					return function(v) {return v;};
				}
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
					numVals = dVals.length,
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
					formatter;
				if (!numVals) {
					return function(v) {return v;};
				}
				if (clr) {
					formatter = function(v) {
						var color, vals, i, a;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						color = (v.match(_colorExp) || [dColor])[0];
						vals = v.split(color).join("").match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
					};
					return formatter;

				}
				formatter = function(v) {
					var vals, a, i;
					if (typeof(v) === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					vals = v.match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + sfx;
				};
				return formatter;
			},

			/**
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function
			 */
			_getEdgeParser = function(props) {
				props = props.split(",");
				return function(t, e, p, cssp, pt, plugin, vars) {
					var a = (e + "").split(" "),
						i;
					vars = {};
					for (i = 0; i < 4; i++) {
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
					}
					return cssp.parse(t, vars, pt, plugin);
				};
			},

			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str, p;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = Math.round(val);
					} else if (val < min && val > -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = d.mod ? d.mod(proxy.rotation, this.t) : proxy.rotation; //special case for ModifyPlugin to hook into an auto-rotating bezier
				}
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
				if (v === 1 || v === 0) {
					mpt = d.firstMPT;
					p = (v === 1) ? "e" : "b";
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt[p] = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt[p] = str;
						}
						mpt = mpt._next;
					}
				}
			},

			/**
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
			 * @param {!string} p property name
			 * @param {(number|string|object)} v value
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
			 */
			MiniPropTween = function(t, p, v, next, r) {
				this.t = t;
				this.p = p;
				this.v = v;
				this.r = r;
				if (next) {
					next._prev = this;
					this._next = next;
				}
			},

			/**
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
			 */
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt && pt !== bpt) {
					if (pt.type <= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i > 0) {
								xp = "xn" + i;
								p = pt.p + "_" + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			},



			/**
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
			 * @param {number} s Starting numeric value
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = r; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},

			_addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) { //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
				var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
				pt.b = start;
				pt.e = pt.xs0 = end;
				return pt;
			},

			/**
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *
			 * @param {!Object} t Target whose property will be tweened
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
			 * @param {string} b Beginning value
			 * @param {string} e Ending value
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
				b = b || dflt || "";
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += ""; //ensures it's a string
				if (clrs && _colorExp.test(e + b)) { //if colors are found, normalize the formatting to rgba() or hsla().
					e = [b, e];
					CSSPlugin.colorStringFilter(e);
					b = e[0];
					e = e[1];
				}
				var ba = b.split(", ").join(",").split(" "), //beginning array
					ea = e.split(", ").join(",").split(" "), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
					ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
					ba = (dflt || "").split(" ");
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				_colorExp.lastIndex = 0;
				for (i = 0; i < l; i++) {
					bv = ba[i];
					ev = ea[i];
					bn = parseFloat(bv);
					//if the value begins with a number (most common). It's fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);

					//if the value is a color
					} else if (clrs && _colorExp.test(bv)) {
						str = ev.indexOf(")") + 1;
						str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
						useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
						bv = _parseColor(bv, useHSL);
						ev = _parseColor(ev, useHSL);
						hasAlpha = (bv.length + ev.length > 6);
						if (hasAlpha && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) { //old versions of IE don't support rgba().
								hasAlpha = false;
							}
							if (useHSL) {
								pt.appendXtra((hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true)
									.appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false)
									.appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
							} else {
								pt.appendXtra((hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)
									.appendXtra("", bv[1], ev[1] - bv[1], ",", true)
									.appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), true);
							}

							if (hasAlpha) {
								bv = (bv.length < 4) ? 1 : bv[3];
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
							}
						}
						_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt["xs" + pt.l] += (pt.l || pt["xs" + pt.l]) ? " " + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
								return pt;
							}
							ni = 0;
							for (xi = 0; xi < bnums.length; xi++) {
								cv = bnums[xi];
								temp = bv.indexOf(cv, ni);
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
								ni = temp + cv.length;
							}
							pt["xs" + pt.l] += bv.substr(ni);
						}
					}
				}
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {
					str = pt.xs0 + pt.data.s;
					for (i = 1; i < pt.l; i++) {
						str += pt["xs" + i] + pt.data["xn" + i];
					}
					pt.e = str + pt["xs" + i];
				}
				if (!pt.l) {
					pt.type = -1;
					pt.xs0 = pt.e;
				}
				return pt.xfirst || pt;
			},
			i = 9;


		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


		/**
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
		 * @param {string=} pfx Prefix (if any)
		 * @param {!number} s Starting value
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)
		 * @param {boolean=} r Round (if true).
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
		 */
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt["xs" + l] += (pad && (l || pt["xs" + l])) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")
		 * @param {Object=} options An object containing any of the following configuration options:
		 *                      - defaultValue: the default value
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */
		var SpecialProp = function(p, options) {
				options = options || {};
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;
				_specialProps[p] = _specialProps[this.p] = this;
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {
					this.parse = options.parser;
				}
				this.clrs = options.color;
				this.multi = options.multi;
				this.keyword = options.keyword;
				this.dflt = options.defaultValue;
				this.pr = options.priority || 0;
			},

			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
				if (typeof(options) !== "object") {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(","),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i < a.length; i++) {
					options.prefix = (i === 0 && options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			},

			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = _internals._registerPluginProp = function(p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			};


		p = SpecialProp.prototype;

		/**
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element
		 * @param {(string|number|object)} b beginning value
		 * @param {(string|number|object)} e ending (destination) value
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list
		 */
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
				i, ba, ea, l, bi, ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = (ea.length > ba.length) ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
		 * @param {Object=} vars Original vars object that contains the data for parsing.
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
		 *      var start = target.style.width;
		 *      return function(ratio) {
		 *              target.style.width = (start + value * ratio) + "px";
		 *              console.log("set width to " + target.style.width);
		 *          }
		 * }, 0);
		 *
		 * Then, when I do this tween, it will trigger my special property:
		 *
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
		 *
		 * In the example, of course, we're just changing the width, but you can do anything you want.
		 *
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		};






		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",
			_transformOriginProp = _checkPropPrefix("transformOrigin"),
			_supports3D = (_checkPropPrefix("perspective") !== null),
			Transform = _internals.Transform = function() {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
			},
			_SVGElement = window.SVGElement,
			_useSVGTransformAttr,
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

			_createSVG = function(type, container, attributes) {
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
					reg = /([a-z])([A-Z])/g,
					p;
				for (p in attributes) {
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
				}
				container.appendChild(element);
				return element;
			},
			_docElement = _doc.documentElement,
			_forceSVGTransformAttr = (function() {
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !window.chrome),
					svg, rect, width;
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
					svg = _createSVG("svg", _docElement);
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});
					width = rect.getBoundingClientRect().width;
					rect.style[_transformOriginProp] = "50% 50%";
					rect.style[_transformProp] = "scaleX(0.5)";
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);
				}
				return force;
			})(),
			_parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
				var tm = e._gsTransform,
					m = _getMatrix(e, true),
					v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
				if (tm) {
					xOriginOld = tm.xOrigin; //record the original values before we alter them.
					yOriginOld = tm.yOrigin;
				}
				if (!absolute || (v = absolute.split(" ")).length < 2) {
					b = e.getBBox();
					local = _parsePosition(local).split(" ");
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x,
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
				}
				decoratee.xOrigin = xOrigin = parseFloat(v[0]);
				decoratee.yOrigin = yOrigin = parseFloat(v[1]);
				if (absolute && m !== _identity2DMatrix) { //if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
					a = m[0];
					b = m[1];
					c = m[2];
					d = m[3];
					tx = m[4];
					ty = m[5];
					determinant = (a * d - b * c);
					x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
					y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
					xOrigin = decoratee.xOrigin = v[0] = x;
					yOrigin = decoratee.yOrigin = v[1] = y;
				}
				if (tm) { //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
					if (skipRecord) {
						decoratee.xOffset = tm.xOffset;
						decoratee.yOffset = tm.yOffset;
						tm = decoratee;
					}
					if (smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
						x = xOrigin - xOriginOld;
						y = yOrigin - yOriginOld;
						//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
						//tm.x -= x - (x * m[0] + y * m[2]);
						//tm.y -= y - (x * m[1] + y * m[3]);
						tm.xOffset += (x * m[0] + y * m[2]) - x;
						tm.yOffset += (x * m[1] + y * m[3]) - y;
					} else {
						tm.xOffset = tm.yOffset = 0;
					}
				}
				if (!skipRecord) {
					e.setAttribute("data-svg-origin", v.join(" "));
				}
			},
			_canGetBBox = function(e) {
				try {
					return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
				} catch (e) {}
			},
			_isSVG = function(e) { //reports if the element is an SVG on which getBBox() actually works
				return !!(_SVGElement && e.getBBox && e.getCTM && _canGetBBox(e) && (!e.parentNode || (e.parentNode.getBBox && e.parentNode.getCTM)));
			},
			_identity2DMatrix = [1,0,0,1,0,0],
			_getMatrix = function(e, force2D) {
				var tm = e._gsTransform || new Transform(),
					rnd = 100000,
					style = e.style,
					isDefault, s, m, n, dec, none;
				if (_transformProp) {
					s = _getStyle(e, _transformPropCSS, null, true);
				} else if (e.currentStyle) {
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = e.currentStyle.filter.match(_ieGetMatrixExp);
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
				if (isDefault && _transformProp && ((none = (_getComputedStyle(e).display === "none")) || !e.parentNode)) {
					if (none) { //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none".
						n = style.display;
						style.display = "block";
					}
					if (!e.parentNode) {
						dec = 1; //flag
						_docElement.appendChild(e);
					}
					s = _getStyle(e, _transformPropCSS, null, true);
					isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
					if (n) {
						style.display = n;
					} else if (none) {
						_removeProp(style, "display");
					}
					if (dec) {
						_docElement.removeChild(e);
					}
				}
				if (tm.svg || (e.getBBox && _isSVG(e))) {
					if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = style[_transformProp];
						isDefault = 0;
					}
					m = e.getAttribute("transform");
					if (isDefault && m) {
						if (m.indexOf("matrix") !== -1) { //just in case there's a "transform" value specified as an attribute instead of CSS style. Accept either a matrix() or simple translate() value though.
							s = m;
							isDefault = 0;
						} else if (m.indexOf("translate") !== -1) {
							s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
							isDefault = 0;
						}
					}
				}
				if (isDefault) {
					return _identity2DMatrix;
				}
				//split the matrix values out into an array (m for matrix)
				m = (s || "").match(_numExp) || [];
				i = m.length;
				while (--i > -1) {
					n = Number(m[i]);
					m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
				}
				return (force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
			},

			/**
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element
			 * @param {Object=} cs computed style object (optional)
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
			 */
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
				if (t._gsTransform && rec && !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					m, i, scaleX, scaleY, rotation, skewX;

				tm.svg = !!(t.getBBox && _isSVG(t));
				if (tm.svg) {
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
				}
				m = _getMatrix(t);
				if (m !== _identity2DMatrix) {

					if (m.length === 16) {
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;

						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(-a31, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							a11 = a11*cos+a12*sin;
							t2 = a21*cos+a22*sin;
							a22 = a21*-sin+a22*cos;
							a32 = a31*-sin+a32*cos;
							a21 = t2;
						}

						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY = 180 - tm.rotationY;
						}

						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;
						tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;
						if (tm.rotationX || tm.rotationY) {
							tm.skewX = 0;
						} else {
							tm.skewX = (a12 || a22) ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0;
							if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
								if (invX) {
									tm.scaleX *= -1;
									tm.skewX += (tm.rotation <= 0) ? 180 : -180;
									tm.rotation += (tm.rotation <= 0) ? 180 : -180;
								} else {
									tm.scaleY *= -1;
									tm.skewX += (tm.skewX <= 0) ? 180 : -180;
								}
							}
						}
						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
						tm.x = a14;
						tm.y = a24;
						tm.z = a34;
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
						}

					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY))) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),
							a = k ? m[0] : 1,
							b = m[1] || 0,
							c = m[2] || 0,
							d = k ? m[3] : 1;
						tm.x = m[4] || 0;
						tm.y = m[5] || 0;
						scaleX = Math.sqrt(a * a + b * b);
						scaleY = Math.sqrt(d * d + c * c);
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
						if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
							if (invX) {
								scaleX *= -1;
								skewX += (rotation <= 0) ? 180 : -180;
								rotation += (rotation <= 0) ? 180 : -180;
							} else {
								scaleY *= -1;
								skewX += (skewX <= 0) ? 180 : -180;
							}
						}
						tm.scaleX = scaleX;
						tm.scaleY = scaleY;
						tm.rotation = rotation;
						tm.skewX = skewX;
						if (_supports3D) {
							tm.rotationX = tm.rotationY = tm.z = 0;
							tm.perspective = defaultTransformPerspective;
							tm.scaleZ = 1;
						}
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
							tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
						}
					}
					tm.zOrigin = zOrigin;
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {
						if (tm[i] < min) if (tm[i] > -min) {
							tm[i] = 0;
						}
					}
				}
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
				if (rec) {
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {
							TweenLite.delayedCall(0.001, function(){ //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
								_removeProp(t.style, _transformProp);
							});
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
							TweenLite.delayedCall(0.001, function(){
								t.removeAttribute("transform");
							});
						}
					}
				}
				return tm;
			},

			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					ang = -t.rotation * _DEG2RAD,
					skew = ang + t.skewX * _DEG2RAD,
					rnd = 100000,
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
					style = this.t.style,
					cs = this.t.currentStyle,
					filters, val;
				if (!cs) {
					return;
				}
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;
				c = -val;
				filters = cs.filter;
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
				var w = this.t.offsetWidth,
					h = this.t.offsetHeight,
					clip = (cs.position !== "absolute"),
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
					ox = t.x + (w * t.xPercent / 100),
					oy = t.y + (h * t.yPercent / 100),
					dx, dy;

				//if transformOrigin is being used, adjust the offset x and y
				if (t.ox != null) {
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
					ox += dx - (dx * a + dy * b);
					oy += dy - (dx * c + dy * d);
				}

				if (!clip) {
					m += ", sizingMethod='auto expand')";
				} else {
					dx = (w / 2);
					dy = (h / 2);
					//translate to ensure that transformations occur around the correct origin (default is center).
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
				}
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
					style.filter = filters.replace(_ieSetMatrixExp, m);
				} else {
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}

				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");
				}

				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;
					dx = t.ieOffsetX || 0;
					dy = t.ieOffsetY || 0;
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
					for (i = 0; i < 4; i++) {
						prop = _margins[i];
						marg = cs[prop];
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
					}
				}
			},

			/* translates a super small decimal to a string WITHOUT scientific notation
			_safeDecimal = function(n) {
				var s = (n < 0 ? -n : n) + "",
					a = s.split("e-");
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
			},
			*/

			_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					style = this.t.style,
					angle = t.rotation,
					rotationX = t.rotationX,
					rotationY = t.rotationY,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					isSVG = t.svg,
					perspective = t.perspective,
					force3D = t.force3D,
					a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t1, t2, transform, comma, zero, skew, rnd;
				//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
				if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

					//2D
					if (angle || t.skewX || isSVG) {
						angle *= _DEG2RAD;
						skew = t.skewX * _DEG2RAD;
						rnd = 100000;
						a11 = Math.cos(angle) * sx;
						a21 = Math.sin(angle) * sx;
						a12 = Math.sin(angle - skew) * -sy;
						a22 = Math.cos(angle - skew) * sy;
						if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(skew - t.skewY * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							a12 *= t1;
							a22 *= t1;
							if (t.skewY) {
								t1 = Math.tan(t.skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
						if (isSVG) {
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
							if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) { //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
								min = this.t.getBBox();
								x += t.xPercent * 0.01 * min.width;
								y += t.yPercent * 0.01 * min.height;
							}
							min = 0.000001;
							if (x < min) if (x > -min) {
								x = 0;
							}
							if (y < min) if (y > -min) {
								y = 0;
							}
						}
						transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
						if (isSVG && _useSVGTransformAttr) {
							this.t.setAttribute("transform", "matrix(" + transform);
						} else {
							//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
							style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
						}
					} else {
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
					}
					return;

				}
				if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
					min = 0.0001;
					if (sx < min && sx > -min) {
						sx = sz = 0.00002;
					}
					if (sy < min && sy > -min) {
						sy = sz = 0.00002;
					}
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;
					}
				}
				if (angle || t.skewX) {
					angle *= _DEG2RAD;
					cos = a11 = Math.cos(angle);
					sin = a21 = Math.sin(angle);
					if (t.skewX) {
						angle -= t.skewX * _DEG2RAD;
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan((t.skewX - t.skewY) * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							cos *= t1;
							sin *= t1;
							if (t.skewY) {
								t1 = Math.tan(t.skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
					}
					a12 = -sin;
					a22 = cos;

				} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;
				} else {
					a11 = a22 = 1;
					a12 = a21 = 0;
				}
				// KEY  INDEX   AFFECTS
				// a11  0       rotation, rotationY, scaleX
				// a21  1       rotation, rotationY, scaleX
				// a31  2       rotationY, scaleX
				// a41  3       rotationY, scaleX
				// a12  4       rotation, skewX, rotationX, scaleY
				// a22  5       rotation, skewX, rotationX, scaleY
				// a32  6       rotationX, scaleY
				// a42  7       rotationX, scaleY
				// a13  8       rotationY, rotationX, scaleZ
				// a23  9       rotationY, rotationX, scaleZ
				// a33  10      rotationY, rotationX, scaleZ
				// a43  11      rotationY, rotationX, perspective, scaleZ
				// a14  12      x, zOrigin, svgOrigin
				// a24  13      y, zOrigin, svgOrigin
				// a34  14      z, zOrigin
				// a44  15
				// rotation: Math.atan2(a21, a11)
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
				// rotationX: Math.atan2(a32, a33)
				a33 = 1;
				a13 = a23 = a31 = a32 = a41 = a42 = 0;
				a43 = (perspective) ? -1 / perspective : 0;
				zOrigin = t.zOrigin;
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.
				comma = ",";
				zero = "0";
				angle = rotationY * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					a31 = -sin;
					a41 = a43*-sin;
					a13 = a11*sin;
					a23 = a21*sin;
					a33 = cos;
					a43 *= cos;
					a11 *= cos;
					a21 *= cos;
				}
				angle = rotationX * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					a32 = a33*sin;
					a42 = a43*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a33*cos;
					a43 = a43*cos;
					a12 = t1;
					a22 = t2;
				}
				if (sz !== 1) {
					a13*=sz;
					a23*=sz;
					a33*=sz;
					a43*=sz;
				}
				if (sy !== 1) {
					a12*=sy;
					a22*=sy;
					a32*=sy;
					a42*=sy;
				}
				if (sx !== 1) {
					a11*=sx;
					a21*=sx;
					a31*=sx;
					a41*=sx;
				}

				if (zOrigin || isSVG) {
					if (zOrigin) {
						x += a13*-zOrigin;
						y += a23*-zOrigin;
						z += a33*-zOrigin+zOrigin;
					}
					if (isSVG) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
					}
					if (x < min && x > -min) {
						x = zero;
					}
					if (y < min && y > -min) {
						y = zero;
					}
					if (z < min && z > -min) {
						z = 0; //don't use string because we calculate perspective later and need the number.
					}
				}

				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (rotationX || rotationY || sz !== 1) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {
					transform += ",0,0,0,0,1,0,";
				}
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

				style[_transformProp] = transform;
			};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {parser:function(t, e, parsingProp, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;
			var swapFunc;
			if (typeof(vars[parsingProp]) === "function") { //whatever property triggers the initial parsing might be a function-based value in which case it already got called in parse(), thus we don't want to call it again in here. The most efficient way to avoid this is to temporarily swap the value directly into the vars object, and then after we do all our parsing in this function, we'll swap it back again.
				swapFunc = vars[parsingProp];
				vars[parsingProp] = e;
			}
			var originalGSTransform = t._gsTransform,
				style = t.style,
				min = 0.000001,
				i = _transformProps.length,
				v = vars,
				endRotations = {},
				transformOriginString = "transformOrigin",
				m1 = _getTransform(t, _cs, true, v.parseTransform),
				orig = v.transform && ((typeof(v.transform) === "function") ? v.transform(_index, _target) : v.transform),
				m2, copy, has3D, hasChange, dr, x, y, matrix, p;
			cssp._transform = m1;
			if (orig && typeof(orig) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = orig;
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";
				_doc.body.appendChild(_tempDiv);
				m2 = _getTransform(_tempDiv, null, false);
				if (m1.svg) { //if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
					x = m1.xOrigin;
					y = m1.yOrigin;
					m2.x -= m1.xOffset;
					m2.y -= m1.yOffset;
					if (v.transformOrigin || v.svgOrigin) { //if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
						orig = {};
						_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
						x = orig.xOrigin;
						y = orig.yOrigin;
						m2.x -= orig.xOffset - m1.xOffset;
						m2.y -= orig.yOffset - m1.yOffset;
					}
					if (x || y) {
						matrix = _getMatrix(_tempDiv, true);
						m2.x -= x - (x * matrix[0] + y * matrix[2]);
						m2.y -= y - (x * matrix[1] + y * matrix[3]);
					}
				}
				_doc.body.removeChild(_tempDiv);
				if (!m2.perspective) {
					m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
				}
				if (v.xPercent != null) {
					m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
				}
				if (v.yPercent != null) {
					m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
				}
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
					x:_parseVal(v.x, m1.x),
					y:_parseVal(v.y, m1.y),
					z:_parseVal(v.z, m1.z),
					xPercent:_parseVal(v.xPercent, m1.xPercent),
					yPercent:_parseVal(v.yPercent, m1.yPercent),
					perspective:_parseVal(v.transformPerspective, m1.perspective)};
				dr = v.directionalRotation;
				if (dr != null) {
					if (typeof(dr) === "object") {
						for (copy in dr) {
							v[copy] = dr[copy];
						}
					} else {
						v.rotation = dr;
					}
				}
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
					m2.x = 0;
					m2.xPercent = _parseVal(v.x, m1.xPercent);
				}
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
					m2.y = 0;
					m2.yPercent = _parseVal(v.y, m1.yPercent);
				}

				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation - m1.skewY, m1.rotation - m1.skewY, "rotation", endRotations); //see notes below about skewY for why we subtract it from rotation here
				if (_supports3D) {
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}
				m2.skewX = _parseAngle(v.skewX, m1.skewX - m1.skewY); //see notes below about skewY and why we subtract it from skewX here

				//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
				if ((m2.skewY = _parseAngle(v.skewY, m1.skewY))) {
					m2.skewX += m2.skewY;
					m2.rotation += m2.skewY;
				}
			}
			if (_supports3D && v.force3D != null) {
				m1.force3D = v.force3D;
				hasChange = true;
			}

			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {
				m2.scaleZ = 1; //no need to tween scaleZ.
			}

			while (--i > -1) {
				p = _transformProps[i];
				orig = m2[p] - m1[p];
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
					hasChange = true;
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);
					if (p in endRotations) {
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()
					pt.plugin = plugin;
					cssp._overwriteProps.push(pt.n);
				}
			}

			orig = v.transformOrigin;
			if (m1.svg && (orig || v.svgOrigin)) {
				x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
				y = m1.yOffset;
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
				pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
				pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
				if (x !== m1.xOffset || y !== m1.yOffset) {
					pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
					pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
				}
				orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {
					hasChange = true;
					p = _transformOriginProp;
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
					pt.b = style[p];
					pt.plugin = plugin;
					if (_supports3D) {
						copy = m1.zOrigin;
						orig = orig.split(" ");
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;
						pt.xs0 = pt.e = m1.zOrigin;
					} else {
						pt.xs0 = pt.e = orig;
					}

					//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {
					_parsePosition(orig + "", m1);
				}
			}
			if (hasChange) {
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}
			if (swapFunc) {
				vars[parsingProp] = swapFunc;
			}
			return pt;
		}, prefix:true});

		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});

		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			e = this.format(e);
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
				style = t.style,
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
			w = parseFloat(t.offsetWidth);
			h = parseFloat(t.offsetHeight);
			ea1 = e.split(" ");
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix
					props[i] = _checkPropPrefix(props[i]);
				}
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
				if (bs.indexOf(" ") !== -1) {
					bs2 = bs.split(" ");
					bs = bs2[0];
					bs2 = bs2[1];
				}
				es = es2 = ea1[i];
				bn = parseFloat(bs);
				bsfx = bs.substr((bn + "").length);
				rel = (es.charAt(1) === "=");
				if (rel) {
					en = parseInt(es.charAt(0)+"1", 10);
					es = es.substr(2);
					en *= parseFloat(es);
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
				} else {
					en = parseFloat(es);
					esfx = es.substr((en + "").length);
				}
				if (esfx === "") {
					esfx = _suffixMap[p] || bsfx;
				}
				if (esfx !== bsfx) {
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
					if (esfx === "%") {
						bs = (hn / w * 100) + "%";
						bs2 = (vn / h * 100) + "%";
					} else if (esfx === "em") {
						em = _convertToPixels(t, "borderLeft", 1, "em");
						bs = (hn / em) + "em";
						bs2 = (vn / em) + "em";
					} else {
						bs = hn + "px";
						bs2 = vn + "px";
					}
					if (rel) {
						es = (parseFloat(bs) + en) + esfx;
						es2 = (parseFloat(bs2) + en) + esfx;
					}
				}
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
			}
			return pt;
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
		}, prefix:true, formatter:_getFormatter("0px 0px", false, true)});
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
			var bp = "background-position",
				cs = (_cs || _getComputedStyle(t, null)),
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				ba, ea, i, pct, overlap, src;
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
				if (src && src !== "none") {
					ba = bs.split(" ");
					ea = es.split(" ");
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;
					while (--i > -1) {
						bs = ba[i];
						pct = (bs.indexOf("%") !== -1);
						if (pct !== (ea[i].indexOf("%") !== -1)) {
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
						}
					}
					bs = ba.join(" ");
				}
			}
			return this.parseComplex(t.style, bs, es, pt, plugin);
		}, formatter:_parsePosition});
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:function(v) {
			v += ""; //ensure it's a string
			return _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v); //if set to something like "100% 100%", Safari typically reports the computed style as just "100%" (no 2nd value), but we should ensure that there are two values, so copy the first one. Otherwise, it'd be interpreted as "100% 0" (wrong).
		}});
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
		_registerComplexSpecialProp("transformStyle", {prefix:true});
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
		_registerComplexSpecialProp("userSelect", {prefix:true});
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;
				delim = _ieVers < 8 ? " " : ",";
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
				e = this.format(e).split(",").join(delim);
			} else {
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
				e = this.format(e);
			}
			return this.parseComplex(t.style, b, e, pt, plugin);
		}});
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
			var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
				end = this.format(e).split(" "),
				esfx = end[0].replace(_suffixExp, "");
			if (esfx !== "px") { //if we're animating to a non-px value, we need to convert the beginning width to that unit.
				bw = (parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx)) + esfx;
			}
			return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
			}, color:true, formatter:function(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			}});
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
			var s = t.style,
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
		}});

		//opacity-related
		var _setIEOpacityRatio = function(v) {
				var t = this.t, //refers to the element's style property
					filters = t.filter || _getStyle(this.data, "filter") || "",
					val = (this.s + this.c * v) | 0,
					skip;
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
						t.removeAttribute("filter");
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
				}
				if (!skip) {
					if (this.xn1) {
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}
					} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
				}
			};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				style = t.style,
				isAutoAlpha = (p === "autoAlpha");
			if (typeof(e) === "string" && e.charAt(1) === "=") {
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
			}
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;
			}
			if (_supportsOpacity) {
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);
			} else {
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.
				pt.type = 2;
				pt.b = "alpha(opacity=" + pt.s + ")";
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
				pt.data = t;
				pt.plugin = plugin;
				pt.setRatio = _setIEOpacityRatio;
			}
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";
				cssp._overwriteProps.push(pt.n);
				cssp._overwriteProps.push(p);
			}
			return pt;
		}});


		var _removeProp = function(s, p) {
				if (p) {
					if (s.removeProperty) {
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;
						}
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				}
			},
			_setClassNameRatio = function(v) {
				this.t._gsClassPT = this;
				if (v === 1 || v === 0) {
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);
					var mpt = this.data, //first MiniPropTween
						s = this.t.style;
					while (mpt) {
						if (!mpt.v) {
							_removeProp(s, mpt.p);
						} else {
							s[mpt.p] = mpt.v;
						}
						mpt = mpt._next;
					}
					if (v === 1 && this.t._gsClassPT === this) {
						this.t._gsClassPT = null;
					}
				} else if (this.t.getAttribute("class") !== this.e) {
					this.t.setAttribute("class", this.e);
				}
			};
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				difData, bs, cnpt, cnptLookup, mpt;
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClassNameRatio;
			pt.pr = -11;
			_hasPriority = true;
			pt.b = b;
			bs = _getAllStyles(t, _cs);
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;
			if (cnpt) {
				cnptLookup = {};
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {
					cnptLookup[mpt.p] = 1;
					mpt = mpt._next;
				}
				cnpt.setRatio(1);
			}
			t._gsClassPT = pt;
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			t.setAttribute("class", pt.e);
			difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
			t.setAttribute("class", b);
			pt.data = difData.firstMPT;
			t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
			pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			return pt;
		}});


		var _setClearPropsRatio = function(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
					transformParse = _specialProps.transform.parse,
					a, p, i, clearTransform, transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}

			}
		};
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClearPropsRatio;
			pt.e = e;
			pt.pr = -10;
			pt.data = cssp._tween;
			_hasPriority = true;
			return pt;
		}});

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}








		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function(target, vars, tween, index) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = _target = target;
			this._tween = tween;
			this._vars = vars;
			_index = index;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof(vars) === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};


		p.parse = function(target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				if (typeof(es) === "function") {
					es = es(_index, _target);
				}
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);

				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = (typeof(es) === "string");
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = (p !== "opacity") ? 0 : 1;
								bsfx = "";
							}
						}

						rel = (isStr && es.charAt(1) === "=");
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}

							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

							//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};


		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn"+i] + pt["xs"+(i+1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
		 * @private
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you
		 * want and it won't create duplicate CSSPropTweens.
		 *
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */
		p._enableTransforms = function(threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};

		var lazySet = function(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function(t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function(pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		p._mod = function(lookup) {
			var pt = this._firstPT;
			while (pt) {
				if (typeof(lookup[pt.p]) === "function" && lookup[pt.p] === Math.round) { //only gets called by RoundPropsPlugin (ModifyPlugin manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently in this plugin for performance reasons, leveraging "r" as an indicator that the value should be rounded internally..
					pt.r = 1;
				}
				pt = pt._next;
			}
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.plugin && pt.plugin !== p && pt.plugin._kill) { //for plugins that are registered with CSSPlugin, we should notify them of the kill.
					pt.plugin._kill(lookup);
					p = pt.plugin;
				}
				pt = pt._next;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};



		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function(e, props, targets) {
				var children, i, child, type;
				if (e.slice) {
					i = e.length;
					while (--i > -1) {
						_getChildStyles(e[i], props, targets);
					}
					return;
				}
				children = e.childNodes;
				i = children.length;
				while (--i > -1) {
					child = children[i];
					type = child.type;
					if (child.style) {
						props.push(_getAllStyles(child));
						if (targets) {
							targets.push(child);
						}
					}
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
						_getChildStyles(child, props, targets);
					}
				}
			};

		/**
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
		 * and it would create other problems. For example:
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *
		 * @param {Object} target object to be tweened
		 * @param {number} Duration in seconds (or frames for frames-based tweens)
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
		 * @return {Array} An array of TweenLite instances
		 */
		CSSPlugin.cascadeTo = function(target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = TweenLite._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;

	}, true);

	
	
	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * RoundPropsPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
				propName: "roundProps",
				version: "1.6.0",
				priority: -1,
				API: 2,

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {
					this._tween = tween;
					return true;
				}

			}),
			_roundLinkedList = function(node) {
				while (node) {
					if (!node.f && !node.blob) {
						node.m = Math.round;
					}
					node = node._next;
				}
			},
			p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function() {
			var tween = this._tween,
				rp = (tween.vars.roundProps.join) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
				i = rp.length,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				prop, pt, next;
			while (--i > -1) {
				lookup[rp[i]] = Math.round;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._mod(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 && pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c) {
			this._addTween(target, p, s, s + c, p, Math.round);
			this._overwriteProps.push(p);
		};

	}());










/*
 * ----------------------------------------------------------------
 * AttrPlugin
 * ----------------------------------------------------------------
 */

	(function() {

		_gsScope._gsDefine.plugin({
			propName: "attr",
			API: 2,
			version: "0.6.0",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function(target, value, tween, index) {
				var p, end;
				if (typeof(target.setAttribute) !== "function") {
					return false;
				}
				for (p in value) {
					end = value[p];
					if (typeof(end) === "function") {
						end = end(index, target);
					}
					this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
					this._overwriteProps.push(p);
				}
				return true;
			}

		});

	}());










/*
 * ----------------------------------------------------------------
 * DirectionalRotationPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.3.0",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween, index) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					end = value[p];
					if (typeof(end) === "function") {
						end = end(index, target);
					}
					split = (end + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;







	
	
	
	
/*
 * ----------------------------------------------------------------
 * EasePack
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, RoughEase, _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function(steps) {
			return new SteppedEase(steps);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
		
	}, true);


});

if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function(window, moduleName) {

		"use strict";
		var _exports = {},
			_globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++])) {}
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl, hasModule;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							hasModule = (typeof(module) !== "undefined" && module.exports);
							if (!hasModule && typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (hasModule){ //node
								if (ns === moduleName) {
									module.exports = _exports[moduleName] = cl;
									for (i in _exports) {
										cl[i] = _exports[i];
									}
								} else if (_exports[moduleName]) {
									_exports[moduleName][n] = cl;
								}
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			_blankArray = [],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				if (i > 1) {
					list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
				}
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function(seamless) {
				if (_id !== null) {
					_self.sleep();
				} else if (seamless) {
					_startTime += -_lastUpdate + (_lastUpdate = _getTime());
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF === "auto" && _self.frame < 5 && document.visibilityState !== "hidden") {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {
					_ticker.wake();
				}
				setTimeout(_checkTimeout, 2000);
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

		p._callback = function(type) {
			var v = this.vars,
				callback = v[type],
				params = v[type + "Params"],
				scope = v[type + "Scope"] || v.callbackScope || this,
				l = params ? params.length : 0;
			switch (l) { //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
				case 0: callback.call(scope); break;
				case 1: callback.call(scope, params[0]); break;
				case 2: callback.call(scope, params[0], params[1]); break;
				default: callback.apply(scope, params);
			}
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					if (_lazyTweens.length) {
						_lazyRender();
					}
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			var duration = this.duration();
			return (!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				var pauseTime = this._pauseTime,
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			return this._uncache(false);
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
					this.render(raw, (raw === this._totalTime), true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.19.0";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
			//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
			_setRatio = function(v) {
				var pt = this._firstPT,
					min = 0.000001,
					val;
				while (pt) {
					val = !pt.blob ? pt.c * v + pt.s : v ? this.join("") : this.start;
					if (pt.m) {
						val = pt.m(val, this._target || pt.t);
					} else if (val < min) if (val > -min) { //prevents issues with converting very small numbers to strings in the browser
						val = 0;
					}
					if (!pt.f) {
						pt.t[pt.p] = val;
					} else if (pt.fp) {
						pt.t[pt.p](pt.fp, val);
					} else {
						pt.t[pt.p](val);
					}
					pt = pt._next;
				}
			},
			//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
			_blobDif = function(start, end, filter, pt) {
				var a = [start, end],
					charIndex = 0,
					s = "",
					color = 0,
					startNums, endNums, num, i, l, nonNumbers, currentNum;
				a.start = start;
				if (filter) {
					filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
					start = a[0];
					end = a[1];
				}
				a.length = 0;
				startNums = start.match(_numbersExp) || [];
				endNums = end.match(_numbersExp) || [];
				if (pt) {
					pt._next = null;
					pt.blob = 1;
					a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
				}
				l = endNums.length;
				for (i = 0; i < l; i++) {
					currentNum = endNums[i];
					nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex)-charIndex);
					s += (nonNumbers || !i) ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
					charIndex += nonNumbers.length;
					if (color) { //sense rgba() values and round them.
						color = (color + 1) % 5;
					} else if (nonNumbers.substr(-5) === "rgba(") {
						color = 1;
					}
					if (currentNum === startNums[i] || startNums.length <= i) {
						s += currentNum;
					} else {
						if (s) {
							a.push(s);
							s = "";
						}
						num = parseFloat(startNums[i]);
						a.push(num);
						a._firstPT = {_next: a._firstPT, t:a, p: a.length-1, s:num, c:((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0, f:0, m:(color && color < 4) ? Math.round : 0};
						//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
					}
					charIndex += currentNum.length;
				}
				s += end.substr(charIndex);
				if (s) {
					a.push(s);
				}
				a.setRatio = _setRatio;
				return a;
			},
			//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
			_addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
				if (typeof(end) === "function") {
					end = end(index || 0, target);
				}
				var s = (start === "get") ? target[prop] : start,
					type = typeof(target[prop]),
					isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
					pt = {t:target, p:prop, s:s, f:(type === "function"), pg:0, n:overwriteProp || prop, m:(!mod ? 0 : (typeof(mod) === "function") ? mod : Math.round), pr:0, c:isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0},
					blob, getterName;
				if (type !== "number") {
					if (type === "function" && start === "get") {
						getterName = ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3));
						pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]();
					}
					if (typeof(s) === "string" && (funcParam || isNaN(s))) {
						//a blob (string that has multiple numbers in it)
						pt.fp = funcParam;
						blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt);
						pt = {t:blob, p:"setRatio", s:0, c:1, f:2, pg:0, n:overwriteProp || prop, pr:0, m:0}; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
					} else if (!isRelative) {
						pt.s = parseFloat(s);
						pt.c = (parseFloat(end) - pt.s) || 0;
					}
				}
				if (pt.c) { //only add it to the linked list if there's a change.
					if ((pt._next = this._firstPT)) {
						pt._next._prev = pt;
					}
					this._firstPT = pt;
					return pt;
				}
			},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens, blobDif:_blobDif}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1, callbackScope:1, stringFilter:1, id:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},
			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (curTween._kill(null, target, tween)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},
			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars, l;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				l = this._targets.length;
				for (i = 0; i < l; i++) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null), i) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					//m - mod           [function | 0]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:1, n:p, pg:1, pr:plugin._priority, m:0};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}
					if (pt._next) {
						pt._next._prev = pt;
					}

				} else {
					propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration - 0.0000001) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
					this._callback("onUpdate");
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
				i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i], overwritingTween)) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (simultaneousOverwrite) { //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
								if (pt.f) {
									pt.t[pt.p](pt.s);
								} else {
									pt.t[pt.p] = pt.s;
								}
								changed = true;
							}
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(Math.min(0, -this._delay)); //in case delay is negative.
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.19.0";
		TweenPlugin.API = 2;
		p._firstPT = null;
		p._addTween = _addPropTween;
		p.setRatio = _setRatio;

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._mod = p._roundProps = function(lookup) {
			var pt = this._firstPT,
				val;
			while (pt) {
				val = lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ]);
				if (val && typeof(val) === "function") { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					if (pt.f === 2) {
						pt.t._applyPT.m = val;
					} else {
						pt.m = val;
					}
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_mod", mod:"_mod", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: " + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, function () { 'use strict';

	/**
	 * 资源路径
	 * resource 就是图片音频数据文件
	 * widget 是零件资源文件
	 * @type {String}
	 */

	var defaultSourcePath = "content/gallery/";
	var defaultWidgetPath = "content/widget/";

	/**
	 * 资源根路径
	 * @type {String}
	 */
	var getSourcePath = function getSourcePath() {
	    if (window.DYNAMICCONFIGT) {
	        return window.DYNAMICCONFIGT.resource + '/gallery/';
	    } else {
	        return defaultSourcePath;
	    }
	};

	/**
	 * 零件
	 * @param  {[type]} 'source' [description]
	 * @return {[type]}          [description]
	 */
	var getWidgetPath = function getWidgetPath() {
	    if (window.DYNAMICCONFIGT) {
	        return window.DYNAMICCONFIGT.resource + '/widget/';
	    } else {
	        return defaultWidgetPath;
	    }
	};

	var isIOS = Xut.plat.isIOS;
	var isAndroid = Xut.plat.isAndroid;

	//杂志直接打开
	var nativeConf = {

	    /**
	     * 资源图片
	     * @return {[type]} [description]
	     */
	    resources: function resources(config) {
	        if (isIOS) {
	            return getSourcePath();
	        }
	        if (isAndroid) {
	            if (parseInt(config.storageMode)) {
	                //sd卡加载资源数据
	                return "/sdcard/appcarrier/magazine/" + config.appId + "/" + getSourcePath();
	            } else {
	                //android_asset缓存加载资源
	                return "/android_asset/www/" + getSourcePath();
	            }
	        }
	    },


	    /**
	     * 视频路径
	     * ios平台在缓存
	     * 安卓在编译raw中
	     */
	    video: function video() {
	        if (isIOS) {
	            return getSourcePath();
	        }
	        if (isAndroid) {
	            return 'android.resource://#packagename#/raw/';
	        }
	    },


	    /**
	     * 音频路径
	     * ios平台在缓存
	     * 安卓在缓存中
	     * @return {[type]} [description]
	     */
	    audio: function audio() {
	        if (isIOS) {
	            return getSourcePath();
	        }
	        if (isAndroid) {
	            return "/android_asset/www/" + getSourcePath();
	        }
	    },


	    /**
	     * 读取svg路径前缀
	     * @return {[type]} [description]
	     */
	    svg: function svg() {
	        return 'www/' + getSourcePath();
	    },


	    /**
	     * js零件
	     * 2016.8.3 喵喵学
	     * @return {[type]} [description]
	     */
	    jsWidget: function jsWidget() {
	        if (isIOS) {
	            return getWidgetPath();
	        }
	        if (isAndroid) {
	            return "/android_asset/www/" + getWidgetPath();
	        }
	    }
	};

	var isIOS$1 = Xut.plat.isIOS;
	var isAndroid$1 = Xut.plat.isAndroid;
	var DUKUCONFIG = window.DUKUCONFIG;
	var MMXCONFIG$1 = window.MMXCONFIG;
	var CLIENTCONFIGT$1 = window.CLIENTCONFIGT;
	var SUbCONFIGT = window.SUbCONFIGT;

	/**
	 * 读酷模式下的路径
	 * @param  {[type]} DUKUCONFIG [description]
	 * @return {[type]}                   [description]
	 */
	if (DUKUCONFIG) {
	    DUKUCONFIG.path = DUKUCONFIG.path.replace('//', '/');
	}

	/**
	 * 除右端的"/"
	 * @param  {[type]} str [description]
	 * @return {[type]}     [description]
	 */
	var rtrim = function rtrim(str) {
	    if (typeof str != 'string') return str;
	    var lastIndex = str.length - 1;
	    if (str.charAt(lastIndex) === '/') {
	        return str.substr(0, lastIndex);
	    } else {
	        return str;
	    }
	};

	// var MMXCONFIGPath = '.'
	// if (MMXCONFIG && MMXCONFIG.path) {
	//     MMXCONFIGPath = location.href.replace(/^file:\/\/\/?/i, '/').replace(/[^\/]*$/, '');
	// }
	var MMXCONFIGPath = location.href.replace(/^file:\/\/\/?/i, '/').replace(/[^\/]*$/, '');
	if (MMXCONFIG$1 && MMXCONFIG$1.path) {
	    MMXCONFIGPath = rtrim(MMXCONFIG$1.path);
	}

	/**
	 *  通过iframe加载判断当前的加载方式
	 *  1 本地iframe打开子文档
	 *  2 读酷加载电子杂志
	 *  3 读酷加载电子杂志打开子文档
	 */
	var iframeMode = function () {
	    var mode = void 0;
	    if (SUbCONFIGT && DUKUCONFIG) {
	        //通过读酷客户端开打子文档方式
	        mode = 'iframeDuKuSubDoc';
	    } else {
	        //子文档加载
	        if (SUbCONFIGT) {
	            mode = 'iframeSubDoc';
	        }
	        //读酷客户端加载
	        if (DUKUCONFIG) {
	            mode = 'iframeDuKu';
	        }
	        //客户端模式
	        //通过零件加载
	        if (CLIENTCONFIGT$1) {
	            mode = 'iframeClient';
	        }
	        //秒秒学客户端加载
	        if (MMXCONFIG$1) {
	            mode = 'iframeMiaomiaoxue';
	        }
	    }
	    return mode;
	}();

	//iframe嵌套配置
	//1 新阅读
	//2 子文档
	//3 秒秒学
	var iframeConf = {

	    /**
	     * 资源图片
	     * @return {[type]} [description]
	     */
	    resources: function resources() {
	        if (isIOS$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return getSourcePath();
	                case 'iframeDuKuSubDoc':
	                    return getSourcePath();
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }

	        if (isAndroid$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * 视频路径
	     * @return {[type]} [description]
	     */
	    video: function video() {
	        if (isIOS$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return getSourcePath();
	                case 'iframeDuKuSubDoc':
	                    return getSourcePath();
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }

	        if (isAndroid$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return 'android.resource://#packagename#/raw/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * 音频路径
	     * @return {[type]} [description]
	     */
	    audio: function audio() {
	        if (isIOS$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return getSourcePath();
	                case 'iframeDuKuSubDoc':
	                    return getSourcePath();
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	        if (isAndroid$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * 调用插件处理
	     * @return {[type]} [description]
	     */
	    svg: function svg() {
	        if (isIOS$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    //www/content/subdoc/00c83e668a6b6bad7eda8eedbd2110ad/content/gallery/
	                    return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }

	        if (isAndroid$1) {
	            switch (iframeMode) {
	                case 'iframeDuKu':
	                    return DUKUCONFIG.path;
	                case 'iframeSubDoc':
	                    return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeDuKuSubDoc':
	                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
	                case 'iframeClient':
	                    return CLIENTCONFIGT$1.path;
	                case 'iframeMiaomiaoxue':
	                    return MMXCONFIGPath + '/content/gallery/';
	            }
	        }
	    },


	    /**
	     * js零件
	     * 2016.8.3 喵喵学
	     * @return {[type]} [description]
	     */
	    jsWidget: function jsWidget() {
	        return MMXCONFIGPath + '/content/widget/';
	    }
	};

	/**
	 * 屏幕尺寸
	 * @return {[type]} [description]
	 */
	function getSize() {
	    //如果是IBooks模式处理
	    if (Xut.IBooks.Enabled) {
	        var screen = Xut.IBooks.CONFIG.screenSize;
	        if (screen) {
	            return {
	                "width": screen.width,
	                "height": screen.height
	            };
	        }
	    }
	    return {
	        "width": $(window).width(),
	        "height": $(window).height()
	    };
	}

	/**
	 * 排版判断
	 * @return {[type]} [description]
	 */
	function getLayerMode(screenSize) {
	    return screenSize.width > screenSize.height ? "horizontal" : "vertical";
	}

	var CEIL = Math.ceil;

	/**
	 * 全局可视区域布局处理
	 * @param  {[type]} () [description]
	 * @return {[type]}    [description]
	 */
	function setView(config, fullProportion) {

	    var screenWidth = config.screenSize.width;
	    var screenHeight = config.screenSize.height;

	    var newWidth = screenWidth;
	    var newHeight = screenHeight;
	    var newTop = 0;
	    var newLeft = 0;

	    /**
	     * 画轴拼接模式
	     * 高度100%，正比缩放宽度，然后设置父容器溢出不隐藏了
	     * 可以看到是连续拼接的页面
	     * @param  {[type]} config.visualMode [description]
	     * @return {[type]}                   [description]
	     */
	    if (config.visualMode === 1) {

	        var designWidth = fullProportion.pptWidth;
	        var designHeight = fullProportion.pptHeight;

	        //竖版PPT
	        if (config.pptVertical) {
	            //横版显示
	            //比如模式3的处理是一致的。只是父容易溢出吧隐藏了
	            if (config.screenHorizontal) {
	                newWidth = fullProportion.pptWidth * fullProportion.height;
	                newLeft = (screenWidth - newWidth) / 2;
	            }
	            //竖版显示
	            //正常全屏显示，类似模式0
	            //config.screenVertical
	        }

	        //横版ppt
	        if (config.pptHorizontal) {
	            //横版设计，在竖版手机上显示，强制分2页，虚拟一页
	            //假如启用了画轴模式，看看是不是竖版的情况，需要切半模版virtualMode
	            //word是两栏，竖版需要强制分开
	            if (config.screenVertical) {}
	            //启动虚拟双页模式
	            // config.doublePageMode = true


	            //横版显示，默认0全屏
	            //config.screenHorizontal
	        }

	        // if (config.doublePageMode && !config.screenHorizontal) {
	        //     //假设高度不会溢出,按两倍屏宽计算
	        //     var _prop = 2 * screenWidth / designWidth;
	        //     offsetLeft = 0;
	        //     scaleHeight = designHeight * _prop;
	        //     offsetTop = (screenHeight - scaleHeight) / 2;

	        //     //如果高度溢出,按屏高计算
	        //     if (scaleHeight > screenHeight) {
	        //         _prop = screenHeight / designHeight;
	        //         scaleWidth = designWidth * _prop;

	        //         offsetTop = 0;
	        //         offsetLeft = (2 * screenWidth - scaleWidth) / 2;
	        //     }

	        //     widthProp = heightProp = _prop;
	        // }
	    }

	    /**
	     * 宽度100%
	     * 正比缩放高度
	     * @param  {[type]} config.visualMode [description]
	     * @return {[type]}                   [description]
	     */
	    if (config.visualMode === 2) {

	        //竖版PPT
	        if (config.pptVertical) {
	            //竖版显示
	            if (config.screenVertical) {
	                newHeight = fullProportion.pptHeight * fullProportion.width;
	                newTop = (screenHeight - newHeight) / 2;
	            }
	            //横版显示
	            else {
	                    newWidth = fullProportion.pptWidth * fullProportion.height;
	                    newLeft = (screenWidth - newWidth) / 2;
	                }
	        }

	        //横版PPT
	        if (config.pptHorizontal) {
	            //竖版显示(宽度100%。上下自适应，显示居中小块)
	            if (config.screenVertical) {
	                newHeight = fullProportion.pptHeight * fullProportion.width;
	                newTop = (screenHeight - newHeight) / 2;
	            }
	        }
	    }

	    /**
	     * 高度100%
	     * 正比缩放宽度
	     * @param  {[type]} config.visualMode [description]
	     * @return {[type]}                   [description]
	     */
	    if (config.visualMode === 3) {

	        //竖版PPT
	        if (config.pptVertical) {
	            //竖版显示
	            //高度100%，宽度溢出
	            if (config.screenVertical) {
	                newWidth = fullProportion.pptWidth * fullProportion.height;
	                newLeft = (screenWidth - newWidth) / 2;
	            }
	        }

	        //横版PPT
	        if (config.pptHorizontal) {
	            //竖版显示(宽度100%。上下自适应，显示居中小块)
	            if (config.screenVertical) {
	                newHeight = fullProportion.pptHeight * fullProportion.width;
	                newTop = (screenHeight - newHeight) / 2;
	            }
	        }
	    }

	    /**
	     * 默认全屏
	     * config.visualMode === 0
	     * @return {[type]}
	     */
	    return {
	        width: CEIL(newWidth),
	        height: CEIL(newHeight),
	        left: CEIL(newLeft),
	        top: CEIL(newTop)
	    };
	}

	/**
	 * 默认ppt尺寸
	 * @type {Number}
	 */
	var PPTWIDTH = 1024;
	var PPTHEIGHT = 768;

	/**
	 * 获取默认全屏比值关系
	 * 用来设置新的view尺寸
	 * @param  {[type]} config    [description]
	 * @param  {[type]} pptWidth  [description]
	 * @param  {[type]} pptHeight [description]
	 * @return {[type]}           [description]
	 */
	function getFullProportion(config, pptWidth, pptHeight) {
	    //设备分辨率
	    var screenWidth = config.screenSize.width;
	    var screenHeight = config.screenSize.height;

	    var screenHorizontal = config.screenHorizontal;

	    //默认ppt尺寸
	    var designWidth = pptWidth ? pptWidth : screenHorizontal ? PPTWIDTH : PPTHEIGHT;
	    var designHeight = pptHeight ? pptHeight : screenHorizontal ? PPTHEIGHT : PPTWIDTH;

	    //当前屏幕的尺寸与数据库设计的尺寸，比例
	    var widthProp = screenWidth / designWidth;
	    var heightProp = screenHeight / designHeight;

	    return {
	        width: widthProp,
	        height: heightProp,
	        left: widthProp,
	        top: heightProp,
	        pptWidth: designWidth,
	        pptHeight: designHeight
	    };
	}

	/**
	 * 计算真正的缩放比
	 * 依照真正的view尺寸设置
	 * @param  {[type]} pptWidth  [description]
	 * @param  {[type]} pptHeight [description]
	 * @return {[type]}           [description]
	 */
	function getRealProportion(config, viewSize, fullProportion) {
	    var widthProp = viewSize.width / fullProportion.pptWidth;
	    var heightProp = viewSize.height / fullProportion.pptHeight;

	    //布局的偏移量，可能是采用了画轴模式，一个可视区可以容纳3个页面
	    var offsetTop = 0;
	    var offsetLeft = 0;

	    return {
	        width: widthProp,
	        height: heightProp,
	        left: widthProp,
	        top: heightProp,
	        offsetTop: offsetTop,
	        offsetLeft: offsetLeft
	    };
	}

	/**
	 * 默认值，未定义
	 * @type {[type]}
	 */
	var DEFAULT = undefined;

	/**
	 * 模式配置
	 */
	var improtMode = {

	  /**
	   * 页面可视模式
	   * 2016.9.19
	   * 4种分辨率显示模式:
	   * 默认全屏缩放
	   *
	   * 0：永远100%屏幕尺寸自适应
	   *
	   * 1：画轴模式：
	   *    在不同分辨率下，按照正比缩放拼接
	   *    在一个可视区中，可以看到3个li拼接后的效果
	   *    按照宽度正比缩放,高度正比缩放，居中(适应画轴拼接模式)
	   *
	   * 2：宽度100% 正比自适应高度
	   *     横版PPT：
	   *        1：横板显示(充满全屏。第1种模式)
	   *        2：竖版显示(宽度100%。上下自适应，显示居中小块)
	   *     竖版PPT:
	   *        1: 竖版显示(宽度100%。上下空白，显示居中，整体缩短, 整理变化不大)
	   *        2: 在横版显示(高度100%，缩放宽度，左右留边)
	   *
	   * 3：高度100% 正比自适应宽度
	   *     横版：
	   *        1：横板显示(充满全屏。第1种模式)
	   *        2：竖版显示(宽度100%。上下自适应，显示居中小块)
	   *     竖版:
	   *        1: 竖版ppt竖版显示(高度100%。宽度溢出，只显示中间部分，整体拉长)
	   *        2: 竖版ppt在横版显示(高度100%，显示居中，左右空白，整体缩短)
	   * @type {Number}
	   */
	  visualMode: 0,

	  /**
	   * 全局翻页模式
	   * 给妙妙单独开的一个模式
	   * 一个novel对应多个season表 所以这里其实不能算全局设置，可以存在多个novel
	   * novel表定义，数据库定义的翻页模式
	   * 用来兼容客户端的制作模式
	   * 妙妙学模式处理，多页面下翻页切换
	   *
	   * 0 通过滑动翻页
	   * 1 禁止滑动,直接快速切换页面(通过左右按键快速切换页面)
	   * @type {Number}
	   */
	  flipMode: 0, //默认0，待数据库填充

	  /**
	   * 应用的加载模式
	   * 0： 应用自行启动
	   * 1： 应用通过接口启动
	   *     Xut.Application.Launch
	   *     提供全局可配置参数
	   * @type {Number}
	   */
	  lauchMode: 0,

	  /**
	   * 应用横竖自适应切换
	   * 默认在浏览器端打开
	   * 这里可以定义打开关闭
	   * 打开：1
	   * 默认：0
	   * [orientate description]
	   * @type {[type]}
	   */
	  orientateMode: Xut.plat.isBrowser ? true : false,

	  /**
	   * 是否启动页面缩放，mini排版处理
	   * 默认自动，根据是否存在flow数据处理
	   * 如果强行介入，这里设置
	   * 1 true 启动
	   * 2 false 禁止
	   */
	  saleMode: false, //默认关闭

	  /**
	   *  仅做测试处理，因为每个section都可以对应配置pageMode参数
	   *  翻页模式（数据库section指定）
	   *
	   *  每个场景对应自己的模式
	   *  所以如果这里配置了，那么所有的场景全部统一配置了
	   *  这里其实是不合理的，所以仅作为测试
	   *
	   *  pageMode：(如果用户没有选择任何处理，pageMode字段就为空)
	   *   0 禁止滑动
	   *   1 允许滑动无翻页按钮
	   *   2 允许滑动带翻页按钮
	   *
	   *  主场景工具栏配置：默认2
	   *  副场景工具栏配置：默认 0
	   */
	  pageMode: DEFAULT, //默认不设置，待数据库填充。如设置,数据库设置忽略

	  /**
	   * 仅做测试处理，因为每个section都可以对应配置tpType参数
	   * 配置工具栏行为
	   *
	   *  工具栏类型
	   *  toolType：(如果用户没有选择任何工具栏信息处理，tbType字段就为空)
	   *   0  禁止工具栏
	   *   1  系统工具栏   - 显示IOS系统工具栏
	   *   2  场景工具栏   - 显示关闭按钮
	   *   3  场景工具栏   - 显示返回按钮
	   *   4  场景工具栏   - 显示顶部小圆点式标示
	   *   填充数组格式，可以多项选择[1,2,3,4]
	   */
	  toolType: { //默认不设置，待数据库填充。如设置,数据库设置忽略
	    mian: DEFAULT, //主场景，系统工具栏
	    deputy: DEFAULT, //副场景，函数工具栏
	    number: DEFAULT //独立配置，默认会启动页面，针对分栏处理
	  },

	  /**
	   * 双页面模式，竖版ppt在横版显示
	   * 一个view中，显示2个page
	   * 一个页面宽度50%，拼接2个页面100%
	   * 高度正比，这样高度不溢出，中间布局留空白
	   * 默认禁止：
	   * 1 true 启动
	   * 2 false 禁止
	   */
	  doublePageMode: false,

	  /**
	   * 调试模式
	   * 如果启动桌面调试模式,自动打开缓存加载,就是每次都打开都回到最后看到的一页
	   *
	   * 默认禁止：
	   * 1 true 启动
	   * 2 false 禁止
	   * @type {Boolean}
	   */
	  debugMode: false,

	  /**
	   * 独立canvas模式处理
	   * 为了测试方便
	   * 可以直接切换到dom模式
	   *
	   * 默认禁止：
	   * 1 true 启动
	   * 2 false 禁止
	   * @type {Boolean}
	   */
	  onlyDomMode: false,

	  /**
	   * 直接通过数据库的历史记录定位到指定的页面
	   * Xut.View.LoadScenario({
	   *     'scenarioId' : scenarioInfo[0],
	   *     'chapterId'  : scenarioInfo[1],
	   *     'pageIndex'  : scenarioInfo[2]
	   *  })
	   *  {
	   *     'scenarioId' : 7,
	   *     'chapterId'  : 9
	   *  }
	   * @type {Boolean}
	   */
	  deBugHistory: DEFAULT
	};

	/**
	 * 数据配置
	 */
	var improtDefault = {

	  /**
	   * 支持电子在在线阅读,向服务端取数据
	   * 自定义配置地址即可'
	   * @type {String}
	   */
	  onlineModeUrl: 'lib/data/database.php',

	  /**
	   * 2016.7.26
	   * 读酷增加强制插件模式
	   * [isPlugin description]
	   * @type {Boolean}
	   */
	  isPlugin: window.DUKUCONFIG && Xut.plat.isIOS,

	  /**
	   * 数据库名
	   * @type {[type]}
	   */
	  dbName: window.xxtmagzinedbname || 'magazine',

	  /**
	   * 存储模式
	   * 0 APK应用本身
	   * 1 外置SD卡
	   */
	  storageMode: 0,

	  /**
	   * 应用路径唯一标示
	   * @type {[type]}
	   */
	  appId: null,

	  /**
	   * 资源路径
	   * @type {[type]}
	   */
	  pathAddress: null

	};

	var isIphone = Xut.plat.isIphone;
	var isBrowser = Xut.plat.isBrowser;
	var GLOBALIFRAME = window.GLOBALIFRAME;
	var CLIENTCONFIGT = window.CLIENTCONFIGT;
	var MMXCONFIG = window.MMXCONFIG;

	var config = Object.create(null);
	var layoutMode = void 0;
	var proportion = void 0;

	/**
	 * 层级关系
	 * @return {[type]} [description]
	 */
	Xut.zIndexlevel = function () {
	    return ++config.zIndexlevel;
	};

	//通过新学堂加载
	//用于处理iframe窗口去全屏
	if (/xinxuetang/.test(window.location.href)) {
	    config.iframeFullScreen = true;
	}

	/**
	 * 是否启动缓存机制
	 * 第一次默认是关闭
	 * 必须读取一次后，缓存启动
	 * 为了支持window.DYNAMICCONFIGT模式
	 * @type {Boolean}
	 */
	var isCacheVideoPath = false;
	var isCacheAudioPath = false;
	var isCacheSvgPath = false;
	var isCacheJsWidgetPath = false;

	var cacheVideoPath = void 0;
	var cacheAudioPath = void 0;
	var cacheSvgPath = void 0;
	var cacheJsWidgetPath = void 0;

	/**
	 * pc端模式
	 * 而且是客户端模式
	 * @return {[type]} [description]
	 */
	var desktopPlat = function desktopPlat() {

	    //2016.9.13
	    //新增动态模式
	    if (window.DYNAMICCONFIGT) {
	        return getSourcePath();
	    }

	    //如果是iframe加载
	    //而且是客户端模式
	    if (GLOBALIFRAME && CLIENTCONFIGT) {
	        return CLIENTCONFIGT.path;
	    }

	    if (typeof initGalleryUrl != 'undefined') {
	        return getSourcePath();
	    } else {
	        //资源存放位置
	        // * storageMode 存放的位置
	        // * 0 APK应用本身
	        // 1 外置SD卡
	        if (Number(config.storageMode)) {
	            return "sdcard/" + config.appId + "/" + getSourcePath();
	        } else {
	            return getSourcePath();
	        }
	    }
	};

	/**
	 * 平台加载用于
	 * 视频.音频妙妙学处理
	 * 1 桌面
	 * 2 移动端
	 * 3 安卓打包后通过网页访问=>妙妙学
	 * @return {[type]} [description]
	 */
	var runMode = function () {
	    if (MMXCONFIG) {
	        return false;
	    }
	    return isBrowser;
	}();

	/**
	 * 图片资源配置路径
	 * [resourcesPath description]
	 * @return {[type]} [description]
	 */
	var _rsourcesPath = function _rsourcesPath() {
	    return isBrowser ? desktopPlat() : GLOBALIFRAME ? iframeConf.resources(config) : nativeConf.resources(config);
	};

	/**
	 * mp3 mp4 音频文件路径
	 * 1 音频加载就会自动拷贝到SD卡上
	 * 2 或者asset上的资源
	 * @return {[type]} [description]
	 */
	var _videoPath = function _videoPath() {
	    return runMode ? desktopPlat() : GLOBALIFRAME ? iframeConf.video() : nativeConf.video();
	};

	/**
	 * 音频路径
	 * @return {[type]} [description]
	 */
	var _audioPath = function _audioPath() {
	    return runMode ? desktopPlat() : GLOBALIFRAME ? iframeConf.audio() : nativeConf.audio();
	};

	/**
	 * SVG文件路径
	 * @return {[type]} [description]
	 */
	var _svgPath = function _svgPath() {
	    return isBrowser ? desktopPlat() : GLOBALIFRAME ? iframeConf.svg() : nativeConf.svg();
	};

	/**
	 * js零件
	 * 2016.8.3 妙妙学新增
	 * 只提供相对路径
	 * @return {[type]} [description]
	 */
	var _jsWidgetPath = function _jsWidgetPath() {
	    return isBrowser ? getWidgetPath() : GLOBALIFRAME ? iframeConf.jsWidget() : nativeConf.jsWidget();
	};

	/**
	 * 打印信息
	 * @param  {[type]} info [description]
	 * @param  {[type]} name [description]
	 * @return {[type]}      [description]
	 */
	Xut.log = function (info, name) {
	    if (!config.debugMode) return;
	    switch (info) {
	        case 'error':
	            console.error && console.error(name);
	            break;
	        case 'debug':
	            console.debug && console.debug(name);
	            break;
	        default:
	            console.log(info);
	            break;
	    }
	};

	/**
	 * 全局配置文件
	 * [debugMode description]
	 * @type {Boolean}
	 */
	_.extend(config, {

	    /**
	     * 视频文件路径
	     * @return {[type]} [description]
	     */
	    videoPath: function videoPath() {
	        if (isCacheVideoPath && cacheVideoPath) {
	            return cacheVideoPath;
	        }
	        isCacheVideoPath = true;
	        return cacheVideoPath = _videoPath();
	    },


	    /**
	     * 音频文件路径
	     * @return {[type]} [description]
	     */
	    audioPath: function audioPath() {
	        if (isCacheAudioPath && cacheAudioPath) {
	            return cacheAudioPath;
	        }
	        isCacheAudioPath = true;
	        return cacheAudioPath = _audioPath();
	    },


	    /**
	     * 配置SVG文件路径
	     * @return {[type]} [description]
	     */
	    svgPath: function svgPath() {
	        if (isCacheSvgPath && cacheSvgPath) {
	            return cacheSvgPath;
	        }
	        isCacheSvgPath = true;
	        return cacheSvgPath = _svgPath();
	    },


	    /**
	     * 配置js零件文件路径
	     * 2016.8.3增加
	     * @return {[type]} [description]
	     */
	    jsWidgetPath: function jsWidgetPath() {
	        if (isCacheJsWidgetPath && cacheJsWidgetPath) {
	            return cacheJsWidgetPath;
	        }
	        isCacheJsWidgetPath = true;
	        return cacheJsWidgetPath = _jsWidgetPath();
	    },


	    /**
	     * 排版模式
	     * @type {[type]}
	     */
	    layoutMode: layoutMode,

	    /**
	     * 缩放比例
	     * @type {[type]}
	     */
	    proportion: proportion,

	    /**
	     * 是浏览器
	     * @type {Boolean}
	     */
	    isBrowser: isBrowser,

	    /**
	     * 全局层级初始值
	     * @type {Number}
	     */
	    zIndexlevel: 1000,

	    /**
	     * 默认图标高度
	     * @type {[type]}
	     */
	    iconHeight: isIphone ? 32 : 44,

	    /**
	     * 数据库尺寸
	     * @type {Number}
	     */
	    dbSize: 1

	}, improtMode, improtDefault);

	Xut.config = config;

	/**
	 * 销毁配置
	 * @return {[type]} [description]
	 */
	function destroyConfig() {
	    cacheVideoPath = null;
	    cacheAudioPath = null;
	    cacheSvgPath = null;
	    cacheJsWidgetPath = null;
	}

	/**
	 * 初始化资源路径
	 * 配置图片路径地址
	 * @return {[type]} [description]
	 */
	function initPathAddress() {
	    //设置资源缓存关闭
	    isCacheVideoPath = false;
	    isCacheAudioPath = false;
	    isCacheSvgPath = false;
	    isCacheJsWidgetPath = false;
	    config.pathAddress = _rsourcesPath();
	}

	/**
	 * 重写默认设置
	 * 通过数据库中的设置的模板尺寸与实际尺寸修复
	 * @type {[type]}
	 */
	var setProportion = function setProportion(pptWidth, pptHeight) {

	    //数据ppt排版设计
	    if (pptWidth && pptHeight) {
	        config.pptHorizontal = pptWidth > pptHeight ? true : false;
	        config.pptVertical = !config.pptHorizontal;
	    }

	    /**
	     * 获取全屏比值，用来设定view的尺寸
	     * @type {[type]}
	     */
	    var fullProportion = getFullProportion(config, pptWidth, pptHeight);

	    /**
	     * 可视区域尺寸
	     * @type {Object}
	     */
	    var viewSize = config.viewSize = setView(config, fullProportion);

	    /**
	     * 判断是否溢出与是否填充
	     * @return {[type]} [description]
	     */
	    viewSize.overflowWidth = false;
	    viewSize.notFillWidth = false;
	    if (viewSize.left < 0) {
	        //溢出宽度
	        viewSize.overflowWidth = true;
	    } else if (viewSize.left > 0) {
	        //没有填满宽度
	        viewSize.notFillWidth = true;
	    }

	    /**
	     * 溢出高度
	     * @param  {[type]}
	     * @return {[type]}
	     * */
	    viewSize.overflowHeight = false;
	    viewSize.notFillHeight = false;
	    if (viewSize.top < 0) {
	        //溢出宽度
	        viewSize.overflowHeight = true;
	    } else if (viewSize.top > 0) {
	        //没有填满宽度
	        viewSize.notFillHeight = true;
	    }

	    /**
	     * 获取全局缩放比
	     * @type {[type]}
	     */
	    proportion = config.proportion = getRealProportion(config, viewSize, fullProportion);
	};

	/**
	 * 默认设置
	 * viewSize,screenSize,layoutMode,proportion
	 * @return {[type]} [description]
	 */
	function initConfig(pptWidth, pptHeight) {

	    /**
	     * 获取分辨率
	     * @type {[type]}
	     */
	    config.screenSize = getSize();

	    /**
	     * 根据设备判断设备的横竖屏
	     * @type {[type]}
	     */
	    config.screenHorizontal = config.screenSize.width > config.screenSize.height ? true : false;
	    config.screenVertical = !config.screenHorizontal;

	    layoutMode = config.layoutMode = getLayerMode(config.screenSize);

	    /**
	     * 设置缩放比
	     */
	    setProportion(pptWidth, pptHeight);
	}

	//定义属性
	var def = Object.defineProperty;

	/**
	 * 定义一个新的对象
	 * 重写属性
	 */
	function def$1(obj, key, val, enumerable, writable) {
	    def(obj, key, {
	        value: val,
	        enumerable: enumerable,
	        writable: writable,
	        configurable: true
	    });
	}

	/**
	 * 定义访问控制器
	 * @return {[type]} [description]
	 */
	function defAccess(obj, key, access) {
	    def(obj, key, {
	        get: access.get,
	        set: access.set
	    });
	}

	/**
	 * 转化数组
	 * @param  {[type]} o [description]
	 * @return {[type]}   [description]
	 */
	function toNumber(o) {
	    return Number(o) || null;
	};

	/**
	 * 创建一个纯存的hash对象
	 */
	function hash() {
	    return Object.create(null);
	}

	function $$extend(object, config) {
	    for (var i in config) {
	        if (i) {
	            if (object[i]) {
	                console.log('接口方法重复', 'Key->' + i, 'Value->' + object[i]);
	            } else {
	                object[i] = config[i];
	            }
	        }
	    }
	}

	/**
	 * /解析json字符串
	 * @param  {[type]} itemArray [description]
	 * @return {[type]}           [description]
	 */
	function parseJSON(itemArray) {
	    if (!itemArray) return;
	    var anminJson;
	    try {
	        anminJson = JSON.parse(itemArray);
	    } catch (error) {
	        console.log('parseJSON失败:' + itemArray);
	    }
	    return anminJson;
	}

	/**
	 * 回车符处理
	 */
	function enterReplace(str) {
	    return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
	}

	/**
	 * 解析json代码
	 * 包装脚本
	 * @param  {[type]} itemArray [description]
	 * @return {[type]}           [description]
	 * execJson("(function(){" + enterReplace(data.postCode) + "})");
	 */
	function makeJsonPack(code) {
	    try {
	        var post = "(function(){" + enterReplace(code) + "})";
	        return new Function("return " + post)();
	    } catch (error) {
	        console.log('解析json出错' + code);
	    }
	}

	/**
	 * 修正判断是否存在处理
	 * @param  {[type]} arr [description]
	 * @return {[type]}     [description]
	 */
	function arrayUnique(arr) {
	    //去重
	    if (arr && arr.length) {
	        var length = arr.length;
	        while (--length) {
	            //如果在前面已经出现，则将该位置的元素删除
	            if (arr.lastIndexOf(arr[length], length - 1) > -1) {
	                arr.splice(length, 1);
	            }
	        }
	        return arr;
	    } else {
	        return arr;
	    }
	}

	/**
	 * 2015.3.24
	 * 1 isBrowser
	 * 2 isMobile
	 * 3 isSurface
	 */
	var transitionEnd = Xut.style.transitionEnd;

	//2015.3.23
	//可以点击与触摸
	var isSurface = Xut.plat.isSurface;
	var hasTouch = Xut.plat.hasTouch;

	//触发事件名
	var touchName = ['touchstart', 'touchmove', 'touchend', 'touchcancel', transitionEnd];
	var mouseName = ['mousedown', 'mousemove', 'mouseup', 'mousecancel', transitionEnd];

	//绑定事件名排序
	var orderName = {
	    start: 0,
	    move: 1,
	    end: 2,
	    cancel: 3,
	    transitionend: 4
	};

	var EVENT_NAME = function () {
	    if (isSurface) {
	        return {
	            touch: touchName,
	            mouse: mouseName
	        };
	    }
	    return hasTouch ? touchName : mouseName;
	}();

	var eachApply = function eachApply(events, callbacks, processor) {
	    _.each(callbacks, function (hooks, key) {
	        return hooks && processor(events[orderName[key]], hooks);
	    });
	};

	/**
	 * 合并事件绑定处理
	 * 因为isSurface设备上
	 * 要同时支持2种方式
	 * @return {[type]} [description]
	 */
	var _on = function _on(context, events, callbacks) {
	    eachApply(events, callbacks, function (eventName, hook) {
	        return context.addEventListener(eventName, hook, false);
	    });
	};

	/**
	 * 销毁事件绑定处理
	 * 因为isSurface设备上
	 * 要同时支持2种方式
	 * @return {[type]} [description]
	 */
	var _off = function _off(context, events, callbacks) {
	    eachApply(events, callbacks, function (eventName, hook) {
	        return context.removeEventListener(eventName, hook, false);
	    });
	};

	/**
	 * 多设备绑定
	 * @param  {[type]}   processor    [处理器]
	 * @param  {[type]}   eventContext [上下文]
	 * @param  {Function} callback     [回调函数]
	 * @return {[type]}                [description]
	 */
	var bind = function bind(context, element, callbacks) {
	    //如果两者都支持
	    //鼠标与触摸
	    if (isSurface) {
	        _.each(EVENT_NAME, function (events) {
	            context(element, events, callbacks);
	        });
	    } else {
	        context(element, EVENT_NAME, callbacks);
	    }
	};

	/**
	 * 合并事件绑定处理
	 * 因为isSurface设备上
	 * 要同时支持2种方式
	 * bindTap(eventContext,{
	 *     start   : start,
	 *     move    : move,
	 *     end     : end
	 * })
	 * @return {[type]} [description]
	 */
	function $$on(element, callbacks) {
	    bind(_on, element, callbacks);
	}

	/**
	 * 移除tap事件
	 * @param  {[type]} context [description]
	 * @param  {[type]} opts    [description]
	 * @return {[type]}         [description]
	 */
	function $$off(element, callbacks) {
	    bind(_off, element, callbacks);
	}

	/**
	 * 如果是$$on绑定的，那么获取事件就可能是多点的
	 * 所以需要$$hanle方法
	 * @param  {[type]} callbacks [description]
	 * @param  {[type]} context   [description]
	 * @param  {[type]} event     [description]
	 * @return {[type]}           [description]
	 */
	function $$handle(callbacks, context, event) {
	    switch (event.type) {
	        case 'touchstart':
	        case 'mousedown':
	            callbacks.start && callbacks.start.call(context, event);
	            break;
	        case 'touchmove':
	        case 'mousemove':
	            callbacks.move && callbacks.move.call(context, event);
	            break;
	        case 'touchend':
	        case 'mouseup':
	        case 'mousecancel':
	        case 'touchcancel':
	            callbacks.end && callbacks.end.call(context, event);
	            break;
	        case transitionEnd:
	            callbacks.transitionend && callbacks.transitionend.call(context, event);
	            break;
	    }
	}

	function $$target(event, original) {
	    var currTouches = null;
	    if (hasTouch) {
	        currTouches = event.touches;
	        if (currTouches && currTouches.length > 0) {
	            event = currTouches[0];
	        }
	    }
	    return original ? event : event.target;
	}

	/**
	 * 资源加载
	 * @return {[type]} [description]
	 */
	var loader = function () {
	    return {
	        /**入口函数,动态脚本加载
	         * @param fileList:           需要动态加载的资源列表
	         * @param callback:           所有资源都加载完后调用的回调函数,通常是页面上需要onload就执行的函数
	         * @param scope:              作用范围
	         * @param preserveOrder:      是否保持脚本顺序
	         */
	        load: function load(fileList, callback, scope, preserveOrder) {
	            //过来数组元素
	            if (fileList.length && preserveOrder) {
	                var temp = [];
	                fileList.forEach(function (val, index) {
	                    if (val) {
	                        temp.push(val);
	                    }
	                });
	                fileList = temp.reverse();
	                temp = null;
	            }

	            var scope = scope || this,

	            //var scope =this,//默认作用范围是当前页面
	            head = document.getElementsByTagName("head")[0],
	                fragment = document.createDocumentFragment(),
	                numFiles = fileList.length,
	                loadedFiles = 0;

	            //加载一个特定的文件从fileList通过索引
	            var loadFileIndex = function loadFileIndex(index) {
	                head.appendChild(scope.buildScriptTag(fileList[index], onFileLoaded));
	            };

	            /**
	             * 调用回调函数,当所有文件都加载完后调用
	             */
	            var onFileLoaded = function onFileLoaded() {
	                loadedFiles++;
	                //如果当前文件是最后一个要加载的文件，则调用回调函数，否则加载下一个文件
	                if (numFiles == loadedFiles && typeof callback == 'function') {
	                    callback.call(scope);
	                } else {
	                    if (preserveOrder === true) {
	                        loadFileIndex(loadedFiles);
	                    }
	                }
	            };

	            if (preserveOrder === true) {
	                loadFileIndex.call(this, 0);
	            } else {
	                for (var i = 0, len = fileList.length; i < len; i++) {
	                    fragment.appendChild(this.buildScriptTag(fileList[i], onFileLoaded));
	                }
	                head.appendChild(fragment);
	            }
	        },

	        //构造javascript和link 标签
	        buildScriptTag: function buildScriptTag(filename, callback) {
	            var exten = filename.substr(filename.lastIndexOf('.') + 1);
	            if (exten == 'js') {
	                var script = document.createElement('script');
	                script.type = "text/javascript";
	                script.src = filename;
	                script.onload = callback;
	                return script;
	            }
	            if (exten == 'css') {
	                var style = document.createElement('link');
	                style.rel = 'stylesheet';
	                style.type = 'text/css';
	                style.href = filename;
	                callback();
	                return style;
	            }
	        }
	    };
	}();

	function pollCss(node, callback) {
	    var sheet = node.sheet,
	        isLoaded;
	    var isOldWebKit = +navigator.userAgent.replace(/.*AppleWebKit\/(\d+)\..*/, "$1") < 536;
	    // for WebKit < 536
	    if (isOldWebKit) {
	        if (sheet) {
	            isLoaded = true;
	        }
	    }
	    // for Firefox < 9.0
	    else if (sheet) {
	            try {
	                if (sheet.cssRules) {
	                    isLoaded = true;
	                }
	            } catch (ex) {
	                // The value of `ex.name` is changed from "NS_ERROR_DOM_SECURITY_ERR"
	                // to "SecurityError" since Firefox 13.0. But Firefox is less than 9.0
	                // in here, So it is ok to just rely on "NS_ERROR_DOM_SECURITY_ERR"
	                if (ex.name === "NS_ERROR_DOM_SECURITY_ERR") {
	                    isLoaded = true;
	                }
	            }
	        }

	    setTimeout(function () {
	        if (isLoaded) {
	            // Place callback here to give time for style rendering
	            callback();
	        } else {
	            pollCss(node, callback);
	        }
	    }, 20);
	}

	function addOnload(node, callback, isCSS, url) {
	    var supportOnload = "onload" in node;
	    var isOldWebKit = +navigator.userAgent.replace(/.*AppleWebKit\/(\d+)\..*/, "$1") < 536;
	    // for Old WebKit and Old Firefox
	    if (isCSS) {
	        setTimeout(function () {
	            pollCss(node, callback);
	        }, 1); // Begin after node insertion
	        return;
	    }

	    if (supportOnload) {
	        node.onload = onload;
	        node.onerror = function () {
	            onload();
	        };
	    } else {
	        node.onreadystatechange = function () {
	            if (/loaded|complete/.test(node.readyState)) {
	                onload();
	            }
	        };
	    }

	    function onload() {
	        // Ensure only run once and handle memory leak in IE
	        node.onload = node.onerror = node.onreadystatechange = null;
	        // Remove the script to reduce memory leak
	        if (!isCSS) {
	            var head = document.getElementsByTagName("head")[0] || document.documentElement;
	            head.removeChild(node);
	        }
	        // Dereference the node
	        node = null;
	        callback();
	    }
	}

	function request(url, callback, charset) {
	    var IS_CSS_RE = /\.css(?:\?|$)/i,
	        isCSS = IS_CSS_RE.test(url),
	        node = document.createElement(isCSS ? "link" : "script");

	    if (charset) {
	        var cs = $.isFunction(charset) ? charset(url) : charset;
	        if (cs) {
	            node.charset = cs;
	        }
	    }
	    addOnload(node, callback, isCSS, url);
	    if (isCSS) {
	        node.rel = "stylesheet";
	        node.href = url;
	    } else {
	        node.async = true;
	        node.src = url;
	    }
	    // For some cache cases in IE 6-8, the script executes IMMEDIATELY after
	    // the end of the insert execution, so use `currentlyAddingScript` to
	    // hold current node, for deriving url in `define` call
	    //currentlyAddingScript = node
	    var head = document.getElementsByTagName("head")[0] || document.documentElement;
	    var baseElement = head.getElementsByTagName("base")[0];
	    // ref: #185 & http://dev.jquery.com/ticket/2709
	    baseElement ? head.insertBefore(node, baseElement) : head.appendChild(node);
	    //currentlyAddingScript = null
	}

	var imgReady = function () {

	    var list = [],
	        intervalId = null,


	    // 用来执行队列
	    tick = function tick() {
	        var i = 0;
	        for (; i < list.length; i++) {
	            list[i].end ? list.splice(i--, 1) : list[i]();
	        };
	        !list.length && stop();
	    },


	    // 停止所有定时器队列
	    stop = function stop() {
	        clearInterval(intervalId);
	        intervalId = null;
	    };

	    return function (url, ready, load, error) {
	        var _onready,
	            width,
	            height,
	            newWidth,
	            newHeight,
	            img = new Image();

	        img.src = url;

	        // 如果图片被缓存，则直接返回缓存数据
	        if (img.complete) {
	            ready && ready.call(img);
	            load && load.call(img);
	            return;
	        };

	        width = img.width;
	        height = img.height;

	        // 加载错误后的事件
	        img.onerror = function () {
	            error && error.call(img);
	            _onready.end = true;
	            img = img.onload = img.onerror = null;
	        };

	        // 图片尺寸就绪
	        _onready = function onready() {
	            newWidth = img.width;
	            newHeight = img.height;
	            if (newWidth !== width || newHeight !== height ||
	            // 如果图片已经在其他地方加载可使用面积检测
	            newWidth * newHeight > 1024) {
	                ready && ready.call(img);
	                _onready.end = true;
	            };
	        };
	        _onready();
	        // 完全加载完毕的事件
	        img.onload = function () {
	            // onload在定时器时间差范围内可能比onready快
	            // 这里进行检查并保证onready优先执行
	            !_onready.end && _onready();
	            load && load.call(img);
	            // IE gif动画会循环执行onload，置空onload即可
	            img = img.onload = img.onerror = null;
	        };

	        // 加入队列中定期执行
	        if (!_onready.end) {
	            list.push(_onready);
	            // 无论何时只允许出现一个定时器，减少浏览器性能损耗
	            if (intervalId === null) intervalId = setInterval(tick, 40);
	        };
	    };
	}();

	var loadfile = request;

	var onlyId = void 0;

	var TAG = 'aaron';
	var storage = window.localStorage;

	//如果数据库为写入appid ,则创建
	var createAppid = function createAppid() {
	    //添加UUID
	    var appId = 'aaron-' + new Date().getDate();
	    //写入数据库
	    Xut.config.db && Xut.config.db.transaction(function (tx) {
	        tx.executeSql("UPDATE Setting SET 'value' = " + appId + " WHERE [name] = 'appId'", function () {}, function () {});
	    }, function () {
	        //  callback && callback();
	    }, function () {
	        //  callback && callback();
	    });
	    return appId;
	};

	//过滤
	var filter = function filter(key) {
	    //添加头部标示
	    if (onlyId) {
	        return key + onlyId;
	    } else {
	        if (!Xut.config.appUUID) {
	            Xut.config.appUUID = createAppid();
	        }
	        //子文档标记
	        if (window.SUbCONFIGT && window.SUbCONFIGT.dbId) {
	            onlyId = "-" + Xut.config.appUUID + "-" + window.SUbCONFIGT.dbId;
	        } else {
	            onlyId = "-" + Xut.config.appUUID;
	        }
	    }
	    return key + onlyId;
	};

	var $$set = function name(key, val) {
	    var setkey;

	    //ipad ios8.3setItem出问题
	    function setItem(key, val) {
	        try {
	            storage.setItem(key, val);
	        } catch (e) {
	            console.log('storage.setItem(setkey, key[i]);');
	        }
	    }

	    if (_.isObject(key)) {
	        for (var i in key) {
	            if (key.hasOwnProperty(i)) {
	                setkey = filter(i);
	                setItem(setkey, key[i]);
	            }
	        }
	    } else {
	        key = filter(key);
	        setItem(key, val);
	    }
	};

	var $$get = function get(key) {
	    key = filter(key);
	    return storage.getItem(key) || undefined;
	};

	/**
	 * 删除localStorage中指定项
	 * @param  {[type]} key [description]
	 * @return {[type]}     [description]
	 */
	function $$remove(key) {
	    key = filter(key);
	    storage.removeItem(key);
	}

	/**
	 * 重设缓存的UUID
	 * 为了只计算一次
	 * @return {[type]} [description]
	 */
	function $$resetUUID() {
	    onlyId = null;
	}

	function $$save(name, val) {
	    $$set(name || TAG, JSON.stringify(val));
	}

	var CEIL$1 = Math.ceil;
	/**
	 * 获取资源
	 * @param  {[type]} url [description]
	 * @return {[type]}     [description]
	 */
	function getResources(url) {
	    var option;
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, false);
	    xhr.send(null);
	    option = parseJSON(xhr.responseText);
	    return option;
	}

	/**
	 * 执行脚本注入
	 */
	function execScript(code, type) {
	    //过滤回车符号
	    var enterReplace = function enterReplace(str) {
	        return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
	    };
	    try {
	        new Function("return " + enterReplace(code))();
	    } catch (e) {
	        console.log('加载脚本错误', type);
	    }
	}

	/**
	 * 路径替换
	 * svg html文件的路径是原始处理的
	 * 如果动态切换就需要替换
	 * @return {[type]} [description]
	 */
	function replacePath(svgstr) {
	    if (window.DYNAMICCONFIGT) {
	        //如果能找到对应的默认路径，则替换
	        if (-1 !== svgstr.indexOf('content/gallery/')) {
	            svgstr = svgstr.replace(/content\/gallery/ig, Xut.config.pathAddress);
	        }
	    }
	    return svgstr;
	}

	/**
	 * 转化缩放比
	 * @param  {[type]} width  [description]
	 * @param  {[type]} height [description]
	 * @param  {[type]} left   [description]
	 * @param  {[type]} top    [description]
	 * @return {[type]}        [description]
	 */
	var transformProportion = function transformProportion(width, height, left, top) {
	    var proportion = config.proportion;
	    return {
	        width: width * proportion.width,
	        height: height * proportion.height,
	        left: left * proportion.left,
	        top: top * proportion.top
	    };
	};

	/*
	 * 修复元素的尺寸
	 * @type {[type]}
	 */
	function reviseSize(results) {

	    //不同设备下缩放比计算
	    var layerSize = transformProportion(results.width, results.height, results.left, results.top);
	    //新的背景图尺寸
	    var backSize = transformProportion(results.backwidth, results.backheight, results.backleft, results.backtop);

	    //赋值新的坐标
	    results.scaleWidth = CEIL$1(layerSize.width);
	    results.scaleHeight = CEIL$1(layerSize.height);
	    results.scaleLeft = CEIL$1(layerSize.left);
	    results.scaleTop = CEIL$1(layerSize.top);

	    //背景坐标
	    results.scaleBackWidth = CEIL$1(backSize.width);
	    results.scaleBackHeight = CEIL$1(backSize.height);
	    results.scaleBackLeft = CEIL$1(backSize.left);
	    results.scaleBackTop = CEIL$1(backSize.top);

	    return results;
	}

	/**
	 *  读取SVG内容
	 *  @return {[type]} [string]
	 */
	function readFile(path, callback, type) {

	    var paths, name, data;

	    /**
	     * ibooks模式 单独处理svg转化策划给你js,加载js文件
	     * @param  {[type]} window.IBOOKSCONFIG [description]
	     * @return {[type]}              [description]
	     */
	    if (Xut.IBooks.CONFIG) {

	        //如果是.svg结尾
	        //把svg替换成js
	        if (/.svg$/.test(path)) {
	            path = path.replace(".svg", '.js');
	        }

	        //全路径
	        paths = config.svgPath().replace("svg", 'js') + path;
	        //文件名
	        name = path.replace(".js", '');

	        //加载脚本
	        request(paths, function () {
	            data = window.HTMLCONFIG[name] || window.IBOOKSCONFIG[name];
	            if (data) {
	                callback(data);
	                delete window.HTMLCONFIG[name];
	                delete window.IBOOKSCONFIG[name];
	            } else {
	                callback('编译:脚本加载失败,文件名:' + name);
	            }
	        });

	        return;
	    }

	    //con str
	    //externalFile使用
	    //如果是js动态文件
	    //content的html结构
	    if (type === "js") {
	        paths = config.svgPath() + path;
	        name = path.replace(".js", '');
	        request(paths, function () {
	            data = window.window.HTMLCONFIG[name];
	            if (data) {
	                callback(data);
	                delete window.window.HTMLCONFIG[name];
	            } else {
	                callback('运行：脚本加载失败,文件名:' + path);
	            }
	        });
	        return;
	    }

	    //svg文件
	    //游览器模式 && 非强制插件模式
	    if (Xut.plat.isBrowser && !config.isPlugin) {
	        $.ajax({
	            type: 'get',
	            dataType: 'html',
	            url: config.svgPath().replace("www/", "") + path,
	            success: function success(svgContent) {
	                callback(svgContent);
	            },
	            error: function error(xhr, type) {
	                callback('ReadFile数据加载失败');
	                console.log('SVG' + path + '解析出错!');
	            }
	        });
	    } else {
	        Xut.Plugin.ReadAssetsFile.readAssetsFileAction(config.svgPath() + path, function (svgContent) {
	            callback(svgContent);
	        }, function (err) {
	            callback('数据加载失败');
	        });
	    }
	}

	var asyncGenerator = function () {
	  function AwaitValue(value) {
	    this.value = value;
	  }

	  function AsyncGenerator(gen) {
	    var front, back;

	    function send(key, arg) {
	      return new Promise(function (resolve, reject) {
	        var request = {
	          key: key,
	          arg: arg,
	          resolve: resolve,
	          reject: reject,
	          next: null
	        };

	        if (back) {
	          back = back.next = request;
	        } else {
	          front = back = request;
	          resume(key, arg);
	        }
	      });
	    }

	    function resume(key, arg) {
	      try {
	        var result = gen[key](arg);
	        var value = result.value;

	        if (value instanceof AwaitValue) {
	          Promise.resolve(value.value).then(function (arg) {
	            resume("next", arg);
	          }, function (arg) {
	            resume("throw", arg);
	          });
	        } else {
	          settle(result.done ? "return" : "normal", result.value);
	        }
	      } catch (err) {
	        settle("throw", err);
	      }
	    }

	    function settle(type, value) {
	      switch (type) {
	        case "return":
	          front.resolve({
	            value: value,
	            done: true
	          });
	          break;

	        case "throw":
	          front.reject(value);
	          break;

	        default:
	          front.resolve({
	            value: value,
	            done: false
	          });
	          break;
	      }

	      front = front.next;

	      if (front) {
	        resume(front.key, front.arg);
	      } else {
	        back = null;
	      }
	    }

	    this._invoke = send;

	    if (typeof gen.return !== "function") {
	      this.return = undefined;
	    }
	  }

	  if (typeof Symbol === "function" && Symbol.asyncIterator) {
	    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
	      return this;
	    };
	  }

	  AsyncGenerator.prototype.next = function (arg) {
	    return this._invoke("next", arg);
	  };

	  AsyncGenerator.prototype.throw = function (arg) {
	    return this._invoke("throw", arg);
	  };

	  AsyncGenerator.prototype.return = function (arg) {
	    return this._invoke("return", arg);
	  };

	  return {
	    wrap: function (fn) {
	      return function () {
	        return new AsyncGenerator(fn.apply(this, arguments));
	      };
	    },
	    await: function (value) {
	      return new AwaitValue(value);
	    }
	  };
	}();

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var isIOS$2 = Xut.plat.isIOS;
	/**
	 * 获取翻页按钮位置
	 * @return {[type]} [description]
	 */
	var getArrowStyle = function getArrowStyle() {
	    var height = config.iconHeight;
	    var settings = config.settings;
	    var styleText = 'height:' + height + 'px;width:' + height + 'px';
	    switch (settings.NavbarPos) {
	        case 0:
	            styleText += ';top:0';
	            break; //顶部
	        case 1:
	            styleText += ';margin-top:' + -height / 2 + 'px';
	            break; //中间
	        case 2:
	            styleText += ';top:auto;bottom:0';
	            break; //底部
	        default:
	            break;
	    }
	    return styleText;
	};

	var gotoPrevSlide = function gotoPrevSlide() {
	    Xut.View.GotoPrevSlide();
	};

	var gotoNextSlide = function gotoNextSlide() {
	    Xut.View.GotoNextSlide();
	};

	/**
	 * 工具栏超类
	 */

	var Bar = function () {
	    function Bar() {
	        classCallCheck(this, Bar);


	        /**
	         * 系统状态栏高度
	         * @type {[type]}
	         */
	        this.super_barHeight = isIOS$2 ? 20 : 0;

	        var prop = config.proportion;
	        var iconHeight = config.iconHeight;

	        //获取高度缩放比
	        //自动选择缩放比例
	        this.super_propHeight = config.layoutMode == "horizontal" ? prop.width : prop.height;

	        //获取图标高度
	        //工具栏图标高度
	        this.super_iconHeight = isIOS$2 ? iconHeight : Math.round(this.super_propHeight * iconHeight);

	        //应用标题
	        this.appName = config.shortName;

	        //应用默认配置
	        this.settings = config.settings;
	    }

	    /**
	     * 创建翻页按钮
	     * @return {[type]} [description]
	     */


	    createClass(Bar, [{
	        key: 'super_createArrows',
	        value: function super_createArrows() {

	            /**
	             * 存放左右翻页按钮
	             * @type {[type]}
	             */
	            this.arrows = hash();

	            //是否使用自定义的翻页按钮: true /false
	            //图标名称是客户端指定的：pageforward_'+appId+'.svg
	            var isCustom = this.settings.customButton;

	            var $str = void 0;

	            //动态图标，数据库定义的翻页图标
	            //font字体画翻页图标
	            if (isCustom) {
	                $str = $(this._createIcon());
	            } else {
	                $str = $(this._createArrow());
	            }
	            var $left = $str.eq(0);
	            var $right = $str.eq($str.length - 1); //存在文本节点

	            this.arrows = {
	                prev: {
	                    off: this._onArrow($left, gotoPrevSlide),
	                    el: $left,
	                    able: true
	                },
	                next: {
	                    off: this._onArrow($right, gotoNextSlide),
	                    el: $right,
	                    able: true
	                }
	            };

	            this.$sceneNode.append($str);
	        }
	    }, {
	        key: '_onArrow',
	        value: function _onArrow(el, callback) {
	            el.on("mouseup touchend", function (e) {
	                callback();
	                return false;
	            });
	            return function () {
	                el.off();
	                el = null;
	            };
	        }
	    }, {
	        key: '_getArrowOption',
	        value: function _getArrowOption() {
	            var style = getArrowStyle();
	            var state = this.barStatus ? '' : 'hide';
	            var height = config.iconHeight;
	            return {
	                style: style,
	                state: state,
	                height: height
	            };
	        }

	        /**
	         * font字体版本：箭头翻页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createArrow',
	        value: function _createArrow() {
	            var option = this._getArrowOption();
	            return '<div class="si-icon xut-flip-control xut-flip-control-left icomoon icon-angle-left ' + option.state + '"\n                     style="' + option.style + ';text-align:center;line-height:' + option.height + 'px;font-size:4vh;">\n                </div>\n                <div class="si-icon xut-flip-control xut-flip-control-right icomoon icon-angle-right ' + option.state + '"\n                     style="' + option.style + ';text-align:center;line-height:' + option.height + 'px;">\n                </div>';
	        }

	        /**
	         * 客户端指定：自定义翻页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createIcon',
	        value: function _createIcon() {
	            var style = getArrowStyle();
	            var state = this.toolBarStatus ? '' : 'hide';

	            //默认图标路径
	            var leftStyle = style + ';background-image:url(images/icons/pageforward_' + config.appId + '.svg);background-size:cover';
	            var rightStyle = style + ';background-image:url(images/icons/pageback_' + config.appId + '.svg);background-size:cover';

	            return '<div name="prevArrow"\n                     class="xut-flip-control xut-flip-control-left ' + state + '"\n                     style="' + leftStyle + '">\n               </div>\n                <div name="nextArrow"\n                     class="xut-flip-control xut-flip-control-right ' + state + '"\n                     style="' + rightStyle + '">\n                </div>';
	        }

	        /**
	         * 针对单个按钮的显示隐藏处理
	         * @param  {[type]} dir [next,prev]
	         * @param  {[type]} status  [true/false]
	         * @return {[type]}       [description]
	         */

	    }, {
	        key: '_toggleArrow',
	        value: function _toggleArrow(dir, status) {
	            if (!this.arrows) return;
	            var arrow = this.arrows[dir];
	            //如果没有创建翻页按钮,则不处理
	            if (!arrow) return;
	            arrow.able = status;
	            //如果人为隐藏了工具栏,则不显示翻页按钮
	            if (this.hasTopBar && !this.toolBarStatus && status) {
	                return;
	            }
	            arrow.el[status ? 'show' : 'hide']();
	        }

	        /**
	         * 显示翻页按钮
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_showArrow',
	        value: function _showArrow() {
	            var arrows = this.arrows;
	            for (var dir in arrows) {
	                var arrow = arrows[dir];
	                arrow.able && arrow.el.show();
	            }
	        }

	        /**
	         * 隐藏翻页按钮
	         * @param  {[type]} unlock [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_hideArrow',
	        value: function _hideArrow() {
	            var arrows = this.arrows;
	            for (var dir in arrows) {
	                arrows[dir].el.hide();
	            }
	        }

	        /**
	         * 显示IOS系统工具栏
	         *  iOS状态栏0=show,1=hide
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'super_showSystemBar',
	        value: function super_showSystemBar() {
	            isIOS$2 && Xut.plat.hasPlugin && Xut.Plugin.statusbarPlugin.setStatus(null, null, 0);
	        }

	        /**
	         * 隐藏IOS系统工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'super_hideSystemBar',
	        value: function super_hideSystemBar() {
	            isIOS$2 && Xut.plat.hasPlugin && Xut.Plugin.statusbarPlugin.setStatus(null, null, 1);
	        }

	        /**
	         * 超类销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'super_destory',
	        value: function super_destory() {
	            if (this.arrows) {
	                this.arrows.prev.off();
	                this.arrows.next.off();
	                this.arrows = null;
	            }
	        }

	        /**
	         * 隐藏下一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideNext',
	        value: function hideNext() {
	            this._toggleArrow('next', false);
	        }

	        /**
	         * 显示下一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showNext',
	        value: function showNext() {
	            this._toggleArrow('next', true);
	        }

	        /**
	         * 隐藏上一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hidePrev',
	        value: function hidePrev() {
	            this._toggleArrow('prev', false);
	        }

	        /**
	         * 显示上一页按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showPrev',
	        value: function showPrev() {
	            this._toggleArrow('prev', true);
	        }

	        /**
	         * [ 显示工具栏]
	         * @param  {[type]} pointer [description]
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: '_showToolBar',
	        value: function _showToolBar(pointer) {
	            switch (pointer) {
	                case 'controlBar':
	                    this.showTopBar();
	                    break;
	                case 'button':
	                    this._showArrow();
	                    this.Lock = false;
	                    break;
	                default:
	                    this.showTopBar();
	                    this._showArrow();
	            }
	        }

	        /**
	         * [ 隐藏工具栏]
	         * @param  {[type]} pointer [description]
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: '_hideToolBar',
	        value: function _hideToolBar(pointer) {
	            switch (pointer) {
	                case 'controlBar':
	                    this.hideTopBar();
	                    break;
	                case 'button':
	                    this._hideArrow();
	                    this.Lock = false;
	                    break;
	                default:
	                    this.hideTopBar();
	                    this._hideArrow();
	            }
	        }

	        /**
	         * 切换状态
	         * @param  {[type]} state   [description]
	         * @param  {[type]} pointer [description]
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: 'toggle',
	        value: function toggle(state, pointer) {
	            if (this.Lock) return;
	            this.Lock = true;
	            switch (state) {
	                case 'show':
	                    this._showToolBar(pointer);
	                    break;
	                case 'hide':
	                    this._hideToolBar(pointer);
	                    break;
	                default:
	                    //默认：工具栏显示隐藏互斥处理
	                    this.toolBarStatus ? this._hideToolBar(pointer) : this._showToolBar(pointer);
	                    break;
	            }
	        }

	        /**
	         * 重置翻页按钮,状态以工具栏为标准
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'resetArrow',
	        value: function resetArrow() {
	            this.toolBarStatus ? this._showArrow() : this._hideArrow();
	        }
	    }]);
	    return Bar;
	}();

	var round = Math.round;
	var ratio = 6;
	var isIOS$3 = Xut.plat.isIOS;
	var TOP = isIOS$3 ? 20 : 0;

	var getNavOptions = function getNavOptions() {

	    var iconHeight = config.iconHeight;
	    var proportion = config.proportion;
	    var viewSize = config.viewSize;

	    //横版模式
	    var isHorizontal = config.layoutMode == 'horizontal';

	    proportion = isHorizontal ? proportion.width : proportion.height;
	    iconHeight = isIOS$3 ? iconHeight : round(proportion * iconHeight);

	    //导航菜单宽高
	    var navHeight = void 0,
	        navWidth = void 0;
	    var sWidth = viewSize.width;
	    var sHeight = viewSize.height;

	    //横版模版
	    if (isHorizontal) {
	        navHeight = round(sHeight / ratio);
	    } else {
	        navWidth = Math.min(sWidth, sHeight) / (isIOS$3 ? 8 : 3);
	        navHeight = round((sHeight - iconHeight - TOP) * 0.96);
	    }

	    return {
	        sWidth: sWidth,
	        sHeight: sHeight,
	        navHeight: navHeight,
	        navWidth: navWidth,
	        proportion: proportion
	    };
	};

	/**
	 * 获得css配置数据
	 * @param  {[type]} seasonlist [description]
	 * @return {[type]}            [description]
	 */
	var getWrapper = function getWrapper(seasonlist) {

	    var width = void 0,
	        height = void 0,
	        blank = void 0,
	        scroller = void 0,
	        contentstyle = void 0,
	        containerstyle = void 0,
	        overwidth = void 0,
	        overHeigth = void 0;

	    //获得css配置数据
	    var options = getNavOptions();
	    var font = round(options.proportion * 2);

	    var navWidth = options.navWidth;
	    var navHeight = options.navHeight;
	    var sWidth = options.sWidth;
	    var sHeight = options.sHeight;

	    if (config.layoutMode == 'horizontal') {
	        height = round(navHeight * 0.9);
	        width = round(height * sWidth / sHeight); //保持缩略图的宽高比
	        blank = round(navHeight * 0.05); //缩略图之间的间距
	        scroller = 'width:' + seasonlist * (width + blank) + 'px>';
	        contentstyle = 'float:left;width:' + width + 'px;height:' + height + 'px;margin-left:' + blank + 'px';
	        containerstyle = 'width:96%;height:' + height + 'px;margin:' + blank + 'px auto;font-size:' + font + 'em';
	        //横版左右滑动
	        //溢出长度+上偏移量
	        overwidth = width * seasonlist + seasonlist * blank;
	    } else {
	        width = round(navWidth * 0.9);
	        height = round(navWidth * 1.1);
	        blank = round(navWidth * 0.05);
	        contentstyle = 'width:' + width + 'px;height:' + height + 'px;margin:' + blank + 'px auto;border-bottom:1px solid rgba(0,0,0,0.3)';
	        containerstyle = 'height:' + (navHeight - 4) + 'px;overflow:hidden;margin:2px auto;font-size:' + font + 'em';
	        //竖版上下滑动
	        overHeigth = height * seasonlist + seasonlist * blank;
	    }

	    return {
	        contentstyle: contentstyle,
	        containerstyle: containerstyle,
	        overwidth: overwidth,
	        overHeigth: overHeigth,
	        scroller: scroller
	    };
	};

	/**
	 * 导航菜单
	 * @param  {[type]} seasonSqlRet [description]
	 * @return {[type]}              [description]
	 */
	function navLayout(results) {

	    var seasonlist = results.length;
	    var options = getWrapper(seasonlist);

	    var list = '';
	    var seasonId = void 0;
	    var chapterId = void 0;
	    var data = void 0;
	    var xxtlink = void 0;

	    for (var i = 0; i < seasonlist; i++) {
	        data = results[i];
	        seasonId = data.seasonId;
	        chapterId = data._id;
	        xxtlink = seasonId + '-' + chapterId;
	        list += '<li style="' + options.contentstyle + '">\n                <div data-xxtlink="' + xxtlink + '">\n                    ' + (i + 1) + '\n                </div>\n           </li>';
	    }

	    //导航
	    var navHTML = '<div id="xut-nav-wrapper" style="' + options.containerstyle + '">\n            <div style="width:' + options.overwidth + 'px;\n                                           height:' + options.overHeigth + 'px;\n                                           ' + options.scroller + '">\n                <ul id="xut-nav-section-list">\n                    ' + list + '\n                </ul>\n            </div>\n        </div>';

	    return String.styleFormat(navHTML);
	}

	/**
	 * 下拉章节列表
	 */

	var Section = function () {
	    function Section(data) {
	        classCallCheck(this, Section);

	        this._isHorizontal = config.layoutMode === 'horizontal';
	        this._pagedata = data;
	        this._$section = $('#xut-nav-section-list');
	        this._$list = this._$section.find("li");
	    }

	    /**
	     * 卷滚条
	     * @param  {[type]} pageIndex [description]
	     * @return {[type]}           [description]
	     */


	    createClass(Section, [{
	        key: 'userIscroll',
	        value: function userIscroll(pageIndex) {
	            var _this = this;

	            var isHorizontal = this._isHorizontal;

	            if (this.hBox) {
	                if (isHorizontal) {
	                    this.hBox.goToPage(pageIndex, 0, 0);
	                } else {
	                    this.hBox.goToPage(0, pageIndex, 0);
	                }
	            } else {
	                this.hBox = new iScroll('#xut-nav-wrapper', {
	                    snap: 'li',
	                    tap: true,
	                    scrollX: isHorizontal,
	                    scrollY: !isHorizontal,
	                    scrollbars: true,
	                    fadeScrollbars: true,
	                    stopPropagation: true
	                });

	                //滑动结束,动态处理缩略图
	                this.hBox.on('scrollEnd', function (e) {
	                    _this.createThumb();
	                    _this._removeThumb();
	                });

	                this._$section.on('tap', this._toJump);
	            }
	        }

	        /**
	         * 点击元素跳转
	         */

	    }, {
	        key: '_toJump',
	        value: function _toJump(e) {
	            var target = e.target;
	            var xxtlink = void 0;
	            if (target) {
	                var _xxtlink = target.getAttribute('data-xxtlink');
	                if (_xxtlink) {
	                    _xxtlink = _xxtlink.split('-');
	                    Xut.View.GotoSlide(_xxtlink[0], _xxtlink[1]);
	                }
	            }
	        }

	        /**
	         * [ 创建缩略图]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createThumb',
	        value: function createThumb() {
	            var index = this._getPageIndex(),
	                //最左边的索引
	            count = this._getViewLen(),
	                //允许显示的页数
	            createBak = this.createBak || [],
	                //已创建的页码索引
	            createNew = [],
	                //新建的页码索引
	            pageData = this._pagedata,
	                maxLen = pageData.length,
	                path = config.pathAddress;

	            //确保不会溢出
	            count = count > maxLen ? maxLen : count;
	            //尽可能地填满
	            index = index + count > maxLen ? maxLen - count : index;

	            var i = 0;
	            var j = void 0;
	            var page = void 0;

	            for (i = 0; i < count; i++) {
	                j = index + i;
	                page = pageData[j];
	                createNew.push(j);
	                if (_.contains(createBak, j)) continue;
	                createBak.push(j);

	                //如果是分层母板了,此时用icon代替
	                if (page.iconImage) {
	                    this._$list.eq(j).css({
	                        'background-image': 'url(' + path + page.iconImage + ')'
	                    });
	                } else {
	                    this._$list.eq(j).css({
	                        'background-image': 'url(' + path + page.md5 + ')',
	                        'background-color': 'white'
	                    });
	                }
	            }

	            this.createNew = createNew;
	            this.createBak = createBak;
	        }

	        /**
	         * [ 清理隐藏的缩略图]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_removeThumb',
	        value: function _removeThumb() {
	            var list = this._$list;
	            var createNew = this.createNew;
	            var createBak = this.createBak;

	            _.each(createBak, function (val, i) {
	                if (!_.contains(createNew, val)) {
	                    //标记要清理的索引
	                    createBak[i] = -1;
	                    list.eq(val).css({
	                        'background': ''
	                    });
	                }
	            });

	            //执行清理
	            this.createBak = _.without(createBak, -1);
	        }

	        /**
	         * [ 得到滑动列表中最左侧的索引]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_getPageIndex',
	        value: function _getPageIndex() {
	            if (this.hBox.options.scrollX) {
	                return this.hBox.currentPage.pageX;
	            } else {
	                return this.hBox.currentPage.pageY;
	            }
	        }

	        /**
	         * [ 获取待创建的缩略图的个数]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_getViewLen',
	        value: function _getViewLen() {
	            var hBox = this.hBox,
	                eleSize = 1,
	                //单个li的高度,
	            count = 1,
	                len = this._pagedata.length; //li的总数

	            if (this._isHorizontal) {
	                eleSize = hBox.scrollerWidth / len;
	                count = hBox.wrapperWidth / eleSize;
	            } else {
	                eleSize = hBox.scrollerHeight / len;
	                count = hBox.wrapperHeight / eleSize;
	            }
	            //多创建一个
	            return Math.ceil(count) + 1;
	        }

	        /**
	         * 滚动指定位置
	         */

	    }, {
	        key: 'scrollTo',
	        value: function scrollTo(pageIndex) {
	            this.userIscroll(pageIndex);
	        }

	        /**
	         * 刷新
	         */

	    }, {
	        key: 'refresh',
	        value: function refresh() {
	            this.hBox && this.hBox.refresh();
	        }

	        /**
	         * 销毁
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this.hBox) {
	                this._$section.off();
	                this._$section = null;
	                this._$list = null;
	                this.hBox.destroy();
	                this.hBox = null;
	            }
	            this._pagedata = null;
	        }
	    }]);
	    return Section;
	}();

	var Navbar = function () {
	    createClass(Navbar, [{
	        key: 'toggle',


	        /**
	         * 切换
	         * @param  {[type]} pageIndex [description]
	         * @return {[type]}           [description]
	         */
	        value: function toggle(pageIndex) {
	            this.pageIndex = pageIndex;
	            this._navControl();
	        }

	        /**
	         * 隐藏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hide',
	        value: function hide() {
	            this.isRunning && this._navControl();
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this.sectionObj) {
	                this.sectionObj.destroy();
	                this.sectionObj = null;
	            }
	            this.$container = null;
	            this.$button = null;
	        }
	    }]);

	    function Navbar(pageIndex) {
	        classCallCheck(this, Navbar);

	        this.pageIndex = pageIndex;
	        this.isRunning = false; //运行状态
	        this.$container = $(".xut-nav-bar"); //显示容器
	        this.$button = $(".xut-control-navbar"); //触发按钮
	        this._initialize();
	    }

	    createClass(Navbar, [{
	        key: '_initialize',
	        value: function _initialize() {
	            var _this = this;

	            var data = [];
	            Xut.data.query('Chapter', Xut.data.novelId, 'seasonId', function (item) {
	                return data.push(item);
	            });
	            Xut.nextTick({
	                'container': this.$container,
	                'content': navLayout(data)
	            }, function () {
	                _this.sectionObj = new Section(data); //目录对象
	                _this.sectionObj.userIscroll(_this.pageIndex); //初始化滑动
	                _this.sectionObj.createThumb(); //初始缩略图
	                _this._navControl(); //初始化样式
	            });
	        }

	        /**
	         * 控制导航条
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_navControl',
	        value: function _navControl() {

	            var action = this.$button.attr('fly') || 'in'; //判断点击的动作
	            var isIn = action === 'in';

	            //初始化目录栏的样式
	            //能够显示出来
	            if (isIn) {
	                this.$container.css({
	                    'z-index': 0,
	                    'opacity': 0,
	                    'display': 'block'
	                });
	            }

	            //触发控制条
	            this.$button.css('opacity', isIn ? 0.5 : 1);

	            //执行动画
	            //出现
	            if (isIn) {
	                //导航需要重置
	                //不同的页面定位不一定
	                this.sectionObj.refresh();
	                this.sectionObj.scrollTo(this.pageIndex);

	                //动画出现
	                this.$container.css({
	                    'z-index': Xut.zIndexlevel(),
	                    'opacity': 1
	                });
	                this.$button.attr('fly', 'out');
	                this.isRunning = true;
	            } else {
	                //隐藏
	                this.$button.attr('fly', 'in');
	                this.$container.hide();
	                this.isRunning = false;
	            }
	        }
	    }]);
	    return Navbar;
	}();

	/**
	 * 跳转首页
	 * @return {[type]} [description]
	 */
	function goHomePage() {
	    if (window.DUKUCONFIG) {
	        Xut.Application.Stop({
	            processed: function processed() {
	                Xut.Application.DropApp(); //退出应用
	            }
	        });
	        return;
	    }
	    //动作处理
	    //如果有动作则关闭，否则直接跳转
	    Xut.Application.Stop({
	        processed: function processed() {
	            Xut.View.GotoSlide(1);
	        }
	    });
	}

	/**
	 * 创建主页按钮
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createHomeIcon(height) {
	    return "<div class=\"xut-control-backhome\"\n                 style=\"float:left;text-indent:0.25em;height:" + height + "px;line-height:" + height + "px;color:#007aff\">\n                \u4E3B\u9875\n            </div>";
	}

	/**
	 * 创建目录按钮
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createDirIcon(height) {
	    return "<div class=\"xut-control-navbar\"\n                 style=\"float:left;margin-left:4px;width:" + height + "px;height:" + height + "px;background-size:cover\">\n            </div>";
	}

	/**
	 * 应用标题
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createTitle(height, appName) {
	    return "<div class=\"xut-control-title\"\n                 style=\"z-index:-99;width:100%;position:absolute;line-height:" + height + "px;pointer-events:none\">\n                " + appName + "\n            </div>";
	}

	/**
	 * 创建页码数
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createPageNumber(height, currentPage, pageTotal) {
	    var marginTop = height * 0.25;
	    var iconH = height * 0.5;
	    return "<div class=\"xut-control-pageIndex\"\n                 style=\"float:right;\n                        margin:" + marginTop + "px 4px;\n                        padding:0 0.25em;\n                        height:" + iconH + "px;\n                        line-height:" + iconH + "px;\n                        border-radius:0.5em\">\n                  <span class=\"control-current-page\">" + currentPage + "</span>/<span>" + pageTotal + "</span>\n            </div>";
	}

	/**
	 * 工具栏隐藏按钮
	 * @param  {[type]} bar [description]
	 * @return {[type]}     [description]
	 */
	function createHideToolbar(height) {
	    return "<div class=\"xut-control-hidebar\"\n                 style=\"float:right;width:" + height + "px;height:" + height + "px;background-size:cover\">\n            </div>";
	}

	/**
	 * 关闭子文档按钮(font字体版本)
	 * @param  {[type]} height [description]
	 * @return {[type]}        [description]
	 */
	function createCloseIcon(height) {
	    return "<div class=\"si-icon icomoon icon-close\"\n                 style=\"float:right;margin-right:4px;width:" + height + "px;height:" + height + "px\">\n            </div>";
	}

	var sysBar = function (_Bar) {
	    inherits(sysBar, _Bar);

	    function sysBar() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            controlNode = _ref.controlNode,
	            sceneNode = _ref.sceneNode,
	            pageMode = _ref.pageMode,
	            pageTotal = _ref.pageTotal,
	            currentPage = _ref.currentPage,
	            toolType = _ref.toolType;

	        classCallCheck(this, sysBar);

	        var _this = possibleConstructorReturn(this, (sysBar.__proto__ || Object.getPrototypeOf(sysBar)).call(this));

	        _this.curTips = null; //当前页码对象
	        _this.Lock = false; //操作锁
	        _this.delay = 50; //动画延时
	        _this.hasTopBar = true; //有顶部工具条

	        _this.$controlNode = controlNode; //导航控制条节点
	        _this.eventElement = controlNode[0]; //绑定事件
	        _this.$sceneNode = sceneNode; //场景根节点
	        _this.pageTotal = pageTotal;
	        _this.currentPage = currentPage;

	        //顶部工具栏可配置
	        //0 禁止工具栏
	        //1 系统工具栏 - 显示IOS系统工具栏
	        _.some(toolType) && _this._initToolbar();

	        //翻页按钮
	        pageMode == 2 && _this.super_createArrows();
	        return _this;
	    }

	    /**
	     * 初始化顶部工具栏
	     * @return {[type]} [description]
	     */


	    createClass(sysBar, [{
	        key: '_initToolbar',
	        value: function _initToolbar() {

	            var $controlNode = this.$controlNode;
	            var setting = this.settings;
	            var iconHeight = this.super_iconHeight;

	            //工具栏的显示状态
	            this.toolBarStatus = $controlNode.css('display') === 'none' ? false : true;

	            //工具栏摆放位置
	            this._toolbarPostion($controlNode, setting.ToolbarPos);

	            var html = '';

	            //首页按钮
	            if (setting.HomeBut) {
	                html += createHomeIcon(iconHeight);
	            }

	            //目录按钮
	            if (setting.ContentBut) {
	                html += createDirIcon(iconHeight);
	            }

	            //添加标题
	            html += createTitle(iconHeight, this.appName);

	            //工具栏隐藏按钮
	            html += createHideToolbar(iconHeight);

	            //关闭子文档
	            if (setting.CloseBut) {
	                html += createCloseIcon(iconHeight);
	            }

	            //页码数
	            if (setting.PageBut) {
	                html += createPageNumber(iconHeight, this.currentPage, this.pageTotal);
	            }

	            //显示
	            Xut.nextTick($controlNode.append(String.styleFormat(html)));

	            //当前页码标识
	            this.curTips = $controlNode.find('.control-current-page');

	            //事件
	            $$on(this.eventElement, {
	                start: this
	            });
	        }

	        /**
	         * 相应事件
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {
	            $$handle({
	                start: function start(e) {
	                    switch ($$target(e).className) {
	                        //跳主页
	                        case "xut-control-backhome":
	                            goHomePage();
	                            break;
	                        //切换目录
	                        case "xut-control-navbar":
	                            this._toggleNavBar();
	                            break;
	                        //隐藏工具栏
	                        case 'xut-control-hidebar':
	                            this.hideTopBar();
	                            break;
	                    }
	                }
	            }, this, e);
	        }

	        /**
	         * 系统工具条的位置
	         * position
	         *     0 顶部
	         *     1 底部
	         * @param  {[type]} bar      [description]
	         * @param  {[type]} position [description]
	         * @return {[type]}          [description]
	         */

	    }, {
	        key: '_toolbarPostion',
	        value: function _toolbarPostion($controlNode, position) {
	            var height = this.super_iconHeight;
	            if (position == 1) {
	                //在底部
	                $controlNode.css({
	                    bottom: 0,
	                    height: height + 'px'
	                });
	            } else {
	                //在顶部
	                $controlNode.css({
	                    top: 0,
	                    height: height + 'px',
	                    paddingTop: this.super_barHeight + 'px'
	                });
	            }
	        }

	        /**
	         * 切换目录导航
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_toggleNavBar',
	        value: function _toggleNavBar() {
	            var pageIndex = Xut.Presentation.GetPageIndex();
	            if (this.navbarObj) {
	                this.navbarObj.toggle(pageIndex);
	            } else {
	                this.navbarObj = new Navbar(pageIndex);
	            }
	        }

	        /**
	         * 更新页码指示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer(_ref2) {
	            var parentIndex = _ref2.parentIndex;

	            this.curTips && this.curTips.html(parentIndex + 1);
	        }

	        /**
	         * 隐藏导航栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideNavbar',
	        value: function hideNavbar() {
	            this.navbarObj && this.navbarObj.hide('hide');
	        }

	        /**
	         * 显示顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showTopBar',
	        value: function showTopBar() {
	            var that = this;

	            if (this.toolBarStatus) {
	                this.Lock = false;
	                return;
	            }
	            this.$controlNode.css({
	                'display': 'block',
	                'opacity': 0
	            });

	            Xut.nextTick(function () {
	                that.$controlNode && that.$controlNode.animate({
	                    'opacity': 1
	                }, that.delay, 'linear', function () {
	                    that.hideNavbar();
	                    that.super_showSystemBar();
	                    that.toolBarStatus = true;
	                    that.Lock = false;
	                });
	            });
	        }

	        /**
	         * 隐藏顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideTopBar',
	        value: function hideTopBar() {
	            var that = this;

	            if (!this.toolBarStatus) {
	                this.Lock = false;
	                return;
	            }

	            this.$controlNode.animate({
	                'opacity': 0
	            }, that.delay, 'linear', function () {
	                that.hideNavbar();
	                that.$controlNode.hide();
	                that.super_hideSystemBar();
	                that.toolBarStatus = false;
	                that.Lock = false;
	            });
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            //目录导航
	            this.navbarObj && this.navbarObj.destroy();

	            //解除事件
	            $$off(this.eventElement, {
	                start: this
	            });

	            //销毁超类
	            this.super_destory();

	            this.curTips = null;
	            this.toolBarStatus = false;
	            this.$controlNode = null;
	            this.eventElement = null;
	        }
	    }]);
	    return sysBar;
	}(Bar);

	var isIOS$4 = Xut.plat.isIOS;

	var closeScenario = function closeScenario() {
	    Xut.View.CloseScenario();
	};

	var fnBar = function (_Bar) {
	    inherits(fnBar, _Bar);

	    function fnBar() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            pageMode = _ref.pageMode,
	            sceneNode = _ref.sceneNode,
	            toolType = _ref.toolType,
	            pageTotal = _ref.pageTotal,
	            currentPage = _ref.currentPage;

	        classCallCheck(this, fnBar);

	        var _this = possibleConstructorReturn(this, (fnBar.__proto__ || Object.getPrototypeOf(fnBar)).call(this));

	        _this.pageTips = null;
	        _this.currTip = null;
	        _this.tipsMode = 0;
	        _this.top = 0;
	        _this.Lock = false;
	        _this.delay = 50;
	        _this.hasTopBar = false;
	        _this.barStatus = true;

	        //options
	        _this.pageMode = pageMode;
	        _this.$sceneNode = sceneNode;
	        _this.toolType = toolType;
	        _this.pageTotal = pageTotal;
	        _this.currentPage = currentPage;

	        _this._initTool();
	        return _this;
	    }

	    /**
	     * 创建工具栏
	     * toolType:
	     *      0   禁止工具栏
	     *      1   系统工具栏   - 显示IOS系统工具栏
	     *      2   场景工具栏   - 显示关闭按钮
	     *      3   场景工具栏   - 显示返回按钮
	     *      4   场景工具栏   - 显示顶部小圆点式标示
	     *  pageMode:
	     *      0禁止滑动
	     *      1允许滑动无翻页按钮
	     *      2 允许滑动带翻页按钮
	     * @return {[type]} [description]
	     */


	    createClass(fnBar, [{
	        key: '_initTool',
	        value: function _initTool() {
	            var $sceneNode = this.$sceneNode;

	            var type = void 0;

	            $sceneNode.hide();

	            this.controlBar = [];
	            //配置工具栏
	            while (type = this.toolType.shift()) {
	                switch (type) {
	                    case 1:
	                        this._createSystemBar();
	                        break;
	                    case 2:
	                        this._createCloseIcon();
	                        break;
	                    case 3:
	                        this._createBackIcon();
	                        break;
	                    case 4:
	                        this._createPageTips();
	                        break;
	                    default:
	                        this.barStatus = false;
	                        this.hasTopBar = false;
	                        break;
	                }
	            }

	            //创建翻页按钮
	            if (this.pageMode === 2) {
	                this.super_createArrows();
	            }

	            $sceneNode.show();
	        }

	        /**
	         * 系统工具栏
	         */

	    }, {
	        key: '_createSystemBar',
	        value: function _createSystemBar() {
	            var height = this.super_barHeight;
	            var html = '<div class="xut-control-bar"\n                         style="top:0;height:' + this.super_iconHeight + 'px;padding-top:' + height + 'px">\n                    </div>';
	            html = $(String.styleFormat(html));
	            this.top = height;
	            this.super_showSystemBar();
	            this._createBackIcon(html);
	            this._createTitle(html);
	            this._createPageNum(html);
	            this.controlBar = html;
	            this.$sceneNode.append(html);
	            this.hasTopBar = true;
	        }

	        /**
	         * 页码小圆点
	         */

	    }, {
	        key: '_createPageTips',
	        value: function _createPageTips() {
	            var _this2 = this;

	            var chapters = this.pageTotal;
	            var height = this.super_iconHeight;
	            var html = '';

	            //li内容
	            var content = '';

	            //如果只有一页则不显示小圆
	            if (chapters < 2) {
	                return html;
	            }

	            //圆点尺寸
	            var size = isIOS$4 ? 7 : Math.max(8, Math.round(this.super_propHeight * 8));
	            var width = 2.5 * size; //圆点间距
	            var tipsWidth = chapters * width; //圆点总宽度
	            var top = (height - size) / 2; //保持圆点垂直居中
	            var left = (config.viewSize.width - tipsWidth) / 2; //保持圆点水平居中


	            for (var i = 1; i <= chapters; i++) {
	                content += '<li class="xut-scenario-dark" \n                      style="float:left;width:' + width + 'px;height:' + height + 'px;" \n                      data-index="' + i + '">\n                    <div class="xut-scenario-radius" \n                          style="width:' + size + 'px;height:' + size + 'px;margin:' + top + 'px auto">\n                    </div>\n                </li>';
	            }

	            html = '<ul class="xut-scenario-tips"  \n                    style="top:' + this.top + 'px;left:' + left + 'px;width:' + tipsWidth + 'px;opacity:0.6">\n                    ' + content + '\n                </ul>';

	            html = $(String.styleFormat(html));

	            //点击跳转页面
	            this.$tipsNode = html;
	            this.$tipsNode.on('click', function (e) {
	                var target = e.target;
	                switch (target.className) {
	                    case 'xut-control-nav-hide':
	                        _this2.hideTopBar();
	                        break;
	                    case 'xut-scenario-dark':
	                        if (_this2.pageMode) {
	                            var index = target.getAttribute('data-index') || 1;
	                            Xut.View.GotoSlide(Number(index));
	                        }
	                        break;
	                    default:
	                        break;
	                }
	            });
	            this.pageTips = html.children();
	            this.tipsMode = 1;
	            this.controlBar.push(html);
	            this.$sceneNode.append(html);
	        }

	        /**
	         * 更新页码指示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer(_ref2) {
	            var parentIndex = _ref2.parentIndex;

	            switch (this.tipsMode) {
	                case 1:
	                    if (this.prevTip) {
	                        this.prevTip.className = 'xut-scenario-dark';
	                    }
	                    this.currTip = this.pageTips[parentIndex];
	                    this.currTip.className = 'xut-scenario-light';
	                    this.prevTip = this.currTip;
	                    break;
	                case 2:
	                    this.currTip.html(parentIndex + 1);
	                    break;
	                default:
	                    break;
	            }
	        }
	    }, {
	        key: '_onBackClose',
	        value: function _onBackClose(el) {
	            el.on("mouseup touchend", function (e) {
	                closeScenario();
	                return false;
	            });
	            return function () {
	                el.off();
	                el = null;
	            };
	        }

	        /**
	         * font字体版本：关闭按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createCloseIcon',
	        value: function _createCloseIcon() {
	            var height = this.super_iconHeight;
	            var html = $('<div class="si-icon xut-scenario-close icomoon icon-close" \n                style="top:' + this.top + 'px;width:' + height + 'px;height:' + height + 'px;line-height:' + height + 'px;text-align:center;font-size:3vh;">\n            </div>');

	            this.$closeIcon = html;
	            this._onBackClose(this.$closeIcon);
	            this.controlBar.push(html);
	            this.$sceneNode.append(html);
	        }

	        /**
	         * font字体版本：返回按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createBackIcon',
	        value: function _createBackIcon() {
	            var height = this.super_iconHeight;
	            var html = $('<div class="si-icon xut-scenario-back icomoon icon-arrow-left" \n                  style="top:' + this.top + 'px;width:' + height + 'px;height:' + height + 'px;line-height:' + height + 'px;">\n            </div>');

	            this.$backIcon = html;
	            this._onBackClose(this.$backIcon);
	            this.controlBar.push(html);
	            this.$sceneNode.append(html);
	        }

	        /**
	         * 创建页码数
	         * @param  {[type]} $sceneNode [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_createPageNum',
	        value: function _createPageNum($sceneNode) {
	            var pageTotal = this.pageTotal,
	                TOP = this.top,
	                height = this.super_iconHeight,
	                currentPage = this.currentPage,
	                style,
	                html;

	            html = '<div class="xut-control-pageindex" \n                  style="position:absolute;\n                         right:4px;\n                         top:' + (height * 0.25 + TOP) + 'px;\n                         padding:0 0.25em;\n                         height:' + height * 0.5 + 'px;\n                         line-height:' + height * 0.5 + 'px;\n                         border-radius:0.5em">\n                <span class="currentPage">' + currentPage + '</span>/<span>' + pageTotal + '</span>\n            </div>';
	            html = $(String.styleFormat(html));
	            this.tipsMode = 2;
	            this.currTip = html.children().first();
	            $sceneNode.append(html);
	        }

	        /**
	         * 应用标题
	         * @param  {[type]} $sceneNode [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_createTitle',
	        value: function _createTitle($sceneNode) {
	            var html = '<div class="xut-control-title"\n                  style="line-height:' + this.super_iconHeight + 'px">\n                ' + this.appName + '\n            </div>';
	            $sceneNode.append(String.styleFormat(html));
	        }

	        /**
	         * 显示顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showTopBar',
	        value: function showTopBar() {
	            var that = this,
	                delay = this.delay,
	                controlBar = this.controlBar;
	            if (this.barStatus) {
	                this.Lock = false;
	                return;
	            }
	            if (this.hasTopBar) {
	                controlBar.css({
	                    'display': 'block',
	                    'opacity': 0
	                });
	                setTimeout(function () {
	                    controlBar.animate({
	                        'opacity': 1
	                    }, delay, 'linear', function () {
	                        that.__showSystemBar();
	                        that.barStatus = true;
	                        that.Lock = false;
	                    });
	                });
	            } else {
	                controlBar.forEach(function (el) {
	                    el.show();
	                    that.Lock = false;
	                    that.barStatus = true;
	                });
	            }
	        }

	        /**
	         * 隐藏顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideTopBar',
	        value: function hideTopBar() {
	            var that = this,
	                delay = this.delay,
	                controlBar = this.controlBar;

	            if (!this.barStatus) {
	                this.Lock = false;
	                return;
	            }
	            if (this.hasTopBar) {
	                controlBar.animate({
	                    'opacity': 0
	                }, delay, 'linear', function () {
	                    that.controlBar.hide();
	                    that.__hideSystemBar();
	                    that.barStatus = false;
	                    that.Lock = false;
	                });
	            } else {
	                controlBar.forEach(function (el) {
	                    el.hide(delay, function () {
	                        that.Lock = false;
	                        that.barStatus = false;
	                    });
	                });
	            }
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.$sceneNode = null;
	            this.controlBar = null;
	            this.pageTips = null;
	            this.currTip = null;
	            this.prevTip = null;

	            //小图标点击事件
	            if (this.$tipsNode) {
	                this.$tipsNode.off();
	                this.$tipsNode = null;
	            }

	            //关闭按钮
	            if (this.$closeIcon) {
	                this.$closeIcon.off();
	                this.$closeIcon = null;
	            }

	            //返回按钮
	            if (this.$backIcon) {
	                this.$backIcon.off();
	                this.$backIcon = null;
	            }

	            //销毁超类
	            this.super_destory();
	        }
	    }]);
	    return fnBar;
	}(Bar);

	/**
	 * 行高
	 * @type {[type]}
	 */
	var sLineHeiht = parseInt($('body').css('font-size')) || 16; //行高

	/**
	 * 书签缓存
	 */
	var BOOKCACHE = void 0;

	var Mark = function () {
	    function Mark() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            parent = _ref.parent,
	            pageId = _ref.pageId,
	            seasonId = _ref.seasonId;

	        classCallCheck(this, Mark);

	        this.parent = parent;
	        this.pageId = pageId;
	        this.seasonId = seasonId;

	        this.viewSize = config.viewSize;
	        this.sHeight = this.viewSize.height;
	        this.sWidth = this.viewSize.width;

	        //是否已存储
	        this.isStored = false;
	        this.init();
	    }

	    /**
	     * 初始化
	     * @return {[type]} [description]
	     */


	    createClass(Mark, [{
	        key: 'init',
	        value: function init() {
	            var $bookMark = this.createBookMarkFont(),
	                dom = this.parent[0],
	                that = this;

	            this.parent.append($bookMark);
	            this.bookMarkMenu = $bookMark.eq(0);
	            //显示书签
	            setTimeout(function () {
	                that.restore();
	            }, 20);
	            //获取历史记录
	            BOOKCACHE = this.getHistory();

	            //邦定用户事件
	            $$on(dom, {
	                end: this
	            });
	        }

	        /**
	         * 创建书签(font版本)
	         * @return {[object]} [jquery生成的dom对象]
	         */

	    }, {
	        key: 'createBookMarkFont',
	        value: function createBookMarkFont() {
	            var height = sLineHeiht * 3; // menu的高为3em
	            var sHeight = this.sHeight;
	            var box = '<div class="xut-bookmark-menu" \n               style="width:100%;height:' + height + 'px;left:0;top:' + sHeight + 'px;">\n              <div class="xut-bookmark-wrap">\n                <div class="xut-bookmark-add">\u52A0\u5165\u4E66\u7B7E</div>\n                <div class="xut-bookmark-off icomoon icon-chevron-down" style="vertical-align:bottom;"></div>\n                <div class="xut-bookmark-view">\u4E66\u7B7E\u8BB0\u5F55</div>\n              </div>\n            </div>\n            <div class="xut-bookmark-list" style="display:none;width:100%;height:' + sHeight + 'px;">\n              <ul class="xut-bookmark-head">\n                <li class="xut-bookmark-back">\u8FD4\u56DE</li>\n                <li>\u4E66\u7B7E</li>\n              </ul>\n              <ul class="xut-bookmark-body"></ul>\n            </div>';
	            this.markHeight = height;
	            return $(box);
	        }

	        /**
	         * 生成书签列表
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createMarkList',
	        value: function createMarkList() {
	            var tmp,
	                seasonId,
	                pageId,
	                list = '',
	                box = '',
	                self = this;

	            //取历史记录
	            _.each(BOOKCACHE, function (mark) {
	                tmp = mark.split('-');
	                seasonId = tmp[0];
	                pageId = tmp[1];
	                mark = self.getMarkId(seasonId, pageId);
	                list += '<li>\n               <a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">\u7B2C' + pageId + '\u9875</a>\n               <a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a>\n             </li>';
	            });

	            return list;
	        }

	        /**
	         * 创建存储标签
	         * 存储格式 seasonId-pageId
	         * @return {string} [description]
	         */

	    }, {
	        key: 'getMarkId',
	        value: function getMarkId(seasonId, pageId) {
	            return seasonId + '-' + pageId;
	        }

	        /**
	         * 获取历史记录
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'getHistory',
	        value: function getHistory() {
	            var mark = $$get('bookMark');
	            if (mark) {
	                return mark.split(',');
	            }
	            return [];
	        }

	        /**
	         * 添加书签
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'addBookMark',
	        value: function addBookMark() {
	            var key;

	            this.updatePageInfo();
	            key = this.getMarkId(this.seasonId, this.pageId);

	            //避免重复缓存
	            if (BOOKCACHE.indexOf(key) > -1) {
	                return;
	            }
	            BOOKCACHE.push(key);
	            $$set('bookMark', BOOKCACHE);
	        }

	        /**
	         * 更新页信息
	         *  针对母板层上的书签
	         */

	    }, {
	        key: 'updatePageInfo',
	        value: function updatePageInfo() {
	            var pageData = Xut.Presentation.GetPageData();
	            this.pageId = pageData._id;
	            this.seasonId = pageData.seasonId;
	        }

	        /**
	         * 删除书签
	         * @param {object} [key] [事件目标对象]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'delBookMark',
	        value: function delBookMark(target) {
	            if (!target || !target.dataset) return;

	            var key = target.dataset.mark,
	                index = BOOKCACHE.indexOf(key);

	            BOOKCACHE.splice(index, 1);
	            $$set('bookMark', BOOKCACHE);

	            if (BOOKCACHE.length == 0) {
	                $$remove('bookMark');
	            }

	            //移除该行
	            $(target).parent().remove();
	        }

	        /**
	         * 显示书签
	         * @param {object} [target] [事件目标对象]
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'viewBookMark',
	        value: function viewBookMark(target) {
	            var $bookMarkList,
	                list = this.createMarkList();

	            if (this.bookMarkList) {
	                $bookMarkList = this.bookMarkList;
	            } else {
	                $bookMarkList = $(target).parent().parent().next();
	            }
	            //更新书签内容
	            $bookMarkList.find('.xut-bookmark-body').html(list);
	            this.bookMarkList = $bookMarkList;
	            $bookMarkList.fadeIn();
	        }

	        /**
	         * 点击放大效果
	         * @param  {[object]} target [事件目标对象]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: 'iconManager',
	        value: function iconManager(target) {
	            var $icon = this.bookMarkIcon = $(target),
	                restore = this.iconRestore;

	            $icon.css({
	                'transform': 'scale(1.2)',
	                'transition-duration': '500ms'
	            })[0].addEventListener(Xut.style.transitionEnd, restore.bind(this), false);
	        }

	        /**
	         * 复原按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'iconRestore',
	        value: function iconRestore() {
	            this.bookMarkIcon.css('transform', '');
	        }

	        /**
	         * 跳转到书签页
	         * @param  {[type]} target [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: 'goBookMark',
	        value: function goBookMark(target) {
	            if (!target || !target.dataset) return;

	            var key = target.dataset.mark.split('-');
	            var seasonId = Number(key[0]);
	            var pageId = Number(key[1]);

	            this.updatePageInfo();
	            //关闭书签列表
	            this.backBookMark();

	            //忽略当前页的跳转
	            if (this.pageId == pageId && this.seasonId == seasonId) {
	                return;
	            }

	            Xut.View.LoadScenario({
	                'scenarioId': seasonId,
	                'chapterId': pageId
	            });
	        }

	        /**
	         * 书签回退键
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'backBookMark',
	        value: function backBookMark() {
	            this.bookMarkList.fadeOut();
	        }

	        /**
	         * 邦定事件
	         * @param  {[type]} evt [事件]
	         * @return {[type]}     [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {
	            var target = e.target;
	            $$handle({
	                end: function end(e) {
	                    switch ($$target(e).className) {
	                        //加入书签
	                        case 'xut-bookmark-add':
	                            this.addBookMark();
	                            this.iconManager(target);
	                            break;
	                        //显示书签记录
	                        case 'xut-bookmark-view':
	                            this.viewBookMark(target);
	                            this.iconManager(target);
	                            break;
	                        //关闭书签
	                        case 'xut-bookmark-off':
	                        case 'xut-bookmark-off icomoon icon-chevron-down':
	                            this.closeBookMark(target);
	                            break;
	                        //返回书签主菜单
	                        case 'xut-bookmark-back':
	                            this.backBookMark();
	                            break;
	                        //删除书签记录
	                        case 'xut-bookmark-del':
	                            this.delBookMark(target);
	                            break;
	                        //跳转到书签页
	                        case 'xut-bookmark-id':
	                            this.goBookMark(target);
	                            break;
	                        default:
	                            //console.log(target.className)
	                            break;
	                    }
	                }
	            }, this, e);
	        }

	        /**
	         * 关闭书签菜单
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'closeBookMark',
	        value: function closeBookMark(target) {
	            this.bookMarkMenu.css({
	                transform: 'translate3d(0,0,0)',
	                'transition-duration': '1s'
	            });
	        }

	        /**
	         * 恢复书签菜单
	         */

	    }, {
	        key: 'restore',
	        value: function restore() {
	            this.bookMarkMenu.css({
	                transform: 'translate3d(0,-' + this.markHeight + 'px,0)',
	                'transition-duration': '1s'
	            });
	        }

	        /**
	         * 销毁书签
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var dom = this.parent[0];

	            $$off(dom, {
	                end: this
	            });

	            //菜单部分
	            if (this.bookMarkMenu) {
	                this.bookMarkMenu.remove();
	                this.bookMarkMenu = null;
	            }

	            //列表部分
	            if (this.bookMarkList) {
	                this.bookMarkList.remove();
	                this.bookMarkList = null;
	            }

	            //按钮效果
	            if (this.bookMarkIcon) {
	                this.bookMarkIcon[0].removeEventListener(Xut.style.transitionEnd, this.iconRestore, false);
	                this.bookMarkIcon = null;
	            }

	            this.parent = null;
	        }
	    }]);
	    return Mark;
	}();

	/**
	 * 阅读模式工具栏
	 * @param options object
	 * @demo {$sceneNode:页面容器,$controlNode:工具栏容器,...}
	 * @desc 继承自Toolbar.js
	 */

	var BookBar = function (_Bar) {
	    inherits(BookBar, _Bar);

	    function BookBar() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            pageMode = _ref.pageMode,
	            sceneNode = _ref.sceneNode,
	            controlNode = _ref.controlNode;

	        classCallCheck(this, BookBar);

	        //工具栏父容器
	        var _this = possibleConstructorReturn(this, (BookBar.__proto__ || Object.getPrototypeOf(BookBar)).call(this));

	        _this.$sceneNode = sceneNode;

	        //工具栏容器
	        _this.$controlNode = controlNode;

	        _this.pageMode = pageMode;

	        //是否有顶部工具栏
	        _this.hasTopBar = true;
	        _this.Lock = false;
	        _this.delay = 50;

	        //图书工具栏高度
	        _this.topBarHeight = _this.super_iconHeight * 1.25;

	        _this.initTool();
	        return _this;
	    }

	    /**
	     * 初始化
	     */


	    createClass(BookBar, [{
	        key: 'initTool',
	        value: function initTool() {

	            //工具栏的显示状态
	            var display = this.$controlNode.css('display');
	            this.barStatus = display == 'none' ? false : true;
	            this.setToolbarStyle();

	            this.createBackIcon();
	            this.createDirIcon();
	            this.createMarkIcon();

	            // this.createStarIcon();

	            //翻页按钮
	            if (this.pageMode == 2) {
	                this.super_createArrows();
	            }

	            //监听事件
	            $$on(this.$sceneNode[0], {
	                end: this
	            });
	        }

	        /**
	         * 工具条的样式
	         */

	    }, {
	        key: 'setToolbarStyle',
	        value: function setToolbarStyle() {
	            var height = this.topBarHeight,
	                TOP = this.barHeight; //系统工具栏占用的高度

	            //在顶部
	            this.$controlNode.css({
	                top: 0,
	                height: height + 'px',
	                paddingTop: TOP + 'px',
	                backgroundColor: 'rgba(0, 0, 0, 0.2)', //transparent
	                fontSize: '0.625em',
	                color: 'white'
	            });
	        }

	        /**
	         * 更新页码
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer() {}
	        //预留


	        /**
	         *  font版本：创建目录图标
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createDirIcon',
	        value: function createDirIcon() {
	            var parent = document.createElement('div');
	            var icon = document.createElement('div');
	            var iconText = document.createElement('div');

	            parent.style.width = '48px';
	            parent.style.height = "100%";
	            parent.style.float = "left";
	            parent.style.marginLeft = "3vw";
	            parent.style.cursor = "pointer";
	            parent.style.position = "relative";

	            icon.style.fontSize = "2.5vh";
	            icon.style.color = "#fff";
	            icon.className = 'icomoon icon-th-list2';
	            icon.style.position = "absolute";
	            icon.style.bottom = this.super_iconHeight * 0.5 + 'px';

	            iconText.innerHTML = '目录';
	            iconText.className = "xut-book-dirFont";
	            // iconText.style.height = "40%";
	            // iconText.style.width = "100%";
	            iconText.style.position = "absolute";
	            iconText.style.bottom = "0";

	            parent.appendChild(icon);
	            parent.appendChild(iconText);
	            this.$controlNode.append(parent);
	        }

	        /**
	         * font版本：创建书签图标
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createMarkIcon',
	        value: function createMarkIcon() {
	            var parent = document.createElement('div');
	            var icon = document.createElement('div');
	            var iconText = document.createElement('div');

	            parent.style.width = '48px';
	            parent.style.height = "100%";
	            parent.style.float = "left";
	            parent.style.marginLeft = "1vw";
	            parent.style.cursor = "pointer";
	            parent.style.position = "relative";

	            icon.style.fontSize = "2.5vh";
	            icon.style.color = "#fff";
	            icon.style.position = "absolute";
	            icon.style.bottom = this.super_iconHeight * 0.5 + 'px';
	            icon.className = 'icomoon icon-bookmark2';

	            iconText.innerHTML = '书签';
	            iconText.className = "xut-book-markFont";
	            //iconText.style.height = "40%";
	            iconText.style.position = "absolute";
	            iconText.style.bottom = "0";

	            parent.appendChild(icon);
	            parent.appendChild(iconText);
	            this.$controlNode.append(parent);
	        }

	        /**
	         * 创建评分图标
	         */

	    }, {
	        key: 'createStarIcon',
	        value: function createStarIcon(bar) {
	            var icon = document.createElement('div');
	            icon.innerHTML = '评分';
	            icon.style.width = this.super_iconHeight + 'px';
	            icon.style.lineHeight = 1.5 * this.topBarHeight + 'px';
	            icon.className = 'xut-book-bar-star';
	            this.$controlNode.append(icon);
	        }

	        /**
	         * font字体版本：后退按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'createBackIcon',
	        value: function createBackIcon() {
	            var icon = document.createElement('div');
	            icon.style.width = this.topBarHeight + 'px';
	            icon.style.lineHeight = this.topBarHeight + 'px';
	            icon.style.color = "#fff";

	            icon.className = 'icomoon icon-angle-left icon-book-bar';
	            icon.style.fontSize = "6vh";
	            this.$controlNode.append(icon);
	        }

	        /**
	         * 显示顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'showTopBar',
	        value: function showTopBar() {
	            var that = this;

	            if (this.barStatus) {
	                this.Lock = false;
	                return;
	            }

	            this.$controlNode.css({
	                'display': 'block',
	                'opacity': 0
	            });

	            setTimeout(function () {
	                that.$controlNode.animate({
	                    'opacity': 1
	                }, that.delay, 'linear', function () {
	                    that.super_showSystemBar();
	                    that.barStatus = true;
	                    that.Lock = false;
	                });
	            }, 50);
	        }

	        /**
	         * 隐藏顶部工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'hideTopBar',
	        value: function hideTopBar() {
	            var that = this;

	            if (!this.barStatus) {
	                this.Lock = false;
	                return;
	            }

	            this.$controlNode.animate({
	                'opacity': 0
	            }, that.delay, 'linear', function () {
	                that.$controlNode.hide();
	                that.super_hideSystemBar();
	                that.barStatus = false;
	                that.Lock = false;
	            });
	        }
	    }, {
	        key: 'hideNavbar',
	        value: function hideNavbar() {}

	        /**
	         * 创建目录菜单
	         */

	    }, {
	        key: 'createDirMenu',
	        value: function createDirMenu() {
	            var self = this;
	            var wrap = document.createElement('div');
	            var mask = document.createElement('div');
	            //添加遮层
	            mask.className = 'xut-book-menu-mask';
	            //获取内容
	            this.getDirContent();
	            wrap.className = 'xut-book-menu';
	            wrap.innerHTML = '<ul>' + this.contentText + '</ul>';
	            this.$sceneNode.append(wrap);
	            //是否滚动
	            this.isScrolled = false;

	            //添加滚动条
	            //url : http://iscrolljs.com/
	            this.iscroll = new iScroll(wrap, {
	                scrollbars: true,
	                fadeScrollbars: true,
	                scrollX: false
	            });

	            this.menu = wrap;

	            this.setColor();

	            this.iscroll.on('scrollStart', function (e) {
	                self.isScrolled = true;
	            });

	            this.iscroll.on('scrollEnd', function (e) {
	                self.isScrolled = false;
	            });

	            wrap.appendChild(mask);
	        }

	        /**
	         *  显示目录菜单
	         */

	    }, {
	        key: 'showDirMenu',
	        value: function showDirMenu() {
	            //获取当前页面
	            var page = Xut.Presentation.GetPageElement();

	            if (this.menu) {
	                this.menu.style.display = 'block';
	            } else {
	                this.createDirMenu();
	            }

	            //添加模糊效果
	            page.addClass('filter');
	            this.page = page;

	            //隐藏顶部工具栏
	            this.$controlNode.hide();
	            var iscroll = this.iscroll;
	            //自动定位到上一位置
	            if (iscroll.y > iscroll.wrapperHeight) {
	                iscroll.scrollToElement(this.selectedChild);
	            }
	        }

	        /**
	         *  隐藏目录菜单
	         */

	    }, {
	        key: 'hideDirMenu',
	        value: function hideDirMenu() {
	            this.menu.style.display = 'none';
	            //恢复顶部工具栏
	            this.$controlNode.show();
	            //移除模糊效果
	            this.page.removeClass('filter');
	        }

	        /**
	         *  创建目录内容
	         */

	    }, {
	        key: 'getDirContent',
	        value: function getDirContent() {

	            var Api = Xut.Presentation;
	            var data = Api.GetAppSectionData();
	            var sns = data[0];
	            var seaonId = sns._id;
	            var cids = Xut.data.Chapter;

	            ////////////////////////////
	            //针对book模式，合并了Season的参数 //
	            //1 SeasonTitle
	            //2 ChapterList列表的范围区间
	            ////////////////////////////
	            data = parseJSON(sns.parameter);

	            if (!data) {
	                console.log('book模式parameter数据出错');
	                return;
	            }

	            //二级目录
	            function secondaryDirectory(startCid, endCid) {
	                var cid,
	                    str = '';
	                for (startCid; startCid <= endCid; startCid++) {
	                    cid = cids.item(startCid - 1);
	                    if (cid && cid.chapterTitle) {
	                        str += '<section><a class="xut-book-menu-item" data-mark=' + seaonId + '-' + startCid + ' href="javascript:0">' + cid.chapterTitle + '</a></section>';
	                    }
	                }
	                return str;
	            }

	            var i = 0;
	            var len = data.length;
	            var li = '<li class="title"><center class="select">目录</center></li>';
	            var seasonInfo, mark, seasonTitle, seaonId, startCid, endCid;

	            for (i; i < len; i++) {
	                seasonInfo = data[i];
	                startCid = seasonInfo.ChapterList[0];
	                endCid = seasonInfo.ChapterList[1];
	                mark = seaonId + '-' + startCid;
	                if (seasonInfo.SeasonTitle.length <= 0) continue;
	                seasonTitle = seasonInfo.SeasonTitle || '第' + (i + 1) + '章';
	                //第一级目录
	                li += '<li>' + '<a class="xut-book-menu-item" data-mark="' + mark + '" href="javascript:0">' + seasonTitle + '</a>' +
	                //第二级目录
	                secondaryDirectory(startCid, endCid) + '</li>';
	            }

	            this.contentText = li;
	        }

	        /**
	         * 突出显示点击颜色
	         */

	    }, {
	        key: 'setColor',
	        value: function setColor(element) {
	            if (this.selectedChild) {
	                this.selectedChild.className = 'xut-book-menu-item';
	            }
	            element = element || this.menu.querySelectorAll('li')[1].children[0];
	            element.className = 'select';
	            this.selectedChild = element;
	        }

	        /**
	         * 跳转到指定书页
	         */

	    }, {
	        key: 'turnToPage',
	        value: function turnToPage(target) {
	            //忽略滚动点击
	            if (this.isScrolled) return;
	            this.setColor(target);
	            this.hideDirMenu();
	            var data = target.dataset.mark || '';
	            if (data) {
	                data = data.split('-');
	                Xut.View.LoadScenario({
	                    'scenarioId': data[0],
	                    'chapterId': data[1]
	                });
	            }
	        }

	        /**
	         * 显示书签
	         */

	    }, {
	        key: 'showBookMark',
	        value: function showBookMark() {
	            if (this.bookMark) {
	                this.bookMark.restore();
	            } else {
	                var pageData = Xut.Presentation.GetPageData();
	                this.bookMark = new Mark({
	                    parent: this.$sceneNode,
	                    seasonId: pageData.seasonId,
	                    pageId: pageData._id
	                });
	            }
	        }

	        /**
	         * 返回首页
	         */

	    }, {
	        key: 'goBack',
	        value: function goBack() {
	            var self = this;
	            Xut.Application.Stop({
	                processed: function processed() {
	                    Xut.View.GotoSlide(1); //调整到首页
	                    self.setColor();
	                }
	            });
	        }

	        /**
	         * 相应事件
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {
	            var target = e.target || e.srcElement;
	            $$handle({
	                end: function end(e) {
	                    switch ($$target(e).className) {
	                        case 'icomoon icon-angle-left icon-book-bar':
	                            this.goBack();
	                            //返回
	                            break;
	                        case 'icomoon icon-th-list2':
	                        case 'xut-book-dirFont':
	                            //目录
	                            this.showDirMenu();
	                            break;
	                        case 'icomoon icon-bookmark2':
	                        case 'xut-book-markFont':
	                            //书签
	                            this.showBookMark();
	                            break;
	                        case 'xut-book-bar-star':
	                            //评分
	                            break;
	                        case 'xut-book-menu-item':
	                            //跳转
	                            this.turnToPage(target);
	                            break;
	                        case 'xut-book-menu-mask':
	                        case 'select':
	                            this.hideDirMenu();
	                            break;
	                        default:
	                            // console.log(name+':undefined')
	                            break;
	                    }
	                }
	            }, this, e);
	        }

	        /**
	         * 销毁
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.iscroll && this.iscroll.destroy();
	            this.bookMark && this.bookMark.destroy();
	            $$off(this.$sceneNode[0], {
	                end: this
	            });
	            this.iscroll = null;
	            this.menu = null;
	            this.page = null;
	            //销毁超类
	            this.super_destory();
	        }
	    }]);
	    return BookBar;
	}(Bar);

	var cacheCounts = void 0;

	/**
	 * 设置流式布局排版信息
	 */
	function set$1(flowCounts) {
	    cacheCounts = flowCounts;
	}

	/**
	 * 获取当前当前到前置的总和
	 * @return {[type]} [description]
	 */
	function getCurrentBeforeCount(seasonId, chapterId) {
	    if (!cacheCounts) return;
	    if (!seasonId && !chapterId) return;
	    var seasonIds = cacheCounts[seasonId];
	    var count = 0;
	    for (var key in seasonIds) {
	        if (key <= chapterId) {
	            count += seasonIds[key];
	            --count;
	        }
	    }
	    return count > 0 ? count : 0;
	}

	/**
	 * 获取当前chapterId之前的总页数
	 * @return {[type]} [description]
	 */
	function getBeforeCount(seasonId, chapterId) {
	    if (!cacheCounts) return;
	    if (!seasonId && !chapterId) return;
	    var seasonIds = cacheCounts[seasonId];
	    var count = 0;
	    for (var key in seasonIds) {
	        if (key < chapterId) {
	            count += seasonIds[key];
	            --count;
	        }
	    }
	    return count > 0 ? count : 0;
	}

	/**
	 * 获取chpater总数
	 * @param  {[type]} seasonId [description]
	 * @return {[type]}          [description]
	 */
	function getFlowChpaterCount(seasonId) {
	    if (!cacheCounts) return;
	    return Object.keys(cacheCounts[seasonId]).length;
	}

	/**
	 * reutrn seasonIds
	 * return chpaterIds
	 * @param  {[type]} seasonId  [description]
	 * @param  {[type]} chpaterId [description]
	 * @return {[type]}           [description]
	 */
	function getFlowCount(seasonId, chapterId) {
	    if (!cacheCounts) return;
	    if (seasonId) {
	        if (chapterId) {
	            return cacheCounts[seasonId] && cacheCounts[seasonId][chapterId];
	        } else {
	            var seasonIds = cacheCounts[seasonId];
	            var count = 0;
	            for (var key in seasonIds) {
	                count += seasonIds[key];
	            }
	            return count;
	        }
	    } else {
	        console.log('getCounts失败');
	    }
	}

	/**
	 * 判断是否为流式布局页面
	 * @param  {[type]} seasonId  [description]
	 * @param  {[type]} chpaterId [description]
	 * @return {[type]}           [description]
	 */
	function isFlowPage(seasonId, chapterId) {
	    return getFlowCount(seasonId, chapterId) ? true : false;
	}

	/**
	 * 页码显示
	 */

	var NumberBar = function () {
	    function NumberBar(_ref) {
	        var _this = this;

	        var $rootNode = _ref.$rootNode,
	            pageTotal = _ref.pageTotal,
	            currentPage = _ref.currentPage;
	        classCallCheck(this, NumberBar);

	        this.$container = this._createDom(pageTotal);
	        this.$currtNode = this.$container.find('div:first');
	        this.$allNode = this.$container.find('div:last');

	        this.toolBarStatus = true;

	        Xut.nextTick(function () {
	            $rootNode.append(_this.$container);
	        });
	    }

	    createClass(NumberBar, [{
	        key: '_createDom',
	        value: function _createDom(pageTotal) {
	            //存在模式3的情况，所以页码要处理溢出的情况。left值
	            var right = 0;
	            if (config.viewSize.overflowWidth) {
	                right = Math.abs(config.viewSize.left) + 'px';
	            }
	            return $('<div class="xut-page-number" style="right:' + right + ';">\n                <div>1</div>\n                <strong>/</strong>\n                <div>' + pageTotal + '</div>\n             </div>');
	        }
	    }, {
	        key: '_showToolBar',
	        value: function _showToolBar() {
	            this.$container.show();
	        }
	    }, {
	        key: '_hideToolBar',
	        value: function _hideToolBar() {
	            this.$container.hide();
	        }
	    }, {
	        key: 'toggle',
	        value: function toggle(state, pointer) {
	            if (pointer !== 'pageNumber') return;
	            switch (state) {
	                case 'show':
	                    this._showToolBar();
	                    break;
	                case 'hide':
	                    this._hideToolBar();
	                    break;
	                default:
	                    //默认：工具栏显示隐藏互斥处理
	                    this.toolBarStatus ? this._hideToolBar() : this._showToolBar();
	                    break;
	            }
	        }

	        /**
	         * 更新页码
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'updatePointer',
	        value: function updatePointer(_ref2) {
	            var _this2 = this;

	            var action = _ref2.action,
	                direction = _ref2.direction,
	                parentIndex = _ref2.parentIndex,
	                _ref2$hasSon = _ref2.hasSon,
	                hasSon = _ref2$hasSon === undefined ? false : _ref2$hasSon,
	                _ref2$sonIndex = _ref2.sonIndex,
	                sonIndex = _ref2$sonIndex === undefined ? 0 : _ref2$sonIndex;


	            var chapterData = Xut.Presentation.GetPageData('page', parentIndex);

	            //从正索引开始
	            ++parentIndex;

	            //默认，需要拿到前置的总和(出去当前)
	            var beforeCount = getBeforeCount(chapterData.seasonId, chapterData._id);
	            var updateIndex = parentIndex + beforeCount + sonIndex;

	            //前翻页，需要叠加flow的总和
	            if (direction === 'prev') {
	                //前翻页：内部翻页
	                if (hasSon) {
	                    updateIndex = parentIndex + beforeCount + sonIndex - 2;
	                }
	                //前翻页：外部往内部翻页，正好前一页是内部页，所以需要获取内部页总和
	                else {
	                        //前翻页，需要拿到当期那到前置的总和
	                        updateIndex = parentIndex + getCurrentBeforeCount(chapterData.seasonId, chapterData._id);
	                    }
	            }

	            Xut.nextTick(function () {
	                _this2.$currtNode.text(updateIndex);
	                if (action === 'init') {
	                    _this2.$container.show();
	                }
	            });
	        }
	    }]);
	    return NumberBar;
	}();

	/**
	 * 场景控制器
	 * 场景对象之间的顺序处理
	 * @return {[type]} [description]
	 */

	//场景层级控制
	var zIndex = 999999;

	//场景合集
	//主场景
	//副场景
	var sceneCollection = {
	    //场景顺序
	    scenarioStack: [],
	    //场景链表
	    scenarioChain: []
	};

	var sceneController = {

	    /**
	     * 场景层级控制
	     * @return {[type]} [description]
	     */
	    createIndex: function createIndex() {
	        return --zIndex;
	    },


	    /**
	     * 设置一个新场景
	     * @param {[type]} scenarioId [description]
	     * @param {[type]} relevant   [description]
	     * @param {[type]} sceneObj   [description]
	     */
	    add: function add(scenarioId, relevant, sceneObj) {
	        sceneCollection.scenarioStack.push(scenarioId);
	        sceneCollection['scenarioId->' + scenarioId] = sceneObj;
	        //场景链表,拥挤记录场景的加载上一页
	        sceneCollection.scenarioChain.push({
	            'scenarioId': scenarioId,
	            'chapterId': relevant
	        });
	        return sceneObj;
	    },


	    /**
	     * 取出上一个场景链
	     * @return {[type]} [description]
	     */
	    takeOutPrevChainId: function takeOutPrevChainId() {
	        var pre = sceneCollection.scenarioChain.pop();
	        if (sceneCollection.scenarioChain.length > 1) {
	            return sceneCollection.scenarioChain.pop();
	        } else {
	            return sceneCollection.scenarioChain[0];
	        }
	    },


	    /**
	     * 检测重复
	     * @param  {[type]} seasonId [description]
	     * @return {[type]}          [description]
	     */
	    checkToRepeat: function checkToRepeat(seasonId) {
	        var last,
	            len = sceneCollection.scenarioChain.length;
	        if (len > 1) {
	            last = sceneCollection.scenarioChain[len - 2];
	        } else {
	            last = sceneCollection.scenarioChain[len - 1];
	        }

	        //往回跳一级
	        if (last['scenarioId'] == seasonId) {
	            this.takeOutPrevChainId();
	        }

	        //直接会跳到主场景
	        if (sceneCollection.scenarioStack[0] == seasonId) {
	            var scenarioChain = sceneCollection.scenarioChain.shift();
	            sceneCollection.scenarioChain.length = 0;
	            sceneCollection.scenarioChain.push(scenarioChain);
	        }
	    },


	    /**
	     * 返回活动对象
	     * @return {[type]} [description]
	     */
	    containerObj: function containerObj(scenarioId) {
	        if (scenarioId === 'current') {
	            var scenarioStack = sceneCollection.scenarioStack;
	            scenarioId = scenarioStack[scenarioStack.length - 1];
	        }
	        return sceneCollection['scenarioId->' + scenarioId];
	    },


	    /**
	     * 找到索引位置的Id
	     * @param  {[type]} scenarioId [description]
	     * @return {[type]}            [description]
	     */
	    findIndexOfId: function findIndexOfId(scenarioId) {
	        return sceneCollection.scenarioStack.lastIndexOf(scenarioId);
	    },


	    /**
	     * 删除指定场景引用
	     * @param  {[type]} scenarioId [description]
	     * @return {[type]}            [description]
	     */
	    remove: function remove(scenarioId) {
	        var indexOf = this.findIndexOfId(scenarioId);

	        //删除索引
	        sceneCollection.scenarioStack.splice(indexOf, 1);

	        //删除场景对象区域
	        delete sceneCollection['scenarioId->' + scenarioId];
	    },


	    /**
	     * 销毁所有场景
	     * @return {[type]} [description]
	     */
	    destroyAllScene: function destroyAllScene() {
	        var cache = _.clone(sceneCollection.scenarioStack);
	        _.each(cache, function (scenarioId) {
	            sceneCollection['scenarioId->' + scenarioId].destroy();
	        });
	        sceneCollection.scenarioChain = [];
	    },


	    /**
	     * 重写场景的顺序编号
	     * 用于记录最后一次跳转的问题
	     * @return {[type]} [description]
	     */
	    rewrite: function rewrite(scenarioId, chapterId) {
	        _.each(sceneCollection.scenarioChain, function (scenarioChain) {
	            if (scenarioChain.scenarioId == scenarioId) {
	                scenarioChain.chapterId = chapterId;
	            }
	        });
	    },


	    /**
	     * 暴露接口
	     * @return {[type]} [description]
	     */
	    expose: function expose() {
	        return sceneCollection;
	    },


	    /**
	     * 解析序列
	     * @param  {[type]} scenarioId    [description]
	     * @param  {[type]} currPageIndex [description]
	     * @return {[type]}               [description]
	     */
	    sequence: function sequence(scenarioId, currPageIndex) {
	        var chains = sceneCollection.scenarioChain;
	        //有多个场景关系,需要记录
	        if (chains.length > 1) {
	            var history = [];
	            //只刷新当前场景的页面
	            _.each(chains, function (chain) {
	                if (chain.scenarioId == scenarioId) {
	                    history.push(chain.scenarioId + '-' + chain.chapterId + '-' + currPageIndex);
	                } else {
	                    history.push(chain.scenarioId + '-' + chain.chapterId);
	                }
	            });
	            return history;
	        }
	    },


	    /**
	     * 反解析
	     * @param  {[type]} chains [description]
	     * @return {[type]}        [description]
	     */
	    seqReverse: function seqReverse(chains) {
	        var chains = chains.split(",");
	        var chainsNum = chains.length;

	        if (chainsNum === 1) {
	            return false;
	        }

	        //如果只有2层
	        if (chainsNum === 2) {
	            return chains[1];
	        }

	        //拼接作用域链
	        //排除首页(已存在)
	        //尾页(新创建)
	        _.each(chains, function (chain, index) {
	            if (index >= 1 && index < chainsNum - 1) {
	                //从1开始吸入,排除最后一个
	                var chain = chain.split('-');
	                sceneCollection.scenarioChain.push({
	                    'scenarioId': chain[0],
	                    'chapterId': chain[1],
	                    'pageIndex': chain[2]
	                });
	            }
	        });
	        return chains[chainsNum - 1];
	    }
	};

	Xut.sceneController = sceneController;

	/**
	 *
	 * 基本事件管理
	 * 1 异步
	 * 2 同步
	 *
	 */

	var ArrayProto = Array.prototype;
	var nativeIndexOf = ArrayProto.indexOf;
	var slice = ArrayProto.slice;
	var _indexOf = function _indexOf(array, needle) {
	    var i, l;
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) {
	        return array.indexOf(needle);
	    }
	    for (i = 0, l = array.length; i < l; i++) {
	        if (array[i] === needle) {
	            return i;
	        }
	    }
	    return -1;
	};

	var Observer = function () {
	    function Observer() {
	        classCallCheck(this, Observer);

	        this.$watch = this.bind;
	        this.$off = this.unbind;
	        this.$emit = this.trigger;
	        this.$once = this.one;

	        //触发列表名称
	        //防止同步触发
	        this._handleName = {};
	    }

	    createClass(Observer, [{
	        key: "bind",
	        value: function bind(event, fn) {
	            var i, part;
	            var events = this.events = this.events || {};
	            var parts = event.split(/\s+/);
	            var num = parts.length;

	            for (i = 0; i < num; i++) {
	                events[part = parts[i]] = events[part] || [];
	                if (_indexOf(events[part], fn) === -1) {
	                    events[part].push(fn);
	                }
	            }

	            //假如存在同步句柄
	            //执行
	            var data;
	            if (data = this._handleName[event]) {
	                this.$emit(event, data[0]);
	            }

	            return this;
	        }
	    }, {
	        key: "one",
	        value: function one(event, fn) {
	            // [notice] The value of fn and fn1 is not equivalent in the case of the following MSIE.
	            // var fn = function fn1 () { alert(fn === fn1) } ie.<9 false
	            var fnc = function fnc() {
	                this.unbind(event, fnc);
	                fn.apply(this, slice.call(arguments));
	            };
	            this.bind(event, fnc);
	            return this;
	        }
	    }, {
	        key: "unbind",
	        value: function unbind(event, fn) {
	            var eventName, i, index, num, parts;
	            var events = this.events;

	            if (!events) return this;

	            //指定
	            if (arguments.length) {
	                parts = event.split(/\s+/);
	                for (i = 0, num = parts.length; i < num; i++) {
	                    if ((eventName = parts[i]) in events !== false) {
	                        index = fn ? _indexOf(events[eventName], fn) : -1;
	                        if (index !== -1) {
	                            events[eventName].splice(index, 1);
	                        }
	                    }
	                }
	            } else {
	                this.events = null;
	            }

	            return this;
	        }
	    }, {
	        key: "trigger",
	        value: function trigger(event) {
	            var args, i;
	            var events = this.events,
	                handlers;

	            //参数
	            args = slice.call(arguments, 1);

	            if (!events || event in events === false) {
	                // console.log(event)
	                //同步的情况
	                //如果除非了事件，可能事件句柄还没有加载
	                this._handleName[event] = args;
	                return this;
	            }

	            handlers = events[event];
	            for (i = 0; i < handlers.length; i++) {
	                handlers[i].apply(this, args);
	            }
	            return this;
	        }
	    }]);
	    return Observer;
	}();

	/**
	 * 抽象管理接口
	 * @return {[type]} [description]
	 */

	var Abstract = function () {
	    function Abstract() {
	        classCallCheck(this, Abstract);
	    }

	    createClass(Abstract, [{
	        key: 'abstractCreateCollection',


	        /**
	         * 创建页面合集
	         * @return {[type]} [description]
	         */
	        value: function abstractCreateCollection() {
	            this.Collections = {};
	        }

	        /**
	         * 增加合集管理
	         */

	    }, {
	        key: 'abstractAddCollection',
	        value: function abstractAddCollection(pageIndex, pageObj) {
	            this.Collections[pageIndex] = pageObj;
	        }

	        /**
	         * 得到页面合集
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractGetCollection',
	        value: function abstractGetCollection() {
	            return this.Collections;
	        }

	        /**
	         * 删除合集管理
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractRemoveCollection',
	        value: function abstractRemoveCollection(pageIndex) {
	            delete this.Collections[pageIndex];
	        }

	        /**
	         * 销毁合集
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractDestroyCollection',
	        value: function abstractDestroyCollection() {
	            var k,
	                Collections = this.Collections;
	            for (k in Collections) {
	                Collections[k].baseDestroy();
	            }
	            this.Collections = null;
	        }

	        /**
	         * 找到页面对象
	         * 1.页面直接pageIndex索引
	         * 2.母版通过母版Id索引
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractGetPageObj',
	        value: function abstractGetPageObj(pageIndex, pageType) {
	            pageType = pageType || this.pageType;
	            //模板传递的可能不是页码
	            if (pageType === 'master') {
	                if (!/-/.test(pageIndex)) {
	                    //如果不是母版ID，只是页码
	                    pageIndex = this._conversionMasterId(pageIndex); //转化成母版id
	                }
	            }
	            return this.Collections && this.Collections[pageIndex];
	        }

	        /**
	         * 合并处理
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractAssistPocess',
	        value: function abstractAssistPocess(pageIndex, callback) {
	            var pageObj;
	            if (pageObj = this.abstractGetPageObj(pageIndex, this.pageType)) {
	                if (callback) {
	                    callback(pageObj);
	                } else {
	                    return pageObj;
	                }
	            }
	        }

	        /**
	         * 获取页面容器ID
	         * chpaterID
	         * masterID
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'abstractGetPageId',
	        value: function abstractGetPageId(pageIndex, pageType) {
	            var key = pageType === 'page' ? '_id' : 'pptMaster';
	            return this.abstractGetPageData(pageIndex, key, pageType);
	        }

	        /**
	         * 获取页面数据
	         */

	    }, {
	        key: 'abstractGetPageData',
	        value: function abstractGetPageData(pageIndex, key, pageType) {
	            var pageObj;
	            //如果传递key是 pageType
	            if (!pageType && key == 'page' || key == 'master') {
	                pageType = key;
	                key = null;
	            }
	            if (pageObj = this.abstractGetPageObj(pageIndex, pageType)) {
	                return key ? pageObj.chapterData[key] : pageObj.chapterData;
	            }
	        }

	        /**
	         * 得到页面的nodes数据
	         * @param  {[type]} pageIndex [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: 'abstractGetPageNode',
	        value: function abstractGetPageNode(pageIndex, pageType) {
	            return this.abstractGetPageData(pageIndex, 'nodes', pageType);
	        }

	        /**
	         * 执行辅助对象事件
	         * @param  {[type]} activityId  [description]
	         * @param  {[type]} currIndex   [description]
	         * @param  {[type]} outCallBack [description]
	         * @param  {[type]} actionName  [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: 'abstractAssistAppoint',
	        value: function abstractAssistAppoint(activityId, currIndex, outCallBack, actionName) {
	            var pageObj;
	            if (pageObj = this.abstractGetPageObj(currIndex)) {
	                return pageObj.baseAssistRun(activityId, outCallBack, actionName);
	            }
	        }
	    }]);
	    return Abstract;
	}();

	/**
	 * 拖拽类
	 */
	var _class = function () {
	    function _class(dragElement, dropElement, autoReturn, dragCallback, dropCallback, container, throwProps) {
	        classCallCheck(this, _class);


	        this.dragElement = dragElement;
	        this.defaultPoint = null;
	        this.dropElement = dropElement;
	        this.autoReturn = autoReturn >= 1 ? true : false; //1:自动返回(true) 0:留在原地(false)
	        this.dragCallback = typeof dragCallback == "function" ? dragCallback : null;
	        this.dropCallback = typeof dropCallback == "function" ? dropCallback : null;
	        this.throwProps = throwProps == false || this.autoReturn ? false : true;
	        this.container = container;
	        this.dragElement.attr("data-defaultindex", this.dragElement.css("z-index"));
	        //this.dragObject = null; //创建的拖拽对象实例
	        var isInit = this.dragElement.attr("data-DragDrop");
	        if (isInit == null) {
	            this.init();
	            this.dragElement.attr("data-DragDrop", true);
	        } else {
	            console.log("This element has binding DragDropClass.");
	        }
	    }

	    /**
	     * 初始化拖拽
	     * @return {[type]} [description]
	     */


	    createClass(_class, [{
	        key: "init",
	        value: function init() {
	            if (this.dragObject != null) return;

	            var self = this;

	            //now make both boxes draggable.
	            var dragObject = this.dragObject = Draggable.create(this.dragElement, {
	                bounds: this.container,
	                dragResistance: 0,
	                edgeResistance: 0.8,
	                type: "left,top", //rotation、scroll(x+y模式与PPT动画冲突)
	                force3D: false, //是否启用硬件加速(left+top模式无需启用，启用后存在闪现问题)
	                throwProps: this.throwProps,
	                snap: {
	                    left: function left(endValue) {
	                        return endValue;
	                    },
	                    top: function top(endValue) {
	                        return endValue;
	                    }
	                },
	                onDragStart: function onDragStart(e) {
	                    //获取拖拽对象原始参数
	                    var defaultOffset = self.dragElement.offset();
	                    self.defaultPoint = {
	                        x: defaultOffset.left,
	                        y: defaultOffset.top,
	                        left: Number(self.dragElement.css("left").replace("px", "")),
	                        top: Number(self.dragElement.css("top").replace("px", ""))
	                    };
	                    if (self.dragCallback) self.dragCallback();
	                },
	                onDragEnd: function onDragEnd(e) {
	                    var dropElement = self.dropElement,
	                        isEnter = false; //是否进入目标

	                    if (dropElement) {
	                        //获取拖拽对象当前参数
	                        var fromOffset = self.dragElement.offset();
	                        var fromPoint = {
	                            x: fromOffset.left,
	                            y: fromOffset.top,
	                            w: self.dragElement.width(),
	                            h: self.dragElement.height()
	                        };
	                        //获取目标对象参数
	                        var toOffset = dropElement.offset();
	                        var toPoint = {
	                            x: toOffset.left,
	                            y: toOffset.top,
	                            w: dropElement.width(),
	                            h: dropElement.height()
	                        };
	                        //目标对象中心点
	                        var targetCenter = {
	                            pointerX: toPoint.x + toPoint.w / 2,
	                            pointerY: toPoint.y + toPoint.h / 2
	                        };
	                        //拖拽点位于目标框中或目标中心点位于拖拽框中视为拖拽成功
	                        if (dragObject.pointerX > toPoint.x && dragObject.pointerX < toPoint.x + toPoint.w && dragObject.pointerY > toPoint.y && dragObject.pointerY < toPoint.y + toPoint.h) {
	                            isEnter = true;
	                            dragObject.disable();
	                        } else if (targetCenter.pointerX > fromPoint.x && targetCenter.pointerX < fromPoint.x + fromPoint.w && targetCenter.pointerY > fromPoint.y && targetCenter.pointerY < fromPoint.y + fromPoint.h) {
	                            isEnter = true;
	                            dragObject.disable();
	                        }
	                        self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));
	                        //拖拽成功
	                        if (isEnter == true) {
	                            //结束后恢复层级关系
	                            // self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));

	                            //拖拽对象与目标对象中心点差
	                            var moveX = targetCenter.pointerX - (self.defaultPoint.x + fromPoint.w / 2);
	                            var moveY = targetCenter.pointerY - (self.defaultPoint.y + fromPoint.h / 2);
	                            //拖拽对象最终停放位置
	                            var newLeft = self.defaultPoint.left + moveX;
	                            var newTop = self.defaultPoint.top + moveY;
	                            //自动拖拽到位
	                            TweenLite.to(self.dragElement, 0.30, {
	                                css: {
	                                    left: newLeft,
	                                    top: newTop
	                                },
	                                ease: Expo.easeOut
	                            });
	                        } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
	                            css: {
	                                left: self.defaultPoint.left,
	                                top: self.defaultPoint.top
	                            }
	                        });
	                    } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
	                        css: {
	                            left: self.defaultPoint.left,
	                            top: self.defaultPoint.top
	                        }
	                    });
	                    //调用结束事件
	                    if (self.dropCallback) self.dropCallback(isEnter);
	                }
	            })[0];
	        }

	        /**
	         * 复位动画与状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: "reset",
	        value: function reset() {
	            var self = this;
	            var dragObject;
	            if (dragObject = this.dragObject) {
	                dragObject.enable();
	                if (self.defaultPoint) {
	                    self.dragElement.css("left", self.defaultPoint.left);
	                    self.dragElement.css("top", self.defaultPoint.top);
	                }
	                /*TweenLite.to(self.dragElement, 0, {
	                    css: {
	                        x: 0,
	                        y: 0
	                    }
	                });*/
	            }
	        }
	    }, {
	        key: "disable",
	        value: function disable() {
	            var dragObject;
	            if (dragObject = this.dragObject) {
	                dragObject.disable();
	            }
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            this.dragObject && this.dragObject.kill();
	            this.dropElement = null;
	            this.dragElement = null;
	            this.dragObject = null;
	        }
	    }]);
	    return _class;
	}();

	/**
	 * ie10下面mouse事件怪异
	 * @return {Boolean} [description]
	 */
	var isIE10 = document.documentMode === 10;

	/**
	 * 针对canvas模式
	 * 特殊的hack
	 * 当前点击的元素是滑动元素
	 * 处理元素的全局事件
	 */
	function setCanvasStart(supportSwipe) {
	    Xut.Contents.Canvas.Reset();
	    Xut.Contents.Canvas.SupportSwipe = supportSwipe;
	    Xut.Contents.Canvas.isTap = true;
	}

	function setCanvasMove() {
	    Xut.Contents.Canvas.isSwipe = true;
	}

	/**
	 * 兼容事件对象
	 * @return {[type]}   [description]
	 */
	function compatibilityEvent(e) {
	    var point;
	    if (e.touches && e.touches[0]) {
	        point = e.touches[0];
	    } else {
	        point = e;
	    }
	    return point;
	}

	/**
	 * 如果是简单的点击事件
	 */
	function simpleEvent(eventContext, eventHandle, supportSwipe) {

	    eventContext.isTap = false;

	    //这里单独绑定事件有个问题,单击move被触发
	    //如果停止e.stopPropagation，那么默认行为就不会被触发
	    //你绑定单击的情况下可以翻页
	    //这里通过坐标的位置来判断
	    var start = function start(e) {
	        var point = compatibilityEvent(e);
	        //记录开始坐标
	        eventContext.pageX = point.pageX;
	        //是否是tap事件
	        eventContext.isTap = true;
	        setCanvasStart(supportSwipe);
	    };

	    var move = function move(e) {
	        if (!eventContext.isTap) {
	            return;
	        }
	        var point = compatibilityEvent(e),
	            deltaX = point.pageX - eventContext.pageX;
	        //如果有move事件，则取消tap事件
	        if (Math.abs(deltaX)) {
	            eventContext.isTap = false;
	            setCanvasMove(supportSwipe);
	        }
	    };

	    var end = function end() {
	        //触发tap事件
	        eventContext.isTap && eventHandle();
	    };

	    eventContext = eventContext[0];

	    //IE10是不支持touch事件，直接绑定click事件
	    if (isIE10) {
	        eventContext.isTap = true;
	        eventContext.addEventListener('click', end, false);
	    } else {

	        $$on(eventContext, {
	            start: start,
	            move: move,
	            end: end
	        });
	    }

	    return {
	        off: function off() {
	            if (eventContext) {
	                if (isIE10) {
	                    eventContext.removeEventListener('click', end, false);
	                } else {
	                    $$off(eventContext, {
	                        start: start,
	                        move: move,
	                        end: end
	                    });
	                }
	                eventContext = null;
	            }
	        }
	    };
	}

	/**
	 * 优化hammer创建,生成必要配置文件
	 * @return {[type]} [description]
	 */
	function createRecognizers(eventName) {
	    var recognizers = [];
	    switch (eventName) {
	        //如果是swipe处理
	        case 'swipeleft':
	        case 'swiperight':
	        case 'swipeup':
	        case 'swipedown':
	            var direction = Hammer.DIRECTION_HORIZONTAL;
	            if (eventName === 'swipeup' || eventName === "swipedown") {
	                direction = Hammer.DIRECTION_VERTICAL;
	            }
	            recognizers.push([Hammer.Swipe, { 'direction': direction, 'velocity': 0.01 }]);
	            break;
	        case 'doubletap':
	            //双击
	            recognizers.push([Hammer.Tap]);
	            recognizers.push([Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]);
	            break;
	        case 'press':
	            //长按
	            recognizers.push([Hammer.Press]);
	            return;
	    }
	    return recognizers;
	}

	/**
	 * 创建hammer引用
	 * @return {[type]}         [description]
	 */
	function createHammer(eventContext, eventName, supportSwipe) {
	    var eventReference;
	    var context = eventContext[0];
	    var recognizer = createRecognizers(eventName);
	    if (recognizer && recognizer.length) {
	        eventReference = Hammer(context, {
	            'recognizers': recognizer
	        });
	    } else {
	        eventReference = Hammer(context);
	    }
	    return eventReference;
	}

	/**
	 * 复杂的事件
	 * @return {[type]} [description]
	 */
	function complexEvent(eventContext, eventName, eventHandler, supportSwipe) {
	    var eventReference = createHammer(eventContext, eventName, supportSwipe);
	    eventReference.on(eventName, function () {
	        eventHandler();
	    });
	    return eventReference;
	}

	/**
	 * 事件类型
	 * @type {Array}
	 * 0 null
	 * 1 auto
	 * 2 tap
	 * 3 drag
	 * 4 dragTag
	 * .........
	 */
	var eventName = ['null', 'auto', 'tap', 'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown', 'doubletap', 'press', 'pinchout', 'pinchin', 'rotate', 'assist'];

	/**
	 * 重写默认事件
	 *
	 * Content对象默认具有左右翻页的特性
	 * 根据过滤来选择是否覆盖重写这个特性
	 * 比如 用户如果遇到 swipeLeft，swipeRight 这种本身与翻页行为冲突的
	 * 将要覆盖这个行为
	 * 过滤事件
	 * 如果用户指定了如下操作行为,将覆盖默认的翻页行为
	 **/
	var filterEvent = ['drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'];

	/**
	 * 是否过滤
	 * @param  {[type]} evtName [description]
	 * @return {[type]}         [description]
	 */
	function isfilter(eventName) {
	    return filterEvent.indexOf(eventName) === -1 ? true : false;
	}

	/**
	 * 特性摘除
	 * 1 ：无事件，默认可以翻页，还可以切换工具栏
	 * 2 ：静态事件，默认可以翻页
	 * 3 : 冲突事件，默认删除
	 * 去除默认元素具有的翻页特性
	 * @param  {[type]} evtName [事件名]
	 * @return {[type]}         [description]
	 */
	function setDefaultBehavior(supportSwipe, $contentNode) {
	    if (supportSwipe) {
	        //静态事件，默认可以翻页，还可以切换工具栏
	        $contentNode.attr('data-behavior', 'swipe');
	    } else {
	        //如果事件存在
	        $contentNode.attr('data-behavior', 'disable');
	    }
	}

	/**
	 * 针对软件培训的操作行为下光标状态需求
	 */
	function addCursor(eventName, $contentNode) {
	    if ($contentNode) {
	        if (!$contentNode.prop('setCursor')) {
	            //只设置一次
	            if (eventName === ('drag' || 'dragTag')) {
	                $contentNode.css('cursor', 'Move');
	            } else {
	                $contentNode.css('cursor', 'Pointer');
	            }
	            $contentNode.prop('setCursor', 'true');
	        }
	    }
	}

	/**
	 *  绑定事件
	 * @param  {[type]} eventDrop [description]
	 * @param  {[type]} data      [description]
	 * @return {[type]}           [description]
	 */
	function bindEvnet(eventDrop, data) {
	    var dragObj, eventHandler, eventReference, eventContext, eventName, supportSwipe;

	    eventContext = data.eventContext;
	    eventName = data.eventName;
	    supportSwipe = data.supportSwipe;

	    switch (eventName) {
	        case 'drag':
	            //拖动
	            dragObj = new _class(eventContext, null, data.parameter, eventDrop.startRun, eventDrop.stopRun);
	            break;
	        case 'dragTag':
	            //拖拽
	            dragObj = new _class(eventContext, data.target, 1, eventDrop.startRun, eventDrop.stopRun);
	            break;
	        default:

	            //事件句柄
	            eventHandler = function eventHandler() {
	                data.eventRun.call(eventContext);
	            };

	            //简单单机
	            if (eventName === 'tap') {
	                eventReference = simpleEvent(eventContext, eventHandler, supportSwipe);
	            } else {
	                //复杂用hammer
	                eventReference = complexEvent(eventContext, eventName, eventHandler, supportSwipe);
	            }
	            break;
	    }

	    return [dragObj, eventReference, eventHandler];
	}

	/**
	 * /匹配事件
	 * parameter 参数
	 * 1：对于自由拖动drag，para参数为0，表示松手后，停留在松手的地方
	 *                      para参数为1，表示松手后，返回原来的位置
	 * 2: 对于拖拽dragTag， para表示目标对象的target
	 */
	function matchEvent(data) {
	    //针对软件培训的操作行为下光标状态需求
	    Xut.plat.isBrowser && data.domMode && addCursor(data.eventName, data.eventContext);

	    //绑定事件
	    var eventDrop = data.eventDrop;

	    //拖动,引用,回调
	    var eventObj = bindEvnet(eventDrop, data);

	    //拖动,拖拽对象处理
	    //动作初始化
	    if (eventObj[0] && eventDrop.init) {
	        eventDrop.init(eventObj[0]);
	    } else {
	        //传递引用
	        data.eventHandler(eventObj[1], eventObj[2]);
	    }
	}

	//数据库预定义14个事件接口
	//提供给content文件
	//用于过滤数据库字段指定的行为
	//https://github.com/EightMedia/hammer.js/wiki/Getting-Started
	//2014.3.18 新增assist 辅助对象事件
	function conversionEventType(eventType) {
	    return eventName[Number(eventType) - 1] || null;
	}

	/**
	 * 注册自定义事件
	 * this还是引用的当前实例的上下文
	 *
	 *   '$contentNode'   : 事件对象
	 *   'target'    : 目标对象
	 *   'parameter' : 拖动参数
	 *   'evtName'   : 事件名,
	 *
	 *   callbackHook 回调函数 ,处理具体的事情
	 */
	function bindContentEvent(data) {
	    //是否支持翻页
	    var supportSwipe = data.supportSwipe = isfilter(data.eventName);
	    //检测是否移除元素的默认行为,因为元素都具有翻页的特性
	    if (data.domMode) {
	        setDefaultBehavior(supportSwipe, data.eventContext);
	    }
	    //执行事件绑定
	    matchEvent(data);
	}

	/**
	 * 销毁对象事件
	 */
	function destroyContentEvent(eventData, eventName) {
	    if (eventData.eventReference) {
	        eventData.eventReference.off(eventName || eventData.eventName, eventData.eventHandler);
	        eventData.eventReference = null;
	        eventData.eventHandler = null;
	    }
	}

	/**
	 * 获取对应的activity对象
	 * @param  {[type]}   activityId [description]
	 * @param  {Function} callback   [description]
	 * @return {[type]}              [description]
	 */
	var getActivity = function getActivity(activityId, callback) {
	    var activity;
	    if (activity = this._abActivitys) {
	        _.each(activity.get(), function (contentObj, index) {
	            if (activityId == contentObj.activityId) {
	                callback(contentObj);
	                return;
	            }
	        }, this);
	    }
	};

	/**
	 * 制作一个处理绑定函数
	 * @param  {[type]} pagebase [description]
	 * @return {[type]}          [description]
	 */
	var makeRunBinding = function makeRunBinding(pagebase) {
	    var registers = this.registers;
	    var shift;
	    return function () {
	        var activityId = registers[0];
	        getActivity.call(pagebase, activityId, function (activityObj) {
	            activityObj.runAnimation(function () {
	                shift = registers.shift();
	                registers.push(shift);
	            });
	        });
	    };
	};

	/**
	 * 多事件处理
	 * 每次通过同一个热点,触发不同的对象操作
	 * @return {[type]} [description]
	 */
	var combineEvents = function combineEvents(pagebase, eventRelated) {
	    var contentObj, eventName;
	    //多条activty数据,一个对象上多事件
	    _.each(eventRelated, function (edata) {
	        _.each(edata, function (scope) {
	            contentObj = pagebase.baseGetContentObject(scope.eventContentId);
	            if (!contentObj) {
	                Xut.log('error', 'pagebase.js第' + pagebase.pageIndex + '页多事件处理出错!!!!');
	                return;
	            }
	            eventName = conversionEventType(scope.eventType);
	            //制动运行动作
	            scope.runAnimation = makeRunBinding.call(scope, pagebase);
	            //销毁方法
	            scope.destroy = function () {
	                destroyContentEvent(scope, eventName);
	                scope.registers = null;
	                scope.runAnimation = null;
	            };

	            //事件绑定
	            bindContentEvent({
	                'eventRun': function eventRun() {
	                    scope.runAnimation();
	                },
	                'eventHandler': function eventHandler(eventReference, _eventHandler) {
	                    scope.eventReference = eventReference;
	                    scope.eventHandler = _eventHandler;
	                },
	                'eventContext': contentObj.$contentNode,
	                'eventName': eventName,
	                'parameter': scope.dragdropPara,
	                'target': null,
	                'domMode': true
	            });
	        });

	        //暴露引用
	        pagebase.listenerHooks.registerEvents = eventRelated;
	    });
	};

	function create(pagebase, eventRelated) {
	    combineEvents(pagebase, eventRelated);
	}

	function _destroy(pagebase) {
	    var registerEvents;
	    if (registerEvents = pagebase.listenerHooks.registerEvents) {
	        _.each(registerEvents, function (edata) {
	            _.each(edata, function (obj) {
	                obj.destroy && obj.destroy();
	            });
	        });
	    }
	    pagebase.listenerHooks.registerEvents = null;
	}

	/**
	 * [ description]
	 * @return {[type]} [description]
	 */

	/**
	 * 处理合集
	 */
	function Collection() {
	    this.remove();
	}

	Collection.prototype = {
	    register: function register(contentObj) {
	        if (!this.list) {
	            this.list = [contentObj];
	        } else {
	            this.list.push(contentObj);
	        }
	    },
	    get: function get() {
	        return this.list;
	    },


	    /**
	     * 是否存在
	     * @return {Boolean} [description]
	     */
	    isExist: function isExist() {
	        return this.list.length;
	    },

	    /**
	     * 得到一个指定的实例
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    specified: function specified(data) {
	        var instance;
	        var listLength = this.list.length;
	        while (listLength) {
	            listLength--;
	            if (instance = this.list[listLength]) {
	                if (instance.type === data.type && instance.id === data.id) {
	                    return instance;
	                }
	            }
	        }
	    },
	    remove: function remove() {
	        this.list = [];
	    },
	    reset: function reset() {
	        this.remove();
	    }
	};

	/**
	 * 根据指定的chpaterId解析
	 * @return {[type]} [description]
	 */
	var scenarioChapter = function scenarioChapter(chapterId) {
	    var chapterSection = Xut.data.chapterSection;
	    var rang = chapterSection['seasonId->' + chapterId];
	    return rang;
	};

	/**
	 * 递归分解
	 * chpater直接对应页面的ID编码，直接去下标即可
	 * waitCreatePointer     需要分解的页面
	 */
	var parseChapter = function parseChapter(waitCreatePointer) {
	    var chapters = [],
	        chapter,
	        dataChpater = Xut.data.Chapter,
	        points = waitCreatePointer.length,
	        key;

	    while (points--) {
	        key = waitCreatePointer[points];
	        if (chapter = dataChpater.item(key)) {
	            chapters.unshift(chapter);
	        }
	    }

	    return chapters;
	};

	/**
	 * 解析视觉差的数据
	 * @param  {[type]}   data     [description]
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var getMasterData = function getMasterData(data, callback) {
	    var pptMaster = data['pptMaster'];
	    var masterData = Xut.data.query('Master', pptMaster);
	    makeActivitys(masterData, function (activitys, autoData) {
	        callback(masterData, activitys, autoData);
	    });
	};

	/**
	 * 解析出页面自动运行的数据
	 * autoplay && !Content
	 * @param  {[type]} activitys [description]
	 * @return {[type]}           [description]
	 */
	var makeAuto = function makeAuto(activityData) {

	    if (!activityData || !activityData.length) return;

	    var sub = void 0;
	    //自动热点
	    var collectAutoBuffers = [];

	    activityData.forEach(function (target, b) {
	        //如果是自动播放,并且满足自定义条件
	        //并且不是content类型
	        if (target.autoPlay && target.actType !== 'Content') {
	            //增加note提示信息数据
	            // id = target._id
	            // key = target.actType ? target.actType + "_" + id : 'showNote_' + id
	            sub = {
	                'id': target._id,
	                'actType': target.actType,
	                'category': target.category,
	                'autoPlay': target.autoPlay
	            };
	            collectAutoBuffers.push(sub);
	        }
	    });

	    return collectAutoBuffers.length && collectAutoBuffers;
	};

	/**
	 * 混入shownote
	 * 组合showNote数据,弹出信息框,也看作一个热点
	 * shownote是chater的信息，混入到activity列表中当作每页的对象处理
	 * @return {[type]} [description]
	 */
	var mixShowNote = function mixShowNote(oneChapter, activityData) {
	    if (oneChapter.note) {
	        activityData.push(oneChapter);
	    }
	};

	/**
	 * 制作activity表的数据
	 * chpaters = {
	 *     pageIndex-12: Object
	 *     pageIndex-13: Object
	 *     pageIndex-14: Object
	 *  }
	 **/
	var makeActivitys = function makeActivitys(chapterData, callback) {
	    if (!chapterData) callback();

	    var activitys = [];
	    var chapterId = chapterData._id;

	    Xut.data.query('Activity', chapterId, 'chapterId', function (item) {
	        activitys.push(item);
	    });

	    //混入文本提示框
	    mixShowNote(chapterData, activitys);

	    //自动运行的数据
	    //解析出每一页自动运行的 Widget,Action,Video数据
	    var autoData = makeAuto(activitys);

	    callback(activitys, autoData);
	};

	/**
	 * 解析关联的Activity表数据
	 * @param  {[type]}   pageData [description]
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var getActivitys = function getActivitys(chapterData, callback) {
	    makeActivitys(chapterData, function (activitys, autoData) {
	        callback(chapterData, activitys, autoData);
	    });
	};

	/**
	 * 1 解析chapter页面数据
	 * 2 解析对应的Activity数据
	 * 3 解析出自动widget数据结构
	 * @param  {[type]}   data     [description]
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var getPageData = function getPageData(data, callback) {
	    var parsePointer = data.pageIndex;
	    var chapterData = data.pageData;
	    if (chapterData) {
	        getActivitys(chapterData, callback);
	    } else {
	        //解析章节数据
	        parseChapter(parsePointer, function (chapter) {
	            //生成chapter数据
	            getActivitys(chapter.length ? chapter[0] : chapter, callback);
	        });
	    }
	};

	/**
	 * 查询接口
	 * @param  {[type]}   tableName [description]
	 * @param  {[type]}   options   [description]
	 * @param  {Function} callback  [description]
	 * @return {[type]}             [description]
	 */
	function query(tableName, options, callback) {
	    switch (tableName) {
	        case 'page':
	            //得到页面关联的数据
	            return getPageData(options, callback);
	        case 'master':
	            //得到母版关联的数据
	            return getMasterData(options, callback);
	        case 'chapter':
	            //得到chapter表数据
	            return parseChapter(options);
	        case 'scenarioChapter':
	            return scenarioChapter(options);
	    }
	}

	/**
	 * 更新数据缓存
	 * @param  {[type]}   pid      [description]
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	function updataCache (pid, callback) {
	    var fn = void 0,
	        base = this,
	        pageType = base.pageType;

	    //缓存数据
	    var addCacheDas = function addCacheDas(namespace, data) {
	        var key = void 0;
	        if (!base._dataCache[namespace]) {
	            base._dataCache[namespace] = data;
	        } else {
	            for (key in data) {
	                base._dataCache[namespace][key] = data[key];
	            }
	        }
	    };

	    //增加数据缓存
	    var addCache = function addCache(data, activitys, autoData) {
	        addCacheDas(base.pageType, data); //挂载页面容器数据
	        addCacheDas('activitys', activitys); //挂载activitys数据
	        addCacheDas('auto', autoData); //挂载自动运行数据
	    };

	    query(pageType, {
	        'pageIndex': pid,
	        'pageData': base.chapterData,
	        'pptMaster': base.pptMaster
	    }, function (data, activitys, autoData) {
	        addCache.apply(addCache, arguments);
	        callback(data);
	    });
	}

	var TANSFROM = Xut.style.transform;

	/**
	 * 创建页面容器li
	 */
	var createli = function createli() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        base = _ref.base,
	        prefix = _ref.prefix,
	        translate = _ref.translate,
	        customStyle = _ref.customStyle,
	        pageData = _ref.pageData,
	        background = _ref.background;

	    var getStyle = base.getStyle;

	    return String.styleFormat('<li id="' + prefix + '"\n            data-id="' + pageData._id + '"\n            data-map="' + base.pid + '"\n            data-pageType="' + base.pageType + '"\n            data-container="true"\n            class="xut-flip fix-transform"\n            style="width:' + getStyle.viewWidth + 'px;\n                   height:' + getStyle.viewHeight + 'px;\n                   left:' + getStyle.viewLeft + 'px;\n                   top:' + getStyle.viewTop + 'px;\n                   ' + TANSFROM + ':' + translate + ';\n                   ' + background + '\n                   ' + customStyle + '\n                   overflow:hidden;">\n            <div class="page-pinch"></div>\n        </li>');
	};

	/**
	 * 创建父容器li结构
	 */
	var createContainer = function createContainer(base, pageData, getStyle, prefix) {

	    var background = '';

	    //chpater有背景，不是svg格式
	    if (!/.svg$/i.test(pageData.md5)) {
	        background = 'background-image:url(' + config.pathAddress + pageData.md5 + ');';
	    }

	    /**
	     * 自定义配置了样式
	     * 因为单页面跳槽层级的问题处理
	     */
	    var customStyle = '';
	    var userStyle = getStyle.userStyle;
	    if (userStyle !== undefined) {
	        //解析自定义规则
	        _.each(userStyle, function (value, key) {
	            customStyle += key + ':' + value + ';';
	        });
	    }

	    return $(createli({
	        base: base,
	        prefix: prefix,
	        translate: getStyle.translate,
	        customStyle: customStyle,
	        pageData: pageData,
	        background: background
	    }));
	};

	function TaskContainer (base, pageData, taskCallback) {

	    var $pageNode = void 0;
	    var $pseudoElement = void 0;

	    var prefix = base.pageType + "-" + (base.pageIndex + 1) + "-" + base.chapterId;
	    var getStyle = base.getStyle;

	    //iboosk编译
	    //在执行的时候节点已经存在
	    //不需要在创建
	    if (Xut.IBooks.runMode()) {
	        $pageNode = $("#" + prefix);
	        taskCallback($pageNode, $pseudoElement);
	        return;
	    }

	    //创建的flip结构体
	    $pageNode = createContainer(base, pageData, getStyle, prefix);

	    Xut.nextTick({
	        container: base.rootNode,
	        content: $pageNode,
	        position: getStyle.direction === 'before' ? 'first' : 'last'
	    }, function () {
	        taskCallback($pageNode, $pseudoElement);
	    });
	}

	var maskBoxImage = Xut.style.maskBoxImage;

	/**
	 * 修正尺寸
	 * @return {[type]} [description]
	 */
	var setDataSize = function setDataSize(data) {
	    //缩放比
	    var proportion = config.proportion;

	    //路径
	    data.path = config.pathAddress;

	    if (data.imageWidth) {
	        data.imageWidth = data.imageWidth * proportion.width;
	    }
	    if (data.imageHeight) {
	        data.imageHeight = data.imageHeight * proportion.height;
	    }
	    if (data.imageLeft) {
	        data.imageLeft = data.imageLeft * proportion.left;
	    }
	    if (data.imageTop) {
	        data.imageTop = data.imageTop * proportion.top;
	    }
	};

	/**
	 * 计算出对页排版偏移值
	 * @return {[type]} [description]
	 */
	var getOffset = function getOffset(pageSide) {
	    var background = void 0;
	    switch (Number(pageSide)) {
	        case 1:
	            background = 'background-position:0';
	            break;
	        case 2:
	            background = 'background-position:' + config.screenSize.width + 'px';
	            break;
	    }
	    return background;
	};

	/**
	 * 创建分层背景图层
	 * [createMaster description]
	 * @param  {[type]} svgContent [description]
	 * @param  {[type]} data       [description]
	 * @return {[type]}            [description]
	 */
	function createBackground(svgContent, data) {

	    var imageLayer,
	        maskLayer,
	        imageLayerData = data.imageLayer,
	        //图片层
	    imageMaskData = data.imageMask,
	        //蒙版层
	    backImageData = data.backImage,
	        //真实图片层
	    backMaskData = data.backMask,
	        //真实蒙版层
	    masterData = data.master,
	        //母板
	    backText = data.md5,
	        //背景文字
	    pptMaster = data.pptMaster; //母板PPTID

	    /**
	     * 未分层结构
	     * 只有SVG数据，没有层次数据 ,不是视觉差
	     * @return {[type]}          [description]
	     */
	    if (backText && !masterData && !pptMaster && !imageLayerData) {
	        if (svgContent) {
	            return String.styleFormat('<div data-multilayer ="true"\n                      class="multilayer">\n                    ' + svgContent + '\n                </div>');
	        } else {
	            return '';
	        }
	    }

	    /**
	     * 分层结构
	     * 1 分母板 文字层 背景 蒙版
	     * 2 视觉差分层处理
	     */

	    /**
	     * 修正尺寸
	     */
	    setDataSize(data);

	    /**
	     * 母版图
	     * 如果有母板数据,如果不是视觉差
	     * @return {[type]} [description]
	     */
	    var masterHTML = '';
	    if (masterData && !pptMaster) {
	        var masterImage = data.path + masterData;
	        masterHTML = '<div class="multilayer-master"\n                  style="background-image:url(' + masterImage + ')">\n             </div>';
	    }

	    /**
	     * 存在背景图
	     * @return {[type]}
	     */
	    var maskHTML = '';
	    if (imageLayerData) {
	        //蒙版图（与背景图是组合关系）
	        var _maskLayer = data.imageMask ? maskBoxImage + ":url(" + data.path + data.imageMask + ");" : "";
	        var maskImage = data.path + imageLayerData;
	        maskHTML = '<div class="multilayer-imageLayer"\n                  style="width:' + data.imageWidth + 'px;\n                         height:' + data.imageHeight + 'px;\n                         top:' + data.imageTop + 'px;\n                         left:' + data.imageLeft + 'px;\n                         background-image:url(' + maskImage + ');' + _maskLayer + '">\n            </div>';
	    }

	    /**
	     * 新增的 真实背景图 默认全屏
	     * @return {[type]
	     */
	    var backImageHTML = '';
	    if (backImageData) {
	        //计算出对页排版偏移值
	        var backImageOffset = getOffset(data.pageSide);
	        var backImagePosition = backImageOffset ? backImageOffset : '';
	        var newWidth = backImageOffset ? '200%' : '100%';
	        var newBackImage = data.path + backImageData;
	        var newBackMask = data.path + backMaskData;
	        if (backMaskData) {
	            //带蒙版
	            if (maskBoxImage != undefined) {
	                backImageHTML = '<div class="multilayer-backImage"\n                          style="width:' + newWidth + ';\n                                 background-image:url(' + newBackImage + ');\n                                 ' + maskBoxImage + ':url(' + newBackMask + ');\n                                 ' + backImagePosition + '">\n                    </div>';
	            } else {
	                //无蒙版
	                backImageHTML = '<canvas class="multilayer-backImage edges"\n                             height=' + document.body.clientHeight + '\n                             width=' + document.body.clientWidth + '\n                             src=' + newBackImage + '\n                             mask=' + newBackMask + '\n                             style="width:' + newWidth + ';\n                                    opacity:0;\n                                    ' + maskBoxImage + ':url(' + newBackImage + ');\n                                    ' + backImagePosition + '">\n                    </canvas>';
	            }
	        } else {
	            //图片层
	            backImageHTML = '<div class="multilayer-backImage"\n                                  style="width:' + newWidth + ';\n                                         background-image:url(' + newBackImage + ');\n                                         ' + backImagePosition + '">\n                            </div>';
	        }
	    }

	    /**
	     * 存在svg文字
	     * @return {[type]}
	     */
	    var backTextHTML = '';
	    if (backText) {
	        backTextHTML = '<div class="multilayer-word">\n                            ' + svgContent + '\n                        </div>';
	    }

	    /**
	     * 组层背景图开始
	     * @type {String}
	     */
	    return String.styleFormat('<div data-multilayer ="true"\n              class="multilayer">\n            ' + masterHTML + '\n            ' + maskHTML + '\n            ' + backImageHTML + '\n            ' + backTextHTML + '\n        </div>');
	}

	/**
	 * 构建背景类
	 * @param {[type]} $containsNode         [根节点]
	 * @param {[type]} data                 [数据]
	 * @param {[type]} suspendCallback      [中断回调]
	 * @param {[type]} successCallback      [description]
	 */

	var TaskBackground = function () {
	    function TaskBackground(_ref) {
	        var data = _ref.data,
	            $containsNode = _ref.$containsNode,
	            suspendCallback = _ref.suspendCallback,
	            successCallback = _ref.successCallback;
	        classCallCheck(this, TaskBackground);

	        var layer,
	            suspendTasks,
	            nextTasks,
	            self = this,
	            content = data["md5"],
	            isSVGContent = /.svg$/i.test(content) ? true : false;

	        this.callback = {
	            'suspendCallback': suspendCallback,
	            'successCallback': successCallback
	        };

	        //iboosk节点预编译
	        //在执行的时候节点已经存在
	        //不需要在创建
	        if (Xut.IBooks.runMode()) {
	            //找到背景节点
	            // var $element = $containsNode.find('.multilayer');
	            successCallback();
	            return;
	        }

	        //背景是否需要SVG解析
	        this.parseMaster(isSVGContent, content, function (svgContents) {
	            svgContents = replacePath(svgContents);
	            //构建背景
	            var backgroundStr = createBackground(svgContents, data);
	            if (backgroundStr) {
	                svgContents = null;
	                self.compileSuspend($(backgroundStr), $containsNode);
	            } else {
	                successCallback();
	            }
	        });
	    }

	    createClass(TaskBackground, [{
	        key: 'clearReference',
	        value: function clearReference() {}

	        /**
	         * 构建中断函数
	         * @param  {[type]} $background [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: 'compileSuspend',
	        value: function compileSuspend($background, $containsNode) {

	            var nextTasks,
	                suspendTasks,
	                self = this;

	            //继续执行
	            nextTasks = function nextTasks() {
	                Xut.nextTick({
	                    'container': $containsNode,
	                    'content': $background
	                }, function () {
	                    self.clearReference();
	                    self.callback.successCallback();
	                });
	            };

	            //中断方法
	            suspendTasks = function suspendTasks() {
	                self.suspendQueues = [];
	                self.suspendQueues.push(function () {
	                    nextTasks();
	                });
	            };

	            self.callback.suspendCallback(nextTasks, suspendTasks);
	        }

	        /**
	         * 运行被阻断的线程任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'runSuspendTasks',
	        value: function runSuspendTasks() {
	            if (this.suspendQueues) {
	                var fn;
	                if (fn = this.suspendQueues.pop()) {
	                    fn();
	                }
	                this.suspendQueues = null;
	            }
	        }

	        /**
	         * /解析SVG背景
	         * @param  {Boolean}  isSVGContent [description]
	         * @param  {[type]}   content      [description]
	         * @param  {Function} callback     [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: 'parseMaster',
	        value: function parseMaster(isSVGContent, content, callback) {
	            if (isSVGContent) {
	                //背景需要SVG解析的
	                readFile(content, function (svgContents) {
	                    callback(svgContents);
	                });
	            } else {
	                callback('');
	            }
	        }
	    }]);
	    return TaskBackground;
	}();

	/**
	 * 设置canvas数据
	 */
	var createCanvasData = function createCanvasData(type, opts) {

		var data = opts.data;
		var contentId = opts.contentId;
		var conData = opts.conData;

		//content收集id标记
		//cid =>content=> 普通动画 ppt
		//wid =>widget=>高级动画
		if (data.canvasRelated[type].indexOf(contentId) == -1) {
			data.canvasRelated[type].push(contentId);
			conData.actionTypes[type] = true;
		}

		if (data.canvasRelated.cid.indexOf(contentId) == -1) {
			data.canvasRelated.cid.push(contentId);
		}

		//给content数据增加直接判断标示
		conData.canvasMode = true;

		//拿到最高层级
		if (conData.zIndex) {
			if (conData.zIndex > data.canvasRelated.containerIndex) {
				data.canvasRelated.containerIndex = conData.zIndex;
			}
		}
	};

	/**
	 * canvas pixi.js类型处理转化
	 * 填充cid, wid
	 * @type {Object}
	 */
	var pixiType = {
		//普通精灵动画
		"Sprite": function Sprite(opts, data) {
			if (data.canvasRelated.enable) {
				//启动精灵模式
				//在动画处理的时候给initAnimations快速调用
				createCanvasData('spiritId', opts);
			}
		},
		//ppt=》pixi动画
		"PPT": function PPT(opts, data) {
			//双重判断
			//必须启动cnavas模式
			//必须数据是canvs模式
			//因为ppt只支持 高级与复杂精灵
			if (data.canvasRelated.enable && opts.conData.canvasMode) {
				createCanvasData('pptId', opts);
			}
		},
		//高级精灵动画
		//widget
		"SeniorSprite": function SeniorSprite(opts, data) {
			if (data.canvasRelated.enable) {
				createCanvasData('widgetId', opts);
			}
		},
		//复杂精灵动画
		//可以在dom模式与canvas混合使用
		//所以dom下还要强制开始canvasMode
		"CompSprite": function CompSprite(opts) {
			var data = opts.data;
			var conData = opts.conData;
			if (/\./i.test(opts.conData.md5)) {
				console.log('复杂精灵动画数据错误');
				return;
			}

			//特殊判断，见canvas.js
			//如果没有启动canvas也能走进这个程序
			//给上特殊标示
			if (!data.canvasRelated.enable && !data.canvasRelated.onlyCompSprite) {
				//仅仅只是满足特殊动画
				//特殊模式，可能chapter表中没有启动canvas模式
				data.canvasRelated.onlyCompSprite = true;
			}
			createCanvasData('compSpriteId', opts);
		}

	};

	/**
	 * 解析参数
	 */
	function callResolveArgs(category, opts) {
		var cate;
		var val;
		var data = opts.data;
		var cates = category.split(",");
		var length = cates.length;
		var i = 0;
		//判断ppt是不是数组中最后一个
		//如果不是，需要对调位置
		var pptindex = cates.indexOf('PPT');

		//如果是首位
		if (pptindex == 0) {
			//ppt永远最后一个
			cates = cates.concat(cates.splice(pptindex, 1));
		}

		if (length) {
			for (var i = 0; i < length; i++) {
				cate = cates[i];
				//匹配数据类型
				pixiType[cate] && pixiType[cate](opts, data);
			}
		}
	}

	/**
	 * 解析canvas数据
	 *
	 */
	function parseCanvas(contentId, category, conData, data) {

		//类型转化
		//双数据类型转行单个类型
		if (Xut.config.onlyDomMode) {
			if (category) {
				var cat;
				var cats = category.split(",");
				var len = cats.length;
				if (len > 1) {
					//删除ppt
					var pptindex = cats.indexOf('PPT');
					if (-1 != pptindex) {
						cats.splice(pptindex, 1);
					}
				}
				conData.category = cats[0];
			}
			return;
		}

		//动作类型
		//用于动画判断
		conData.actionTypes = {};

		//下一个数据
		var opts = {
			contentId: contentId,
			conData: conData,
			data: data
		};

		//转成canvas标记
		//如果有pixi的处理类型
		//2016.2.25
		//SeniorSprite,PPT
		//Sprite,PPT
		//SeniorSprite
		//Sprite
		//PPT
		//CompSprite
		//多种处理方式
		//可以组合
		category && callResolveArgs(category, opts);
	}

	/**
	 * 解析序列中需要的数据
	 * @param  {[type]}   contentIds [description]
	 * @param  {Function} callback   [description]
	 * @return {[type]}              [description]
	 */
	function parseContentDas(contentIds, callback) {
	    var data,
	        temp = [];
	    contentIds.forEach(function (contentId, index) {
	        data = Xut.data.query('Content', contentId);
	        temp.unshift(data);
	        callback && callback(data, contentId);
	    });
	    return temp;
	}

	/**
	 * 针对容器类型的处理
	 * @param  {[type]} containerName [description]
	 * @param  {[type]} contentId     [description]
	 * @param  {[type]} pid     [description]
	 * @return {[type]}               [description]
	 */
	var createContainerWrap = function createContainerWrap(containerName, contentId, pid) {

	    var contentDas = parseContentDas([contentId]);
	    var data = reviseSize(contentDas[0]);
	    var wapper = '<div  id="' + containerName + '"\n               data-behavior="click-swipe"\n               style="width:' + data.scaleWidth + 'px;\n                      height:' + data.scaleHeight + 'px;\n                      top:' + data.scaleTop + 'px;\n                      left:' + data.scaleLeft + 'px;\n                      position:absolute;\n                      z-index:' + data.zIndex + ';">';

	    return String.styleFormat(wapper);
	};

	function createContainer$1(containerRelated, pid) {
	    var itemIds,
	        uuid,
	        contentId,
	        containerName,
	        containerObj = {
	        createUUID: [],
	        containerName: []
	    };

	    containerRelated.forEach(function (data, index) {
	        contentId = data.imageIds;
	        containerName = "Container_" + pid + "_" + contentId;
	        uuid = "aaron" + Math.random();
	        containerObj[uuid] = {
	            'start': [createContainerWrap(containerName, contentId, pid)],
	            'end': '</div>'
	        };
	        containerObj.createUUID.push(uuid);
	        containerObj.containerName.push(containerName);
	        data.itemIds.forEach(function (id) {
	            containerObj[id] = uuid;
	        });
	    });
	    return containerObj;
	}

	var maskBoxImage$1 = Xut.style.maskBoxImage;
	var FLOOR$2 = Math.floor;

	/**
	 * 蒙版动画
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var maskContent = function maskContent(data, wrapObj) {

	    var restr = "";

	    //如果有蒙版图
	    var isMaskImg = data.mask ? maskBoxImage$1 + ":url(" + Xut.config.pathAddress + data.mask + ");" : "";
	    var pathImg = wrapObj.pathImg;

	    //蒙板图
	    if (data.mask || wrapObj['isGif']) {
	        //蒙版图
	        if (maskBoxImage$1 != undefined) {
	            restr += String.styleFormat("<img data-type=\"mask-images\"\n                      class=\"inherit-size fullscreen-background edges\"\n                      src=\"" + pathImg + "\"\n                      style=\"" + isMaskImg + "\"/>");
	        } else {
	            //canvas
	            restr += String.styleFormat("<canvas class=\"inherit-size fullscreen-background edges\"\n                         src=\"" + pathImg + "\"\n                         mask=\"" + isMaskImg + "\"\n                         width=\"" + data.scaleWidth + "\"\n                         height=\"" + data.scaleHeight + "\"\n                         style=\"opacity:0;" + (Xut.config.pathAddress.replace(/\//g, "\/") + data.mask) + "\"/>");
	        }

	        //精灵图
	    } else if (data.category == 'Sprite') {

	        var matrixX = 100 * data.thecount;
	        var matrixY = 100;

	        //如果有参数
	        //精灵图是矩阵图
	        if (data.parameter) {
	            var parameter = parseJSON(data.parameter);
	            if (parameter && parameter.matrix) {
	                var matrix = parameter.matrix.split("-");
	                matrixX = 100 * Number(matrix[0]);
	                matrixY = 100 * Number(matrix[1]);
	            }
	        }
	        restr += String.styleFormat("<div data-type=\"sprite-images\"\n                  class=\"sprite\"\n                  style=\"height:" + data.scaleHeight + "px;\n                         background-image:url(" + wrapObj['pathImg'] + ");\n                         background-size:" + matrixX + "% " + matrixY + "%;\">\n            </div>");
	    } else {
	        //普通图片
	        restr += String.styleFormat("<img data-type=\"ordinary-images\"\n                  class=\"inherit-size fullscreen-background\"\n                  src=\"" + pathImg + "\"\n                  style=\"" + isMaskImg + "\"/>");
	    }

	    return restr;
	};

	/**
	 * 纯文本内容
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	var textContent = function textContent(data) {
	    return String.styleFormat("<div id = \"" + data['_id'] + "\" style=\"background-size:100% 100%;height:auto\">\n              " + data.content + "\n         </div>");
	};

	/**
	 * 如果是.js结尾的
	 * 新增的html文件
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var jsContent = function jsContent(data, wrapObj) {
	    return replacePath(wrapObj.htmlstr);
	};

	/**
	 * 如果内容是svg
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var svgContent = function svgContent(data, wrapObj) {
	    var restr = "";
	    var svgstr = wrapObj.svgstr;
	    var scaleWidth = data.scaleWidth;

	    //从SVG文件中，读取Viewport的值
	    if (svgstr != undefined) {

	        //替换svg内部读取文件地址
	        svgstr = replacePath(svgstr);

	        var startPos = svgstr.search('viewBox="');
	        var searchTmp = svgstr.substring(startPos, startPos + 64).replace('viewBox="', '').replace('0 0 ', '');
	        var endPos = searchTmp.search('"');
	        var temp = searchTmp.substring(0, endPos);
	        var sptArray = temp.split(" ");
	        var svgwidth = sptArray[0];
	        var svgheight = sptArray[1];

	        //svg内容宽度:svg内容高度 = viewBox宽:viewBox高
	        //svg内容高度 = svg内容宽度 * viewBox高 / viewBox宽
	        var svgRealHeight = FLOOR$2(scaleWidth * svgheight / svgwidth);
	        //如果svg内容高度大于布局高度则添加滚动条
	        if (svgRealHeight > data.scaleHeight + 1) {
	            var svgRealWidth = FLOOR$2(scaleWidth);
	            //if there do need scrollbar, then restore text to its original prop
	            //布局位置
	            var marginleft = wrapObj.backMode ? data.scaleLeft - data.scaleBackLeft : 0;
	            var margintop = wrapObj.backMode ? data.scaleTop - data.scaleBackTop : 0;

	            if (data.isScroll) {
	                restr = String.styleFormat("<div data-type=\"svg\"\n                          style=\"width:" + svgRealWidth + "px;\n                                 height:" + svgRealHeight + "px;\n                                 margin-left:" + marginleft + "px;\n                                 margin-top:" + margintop + "px;\">\n                        " + svgstr + "\n                     </div>");
	            } else {
	                restr = String.styleFormat("<div data-type=\"svg\"\n                          class=\"inherit-size\"\n                          style=\"margin-left:" + marginleft + "px;\n                                 margin-top:" + margintop + "px;\">\n                        " + svgstr + "\n                    </div>");
	            }
	        } else {
	            restr += svgstr;
	        }
	    }
	    return restr;
	};

	/**
	 * 填充content内容
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var fillContent = function fillContent(data, wrapObj) {
	    var restr = '';
	    //如果内容是图片
	    //如果是svg或者html
	    if (wrapObj.imgContent) {
	        //如果是SVG
	        if (wrapObj.isSvg) {
	            restr += svgContent(data, wrapObj);
	        }
	        //如果是.js结构的html文件
	        else if (wrapObj.isJs) {
	                restr += jsContent(data, wrapObj);
	            }
	            //如果是蒙板，或者是gif类型的动画，给高度
	            else {
	                    restr += maskContent(data, wrapObj);
	                }
	    }
	    //纯文本文字
	    else {
	            restr += textContent(data, wrapObj);
	        }
	    return restr;
	};

	/**
	 * 创建包含容器content
	 * @param  {[type]} data    [description]
	 * @param  {[type]} wrapObj [description]
	 * @return {[type]}         [description]
	 */
	var createContainer$2 = function createContainer(data, wrapObj) {
	    var wapper = void 0;
	    var backwidth = void 0,
	        backheight = void 0,
	        backleft = void 0,
	        backtop = void 0;
	    var zIndex = data.zIndex;
	    var id = data._id;

	    //Content_23_37
	    //Content_23_38
	    //Content_23_39
	    var containerName = wrapObj.containerName;
	    var pid = wrapObj.pid;
	    var makeId = wrapObj.makeId;
	    var background = data.background ? 'background-image: url(' + Xut.config.pathAddress + data.background + ');' : '';

	    //背景尺寸优先
	    if (data.scaleBackWidth && data.scaleBackHeight) {
	        backwidth = data.scaleBackWidth;
	        backheight = data.scaleBackHeight;
	        backleft = data.scaleBackLeft;
	        backtop = data.scaleBackTop;
	        wrapObj.backMode = true; //背景图模式
	    } else {
	        backwidth = data.scaleWidth;
	        backheight = data.scaleHeight;
	        backleft = data.scaleLeft;
	        backtop = data.scaleTop;
	    }

	    //content默认是显示的数据的
	    //content.visible = 0
	    //如果为1 就隐藏改成hidden
	    //05.1.14
	    var visibility = 'visible';
	    if (data.visible) {
	        visibility = 'hidden';
	    }

	    // var isHtml = "";
	    //2015.12.29
	    //如果是html内容
	    if (wrapObj.isJs) {
	        wapper = "<div id=\"" + containerName + "\"\n                       data-behavior=\"click-swipe\"\n                       class=\"fullscreen-background \"\n                       style=\"width:" + backwidth + "px;\n                              height:" + backheight + "px;\n                              top:" + backtop + "px;\n                              left:" + backleft + "px;\n                              position:absolute;\n                              z-index:" + zIndex + ";\n                              visibility:" + visibility + ";\n                              {10}\">\n                 <div data-type=\"scroller\"\n                      style=\"width:" + backwidth + "px;\n                             position:absolute;\">";
	        return String.styleFormat(wapper);
	    }

	    //scroller:=> absolute 因为别的元素有依赖

	    //正常content类型
	    //如果是scroller需要绝对的尺寸，所以替换100% 不可以
	    wapper = "<div id=\"" + containerName + "\"\n                   data-behavior=\"click-swipe\"\n                   style=\"width:" + backwidth + "px;\n                          height:" + backheight + "px;\n                          top:" + backtop + "px;\n                          left:" + backleft + "px;\n                          position:absolute;\n                          z-index:" + zIndex + ";\n                          visibility:" + visibility + "\">\n              <div data-type=\"scroller\"\n                   class=\"fullscreen-background \"\n                   style=\"width:" + backwidth + "px;\n                          height:" + backheight + "px;\n                          position:absolute;\n                          " + background + "\">";

	    return String.styleFormat(wapper);
	};

	/**
	 * 组成HTML结构
	 * @param  {[type]} argument [description]
	 * @return {[type]}          [description]
	 */
	function createDom(data, wrapObj) {
	    var restr = '';

	    //创建包装容器content节点
	    restr += createContainer$2(data, wrapObj);

	    //创建内容
	    restr += fillContent(data, wrapObj);
	    restr += "</div></div>";

	    return restr;
	}

	/**
	 * 组成HTML结构
	 * @param  {[type]} argument [description]
	 * @return {[type]}          [description]
	 */
	function createCanvas(data, wrapObj) {

	    var mark = '';
	    if (data.category) {
	        var cats = data.category.split(",");
	        var len = cats.length;
	        if (len) {
	            while (len--) {
	                mark += cats[len];
	            }
	        }
	    }

	    var temp = '<canvas id="{0}"' + ' data-ctype={1}' + ' width="{2}"' + ' height="{3}">' + '</canvas>';

	    var str = String.format(temp, wrapObj.makeId('canvas'), mark.toLocaleLowerCase(), data.scaleWidth, data.scaleHeight);

	    return str;
	}

	/**
	 * 解析序列中需要的数据
	 * @param  {[type]}   contentIds [description]
	 * @param  {Function} callback   [description]
	 * @return {[type]}              [description]
	 */

	/**
	 * 制作包装对象
	 * 用于隔绝content数据的引用关系
	 * 导致重复数据被修正的问题
	 * @return {[type]}             [description]
	 */
	var makeWarpObj = function makeWarpObj(contentId, content, pageType, pid, virtualOffset) {
	    //唯一标示符
	    var prefix = "_" + pid + "_" + contentId;
	    return {
	        pageType: pageType,
	        contentId: contentId,
	        isJs: /.js$/i.test(content.md5), //html类型
	        isSvg: /.svg$/i.test(content.md5), //svg类型
	        data: content,
	        pid: pid,
	        virtualOffset: virtualOffset, //布局位置
	        containerName: 'Content' + prefix,
	        makeId: function makeId(name) {
	            return name + prefix;
	        }
	    };
	};

	/**
	 * 创建图片地址
	 * @return {[type]}         [description]
	 */
	var analysisPath = function analysisPath(wrapObj, conData) {
	    var pathImg, imgContent, isGif, originalPathImg, resourcePath, results, name;

	    imgContent = conData.md5;
	    isGif = /.gif$/i.test(imgContent); //是gif格式
	    originalPathImg = config.pathAddress + imgContent; //原始地址

	    if (isGif) {
	        pathImg = Xut.createRandomImg(originalPathImg); //处理gif图片缓存+随机数
	    } else {
	        pathImg = originalPathImg;
	    }

	    if (conData.category === "AutoCompSprite") {
	        try {
	            resourcePath = config.pathAddress + imgContent + "/app.json";
	            results = getResources(resourcePath);
	            var spiritList = results.spiritList[0];
	            var actListName = spiritList.params.actList;
	            name = spiritList.params[actListName].ImageList[0].name;

	            pathImg += '/' + name;
	            conData.resource = results;
	            conData.containerName = wrapObj.containerName;
	        } catch (err) {
	            console.log('AutoCompSprite获取数据失败');
	        }
	    }

	    wrapObj.imgContent = imgContent;
	    wrapObj.isGif = isGif;
	    wrapObj.pathImg = pathImg;
	};

	/**
	 * content
	 *  svg数据
	 *  html数据
	 * 解析外部文件
	 * @param  {[type]} wrapObj     [description]
	 * @param  {[type]} svgCallback [description]
	 * @return {[type]}             [description]
	 */
	var externalFile = function externalFile(wrapObj, svgCallback) {
	    //svg零件不创建解析具体内容
	    if (wrapObj.isSvg) {
	        readFile(wrapObj.data.md5, function (svgdata) {
	            wrapObj.svgstr = svgdata;
	            svgCallback(wrapObj);
	        });
	    } else if (wrapObj.isJs) {
	        //如果是.js的svg文件
	        readFile(wrapObj.data.md5, function (htmldata) {
	            wrapObj.htmlstr = htmldata;
	            svgCallback(wrapObj);
	        }, "js");
	    } else {
	        svgCallback(wrapObj);
	    }
	};

	//=====================================================
	//
	//  构建content的序列tokens
	//  createImageIds,
	//  createContentIds
	//  pid,
	//  pageType,
	//  dydCreate //重要判断,动态创建
	//
	//=======================================================
	function structure(callback, data, context) {
	    var content,
	        contentId,
	        wrapObj,
	        containerObj,
	        sizeResults,
	        contentCollection,
	        contentCount,
	        cloneContentCount,
	        pid = data.pid,
	        pageType = data.pageType,
	        containerRelated = data.containerRelated,
	        seasonRelated = data.seasonRelated,
	        isMaster = pageType === 'master',


	    //容器li生成的位置
	    //left,right
	    virtualOffset = data.virtualOffset,


	    ////////////
	    //浮动处理 //
	    //1.浮动母版对象
	    //2.浮动页面对象
	    ////////////
	    floatMaters = data.floatMaters,
	        floatPages = data.floatPages,


	    //文本框
	    //2016.1.7
	    contentHtmlBoxIds = [],


	    //所有content的id记录
	    //返回出去给ibooks预编译使用
	    idFix = [],


	    //缓存contentDas
	    contentDas = {},

	    //缓存content结构
	    cachedContentStr = [];

	    /**
	     * 容器结构创建
	     */
	    if (containerRelated && containerRelated.length) {
	        containerObj = createContainer$1(containerRelated, pid);
	    }

	    /**
	     * 转化canvas模式 contentMode 0/1
	     * 页面或者母板浮动对象
	     * 页面是最顶级的
	     * @return {[type]}           [description]
	     */
	    var eachPara = function eachPara(parameter, contentId, conData) {
	        var zIndex;
	        _.each(parameter, function (para) {
	            //针对母版content的topmost数据处理，找出浮动的对象Id
	            //排除数据topmost为0的处理
	            zIndex = para['topmost'];
	            if (zIndex && zIndex != 0) {
	                if (isMaster) {
	                    //收集浮动的母版对象id
	                    floatMaters.ids.push(contentId);
	                    floatMaters.zIndex[contentId] = zIndex;
	                } else {
	                    //浮动页面
	                    floatPages.ids.push(contentId);
	                    floatPages.zIndex[contentId] = zIndex;
	                }
	            }
	        });
	    };

	    /**
	     * 开始过滤参数
	     * @return {[type]}           [description]
	     */
	    var prefilter = function prefilter(conData, contentId) {
	        var eventId, parameter;
	        var category = conData.category;

	        //如果是模板书签，强制为浮动对象
	        if (isMaster && (eventId = seasonRelated[contentId])) {
	            if (eventId['BookMarks']) {
	                floatMaters.ids.push(contentId);
	            }
	        }

	        //如果有parameter参数
	        //1 浮动对象
	        //2 canvas对象
	        if (conData) {
	            //匹配canvas对象数据
	            if (category) {
	                //解析canvas先关数据
	                parseCanvas(contentId, category, conData, data);
	            }
	            //如果有parameter
	            if (conData.parameter) {
	                if (parameter = parseJSON(conData.parameter)) {
	                    //parameter保持数组格式
	                    eachPara(parameter.length ? parameter : [parameter], contentId, conData);
	                }
	            }
	        }
	    };

	    /**
	     * 解析出每一个content对应的动作
	     * 传递prefilter过滤器
	     * 1 浮动动作
	     * 2 canvas动作
	     * @type {[type]}
	     */
	    contentCollection = parseContentDas(data.createContentIds, prefilter);
	    contentCount = cloneContentCount = contentCollection.length;

	    //如果是启动了特殊高精灵动画
	    //强制打开canvas模式设置
	    //这里可以排除掉其余的canvas动画
	    if (data.canvasRelated.onlyCompSprite) {
	        data.canvasRelated.enable = true;
	    }

	    ////////////////
	    //开始生成所有的节点 //
	    //1:dom
	    //2:canvas
	    ////////////////
	    while (contentCount--) {

	        //根据数据创content结构
	        if (content = contentCollection[contentCount]) {
	            contentId = content['_id'];

	            //创建包装器,处理数据引用关系
	            wrapObj = makeWarpObj(contentId, content, pageType, pid, virtualOffset);
	            idFix.push(wrapObj.containerName);

	            //保存文本框content的Id
	            if (wrapObj.isJs) {
	                contentHtmlBoxIds.push(contentId);
	            }
	            //转换缩放比
	            sizeResults = reviseSize(wrapObj.data);

	            //正常模式下创建
	            startCreate(wrapObj, content, contentId);
	        } else {
	            //或者数据出错
	            checkComplete();
	        }
	    }

	    /**
	     * analysisPath
	     * @param  {[type]} wrapObj   [description]
	     * @param  {[type]} content   [description]
	     * @param  {[type]} contentId [description]
	     * @return {[type]}           [description]
	     */
	    function startCreate(wrapObj, content, contentId) {
	        //缓存数据
	        contentDas[contentId] = content;
	        //开始创建
	        createRelated(contentId, wrapObj);
	    }

	    /**
	     * 清理剔除的content
	     * @param  {[type]} contentId [description]
	     * @return {[type]}           [description]
	     */
	    function clearContent(contentId) {
	        data.createContentIds.splice(data.createContentIds.indexOf(contentId), 1);
	        checkComplete();
	    }

	    /**
	     * 创建content节点
	     * @param  {[type]} wrapObj [description]
	     * @return {[type]}         [description]
	     */
	    function createRelated(contentId, wrapObj) {
	        externalFile(wrapObj, function (wrapObj) {
	            var uuid = void 0,
	                startStr = void 0,
	                contentStr = void 0;

	            var conData = wrapObj.data;

	            //拼接地址
	            analysisPath(wrapObj, conData);

	            //canvas节点
	            if (conData.canvasMode) {
	                contentStr = createCanvas(conData, wrapObj);
	            } else {
	                //dom节点
	                contentStr = createDom(conData, wrapObj);
	            }

	            //如果创建的是容器对象
	            if (containerObj && (uuid = containerObj[contentId])) {
	                startStr = containerObj[uuid];
	                startStr.start.push(contentStr);
	            } else {
	                //普通对象
	                cachedContentStr.unshift(contentStr);
	            }

	            //检测完毕
	            checkComplete();
	        });
	    }

	    /**
	     * 返回处理
	     * @return {[type]} [description]
	     */
	    function checkComplete() {
	        if (cloneContentCount === 1) {
	            var data = {
	                contentDas: contentDas,
	                idFix: idFix,
	                contentHtmlBoxIds: contentHtmlBoxIds,
	                containerPrefix: ''
	            };
	            //针对容器处理
	            if (containerObj) {
	                var start, end, containerPrefix, containerStr;
	                containerStr = [];

	                //合并容器
	                containerObj.createUUID.forEach(function (uuid) {
	                    start = containerObj[uuid].start.join('');
	                    end = containerObj[uuid].end;
	                    containerStr.push(start.concat(end));
	                });
	                containerStr = containerStr.join('');
	                containerPrefix = containerObj.containerName;
	                containerObj = null;

	                data.contentStr = cachedContentStr.join('').concat(containerStr);
	                data.containerPrefix = containerPrefix;
	            } else {
	                data.contentStr = cachedContentStr.join('');
	            }

	            callback.call(context, data);
	        }
	        cloneContentCount--;
	    }
	}

	/**
	 * 针对分段处理
	 * 只构件必要的节点节点对象
	 * content字段中visible === 0 是构建显示的对象
	 *                      === 1 是构建隐藏的对象
	 *
	 * 并且不是动态创建
	 */
	// if (false && (1 == content.visible) && !data.dydCreate) {
	// endReturn();  //false 先屏蔽 ，客户端未实现
	// }else{}

	var docElement = document.documentElement;

	//默认字体
	var defaultFontSize = void 0;

	try {
	    defaultFontSize = parseInt(getComputedStyle(docElement).fontSize);
	} catch (er) {
	    defaultFontSize = 16;
	}

	//新的字体大小
	var newFontSize = void 0;

	var whiteObject = {
	    "rgb(255, 255, 255)": true,
	    "#ffffff": true,
	    "#FFFFFF": true,
	    "#fff": true,
	    "#FFF": true
	};

	/**
	 * 字体大小
	 * @type {Array}
	 */
	var sizeArray = ["1", "1.5", "2.0"];

	var getFontSize = function getFontSize() {
	    newFontSize = defaultFontSize * config.proportion.width;
	    return [Math.floor(newFontSize * 1.5), Math.floor(newFontSize * 2.0), Math.floor(newFontSize * 2.5)];
	};

	/**
	 * 工具栏布局
	 * @return {[type]} [description]
	 */
	function toolBar(fontSize) {
	    var baseValue1 = fontSize[0];
	    var baseValue2 = fontSize[1];
	    var baseValue3 = fontSize[2];
	    var boxHTML = '<div class="htmlbox_close_container">\n            <a class="htmlbox_close"></a>\n        </div>\n        <ul class="htmlbox_fontsizeUl">\n            <li>\n                <a class="htmlbox_small"\n                   style="width:' + baseValue1 + 'px;height:' + baseValue1 + 'px;margin-top:-' + baseValue1 / 2 + 'px"></a>\n            </li>\n            <li>\n                <a class="htmlbox_middle"\n                   style="width:' + baseValue2 + 'px;height:' + baseValue2 + 'px;margin-top:-' + baseValue2 / 2 + 'px"></a></li>\n            <li>\n                <a class="htmlbox_big"\n                   style="width:' + baseValue3 + 'px;height:' + baseValue3 + 'px;margin-top:-' + baseValue3 / 2 + 'px"></a>\n            </li>\n        </ul>';

	    return String.styleFormat(boxHTML);
	}

	/**
	 * 创建盒子容器
	 * @return {[type]} [description]
	 */
	function createWapper(boxHeight, context, iscrollName, textContent) {
	    var wapper = '<div class="htmlbox-container">\n            <div class="htmlbox-toolbar" style="height:' + boxHeight + 'px;line-height:' + boxHeight + 'px;">' + context + '</div>\n            <div class="' + iscrollName + '" style="overflow:hidden;position:absolute;width:100%;height:92%;">\n                <ul>' + textContent + '</ul>\n            </div>\n        </div>';
	    return String.styleFormat(wapper);
	}

	var HtmlBox = function () {
	    function HtmlBox(contentId, $contentNode) {
	        classCallCheck(this, HtmlBox);


	        this.contentId = contentId;
	        this.$contentNode = $contentNode;

	        var self = this;

	        //事件对象引用
	        var eventHandler = function eventHandler(eventReference, _eventHandler) {
	            self.eventReference = eventReference;
	            self.eventHandler = _eventHandler;
	        };

	        //绑定点击事件
	        bindContentEvent({
	            'eventRun': function eventRun() {
	                Xut.View.HideToolBar('pageNumber');
	                self._init(contentId, $contentNode);
	            },
	            'eventHandler': eventHandler,
	            'eventContext': $contentNode,
	            'eventName': "tap",
	            'domMode': true
	        });
	    }

	    createClass(HtmlBox, [{
	        key: '_init',
	        value: function _init(contentId, $contentNode) {
	            var self = this;

	            self._adjustColor();

	            //移除偏移量 存在偏移量造成文字被覆盖
	            var textContent = $contentNode.find(">").html();
	            textContent = textContent.replace(/translate\(0px, -\d+px\)/g, 'translate(0px,0px)');

	            var iscrollName = "htmlbox-iscroll-" + contentId;

	            //缓存名
	            this.storageName = iscrollName + config.appId;

	            var fontSize = getFontSize();

	            //工具栏的高度必须大于最大的字体大小
	            var boxHeight = fontSize[2] + 2;
	            //关闭按钮的top值
	            var closeTop = Math.floor(boxHeight / 2);

	            //获取保存的字体值
	            var initValue = $$get(this.storageName);
	            if (initValue) {
	                this._adjustSize(initValue);
	            } else {
	                //默认
	                this._adjustSize(newFontSize);
	            }

	            /**
	             * 创建容器
	             * @type {[type]}
	             */
	            this.$htmlbox = $(createWapper(boxHeight, toolBar(fontSize), iscrollName, textContent));

	            $contentNode.after(this.$htmlbox);

	            //修改::before ::after伪元素top值 确保关闭按钮垂直居中
	            document.styleSheets[0].addRule('.htmlbox_close::before', 'top:' + closeTop + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::before { top:' + closeTop + 'px }', 0);
	            document.styleSheets[0].addRule('.htmlbox_close::after', 'top:' + closeTop + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::after { top:' + closeTop + 'px }', 0);

	            //修正htmlbox位置
	            this._relocateToolbar(iscrollName);
	            //卷滚
	            this._createIscroll(this.$htmlbox, iscrollName);

	            /**
	             * 绑定事件上下文呢
	             * @type {[type]}
	             */
	            this.eventContext = this.$htmlbox.find('.htmlbox-toolbar')[0];

	            /**
	             * 改变字体与刷新卷滚
	             * @param  {[type]} fontsize [description]
	             * @return {[type]}          [description]
	             */
	            var change = function change(fontsize) {
	                self._adjustSize(fontsize * newFontSize, true);
	                self.iscroll && self.iscroll.refresh();
	            };

	            /**
	             * 关闭
	             * @return {[type]} [description]
	             */
	            var colse = function colse() {
	                self._restoreColor();
	                //还原跟字体大小
	                self._adjustSize(defaultFontSize);
	                self.removeBox();
	                Xut.View.ShowToolBar('pageNumber');
	            };

	            //处理器
	            var process = {
	                htmlbox_close_container: colse,
	                htmlbox_close: colse,
	                htmlbox_small: function htmlbox_small() {
	                    change(sizeArray[0]);
	                },
	                htmlbox_middle: function htmlbox_middle() {
	                    change(sizeArray[1]);
	                },
	                htmlbox_big: function htmlbox_big() {
	                    change(sizeArray[2]);
	                }
	            };

	            //冒泡匹配按钮点击
	            this.start = function (e) {
	                var className = e.target.className;
	                process[className] && process[className]();
	            };

	            $$on(this.eventContext, {
	                start: this.start
	            });
	        }

	        /**
	         * 遍历p span文字标签 调整字体颜色
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_adjustColor',
	        value: function _adjustColor() {
	            this.textLabelArray = ['p', 'span'];
	            var self = this;
	            _.each(self.textLabelArray, function (text) {
	                _.each(self.$contentNode.find(text), function (el) {
	                    var formerColor = getComputedStyle(el).color;
	                    //若字体颜色为白色 调整为黑色
	                    if (whiteObject.hasOwnProperty(formerColor)) {
	                        el.hasFormerColor = true;
	                        el.style.color = "black";
	                    }
	                });
	            });
	        }

	        /**
	         * 调整字体大小
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_adjustSize',
	        value: function _adjustSize(value, save) {
	            value = parseInt(value);
	            docElement.style.fontSize = value + 'px';
	            save && $$set(this.storageName, value);
	        }

	        /**
	         * 恢复放大过的字体颜色
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_restoreColor',
	        value: function _restoreColor() {
	            var self = this;
	            _.each(self.textLabelArray, function (text) {
	                _.each(self.$contentNode.find(text), function (el) {
	                    //将字体由黑色恢复为白色
	                    if (el.hasFormerColor) {
	                        el.style.color = "white";
	                        el.hasFormerColor = false;
	                    }
	                });
	            });
	        }

	        /**
	         * 修正htmlbox位置
	         * @param  {[type]} iscrollName [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_relocateToolbar',
	        value: function _relocateToolbar(iscrollName) {
	            //修正模式2下屏幕溢出高度  
	            var viewSize = config.viewSize;
	            var left = viewSize.overflowWidth && Math.abs(viewSize.left) || 0;
	            var top = viewSize.overflowHeight && Math.abs(viewSize.top) || 0;
	            this.$htmlbox[0].style.cssText += "margin-top:" + top + "px";

	            //修正模式3下屏幕溢出宽度
	            //1.修正关闭按钮::before ::after伪元素left值 确保关闭按钮水平居中
	            //首先恢复到最开始的left:2%状态
	            document.styleSheets[0].addRule('.htmlbox_close::before', 'left:2%');
	            document.styleSheets[0].insertRule('.htmlbox_close::before { left:2% }', 0);
	            document.styleSheets[0].addRule('.htmlbox_close::after', 'left:2%');
	            document.styleSheets[0].insertRule('.htmlbox_close::after { left:2% }', 0);
	            var formerLeft = window.getComputedStyle(this.$htmlbox.find('.htmlbox_close')[0], '::before').getPropertyValue('left');
	            var currentLeft = parseInt(formerLeft) + left;

	            //开始修正
	            document.styleSheets[0].addRule('.htmlbox_close::before', 'left:' + currentLeft + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::before { left:' + currentLeft + 'px }', 0);
	            document.styleSheets[0].addRule('.htmlbox_close::after', 'left:' + currentLeft + 'px');
	            document.styleSheets[0].insertRule('.htmlbox_close::after { left:' + currentLeft + 'px }', 0);
	            //2.修正字体放大ul按钮
	            this.$htmlbox.find(".htmlbox_fontsizeUl")[0].style.cssText += "margin-right:" + left + "px";
	            //3.修正文本框
	            this.$htmlbox.find("." + iscrollName)[0].style.cssText += "margin-left:" + left + "px;";
	            var formerScrollWidth = window.getComputedStyle(this.$htmlbox.find("." + iscrollName)[0]).getPropertyValue('width');

	            var currentScrollWidth = parseInt(formerScrollWidth) - 2 * left;

	            this.$htmlbox.find("." + iscrollName).width(currentScrollWidth);
	        }

	        /**
	         * 卷滚
	         * @param  {[type]} iscrollName [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_createIscroll',
	        value: function _createIscroll($htmlbox, iscrollName) {
	            var ulHeight = $htmlbox.find('.' + iscrollName + ' >ul').css('height');
	            var htmlboxHeight = $htmlbox.find('.' + iscrollName).css('height');

	            //溢出，增加卷滚
	            if (parseInt(ulHeight) > parseInt(htmlboxHeight)) {
	                this.iscroll = new iScroll("." + iscrollName, {
	                    scrollbars: true,
	                    fadeScrollbars: true
	                });
	            }
	        }

	        /**
	         * 移除盒子
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'removeBox',
	        value: function removeBox() {
	            $$off(this.eventContext, {
	                start: this.start
	            });
	            this.$htmlbox && this.$htmlbox.remove();

	            if (this.iscroll) {
	                this.iscroll.destroy();
	                this.iscroll = null;
	            }
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            _.each(this.eventReference, function (off) {
	                off("tap");
	            });
	            this.removeBox();
	        }
	    }]);
	    return HtmlBox;
	}();

	function textBoxMixin (activitProto) {

	    /**
	     * 检测是HTML文本框处理
	     * @return {[type]} [description]
	    */
	    activitProto.htmlTextBox = function () {
	        var self = this;
	        var relatedData = this.relatedData;
	        var contentHtmlBoxIds = relatedData.contentHtmlBoxIds;
	        var contentId;
	        var contentName;
	        var $contentNode;
	        //文本框实例对象
	        //允许一个activity有多个
	        this.htmlBoxInstance = [];

	        //创建文本框对象
	        if (contentHtmlBoxIds.length && relatedData.contentDas) {
	            _.each(relatedData.contentDas, function (cds) {
	                if (~contentHtmlBoxIds.indexOf(cds._id)) {
	                    contentId = cds._id;
	                    contentName = self.makePrefix('Content', self.pid, contentId);
	                    //找到对应绑定事件的元素
	                    $contentNode = self.getContextNode(contentName);
	                    if (!$contentNode.attr("data-htmlbox")) {
	                        //构建html文本框对象
	                        self.htmlBoxInstance.push(new HtmlBox(contentId, $contentNode));
	                        //增加htmlbox标志去重
	                        //多个actictiy共享问题
	                        $contentNode.attr("data-htmlbox", "true");
	                    }
	                }
	            });
	        }
	    };
	}

	var icons = {
	    hide: 'images/icons/arrowDown.svg'
	};
	var sLineHeiht$1 = parseInt($('body').css('font-size')) || 16;
	var BOOKCACHE$1;
	//书签缓存

	function BookMark(options) {
	    this.parent = options.parent;
	    this.pageId = options.pageId;
	    this.seasonId = options.seasonId;
	    //是否已存储
	    this.isStored = false;
	    this.init();
	}

	/**
	 * 初始化
	 * @return {[type]} [description]
	 */
	BookMark.prototype.init = function () {
	    var $bookMark = this.createBookMark(),
	        dom = this.parent[0],
	        that = this;

	    this.parent.append($bookMark);
	    this.bookMarkMenu = $bookMark.eq(0);
	    //显示书签
	    setTimeout(function () {
	        that.restore();
	    }, 20);
	    //获取历史记录
	    BOOKCACHE$1 = this.getHistory();

	    //邦定用户事件
	    $$on(dom, {
	        end: this
	    });
	};

	/**
	 * 创建书签
	 * @return {[object]} [jquery生成的dom对象]
	 */
	BookMark.prototype.createBookMark = function () {

	    var sHeight = Xut.config.viewSize.height;

	    var height = sLineHeiht$1 * 3,
	        // menu的高为3em
	    box = '<div class="xut-bookmark-menu" style="width:100%;height:{0}px;left:0;top:{1}px;">' + '<div class="xut-bookmark-wrap">' + '<div class="xut-bookmark-add">加入书签</div>' + '<div class="xut-bookmark-off" style="background-image:url({2})"></div>' + '<div class="xut-bookmark-view">书签记录</div>' + '</div>' + '</div>' + '<div class="xut-bookmark-list" style="display:none;width:100%;height:{3}px;">' + '<ul class="xut-bookmark-head">' + '<li class="xut-bookmark-back">返回</li>' + '<li>书签</li>' + '</ul>' + '<ul class="xut-bookmark-body"></ul>' + '</div>';
	    box = String.format(box, height, sHeight, icons.hide, sHeight);
	    this.markHeight = height;
	    return $(box);
	};

	/**
	 * 生成书签列表
	 * @return {[type]} [description]
	 */
	BookMark.prototype.createMarkList = function () {
	    var tmp,
	        seasonId,
	        pageId,
	        list = '',
	        self = this;

	    //取历史记录
	    _.each(BOOKCACHE$1, function (mark) {
	        tmp = mark.split('-');
	        seasonId = tmp[0];
	        pageId = tmp[1];
	        mark = self.getMarkId(seasonId, pageId);
	        list += '<li><a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">第' + pageId + '页</a><a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a></li>';
	    });

	    return list;
	};

	/**
	 * 创建存储标签
	 * 存储格式 seasonId-pageId
	 * @return {string} [description]
	 */
	BookMark.prototype.getMarkId = function (seasonId, pageId) {
	    return seasonId + '-' + pageId;
	};

	/**
	 * 获取历史记录
	 * @return {[type]} [description]
	 */
	BookMark.prototype.getHistory = function () {
	    var mark = $$get('bookMark');
	    if (mark) {
	        return mark.split(',');
	    }
	    return [];
	};

	/**
	 * 添加书签
	 * @return {[type]} [description]
	 */
	BookMark.prototype.addBookMark = function () {
	    var key;

	    this.updatePageInfo();
	    key = this.getMarkId(this.seasonId, this.pageId);

	    //避免重复缓存
	    if (BOOKCACHE$1.indexOf(key) > -1) {
	        return;
	    }
	    BOOKCACHE$1.push(key);
	    $$set('bookMark', BOOKCACHE$1);
	};

	/**
	 * 更新页信息
	 *  针对母板层上的书签
	 */
	BookMark.prototype.updatePageInfo = function () {
	    var pageData = Xut.Presentation.GetPageData();
	    this.pageId = pageData._id;
	    this.seasonId = pageData.seasonId;
	};

	/**
	 * 删除书签
	 * @param {object} [key] [事件目标对象]
	 * @return {[type]} [description]
	 */
	BookMark.prototype.delBookMark = function (target) {
	    if (!target || !target.dataset) return;

	    var key = target.dataset.mark,
	        index = BOOKCACHE$1.indexOf(key);

	    BOOKCACHE$1.splice(index, 1);
	    $$set('bookMark', BOOKCACHE$1);

	    if (BOOKCACHE$1.length == 0) {
	        $$remove('bookMark');
	    }

	    //移除该行
	    $(target).parent().remove();
	};

	/**
	 * 显示书签
	 * @param {object} [target] [事件目标对象]
	 * @return {[type]} [description]
	 */
	BookMark.prototype.viewBookMark = function (target) {
	    var $bookMarkList,
	        list = this.createMarkList();

	    if (this.bookMarkList) {
	        $bookMarkList = this.bookMarkList;
	    } else {
	        $bookMarkList = $(target).parent().parent().next();
	    }
	    //更新书签内容
	    $bookMarkList.find('.xut-bookmark-body').html(list);
	    this.bookMarkList = $bookMarkList;
	    $bookMarkList.fadeIn();
	};

	/**
	 * 点击放大效果
	 * @param  {[object]} target [事件目标对象]
	 * @return {[type]}      [description]
	 */
	BookMark.prototype.iconManager = function (target) {
	    var $icon = this.bookMarkIcon = $(target),
	        restore = this.iconRestore;
	    console.log(Xut.style);
	    $icon.css({
	        'transform': 'scale(1.2)',
	        'transition-duration': '500ms'
	    })[0].addEventListener(Xut.style.transitionEnd, restore.bind(this), false);
	};

	/**
	 * 复原按钮
	 * @return {[type]} [description]
	 */
	BookMark.prototype.iconRestore = function () {
	    this.bookMarkIcon.css('transform', '');
	};

	/**
	 * 跳转到书签页
	 * @param  {[type]} target [description]
	 * @return {[type]}        [description]
	 */
	BookMark.prototype.goBookMark = function (target) {
	    if (!target || !target.dataset) return;

	    var key = target.dataset.mark.split('-'),
	        seasonId = Number(key[0]),
	        pageId = Number(key[1]);

	    this.updatePageInfo();
	    //关闭书签列表
	    this.backBookMark();

	    //忽略当前页的跳转
	    if (this.pageId == pageId && this.seasonId == seasonId) {
	        return;
	    }

	    Xut.View.LoadScenario({
	        'scenarioId': seasonId,
	        'chapterId': pageId
	    });
	};

	/**
	 * 书签回退键
	 * @return {[type]} [description]
	 */
	BookMark.prototype.backBookMark = function () {
	    this.bookMarkList.fadeOut();
	};

	/**
	 * 邦定事件
	 * @param  {[type]} evt [事件]
	 * @return {[type]}     [description]
	 */
	BookMark.prototype.handleEvent = function (evt) {
	    var target = evt.target;
	    switch (target.className) {
	        //加入书签
	        case 'xut-bookmark-add':
	            this.addBookMark();
	            this.iconManager(target);
	            break;
	        //显示书签记录
	        case 'xut-bookmark-view':
	            this.viewBookMark(target);
	            this.iconManager(target);
	            break;
	        //关闭书签
	        case 'xut-bookmark-off':
	            this.closeBookMark(target);
	            break;
	        //返回书签主菜单
	        case 'xut-bookmark-back':
	            this.backBookMark();
	            break;
	        //删除书签记录
	        case 'xut-bookmark-del':
	            this.delBookMark(target);
	            break;
	        //跳转到书签页
	        case 'xut-bookmark-id':
	            this.goBookMark(target);
	            break;
	        default:
	            //console.log(target.className)
	            break;
	    }
	};

	/**
	 * 关闭书签菜单
	 * @return {[type]} [description]
	 */
	BookMark.prototype.closeBookMark = function () {
	    this.bookMarkMenu.css({
	        transform: 'translate3d(0,0,0)',
	        'transition-duration': '1s'
	    });
	};

	/**
	 * 恢复书签菜单
	 */
	BookMark.prototype.restore = function () {
	    this.bookMarkMenu.css({
	        transform: 'translate3d(0,-' + this.markHeight + 'px,0)',
	        'transition-duration': '1s'
	    });
	};

	/**
	 * 销毁书签
	 * @return {[type]} [description]
	 */
	BookMark.prototype.destroy = function () {
	    var dom = this.parent[0];

	    dom.removeEventListener('touchend', this, false);
	    dom.removeEventListener('mouseup', this, false);

	    //菜单部分
	    if (this.bookMarkMenu) {
	        this.bookMarkMenu.remove();
	        this.bookMarkMenu = null;
	    }

	    //列表部分
	    if (this.bookMarkList) {
	        this.bookMarkList.remove();
	        this.bookMarkList = null;
	    }

	    //按钮效果
	    if (this.bookMarkIcon) {
	        this.bookMarkIcon[0].removeEventListener(Xut.plat.transitionEnd, this.iconRestore, false);
	        this.bookMarkIcon = null;
	    }

	    this.parent = null;
	};

	/**
	* 创建书签
	* @return {[type]} [description]
	*/
	function bookMarkMixin (activitProto) {

	    activitProto.createBookMark = function () {
	        var node, seasonId, pageId, pageData;
	        if (this.pageType === 'master') {
	            //模板取对应的页面上的数据
	            pageData = Xut.Presentation.GetPageData();
	            node = this.relatedData.floatMaters.container;
	            pageId = pageData._id;
	            seasonId = pageData.seasonId;
	        } else {
	            node = this.$containsNode;
	            seasonId = this.relatedData.seasonId;
	            pageId = this.pageId;
	        }
	        var options = {
	            parent: node,
	            seasonId: seasonId,
	            pageId: pageId
	        };

	        if (this.bookMark) {
	            //如果上次只是隐藏则可以恢复
	            this.bookMark.restore();
	        } else {
	            this.bookMark = new BookMark(options);
	        }
	    };
	}

	//图标
	var icons$1 = {
	    search: 'images/icons/search.svg',
	    clear: 'images/icons/clear.svg',
	    exit: 'images/icons/exit.svg'
	};

	function SearchBar(options) {
	    //父容器
	    this.parent = options.parent;
	    //提示信息
	    this.tips = options.tips;
	    this.init();
	}

	/**
	 * 初始化
	 * @return {[type]} [description]
	 */
	SearchBar.prototype.init = function () {
	    var $box = this.searchForm(),
	        dom = this.parent[0];

	    this.parent.append($box);
	    this.searchBox = $box;
	    this.resultBox = $box.find('.xut-search-result');
	    this.input = $box.find('.xut-search-input');
	    this.searchBtn = $box.find('.xut-search-btn');

	    //用户操作事件邦定
	    $$on(dom, {
	        end: this
	    });

	    //即时搜索
	    dom.addEventListener('keyup', this, false);
	};

	/**
	 * 创建搜索框
	 * @return {[object]} [jquery生成的dom对象]
	 */
	SearchBar.prototype.searchForm = function () {
	    var W = window.innerWidth * 0.3,
	        H = window.innerHeight;
	    var text = this.tips || '请在搜索框中输入要搜索的关键字';

	    var box = '<div class="xut-form-search">' + '<div class="xut-form-search-wrap">' + '<div style="height:17%;">' + '<div style="height:20%"></div>' + '<div class="xut-search-row">' + '<input type="text" class="xut-search-input">' + '<div class="xut-search-btn" style="background-image: url(' + icons$1.search + ')"></div>' + '</div>' + '<p class="xut-search-tips" style="line-height:' + Math.round(H * 0.06) + 'px">' + text + '</p>' + '</div>' + '<div style="height:76%">' + '<ul class="xut-search-result"></ul>' + '</div>' + '<div style="height:7%">' + '<div class="xut-search-exit" style="background-image: url(' + icons$1.exit + ')"></div>' + '</div>' + '</div></div>';

	    var $box = $(box);

	    $box.css('width', W < 200 ? 200 : W);

	    return $box;
	};

	/**
	 * 搜索
	 * @param {string} [keyword] [搜索关键字]
	 */
	SearchBar.prototype.search = function (keyword) {
	    var data = Xut.data.Chapter,
	        ln = data.length,
	        list = '',
	        rs,
	        pageId,
	        seasonId;

	    if (!keyword) {
	        this.resultBox.html('');
	        return;
	    }

	    for (var i = 0; i < ln; i++) {
	        rs = data.item(i);
	        if (rs.chapterTitle.indexOf(keyword) > -1) {
	            pageId = rs._id;
	            seasonId = rs.seasonId;
	            list += '<li><a class="xut-search-link" data-mark="' + seasonId + '-' + pageId + '" href="javascript:0">' + rs.chapterTitle + '</a></li>';
	        }
	    }

	    this.resultBox.html(list);
	};

	/**
	 * 切换搜索按钮图标
	 * @param  {[type]} icon [图标路径]
	 * @return {[type]}      [description]
	 */
	SearchBar.prototype.iconManager = function (icon) {
	    if (this.isChange) {
	        this.searchBtn.css('background-image', 'url(' + icon + ')');
	    }
	};

	/**
	 * 跳转到搜索结果页
	 * @param  {[type]} target [description]
	 * @return {[type]}        [description]
	 */
	SearchBar.prototype.searchLink = function (target) {
	    if (!target || !target.dataset) return;
	    var mark = target.dataset.mark.split('-'),
	        seasonId = mark[0],
	        pageId = mark[1];

	    Xut.View.LoadScenario({
	        'scenarioId': seasonId,
	        'chapterId': pageId
	    });
	};

	/**
	 * 邦定事件
	 * @param  {[type]} evt [事件]
	 * @return {[type]}     [description]
	 */
	SearchBar.prototype.handleEvent = function (evt) {
	    var target = evt.target;
	    switch (target.className) {
	        case 'xut-search-btn':
	            //点击搜索
	            this.search(this.input.val());
	            this.isChange = true;
	            this.iconManager(icons$1.clear);
	            break;
	        case 'xut-search-input':
	            //实时搜索
	            this.search(target.value);
	            //还原按钮图标
	            this.iconManager(icons$1.search);
	            this.isChange = false;
	            break;
	        case 'xut-search-exit':
	            //关闭搜索框
	            this.exit();
	            break;
	        case 'xut-search-link':
	            //跳转
	            this.searchLink(target);
	            break;
	        default:
	            break;
	    }
	};

	/**
	 * 关闭搜索框
	 * @return {[type]} [description]
	 */
	SearchBar.prototype.exit = function () {
	    this.input.val('');
	    this.resultBox.empty();
	    this.searchBox.hide();
	};

	/**
	 * 恢复搜索框
	 */
	SearchBar.prototype.restore = function () {
	    var searchBox = this.searchBox;
	    searchBox && searchBox.show();
	};

	/**
	 * 销毁搜索框
	 * @return {[type]} [description]
	 */
	SearchBar.prototype.destroy = function () {
	    var dom = this.parent[0];
	    dom.removeEventListener('keyup', this, false);
	    dom.removeEventListener('touchend', this, false);
	    dom.removeEventListener('mouseup', this, false);

	    this.searchBox.remove();
	    this.searchBox = null;
	    this.resultBox = null;
	    this.searchBtn = null;
	    this.input = null;
	    this.parent = null;
	};

	/**
	 * 创建搜索框
	 * @return {[type]} [description]
	 */

	function searchBarMixin (activitProto) {

	    activitProto.createSearchBar = function () {
	        var options = {
	            parent: this.$containsNode
	        };
	        if (this.searchBar) {
	            //如果上次只是隐藏则可以恢复
	            this.searchBar.restore();
	        } else {
	            this.searchBar = new SearchBar(options);
	        }
	    };
	}

	/**
	 * 音频动作
	 * @param  {[type]} global [description]
	 * @return {[type]}        [description]
	 */

	//音频动作
	//替换背景图
	//指定动画
	function Action(options) {

	    var audioNode = document.querySelector('#Audio_' + options.audioId);

	    //页面从属
	    var pageType = audioNode.getAttribute('data-belong');

	    //切换背景
	    function toggle(linker) {
	        audioNode.style.backgroundImage = 'url(' + Xut.config.pathAddress + linker + ')';
	    }

	    function run(ids) {
	        ids = ids.split(',');
	        Xut.Assist.Run(pageType, ids);
	    }

	    function stop(ids) {
	        ids = ids.split(',');
	        Xut.Assist.Stop(pageType, ids);
	    }
	    return {
	        play: function play() {
	            options.startImg && toggle(options.startImg);
	            options.startScript && run(options.startScript);
	        },
	        pause: function pause() {
	            options.stopImg && toggle(options.stopImg);
	            options.stopScript && stop(options.startScript);
	        },
	        destroy: function destroy() {
	            audioNode = null;
	        }
	    };
	}

	/**
	 * 音频字幕
	 * @param  {[type]} global [description]
	 * @return {[type]}        [description]
	 */
	//字幕检测时间
	var Interval = 50;

	var getStyles = function getStyles(elem, name) {
	    var styles = elem.ownerDocument.defaultView.getComputedStyle(elem, null);
	    return styles.getPropertyValue(name);
	};

	/**
	 * 字幕类
	 *   音频实例
	 * options 参数
	 */

	var Subtitle = function () {
	    function Subtitle(options, controlDoms, getAudioTime) {
	        classCallCheck(this, Subtitle);


	        var visibility = void 0;
	        var orgAncestorVisibility = void 0;

	        //快速处理匹配数据
	        var checkData = {};

	        this.getAudioTime = getAudioTime;
	        this.options = options;
	        this.parents = controlDoms.parents;
	        this.ancestors = controlDoms.ancestors;

	        this.timer = 0;

	        //缓存创建的div节点
	        this.cacheCreateDivs = {};

	        //保存原始的属性
	        orgAncestorVisibility = this.orgAncestorVisibility = {};
	        _.each(this.ancestors, function (node, cid) {
	            visibility = getStyles(node, 'visibility');
	            if (visibility) {
	                orgAncestorVisibility[cid] = visibility;
	            }
	        });

	        //去重记录
	        this.recordRepart = {};

	        //phonegap getCurrentPosition得到的音频播放位置不从0开始 记录起始位置
	        this.changeValue = 0;

	        _.each(options.subtitles, function (data) {
	            checkData[data.start + '-start'] = data;
	            checkData[data.end + '-end'] = data;
	        });

	        this.createSubtitle(checkData);
	    }

	    /**
	     * 运行字幕
	     * @return {[type]}
	     */


	    createClass(Subtitle, [{
	        key: 'createSubtitle',
	        value: function createSubtitle(checkData) {
	            var _this = this;

	            var getAudioTime = this.getAudioTime;
	            var options = this.options;

	            /**
	             * 准备创建字幕
	             * @param  {[type]} audioTime [description]
	             * @return {[type]}           [description]
	             */
	            var createAction = function createAction(audioTime) {
	                var match = void 0;
	                _.each(checkData, function (data, key) {
	                    match = key.split('-');
	                    //创建动作
	                    _this.action(match[0], audioTime, match[1], data);
	                });
	                _this.createSubtitle(checkData);
	            };

	            /**
	             * 判断不同的播放平台
	             * @return {[type]} [description]
	             */
	            var JudgePlat = function JudgePlat() {
	                getAudioTime(function (audioTime) {
	                    createAction(audioTime);
	                });
	            };

	            this.timer = setTimeout(function () {
	                JudgePlat();
	            }, Interval);
	        }

	        //执行动作
	        //创建文本框
	        //显示/隐藏

	    }, {
	        key: 'action',
	        value: function action(currentTime, audioTime, _action, data) {
	            if (audioTime > currentTime - Interval && audioTime < currentTime + Interval) {
	                //创建
	                if (!this.recordRepart[data.start] && _action === 'start') {
	                    this.recordRepart[data.start] = true;
	                    //创建字幕dom
	                    this.createDom(data);

	                    //如果是一段字幕结束处理
	                } else if (!this.recordRepart[data.end] && _action === 'end') {
	                    this.recordRepart[data.end] = true;
	                    // //隐藏
	                    var ancestorNode = this.ancestors[data.id];
	                    if (ancestorNode) {
	                        ancestorNode.style.visibility = "hidden";
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'createDom',
	        value: function createDom(data) {

	            var config = Xut.config;

	            //屏幕分辨率
	            var proportion = config.proportion;
	            var proportionWidth = proportion.width;
	            var proportionHeight = proportion.height;

	            var cid = data.id;
	            var parentNode = this.parents[cid];
	            var ancestorNode = this.ancestors[cid];
	            var preDiv = this.cacheCreateDivs[cid];
	            var preP = preDiv && preDiv.children[0];

	            //缩放
	            var sTop = data.top * proportion.top;
	            var sLeft = data.left * proportion.left;
	            var sHeight = data.height * proportion.height;
	            var sWidth = data.width * proportion.width;

	            //转换行高
	            var sLineHeight = data.lineHeight ? data.lineHeight : '100%';

	            //公用同一个contengid,已经存在
	            if (preDiv) {
	                createContent(preDiv, preP, data);
	            } else {
	                //创建父元素与子元素
	                var createDiv = document.createElement('div');
	                var createP = document.createElement('p');
	                //设置样式
	                createContent(createDiv, createP, data);
	                createDiv.appendChild(createP); //添加到指定的父元素  

	                parentNode.appendChild(createDiv);

	                //保存引用
	                this.cacheCreateDivs[cid] = createDiv;
	            }

	            //创建内容
	            function createContent(parent, p, data) {
	                createDivStyle(parent, data); //设置div
	                createPStyle(p, data);
	            }

	            //设置父容器div 字体颜色，大小，类型，位置，文本水平、垂直居中
	            function createDivStyle(parent, data) {
	                var cssText = 'position       :absolute; ' + 'display        :table;' + 'vertical-align :center;' + 'top            :{0}px;' + 'left           :{1}px;' + 'height         :{2}px;' + 'width          :{3}px;';

	                parent.style.cssText = String.format(cssText, sTop, sLeft, sHeight, sWidth);
	            }

	            //内容元素的样式
	            function createPStyle(p, data) {

	                var cssText = ' text-align     :center;' + ' display        :table-cell;' + ' vertical-align :middle;' + ' color          :{0};' + ' font-family    :{1};' + ' font-bold      :{2};' + ' font-size      :{3}px;' + ' line-height    :{4}%';

	                //设置字体间距
	                p.style.cssText = String.format(cssText, data.fontColor, data.fontName, data.fontBold, data.fontSize * proportionWidth, sLineHeight);
	                //设置文字内容
	                p.innerHTML = data.title;
	            }

	            //操作最外层的content节点
	            if (ancestorNode) {
	                var ancestorNodeValue = getStyles(ancestorNode, 'visibility');
	                if (ancestorNodeValue != 'visible') {
	                    ancestorNode.style.visibility = 'visible';
	                }
	            }
	        }

	        /**
	         * 清理音频
	         * @return {[type]}
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var self = this;
	            _.each(this.cacheCreateDivs, function (node) {
	                node.parentNode.removeChild(node);
	            });
	            //恢复初始状态
	            _.each(this.ancestors, function (node, id) {
	                var orgValue = self.orgAncestorVisibility[id];
	                var currValue = getStyles(node, 'visibility');
	                if (currValue != orgValue) {
	                    node.style.visibility = orgValue;
	                }
	            });

	            this.ancestors = null;
	            this.cacheCreateDivs = null;
	            this.changeValue = 0;
	            this.parents = null;
	            if (this.timer) {
	                clearTimeout(this.timer);
	                this.timer = 0;
	            }
	        }
	    }]);
	    return Subtitle;
	}();

	/**
	 * 音频工厂类
	 * @param {[type]} options [description]
	 */
	var BaseClass = function () {
	    function BaseClass() {
	        classCallCheck(this, BaseClass);
	    }

	    //构建之前关数据


	    createClass(BaseClass, [{
	        key: 'preRelated',
	        value: function preRelated(trackId, options) {
	            //完成end后 外部回调删除这个对象
	            //单独调用引用对象
	            //传递一个 options.complete
	            this.innerCallback = options.innerCallback;
	            //仅运行一次
	            //外部调用
	            this.outerCallback = trackId == 9999 ? options.complete : null;
	        }

	        //构建之后关数据

	    }, {
	        key: 'afterRelated',
	        value: function afterRelated(options, controlDoms) {
	            var _this = this;

	            //音频重复播放次数
	            if (options.data && options.data.repeat) {
	                this.repeat = Number(options.data.repeat); //需要重复
	            }
	            //音频动作
	            if (options.action) {
	                this.acitonObj = Action(options);
	            }
	            //字幕对象
	            if (options.subtitles && options.subtitles.length > 0) {
	                //创建字幕对象
	                this.subtitleObject = new Subtitle(options, controlDoms, function (cb) {
	                    return _this.getAudioTime(cb);
	                });
	            }

	            //如果有外部回调处理
	            if (this.outerCallback) {
	                this.outerCallback.call(this);
	            }
	        }

	        //运行成功失败后处理方法
	        //phoengap会调用callbackProcess
	        //导致乱了

	    }, {
	        key: 'callbackProcess',
	        value: function callbackProcess(sysCommand) {
	            if (this.outerCallback) {
	                //外部调用结束
	                this.end();
	            } else {
	                //安卓没有重复播放
	                //phonegap未处理
	                if (!Xut.plat.isAndroid && this.repeat) {
	                    //如果需要重复
	                    this.repeatProcess();
	                } else {
	                    //外部清理对象
	                    //audioManager中直接删当前对象
	                    this.innerCallback(this);
	                }
	            }
	        }

	        //重复处理

	    }, {
	        key: 'repeatProcess',
	        value: function repeatProcess() {
	            --this.repeat;
	            this.play();
	        }

	        //播放

	    }, {
	        key: 'play',
	        value: function play() {
	            //flash模式不执行
	            if (this.audio && !this.isFlash) {
	                this.status = 'playing';
	                this.audio.play();
	            }
	            this.acitonObj && this.acitonObj.play();
	        }

	        //停止

	    }, {
	        key: 'pause',
	        value: function pause() {
	            this.status = 'paused';
	            this.audio.pause();
	            this.acitonObj && this.acitonObj.pause();
	        }

	        //销毁

	    }, {
	        key: 'end',
	        value: function end() {
	            this.status = 'ended';
	            this.audio.end();
	            this.audio = null;
	            this.acitonObj && this.acitonObj.destroy();
	        }

	        //相关

	    }, {
	        key: 'destroyRelated',
	        value: function destroyRelated() {
	            //销毁字幕
	            if (this.subtitleObject) {
	                this.subtitleObject.destroy();
	                this.subtitleObject = null;
	            }
	            //动作
	            if (this.acitonObj) {
	                this.acitonObj.destroy();
	                this.acitonObj = null;
	            }
	        }
	    }]);
	    return BaseClass;
	}();

	/**
	 * audio对象下标
	 * @type {Number}
	 */
	var index = 0;
	var loop = 5;
	var audioes = [];

	/**
	 * 修复audio
	 * @param  {[type]} obj    [description]
	 * @param  {[type]} key    [description]
	 * @param  {[type]} access [description]
	 * @return {[type]}        [description]
	 */
	function fixAudio(obj, key, access) {
	    var start = function start() {
	        var audio = void 0,
	            i = void 0;
	        for (i = 0; i < loop; i++) {
	            audio = new Audio();
	            audio.play();
	            audioes.push(audio);
	        }
	        $$off(document, { start: start });
	    };
	    $$on(document, { start: start });
	}

	/**
	 * 销毁创建的video对象
	 * @return {[type]} [description]
	 */
	function destroyFixAudio() {
	    for (var i = 0; i < audioes.length; i++) {
	        audioes[i] = null;
	    }
	    audioes = null;
	}

	function hasAudioes() {
	    return audioes.length;
	}

	function getAudio() {
	    var audio = audioes[index++];
	    if (!audio) {
	        index = 0;
	        return getAudio();
	    }
	    return audio;
	}

	var instance = hash(); //存放不同音轨的一个实例
	var audioPlayer = void 0;
	var plat$2 = Xut.plat;

	var UUIDcreatePart = function UUIDcreatePart(length) {
	    var uuidpart = "";
	    var uuidchar = void 0;
	    for (var i = 0; i < length; i++) {
	        uuidchar = parseInt(Math.random() * 256, 10).toString(16);
	        if (uuidchar.length == 1) {
	            uuidchar = "0" + uuidchar;
	        }
	        uuidpart += uuidchar;
	    }
	    return uuidpart;
	};

	var createUUID = function createUUID() {
	    return [4, 2, 2, 2, 6].map(UUIDcreatePart).join('-');
	};

	/**
	 * 使用PhoneGap的Media播放
	 * @param  {string} url 路径
	 * @return {[type]}      [description]
	 */

	var _Media = function (_BaseClass) {
	    inherits(_Media, _BaseClass);

	    function _Media(options, controlDoms) {
	        classCallCheck(this, _Media);

	        var _this = possibleConstructorReturn(this, (_Media.__proto__ || Object.getPrototypeOf(_Media)).call(this));

	        var url = config.audioPath() + options.url,
	            trackId = options.trackId,
	            self = _this,
	            audio;

	        //构建之前处理
	        _this.preRelated(trackId, options);

	        //音频成功与失败调用
	        audio = new window.GLOBALCONTEXT.Media(url, function () {
	            self.callbackProcess(true);
	        }, function () {
	            self.callbackProcess(true);
	        });

	        //autoplay
	        _this.audio = audio;
	        _this.trackId = trackId;
	        _this.options = options;

	        //相关数据
	        _this.afterRelated(options, controlDoms);

	        _this.play();
	        return _this;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    createClass(_Media, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            var _this2 = this;

	            this.audio.getCurrentPosition(function (position) {
	                var audioTime = void 0;
	                position = position * 1000;
	                if (!_this2.changeValue) {
	                    _this2.changeValue = position;
	                }
	                position -= _this2.changeValue;
	                if (position > -1) {
	                    audioTime = Math.round(position);
	                }
	                callback(audioTime);
	            }, function (e) {
	                console.log("error:" + e);
	                //出错继续检测
	                callback();
	            });
	        }

	        /**
	         * 取反
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.release();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);
	    return _Media;
	}(BaseClass);

	/**
	 * 采用Falsh播放
	 * @type {[type]}
	 */


	var _Flash = function (_BaseClass2) {
	    inherits(_Flash, _BaseClass2);

	    function _Flash(options, controlDoms) {
	        classCallCheck(this, _Flash);

	        var _this3 = possibleConstructorReturn(this, (_Flash.__proto__ || Object.getPrototypeOf(_Flash)).call(this));

	        var trackId = options.trackId,
	            url = config.audioPath() + options.url,
	            self = _this3,
	            audio;

	        //构建之前处理
	        _this3.preRelated(trackId, options);

	        audio = new Audio5js({
	            swf_path: './lib/data/audio5js.swf',
	            throw_errors: true,
	            format_time: true,
	            ready: function ready(player) {
	                this.load(url);
	                //如果调用了播放
	                this.play();
	                self.status = "playing";
	            }
	        });

	        _this3.audio = audio;
	        _this3.trackId = trackId;
	        _this3.status = 'playing';
	        _this3.options = options;

	        _this3.isFlash = true;

	        //相关数据
	        _this3.afterRelated(options, controlDoms);
	        return _this3;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    createClass(_Flash, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.audio.audio.currentTime * 1000));
	        }
	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.destroy();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);
	    return _Flash;
	}(BaseClass);

	/**
	 * 采用_Audio5js播放
	 * @type {[type]}
	 */


	var _Audio5js = function (_BaseClass3) {
	    inherits(_Audio5js, _BaseClass3);

	    function _Audio5js(options, controlDoms) {
	        classCallCheck(this, _Audio5js);

	        var _this4 = possibleConstructorReturn(this, (_Audio5js.__proto__ || Object.getPrototypeOf(_Audio5js)).call(this));

	        var trackId = options.trackId,
	            url = config.audioPath() + options.url,
	            self = _this4,
	            audio;

	        //构建之前处理
	        _this4.preRelated(trackId, options);

	        audio = new Audio5js({
	            ready: function ready(player) {
	                this.load(url);
	                //如果调用了播放
	                this.play();
	                self.status = "playing";
	            }
	        });

	        _this4.audio = audio;
	        _this4.trackId = trackId;
	        _this4.status = 'playing';
	        _this4.options = options;

	        //相关数据
	        _this4.afterRelated(options, controlDoms);
	        return _this4;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    createClass(_Audio5js, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.audio.audio.currentTime * 1000));
	        }
	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.destroy();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);
	    return _Audio5js;
	}(BaseClass);

	/**
	 * 使用html5的audio播放
	 * @param  {string} url    音频路径
	 * @param  {object} options 可选参数
	 * @return {object}         [description]
	 */


	var _Audio = function (_BaseClass4) {
	    inherits(_Audio, _BaseClass4);

	    function _Audio(options, controlDoms) {
	        classCallCheck(this, _Audio);

	        var _this5 = possibleConstructorReturn(this, (_Audio.__proto__ || Object.getPrototypeOf(_Audio)).call(this));

	        var trackId = options.trackId;
	        var url = config.audioPath() + options.url;
	        var audio = void 0;
	        var self = _this5;

	        var hasAudio = hasAudioes();

	        //构建之前处理
	        _this5.preRelated(trackId, options);

	        if (instance[trackId]) {
	            audio = hasAudio ? getAudio() : instance[trackId];
	            audio.src = url;
	        } else {
	            if (hasAudio) {
	                audio = getAudio();
	                audio.src = url;
	            } else {
	                audio = new Audio(url);
	                //更新音轨
	                //妙妙学方式不要音轨处理
	                instance[trackId] = audio;
	            }
	        }

	        _this5._callback = function () {
	            self.callbackProcess();
	        };

	        _this5._throughCallback = function () {
	            self.play();
	        };

	        /**
	         * safari 自动播放
	         * 手机浏览器需要加
	         * 2016.8.26
	         * @type {Boolean}
	         */
	        audio.autoplay = true;

	        audio.addEventListener('canplaythrough', _this5._throughCallback, false);
	        audio.addEventListener('ended', _this5._callback, false);
	        audio.addEventListener('error', _this5._callback, false);

	        _this5.audio = audio;
	        _this5.trackId = trackId;
	        _this5.status = 'playing';
	        _this5.options = options;

	        //相关数据
	        _this5.afterRelated(options, controlDoms);
	        return _this5;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    createClass(_Audio, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.currentTime * 1000));
	        }
	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.pause();
	                this.audio.removeEventListener('canplaythrough', this._throughCallback, false);
	                this.audio.removeEventListener('ended', this._callback, false);
	                this.audio.removeEventListener('error', this._callback, false);
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);
	    return _Audio;
	}(BaseClass);

	/**
	 * 使用PhoneGap的 js直接调用 cordova Media播放
	 * @param  {string} url 路径
	 * @return {[type]}      [description]
	 */


	var _cordovaMedia = function (_BaseClass5) {
	    inherits(_cordovaMedia, _BaseClass5);

	    function _cordovaMedia(options, controlDoms) {
	        classCallCheck(this, _cordovaMedia);

	        var _this6 = possibleConstructorReturn(this, (_cordovaMedia.__proto__ || Object.getPrototypeOf(_cordovaMedia)).call(this));

	        var url = config.audioPath() + options.url,
	            trackId = options.trackId,
	            self = _this6,
	            audio;

	        _this6.id = createUUID();

	        //构建之前处理
	        _this6.preRelated(trackId, options);

	        var audio = {
	            startPlayingAudio: function startPlayingAudio() {
	                window.audioHandler.startPlayingAudio(self.id, url);
	            },
	            pausePlayingAudio: function pausePlayingAudio() {
	                window.audioHandler.pausePlayingAudio(self.id);
	            },
	            release: function release() {
	                window.audioHandler.release(self.id);
	            },
	            /**
	             * 扩充，获取位置
	             * @return {[type]} [description]
	             */
	            expansionCurrentPosition: function expansionCurrentPosition() {
	                return window.getCurrentPosition(self.id);
	            }
	        };

	        //autoplay
	        _this6.audio = audio;
	        _this6.trackId = trackId;
	        _this6.options = options;

	        //相关数据
	        _this6.afterRelated(options, controlDoms);

	        _this6.play();
	        return _this6;
	    }

	    /**
	     * Compatible with asynchronous
	     * for subitile use
	     * get audio
	     * @return {[type]} [description]
	     */


	    createClass(_cordovaMedia, [{
	        key: 'getAudioTime',
	        value: function getAudioTime(callback) {
	            callback(Math.round(this.audio.expansionCurrentPosition() * 1000));
	        }

	        //播放

	    }, {
	        key: 'play',
	        value: function play() {
	            if (this.audio) {
	                this.status = 'playing';
	                this.audio.startPlayingAudio();
	            }
	            this.acitonObj && this.acitonObj.play();
	        }

	        //停止

	    }, {
	        key: 'pause',
	        value: function pause() {
	            this.status = 'paused';
	            this.audio && this.audio.pausePlayingAudio();
	            this.acitonObj && this.acitonObj.pause();
	        }

	        //结束

	    }, {
	        key: 'end',
	        value: function end() {
	            if (this.audio) {
	                this.audio.release();
	                this.audio = null;
	            }
	            this.status = 'ended';
	            this.destroyRelated();
	        }
	    }]);
	    return _cordovaMedia;
	}(BaseClass);

	//安卓客户端apk的情况下


	if (plat$2.isAndroid && !plat$2.isBrowser) {
	    audioPlayer = _Media;
	} else {
	    //妙妙学的 客户端浏览器模式
	    if (window.MMXCONFIG && window.audioHandler) {
	        audioPlayer = _cordovaMedia;
	    } else {
	        audioPlayer = _Audio;
	    }
	    //2015.12.23
	    //如果不支持audio改用flash
	    // supportAudio(function() {
	    //     Xut.Audio = Flash;
	    // });
	}

	function eventMixin (activitProto) {

	    /**
	     * 构建事件体系
	     * @return {[type]} [description]
	     */
	    activitProto.fillEventData = function () {

	        //配置事件节点
	        var eventId,
	            pid,
	            contentName,

	        //事件上下文对象
	        eventContext,
	            eventData = this.eventData;

	        pid = this.pid;

	        //如果存在imageIds才处理,单独绑定事件处理
	        if (eventId = eventData.eventContentId) {

	            //dom
	            //找到对应绑定事件的元素
	            var domEvent = function domEvent() {
	                contentName = this.makePrefix('Content', pid, this.id);
	                eventData.type = 'dom';
	                eventData.canvasMode = false;
	                eventData.domMode = true;
	            };

	            //canvas模式非常特别
	            //canvas容器+内部pixi对象
	            //所以事件绑定在最外面
	            var canvasEvent = function canvasEvent() {
	                contentName = this.makePrefix('canvas', pid, this.id);
	                eventData.type = 'canvas';
	                eventData.canvasMode = true;
	                eventData.domMode = false;
	            };

	            //canvas事件
	            if (-1 !== this.canvasRelated.cid.indexOf(eventId)) {
	                canvasEvent.call(this);
	            } else {
	                //dom事件
	                domEvent.call(this);
	            }

	            eventContext = this.getContextNode(contentName);
	            eventData.eventContext = eventContext;

	            if (eventContext) {
	                /**
	                 * 绑定事件加入到content钩子
	                 */
	                this.relatedCallback.contentsHooks(pid, eventId, {
	                    $contentNode: eventContext,
	                    //增加外部判断
	                    isBindEventHooks: true,
	                    type: eventData.type
	                });
	            } else {
	                /**
	                 * 针对动态事件处理
	                 * 快捷方式引用到父对象
	                 * @type {[type]}
	                 */
	                eventData.parent = this;
	            }
	        }

	        /**
	         * 解析出事件类型
	         */
	        eventData.eventName = conversionEventType(eventData.eventType);
	    };

	    /**
	     * 绑定事件行为
	     * @return {[type]} [description]
	     */
	    activitProto.bindEventBehavior = function (callback) {
	        var self = this,
	            eventData = this.eventData,
	            eventName = eventData.eventName,
	            eventContext = eventData.eventContext;

	        /**
	         * 运行动画
	         * @return {[type]} [description]
	         */
	        var startRunAnim = function startRunAnim() {
	            //当前事件对象没有动画的时候才能触发关联动作
	            var animOffset,
	                boundary = 5; //边界值

	            if (eventData.domMode && (animOffset = eventContext.prop('animOffset'))) {
	                var originalLeft = animOffset.left;
	                var originalTop = animOffset.top;
	                var newOffset = eventContext.offset();
	                var newLeft = newOffset.left;
	                var newTop = newOffset.top;
	                //在合理的动画范围是允许点击的
	                //比如对象只是一个小范围的内的改变
	                //正负10px的移动是允许接受的
	                if (originalLeft > newLeft - boundary && originalLeft < newLeft + boundary || originalTop > newTop - boundary && originalTop < newTop + boundary) {
	                    self.runAnimation();
	                }
	            } else {
	                self.runAnimation();
	            }
	        };

	        /**
	         * 设置按钮的行为
	         * 音频
	         * 反弹
	         */
	        var setBehavior = function setBehavior(feedbackBehavior) {

	            var behaviorSound;
	            //音频地址
	            if (behaviorSound = feedbackBehavior.behaviorSound) {

	                var createAuido = function createAuido() {
	                    return new audioPlayer({
	                        url: behaviorSound,
	                        trackId: 9999,
	                        complete: function complete() {
	                            this.play();
	                        }
	                    });
	                };
	                //妙妙学客户端强制删除
	                if (window.MMXCONFIG && window.audioHandler) {
	                    self._fixAudio.push(createAuido());
	                } else {
	                    createAuido();
	                }
	            }
	            //反弹效果
	            if (feedbackBehavior.isButton) {
	                //div通过css实现反弹
	                if (eventData.domMode) {
	                    eventContext.addClass('xut-behavior');
	                    setTimeout(function () {
	                        eventContext.removeClass('xut-behavior');
	                        startRunAnim();
	                    }, 500);
	                } else {
	                    console.log('feedbackBehavior');
	                }
	            } else {
	                startRunAnim();
	            }
	        };

	        /**
	         * 事件引用钩子
	         * 用户注册与执行
	         * @type {Object}
	         */
	        var eventDrop = {
	            //保存引用,方便直接销毁
	            init: function init(drag) {
	                eventData.dragDrop = drag;
	            },
	            //拖拽开始的处理
	            startRun: function startRun() {},
	            //拖拽结束的处理
	            stopRun: function stopRun(isEnter) {
	                if (isEnter) {
	                    //为true表示拖拽进入目标对象区域
	                    self.runAnimation();
	                }
	            }
	        };

	        /**
	         * 正常动画执行
	         * 除去拖动拖住外的所有事件
	         * 点击,双击,滑动等等....
	         * @return {[type]} [description]
	         */
	        var eventRun = function eventRun() {
	            //如果存在反馈动作
	            //优先于动画执行
	            var feedbackBehavior;
	            if (feedbackBehavior = eventData.feedbackBehavior[eventData.eventContentId]) {
	                setBehavior(feedbackBehavior);
	            } else {
	                startRunAnim();
	            }
	        };

	        /**
	         * 事件对象引用
	         * @return {[type]} [description]
	         */
	        var eventHandler = function eventHandler(eventReference, _eventHandler) {
	            eventData.eventReference = eventReference;
	            eventData.eventHandler = _eventHandler;
	        };

	        //绑定用户自定义事件
	        if (eventContext && eventName) {

	            var domName, target, dragdropPara;

	            dragdropPara = eventData.dragdropPara;

	            //获取拖拽目标对象
	            if (eventName === 'dragTag') {
	                domName = this.makePrefix('Content', this.pid, dragdropPara);
	                target = this.getContextNode(domName);
	            }

	            //增加事件绑定标示
	            //针对动态加载节点事件的行为过滤
	            eventData.isBind = true;

	            bindContentEvent({
	                'eventDrop': eventDrop,
	                'eventRun': eventRun,
	                'eventHandler': eventHandler,
	                'eventContext': eventContext,
	                'eventName': eventName,
	                'parameter': dragdropPara,
	                'target': target,
	                'domMode': eventData.domMode
	            });
	        }
	    };
	}

	var _class$1 = function () {
	    function _class(data, options) {
	        classCallCheck(this, _class);

	        this.data = data;

	        //精灵动画类型 默认为高级精灵动画true 简单转复杂为false
	        this.animationType = true;

	        //高级精灵动画
	        if (options.type == 'seniorSprite') {
	            this.contentPrefix = options.contentPrefix;
	            this.obj = $("#" + this.contentPrefix + this.data.framId);
	            this.resourcePath = options.resourcePath;
	        }
	        //简单精灵强制转换复杂精灵动画
	        else {
	                this.animationType = false;
	                this.contentId = options.contentId;
	                this.obj = $(options.ele);
	                this.resourcePath = config.pathAddress + options.resourcePath + "/";
	            }

	        //是否有蒙版图
	        //resType:1没有蒙版 0：有蒙版
	        this.isMask = false;

	        this.curFPS = 0;
	        this.loop = 1;
	        this.resetCount = 0;

	        var params = this.data.params;
	        var action = this.action = params["actList"].split(",")[0];
	        var pa = params[action];
	        this.FPS = parseInt(pa.fps);
	        this.playerType = pa.playerType;

	        //isSports:0非运动状态 isSports:1运动状态
	        this.isSports = parseInt(pa.isSports);
	        this.originalImageList = pa.ImageList;

	        this.totalFPS = this.originalImageList.length;
	        this._imgArray = [];
	        this.sprObj = null;

	        if (this.playerType == "loop") {
	            this.loop = 0;
	        }

	        this._init();
	    }

	    /**
	     * 初始化
	     * @return {[type]} [description]
	     */


	    createClass(_class, [{
	        key: '_init',
	        value: function _init() {
	            this._initImage();

	            //判断是否运动状态
	            if (this.isSports) {
	                //初始化位置信息
	                this._initPosition();
	            }
	            //初始化结构
	            this._initStructure();
	        }

	        /**
	         * 检查是否可以运行
	         * 第一次预加载必须先结束
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_checkNextAction',
	        value: function _checkNextAction(task) {
	            if (this._initImageState) {
	                task();
	            } else {
	                this._waitTask = [];
	                this._waitTask.push(task);
	            }
	        }

	        /**
	         * 初始化qualified张图片
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initImage',
	        value: function _initImage() {
	            var _this = this;

	            var i = 0;
	            var qualified = 10;
	            var count = this.qualified = this.totalFPS >= qualified ? qualified : this.totalFPS;
	            var collect = function () {
	                return function () {
	                    if (count == 1) {
	                        _this._initImageState = true;
	                        if (_this._waitTask && _this._waitTask.length) {
	                            _this._waitTask.pop()();
	                        }
	                    } else {
	                        count--;
	                    }
	                };
	            }();

	            for (i; i < this.qualified; i++) {
	                this._preloadImage(i, collect);
	            }
	        }

	        /**
	         * 初始化位置信息
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initPosition',
	        value: function _initPosition() {
	            var obj = this.obj;
	            var params = this.data.params;
	            var action = this.action;
	            this.startPoint = {
	                x: this.originalImageList[0].X,
	                y: this.originalImageList[0].Y,
	                w: parseInt(params[action].width),
	                h: parseInt(params[action].height)
	            };
	            this.xRote = parseInt(obj.css("width")) / this.startPoint.w;
	            this.yRote = parseInt(obj.css("height")) / this.startPoint.h;
	            this.startLeft = parseInt(obj.css("left"));
	            this.startTop = parseInt(obj.css("top"));
	        }

	        /**
	         * 初始化结构
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initStructure',
	        value: function _initStructure() {
	            var obj = this.obj;
	            var framId = void 0;
	            var resourcePath = this.resourcePath;
	            var html = '';

	            // if (this.animationType) {
	            //     framId = this.data.framId
	            // } else {
	            //     let contentId = this.contentId;
	            //     framId = contentId + '_' + this.data.framId
	            // }

	            if (this.isMask) {
	                var filename = this._getFilename(this.originalImageList[0].name);
	                var maskUrl = resourcePath + filename;
	                html = '<div style="width:100%;height:100%;\n                             background: url(' + maskUrl + '.jpg) no-repeat;\n                             background-size: 100% 100%;\n                             -webkit-mask: url(' + maskUrl + '.png) no-repeat;\n                             -webkit-mask-size: 100% 100%;\'>\n                </div>';
	                this.sprObj = $(String.styleFormat(html));
	                obj.append(this.sprObj);
	            } else {
	                var src = resourcePath + this.originalImageList[0].name;
	                html = '<img src="' + src + '" style="width:100%;height:100%;"/>';

	                this.sprObj = $(String.styleFormat(html));
	                obj.html(this.sprObj);
	            }
	        }

	        /**
	         * 获取文件名
	         * @param  {[type]} name [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: '_getFilename',
	        value: function _getFilename(name) {
	            return name.substr(0, name.indexOf('.'));
	        }

	        /**
	         * 图片预加载
	         * 1 png
	         * 2 jpg mask
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_preloadImage',
	        value: function _preloadImage(index, callback) {
	            if (index >= this.totalFPS) {
	                return;
	            }
	            var self = this;
	            var collect = function collect() {
	                self._imgArray && self._imgArray.push(this);
	                callback && callback();
	            };

	            var imageList = this.originalImageList;
	            var resourcePath = this.resourcePath;
	            if (this.isMask) {
	                var filename = this._getFilename(imageList[index].name);
	                imgReady(resourcePath + filename + ".png", collect);
	                imgReady(resourcePath + filename + ".jpg", collect);
	            } else {
	                imgReady(resourcePath + imageList[index].name, collect);
	            }
	        }

	        /**
	         * 改变图片url
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_changeImageUrl',
	        value: function _changeImageUrl() {
	            var imageList = this.originalImageList;
	            var curFPS = imageList[this.curFPS];
	            var resourcePath = this.resourcePath;

	            //第一次循环才加载图片
	            if (this.resetCount === 0) {
	                this._preloadImage(this.curFPS + this.qualified);
	            }

	            if (this.isMask) {
	                var filename = this._getFilename(curFPS.name);
	                this.sprObj.css("background-image", "url(" + resourcePath + filename + ".jpg)");
	                this.sprObj.css("-webkit-mask-image", "url(" + resourcePath + filename + ".png)");
	            } else {
	                var str = resourcePath + curFPS.name;
	                this.sprObj.attr("src", str);
	            }
	        }

	        /**
	         * 改变图片位置
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_changePosition',
	        value: function _changePosition() {
	            var imageList = this.originalImageList;
	            var curFPS = imageList[this.curFPS];
	            var x = curFPS.X - this.startPoint.x;
	            var y = curFPS.Y - this.startPoint.y;
	            this.obj.css({
	                left: this.startLeft + x * this.xRote,
	                top: this.startTop + y * this.yRote
	            });
	        }

	        /**
	         * 运行动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_change',
	        value: function _change() {
	            this._changeImageUrl();
	            if (this.isSports) {
	                this._changePosition();
	            }
	        }
	    }, {
	        key: '_time',
	        value: function _time() {
	            var _this2 = this;

	            this.timer = setTimeout(function () {
	                clearTimeout(_this2.timer);
	                _this2.timer = null;
	                _this2._change();
	                _this2.curFPS++;
	                _this2._set();
	            }, 1000 / this.FPS);
	        }

	        /**
	         * 设置动画运行状态
	         * look 0  循环
	         * lokk 1~n 指定次数
	         */

	    }, {
	        key: '_set',
	        value: function _set() {
	            var _this3 = this;

	            //循环复位
	            if (this.curFPS >= this.totalFPS - 1) {
	                this.curFPS = 0;
	                this.resetCount++;
	            }

	            //指定次数
	            if (this.loop && this.loop == this.resetCount) {
	                this._stop();
	                return;
	            }
	            this._checkNextAction(function () {
	                _this3._time();
	            });
	        }
	    }, {
	        key: '_stop',
	        value: function _stop() {
	            if (this.timer) {
	                clearTimeout(this.timer);
	                this.timer = null;
	            }
	            this.curFPS = 0;
	            this.resetCount = 0;
	        }

	        /**
	         * 开始运行动画
	         * @param  {[type]} action [description]
	         * @param  {[type]} loop   [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: 'play',
	        value: function play(action, loop) {
	            this.action = action;
	            if (!this.data.params[action]) {
	                console.log(" Function changeSwitchAni  parameters " + action + " error");
	                return;
	            }
	            this.loop = loop;
	            this._stop();
	            this._set();
	        }

	        /**
	         * 停止
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            this._stop();
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this._stop();
	            this.obj = null;
	            this.sprObj = null;
	            this.data.params = null;
	            this.data = null;
	            this._imgArray.forEach(function (img) {
	                img = null;
	            });
	            this.originalImageList = null;
	            this._imgArray = null;
	        }
	    }]);
	    return _class;
	}();

	var spiritObjs = {};

	// $("body").on("dblclick",function(){
	//   console.log(spiritObjs)
	// })

	/**
	 * get data
	 * @param  {[type]} inputPara [description]
	 * @param  {[type]} contents  [description]
	 * @return {[type]}           [description]
	 */
	var getData = function getData(inputPara, contents) {
	    var option = void 0;
	    var resourcePath = config.jsWidgetPath() + "gallery/" + inputPara.id + "/";
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', resourcePath + 'app.json', false);
	    xhr.send(null);
	    try {
	        option = parseJSON(xhr.responseText);
	    } catch (e) {
	        console.log("app.json get error:" + e);
	    }
	    return option;
	};

	var moveContent = function moveContent(contentPrefix, id, parentId) {
	    var obj = $("#" + contentPrefix + id);
	    var parentObj = $("#" + contentPrefix + parentId);
	    var $parent = $("#spirit_parent_" + parentId);
	    if ($parent.length == 0) {
	        parentObj.append("<div style='position:absolute; width:100%; height:100%'  id='spirit_parent_" + parentId + "'></div>");
	    }
	    $parent.append(obj);
	};

	var getId = function getId(inputPara, contentPrefix) {
	    var id = '';
	    if (_.isObject(inputPara)) {
	        id = contentPrefix + inputPara.framId;
	    } else {
	        id = inputPara;
	    }
	    return id;
	};

	function updateAction(id, params) {

	    var loop = 1;
	    var obj = void 0;
	    if (params.playerType == "loop") {
	        loop = 0;
	    }

	    if (obj = spiritObjs[id]) {
	        obj.play(params.actList, loop);
	    } else {
	        console.log('error');
	    }
	}

	function AdvSprite (inputPara, contents) {
	    var option = getData(inputPara, contents);
	    var ResourcePath = config.jsWidgetPath() + "gallery/" + inputPara.id + "/";
	    var contentPrefix = inputPara.contentPrefix;
	    var ids = [];
	    var options = {};
	    options.contentPrefix = contentPrefix;
	    options.resourcePath = ResourcePath;
	    options.type = 'seniorSprite';

	    for (var i = 0; i < option.spiritList.length; i++) {
	        var spiritList = option.spiritList[i];
	        var id = getId(spiritList, contentPrefix);
	        var framId = spiritList.framId;
	        var parentId = spiritList.parentId;
	        if (_.isObject(inputPara)) {
	            if (parentId != "0") {
	                moveContent(contentPrefix, framId, parentId);
	            }
	            spiritObjs[id] = new _class$1(spiritList, options);
	            ids.push(id);
	        } else {
	            console.log("inputPara undefine Spirit");
	        }
	    }

	    return {
	        stop: function stop() {
	            ids.forEach(function (key) {
	                spiritObjs[key].stop();
	            });
	        },
	        destroy: function destroy() {
	            ids.forEach(function (key) {
	                spiritObjs[key].destroy();
	                spiritObjs[key] = null;
	                delete spiritObjs[key];
	            });
	        }
	    };
	}

	//检测是否支持HTML5的video播放
	var supportVideo = function () {
	    var video = document.createElement('video');
	    var type = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
	    return !!video.canPlayType && "probably" == video.canPlayType(type);
	}();

	//检测是否安装了flash插件
	var supportFlash = function () {
	    var i_flash = false;
	    if (navigator.plugins) {
	        for (var i = 0; i < navigator.plugins.length; i++) {
	            if (navigator.plugins[i].name.toLowerCase().indexOf("shockwave flash") != -1) {
	                i_flash = true;
	            }
	        }
	    }
	    return i_flash;
	}();

	var pixelRatio = window.devicePixelRatio;
	var resolution = window.screen;

	var VideoPlayer = null;

	/**
	 * 网页
	 * @param {[type]} options [description]
	 */
	var _WebPage = function _WebPage(options) {

	    var pageUrl = options.pageUrl;

	    //跳转app市场
	    //普通网页是1
	    //跳转app市场就是2
	    if (options.hyperlink == 2) {
	        //跳转到app市场
	        window.open(pageUrl);
	        //数据统计
	        $.get('http://www.appcarrier.cn/index.php/adplugin/recordads?aid=16&esbId=ios');
	    } else {

	        var padding = options.padding || 0,
	            width = options.width,
	            height = options.height,
	            videoId = options.videoId,
	            left = options.left,
	            top = options.top,
	            $videoNode,
	            eleWidth,
	            eleHeight;

	        if (padding) {
	            eleWidth = width - 2 * padding;
	            eleHeight = height - 2 * padding;
	        } else {
	            eleWidth = width;
	            eleHeight = height;
	        }

	        $videoNode = $('<div id="videoWrap_' + videoId + '" style="position:absolute;left:' + left + 'px;top:' + top + 'px;width:' + width + 'px;height:' + height + 'px;z-index:' + Xut.zIndexlevel() + '">' + '<div style="position:absolute;left:' + padding + 'px;top:' + padding + 'px;width:' + eleWidth + 'px;height:' + eleHeight + 'px;">' + '<iframe src="' + pageUrl + '" style="position:absolute;left:0;top:0;width:100%;height:100%;"></iframe>' + '</div>' + '</div>');

	        options.container.append($videoNode);
	    }

	    function play() {
	        $videoNode && $videoNode.show();
	    }

	    function stop() {
	        $videoNode && $videoNode.hide();
	    }

	    function close() {
	        if ($videoNode) {
	            $videoNode.remove();
	            $videoNode = null;
	        }
	    }

	    play();

	    return {
	        play: play,
	        stop: stop,
	        close: close
	    };
	};

	/**
	 * 安卓phonegap播放器
	 * @param  {[type]} options [description]
	 * @return {[type]}         [description]
	 */
	var _Media$1 = function _Media(options) {

	    var width = void 0;
	    var height = void 0;
	    var left = void 0;
	    var top = void 0;
	    var url = void 0;

	    //如果是读库或者妙妙学
	    url = window.MMXCONFIG || window.DUKUCONFIG ? options.url
	    //如果是纯apk模式
	    : options.url.substring(0, options.url.lastIndexOf('.'));

	    //如果是安卓平台，视频插件去的分辨率
	    //所以这里要把 可以区尺寸，转成分辨率
	    //读库强制全屏
	    if (window.DUKUCONFIG) {
	        width = resolution.width;
	        height = resolution.height;
	        top = 0;
	        left = 0;
	    } else {
	        //正常的是按照屏幕尺寸的
	        //这是安卓插件问题,按照分辨率计算
	        width = options.width * pixelRatio;
	        height = options.height * pixelRatio;
	        left = options.left * pixelRatio || 0;
	        top = options.top * pixelRatio || 0;
	    }

	    var play = function play() {
	        Xut.Plugin.VideoPlayer.play(function () {
	            //成功回调
	        }, function () {
	            //失败回调
	        }, Xut.config.videoPath() + url, 1, left, top, height, width);
	    };

	    var close = function close() {
	        Xut.Plugin.VideoPlayer.close();
	    };

	    play();

	    return {
	        play: play,
	        stop: close,
	        close: close
	    };
	};

	/**
	 *   html5的video播放器
	 *   API :
	 *   play();播放
	 *   stop();    //停止播放并隐藏界面
	 *   destroy(); //清除元素节点及事件绑定
	 *  demo :
	 *  var video = new Video({url:'1.mp4',width:'320',...});
	 *  video.play();
	 */
	var Video5 = function _Video5(options) {

	    var container = options.container || $('body');
	    var url = Xut.config.videoPath() + options.url;
	    var width = options.width;
	    var height = options.height;
	    var top = options.top;
	    var left = options.left;
	    var zIndex = options.zIndex;

	    var $videoWrap = $('<div></div>');
	    var $video = $(document.createElement('video'));
	    var video = $video[0];

	    //video节点
	    $video.css({
	        width: width,
	        height: height
	    }).attr({
	        'src': url,
	        'controls': 'controls',
	        'autoplay': 'autoplay'
	    });

	    //父容器
	    $videoWrap.append($video).css({
	        position: 'absolute',
	        'z-index': -1,
	        top: top,
	        left: left,
	        width: 0,
	        height: 0
	    });

	    /**
	     * 播放视频
	     * @return {[type]} [description]
	     */
	    var _paly = function _paly() {
	        $videoWrap.show();
	        video.play();
	    };

	    //////////////////////////
	    ///2016.6.23
	    //安卓ios需要直接调用play开始
	    ////////////////////////
	    if (Xut.plat.isIOS || Xut.plat.isAndroid) {
	        _paly();
	    }

	    /**
	     * 停止
	     * @return {[type]} [description]
	     */
	    var stop = function stop() {

	        video.pause();

	        //妙妙学只需要停止
	        if (!window.MMXCONFIG) {
	            //复位视频
	            if (video.duration) {
	                video.currentTime = 0.01;
	            }

	            $videoWrap.hide();

	            //用于启动视频
	            if (options.startBoot) {
	                options.startBoot();
	                destroy();
	            }
	        }
	    };

	    /**
	     * 错误
	     * @return {[type]} [description]
	     */
	    var error = function error() {
	        //用于启动视频
	        if (options.startBoot) {
	            options.startBoot();
	            destroy();
	        }
	    };

	    /**
	     * 防止播放错误时播放界面闪现
	     * @return {[type]} [description]
	     */
	    var start = function start() {
	        $videoWrap.css({
	            width: width + 'px',
	            height: height + 'px',
	            zIndex: zIndex
	        });

	        //加完后播放视频
	        _paly();
	    };

	    /**
	     * 销毁
	     * @return {[type]} [description]
	     */
	    var destroy = function destroy() {
	        video.removeEventListener('ended', stop, false);
	        video.removeEventListener('error', error, false);
	        video.removeEventListener('loadeddata', start, false);
	        video.removeEventListener('webkitendfullscreen', stop, false);
	        $videoWrap.hide().remove();
	    };

	    container.append($videoWrap);

	    video.addEventListener('ended', stop, false);
	    video.addEventListener('error', error, false);
	    video.addEventListener('loadeddata', start, false);
	    video.addEventListener('webkitendfullscreen', stop, false);

	    return {
	        play: _paly,
	        stop: stop,
	        close: destroy
	    };
	};

	/**
	 * https://github.com/videojs/video.js/blob/master/docs/guides/setup.md
	 * 基于video.js的web播放器,在pc端flash优先
	 * @param {[type]} options [description]
	 */
	var _VideoJS = function _VideoJS(options) {
	    var container = options.container || $('body'),
	        videoId = options.videoId,
	        url = Xut.config.videoPath() + options.url,
	        width = options.width,
	        height = options.height,
	        zIndex = options.zIndex,
	        top = options.top,
	        left = options.left,
	        video,
	        source,
	        player;

	    video = document.createElement('video');
	    source = document.createElement('source');
	    source.setAttribute('src', url);
	    source.setAttribute('type', 'video/mp4');
	    video.id = 'video_' + videoId;
	    video.className = "video-js vjs-sublime-skin";
	    video.appendChild(source);
	    container.append(video);
	    //指定本地的swf地址取代网络地址
	    videojs.options.flash.swf = "lib/data/video-js.swf";

	    var clear = function clear() {
	        //结束后清理自己
	        removeVideo(options.pageId);
	    };

	    //videojs是videojs定义的全局函数
	    player = videojs(video, {
	        //视频引擎顺序,位置排前面的优先级越高
	        "techOrder": ["html5", "flash"],
	        //预加载
	        "preload": "auto",
	        //是否有控制条
	        "controls": true,
	        "autoplay": true,
	        "width": width,
	        "height": height,
	        //播放元素相关设置
	        children: {
	            //暂停时是否显示大大的播放按钮
	            bigPlayButton: false,
	            //是否显示错误提示
	            errorDisplay: false,
	            //是否显示视频快照
	            posterImage: false,
	            //是否显示字幕
	            textTrackDisplay: false,
	            volumeMenuButton: false
	        },
	        //控制条相关设置
	        controlBar: {
	            //是否显示字幕按钮
	            captionsButton: false,
	            chaptersButton: false,

	            liveDisplay: false,
	            //是否显示剩余时间
	            remainingTimeDisplay: true,
	            //是否显示子标题按钮
	            subtitlesButton: false,
	            //是否显示回放菜单按钮
	            playbackRateMenuButton: false,
	            //是否显示时间分隔符"/"
	            timeDivider: false,
	            //是否显示当前视频的当前时间值
	            currentTimeDisplay: false,
	            //是否显示视频时长
	            durationDisplay: false
	        }
	    }, function () {
	        //可以播放时提升层级，防止闪现
	        this.on('canplay', function () {
	            wrap.style.zIndex = zIndex;
	        });

	        //播放完毕后自动关闭
	        this.on('ended', function () {
	            //结束后清理自己
	            clear();
	        });

	        this.on('error', function () {
	            clear();
	        });

	        //因为没有关闭按钮,又不想自己做,就把全屏变成关闭好了.
	        this.on("touchend mouseup", function (e) {
	            var className = e.target.className.toLowerCase();
	            if (-1 != className.indexOf('vjs-fullscreen-control')) {
	                clear();
	            }
	        });
	    });

	    //修正视频样式
	    var wrap = player.el();
	    var videoElement = wrap.children[0];
	    wrap.style.left = left + 'px';
	    wrap.style.top = top + 'px';
	    wrap.style.zIndex = -1;

	    return {

	        play: function play() {
	            console.log(111);
	        },

	        stop: function stop() {
	            player.pause();
	        },

	        close: function close() {
	            player.dispose();
	            player = null;
	        }
	    };
	};

	//浏览器平台
	if (Xut.plat.isBrowser) {
	    VideoPlayer = Video5;
	} else {
	    //检测平台
	    if (Xut.plat.isIOS || top.EduStoreClient) {
	        //如果是ibooks模式
	        if (Xut.IBooks.Enabled) {
	            VideoPlayer = _VideoJS;
	        } else {
	            //如果是ios或读酷pc版则使用html5播放
	            VideoPlayer = Video5;
	        }
	    } else if (Xut.plat.isAndroid) {
	        if (window.MMXCONFIG) {
	            // 安卓妙妙学强制走h5
	            VideoPlayer = Video5;
	        } else {
	            //android平台
	            VideoPlayer = _Media$1;
	        }
	    }
	}

	var VideoClass = function () {
	    function VideoClass(options, container) {
	        classCallCheck(this, VideoClass);


	        options.container = container;
	        if ('video' == options.category) {
	            this.video = VideoPlayer(options);
	        } else if ('webpage' == options.category) {
	            this.video = _WebPage(options);
	        } else {
	            console.log('options.category must be video or webPage ');
	        }
	        Xut.View.Toolbar("hide");
	    }

	    createClass(VideoClass, [{
	        key: 'play',
	        value: function play() {
	            //隐藏工具栏
	            Xut.View.Toolbar("hide");
	            this.video.play();
	        }
	    }, {
	        key: 'stop',
	        value: function stop() {
	            //显示工具栏
	            Xut.View.Toolbar("show");
	            this.video.stop();
	        }
	    }, {
	        key: 'close',
	        value: function close() {
	            this.video.close();
	        }
	    }]);
	    return VideoClass;
	}();

	var pageBox$1 = void 0;
	var playBox$1 = void 0;

	var initBox$1 = function initBox() {
	    pageBox$1 = hash(); //当前页面包含的视频数据
	    playBox$1 = hash(); //播放过的视频数据 （播放集合)
	};

	initBox$1();

	/**
	 * 配置视频结构
	 * @param  {[type]} data       [description]
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @return {[type]}            [description]
	 */
	var deployVideo = function deployVideo(data, pageId, activityId) {

	    var proportion = config.proportion;

	    var videoInfo = {
	        'pageId': pageId,
	        'videoId': activityId,
	        'url': data.md5,
	        'pageUrl': data.url,
	        'left': data.left * proportion.left || 0,
	        'top': data.top * proportion.top || 0,
	        'width': data.width * proportion.width || config.viewSize.width,
	        'height': data.height * proportion.height || config.viewSize.height,
	        'padding': data.padding * proportion.left || 0,
	        'zIndex': data.zIndex || 2147483647,
	        'background': data.background,
	        'category': data.category,
	        'hyperlink': data.hyperlink
	    };

	    if (!_.isObject(pageBox$1[pageId])) {
	        pageBox$1[pageId] = {};
	    }

	    pageBox$1[pageId][activityId] = videoInfo;
	};

	/**
	 * 检测数据是否存在
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @return {[type]}            [description]
	 */
	var checkRepeat$1 = function checkRepeat(pageId, activityId) {
	    var chapterData = pageBox$1[pageId];
	    //如果能在pageBox找到对应的数据
	    if (chapterData && chapterData[activityId]) {
	        return true;
	    }
	    return false;
	};

	//处理重复数据
	// 1:pageBox能找到对应的 videoId
	// 2:重新查询数据
	var parseVideo = function parseVideo(pageId, activityId) {
	    //复重
	    if (checkRepeat$1(pageId, activityId)) {
	        return;
	    }
	    //新的查询
	    var data = Xut.data.query('Video', activityId);
	    deployVideo(data, pageId, activityId);
	};

	/**
	 * 加载视频
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	var loadVideo = function loadVideo(pageId, activityId, container) {
	    var data = pageBox$1[pageId][activityId];

	    //search video cache
	    if (playBox$1[pageId] && playBox$1[pageId][activityId]) {
	        //console.log('*********cache*********');
	        playBox$1[pageId][activityId].play();
	    } else {
	        //console.log('=========new=============');
	        if (!_.isObject(playBox$1[pageId])) {
	            playBox$1[pageId] = {};
	        }
	        //cache video object
	        playBox$1[pageId][activityId] = new VideoClass(data, container);
	    }
	};

	/**
	 * 触发视频
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	var initVideo = function initVideo(pageId, activityId, container) {
	    //解析数据
	    parseVideo(pageId, activityId);
	    //调用播放
	    loadVideo(pageId, activityId, container);
	};

	/**
	 * 自动播放
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	function autoVideo(pageId, activityId, container) {
	    initVideo(pageId, activityId, container);
	}

	/**
	 * 手动播放
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} container  [description]
	 * @return {[type]}            [description]
	 */
	function triggerVideo(pageId, activityId, container) {
	    initVideo(pageId, activityId, container);
	}

	/**
	 * 清理移除页的视频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function removeVideo(pageId) {
	    //清理视频
	    if (playBox$1 && playBox$1[pageId]) {
	        for (var activityId in playBox$1[pageId]) {
	            playBox$1[pageId][activityId].close();
	        }
	        delete playBox$1[pageId];
	    }
	    //清理数据
	    if (pageBox$1 && pageBox$1[pageId]) {
	        delete pageBox$1[pageId];
	    }
	}

	/**
	 * 清理全部视频
	 * @return {[type]} [description]
	 */
	function clearVideo() {
	    var flag = false; //记录是否处理过销毁状态
	    for (var pageId in playBox$1) {
	        for (var activityId in playBox$1[pageId]) {
	            playBox$1[pageId][activityId].close();
	            flag = true;
	        }
	    }
	    initBox$1();
	    return flag;
	}

	/**
	 * 挂起视频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function hangUpVideo(pageId) {
	    for (var _pageId in playBox$1) {
	        for (var activityId in playBox$1[_pageId]) {
	            playBox$1[_pageId][activityId].stop();
	        }
	    }
	}

	//动作标示
	var ACTIVIT = 'hot'; //热点音频
	var ANIMATE = 'content'; //动画音频
	var SEASON = 'season'; //节音频

	/**
	 * 容器合集
	 * 1 pageBox 当前待播放的热点音频
	 * 2 playBox 播放中的热点音频集合
	 */
	//[type][pageId][queryId]
	var pageBox;
	var playBox;
	var initBox = function initBox() {
	    pageBox = hash();

	    //[type][pageId][queryId]
	    playBox = hash();
	};

	initBox();

	/**
	 * 解析数据
	 * @param  {[type]} type    [description]
	 * @param  {[type]} queryId [description]
	 * @return {[type]}         [description]
	 */
	var parseData = function parseData(type, queryId) {
	    var data;
	    switch (type) {
	        case ANIMATE:
	            data = Xut.data.query('Video', queryId, true);
	            break;
	        case SEASON:
	            data = Xut.data.query('Video', queryId, true);
	            break;
	        default:
	            data = Xut.data.query('Video', queryId);
	            break;
	    }
	    return data;
	};

	/**
	 * 获取父容器
	 * @return {[type]} [description]
	 */
	var getParentDom = function getParentDom(subtitles, pageId, queryId) {
	    //字幕数据
	    var parentDoms = hash();
	    var ancestorDoms = hash();
	    var contentsFragment;
	    var dom;
	    var pageIndex = pageId - 1;
	    if (subtitles) {
	        //获取文档节点
	        contentsFragment = Xut.Contents.contentsFragment[pageId];

	        //如果maskId大于9000默认为处理
	        var isMask = pageId > 9000;
	        if (isMask) {
	            //指定页码编号
	            pageIndex = Xut.Presentation.GetPageIndex();
	        }

	        //找到对应的节点
	        _.each(subtitles, function (data) {
	            //'Content_0_1' 规则 类型_页码（0开始）_id
	            if (!parentDoms[data.id]) {
	                dom = contentsFragment['Content_' + pageIndex + '_' + data.id];
	                ancestorDoms[data.id] = dom;
	                var $dom = $(dom);
	                if ($dom.length) {
	                    var _div = $dom.find('div').last();
	                    if (_div.length) {
	                        parentDoms[data.id] = _div[0];
	                    }
	                }
	            }
	        });
	    }

	    return {
	        parents: parentDoms,
	        ancestors: ancestorDoms
	    };
	};

	/**
	 * 检测数据是否存在
	 * @return {[type]}         [description]
	 */
	var checkRepeat = function checkRepeat(pageId, queryId, type) {
	    var pBox = pageBox[type];
	    if (pBox && pBox[pageId] && pBox[pageId][queryId]) {
	        return true;
	    }
	    return false;
	};

	/**
	 * 组合热点音频数据结构
	 * data, pageId, queryId, type
	 * 数据，页码编号，videoId, 查询的类型
	 * @return {[type]}         [description]
	 */
	var combination = function combination(data, pageId, queryId, type, eleName) {
	    var tempDoms;
	    if (!pageBox[type]) {
	        pageBox[type] = hash();
	    }
	    if (!pageBox[type][pageId]) {
	        pageBox[type][pageId] = hash();
	    }
	    //有字幕处理
	    if (data.theTitle) {
	        var subtitles = parseJSON(data.theTitle);
	    }
	    //配置音频结构
	    return pageBox[type][pageId][queryId] = {
	        'trackId': data.track, //音轨
	        'url': data.md5, //音频名字
	        'subtitles': subtitles,
	        'audioId': queryId,
	        'data': data
	    };
	};

	/**
	 * 装配音频数据
	 * @param  {int} pageId    页面id或节的分组id
	 * @param  {int} queryId   查询id,支持activityId,audioId
	 * @param  {string} type   音频来源类型[动画音频,节音频,热点音频]
	 */
	var deployAudio = function deployAudio(pageId, queryId, type, actionData) {
	    //避免复重查询
	    if (checkRepeat(pageId, queryId, type)) {
	        return false;
	    }
	    //解析合集数据
	    var data = parseData(type, queryId);
	    //存在音频文件
	    if (data && data.md5) {
	        //新的查询
	        var ret = combination(data, pageId, queryId, type, actionData);
	        //混入新的动作数据
	        //2015.9.24
	        //音频替换图片
	        //触发动画
	        if (actionData) {
	            _.extend(ret, actionData, {
	                action: true //快速判断存在动作数据
	            });
	        }
	    }
	};

	/**
	 * 检查要打断的音频
	 * @param  {[type]} type    音频类型
	 * @param  {[type]} pageId  [description]
	 * @param  {[type]} queryId [description]
	 * @param  {[type]} pageBox [description]
	 * @return {boolen}         不打断返回true,否则返回false
	 */
	var checkBreakAudio = function checkBreakAudio(type, pageId, queryId, pageBox) {
	    var playObj = playBox[type][pageId][queryId],
	        trackId = pageBox.trackId,
	        _trackId = playObj.trackId;

	    //如果是节音频，且地址相同，则不打断
	    if (type == SEASON && playObj.url == pageBox.url) {
	        return true;
	    }

	    //如果要用零音轨||零音轨有音乐在播||两音轨相同
	    //则打断
	    if (trackId == 0 || _trackId == 0 || trackId == _trackId) {
	        playObj.end();
	        delete playBox[type][pageId][queryId];
	    }
	    return false;
	};

	/**
	 * 播放音频之前检查
	 * @param  {int} pageId    [description]
	 * @param  {int} queryId    查询id
	 * @param  {string} type    决定video表按哪个字段查询
	 * @return {object}         音频对象/不存在为null
	 */
	var preCheck = function preCheck(pageId, queryId, type) {
	    var t,
	        p,
	        q,
	        playObj = pageBox[type][pageId][queryId],
	        seasonAudio = null;
	    for (t in playBox) {
	        for (p in playBox[t]) {
	            for (q in playBox[t][p]) {
	                if (checkBreakAudio(t, p, q, playObj)) {
	                    seasonAudio = playBox[t][p][q];
	                }
	            }
	        }
	    }
	    return seasonAudio;
	};

	/**
	 * 加载音频对象
	 * @return {[type]}         [description]
	 */
	var loadAudio = function loadAudio(pageId, queryId, type) {

	    //找到页面对应的音频
	    //类型=》页面=》指定音频Id
	    var pageObj = pageBox[type][pageId][queryId];
	    //检测
	    var seAudio = preCheck(pageId, queryId, type);

	    //播放音频时关掉视频
	    clearVideo();

	    //构建播放列表
	    if (!playBox[type]) {
	        playBox[type] = hash();
	    }
	    if (!playBox[type][pageId]) {
	        playBox[type][pageId] = hash();
	    }
	    //假如有字幕信息
	    //找到对应的文档对象
	    if (pageObj.subtitles) {
	        var tempDoms = getParentDom(pageObj.subtitles, pageId, queryId);
	    }

	    //播放完成处理
	    pageObj.innerCallback = function (audio) {
	        if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
	            audio.end();
	            delete playBox[type][pageId][queryId];
	        }
	    };

	    //存入播放对象池
	    playBox[type][pageId][queryId] = seAudio || new audioPlayer(pageObj, tempDoms);
	};

	/**
	 * 交互点击
	 * @param  {int} pageId     [description]
	 * @param  {int} queryId    [description]
	 * @param  {string} type    ACTIVIT
	 * @return {[type]}         [description]
	 */
	var loadTiggerAudio = function loadTiggerAudio(pageId, queryId, type) {
	    var playObj, status;
	    if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
	        playObj = playBox[type][pageId][queryId];
	        status = playObj.audio ? playObj.status : null;
	    }
	    switch (status) {
	        case 'playing':
	            playObj.pause();
	            break;
	        case 'paused':
	            playObj.play();
	            break;
	        default:
	            loadAudio(pageId, queryId, type);
	            break;
	    }
	};

	/**
	 * 清理全部音频
	 * @return {[type]} [description]
	 */
	var removeAudio = function removeAudio() {
	    var t, p, a;
	    for (t in playBox) {
	        for (p in playBox[t]) {
	            for (a in playBox[t][p]) {
	                playBox[t][p][a].end();
	            }
	        }
	    }
	    initBox();
	};

	///////////////////
	//1 独立音频处理, 音轨/跨页面 //
	//2 动画音频,跟动画一起播放与销毁
	///////////////////

	/**
	 * 自动播放触发接口
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} actionData [description]
	 * @return {[type]}            [description]
	 */
	function autoAudio(pageId, activityId, actionData) {
	    deployAudio(pageId, activityId, ACTIVIT, actionData);
	    loadAudio(pageId, activityId, ACTIVIT);
	}

	/**
	 * 手动触发
	 * @param  {[type]} pageId     [description]
	 * @param  {[type]} activityId [description]
	 * @param  {[type]} actionData [description]
	 * @return {[type]}            [description]
	 */
	function triggerAudio(pageId, activityId, actionData) {
	    deployAudio(pageId, activityId, ACTIVIT, actionData);
	    loadTiggerAudio(pageId, activityId, ACTIVIT);
	}

	/**
	 * 挂起音频
	 * @return {[type]} [description]
	 */
	function hangUpAudio() {
	    var t, p, a;
	    for (t in playBox) {
	        for (p in playBox[t]) {
	            for (a in playBox[t][p]) {
	                playBox[t][p][a].pause();
	            }
	        }
	    }
	}

	/**
	 * 动画音频触发接口
	 * @param  {[type]} pageId  [description]
	 * @param  {[type]} audioId [description]
	 * @return {[type]}         [description]
	 */
	function createContentAudio(pageId, audioId) {
	    deployAudio(pageId, audioId, ANIMATE);
	    loadAudio(pageId, audioId, ANIMATE);
	}

	/**
	 * 销毁动画音频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function clearContentAudio(pageId) {
	    if (!playBox[ANIMATE] || !playBox[ANIMATE][pageId]) {
	        return false;
	    }
	    var playObj = playBox[ANIMATE][pageId];
	    if (playObj) {
	        for (var i in playObj) {
	            playObj[i].end();
	            delete playBox[ANIMATE][pageId][i];
	        }
	    }
	}

	/**
	 * 清理音频
	 * @param  {[type]} pageId [description]
	 * @return {[type]}        [description]
	 */
	function clearAudio(pageId) {
	    if (pageId) {
	        //如果只跳槽关闭动画音频
	        clearContentAudio(pageId);
	    } else {
	        removeAudio(); //多场景模式,不处理跨页面
	    }
	}

	var filter$1 = Xut.style.filter;

	/**
	 * 淡入淡出动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function fade(animproto) {

	    //出现/消失
	    animproto.getEffectAppear = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        if (isExit == false) t1.to(object, 0.001, {
	            autoAlpha: 1
	        });else t1.to(object, 0.001, {
	            css: {
	                visibility: "hidden"
	            }
	        });
	        return t1;
	    };

	    //淡出
	    animproto.getEffectFade = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                ease: parameter.tweenEase,
	                immediateRender: false
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //闪烁(一次)
	    animproto.getEffectFlashOnce = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var time = duration / 3;
	        t1.to(object, 0.001, {
	            css: {
	                visibility: "hidden"
	            }
	        }).to(object, time * 2, {}).to(object, time, {
	            css: {
	                visibility: "visible"
	            }
	        });
	        return t1;
	    };

	    //不饱和
	    animproto.getEffectDesaturate = function (parameter, object, duration, delay, repeat) {
	        if (!(filter$1 in object[0].style)) return new TimelineMax();
	        var saturation = parameter.saturation ? parameter.saturation : 0.5; //饱和度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateSaturate
	        });
	        return t1;

	        function updateSaturate() {
	            var progress = t1.progress();
	            var percent = progress <= 0.5 ? progress * 2 : 1;
	            var val = 1 + (saturation - 1) * percent;
	            object.css(filter$1, "saturate(" + val + ")");
	        }
	    };

	    //加深
	    animproto.getEffectDarken = function (parameter, object, duration, delay, repeat) {
	        if (!(filter$1 in object[0].style)) return new TimelineMax();
	        var brightness = parameter.brightness && parameter.brightness < 1 ? brightness.saturation : 0.5; //亮度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateBrightness
	        });
	        return t1;

	        function updateBrightness() {
	            var progress = t1.progress();
	            var percent = progress <= 0.5 ? progress * 2 : 1;
	            var val = 1 + (brightness - 1) * percent;
	            object.css(filter$1, "brightness(" + val + ")");
	        }
	    };

	    //变淡
	    animproto.getEffectLighten = function (parameter, object, duration, delay, repeat) {
	        if (!(filter$1 in object[0].style)) return new TimelineMax();
	        var brightness = parameter.brightness && parameter.brightness > 1 ? parameter.brightness : 1.5; //亮度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateBrightness
	        });
	        return t1;

	        function updateBrightness() {
	            var progress = t1.progress();
	            var percent = progress <= 0.5 ? progress * 2 : 1;
	            var val = 1 + (brightness - 1) * percent;
	            object.css(filter$1, "brightness(" + val + ")");
	        }
	    };

	    //透明
	    animproto.getEffectTransparency = function (parameter, object, duration, delay, repeat) {
	        var opacity = parameter.amount ? parameter.amount : 0.5; //透明度
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            autoAlpha: opacity,
	            ease: parameter.tweenEase
	        });
	        return t1;
	    };
	}

	/**
	 * 飞入飞出动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function fly(animproto) {

	    //飞入效果
	    animproto.getEffectFly = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(上、下、左、右、左上、左下、右上、右下)
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        var easeString = Expo.easeOut;
	        var x, y;

	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (parameter.smoothStart == 1 || parameter.smoothEnd == 1 || parameter.bounceEnd == 1) {
	            if (isExit == true) easeString = Power4.easeOut;else easeString = Elastic.easeOut;
	        }

	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "visible"
	                }]
	            });
	            switch (direction) {
	                case "DirectionDown":
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.from(object, duration, {
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    t1.from(object, duration, {
	                        x: x,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionUp":
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.from(object, duration, {
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    t1.from(object, duration, {
	                        x: x,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionDownLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionDownRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionUpLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case "DirectionUpRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.from(object, duration, {
	                        x: x,
	                        y: y,
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                default:
	                    console.log("getEffectFly:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    x: 0,
	                    y: 0,
	                    visibility: "hidden" //clearProps功能(对象被还原)必须隐藏对象
	                }]
	            });
	            switch (direction) {
	                case "DirectionDown":
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.to(object, duration, {
	                        y: y,
	                        //clearProps: "y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    t1.to(object, duration, {
	                        x: x,
	                        //clearProps: "x",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionUp":
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.to(object, duration, {
	                        y: y,
	                        //clearProps: "y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    t1.to(object, duration, {
	                        x: x,
	                        //clearProps: "x",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionDownLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionDownRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = objInfo.offsetBottom + objInfo.height;
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionUpLeft":
	                    x = 0 - (objInfo.offsetLeft + objInfo.width);
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionUpRight":
	                    x = objInfo.offsetRight + objInfo.width;
	                    y = 0 - (objInfo.offsetTop + objInfo.height);
	                    t1.to(object, duration, {
	                        x: x,
	                        y: y,
	                        //clearProps: "x,y",
	                        ease: easeString
	                    });
	                    break;
	                default:
	                    console.log("getEffectFly:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //浮入/浮出(下方)
	    animproto.getEffectAscend = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            //t1.to(object, 0.001, {opacity: 0, y: 100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                y: 100,
	                ease: parameter.tweenEase,
	                immediateRender: false
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    y: 0
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                y: 100,
	                //clearProps: "y", //己失效
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //浮入/浮出(上方)
	    animproto.getEffectDescend = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            //t1.to(object, 0.001, {y: -100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                y: -100,
	                ease: parameter.tweenEase,
	                immediateRender: false
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                y: -100,
	                ease: parameter.tweenEase,
	                clearProps: "y"
	            });
	        }
	        return t1;
	    };

	    //切入/出
	    animproto.getEffectPeek = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(上下左右)
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionUp":
	                    t1.from(object, duration, {
	                        y: -objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
	                    });
	                    break;
	                case "DirectionDown":
	                    t1.from(object, duration, {
	                        y: objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
	                    });
	                    break;
	                case "DirectionLeft":
	                    t1.from(object, duration, {
	                        x: -objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
	                    });
	                    break;
	                case "DirectionRight":
	                    t1.from(object, duration, {
	                        x: objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
	                    });
	                    break;
	                default:
	                    console.log("getEffectPeek:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionUp":
	                    t1.to(object, duration, {
	                        y: -objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
	                    });
	                    break;
	                case "DirectionDown":
	                    t1.to(object, duration, {
	                        y: objInfo.height,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
	                    });
	                    break;
	                case "DirectionLeft":
	                    t1.to(object, duration, {
	                        x: -objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
	                    });
	                    break;
	                case "DirectionRight":
	                    t1.to(object, duration, {
	                        x: objInfo.width,
	                        ease: Linear.easeNone,
	                        onUpdate: this._updateClipRect,
	                        onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
	                    });
	                    break;
	                default:
	                    console.log("getEffectPeek:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //螺旋飞入/出
	    animproto.getEffectSpiral = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var easeString = Power1.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1.from(object, duration, {
	                scale: 0,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: -200
	                    }, {
	                        x: 0,
	                        y: -400
	                    }, {
	                        x: -500,
	                        y: -600
	                    }]
	                },
	                ease: easeString
	            });
	        } else {
	            t1.to(object, duration, {
	                scale: 0,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: -200
	                    }, {
	                        x: 0,
	                        y: -400
	                    }, {
	                        x: -500,
	                        y: -600
	                    }]
	                },
	                ease: easeString
	            });
	        }
	        return t1;
	    };

	    //曲线向上/下
	    animproto.getEffectArcUp = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Power1.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                scale: 2,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 400
	                    }, {
	                        x: -500,
	                        y: 600
	                    }]
	                },
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    scale: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                scale: 2,
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 400
	                    }, {
	                        x: -500,
	                        y: 600
	                    }]
	                },
	                ease: easeString,
	                clearProps: "x,y"
	            });
	        }
	        return t1;
	    };

	    //升起/下沉
	    animproto.getEffectRiseUp = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        var y = objInfo.offsetBottom + objInfo.height;
	        var easeString = Back.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                y: y,
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                y: y,
	                ease: easeString
	            });
	        }
	        return t1;
	    };
	}

	var ceil = Math.ceil;
	var pow = Math.pow;
	//RGB
	var regexpHex = /^#[0-9a-fA-F]{3,6}$/; //Hex

	/**
	 * 计算两点直线距离
	 */
	function calculateDistance(currentPoint, historyPoint) {
	    var xdiff = currentPoint.x - historyPoint.x;
	    var ydiff = currentPoint.y - historyPoint.y;
	    return ceil(pow(xdiff * xdiff + ydiff * ydiff, 0.5));
	}

	/**
	 * 区间计算
	 */
	function calculateDirection(currentPoint, historyPoint) {
	    var quadrant = ""; //象限
	    if (currentPoint.y == historyPoint.y && currentPoint.x > historyPoint.x) quadrant = "+x"; //水平正方向
	    else if (currentPoint.y == historyPoint.y && currentPoint.x < historyPoint.x) quadrant = "-x"; //水平负方向
	        else if (currentPoint.x == historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "+y"; //垂直正方向
	            else if (currentPoint.x == historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "-y"; //垂直负方向
	                else if (currentPoint.x > historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "1"; //第一象限
	                    else if (currentPoint.x > historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "2"; //第二象限
	                        else if (currentPoint.x < historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "3"; //第三象限
	                            else if (currentPoint.x < historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "4"; //第四象限
	    return quadrant;
	}

	/**
	 * 十六进制颜色转换为RGB颜色
	 * @param color 要转换的十六进制颜色
	 * @return RGB颜色
	 */
	function colorHexToRGB(color, opacity) {
	    color = color.toUpperCase();
	    if (regexpHex.test(color)) {
	        var hexArray = new Array();
	        var count = 1;
	        for (var i = 1; i <= 3; i++) {
	            if (color.length - 2 * i > 3 - i) {
	                hexArray.push(Number("0x" + color.substring(count, count + 2)));
	                count += 2;
	            } else {
	                hexArray.push(Number("0x" + color.charAt(count) + color.charAt(count)));
	                count += 1;
	            }
	        }
	        if (opacity && opacity > 0) return "RGBA(" + hexArray.join(",") + "," + opacity + ")";else return "RGB(" + hexArray.join(",") + ")";
	    } else {
	        console.error("Hex Color string(" + color + ") format conversion error.");
	        return color;
	    }
	}

	/*基本动画类鼠标响应事件*/

	var hasTouch$2 = Xut.plat.hasTouch;

	var MoveMent = function () {
	    function MoveMent(pageType, parentId, objectId, startCallback, moveCallback, endCallback) {
	        classCallCheck(this, MoveMent);

	        this.hasTouch = hasTouch$2;
	        this.parent = document.getElementById(parentId);
	        this.scroller = document.getElementById(objectId);
	        this.startCallback = startCallback;
	        this.moveCallback = moveCallback;
	        this.endCallback = endCallback;
	        if (this.scroller == null) {
	            console.error("The control area of the object is empty.");
	            return;
	        }

	        //取消默认翻页行为
	        if (Xut.Contents.ResetDefaultControl) {
	            Xut.Contents.ResetDefaultControl(pageType, parentId);
	        }

	        //注销重复事件
	        if (this.scroller["bindMoveMent"]) {
	            this.scroller["bindMoveMent"].destroy();
	        }

	        $$on(this.scroller, {
	            start: this
	        });

	        this.scroller["bindMoveMent"] = this; //实例化对象绑定到元素，便于后期调用
	    }

	    createClass(MoveMent, [{
	        key: "handleEvent",
	        value: function handleEvent(e) {
	            $$handle({
	                start: function start(e) {
	                    this._start(e);
	                },
	                move: function move(e) {
	                    this._move(e);
	                },
	                end: function end(e) {
	                    this._end(e);
	                },
	                cancel: function cancel(e) {
	                    this._end(e);
	                }
	            }, this, e);
	        }
	    }, {
	        key: "_start",
	        value: function _start(e) {
	            e.preventDefault();
	            if (typeof this.startCallback == "function") this.startCallback(e);
	            $$on(this.scroller, {
	                move: this,
	                end: this,
	                cancel: this
	            });
	        }
	    }, {
	        key: "_move",
	        value: function _move(e) {
	            if (typeof this.moveCallback == "function") this.moveCallback(e);
	        }
	    }, {
	        key: "_end",
	        value: function _end(e) {
	            $$off(this.scroller, {
	                move: this,
	                end: this,
	                cancel: this
	            });
	            if (typeof this.endCallback == "function") this.endCallback(e);
	        }
	    }, {
	        key: "destroy",
	        value: function destroy(type, el, bubble) {
	            $$off(this.scroller, {
	                start: this,
	                move: this,
	                end: this,
	                cancel: this
	            });
	            this.scroller = null;
	        }
	    }]);
	    return MoveMent;
	}();

	var hasTouch$1 = Xut.plat.hasTouch;

	/**
	 * 路径动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function path(animproto) {

	    //路径动画
	    animproto.getPathAnimation = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var path = parameter.path ? parameter.path : ""; //路径
	        if (!path || path == "") return t1;

	        var autoReverse = parameter.autoReverse == 1 ? true : false; //自动翻转(系统自带,实为沿路径返回)
	        var subRepeat = autoReverse == true ? 1 : 0; //如果autoReverse为真而子动画必须为1，否则默认为0
	        var autoRotate = parameter.objFollow == 1 ? true : false; //是否跟随路径旋转对象(Z轴)
	        var autoTurn = parameter.objFollow == 2 ? true : false; //反向运动时自动翻转对象(Y轴)
	        //连续行为参数处理
	        var axis = 0;
	        var degree = 0; //旋转角度
	        var scaleFactor = null; //缩放比例(未设置时必须为null才能不影响其它动画效果)

	        // var motionScript = ""; //连续脚本
	        if (parameter.attrAlongPath) {
	            axis = parameter.attrAlongPath.axis ? parameter.attrAlongPath.axis : 0;
	            degree = Math.abs(parameter.attrAlongPath.degree) > 0 ? Number(parameter.attrAlongPath.degree) : 0;
	            scaleFactor = parameter.attrAlongPath.scaleFactor > 0 ? parameter.attrAlongPath.scaleFactor : null;
	            // motionScript = parameter.attrAlongPath.motionScript;
	        }

	        var currentFrame = 0; //当前帧
	        var currentDegree = 0; //当前翻转角度
	        var currentOffset = object.offset(); //对象当前位置
	        var turnState = ""; //当前运动状态(左/右)
	        //对象原点坐标（相对页面原点）
	        var objInfo = {
	            top: currentOffset.top,
	            left: currentOffset.left,
	            oX: currentOffset.left + object.width() / 2, //计算object的中心点x坐标
	            oY: currentOffset.top + object.height() / 2 //计算object的中心点有y坐标
	        };
	        //移动起点坐标（默认为对象原点0,0）
	        var x0 = 0,
	            y0 = 0;
	        //对象当前坐标
	        var cx = 0,
	            cy = 0;

	        function resetStartPoint(x, y) {
	            //如果路径动画为：EffectPathStairsDown向下阶梯、EffectPathBounceLeft向左弹跳、EffectPathBounceRight 向右弹跳，则需要重置起点坐标(此问题待验证,暂取消)
	            /*if (parameter.animationName == "EffectPathStairsDown" || parameter.animationName == "EffectPathBounceLeft" || parameter.animationName == "EffectPathBounceRight") {
	                x0 = x;
	                y0 = y;
	            }*/
	            //更新当前坐标
	            cx = x;
	            cy = y;
	        }
	        var isCurve = path.indexOf("C") < 0 && path.indexOf("c") < 0; //是否为曲线路径
	        var ArrPath = path.split(' ');
	        var svgPath = ''; //VML路径转SVG路径(测试)
	        var quArr = [];
	        var x, y;
	        for (var k = 0; k < ArrPath.length; k++) {
	            var str = ArrPath[k];
	            switch (str) {
	                case "M": //移动（开始）
	                case "m":
	                    x = Math.round(ArrPath[k + 1] * this.screenWidth);
	                    y = Math.round(ArrPath[k + 2] * this.screenHeight);
	                    /*t1.add(TweenMax.to(object, 0.001, {
	                        x: x,
	                        y: y
	                    }));*/
	                    quArr.push({
	                        x: x,
	                        y: y
	                    });
	                    k = k + 2;
	                    resetStartPoint(x, y);
	                    svgPath += 'M ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
	                    break;
	                case "C": //曲线
	                case "c":
	                    var x1 = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
	                    var y1 = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
	                    var x2 = x0 + Math.round(ArrPath[k + 3] * this.screenWidth);
	                    var y2 = y0 + Math.round(ArrPath[k + 4] * this.screenHeight);
	                    var x3 = x0 + Math.round(ArrPath[k + 5] * this.screenWidth);
	                    var y3 = y0 + Math.round(ArrPath[k + 6] * this.screenHeight);
	                    quArr.push({
	                        x: x1,
	                        y: y1
	                    }, {
	                        x: x2,
	                        y: y2
	                    }, {
	                        x: x3,
	                        y: y3
	                    });
	                    k = k + 6;
	                    resetStartPoint(x3, y3);
	                    svgPath += ' C ' + (objInfo.oX + x1) + ' ' + (objInfo.oY + y1) + ' ' + (objInfo.oX + x2) + ' ' + (objInfo.oY + y2) + ' ' + (objInfo.oX + x3) + ' ' + (objInfo.oY + y3);
	                    break;
	                case "L": //直线
	                case "l":
	                    x = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
	                    y = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
	                    if (x == cx && y == cy) {
	                        k = k + 2;
	                        break;
	                    }
	                    quArr.push({
	                        x: x,
	                        y: y
	                    });
	                    k = k + 2;
	                    resetStartPoint(x, y);
	                    svgPath += ' L ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
	                    break;
	                case "Z":
	                    //闭合
	                    if (quArr[0].x != quArr[quArr.length - 1].x || quArr[0].y != quArr[quArr.length - 1].y) {
	                        quArr.push({
	                            x: quArr[0].x,
	                            y: quArr[0].y
	                        });
	                    }
	                    svgPath += ' Z';
	                    break;
	                case "E":
	                    //结束
	                    break;
	            }
	        }

	        //启用手势
	        if (parameter.gesture) {
	            t1 = new TimelineMax({
	                paused: true,
	                useFrames: true
	            });
	            parameter.tweenEase = "Linear.easeNone"; //手势控制必须为匀速运动

	            //创建SVG路径(用于测试)
	            /*if (isDesktop) {
	                if ($("#svgPathContainer").length == 0)
	                    this.container.append('<div id="svgPathContainer" style="position:absolute;width:100%;height:100%;"><svg width="100%" height="100%"  xmlns="http://www.w3.org/2000/svg" version="1.1"></svg></div>');
	                var svgDocument = $("#svgPathContainer").find("svg")[0];
	                //创建当前路径
	                var p = makeShape("Path", {
	                    id: "Path_" + object[0].id,
	                    d: svgPath
	                });
	                svgDocument.appendChild(p);
	            }*/

	            //创建手势控制区域
	            var controlId = object[0].id; //控制区ID
	            if (parameter.gesture.controlType == 1) {
	                if (parameter.pathContent > 0) {
	                    controlId = controlId.replace(/\d+$/, parameter.pathContent);
	                } else {
	                    controlId = "Cont_" + object[0].id;
	                    // var expandArea = 20; //最小可触摸尺寸(扩展外框)
	                    //     var rect = p.getBoundingClientRect();
	                    //     this.container.append('<div id="' + controlId + '" style="z-index:9999;position:absolute;left:' + (rect.left - expandArea) + 'px;top:' + (rect.top - expandArea) + 'px;width:' + (rect.width + expandArea * 2) + 'px;height:' + (rect.height + expandArea * 2) + 'px;"></div>');
	                }
	            }
	            //计算路径距离
	            var distance = 0;
	            //distance = p.getTotalLength(); //SVG路径获取长度
	            var sprotInfo = [];
	            for (var m = 1; m < quArr.length; m++) {
	                //获取距离
	                distance += calculateDistance(quArr[m], quArr[m - 1]);
	                sprotInfo.push({
	                    start: 0,
	                    end: distance,
	                    quadrant: calculateDirection(quArr[m], quArr[m - 1])
	                });
	            }
	            //修改时间为帧数(距离转换为帧)
	            duration = Math.floor(distance);
	            //触发点列表
	            var cuePoints = [];
	            if (parameter.gesture.cuePoints) {
	                for (var i = 0; i < parameter.gesture.cuePoints.length; i++) {
	                    cuePoints.push({
	                        cueStart: Math.floor(parameter.gesture.cuePoints[i].cueStart * duration),
	                        cueEnd: Math.floor(parameter.gesture.cuePoints[i].cueEnd * duration),
	                        valueStart: parameter.gesture.cuePoints[i].valueStart,
	                        valueEnd: parameter.gesture.cuePoints[i].valueEnd,
	                        mouseEnter: false,
	                        mouseLeave: false
	                    });
	                }
	            }

	            //绑定手势事件
	            var historyPoint = null;

	            var startEvent = function startEvent(e) {
	                historyPoint = {
	                    x: hasTouch$1 ? e.changedTouches[0].pageX : e.clientX,
	                    y: hasTouch$1 ? e.changedTouches[0].pageY : e.clientY
	                };
	            };

	            var moveEnd = function moveEnd() {
	                historyPoint = null;
	                //松手后行为(辅助对象ID)
	                if (parameter.gesture.afterTouch > 0) Xut.Assist.Run(parameter.pageType, parameter.gesture.afterTouch, null);
	            };

	            var moveEvent = function moveEvent(e) {
	                var i;
	                var currentPoint = {
	                    x: hasTouch$1 ? e.changedTouches[0].pageX : e.clientX,
	                    y: hasTouch$1 ? e.changedTouches[0].pageY : e.clientY
	                };
	                var d = calculateDistance(currentPoint, historyPoint); //鼠示移动距离
	                var quadrant1 = 0; //对象移动方向
	                for (i = 0; i < sprotInfo.length; i++) {
	                    if (currentFrame <= sprotInfo[i].end) {
	                        quadrant1 = sprotInfo[i].quadrant;
	                        break;
	                    }
	                }
	                var quadrant2 = calculateDirection(currentPoint, historyPoint); //鼠标移动方向
	                switch (quadrant1) {
	                    case "1":
	                    case "2":
	                        if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame + d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame + (currentPoint.x - historyPoint.x);else if (quadrant1 == "1" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame - (currentPoint.y - historyPoint.y);else if (quadrant1 == "2" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
	                        break;
	                    case "3":
	                    case "4":
	                        if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame - (currentPoint.x - historyPoint.x);else if (quadrant1 == "3" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame + (currentPoint.y - historyPoint.y);else if (quadrant1 == "4" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
	                        break;
	                    case "+x":
	                        if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame + d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame + (currentPoint.x - historyPoint.x);
	                        break;
	                    case "-x":
	                        if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame - d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame - (currentPoint.x - historyPoint.x);
	                        break;
	                    case "+y":
	                        if (quadrant2 == "1" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "2" || quadrant2 == "3") currentFrame = currentFrame + d;else if (quadrant2 == "+y" || quadrant2 == "-y") currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
	                        break;
	                    case "-y":
	                        if (quadrant2 == "1" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "2" || quadrant2 == "3") currentFrame = currentFrame - d;else if (quadrant2 == "+y" || quadrant2 == "-y") currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
	                        break;
	                }
	                if (currentFrame <= 0) currentFrame = 0;
	                if (currentFrame >= duration) currentFrame = duration;
	                t1.seek(currentFrame);
	                updateTurnState();
	                historyPoint = currentPoint;
	                //处理触发点列表
	                for (i = 0; i < cuePoints.length; i++) {
	                    if (cuePoints[i].mouseEnter == false && currentFrame >= cuePoints[i].cueStart && currentFrame <= cuePoints[i].cueEnd) {
	                        cuePoints[i].mouseEnter = true;
	                        cuePoints[i].mouseLeave = false;
	                        if (cuePoints[i].valueStart > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueStart, null);
	                        break;
	                    } else if (cuePoints[i].mouseEnter == true && cuePoints[i].mouseLeave == false && (currentFrame < cuePoints[i].cueStart || currentFrame > cuePoints[i].cueEnd)) {
	                        cuePoints[i].mouseEnter = false;
	                        cuePoints[i].mouseLeave = true;
	                        if (cuePoints[i].valueEnd > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueEnd, null);
	                        break;
	                    }
	                }
	            };

	            var objectId = object[0].id;
	            if (parameter.gesture.controlType == 1) {
	                objectId = controlId;
	            }

	            new MoveMent(parameter.pageType, controlId, objectId, startEvent, moveEvent, moveEnd);
	        }
	        //贝赛尔曲线参数构造
	        var bezierObj = {
	            type: "soft",
	            values: quArr,
	            autoRotate: autoRotate
	        };
	        if (isCurve == true) {
	            bezierObj = {
	                curviness: 0, //curviness圆滑度(数字越大越圆滑),默认为1,0是直线运动
	                values: quArr,
	                autoRotate: autoRotate
	            };
	        }
	        //实例化动画参数
	        if (degree == 0) {
	            t1.to(object, duration, {
	                scale: scaleFactor,
	                bezier: bezierObj,
	                repeat: subRepeat,
	                yoyo: autoReverse,
	                onUpdate: updateTurnState,
	                ease: parameter.tweenEase
	            });
	        } else {
	            switch (axis) {
	                default:
	                case 0:
	                    //Z轴
	                    t1.to(object, duration, {
	                        scale: scaleFactor,
	                        rotation: degree + "deg",
	                        bezier: bezierObj,
	                        repeat: subRepeat,
	                        yoyo: autoReverse,
	                        onUpdate: updateTurnState,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case 1:
	                    //X轴
	                    t1.to(object, duration, {
	                        scale: scaleFactor,
	                        rotationX: degree + "deg",
	                        bezier: bezierObj,
	                        repeat: subRepeat,
	                        yoyo: autoReverse,
	                        onUpdate: updateTurnState,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case 2:
	                    //Y轴
	                    t1.to(object, duration, {
	                        scale: scaleFactor,
	                        rotationY: degree + "deg",
	                        bezier: bezierObj,
	                        repeat: subRepeat,
	                        yoyo: autoReverse,
	                        onUpdate: updateTurnState,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	            }
	        }

	        //初始化定位(百分比)
	        if (parameter.gesture && parameter.gesture.initPos > 0) {
	            currentFrame = duration * parameter.gesture.initPos;
	            t1.seek(currentFrame);
	        }

	        return t1;

	        function updateTurnState() {
	            /*var sel=object[0]
	            sel.style.display = 'none';
	            sel.offsetHeight;
	            sel.style.display = 'block';*/
	            if (autoTurn == false) return;
	            var oldOffset = currentOffset;
	            currentOffset = object.offset();
	            if (turnState == "") {
	                if (currentOffset.left > oldOffset.left) {
	                    turnState = "left";
	                } else if (currentOffset.left < oldOffset.left) {
	                    turnState = "right";
	                }
	            } else {
	                if (currentOffset.left > oldOffset.left) {
	                    if (turnState == "right") {
	                        if (currentDegree == 0) currentDegree = 180;else currentDegree = 0;
	                        TweenLite.set(object.children(), {
	                            rotationY: currentDegree
	                        });
	                        turnState = "left";
	                    }
	                } else if (currentOffset.left < oldOffset.left) {
	                    if (turnState == "left") {
	                        if (currentDegree == 0) currentDegree = 180;else currentDegree = 0;
	                        TweenLite.set(object.children(), {
	                            rotationY: currentDegree
	                        });
	                        turnState = "right";
	                    }
	                }
	            }
	        }
	    };
	}

	/**
	 * 旋转类动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function rotate(animproto) {

	    //基本旋转
	    animproto.getEffectSwivel = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical
	        var t1 = null;
	        var easeString = Linear.easeNone;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionHorizontal":
	                    t1.from(object, duration, {
	                        rotationY: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionVertical":
	                    t1.from(object, duration, {
	                        rotationX: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                default:
	                    console.log("getEffectSwivel:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden"
	                }]
	            });
	            switch (direction) {
	                case "DirectionHorizontal":
	                    t1.to(object, duration, {
	                        rotationY: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                case "DirectionVertical":
	                    t1.to(object, duration, {
	                        rotationX: "480deg",
	                        ease: easeString
	                    });
	                    break;
	                default:
	                    console.log("getEffectSwivel:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //陀螺旋转
	    animproto.getEffectSpin = function (parameter, object, duration, delay, repeat) {
	        var degree = parameter.amount ? parameter.amount : 360; //陀螺旋转角度
	        if (Math.abs(parameter.degree) > 0) degree = parameter.degree;
	        if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
	        switch (parameter.centerPos) {
	            case 1:
	                //左上角
	                object.css("-webkit-transform-origin", "left top");
	                break;
	            case 2:
	                //上边中心
	                object.css("-webkit-transform-origin", "center top");
	                break;
	            case 3:
	                //右上角
	                object.css("-webkit-transform-origin", "right top");
	                break;
	            case 4:
	                //左边中心
	                object.css("-webkit-transform-origin", "left cneter");
	                break;
	            case 5:
	                //右边中心
	                object.css("-webkit-transform-origin", "right center");
	                break;
	            case 6:
	                //左下角
	                object.css("-webkit-transform-origin", "left bottom");
	                break;
	            case 7:
	                //下边中心
	                object.css("-webkit-transform-origin", "center bottom");
	                break;
	            case 8:
	                //右下角
	                object.css("-webkit-transform-origin", "right bottom");
	                break;
	            case 0:
	            default:
	                //默认中心0
	                object.css("-webkit-transform-origin", "center");
	                break;
	        }

	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        //t1.to(object, duration, {rotation:degree+"deg",ease:parameter.tweenEase});
	        switch (parameter.axis) {
	            case 1:
	                //X轴
	                t1.to(object, duration, {
	                    rotationX: "+=" + degree + "deg",
	                    ease: parameter.tweenEase
	                });
	                break;
	            case 2:
	                //Y轴
	                t1.to(object, duration, {
	                    rotationY: "+=" + degree + "deg",
	                    ease: parameter.tweenEase
	                });
	                break;
	            case 0: //Z轴
	            default:
	                t1.to(object, duration, {
	                    rotation: "+=" + degree + "deg",
	                    ease: parameter.tweenEase
	                });
	                break;
	        }
	        return t1;
	    };

	    //飞旋
	    animproto.getEffectBoomerang = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var time = duration / 3;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.add(TweenMax.to(object, 0.01, {
	                x: 300,
	                y: -200,
	                rotation: "-60deg"
	            }), "first");
	            t1.add(TweenMax.to(object, time, {
	                autoAlpha: 1,
	                x: 0,
	                y: 0,
	                rotation: "0deg"
	            }), "second");
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "-80deg"
	            }), "second");
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "0deg"
	            }));
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    x: 0,
	                    y: 0,
	                    rotation: "0deg"
	                }]
	            });
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "-80deg"
	            }), "frist");
	            t1.add(TweenMax.to(object, time, {
	                autoAlpha: 0,
	                x: 300,
	                y: -200,
	                rotation: "-60deg"
	            }), "second");
	            t1.add(TweenMax.to(object, time, {
	                rotationY: "0deg"
	            }), "second");
	        }
	        return t1;
	    };

	    //中心旋转
	    animproto.getEffectCenterRevolve = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Power1.easeInOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 100
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 300
	                    }]
	                },
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden"
	                }]
	            });
	            t1.to(object, duration, {
	                bezier: {
	                    type: "cubic",
	                    values: [{
	                        x: 0,
	                        y: 0
	                    }, {
	                        x: 200,
	                        y: 100
	                    }, {
	                        x: 200,
	                        y: 200
	                    }, {
	                        x: 0,
	                        y: 300
	                    }]
	                },
	                ease: easeString
	            });
	        }
	        return t1;
	    };

	    //回旋
	    animproto.getEffectSpinner = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Expo.easeOut;
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                scale: 0,
	                rotation: "180deg",
	                ease: easeString
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden",
	                    scale: 1,
	                    rotation: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                scale: 0,
	                rotation: "180deg",
	                ease: easeString
	            });
	        }
	        return t1;
	    };

	    //旋转(淡出式回旋)
	    animproto.getEffectFadedSwivel = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var easeString = Linear.easeNone;
	        var degree = Math.abs(parameter.degree) > 0 ? Number(parameter.degree) : 90;
	        if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
	        switch (parameter.centerPos) {
	            case 1:
	                //左上角
	                object.css("-webkit-transform-origin", "left top");
	                break;
	            case 2:
	                //上边中心
	                object.css("-webkit-transform-origin", "center top");
	                break;
	            case 3:
	                //右上角
	                object.css("-webkit-transform-origin", "right top");
	                break;
	            case 4:
	                //左边中心
	                object.css("-webkit-transform-origin", "left cneter");
	                break;
	            case 5:
	                //右边中心
	                object.css("-webkit-transform-origin", "right center");
	                break;
	            case 6:
	                //左下角
	                object.css("-webkit-transform-origin", "left bottom");
	                break;
	            case 7:
	                //下边中心
	                object.css("-webkit-transform-origin", "center bottom");
	                break;
	            case 8:
	                //右下角
	                object.css("-webkit-transform-origin", "right bottom");
	                break;
	            case 0:
	            default:
	                //默认中心0
	                object.css("-webkit-transform-origin", "center");
	                break;
	        }
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            //t1.from(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
	            switch (parameter.axis) {
	                case 0:
	                    //Z轴
	                    t1.from(object, duration, {
	                        autoAlpha: 0,
	                        rotation: degree + "deg",
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case 1:
	                    //X轴
	                    t1.from(object, duration, {
	                        autoAlpha: 0,
	                        rotationX: degree + "deg",
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	                case 2: //Y轴
	                default:
	                    t1.from(object, duration, {
	                        autoAlpha: 0,
	                        rotationY: degree + "deg",
	                        ease: easeString,
	                        immediateRender: false
	                    });
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            //t1.to(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
	            switch (parameter.axis) {
	                case 0:
	                    //Z轴
	                    t1.to(object, duration, {
	                        autoAlpha: 0,
	                        rotation: degree + "deg",
	                        ease: easeString
	                    });
	                    break;
	                case 1:
	                    //X轴
	                    t1.to(object, duration, {
	                        autoAlpha: 0,
	                        rotationX: degree + "deg",
	                        ease: easeString
	                    });
	                    break;
	                case 2: //Y轴
	                default:
	                    t1.to(object, duration, {
	                        autoAlpha: 0,
	                        rotationY: degree + "deg",
	                        ease: easeString
	                    });
	                    break;
	            }
	        }
	        return t1;
	    };
	}

	var filter$2 = Xut.style.filter;

	function special(animproto) {

	    //文字动画
	    animproto.getTextAnimation = function (parameter, object, duration, delay, repeat) {
	        if (delay == 0) delay = 0.1; //子对象间延时不能为0
	        var type = parameter.effectType ? parameter.effectType : "text1";
	        var color = parameter.startColor ? parameter.startColor : "";
	        var svgElement = object.find("svg").children();
	        var t1 = new TimelineMax({
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        switch (type) {
	            default:
	            case "text5": //文字逐行蹦出(以行为单位)
	            case "text1":
	                //文字逐个蹦出(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0
	                    }
	                }, delay);
	                break;
	            case "text2":
	                //文字放大出现(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0,
	                        "font-size": 120
	                    },
	                    ease: "Strong.easeOut"
	                }, delay);
	                break;
	            case "text3":
	                //文字缩小出现(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0,
	                        "font-size": 0
	                    },
	                    ease: "Power1.easeIn"
	                }, delay);
	                break;
	            case "text4":
	                //文字渐变出现(以字为单位)
	                t1.staggerFrom(svgElement.children(), duration, {
	                    css: {
	                        'opacity': 0,
	                        "fill": color
	                    },
	                    ease: "Power1.easeIn"
	                }, delay);
	                break;
	        }
	        return t1;
	    };

	    //脉冲
	    animproto.getEffectFlashBulb = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var range = Number(parameter.range) ? parameter.range : 0.1;
	        var time = duration / 2;
	        t1.to(object, time, {
	            autoAlpha: 0.5,
	            scale: "+=" + range
	        }).to(object, time, {
	            autoAlpha: 1,
	            scale: "-=" + range
	        });
	        return t1;
	    };

	    //百叶窗
	    animproto.getEffectBlinds = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical）
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectBlinds
	        });
	        return t1;

	        function updateEffectBlinds() {
	            var num = 6; //分成N等份
	            var progress = t1.progress();
	            var percent = progress / num;
	            var avg = 1 / num;
	            var temp = 0.01; //渐变的过渡区
	            var str = "";
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionHorizontal":
	                        //水平
	                        str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + percent + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
	                        for (var i = 1; i < num; i++) {
	                            str += ",color-stop(" + i * avg + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg + temp) + ",rgba(0,0,0,1))";
	                            str += ",color-stop(" + (i * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg + percent + temp) + ",rgba(0,0,0,0))";
	                        }
	                        str += ")";
	                        break;
	                    case "DirectionVertical":
	                        //垂直
	                        str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + percent + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
	                        for (var j = 1; j < num; j++) {
	                            str += ",color-stop(" + j * avg + ",rgba(0,0,0,0))" + ",color-stop(" + (j * avg + temp) + ",rgba(0,0,0,1))";
	                            str += ",color-stop(" + (j * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (j * avg + percent + temp) + ",rgba(0,0,0,0))";
	                        }
	                        str += ")";
	                        break;
	                    default:
	                        console.log("getEffectBlinds:parameter error.");
	                        break;
	                }
	                object.css("-webkit-mask", str);
	                if (percent >= avg - temp) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionHorizontal":
	                        //水平
	                        str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
	                        for (var n = 1; n < num; n++) {
	                            str += ",color-stop(" + n * avg + ",rgba(0,0,0,1))" + ",color-stop(" + (n * avg - temp) + ",rgba(0,0,0,0))";
	                            str += ",color-stop(" + (n * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (n * avg - percent - temp) + ",rgba(0,0,0,1))";
	                        }
	                        str += ")";
	                        break;
	                    case "DirectionVertical":
	                        //垂直
	                        str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
	                        for (var k = 1; k < num; k++) {
	                            str += ",color-stop(" + k * avg + ",rgba(0,0,0,1))" + ",color-stop(" + (k * avg - temp) + ",rgba(0,0,0,0))";
	                            str += ",color-stop(" + (k * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (k * avg - percent - temp) + ",rgba(0,0,0,1))";
	                        }
	                        str += ")";
	                        break;
	                    default:
	                        console.log("getEffectBlinds:parameter error.");
	                        break;
	                }
	                object.css("-webkit-mask", str);
	                if (percent >= avg - temp) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //劈裂
	    animproto.getEffectSplit = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionVerticalIn、DirectionHorizontalIn、DirectionHorizontalOut、DirectionVerticalOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectSplit
	        });
	        return t1;

	        function updateEffectSplit() {
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                if (progress > 0.9) {
	                    //跳过最后10%（解决iPad的闪问题）
	                    object.css("-webkit-mask", "none");
	                    return;
	                }
	                switch (direction) {
	                    case "DirectionVerticalIn":
	                        //左右向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionHorizontalIn":
	                        //上下向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionHorizontalOut":
	                        //中间向上下展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
	                        break;
	                    case "DirectionVerticalOut":
	                        //中间向左右展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
	                        break;
	                    default:
	                        console.log("getEffectSplit:parameter error.");
	                        break;
	                }
	                //if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                if (progress < 0.1) return; //跳过前面10%（解决iPad的闪问题）
	                switch (direction) {
	                    case "DirectionVerticalIn":
	                        //左右向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
	                        break;
	                    case "DirectionHorizontalIn":
	                        //上下向中间收
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
	                        break;
	                    case "DirectionHorizontalOut":
	                        //中间向上下展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionVerticalOut":
	                        //中间向左右展开
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
	                        break;
	                    default:
	                        console.log("getEffectSplit:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //擦除
	    animproto.getEffectWipe = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(上下左右)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var objInfo = this._getObjectInfo(object);
	        if (isExit == false) {
	            //t1.to(object,duration,{onStart:this._startHandler,onStartParams:[object],onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
	            t1.to(object, duration, {
	                onUpdate: this._updateClipRect,
	                onUpdateParams: [t1, object, isExit, direction, objInfo]
	            });
	        } else {
	            //t1.to(object,duration,{onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
	            t1.to(object, duration, {
	                onUpdate: this._updateClipRect,
	                onUpdateParams: [t1, object, isExit, direction, objInfo]
	            });
	        }
	        return t1;
	    };

	    //翻转式由远及近
	    animproto.getEffectGrowAndTurn = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "90deg",
	                ease: parameter.tweenEase,
	                clearProps: "scale,rotation"
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    scale: 1,
	                    rotation: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "90deg",
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //玩具风车
	    animproto.getEffectPinwheel = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "540deg",
	                ease: parameter.tweenEase
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    scale: 1,
	                    rotation: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                scale: 0,
	                rotation: "540deg",
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //展开/收缩
	    animproto.getEffectExpand = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                rotationY: "45deg",
	                ease: parameter.tweenEase
	            });
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1,
	                    rotationY: "0deg"
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                rotationY: "45deg",
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //浮动
	    animproto.getEffectFloat = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = null;
	        var objInfo = this._getObjectInfo(object);
	        var x, y;
	        if (isExit == false) {
	            x = objInfo.offsetRight + objInfo.width;
	            y = 0 - (objInfo.offsetTop + objInfo.height);
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            t1.from(object, duration, {
	                autoAlpha: 0,
	                rotation: "-45deg",
	                x: x,
	                y: y,
	                ease: parameter.tweenEase
	            });
	        } else {
	            x = objInfo.offsetRight + objInfo.width;
	            y = 0 - (objInfo.offsetTop + objInfo.height);
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            t1.to(object, duration, {
	                autoAlpha: 0,
	                rotation: "-45deg",
	                x: x,
	                y: y,
	                ease: parameter.tweenEase
	            });
	        }
	        return t1;
	    };

	    //字幕式
	    animproto.getEffectCredits = function (parameter, object, isExit, duration, delay, repeat) {
	        var objInfo = this._getObjectInfo(object);
	        var y = 0,
	            top = 0;
	        if (isExit == false) {
	            //从下往上移
	            y = 0 - (this.screenHeight + objInfo.height);
	            top = objInfo.top + objInfo.offsetBottom + objInfo.height;
	        } else {
	            //从上往下移
	            y = this.screenHeight + objInfo.height;
	            top = objInfo.top - (objInfo.offsetTop + objInfo.height);
	        }
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible",
	                top: top + "px"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            y: y,
	            ease: parameter.tweenEase
	        });
	        return t1;
	    };

	    //弹跳
	    animproto.getEffectBounce = function (parameter, object, isExit, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var objInfo = this._getObjectInfo(object);

	        var time2, time3, time4, time5, y1, y2, y3, y4, lastY, height, time1, total, width;

	        if (isExit == false) {
	            total = duration;
	            time1 = total / 5;
	            time2 = total / 10;
	            time3 = total / 20;
	            time4 = total / 40;
	            time5 = total / 80;
	            width = 50 + 20 + 10 + 5 + 2.5 + 1 + 0.5 + 0.2 + 0.1;
	            height = this.screenHeight / 4;
	            y1 = height / 2;
	            y2 = height / 4;
	            y3 = height / 8;
	            y4 = height / 16;
	            lastY = objInfo.offsetBottom - height + objInfo.height;

	            t1.to(object, 0.01, {
	                x: -width,
	                y: -height
	            }).to(object, time1, {
	                x: "+=50",
	                y: "+=" + height,
	                ease: Circ.easeIn
	            }) //慢到快
	            .to(object, time1, {
	                x: "+=20",
	                y: "-=" + y1,
	                scaleY: 0.8,
	                ease: Circ.easeOut
	            }) //快到慢
	            .to(object, time1, {
	                x: "+=10",
	                y: "+=" + y1,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time2, {
	                x: "+=5",
	                y: "-=" + y2,
	                scaleY: 0.85,
	                ease: Circ.easeOut
	            }).to(object, time2, {
	                x: "+=2.5",
	                y: "+=" + y2,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time3, {
	                x: "+=1",
	                y: "-=" + y3,
	                scaleY: 0.9,
	                ease: Circ.easeOut
	            }).to(object, time3, {
	                x: "+=0.5",
	                y: "+=" + y3,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time4, {
	                x: "+=0.2",
	                y: "-=" + y4,
	                scaleY: 0.95,
	                ease: Circ.easeOut
	            }).to(object, time4, {
	                x: "+=0.1",
	                y: "+=" + y4,
	                scaleY: 1,
	                ease: Circ.easeIn,
	                clearProps: "x,y"
	            });
	            return t1;
	        } else {
	            total = duration;
	            time1 = total / 5;
	            time2 = total / 10;
	            time3 = total / 20;
	            time4 = total / 40;
	            time5 = total / 80;
	            height = this.screenHeight / 4;
	            y1 = height / 2;
	            y2 = height / 4;
	            y3 = height / 8;
	            y4 = height / 16;
	            lastY = objInfo.offsetBottom - height + objInfo.height;
	            t1.to(object, time1, {
	                x: "+=50",
	                y: "+=" + height,
	                ease: Circ.easeIn
	            }) //慢到快
	            .to(object, time1, {
	                x: "+=20",
	                y: "-=" + y1,
	                scaleY: 0.8,
	                ease: Circ.easeOut
	            }) //快到慢
	            .to(object, time1, {
	                x: "+=10",
	                y: "+=" + y1,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time2, {
	                x: "+=5",
	                y: "-=" + y2,
	                scaleY: 0.85,
	                ease: Circ.easeOut
	            }).to(object, time2, {
	                x: "+=2.5",
	                y: "+=" + y2,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time3, {
	                x: "+=1",
	                y: "-=" + y3,
	                scaleY: 0.9,
	                ease: Circ.easeOut
	            }).to(object, time3, {
	                x: "+=0.5",
	                y: "+=" + y3,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time4, {
	                x: "+=0.2",
	                y: "-=" + y4,
	                scaleY: 0.95,
	                ease: Circ.easeOut
	            }).to(object, time4, {
	                x: "+=0.1",
	                y: "+=" + y4,
	                scaleY: 1,
	                ease: Circ.easeIn
	            }).to(object, time5, {
	                x: "+=0.1",
	                y: "+=" + lastY,
	                ease: Circ.easeIn
	            });
	        }
	        return t1;
	    };

	    //彩色脉冲
	    animproto.getEffectFlicker = function (parameter, object, duration, delay, repeat) {
	        if (!(filter$2 in object[0].style)) return new TimelineMax();
	        //if (repeat < 2) repeat = 2; //默认三次
	        var color2 = parameter.color2 ? parameter.color2 : "#fff"; //颜色
	        var maxGlowSize = parameter.maxGlowSize ? parameter.maxGlowSize : 0.1; //光晕最大尺寸(百分比)
	        var minGlowSize = parameter.minGlowSize ? parameter.minGlowSize : 0.05; //光晕最小尺寸(百分比)
	        var size = object.width() > object.height() ? object.height() : object.width();
	        var maxSize = maxGlowSize * size;
	        var minSize = minGlowSize * size;
	        var opacity = Number(parameter.opacity) ? parameter.opcity : 0.75; //不透明度
	        var distance = Number(parameter.distance) ? parameter.distance * size : 0; //距离
	        var color = colorHexToRGB(color2, opacity);
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                //"box-shadow": "none"
	                filter: "none"
	            }]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectFlicker
	        });
	        return t1;

	        function updateEffectFlicker() {
	            var progress = t1.progress();
	            var percent = parseInt(progress * (maxSize - minSize));
	            if (progress > 0.5) percent = parseInt((1 - progress) * (maxSize - minSize));
	            //object.css("box-shadow", distance + "px " + distance + "px " + minSize + "px " + (minSize + percent) + "px " + color);
	            object.css(filter$2, "drop-shadow(" + color + " " + distance + "px " + distance + "px " + (minSize + percent) + "px)");
	        }
	    };

	    //跷跷板
	    animproto.getEffectTeeter = function (parameter, object, duration, delay, repeat) {
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        // var mode = parameter.mode;
	        var range = Number(parameter.range) ? parameter.range : 0.02;
	        var time = duration / 8; //计算指定动画时间内每次运动时间(总时长不变，循环除外)
	        switch (parameter.mode) {
	            case 1:
	                //左右移动
	                range = range * object.width();
	                t1.to(object, time, {
	                    x: -range
	                }).to(object, time * 2, {
	                    x: range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    x: -range
	                });
	                t1.to(object, time * 2, {
	                    x: range
	                });
	                //}
	                t1.to(object, time, {
	                    x: 0
	                });
	                break;
	            case 2:
	                //上下移动
	                range = range * object.height();
	                t1.to(object, time, {
	                    y: -range
	                }).to(object, time * 2, {
	                    y: range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    y: -range
	                });
	                t1.to(object, time * 2, {
	                    y: range
	                });
	                //}
	                t1.to(object, time, {
	                    y: 0
	                });
	                break;
	            case 3:
	                //左右挤压
	                t1.to(object, time, {
	                    scaleX: 1 + range
	                }).to(object, time * 2, {
	                    scaleX: 1 - range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    scaleX: 1 + range
	                });
	                t1.to(object, time * 2, {
	                    scaleX: 1 - range
	                });
	                //}
	                t1.to(object, time, {
	                    scaleX: 1
	                });
	                break;
	            case 4:
	                //上下挤压
	                t1.to(object, time, {
	                    scaleY: 1 + range
	                }).to(object, time * 2, {
	                    scaleY: 1 - range
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    scaleY: 1 + range
	                });
	                t1.to(object, time * 2, {
	                    scaleY: 1 - range
	                });
	                //}
	                t1.to(object, time, {
	                    scaleY: 1
	                });
	                break;
	            case 0: //左右晃晃
	            default:
	                range = range * 100;
	                t1.to(object, time, {
	                    rotation: range + "deg"
	                }).to(object, time * 2, {
	                    rotation: -range + "deg"
	                });
	                //for (var i = 1; i < repeat; i++) {
	                t1.to(object, time * 2, {
	                    rotation: range + "deg"
	                });
	                t1.to(object, time * 2, {
	                    rotation: -range + "deg"
	                });
	                //}
	                t1.to(object, time, {
	                    rotation: "0deg"
	                });
	                break;
	        }
	        return t1;
	    };

	    //补色
	    animproto.getEffectComplementaryColor = function (parameter, object, duration, delay, repeat) {
	        var zIndex = Number(object.css("z-index"));
	        if (isNaN(zIndex)) {
	            zIndex = 10;
	            console.log("The Z-index property for this object to get error.");
	        }
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                "z-Index": zIndex + 100
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object, {
	                "z-Index": zIndex
	            }]
	        });
	        t1.to(object, duration, {
	            autoAlpha: 1
	        });
	        return t1;
	    };

	    //rect切割效果更新
	    animproto._updateClipRect = function (t1, object, isExit, direction, objInfo) {
	        var progress = t1.progress();
	        var len = progress;
	        var width, left, top, height;
	        if (isExit == false) {
	            top = objInfo.height * (1 - len);
	            height = objInfo.height - top;
	            left = objInfo.width * (1 - len);
	            width = objInfo.width - left;
	            switch (direction) {
	                case "DirectionUp":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
	                    break;
	                case "DirectionDown":
	                    object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
	                    break;
	                case "DirectionLeft":
	                    object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
	                    break;
	                case "DirectionRight":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
	                    break;
	                default:
	                    console.log("_updateClipRect:parameter error.");
	                    break;
	            }
	        } else {
	            top = objInfo.height * len;
	            height = objInfo.height - top;
	            left = objInfo.width * len;
	            width = objInfo.width - left;
	            switch (direction) {
	                case "DirectionUp":
	                    object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
	                    break;
	                case "DirectionDown":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
	                    break;
	                case "DirectionLeft":
	                    object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
	                    break;
	                case "DirectionRight":
	                    object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
	                    break;
	                default:
	                    console.log("_updateClipRect:parameter error.");
	                    break;
	            }
	        }
	    };
	}

	/**
	 * 缩放类动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function zoom(animproto) {

	    //基本缩放
	    animproto.getEffectZoom = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(放大:DirectionIn、屏幕中心放大:DirectionInCenter、轻微放大:DirectionInSlightly、缩小:DirectionOut、屏幕底部缩小:DirectionOutBottom、轻微缩小:DirectionOutSlightly)
	        var t1 = null;
	        var result;
	        object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
	        if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object, {
	                    visibility: "visible"
	                }],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionIn":
	                    t1.from(object, duration, {
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInCenter":
	                    result = this._getDirectionInCenter(object);
	                    t1.from(object, duration, {
	                        scale: 0,
	                        x: result.x,
	                        y: result.y,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInSlightly":
	                    t1.from(object, duration, {
	                        scale: 0.7,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOut":
	                    t1.from(object, duration, {
	                        scale: 3,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutBottom":
	                    //屏幕底部缩小(理解为底部的中间开始)
	                    t1.from(object, duration, {
	                        scale: 2,
	                        top: this.screenWidth + "px",
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutSlightly":
	                    t1.from(object, duration, {
	                        scale: 1.5,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectZoom:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    visibility: "hidden"
	                }]
	            });
	            switch (direction) {
	                case "DirectionIn":
	                    t1.to(object, duration, {
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInCenter":
	                    result = this._getDirectionInCenter(object);
	                    t1.to(object, duration, {
	                        scale: 0,
	                        x: result.x,
	                        y: result.y,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionInSlightly":
	                    t1.to(object, duration, {
	                        scale: 0.7,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOut":
	                    t1.to(object, duration, {
	                        scale: 3,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutBottom":
	                    t1.to(object, duration, {
	                        scale: 2,
	                        top: this.screenHeight + "px",
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutSlightly":
	                    t1.to(object, duration, {
	                        scale: 1.5,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectZoom:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //缩放 淡出式缩放
	    animproto.getEffectFadedZoom = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(对象中心DirectionIn、幻灯片中心DirectionInCenter)
	        var t1 = null;
	        object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
	        var svgElement = object.find("svg"); //获取SVG对象
	        if (svgElement) svgElement.css('-webkit-transform', 'translate3d(0px, 0px, 0px)'); //解决SVG文字错乱问题

	        var keepRatio = parameter.keepRatio == 0 ? false : true; //保持长宽比
	        var fullScreen = parameter.fullScreen == 1 ? true : false; //缩放到全屏
	        var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
	        var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
	        var result;
	        if (fullScreen == true) {
	            //计算比例
	            var xScale = this.screenWidth / object.width();
	            var yScale = this.screenHeight / object.height();
	            var scaleValue = xScale;
	            if (xScale > yScale) scaleValue = yScale;
	            result = this._getDirectionInCenter(object);
	            if (isExit == false) {
	                t1 = new TimelineMax({
	                    delay: delay,
	                    repeat: repeat,
	                    onStart: this._startHandler,
	                    onStartParams: [parameter, object, {
	                        opacity: 0
	                    }],
	                    onComplete: this._completeHandler,
	                    onCompleteParams: [parameter, object]
	                });
	                t1.to(object, duration, {
	                    x: result.x,
	                    y: result.y,
	                    autoAlpha: 1,
	                    scale: scaleValue,
	                    ease: parameter.tweenEase
	                });
	            } else {
	                t1 = new TimelineMax({
	                    delay: delay,
	                    repeat: repeat,
	                    onStart: this._startHandler,
	                    onStartParams: [parameter, object],
	                    onComplete: this._completeHandler,
	                    onCompleteParams: [parameter, object]
	                });
	                t1.to(object, duration, {
	                    x: result.x,
	                    y: result.y,
	                    autoAlpha: 0,
	                    scale: scaleValue,
	                    ease: parameter.tweenEase
	                });
	            }
	        } else if (isExit == false) {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object]
	            });
	            switch (direction) {
	                case "DirectionIn":
	                    if (keepRatio == true) t1.from(object, duration, {
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });else {
	                        t1.from(object, duration, {
	                            autoAlpha: 0,
	                            scaleX: scaleX,
	                            scaleY: scaleY,
	                            ease: parameter.tweenEase
	                        });
	                    }
	                    break;
	                case "DirectionInCenter":
	                    result = this._getDirectionInCenter(object);
	                    if (keepRatio == true) t1.from(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });else t1.from(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scaleX: scaleX,
	                        scaleY: scaleY,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectFadedZoom:parameter error.");
	                    break;
	            }
	        } else {
	            t1 = new TimelineMax({
	                delay: delay,
	                repeat: repeat,
	                onStart: this._startHandler,
	                onStartParams: [parameter, object],
	                onComplete: this._completeHandler,
	                onCompleteParams: [parameter, object, {
	                    opacity: 1
	                }]
	            });
	            switch (direction) {
	                case "DirectionOut":
	                    if (keepRatio == true) t1.to(object, duration, {
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase,
	                        clearProps: "scale"
	                    });else t1.to(object, duration, {
	                        autoAlpha: 0,
	                        scaleX: scaleX,
	                        scaleY: scaleY,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                case "DirectionOutCenter":
	                    result = this._getDirectionInCenter(object);
	                    if (keepRatio == true) t1.to(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scale: 0,
	                        ease: parameter.tweenEase
	                    });else t1.to(object, duration, {
	                        x: result.x,
	                        y: result.y,
	                        autoAlpha: 0,
	                        scaleX: scaleX,
	                        scaleY: scaleY,
	                        ease: parameter.tweenEase
	                    });
	                    break;
	                default:
	                    console.log("getEffectFadedZoom:parameter error.");
	                    break;
	            }
	        }
	        return t1;
	    };

	    //放大/缩小
	    animproto.getEffectGrowShrink = function (parameter, object, duration, delay, repeat) {
	        var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
	        var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
	        // var keepRatio = (parameter.keepRatio == 0) ? false : true; //保持长宽比
	        var fullScreen = parameter.fullScreen == 1 ? true : false; //缩放到全屏
	        var resetSize = parameter.resetSize == 1 ? true : false; //恢复默认尺寸
	        var easeString = Linear.easeNone; //Elastic.easeOut
	        if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        if (fullScreen == true) {
	            //计算比例
	            var xScale = this.screenWidth / object.width();
	            var yScale = this.screenHeight / object.height();
	            var scaleValue = xScale;
	            if (xScale > yScale) scaleValue = yScale;
	            var result = this._getDirectionInCenter(object);
	            t1.to(object, duration, {
	                x: result.x,
	                y: result.y,
	                scale: scaleValue,
	                ease: parameter.tweenEase
	            });
	        } else if (resetSize == true) {
	            t1.to(object, duration, {
	                scaleX: 1,
	                scaleY: 1,
	                ease: easeString
	            });
	        } else t1.to(object, duration, {
	            scaleX: scaleX,
	            scaleY: scaleY,
	            ease: easeString
	        });
	        return t1;
	    };

	    /**
	     * 获取对象至屏幕中心的距离
	     * @param  {[type]} object [description]
	     * @return {[type]}        [description]
	     */
	    animproto._getDirectionInCenter = function (object) {
	        var objInfo = this._getObjectInfo(object);
	        var x = Math.round(this.screenWidth / 2 - objInfo.offsetLeft - objInfo.width / 2);
	        var y = Math.round(this.screenHeight / 2 - objInfo.offsetTop - objInfo.height / 2);
	        return {
	            x: x,
	            y: y
	        };
	    };
	}

	/**
	 * 形状动画
	 * @param  {[type]} animproto [description]
	 * @return {[type]}           [description]
	 */
	function shape(animproto) {

	    //形状一(圆)
	    animproto.getEffectCircle = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var result = this._getObjectInfo(object);
	        var radius = Math.ceil(Math.sqrt(result.width * result.width / 4 + result.height * result.height / 4));
	        switch (direction) {
	            case "DirectionIn": //放大
	            case "DirectionOut":
	                //缩小
	                if (isExit == false) {
	                    t1.to(object, duration, {
	                        onUpdate: updateCircleGradient
	                    });
	                } else {
	                    t1.to(object, duration, {
	                        onUpdate: updateCircleGradient
	                    });
	                }
	                break;
	            default:
	                console.log("getEffectCircle:parameter error.");
	                break;
	        }
	        return t1;

	        function updateCircleGradient() {
	            var progress = t1.progress();
	            var len = parseInt(progress * radius);
	            if (isExit == false) switch (direction) {
	                case "DirectionIn":
	                    //DirectionIn放大
	                    object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,1)),to(rgba(0,0,0,0)),color-stop(10%,rgba(0,0,0,0)))");
	                    if (len == radius) object.css("-webkit-mask", "none");
	                    break;
	                case "DirectionOut":
	                    //DirectionOut缩小
	                    object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,1)), to(rgba(0,0,0,0)), color-stop(90%, rgba(0,0,0,1)))");
	                    if (len == radius) object.css("-webkit-mask", "none");
	                    break;
	            } else {
	                switch (direction) {
	                    case "DirectionIn":
	                        //DirectionIn放大
	                        object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,0)),to(rgba(0,0,0,1)),color-stop(10%,rgba(0,0,0,1)))");
	                        if (len == radius) {
	                            //object.css("opacity","0");
	                            object.css("visibility", "hidden");
	                            object.css("-webkit-mask", "none");
	                        }
	                        break;
	                    case "DirectionOut":
	                        //DirectionOut缩小
	                        object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,0)), to(rgba(0,0,0,1)), color-stop(90%, rgba(0,0,0,0)))");
	                        if (len == radius) {
	                            //object.css("opacity","0");
	                            object.css("visibility", "hidden");
	                            object.css("-webkit-mask", "none");
	                        }
	                        break;
	                }
	            }
	        }
	    };

	    //形状二(方框)
	    animproto.getEffectBox = function (parameter, object, isExit, duration, delay, repeat) {
	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        if (this.useMask == false) direction = "DirectionOut";

	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        var objInfo = this._getObjectInfo(object);
	        t1.to(object, duration, {
	            onUpdate: updateEffectBox
	        });
	        return t1;

	        function updateEffectBox() {
	            var width, height, left, top;
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionOut":
	                        top = objInfo.height * (0.5 - percent);
	                        height = objInfo.height - top;
	                        left = objInfo.width * (0.5 - percent);
	                        width = objInfo.width - left;
	                        object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    case "DirectionOut":
	                        top = objInfo.height * percent;
	                        height = objInfo.height - top;
	                        left = objInfo.width * percent;
	                        width = objInfo.width - left;
	                        object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //形状三(菱形)
	    animproto.getEffectDiamond = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        // var objInfo = this._getObjectInfo(object);
	        t1.to(object, duration, {
	            onUpdate: updateEffectBox
	        });
	        return t1;

	        function updateEffectBox() {
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionOut":
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionOut":
	                    case "DirectionIn":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
	                        break;
	                    default:
	                        console.log("getEffectBox:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };

	    //形状四(加号)
	    animproto.getEffectPlus = function (parameter, object, isExit, duration, delay, repeat) {
	        if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

	        var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
	        var t1 = new TimelineMax({
	            delay: delay,
	            repeat: repeat,
	            onStart: this._startHandler,
	            onStartParams: [parameter, object, {
	                visibility: "visible"
	            }],
	            onComplete: this._completeHandler,
	            onCompleteParams: [parameter, object]
	        });
	        t1.to(object, duration, {
	            onUpdate: updateEffectPlus
	        });
	        return t1;

	        function updateEffectPlus() {
	            var progress = t1.progress();
	            var percent = progress / 2;
	            if (isExit == false) {
	                switch (direction) {
	                    case "DirectionIn":
	                    case "DirectionOut":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))");
	                        break;
	                    default:
	                        console.log("getEffectPlus:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) object.css("-webkit-mask", "none");
	            } else {
	                switch (direction) {
	                    case "DirectionIn":
	                    case "DirectionOut":
	                        object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + percent + ",transparent),color-stop(" + percent + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + percent + ",transparent),color-stop(" + percent + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))");
	                        break;
	                    default:
	                        console.log("getEffectPlus:parameter error.");
	                        break;
	                }
	                if (percent >= 0.5) {
	                    //object.css("opacity","0");
	                    object.css("visibility", "hidden");
	                    object.css("-webkit-mask", "none");
	                }
	            }
	        }
	    };
	}

	var ROUND = Math.round;
	var CEIL$2 = Math.ceil;

	var isMacOS = Xut.plat.isMacOS;
	var isDesktop = Xut.plat.isDesktop;

	/**
	 * 参数说明
	 * pageType: 页面类型
	 * chapterId: 当前页ID
	 * element: 动画对象
	 * parameter: 动画参数数组
	 * container: 父容器
	 * hasLoop: 是否循环动画
	 * startEvent: 整个动画开始事件
	 * completeEvent: 整个动画结束事件
	 **/

	var Powepoint = function () {
	    function Powepoint(pageIndex, pageType, chapterId, element, parameter, container) {
	        classCallCheck(this, Powepoint);


	        if (_.isArray(parameter) && parameter.length) {
	            this.options = parameter;
	        } else {
	            console.log("Animation options error is not Array.");
	            return;
	        }

	        this.screenWidth = config.viewSize.width;
	        this.screenHeight = config.viewSize.height;
	        this.container = container || $(document.body); //父容器(主要用于手势控制路径动画)
	        this.isDebug = false; //是否显示调试信息

	        this.pageIndex = pageIndex;
	        this.pageType = pageType;
	        this.chapterId = chapterId;
	        this.element = element;

	        /**
	         * 动画对象默认样式
	         * @type {String}
	         */
	        this.elementStyle = '';

	        /**
	         * 初始化后对象状态
	         * @type {String}
	         */
	        this.elementVisibility = 'visible';

	        /**
	         * 是否使用CSS渐变效果
	         * @type {[type]}
	         */
	        this.useMask = isDesktop || isMacOS ? true : false;

	        /**
	         * 第一个动画参数（默认支持多个动画作用于一个对象）
	         * @type {[type]}
	         */
	        this.parameter0 = null;

	        /**
	         * 第一个动画类型（进入/退出）
	         * @type {Boolean}
	         */
	        this.isExit0 = false;

	        /**
	         * 动画前脚本
	         * @type {String}
	         */
	        this.preCode = '';

	        /**
	         * 动画后脚本
	         * @type {String}
	         */
	        this.postCode = '';

	        /**
	         * 延时
	         * @type {Number}
	         */
	        this.codeDelay = 0;

	        /**
	         * 是否完全执行过(用于解决重复执行问题)
	         * @type {Boolean}
	         */
	        this.isCompleted = false;

	        /**
	         * 初始对象状态:opacity(visibility)
	         */
	        this._initElement();
	    }

	    /**
	     * 解析脚本代码
	     * 包装能函数
	     * @return {[type]} [description]
	     */


	    createClass(Powepoint, [{
	        key: '_parseCode',
	        value: function _parseCode(code1, code2) {
	            if (code1 && code1.length > 0) {
	                return makeJsonPack(code1);
	            } else if (code2 && code2.length > 0) {
	                return makeJsonPack(code2);
	            }
	        }

	        /**
	         * 解析延时脚本
	         * @param  {[type]} code1 [description]
	         * @param  {[type]} code2 [description]
	         * @return {[type]}       [description]
	         */

	    }, {
	        key: '_parseDelayCode',
	        value: function _parseDelayCode(code1, code2) {
	            if (code1 && code1.length > 0) {
	                return code1;
	            } else if (code2 && code2.length > 0) {
	                return code2;
	            }
	        }

	        /**
	         * 根据数据库的设置
	         * 对象初始化(visibility)
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initElement',
	        value: function _initElement() {

	            var data = this.options[0];
	            this.parameter0 = parseJSON(data.parameter);

	            //为高级动画修改增加
	            //2016.3.16
	            this.parameter0.pageType = this.pageType;
	            this.parameter0.pageIndex = this.pageIndex;

	            this.isExit0 = this.parameter0.exit ? this.parameter0.exit.toLowerCase() == "true" : false;

	            //获取动画前脚本
	            this.preCode = this._parseCode(data.preCode, this.parameter0.preCode);

	            //获取动画后脚本
	            this.postCode = this._parseCode(data.postCode, this.parameter0.postCode);

	            //获取延时时间
	            this.codeDelay = this._parseDelayCode(data.codeDelay, this.parameter0.codeDelay);

	            //给元素增加ppt属性标记
	            if (!this.element.attr("data-pptAnimation")) {
	                var animationName = data.animationName;

	                //路径动画对象默认显示
	                if (animationName.indexOf("EffectPath") == 0 || animationName == "EffectCustom") {
	                    this.element.css("visibility", "visible");
	                } else {
	                    switch (animationName) {
	                        //强调动画默认显示
	                        case "EffectFlashBulb": //脉冲
	                        case "EffectFlicker": //彩色脉冲
	                        case "EffectTeeter": //跷跷板
	                        case "EffectSpin": //陀螺旋转
	                        case "EffectGrowShrink": //放大/缩小
	                        case "EffectDesaturate": //不饱和
	                        case "EffectDarken": //加深
	                        case "EffectLighten": //变淡
	                        case "EffectTransparency": //透明
	                        case "EffectColorBlend": //对象颜色
	                        case "EffectComplementaryColor": //补色
	                        case "EffectChangeLineColor": //线条颜色
	                        case "EffectChangeFillColor": //填允颜色
	                        case "EffectFlashOnce":
	                            //闪烁(一次)
	                            this.element.css("visibility", "visible");
	                            break;
	                        case "EffectCredits":
	                            //字幕式特殊处理
	                            this.element.css("visibility", "hidden");
	                            break;
	                        default:
	                            if (this.isExit0) this.element.css("visibility", "visible"); //退出动画默认显示
	                            else this.element.css("visibility", "hidden"); //进入动画默认隐藏
	                            break;
	                    }
	                }

	                //标识初始化状态
	                this.element.attr("data-pptAnimation", true);
	                this.elementStyle = this.element[0].style.cssText;
	                this.elementVisibility = this.element.css("visibility");
	            }
	        }

	        /**
	         * 获取对象相关信息
	         * @param  {[type]} object [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_getObjectInfo',
	        value: function _getObjectInfo(object) {
	            var width = ROUND(object.width()); //四舍五入取整
	            var height = ROUND(object.height());
	            var top = ROUND(parseInt(object.css("top")));
	            var left = ROUND(parseInt(object.css("left")));
	            var offsetTop = ROUND(object.offset().top);

	            if (object.attr("offsetTop")) {
	                offsetTop = parseInt(object.attr("offsetTop"));
	            } else {
	                object.attr("offsetTop", offsetTop);
	            }

	            var offsetBottom = CEIL$2(this.screenHeight - offsetTop - height);
	            var offsetLeft = ROUND(object.offset().left);
	            if (object.attr("offsetLeft")) {
	                offsetLeft = parseInt(object.attr("offsetLeft"));
	            } else {
	                object.attr("offsetLeft", offsetLeft);
	            }
	            var offsetRight = CEIL$2(this.screenWidth - offsetLeft - width);

	            return {
	                width: width,
	                height: height,
	                top: top,
	                left: left,
	                offsetTop: offsetTop,
	                offsetLeft: offsetLeft,
	                offsetBottom: offsetBottom,
	                offsetRight: offsetRight
	            };
	        }

	        /**
	         * 子动画通用开始事件
	         * @param  {[type]} parameter [description]
	         * @param  {[type]} object    [description]
	         * @param  {[type]} params    [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_startHandler',
	        value: function _startHandler(parameter, object, params) {
	            for (var item in params) {
	                switch (item) {
	                    case "x":
	                        TweenLite.set(object, {
	                            x: params[item]
	                        });
	                        break;
	                    case "y":
	                        TweenLite.set(object, {
	                            y: params[item]
	                        });
	                        break;
	                    case "rotation":
	                        TweenLite.set(object, {
	                            rotation: params[item]
	                        });
	                        break;
	                    case "rotationX":
	                        TweenLite.set(object, {
	                            rotationX: params[item]
	                        });
	                        break;
	                    case "rotationY":
	                        TweenLite.set(object, {
	                            rotationY: params[item]
	                        });
	                        break;
	                    case "scale":
	                        TweenLite.set(object, {
	                            scale: params[item]
	                        });
	                        break;
	                    default:
	                        object.css(item, params[item]);
	                        break;
	                }
	            }

	            //ppt动画音频
	            if (parameter.videoId > 0) {
	                createContentAudio(parameter.chapterId, parameter.videoId);
	            }

	            /*eslint-disable */

	            //ppt动画扩展处理
	            if (parameter.pptanimation && parameter.pptanimation.pptapi) {

	                var params = parameter.pptanimation.parameters ? parameter.pptanimation.parameters : {};
	                switch (parameter.pptanimation.pptapi) {
	                    case "bonesWidget":
	                        //骨骼动画
	                        bonesWidget.updateAction(object.attr("id"), params.actList);
	                        break;
	                    case "spiritWidget":
	                        // if (window.spiritWidget) {
	                        updateAction(object.attr("id"), params);
	                        // }
	                        break;
	                }
	            }

	            /*eslint-enable */
	        }

	        /**
	         * 子动画通用结束事件
	         * @param  {[type]} parameter [description]
	         * @param  {[type]} object    [description]
	         * @param  {[type]} params    [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_completeHandler',
	        value: function _completeHandler(parameter, object, params) {
	            //if(parameter.pptAudio) parameter.pptAudio.end(); //声音存在延时问题，马上结束可导制无法听到声音
	            for (var item in params) {
	                switch (item) {
	                    case "x":
	                        TweenLite.set(object, {
	                            x: params[item]
	                        });
	                        break;
	                    case "y":
	                        TweenLite.set(object, {
	                            y: params[item]
	                        });
	                        break;
	                    case "rotation":
	                        TweenLite.set(object, {
	                            rotation: params[item]
	                        });
	                        break;
	                    case "rotationX":
	                        TweenLite.set(object, {
	                            rotationX: params[item]
	                        });
	                        break;
	                    case "rotationY":
	                        TweenLite.set(object, {
	                            rotationY: params[item]
	                        });
	                        break;
	                    case "scale":
	                        TweenLite.set(object, {
	                            scale: params[item]
	                        });
	                        break;
	                    default:
	                        object.css(item, params[item]);
	                        break;
	                }
	            }
	        }

	        /**
	         * 返回动画对象
	         * @param  {[type]} data  [description]
	         * @param  {[type]} index [description]
	         * @return {[type]}       [description]
	         */

	    }, {
	        key: '_getTimeline',
	        value: function _getTimeline(data, index) {
	            var object = this.element;
	            var parameter = this.parameter0;
	            var isExit = this.isExit0;
	            if (index > 0 || this.parameter0 == null) {
	                parameter = parseJSON(data.parameter);
	                isExit = parameter.exit ? parameter.exit.toLowerCase() == "true" : false; //false:进入 true:消失
	                if (index == 0) {
	                    this.parameter0 = parameter;
	                    this.isExit0 = isExit;
	                }
	            }
	            var duration = data.speed / 1000; //执行时间
	            var delay = data.delay / 1000; //延时时间
	            if (navigator.epubReadingSystem) {
	                //如果是epub阅读器则动画延时0.15秒
	                delay += 0.15;
	            }
	            var repeat = data.repeat >= 0 ? data.repeat - 1 : 0; //重复次数
	            parameter.pageType = this.pageType;
	            parameter.chapterId = this.chapterId;
	            parameter.animationName = data.animationName;
	            //赋给动画音频Id
	            parameter.videoId = data.videoId;

	            var animationName = parameter.animationName;

	            //文字动画
	            if (animationName == "xxtTextEffect") {
	                return this.getTextAnimation(parameter, object, duration, delay, repeat);
	            }

	            //路径动画
	            if (animationName.indexOf("EffectPath") == 0 || animationName == "EffectCustom") {
	                return this.getPathAnimation(parameter, object, duration, delay, repeat);
	            }

	            switch (animationName) {
	                case "EffectFade":
	                    //淡出
	                    return this.getEffectFade(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFly":
	                    //飞入/飞出
	                    return this.getEffectFly(parameter, object, isExit, duration, delay, repeat);
	                case "EffectAscend":
	                    //浮入/浮出(上升)
	                    return this.getEffectAscend(parameter, object, isExit, duration, delay, repeat);
	                case "EffectDescend":
	                    //浮入/浮出(下降)
	                    return this.getEffectDescend(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSplit":
	                    //劈裂(分割)
	                    return this.getEffectSplit(parameter, object, isExit, duration, delay, repeat);
	                case "EffectWipe":
	                    //擦除
	                    return this.getEffectWipe(parameter, object, isExit, duration, delay, repeat);
	                case "EffectCircle":
	                    //形状一(圆)
	                    return this.getEffectCircle(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBox":
	                    //形状二(方框)
	                    return this.getEffectBox(parameter, object, isExit, duration, delay, repeat);
	                case "EffectDiamond":
	                    //形状三(菱形)
	                    return this.getEffectDiamond(parameter, object, isExit, duration, delay, repeat);
	                case "EffectPlus":
	                    //形状四(加号)
	                    return this.getEffectPlus(parameter, object, isExit, duration, delay, repeat);
	                case "EffectGrowAndTurn":
	                    //翻转式由远及近
	                    return this.getEffectGrowAndTurn(parameter, object, isExit, duration, delay, repeat);
	                case "EffectZoom":
	                    //基本缩放
	                    return this.getEffectZoom(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFadedZoom":
	                    //淡出式缩放
	                    return this.getEffectFadedZoom(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSwivel":
	                    //基本旋转
	                    return this.getEffectSwivel(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFadedSwivel":
	                    //旋转(淡出式回旋)
	                    return this.getEffectFadedSwivel(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBounce":
	                    //弹跳
	                    return this.getEffectBounce(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBlinds":
	                    //百叶窗
	                    return this.getEffectBlinds(parameter, object, isExit, duration, delay, repeat);
	                case "EffectPeek":
	                    //切入/出
	                    return this.getEffectPeek(parameter, object, isExit, duration, delay, repeat);
	                case "EffectExpand":
	                    //展开/收缩
	                    return this.getEffectExpand(parameter, object, isExit, duration, delay, repeat);
	                case "EffectRiseUp":
	                    //升起/下沉
	                    return this.getEffectRiseUp(parameter, object, isExit, duration, delay, repeat);
	                case "EffectCenterRevolve":
	                    //中心旋转
	                    return this.getEffectCenterRevolve(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSpinner":
	                    //回旋
	                    return this.getEffectSpinner(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFloat":
	                    //浮动
	                    return this.getEffectFloat(parameter, object, isExit, duration, delay, repeat);
	                case "EffectSpiral":
	                    //螺旋飞入/出
	                    return this.getEffectSpiral(parameter, object, isExit, duration, delay, repeat);
	                case "EffectPinwheel":
	                    //玩具风车
	                    return this.getEffectPinwheel(parameter, object, isExit, duration, delay, repeat);
	                case "EffectCredits":
	                    //字幕式
	                    return this.getEffectCredits(parameter, object, isExit, duration, delay, repeat);
	                case "EffectBoomerang":
	                    //飞旋
	                    return this.getEffectBoomerang(parameter, object, isExit, duration, delay, repeat);
	                case "EffectArcUp":
	                    //曲线向上/下
	                    return this.getEffectArcUp(parameter, object, isExit, duration, delay, repeat);
	                case "EffectFlashBulb":
	                    //脉冲
	                    return this.getEffectFlashBulb(parameter, object, duration, delay, repeat);
	                case "EffectFlicker":
	                    //彩色脉冲
	                    return this.getEffectFlicker(parameter, object, duration, delay, repeat);
	                case "EffectTeeter":
	                    //跷跷板
	                    return this.getEffectTeeter(parameter, object, duration, delay, repeat);
	                case "EffectSpin":
	                    //陀螺旋转
	                    return this.getEffectSpin(parameter, object, duration, delay, repeat);
	                case "EffectGrowShrink":
	                    //放大/缩小
	                    return this.getEffectGrowShrink(parameter, object, duration, delay, repeat);
	                case "EffectDesaturate":
	                    //不饱和
	                    return this.getEffectDesaturate(parameter, object, duration, delay, repeat);
	                case "EffectDarken":
	                    //加深
	                    return this.getEffectDarken(parameter, object, duration, delay, repeat);
	                case "EffectLighten":
	                    //变淡
	                    return this.getEffectLighten(parameter, object, duration, delay, repeat);
	                case "EffectTransparency":
	                    //透明
	                    return this.getEffectTransparency(parameter, object, duration, delay, repeat);
	                case "EffectColorBlend":
	                    //对象颜色
	                    return new TimelineMax();
	                case "EffectComplementaryColor":
	                    //补色
	                    return this.getEffectComplementaryColor(parameter, object, duration, delay, repeat);
	                case "EffectChangeLineColor":
	                    //线条颜色
	                    return new TimelineMax();
	                case "EffectChangeFillColor":
	                    //填允颜色
	                    return new TimelineMax();
	                case "EffectFlashOnce":
	                    //闪烁(一次)
	                    return this.getEffectFlashOnce(parameter, object, duration, delay, repeat);
	                //进入退出动画
	                default:
	                case "EffectAppear":
	                    //出现/消失
	                    return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);
	            }
	        }

	        /**
	         * 初始化
	         * @param  {[type]} startEvent    [description]
	         * @param  {[type]} completeEvent [description]
	         * @return {[type]}               [description]
	         */

	    }, {
	        key: '_initAnimation',
	        value: function _initAnimation(completeEvent) {
	            var self = this;

	            /**
	             * 整个动画完成事件(动画不需继续执行视为执行完成)
	             * @return {[type]} [description]
	             */
	            var completeAction = function completeAction() {
	                if (completeEvent && _.isFunction(completeEvent)) {
	                    completeEvent();
	                }
	            };

	            var tl = new TimelineLite({
	                paused: true,
	                onStartParams: [this.preCode],
	                onCompleteParams: [this.postCode, this.codeDelay],
	                onStart: function onStart(preCode) {
	                    //条件判断动画是否执行
	                    if (preCode && _.isFunction(preCode)) {
	                        self.animation.pause();
	                        var result = false;
	                        try {
	                            result = preCode();
	                        } catch (error) {
	                            console.log("Run preCode is error in startHandler:" + error);
	                        }
	                        if (result == true) self.animation.resume();else {
	                            self.animation.stop();
	                            completeAction();
	                        }
	                    }
	                },
	                onComplete: function onComplete(postCode, codeDelay) {
	                    self.isCompleted = true;
	                    //延迟执行postCode代码
	                    try {
	                        if (typeof postCode == "function") {
	                            if (codeDelay > 0) {
	                                setTimeout(postCode, codeDelay);
	                            } else {
	                                postCode();
	                            }
	                        }
	                    } catch (error) {
	                        console.log("Run postCode is error in completeHandler:" + error);
	                    }
	                    completeAction();
	                }
	            });

	            for (var i = 0; i < this.options.length; i++) {
	                if (i == 0) {
	                    tl.add(this._getTimeline(this.options[i], i), "shape0");
	                } else {
	                    var invokeMode = this.options[i].invokeMode;
	                    if (invokeMode == 2) tl.add(this._getTimeline(this.options[i], i));else tl.add(this._getTimeline(this.options[i], i), "shape0"); //"shape"+(i-1)
	                }
	            }
	            return tl;
	        }

	        /**
	         * 执行动画
	         * @param  {[type]} scopeComplete [description]
	         * @return {[type]}               [description]
	         */

	    }, {
	        key: 'play',
	        value: function play(animComplete) {
	            if (this.isCompleted) {
	                this.reset();
	            }
	            this.animation && this.stop();
	            this.animation = this._initAnimation(animComplete);
	            this.animation.play();
	        }

	        /**
	         * 停止动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            if (this.animation instanceof TimelineLite) {
	                this.animation.stop();
	                this.animation.kill();
	                this.animation.clear();
	                this.animation.vars = null;
	            }
	            this.animation = null;
	        }

	        /**
	         * 复位动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            this.animation && this.stop();
	            if (this.elementStyle && this.elementStyle.length) {
	                var origin = this.element.css("-webkit-transform-origin");
	                //卷滚区域里的对象不需要还原
	                if (this.element.attr("isscroll") == null) {
	                    this.element[0].style.cssText = this.elementStyle;
	                }
	                this.element.css("-webkit-transform-origin", origin);
	                this.element.css("visibility", this.elementVisibility);
	                this.element.css("-webkit-transform", "none");
	                this.element[0]["_gsTransform"] = null; //清理对象上绑定的动画属性
	            }
	            this.isCompleted = false;
	        }

	        /**
	         * 销毁动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.stop();
	            this.container = null;
	            this.options = null;
	            this.element = null;
	        }
	    }]);
	    return Powepoint;
	}();

	fade(Powepoint.prototype);
	fly(Powepoint.prototype);
	path(Powepoint.prototype);
	rotate(Powepoint.prototype);
	special(Powepoint.prototype);
	zoom(Powepoint.prototype);
	shape(Powepoint.prototype);

	var style = Xut.style;
	var keyframes = style.keyframes;
	var animationEnd = style.animationEnd;
	var playState = style.animationPlayState;
	var prefixAnims = style.animation;

	var styleElement = null;

	/**
	 * [ description]动态插入一条样式规则
	 * @param  {[type]} rule [样式规则]
	 * @return {[type]}      [description]
	 */
	function insertCSSRule(rule) {
	    var number, sheet, cssRules;
	    //如果有全局的style样式文件
	    if (styleElement) {
	        number = 0;
	        try {
	            sheet = styleElement.sheet;
	            cssRules = sheet.cssRules;
	            number = cssRules.length;
	            sheet.insertRule(rule, number);
	        } catch (e) {
	            console.log(e);
	        }
	    } else {
	        //创建样式文件
	        styleElement = document.createElement("style");
	        styleElement.type = 'text/css';
	        styleElement.innerHTML = rule;
	        styleElement.uuid = 'aaron';
	        document.head.appendChild(styleElement);
	    }
	}

	/**
	 * [ description]删除一条样式规则
	 * @param  {[type]} ruleName [样式名]
	 * @return {[type]}          [description]
	 */
	function deleteCSSRule(ruleName) {
	    if (styleElement) {
	        var sheet = styleElement.sheet,
	            cssRules = sheet.rules || sheet.cssRules,
	            //取得规则列表
	        i = 0,
	            n = cssRules.length,
	            rule;
	        for (i; i < n; i++) {
	            rule = cssRules[i];
	            if (rule.name === ruleName) {
	                //删除单个规则
	                sheet.deleteRule(i);
	                break;
	            }
	        }
	        //删除style样式
	        if (cssRules.length == 0) {
	            document.head.removeChild(styleElement);
	            styleElement = null;
	        }
	    }
	}

	/**
	 * css3模式
	 * 单图
	 * 矩形图
	 * @param  {[type]} options [description]
	 * @return {[type]}         [description]
	 */
	function css3(options) {

	    var matrix = void 0,
	        parameter = void 0,
	        rule1 = void 0,
	        rule2 = void 0,
	        timer = void 0;

	    var $spriteNode = options.$contentNode.find('.sprite');
	    var data = options.data;
	    var callback = options.callback || function () {};
	    var aniName = 'sprite_' + options.id;
	    var count = data.thecount;
	    var fps = data.fps;
	    var time = Math.round(1 / fps * count * 10) / 10;
	    var width = Math.ceil(data.scaleWidth * count);
	    var loop = data.loop ? 'infinite' : 1;

	    //如果是矩形图
	    if (data.parameter) {
	        parameter = parseJSON(data.parameter);
	        if (parameter && parameter.matrix) {
	            matrix = parameter.matrix.split("-");
	        }
	    }

	    /**
	     * 设置精灵动画位置
	     * @param {[type]} aniName [description]
	     * @param {[type]} x       [description]
	     */
	    function setPostion(aniName, x) {
	        //矩阵生成step的处理
	        //  0 1 2
	        //  3 4 5
	        //  6 7 8
	        if (matrix) {
	            var frames = [];
	            var base = 100 / count;
	            var col = Number(matrix[0]); //列数
	            //首次
	            frames.push(0 + '% { background-position:0% 0%}');
	            for (var i = 0; i < count; i++) {
	                // var currRow = Math.ceil((i + 1) / col); //当前行数
	                var currCol = Math.floor(i / col); //当前列数
	                var period = currCol * col; //每段数量
	                x = 100 * (i - period);
	                var y = 100 * currCol;
	                x = x == 0 ? x : "-" + x;
	                y = y == 0 ? y : "-" + y;
	                frames.push((i + 1) * base + '% { background-position: ' + x + '% ' + y + '%}');
	            }
	            return aniName + '{' + frames.join("") + '}';
	        } else {
	            var rule = '{0} {from { background-position:0 0; } to { background-position: -{1}px 0px}}';
	            return String.format(rule, aniName, Math.round(x));
	        }
	    }

	    /**
	     * 格式化样式表达式
	     * 2016.7.15 add paused control
	     * @param {[type]}   [description]
	     */
	    function setStep(aniName, time, count, loop) {
	        var rule;
	        if (matrix) {
	            rule = '{0} {1}s step-start {2}';
	            return String.format(rule, aniName, time, loop);
	        } else {
	            rule = '{0} {1}s steps({2}, end) {3}';
	            return String.format(rule, aniName, time, count, loop);
	        }
	    }

	    /**
	     * 设置动画样式
	     * @param {[type]} rule     [description]
	     */
	    function initStyle(rule) {
	        prefixAnims && $spriteNode.css(prefixAnims, rule).css(playState, 'paused');
	    }

	    /**
	     * 添加到样式规则中
	     * @param {[type]} rule [description]
	     */
	    function setKeyframes(rule) {
	        if (keyframes) {
	            insertCSSRule(keyframes + rule);
	        }
	    }

	    //动画css关键帧规则
	    rule1 = setStep(aniName, time, count, loop);
	    rule2 = setPostion(aniName, width);

	    initStyle(rule1);
	    setKeyframes(rule2);
	    $spriteNode.on(animationEnd, callback);

	    return {

	        play: function play() {
	            //添加定时器 解决设备卡顿时普通精灵动画不播放的问题
	            timer = setTimeout(function () {
	                $spriteNode.css(playState, 'running');
	            }, 50);
	        },

	        stop: function stop() {
	            $spriteNode.css(playState, 'paused');
	        },

	        destroy: function destroy() {
	            //停止精灵动画
	            deleteCSSRule(aniName);
	            $spriteNode.off(animationEnd, callback);
	            clearTimeout(timer);
	            timer = null;
	            $spriteNode = null;
	        }

	    };
	}

	function keyframe(options) {
	    var matrix = void 0,
	        parameter = void 0,
	        timer = void 0,
	        x = void 0,
	        y = void 0;

	    var arrays = [];
	    var t = 0;
	    var $spriteNode = options.$contentNode.find('.sprite');
	    var data = options.data;
	    var callback = options.callback || function () {};

	    var count = data.thecount;
	    var fps = data.fps;
	    var loop = data.loop;
	    var width = data.scaleWidth;
	    var height = data.scaleHeight;

	    //如果是矩形图
	    if (data.parameter) {
	        parameter = parseJSON(data.parameter);
	        if (parameter && parameter.matrix) {
	            matrix = parameter.matrix.split("-");
	        }
	    }

	    getCoordinate();
	    //得到坐标：矩阵图：X Y坐标 普通：X坐标
	    function getCoordinate() {
	        //矩阵图
	        if (matrix) {
	            var cols = matrix[0];
	            var rows = matrix[1];
	            for (var i = 0; i < rows; i++) {
	                y = -height * i + 'px';
	                for (var k = 0; k < cols; k++) {
	                    x = -width * k + 'px';

	                    arrays.push(x, y);
	                }
	            }
	            //数组长度大于给定的数量时 删除数组中多余的数据
	            if (arrays.length / 2 > count) {
	                var temp = arrays.length / 2 - count;
	                for (var f = 2 * temp; f > 0; f--) {
	                    arrays.pop();
	                }
	            }
	        } else {
	            for (var i = 0; i < count; i++) {
	                x = -width * i + 'px';
	                arrays.push(x);
	            }
	        }
	    }

	    function start() {
	        if (matrix) {
	            if (t > arrays.length / 2 - 1) {
	                if (loop > 0) {
	                    t = 0;
	                    time();
	                } else {
	                    return;
	                }
	            } else {
	                time();
	            }
	        } else {
	            if (t > count - 1) {
	                if (loop > 0) {
	                    t = 0;
	                    time();
	                } else {
	                    return;
	                }
	            } else {
	                time();
	            }
	        }
	    }

	    function time() {
	        timer = setTimeout(function () {
	            if (matrix) {
	                x = arrays[2 * t];
	                y = arrays[2 * t + 1];
	                $spriteNode.css('backgroundPositionX', x);
	                $spriteNode.css('backgroundPositionY', y);
	            } else {
	                x = arrays[t];
	                $spriteNode.css('backgroundPositionX', x);
	            }
	            t++;
	            start();
	        }, 1000 / fps);
	    }

	    return {
	        play: function play() {
	            start();
	        },

	        stop: function stop() {
	            clearTimeout(timer);
	        },

	        destroy: function destroy() {
	            //停止精灵动画
	            this.stop();
	            t = 0;
	            $spriteNode = null;
	            data = null;
	            arrays = null;
	        }

	    };
	}

	//判断是否支持css3属性
	var animationPlayState = Xut.style.animationPlayState;

	/**
	 * css3动画
	 * 1 帧动画
	 * 2 定时器动画
	 * @param {[type]} options [description]
	 */
	function ComSprite (options) {
	  //timer,css
	  var mode = options.mode || 'css';
	  return mode === 'css' && animationPlayState ? css3(options) : keyframe(options);
	}

	var moveContent$1 = function moveContent(contentPrefix, id, parentId) {
	    var obj = $("#" + contentPrefix + id);
	    var parentObj = $("#" + contentPrefix + parentId);
	    var $parent = $("#spirit_parent_" + parentId);
	    if ($parent.length == 0) {
	        parentObj.append("<div style='position:absolute; width:100%; height:100%'  id='spirit_parent_" + parentId + "'></div>");
	    }
	    $parent.append(obj);
	};

	var _class$2 = function () {
	    function _class(options) {
	        classCallCheck(this, _class);

	        this.options = options;
	        this.ids = [];
	    }

	    createClass(_class, [{
	        key: "play",
	        value: function play() {

	            var id = void 0,
	                action = void 0,
	                ids = void 0,
	                data = void 0,
	                resource = void 0,
	                loop = void 0,
	                spiritList = void 0,
	                framId = void 0,
	                parentId = void 0,
	                params = void 0,
	                options = void 0;

	            options = this.options;
	            data = options.data;
	            resource = data.resource;
	            loop = data.loop;
	            this.spiritObjs = {};
	            var option = {};
	            option.contentId = options.id;
	            option.ele = options.$contentNode;
	            option.resourcePath = data.md5;
	            option.type = "advSprite";
	            for (var i = 0; i < resource.spiritList.length; i++) {
	                spiritList = resource.spiritList[i];
	                id = data.containerName;
	                framId = spiritList.framId;
	                parentId = spiritList.parentId;
	                this.ids.push(id);
	                if (parentId != "0") {
	                    var tempArray = id.split('_');
	                    var contentPrefix = tempArray[0] + '_' + tempArray[1];
	                    moveContent$1(contentPrefix, framId, parentId);
	                }
	                this.spiritObjs[id] = new _class$1(spiritList, option);
	                params = spiritList.params;

	                action = params["actList"].split(",")[0];
	                //0 循环播放 1播放一次
	                this.spiritObjs[id].play(action, loop);
	            }
	        }
	    }, {
	        key: "stop",
	        value: function stop() {
	            var _this = this;

	            this.ids.forEach(function (key) {
	                _this.spiritObjs[key].stop();
	            });
	        }
	    }, {
	        key: "reset",
	        value: function reset() {
	            this.stop();
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            var _this2 = this;

	            this.ids.forEach(function (key) {
	                if (_this2.spiritObjs[key]) {
	                    _this2.spiritObjs[key].destroy();
	                    _this2.spiritObjs[key] = null;
	                    delete _this2.spiritObjs[key];
	                }
	            });
	            this.options.data = null;
	            this.options.$contentNode = null;
	            this.options = null;
	            this.ids = null;
	        }
	    }]);
	    return _class;
	}();

	//2016.7.15废弃
	//pixi暂时不使用
	var pixiSpirit = {};
	var pixiSpecial = {};

	// import { Sprite as pixiSpirit } from '../pixi/sprite/index'
	// import { specialSprite as pixiSpecial } from '../pixi/special/index'


	/**
	 * 销毁动画音频
	 * @param  {[type]} videoIds  [description]
	 * @param  {[type]} chapterId [description]
	 * @return {[type]}           [description]
	 */
	var destroyAudio = function destroyAudio(videoIds, chapterId) {
	    var isExist = false;
	    //如果有音频存在
	    videoIds && _.each(videoIds, function (data) {
	        //如果存在对象音频
	        if (data.videoId) {
	            isExist = true;
	            return 'breaker';
	        }
	    });
	    if (isExist) {
	        clearContentAudio(chapterId);
	    }
	};

	/**
	 * 4种扩展对象
	 * @type {Array}
	 */
	var OBJNAME = ['pptObj', 'pixiObj', 'comSpriteObj', 'autoSpriteObj'];

	/**
	 * Traverse each value of OBJNAME
	 * @param  {Function} callback [description]
	 * @return {[type]}            [description]
	 */
	var access = function access(callback) {
	    OBJNAME.forEach(function (key) {
	        callback(key);
	    });
	};

	/**
	 * 动画效果
	 * @param {[type]} options [description]
	 */

	var Animation = function () {
	    function Animation(options) {
	        classCallCheck(this, Animation);

	        _.extend(this, options);
	    }

	    /**
	     * Build the canvas of animation
	     * 比较复杂
	     * 1 普通与ppt组合
	     * 2 高级与ppt组合
	     * 3 ppt独立
	     * 4 普通精灵动画
	     * 8  其中 高级精灵动画是widget创建，需要等待
	     * @return {[type]} [description]
	     */


	    createClass(Animation, [{
	        key: '_createCanvas',
	        value: function _createCanvas(id, parameter, category, callback) {
	            var _this = this;

	            var initstate = void 0;

	            //动作类型
	            //可能是组合动画
	            var actionTypes = this.contentDas.actionTypes;
	            var makeOpts = {
	                data: this.contentDas,
	                renderer: this.$contentNode,
	                pageIndex: this.pageIndex
	            };

	            //创建pixi上下文的ppt对象
	            var createPixiPPT = function createPixiPPT() {
	                //parameter存在就是ppt动画
	                if ((parameter || actionTypes.pptId) && _this.$contentNode.view) {
	                    _this.pptObj = callback(Powepoint, $(_this.$contentNode.view));
	                    _this.pptObj.contentId = id;
	                }
	            };

	            var $veiw = this.$contentNode.view;
	            if ($veiw) {
	                initstate = $veiw.getAttribute('data-init');
	            }

	            var setState = function setState() {
	                $veiw.setAttribute('data-init', true);
	            };

	            //多个canvas对应多个ppt
	            //容器不需要重复创建
	            //精灵动画
	            if (actionTypes.spiritId) {
	                if (initstate) {
	                    createPixiPPT();
	                } else {
	                    //加入任务队列
	                    this.nextTask.context.add(id);
	                    this.pixiObj = new pixiSpirit(makeOpts);
	                    //防止多条一样的数据绑多个动画
	                    //构建精灵动画完毕后
	                    //构建ppt对象
	                    this.pixiObj.$once('load', function () {
	                        //ppt动画
	                        createPixiPPT();

	                        //任务完成
	                        _this.nextTask.context.remove(id);
	                    });
	                    setState();
	                }
	            }

	            //特殊高级动画
	            //必须是ppt与pixi绑定的
	            if (actionTypes.compSpriteId) {
	                // console.log(this,this.id,this.contentDas.initpixi)
	                //这个dom已经创建了pixi了
	                if (initstate) {
	                    createPixiPPT();
	                } else {
	                    this.pixiObj = new pixiSpecial(makeOpts);
	                    setState();

	                    //ppt动画
	                    createPixiPPT();
	                }
	            }
	        }

	        /**
	         * Build the dom of animation
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createDom',
	        value: function _createDom(category, callback) {

	            if (category) {
	                var data = {
	                    id: this.id,
	                    data: this.contentDas,
	                    $contentNode: this.$contentNode
	                };
	                switch (category) {
	                    //普通精灵动画
	                    case "Sprite":
	                        this.comSpriteObj = ComSprite(data);
	                        break;
	                    //普通转复杂精灵动画
	                    case "AutoCompSprite":
	                        this.autoSpriteObj = new _class$2(data);
	                        break;
	                }
	            }

	            //ppt动画
	            this.pptObj = callback(Powepoint);
	        }

	        /**
	         * 绑定动画
	         * 为了向上兼容API
	         *  1 dom动画
	         *  2 canvas动画
	         */

	    }, {
	        key: 'init',
	        value: function init(id, context, $containsNode, chapterId, parameter, pageType) {

	            var pageIndex = void 0,
	                create = void 0,
	                category = void 0;

	            category = this.contentDas.category;
	            pageIndex = this.pageIndex;
	            create = function create(constr, newContext) {
	                var element = newContext || context;
	                if (element.length) {
	                    return new constr(pageIndex, pageType, chapterId, element, parameter, $containsNode);
	                } else {
	                    console.log('\u521B\u5EFA:' + constr + '\u5931\u8D25');
	                }
	            };

	            //build
	            //dom mode
	            //canvas mode
	            this.domMode ? this._createDom(category, create) : this._createCanvas(id, parameter, category, create);
	        }

	        /**
	         * 运行动画
	         * @param  {[type]} scopeComplete   [动画回调]
	         * @param  {[type]} canvasContainer [description]
	         * @return {[type]}                 [description]
	         */

	    }, {
	        key: 'play',
	        value: function play(playComplete) {
	            var _this2 = this;

	            var $contentNode = this.$contentNode;

	            //canvas
	            if ($contentNode && $contentNode.view) {
	                $contentNode = this.$contentNode.view;
	            }

	            access(function (key) {
	                if (_this2[key]) {
	                    if (key === 'pptObj') {
	                        //优化处理,只针对互斥的情况下
	                        //处理层级关系
	                        if ($contentNode.prop && $contentNode.prop("mutex")) {
	                            $contentNode.css({ //强制提升层级
	                                'display': 'block'
	                            });
	                        }
	                    }
	                    _this2[key].play && _this2[key].play(playComplete);
	                }
	            });
	        }

	        /**
	         * 停止动画
	         * @param  {[type]} chapterId [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop(chapterId) {
	            var _this3 = this;

	            access(function (key) {
	                if (_this3[key]) {
	                    if (key === 'pptObj') {
	                        //销毁ppt音频
	                        destroyAudio(_this3[key].options, chapterId);
	                    }
	                    _this3[key].stop && _this3[key].stop();
	                }
	            });
	        }

	        /**
	         * 翻页结束，复位上一页动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            var _this4 = this;

	            access(function (key) {
	                _this4[key] && _this4[key].reset && _this4[key].reset();
	            });
	        }

	        /**
	         * 销毁动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var _this5 = this;

	            access(function (key) {
	                _this5[key] && _this5[key].destroy && _this5[key].destroy();
	            });

	            //销毁renderer = new PIXI.WebGLRenderer
	            if (this.canvasMode) {
	                //rederer.destroy()
	                this.$contentNode.view && this.$contentNode.destroy();
	            }

	            //销毁每一个数据上的canvas上下文引用
	            if (this.contentDas.$contentNode) {
	                this.contentDas.$contentNode = null;
	            }

	            access(function (key) {
	                _this5[key] = null;
	            });

	            this.getParameter = null;
	        }
	    }]);
	    return Animation;
	}();

	var transform = Xut.style.transform;
	var setTranslateZ = Xut.style.setTranslateZ;

	var hasValue$1 = function hasValue(value) {
	    return value != undefined;
	};

	/**
	 * 变化节点的css3transform属性
	 * @param  {[type]} $contentNode   [description]
	 * @param  {[type]} property   [description]
	 * @param  {[type]} pageOffset [description]
	 * @return {[type]}            [description]
	 */
	var transformNodes = function transformNodes($contentNode, property, pageOffset) {
	    var style = {},
	        effect = '',
	        parallaxOffset,
	        //最终的偏移量X
	    x = 0,
	        y = 0,
	        z = 0,
	        round = Math.round;

	    //浮动对象初始化偏移量
	    parallaxOffset = pageOffset;

	    if (hasValue$1(property.translateX) || hasValue$1(property.translateY) || hasValue$1(property.translateZ)) {
	        x = round(property.translateX) || 0;
	        y = round(property.translateY) || 0;
	        z = round(property.translateZ) || 0;
	        parallaxOffset += x;
	        var translateZ = setTranslateZ(z);
	        effect += 'translate(' + parallaxOffset + 'px,' + y + 'px) ' + translateZ;
	    }

	    if (hasValue$1(property.rotateX) || hasValue$1(property.rotateY) || hasValue$1(property.rotateZ)) {
	        x = round(property.rotateX);
	        y = round(property.rotateY);
	        z = round(property.rotateZ);
	        effect += x ? 'rotateX(' + x + 'deg) ' : '';
	        effect += y ? 'rotateY(' + y + 'deg) ' : '';
	        effect += z ? 'rotateZ(' + z + 'deg) ' : '';
	    }

	    if (hasValue$1(property.scaleX) || hasValue$1(property.scaleY) || hasValue$1(property.scaleZ)) {
	        x = round(property.scaleX * 100) / 100 || 1;
	        y = round(property.scaleY * 100) / 100 || 1;
	        z = round(property.scaleZ * 100) / 100 || 1;
	        effect += String.format('scale3d({0},{1},{2}) ', x, y, z);
	    }

	    if (hasValue$1(property.opacity)) {
	        style.opacity = round((property.opacityStart + property.opacity) * 100) / 100;
	        effect += ';';
	    }

	    if (effect) {
	        style[transform] = effect;
	        $contentNode.css(style);
	    }

	    return parallaxOffset;
	};

	/**
	 * 转换成比例值
	 * @param  {[type]} parameters [description]
	 * @return {[type]}            [description]
	 */
	var conversionRatio = function conversionRatio(parameters) {
	    if (parameters.opacityStart > -1) {
	        parameters.opacity = (parameters.opacityEnd || 1) - parameters.opacityStart;
	        delete parameters.opacityEnd;
	    }
	    return parameters;
	};

	/**
	 * 转化成实际值
	 * @param  {[type]} parameters     [description]
	 * @param  {[type]} nodeProportion [description]
	 * @return {[type]}                [description]
	 */
	var conversionValue = function conversionValue(parameters, nodeProportion) {
	    var results = {},
	        width = -config.viewSize.width,
	        height = -config.viewSize.height;

	    for (var i in parameters) {
	        switch (i) {
	            case 'translateX':
	            case 'translateZ':
	                results[i] = parameters[i] * nodeProportion * width;
	                break;
	            case 'translateY':
	                results[i] = parameters[i] * nodeProportion * height;
	                break;
	            case 'opacityStart':
	                results[i] = parameters[i];
	                break;
	            default:
	                results[i] = parameters[i] * nodeProportion;
	        }
	    }

	    return results;
	};

	function Parallax(data) {
	    var parameters = void 0;
	    try {
	        //转化所有css特效的参数的比例
	        parameters = JSON.parse(data.getParameter()[0]['parameter']);
	    } catch (err) {
	        return false;
	    }

	    var pid = data.pid,
	        translate = conversionRatio(parameters),

	    //页面偏移量
	    pageOffset = this.relatedData.pageOffset && this.relatedData.pageOffset.split("-"),

	    //开始的nodes值
	    currPageOffset = pageOffset[0],

	    //范围区域
	    pageRange = pageOffset[1],

	    //页面偏移比例
	    nodeOffsetProportion = (currPageOffset - 1) / (pageRange - 1),

	    //计算出偏移值
	    offsetTranslate = conversionValue(translate, nodeOffsetProportion),

	    //页面分割比
	    nodeProportion = 1 / (pageRange - 1);

	    //改变节点的transform属性
	    //返回改变后translateX值
	    var parallaxOffset = transformNodes(data.$contentNode, _.extend({}, offsetTranslate), data.transformOffset);

	    /**
	     * 为了兼容动画，把视觉差当作一种行为处理
	     * 合并data数据
	     * @type {Object}
	     */
	    data.parallax = {
	        //计算页码结束边界值,用于跳转过滤
	        calculateRangePage: function calculateRangePage() {
	            return {
	                'start': pid - currPageOffset + 1,
	                'end': pageRange - currPageOffset + pid
	            };
	        },
	        'translate': translate,
	        'offsetTranslate': offsetTranslate,
	        'nodeProportion': nodeProportion,
	        '$contentNode': data.$contentNode,
	        'parallaxOffset': parallaxOffset //经过视觉差修正后的偏移量
	    };

	    return data;
	}

	//2016.7.15废弃
	//pixi暂时不使用
	// import { Context } from '../pixi/context'

	/**
	 * 预运行动作
	 * 自动 && 出现 && 无时间 && 无音乐
	 *  && 不是精灵动画 && 没有脚本代码 && 并且不能是收费
	 * @return {[type]}         [description]
	 */
	var preRunAction = function preRunAction(data, eventName) {
	    var para, state, category, parameter;
	    parameter = data.getParameter();

	    //过滤预生成动画
	    if (parameter.length === 1) {
	        category = data.contentDas.category;
	        para = parameter[0];
	        if (para.animationName === 'EffectAppear' && data.domMode //并且只有dom模式才可以，canvas排除
	        && eventName === 'auto' && !para.videoId && !para.delay && category !== 'Sprite' && category !== 'AutoCompSprite' && !para.preCode //动画前脚本
	        && !para.postCode //动画后脚本
	        && !/"inapp"/i.test(para.parameter)) {
	            //并且不能是收费处理

	            /**
	             *针对预处理动作,并且没有卷滚的不注册
	             *满足是静态动画
	             *true是显示,false隐藏å
	             */
	            var state = data.isRreRun = /"exit":"False"/i.test(para.parameter) === true ? 'visible' : 'hidden';

	            return state;
	        }
	    }
	};

	/**
	 * 构建动画
	 * @return {[type]} [description]
	 */
	var createScope = function createScope(base, contentId, pid, actName, parameter, hasParallax) {

	    //默认启动dom模式
	    var data = {
	        type: 'dom',
	        canvasMode: false,
	        domMode: true
	    };
	    var $contentNode;
	    var pageType = base.pageType;
	    var contentName;
	    var canvasDom;
	    var contentDas = base.relatedData.contentDas[contentId];

	    //如果启动了canvas模式
	    //改成作用域的一些数据
	    if (base.canvasRelated.enable) {
	        //如果找到对应的canvas对象
	        if (-1 !== base.canvasRelated.cid.indexOf(contentId)) {
	            contentName = "canvas_" + pid + "_" + contentId;
	            canvasDom = base.getContextNode(contentName)[0];

	            //创建上下文pixi
	            if (contentDas.$contentNode) {
	                $contentNode = contentDas.$contentNode;
	            } else {
	                // $contentNode = Context(contentDas, canvasDom, base.pageIndex)
	                //保存canvas pixi的上下文引用
	                // base.relatedData.contentDas[contentId].$contentNode = $contentNode
	            }
	            data.type = 'canvas';
	            data.canvasMode = true;
	            data.domMode = false;
	        }
	    }

	    //如果是dom模式
	    if (!$contentNode) {
	        /**
	         * 确保节点存在
	         * @type {[type]}
	         */
	        if (!($contentNode = base.getContextNode(actName))) {
	            return;
	        }
	    }

	    /**
	     * 制作公共数据
	     * @type {Object}
	     */
	    _.extend(data, {
	        base: base,
	        id: contentId,
	        pid: pid,
	        actName: actName,
	        contentDas: contentDas,
	        $contentNode: $contentNode,
	        pageType: pageType,
	        pageIndex: base.pageIndex,
	        canvasRelated: base.canvasRelated,
	        nextTask: base.nextTask,
	        canvasDom: canvasDom
	    });

	    /**
	     * 如果是母版层理,视觉差处理
	     * processType 三种情况
	     *          parallax
	     *          animation
	     *          both(parallax,animation)
	     * @type {[type]}
	     */
	    if (hasParallax && pageType === 'master') {
	        data.processType = 'parallax';
	    } else {
	        data.processType = 'animation';
	    }

	    //生成查询方法
	    data.getParameter = function () {
	        //分区母版与页面的数据结构
	        //parameter-master-parallax
	        //parameter-master-animation
	        //parameter-page-animation
	        var fix = 'parameter-' + pageType + '-' + data.processType;
	        data[fix] = parameter;
	        return function () {
	            return data[fix];
	        };
	    }();

	    /**
	     * 生成视觉差作用域
	     * @type {[type]}
	     */
	    if (data.processType === 'parallax') {
	        //初始化视觉差对象的坐标偏移量
	        data.transformOffset = base.relatedData.transformOffset(data.id);
	        return Parallax.call(base, data);
	    }

	    /**
	     *  优化机制,预生成处理
	     *  过滤自动热点并且是出现动作，没有时间，用于提升体验
	     */
	    preRunAction(data, base.eventData.eventName);

	    /**
	     * 生成子作用域对象，用于抽象处理动画,行为
	     */
	    return new Animation(data);
	};

	/**
	 * 分解每个子作用域
	 * 1 生成临时占位作用域,用于分段动画
	 * 2 生成所有动画子作用域
	 * @param  {[type]} parameter [description]
	 * @return {[type]}           [description]
	 */
	var createHandlers = function createHandlers(base, parameter) {

	    //dom对象
	    var para = parameter[0],
	        contentId = para['contentId'],
	        //可能有多个动画数据 [Object,Object,Object]
	    pid = base.pid,
	        actName = base.makePrefix('Content', pid, contentId);

	    /**
	     * 构建子作用域
	     */
	    return createScope(base, contentId, pid, actName, parameter, para.masterId);
	};

	/**
	 * 构建作用域
	 * @return {[type]} [description]
	 */
	var fnCreate = function fnCreate(base) {
	    return function (data, callback) {
	        var para, handlers;
	        if (data && data.length) {
	            //生成动画作用域对象
	            while (para = data.shift()) {
	                if (handlers = createHandlers(base, para)) {
	                    callback(handlers);
	                }
	            }
	        }
	    };
	};

	/**
	 * 源对象复制到目标对象
	 */
	var innerExtend = function innerExtend(target, source) {
	    var property;
	    for (property in source) {
	        if (target[property] === undefined) {
	            target[property] = source[property];
	        }
	    }
	};

	//处理itemArray绑定的动画对象
	//注入动画
	//绑定用户事件
	function createContent (base) {
	    var animation = base.seed.animation,
	        parallax = base.seed.parallax,

	    //抽出content对象
	    abstractContents = [],

	    //创建引用
	    batcheCreate = fnCreate(base);

	    switch (base.pageType) {
	        case 'page':
	            batcheCreate(animation, function (handlers) {
	                abstractContents.push(handlers);
	            });
	            break;
	        case 'master':
	            //母版层的处理
	            var tempParallaxScope = {},
	                tempAnimationScope = {},
	                tempAssistContents = [];
	            //视觉差处理
	            batcheCreate(parallax, function (handlers) {
	                tempParallaxScope[handlers.id] = handlers;
	            });

	            batcheCreate(animation, function (handlers) {
	                tempAnimationScope[handlers.id] = handlers;
	            });

	            var hasParallax = _.keys(tempParallaxScope).length,
	                hasAnimation = _.keys(tempAnimationScope).length;

	            //动画为主
	            //合并，同一个对象可能具有动画+视觉差行为
	            if (hasParallax && hasAnimation) {
	                _.each(tempAnimationScope, function (target) {
	                    var id = target.id;
	                    var source = tempParallaxScope[id];
	                    if (source) {
	                        //如果能找到就需要合并
	                        innerExtend(target, source); //复制方法
	                        target.processType = 'both'; //标记新组合
	                        delete tempParallaxScope[id]; //删除引用
	                    }
	                });
	                //剩余的处理
	                if (_.keys(tempParallaxScope).length) {
	                    _.extend(tempAnimationScope, tempParallaxScope);
	                }
	                tempParallaxScope = null;
	            }
	            //转化成数组
	            _.each(hasAnimation ? tempAnimationScope : tempParallaxScope, function (target) {
	                tempAssistContents.push(target);
	            });
	            abstractContents = tempAssistContents;
	            break;
	    }

	    batcheCreate = null;

	    return abstractContents;
	}

	/**
	 * 2016.4.11
	 * 因为canvas模式导致
	 * 任务必须等待context上下创建
	 * 完成后执行
	 * 1 事件
	 * 2 预执行
	 * @type {Array}
	 */
	function createTask (callback) {
	    return {
	        context: {
	            /**
	             * 状态表示
	             */

	            /**
	             * 是否等待创建
	             * @type {Boolean}
	             */
	            wait: false,

	            /**
	             * 是否完成创建
	             * @type {Boolean}
	             */
	            statas: false,

	            /**
	             * id合集
	             * @type {Array}
	             */
	            _ids: [],

	            /**
	             * 事件
	             * @type {Array}
	             */
	            event: [],

	            /**
	             * 预执行
	             * @type {Object}
	             */
	            pre: {}, //预执行


	            /**
	             * 检测是否完成
	             * @return {[type]} [description]
	             */
	            check: function check() {
	                var total = this.length();
	                if (!total.length) {
	                    //完成创建
	                    this.statas = true;
	                }
	                //如果已经等待
	                if (this.wait) {
	                    callback && callback();
	                    return;
	                }
	                // //创建比流程先执行完毕
	                // //一般几乎不存在
	                // //但是不排除
	                // if (!this.wait && this.statas) {
	                //     this.wait = true;
	                //     return;
	                // }
	            },
	            add: function add(id) {
	                if (-1 === this._ids.indexOf(id)) {
	                    this._ids.push(id);
	                }
	            },
	            remove: function remove(id) {
	                if (!id) {
	                    return;
	                }
	                var index = this._ids.indexOf(id);
	                var val = this._ids.splice(index, 1);
	                this.check(val);
	                return val;
	            },
	            length: function length() {
	                return this._ids.length;
	            }
	        }
	    };
	}

	/**
	 * 处理拖动对象
	 * @return {[type]} [description]
	 */
	function accessDrop(eventData, callback) {
	    if (eventData && eventData.dragDrop) {
	        callback(eventData.dragDrop);
	    }
	}

	var Activity = function () {

	    /**
	     * activity触发器类
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    function Activity(data) {
	        classCallCheck(this, Activity);


	        _.extend(this, data);

	        /**
	         * 2016.4.11
	         * 检测是所有的子任务必须完成
	         * 因为canvas模式导致
	         * 任务必须等待context上下创建
	         * context就是pixi的直接对象，精灵..都是异步的
	         */
	        this.nextTask = createTask(this.noticeComplete);

	        /**
	         * 填充事件数据
	         */
	        this.fillEventData();

	        /**
	         * 保存子对象content
	         * @type {Array}
	         */
	        this.abstractContents = createContent(this);

	        /**
	         * 处理html文本框
	         * 2016.1.6
	         */
	        this.htmlTextBox();

	        /**
	         * 绑定事件
	         */
	        this.bindEventBehavior();

	        /**
	         * 初始化content行为
	         */
	        this._initContents();

	        /**
	         * 2016.2.26
	         * 修复妙妙学
	         * 妙妙客户端处理
	         * 点击效果的音频处理
	         * @type {Array}
	         */
	        this._fixAudio = [];

	        /**
	         * 如果存在content
	         * 等待创建执行
	         * @param  {[type]} this.nextTask.context.length()
	         * @return {[type]}
	         */
	        if (this.nextTask.context.length()) {
	            this.nextTask.context.wait = true;
	            return this;
	        }

	        /**
	         * 如果没有pixi的异步创建
	         * 同步代码直接完成
	         */
	        this.noticeComplete();
	    }

	    /**
	     * 初始化content行为
	     * @return {[type]} [description]
	     */


	    createClass(Activity, [{
	        key: '_initContents',
	        value: function _initContents() {

	            var pageId = this.relatedData.pageId;
	            var $containsNode = this.$containsNode;
	            var collectorHooks = this.relatedCallback.contentsHooks;
	            var pageType = this.pageType;

	            this.eachAssistContents(function (scope) {

	                var context, id, isRreRun, parameter;

	                //针对必须创建
	                if (!(context = scope.$contentNode)) {
	                    console.log('$contentNode不存在');
	                    return;
	                }

	                //如果是视觉差对象，也需要实现收集器
	                if (scope.processType === 'parallax') {
	                    collectorHooks(scope.pid, scope.id, scope);
	                    return;
	                }

	                //如果是动画才处理
	                id = scope.id;
	                isRreRun = scope.isRreRun;
	                parameter = scope.getParameter();

	                //如果不是预生成,注册动画事件
	                if (isRreRun === undefined) {
	                    //初始化动画
	                    scope.init(id, context, $containsNode, pageId, parameter, pageType);
	                }

	                //绑定DOM一些属性
	                this._toRepeatBind(id, context, isRreRun, scope, collectorHooks);
	            });
	        }

	        /**
	         * dom节点去重绑定
	         * 在每一次构建activity对象中，不重复处理content一些特性
	         * 1 翻页特性
	         * 2 注册钩子
	         * 3 预显示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_toRepeatBind',
	        value: function _toRepeatBind(id, context, isRreRun, scope, collectorHooks) {
	            var indexOf, relatedData;

	            relatedData = this.relatedData;

	            //过滤重复关系
	            //每个元素只绑定一次
	            if (-1 !== (indexOf = relatedData.createContentIds.indexOf(id))) {
	                //删除,去重
	                relatedData.createContentIds.splice(indexOf, 1);
	                //收集每一个content注册
	                collectorHooks(scope.pid, id, scope);
	                //增加翻页特性
	                this._addIScroll(scope, context);
	                //直接复位状态,针对出现动画 show/hide
	                if (isRreRun) {
	                    //直接改变元素状态
	                    context.css({
	                        'visibility': isRreRun
	                    });
	                }
	            }
	        }

	        /**
	         * 增加翻页特性
	         * 可能有多个引用关系
	         * @return {[type]}         [description]
	         */

	    }, {
	        key: '_addIScroll',
	        value: function _addIScroll(scope, $contentNode) {
	            var _this = this;

	            var self = this,
	                contentDas = scope.contentDas;

	            /**
	             * 给外部调用处理
	             * @param  {[type]} contentNode [description]
	             * @return {[type]}             [description]
	             */
	            var makeBindLinkFunction = function makeBindLinkFunction(contentNode) {

	                //ios or pc
	                if (!Xut.plat.isAndroid) {
	                    return function () {
	                        self.iscroll = new iScroll(contentNode, {
	                            scrollbars: true,
	                            fadeScrollbars: true
	                        });
	                    };
	                }

	                //在安卓上滚动文本的互斥不显示做一个补丁处理
	                //如果是隐藏的,需要强制显示,待邦定滚动之后再还原
	                //如果是显示的,则不需要处理,
	                var prePocess = self.makePrefix('Content', scope.pid, scope.id);
	                var preEle = self.getContextNode(prePocess);
	                var visible = preEle.css('visibility');
	                var restore = function restore() {};
	                var opacity = void 0;

	                if (visible == 'hidden') {
	                    opacity = preEle.css('opacity');
	                    //如果设置了不透明,则简单设为可见的
	                    //否则先设为不透明,再设为可见
	                    if (opacity == 0) {
	                        preEle.css({
	                            'visibility': 'visible'
	                        });
	                        restore = function restore() {
	                            preEle.css({
	                                'visibility': visible
	                            });
	                        };
	                    } else {
	                        preEle.css({
	                            'opacity': 0
	                        }).css({
	                            'visibility': 'visible'
	                        });
	                        restore = function restore() {
	                            preEle.css({
	                                'opacity': opacity
	                            }).css({
	                                'visibility': visible
	                            });
	                        };
	                    }
	                }

	                return function () {
	                    restore();
	                    preEle = null;
	                    restore = null;
	                };
	            };

	            var bindIscroll = function bindIscroll() {
	                $contentNode.css('overflow', 'hidden'); //增加元素溢出隐藏处理
	                $contentNode.children().css('height', ''); //去掉子元素高度，因为有滚动文本框
	                _this.relatedCallback.iscrollHooks.push(makeBindLinkFunction($contentNode[0]));
	            };

	            //增加卷滚条标记
	            //但是svg如果没有内容除外
	            if (contentDas.isScroll) {
	                var hasSVG = $contentNode.find('svg');
	                if (hasSVG) {
	                    //必须保证svg有数据
	                    if (hasSVG.text()) {
	                        bindIscroll();
	                    }
	                }
	                //如果不是svg数据，直接绑定
	                else {
	                        bindIscroll();
	                    }
	            }

	            //如果是图片则补尝允许范围内的高度
	            if (!contentDas.mask || !contentDas.isGif) {
	                $contentNode.find && $contentNode.find('img').css({
	                    'height': contentDas.scaleHeight
	                });
	            }
	        }

	        /**
	         * 制作一个查找标示
	         * @return {[type]}
	         */

	    }, {
	        key: 'makePrefix',
	        value: function makePrefix(name, pid, id) {
	            return name + "_" + pid + "_" + id;
	        }

	        /**
	         * 从文档碎片中找到对应的dom节点
	         * 查找的范围
	         * 1 文档根节点
	         * 2 文档容器节点
	         * @param  {[type]} prefix [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: 'getContextNode',
	        value: function getContextNode(prefix, type) {
	            var node = void 0,
	                $node = void 0,
	                containerPrefix = void 0,
	                contentsFragment = void 0;

	            //dom模式
	            contentsFragment = this.relatedData.contentsFragment;
	            if (node = contentsFragment[prefix]) {
	                $node = $(node);
	            } else {
	                //容器处理
	                if (containerPrefix = this.relatedData.containerPrefix) {
	                    _.each(containerPrefix, function (containerName) {
	                        node = contentsFragment[containerName];
	                        $node = $(node).find('#' + prefix);
	                        if ($node.length) {
	                            return;
	                        }
	                    });
	                }
	            }
	            return $node;
	        }

	        /**
	         * 复位独立动画
	         * 提供快速翻页复用
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_resetAloneAnim',
	        value: function _resetAloneAnim() {
	            //复位拖动对象
	            accessDrop(this.eventData, function (drop) {
	                drop.reset();
	            });
	        }

	        /**
	         * 动画运行之后
	         * 1 创建一个新场景
	         * 2 执行跳转到收费提示页面
	         * 3 触发搜索工具栏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_relevantOperation',
	        value: function _relevantOperation() {

	            var scenarioInfo, eventContentId;

	            //触发事件的content id
	            if (this.eventData) {
	                eventContentId = this.eventData.eventContentId;
	            }

	            if (eventContentId) {

	                //查找出当前节的所有信息
	                if (scenarioInfo = this.relatedData.seasonRelated[eventContentId]) {

	                    //如果存在搜索栏触发
	                    if (scenarioInfo.SearchBar) {
	                        this.createSearchBar();
	                        return;
	                    }

	                    //如果存在书签
	                    if (scenarioInfo.BookMarks) {
	                        this.createBookMark();
	                        return;
	                    }

	                    //处理新的场景
	                    if (scenarioInfo.seasonId || scenarioInfo.chapterId) {
	                        setTimeout(function () {
	                            Xut.View.LoadScenario({
	                                'scenarioId': scenarioInfo.seasonId,
	                                'chapterId': scenarioInfo.chapterId
	                            });
	                        }, hasAudioes() ? 1000 : 0);
	                        return;
	                    }

	                    // console.log('content跳转信息出错',scenarioInfo)
	                }
	            }
	        }

	        /**
	         * 保证正确遍历
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'eachAssistContents',
	        value: function eachAssistContents(callback) {
	            _.each(this.abstractContents, function (scope) {
	                callback.call(this, scope);
	            }, this);
	        }

	        /**
	         * 运行动画
	         * @param  {[type]} outComplete [动画回调]
	         * @return {[type]}             [description]
	         * evenyClick 每次都算有效点击
	         */

	    }, {
	        key: 'runAnimation',
	        value: function runAnimation(outComplete, evenyClick) {

	            var self = this;
	            var pageId = this.relatedData.pageId;

	            if (evenyClick) {
	                this.preventRepeat = false;
	            }

	            //防止重复点击
	            if (this.preventRepeat) {
	                return false;
	            }

	            this.preventRepeat = true;

	            //如果没有运行动画
	            if (!this.seed.animation) {
	                this.preventRepeat = false;
	                this._relevantOperation();
	                return;
	            }

	            //创建的无行为content
	            var partContentRelated = this.relatedData.partContentRelated;

	            //制作作用于内动画完成
	            //等待动画完毕后执行动作or场景切换
	            var captureAnimComplete = this.captureAnimComplete = function (counts) {
	                return function (scope) {
	                    //动画结束,删除这个hack
	                    scope && scope.$contentNode && scope.$contentNode.removeProp && scope.$contentNode.removeProp('animOffset');

	                    //如果快速翻页
	                    //运行动画的时候，发现不是可视页面
	                    //需要关闭这些动画
	                    var closeAnim = pageId != Xut.Presentation.GetPageId();

	                    if (closeAnim && scope) {
	                        scope.stop && scope.stop(pageId);
	                        scope.reset && scope.reset();
	                    }

	                    //捕获动画状态
	                    if (counts === 1) {
	                        if (closeAnim) {
	                            //复位动画
	                            self._resetAloneAnim();
	                        }
	                        self.preventRepeat = false;
	                        self._relevantOperation();
	                        outComplete && outComplete();
	                        self.captureAnimComplete = null;
	                    } else {
	                        --counts;
	                    }
	                };
	            }(this.abstractContents.length);

	            /**
	             * 如果是preRun处理
	             * @return {Boolean} [description]
	             */
	            var isRreRunPocess = function isRreRunPocess(scope) {
	                //针对空跳过处理
	                if (partContentRelated && partContentRelated.length && -1 !== partContentRelated.indexOf(scope.id)) {
	                    captureAnimComplete();
	                } else {
	                    //必须要修改
	                    if (scope.$contentNode) {
	                        if (scope.canvasMode) {
	                            console.log('canvsa isRreRunPocess');
	                            //直接改变元素状态
	                            //scope.$contentNode.view.style.visible = scope.isRreRun === 'visible' ? true : false;
	                        } else {
	                            //因为执行的顺序问题，动画与页面零件
	                            //isscroll标记控制
	                            if (!scope.$contentNode.attr('isscroll')) {
	                                scope.$contentNode.css({
	                                    'visibility': scope.isRreRun
	                                });
	                            }
	                        }
	                    }
	                    captureAnimComplete();
	                }
	            };

	            //执行动画
	            this.eachAssistContents(function (scope) {
	                if (scope.isRreRun) {
	                    isRreRunPocess(scope);
	                } else {

	                    //标记动画正在运行
	                    scope.$contentNode && scope.$contentNode.prop && scope.$contentNode.prop({
	                        'animOffset': scope.$contentNode.offset()
	                    });

	                    //ppt动画
	                    //ppt音频
	                    scope.play(function () {
	                        captureAnimComplete(scope);
	                    });
	                }
	            });

	            this.runState = true;
	        }

	        /**
	         * 停止动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stopAnimation',
	        value: function stopAnimation() {
	            var pageId = this.relatedData.pageId;
	            this.runState = false;
	            this.eachAssistContents(function (scope) {
	                !scope.isRreRun && scope.stop && scope.stop(pageId);
	            });
	        }

	        /**
	         * 销毁动画
	         * @param  {[type]} elementCallback [description]
	         * @return {[type]}                 [description]
	         */

	    }, {
	        key: '_destroyAnimation',
	        value: function _destroyAnimation(elementCallback) {
	            //销毁拖动对象
	            accessDrop(this.eventData, function (drop) {
	                drop.destroy();
	            });
	            this.eachAssistContents(function (scope) {
	                if (scope.destroy) {
	                    scope.destroy();
	                }
	                elementCallback && elementCallback(scope);
	            });
	        }

	        /**
	         * 自动运行
	         * @param  {[type]} outComplete [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: 'autoPlay',
	        value: function autoPlay(outComplete) {
	            var eventData = this.eventData;
	            if (eventData && eventData.eventName === 'auto') {
	                this.runAnimation(outComplete);
	            } else {
	                outComplete();
	            }
	        }

	        /**
	         * 复位状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            this.eachAssistContents(function (scope) {
	                !scope.isRreRun && scope.reset && scope.reset(); //ppt动画
	            });

	            this._resetAloneAnim();
	        }

	        /**
	         * 停止动作
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            if (this.runState) {
	                this.stopAnimation();
	            }
	            this.preventRepeat = false;

	            //复位盒子
	            if (this.htmlBoxInstance.length) {
	                _.each(this.htmlBoxInstance, function (instance) {
	                    instance.removeBox();
	                });
	            }

	            //修复妙妙客户端
	            //没有点击音频结束的回调
	            //最多允许播放5秒
	            if (this._fixAudio.length) {
	                _.each(this._fixAudio, function (instance) {
	                    setTimeout(function () {
	                        instance.end();
	                    }, 5000);
	                });
	                this._fixAudio = [];
	            }
	        }

	        //销毁
	        //提供一个删除回调
	        //用于处理浮动对象的销毁

	    }, {
	        key: 'destroy',
	        value: function destroy(elementCallback) {

	            //销毁绑定事件
	            if (this.eventData.eventContext) {
	                destroyContentEvent(this.eventData);
	                this.eventData.eventContext = null;
	            }

	            //2016.1.7
	            //如果有文本框事件
	            //一个activity允许有多个文本框
	            //所以是数组索引
	            if (this.htmlBoxInstance.length) {
	                _.each(this.htmlBoxInstance, function (instance) {
	                    instance.destroy();
	                });
	                this.htmlBoxInstance = null;
	            }

	            //销毁动画
	            this._destroyAnimation(elementCallback);
	            this.abstractContents = null;

	            //iscroll销毁
	            if (this.iscroll) {
	                this.iscroll.destroy();
	                this.iscroll = null;
	            }

	            //销毁搜索框
	            if (this.searchBar) {
	                this.searchBar.destroy();
	                this.searchBar = null;
	            }

	            //销毁书签
	            if (this.bookMark) {
	                this.bookMark.destroy();
	                this.bookMark = null;
	            }

	            this.$containsNode = null;
	        }
	    }]);
	    return Activity;
	}();

	var activitProto = Activity.prototype;

	textBoxMixin(activitProto);
	bookMarkMixin(activitProto);
	searchBarMixin(activitProto);
	eventMixin(activitProto);

	//零件类型,快速判断
	//新增content卷滚区域,所有JS零件content
	//类型选择,content有扩充的子类型
	//针对零件类型在category字段中的子分类
	var widgetType = {};
	_.each("jsWidget content svgWidget canvasWidget path".split(" "), function (key, name) {
	    widgetType[key] = true;
	});

	/**
	 * 类型统一
	 * @param  {[type]} activity [description]
	 * @return {[type]}          [description]
	 */
	function unifyType(activity) {
	    //满足条件统一为零件类型
	    return widgetType[activity.category] ? "JsWidget" : activity.actType;
	}

	/**
	 * 创建事件容器
	 * @param  {[type]} eventId [description]
	 * @return {[type]}         [description]
	 */
	function createEventContainer(relateds, eventId) {
	    if (!relateds.seasonRelated[eventId]) {
	        relateds.seasonRelated[eventId] = {};
	    }
	}

	/**
	 * 配合出item中相关信息
	 * 1.场景信息
	 * 2.收费信息
	 * @param  {[type]} tokens [description]
	 * @return {[type]}        [description]
	 */
	function adapterItemArrayRelated(relateds, activitys, tokens) {
	    //如果分解出节信息
	    var seasonId,
	        inAppValue,
	        chapterId,
	        values,
	        eventId = activitys.imageId;

	    _.each(['seasonId', 'Inapp', 'SearchBar', 'BookMarks'], function (type) {
	        values = tokens[type];
	        //如果有值
	        if (values !== undefined) {
	            //创建容器
	            createEventContainer(relateds, eventId);
	            switch (type) {
	                //跳转新场景信息
	                case 'seasonId':
	                    chapterId = tokens['chapterId'] || tokens['chapter'];
	                    relateds.seasonRelated[eventId] = {
	                        seasonId: values[0],
	                        chapterId: chapterId ? chapterId[0] : ''
	                    };
	                    break;
	                //收费信息,给事件上绑定收费接口
	                //0 收费 1 已收费
	                case 'Inapp':
	                    relateds.seasonRelated[eventId]['Inapp'] = values[0];
	                    break;
	                default:
	                    //搜索栏
	                    //书签
	                    relateds.seasonRelated[eventId][type] = eventId;
	                    break;
	            }
	        }
	    });
	}

	/**************************************************************************
	 *
	 *      分组Content表中对应的多个Conte
	 *      1：Animation表
	 *      2: Parallax表
	 *      3: seed种子合集 就是解析1：Animation表，Parallax表得到的数据
	 *
	 ****************************************************************************/
	function resolveContentToActivity(callback, activity, pageType, pid) {
	    var animContentIds,
	        paraContentIds,
	        parallaxRelated,
	        parallaxDas,
	        animRelated,
	        animationDas = '',
	        eventId = activity.imageId,

	    //需要分解的contentIds合集
	    // 1 动画表数据      Animation
	    // 2 视觉差数据     Parallax
	    // 3 超链接            seasonId
	    // 4 收费         Inapp
	    tokens = tokenize(activity['itemArray']) || [],

	    //解析Animations,Parallaxs数据
	    //  seed {
	    //      Animation:[data,Ids]
	    //      Parallax:[data,Ids]
	    //  }
	    seed = callback(tokens),


	    //判断类型
	    type = Object.keys(seed)[0];

	    /**
	     * 去重事件ID
	     * original  原ID合集
	     * detection 需要检测去重的ID
	     *
	     */
	    function toRepeatContents(original) {
	        if (original && eventId) {
	            var indexOf = original.indexOf(eventId);
	            if (-1 !== indexOf) {
	                original.splice(indexOf, 1);
	            }
	        }
	    }

	    switch (type) {
	        //容器
	        case 'Container':
	            animContentIds = seed.Container;
	            toRepeatContents(animContentIds);
	            break;
	        //多事件处理
	        case 'Contents':
	            return seed.Contents;
	        default:
	            /**
	             * 如果是对象处理，
	             * 针对动画表，视觉差表,行为的处理
	             */
	            //需要创建的content合集
	            if (_.keys(seed).length) {
	                animRelated = seed.Animation;
	                parallaxRelated = seed.Parallax;
	                //页面模式
	                if (pageType === 'page') {
	                    if (animRelated) {
	                        animContentIds = animRelated.ids;
	                        animationDas = animRelated.das;
	                    }
	                } else {
	                    //视觉差存在视觉差表处理
	                    // console.log(1111,animRelated, parallaxRelated)
	                    //母版的动画数据
	                    if (animRelated) {
	                        animContentIds = animRelated.ids;
	                        animationDas = animRelated.das;
	                    }
	                    //母版的视察数据
	                    if (parallaxRelated) {
	                        paraContentIds = parallaxRelated.ids;
	                        parallaxDas = parallaxRelated.das;
	                    }
	                }

	                //如果id都存在
	                //合并
	                if (animContentIds && paraContentIds) {
	                    animContentIds = animContentIds.concat(paraContentIds);
	                }

	                //只存在视察
	                if (!animContentIds && paraContentIds) {
	                    animContentIds = paraContentIds;
	                }
	                toRepeatContents(animContentIds);
	            }
	            break;
	    }

	    //创建对象是层次关系
	    return {
	        'pageType': pageType,
	        'activity': activity,
	        'imageIds': eventId,
	        //data
	        'seed': {
	            'animation': animationDas,
	            'parallax': parallaxDas
	        },
	        //id
	        'ids': {
	            'content': animContentIds,
	            'parallax': paraContentIds
	        }
	    };
	}

	/************************************************************************
	 *
	 *     合并,过滤需要处理的content
	 *     combineImageIds  可以创建的imageId合集，也就是content的合集,用来绑定自定义事件
	 *     createContentIds 可以创建的content合集,过滤合并重复
	 *
	 * **********************************************************************/
	function toRepeatCombineGroup(compilerActivitys, mixFilterRelated, pageType) {
	    var ids,
	        contentIds,
	        needCreateContentIds,
	        imageIds,
	        activityRelated,
	        parallaxId,
	        combineItemIds = [],
	        combineImageIds = [],
	        i = compilerActivitys.length;

	    function pushCache(target, original, callback) {
	        var id,
	            i = original.length;
	        while (i--) {
	            id = Number(original[i]);
	            target.push(id);
	            callback && callback(id);
	        }
	    }

	    while (i--) {
	        //开始执行过滤操作
	        activityRelated = compilerActivitys[i];
	        ids = activityRelated.ids;
	        contentIds = ids.content;
	        parallaxId = ids.parallax; //浮动类型的对象
	        imageIds = activityRelated.imageIds;

	        //针对普通content对象
	        if (contentIds && contentIds.length) {
	            //如果不为空
	            pushCache(combineItemIds, contentIds);
	        }

	        //视察对象
	        if (parallaxId && parallaxId.length) {
	            //如果不为空
	            pushCache(combineItemIds, parallaxId);
	        }

	        //事件合集
	        if (imageIds) {
	            combineImageIds.push(Number(imageIds));
	        }
	    }

	    //混入外部合并了逻辑
	    if (mixFilterRelated && mixFilterRelated.length) {
	        _.each(mixFilterRelated, function (data) {
	            if (data) {
	                combineItemIds = combineItemIds.concat(data);
	            }
	        });
	    }

	    //过滤合并多个content数据
	    if (combineImageIds.length) {
	        needCreateContentIds = arrayUnique(combineItemIds.concat(combineImageIds));
	    } else {
	        needCreateContentIds = arrayUnique(combineItemIds);
	    }

	    //排序
	    needCreateContentIds = needCreateContentIds.sort(function (a, b) {
	        return a - b;
	    });

	    /**
	     * 合并创建信息
	     * 需要创建的事件
	     * 需要创建的所有对象
	     */
	    return [combineImageIds, needCreateContentIds];
	}

	/**
	 * 解析指定类型数据
	 * strengthenAnmin 视觉差增强动画表
	 * @return {[type]}
	 */
	function parseTypeRelation(tableName, tokenIds) {
	    var tokenId;
	    var itemData = {};
	    _.each(tableName, function (tName) {
	        if (tokenId = tokenIds[tName]) {
	            if (itemData[tName]) {
	                console.log('未处理解析同一个表');
	            } else {
	                itemData[tName] = inGroup(tName, tokenId);
	            }
	        }
	    });
	    return itemData;
	}

	/**
	 * 分组
	 * @return {[type]} [description]
	 */
	function inGroup(tableName, contentIds) {
	    var k,
	        keyName,
	        data,
	        contentId,
	        temp = {},
	        das = [],
	        ids = [],
	        query = Xut.data.query;

	    _.each(contentIds, function (id) {
	        if (data = query(tableName, id)) {
	            contentId = data.contentId;
	            if (-1 === ids.indexOf(contentId)) {
	                ids.push(contentId);
	            }
	            //合并同个contentId多条动画数据的情况
	            keyName = "contentId-" + contentId;
	            if (temp[keyName]) {
	                temp[keyName].push(data);
	            } else {
	                temp[keyName] = [data];
	            }
	        }
	    });

	    //转成数组格式
	    for (k in temp) {
	        das.push(temp[k]);
	    }

	    return {
	        das: das,
	        ids: ids
	    };
	}

	//解析itemArray序列,得到对应的id
	function tokenize(itemArray) {
	    var itemJson,
	        actType,
	        anmins = {};
	    if (!itemArray) return;
	    itemJson = parseJSON(itemArray);
	    //解析多个参数
	    if (itemJson.length) {
	        _.each(itemJson, function (opts) {
	            actType = opts.actType;
	            if (!anmins[actType]) {
	                anmins[actType] = [];
	            }
	            anmins[actType].push(opts.id);
	        });
	    } else {
	        actType = itemJson.actType;
	        anmins[actType] = [];
	        //actType: "Animation", id: 14
	        //actType: "Inapp", value: 0
	        anmins[actType].push(itemJson.id || itemJson.value);
	    }
	    return anmins;
	}

	/**
	 * 解析出需要构建的content对象
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	function activityParser(activityData) {
	    var actType = void 0;
	    var compileContent = [];

	    //需要创建的数据结构
	    _.each(activityData.activitys, function (activityData) {
	        actType = activityData.actType || activityData.animation;
	        //特殊类型 showNote
	        if (!actType && activityData.note) {
	            activityData['actType'] = actType = "ShowNote";
	        }
	        //匹配content处理相关类型
	        if (activityData.itemArray || activityData.autoPlay !== 2) {
	            switch (actType) {
	                case 'Container':
	                case 'Content':
	                case 'Parallax':
	                case 'Contents':
	                    compileContent.push(activityData);
	                    break;
	            }
	        }
	    });

	    return compileContent;
	}

	/**
	 * 解析解析每一条 Activitys 对应的数据结构
	 * @param  {[type]} compileActivitys [description]
	 * @param  {[type]} data             [description]
	 * @return {[type]}                  [description]
	 */
	function contentParser(compileActivitys, data) {

	    var activitys,
	        hookType,
	        resultsActivitys,
	        //结果结合
	    i = compileActivitys.length,
	        pageType = data.pageType,
	        pid = data.pid,


	    /**
	     * 相关数据合集
	     * @type {Object}
	     */
	    activityRelated = [],
	        //Activit合集相关数据信息
	    tempRelated = [],
	        //临时数据

	    /**
	     * 解析出来的相关信息
	     * @type {Object}
	     */
	    relateds = {
	        seasonRelated: {}, //节信息
	        containerRelated: [], //容器合集相关数据信息
	        eventRelated: {}, //多事件容器合集
	        partContentRelated: [] //卷滚conten只创建,不处理行为
	    };

	    /**
	     * 创建解析
	     * @param  {Function} callback [description]
	     * @return {[type]}            [description]
	     */
	    var createResolve = function createResolve(callback) {
	        return resolveContentToActivity(function (tokens) {
	            return callback(tokens);
	        }, activitys, pageType, pid);
	    };

	    /**
	     * 类型处理器
	     * 除去动画的其余处理类型
	     * @type {Object}
	     */
	    var hookResolve = {

	        /**
	         * 单独处理容器类型
	         * @param  {[type]} relateds [description]
	         * @return {[type]}          [description]
	         */
	        Container: function Container() {
	            relateds.containerRelated.push(createResolve(function (tokens) {
	                return {
	                    'Container': tokens['Content']
	                };
	            }));
	        },


	        /**
	         * 多事件
	         * @param  {[type]} relateds [description]
	         * @return {[type]}          [description]
	         */
	        Contents: function Contents() {
	            var item;
	            if (item = createResolve(function (tokens) {
	                return {
	                    'Contents': [tokens]
	                };
	            })[0]) {
	                //给content注册多个绑定事件
	                var eventId = activitys.imageId;
	                var eventData = {
	                    'eventContentId': eventId,
	                    'activityId': activitys._id,
	                    'registers': item['activity'],
	                    'eventType': activitys.eventType,
	                    'dragdropPara': activitys.para1 //拖拽对象
	                };
	                var isEvt = relateds.eventRelated['eventContentId->' + eventId];
	                if (isEvt) {
	                    isEvt.push(eventData);
	                } else {
	                    relateds.eventRelated['eventContentId->' + eventId] = [eventData];
	                }
	            }
	        },


	        /**
	         * 所有js零件
	         * @param  {[type]} relateds [description]
	         * @return {[type]}          [description]
	         */
	        JsWidget: function JsWidget() {
	            var scrollContents = parseJSON(activitys.itemArray);
	            if (_.isArray(scrollContents)) {
	                _.each(scrollContents, function (data) {
	                    relateds.partContentRelated.push(data.id);
	                });
	            } else {
	                relateds.partContentRelated.push(scrollContents.id);
	            }
	        }
	    };

	    /**
	     * 解析出当前页面的所有的Activit表
	     * 1个chpater页面 可以对应多个Activit表中的数据
	     * 1 Container 容器类型
	     * 2 page 类型
	     * 3 parallax 类型
	     * 4 Scenario 类型
	     * 5 content合集 contents处理
	     */
	    while (activitys = compileActivitys.shift()) {
	        //统一类型
	        hookType = unifyType(activitys);
	        if (!hookResolve[hookType] //类型匹配
	        || hookResolve[hookType] && hookResolve[hookType](relateds)) {
	            //钩子事件
	            //如果是动画表,视觉差表关联的content类型
	            resultsActivitys = createResolve(function (tokens) {
	                //解析itemArray字段中的相关的信息
	                adapterItemArrayRelated(relateds, activitys, tokens);
	                if (pageType === 'page') {
	                    //页面只有动画
	                    return parseTypeRelation(['Animation'], tokens);
	                } else if (pageType === 'master') {
	                    //新增第三个参数，
	                    //视觉差支持所有content动画
	                    return parseTypeRelation(['Animation', 'Parallax'], tokens);
	                }
	            });

	            //如果有手动触发器,置于最后
	            if (activitys.imageId) {
	                tempRelated.push(resultsActivitys);
	            } else {
	                activityRelated.push(resultsActivitys);
	            }

	            resultsActivitys = null;
	        }
	    }

	    //合并排序
	    if (tempRelated.length) {
	        activityRelated = activityRelated.concat(tempRelated);
	        tempRelated = null;
	    }

	    /**
	     *  过滤出与创建相关的content合集ID
	     *      createEventIds  主content列表 (用来绑定eventType事件)
	     *      createContentIds 合并所有content操作后,过滤掉重复的content,得到可以创建的content的ID合集
	     */
	    var createRelevant = toRepeatCombineGroup(activityRelated, relateds.partContentRelated, pageType);
	    var createEventIds = createRelevant[0];
	    var createContentIds = createRelevant[1];

	    //如果存在过滤器
	    if (Xut.CreateFilter.size()) {
	        var filterEach = Xut.CreateFilter.each(data.chapterId);
	        if (filterEach) {
	            filterEach(createEventIds, function (indexOf) {
	                createEventIds.splice(indexOf, 1);
	            });
	            filterEach(createContentIds, function (indexOf) {
	                createContentIds.splice(indexOf, 1);
	            });
	            filterEach = null;
	        }
	    }

	    return _.extend(data, relateds, {
	        'createEventIds': createEventIds, //事件ID数
	        'createContentIds': createContentIds, //创建的content总ID数
	        'createActivitys': activityRelated
	    });
	}

	/**
	 * 当监听的节点内容发生变化时,触发指定的回调
	 * @param opts {
	 *   container:父容器,dom对象或jQuery对象
	 *   content  :要加入父容器的内容,字符串或jQuery对象
	 *   position :内容插入父容器的位置,'first' 表示在前加入,默认在末尾
	 *   delay    :延时,默认0
	 *   }
	 * @version  1.02
	 * @author [author] bjtqti
	 * @return {[type]} [description]
	 */

	var DOC = document;
	var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

	var implementation = DOC.implementation.hasFeature("MutationEvents", "2.0");

	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	var _nextTick = function () {
	    var callbacks = [];
	    var pending = false;
	    var timerFunc;

	    function nextTickHandler() {
	        pending = false;
	        var copies = callbacks.slice(0);
	        callbacks = [];
	        for (var i = 0; i < copies.length; i++) {
	            copies[i]();
	        }
	    }

	    if (typeof MutationObserver !== 'undefined' && !Xut.plat.hasMutationObserverBug) {
	        var counter = 1;
	        var observer = new MutationObserver(nextTickHandler);
	        var textNode = document.createTextNode(counter);
	        observer.observe(textNode, {
	            characterData: true
	        });
	        timerFunc = function timerFunc() {
	            counter = (counter + 1) % 2;
	            textNode.data = counter;
	        };
	    } else {
	        // webpack attempts to inject a shim for setImmediate
	        // if it is used as a global, so we have to work around that to
	        // avoid bundling unnecessary code.
	        var context = Xut.plat.isBrowser ? window : typeof global !== 'undefined' ? global : {};
	        timerFunc = context.setImmediate || setTimeout;
	    }
	    return function (cb, ctx) {
	        var func = ctx ? function () {
	            cb.call(ctx);
	        } : cb;
	        callbacks.push(func);
	        if (pending) return;
	        pending = true;
	        timerFunc(nextTickHandler, 0);
	    };
	}();

	var nextTick = function nextTick() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        container = _ref.container,
	        content = _ref.content,
	        position = _ref.position,
	        _ref$delay = _ref.delay,
	        delay = _ref$delay === undefined ? 0 : _ref$delay;

	    var callback = arguments[1];
	    var context = arguments[2];


	    //如果只提供一个回到函数
	    if (arguments.length === 1 && typeof arguments[0] === 'function') {
	        callback = arguments[0];
	        if (typeof callback === 'function') {
	            return _nextTick(callback);
	        }
	        console.log('nextTick: 参数提供错误');
	        return;
	    }

	    if (!container || !content) {
	        return;
	    }

	    //检查容器---$(container) 转为dom对象
	    if (container instanceof $) {
	        container = container[0];
	    }

	    if (container.nodeType !== 1) {
	        console.log('nextTick: container must be HTMLLIElement ');
	        return;
	    }

	    var animatId = 'T' + (Math.random() * 10000 << 1);
	    var tick = DOC.createElement('input');

	    //标记任务
	    tick.setAttribute('value', animatId);

	    //检查内容
	    if (typeof content === 'string') {
	        var temp = $(content);
	        if (!temp[0]) {
	            //纯文本内容
	            temp = DOC.createTextNode(content);
	            temp = $(temp);
	        }
	        content = temp;
	        temp = null;
	    }

	    /**
	     * 完成任务后处理&Observer
	     * @return {[type]} [description]
	     */
	    var _completeTask = function _completeTask() {
	        container.removeChild(tick);
	        callback.call(context);
	        container = null;
	        tick = null;
	        context = null;
	    };

	    /**
	     * 将内容加入父容器
	     * @return {[type]} [description]
	     */
	    var _appendChild = function _appendChild() {
	        //拼接内容
	        var frag = DOC.createDocumentFragment();
	        var len = content.length;
	        for (var i = 0; i < len; i++) {
	            frag.appendChild(content[i]);
	        }
	        frag.appendChild(tick);

	        //判断插入的位置
	        if (position === 'first') {
	            container.insertBefore(frag, container.firstChild);
	        } else {
	            container.appendChild(frag);
	        }

	        frag = null;

	        //触发变动事件
	        tick.setAttribute('value', animatId);
	    };

	    if (MutationObserver) {
	        var observer = new MutationObserver(function (mutations) {
	            mutations.forEach(function (record) {
	                if (record.oldValue === animatId) {
	                    _completeTask();
	                    observer = null;
	                }
	            });
	        });

	        //设置要监听的属性
	        observer.observe(tick, {
	            attributes: true,
	            //childList: true,
	            attributeOldValue: true,
	            attributeFilter: ["value"] //只监听value属性,提高性能
	        });

	        _appendChild();
	    } else {

	        //检测是否支持DOM变动事件
	        if (implementation) {
	            (function () {

	                /**
	                 * 完成任务后处理&Event
	                 * @param  {[type]} event [description]
	                 * @return {[type]}       [description]
	                 */
	                var _finishTask = function _finishTask(event) {
	                    if (event.target.value === animatId) {
	                        //container.removeEventListener('DOMNodeRemoved',_finishTask,false);
	                        container.removeEventListener('DOMNodeInserted', _finishTask, false);
	                        callback.call(context);
	                    }
	                };

	                //container.addEventListener('DOMNodeRemoved',_finishTask,false);
	                container.addEventListener('DOMNodeInserted', _finishTask, false);
	                _appendChild();
	                container.removeChild(tick);
	            })();
	        } else {
	            //歉容Android2.xx处理
	            _appendChild();
	            setTimeout(function () {
	                _completeTask();
	            }, delay);
	        }
	    }
	};

	Xut.nextTick = nextTick;

	var TRANSFORM = Xut.style.transform;

	function createFn(obj, id, callback) {
	    var cObj = obj[id];
	    if (!cObj) {
	        cObj = obj[id] = {};
	    }
	    callback.call(cObj);
	}

	/**
	 * 转成数组格式
	 * @param  {[type]} contentsFragment [description]
	 * @return {[type]}                  [description]
	 */
	function toArray$1(o) {
	    var contentsFragment = [];
	    _.each(o, function ($node) {
	        contentsFragment.push($node);
	    });
	    return contentsFragment;
	}

	/**
	 * 构建快速查询节点对象
	 * 转成哈希方式
	 * @return {[type]} [description]
	 */
	function toObject(cachedContentStr) {
	    var tempFragmentHash = {};
	    _.each($(cachedContentStr), function (ele, index) {
	        tempFragmentHash[ele.id] = ele;
	    });
	    return tempFragmentHash;
	}

	/**
	 * 行为反馈
	 *  content id = {
	 *      弹动
	 *      音频URl
	 *  }
	 */
	function addBehavior(data) {
	    var parameter,
	        soundSrc,
	        contentId,
	        isButton,
	        feedbackBehavior = data.feedbackBehavior = {};
	    _.each(data.activitys, function (activitys) {
	        if (activitys.parameter && (parameter = parseJSON(activitys.parameter))) {
	            contentId = activitys.imageId;
	            //视觉反馈
	            if (isButton = parameter['isButton']) {
	                if (isButton != 0) {
	                    //过滤数据的字符串类型
	                    createFn(feedbackBehavior, contentId, function () {
	                        this['isButton'] = true;
	                    });
	                }
	            }
	            //音频行为
	            if (soundSrc = parameter['behaviorSound']) {
	                if (soundSrc != 0) {
	                    createFn(feedbackBehavior, contentId, function () {
	                        this['behaviorSound'] = soundSrc;
	                    });
	                }
	            }
	        }
	    });
	}

	/**
	 *创建浮动相关的信息
	 * @return {[type]} [description]
	 */
	function crateFloat(callback, floatName, dasFloat, data, base) {

	    var $containsNodes = [];
	    var prefix = 'Content_' + data.pid + "_";

	    //去重复
	    dasFloat.ids = arrayUnique(dasFloat.ids);

	    var makePrefix,
	        fragment,
	        zIndex,
	        zIndexs = dasFloat.zIndex;

	    data.count++;

	    //分离出浮动节点
	    _.each(dasFloat.ids, function (id) {
	        makePrefix = prefix + id;
	        if (fragment = data.contentsFragment[makePrefix]) {
	            zIndex = zIndexs[id];
	            //保证层级关系
	            // fragment.style.zIndex = (Number(zIndex) + Number(fragment.style.zIndex)) 
	            $containsNodes.push(fragment);
	            delete data.contentsFragment[makePrefix];
	        }
	    });

	    //floatPages模式下面
	    //如果是当前页面
	    //因为会产生三页面并联
	    //所以中间去最高层级
	    if (floatName === 'floatPages' && data.getStyle.offset === 0) {
	        zIndex = 2001;
	    } else {
	        zIndex = 2000;
	    }

	    //浮动根节点
	    //floatPages设置的content溢出后处理
	    //在非视区增加overflow:hidden
	    //可视区域overflow:''
	    var overflow = 'overflow:hidden;';
	    //如果是母板,排除
	    if (floatName === 'floatMaters') {
	        overflow = '';
	    }

	    var floatStr = String.format('<div id="' + floatName + '-li-{0}" class="xut-float" style="' + TRANSFORM + ':{1};z-index:' + zIndex + ';{2}"></div>', data.pid, data.getStyle.translate, overflow);

	    var container = $(floatStr);

	    //增加浮动容器
	    $(data.rootNode).after(container);

	    callback($containsNodes, container);
	}

	/**
	 * 创建浮动母版对象
	 * @return {[type]} [description]
	 */
	function createFloatMater(base, data, complete) {
	    //创建浮动对象
	    crateFloat(function ($containsNodes, container) {
	        //浮动容器
	        data.floatMaters.container = container;

	        nextTick({
	            'container': container,
	            'content': $containsNodes
	        }, function () {
	            //收集浮动母版对象标识
	            base.pageBaseHooks.collector.floatMaters(data.floatMaters);
	            complete(data);
	        });
	    }, 'floatMaters', data.floatMaters, data, base);
	}

	/**
	 * 创建浮动的页面对象
	 */
	function createFloatPage(base, data, complete) {
	    //创建浮动对象
	    crateFloat(function ($containsNodes, container) {
	        //浮动容器
	        data.floatPages.container = container;
	        nextTick({
	            'container': container,
	            'content': $containsNodes
	        }, function () {
	            //收集浮动母版对象标识
	            base.pageBaseHooks.collector.floatPages(data.floatPages);
	            complete(data);
	        });
	    }, 'floatPages', data.floatPages, data, base);
	}

	/** 配置ID
	 * @return {[type]} [description]
	 */
	function autoUUID() {
	    return 'autoRun-' + Math.random().toString(36).substring(2, 15);
	}

	/**
	 * 给所有content节点绑定对应的事件与动画
	 * 1 动画
	 * 2 事件
	 * 3 视觉差
	 * 4 动画音频
	 * 5 canvas动画
	 * @return {[type]} [description]
	 */
	function bindActivitys(data, contentDas, callback) {
	    var compiler,
	        $containsNode = data.$containsNode,
	        eventRelated = data.eventRelated,
	        //合集事件
	    pid = data.pid,
	        createActivitys = data.createActivitys,
	        feedbackBehavior = data.feedbackBehavior,
	        //反馈数据,跟事件相关
	    pageBaseHooks = data.pageBaseHooks,
	        pageId = data.chapterId;

	    //如果有浮动对象,才需要计算偏移量
	    //母版里面可能存在浮动或者不浮动的对象
	    //那么在布局的时候想对点不一样
	    //如果在浮动区域就取浮动初始值
	    //否则就是默认的想对点0
	    var transformOffset = function (ids, initTransformOffset) {
	        return function (id) {
	            //匹配是不是属于浮动对象
	            if (ids.length && ids[id]) {
	                //初始化容器布局的坐标
	                return initTransformOffset;
	            }
	            return 0;
	        };
	    }(data.floatMaters.ids, data.getStyle.offset);

	    //相关回调
	    var relatedCallback = {
	        //绑定卷滚条钩子
	        'iscrollHooks': [],
	        //contetn钩子回调
	        'contentsHooks': pageBaseHooks.collector.contents
	    };

	    //相关数据
	    var relatedData = {
	        'floatMaters': data.floatMaters,
	        'seasonId': data.chpaterData.seasonId,
	        'pageId': pageId,
	        'contentDas': contentDas, //所有的content数据合集
	        'container': data.liRootNode,
	        'seasonRelated': data.seasonRelated,
	        'containerPrefix': data.containerPrefix,
	        'nodes': data.nodes,
	        'pageOffset': data.pageOffset,
	        'createContentIds': data.createContentIds,
	        'partContentRelated': data.partContentRelated,
	        'transformOffset': transformOffset,
	        'contentsFragment': data.contentsFragment,
	        'contentHtmlBoxIds': data.contentHtmlBoxIds
	    };

	    /**
	     * 继续下一个任务
	     * @return {[type]} [description]
	     */
	    var nextTask = function nextTask() {
	        //多事件合集处理pagebase
	        if (eventRelated) {
	            pageBaseHooks.eventBinding && pageBaseHooks.eventBinding(eventRelated);
	        }
	        //删除钩子
	        delete relatedCallback.contentsHooks;
	        callback(relatedCallback);
	    };

	    /**
	     * 生成activty控制对象
	     * @type {[type]}
	     */
	    var makeActivitys = function makeActivitys(compiler) {
	        return function (callback) {
	            var filters;
	            var imageId = compiler['imageIds']; //父id
	            var activity = compiler['activity'];
	            var eventType = activity.eventType;
	            var dragdropPara = activity.para1;
	            var eventContentId = imageId;

	            /**
	             * 多事件数据过滤
	             * 为了防止数据写入错误数据
	             * 如果当前对象上有多事件的行为
	             * 则默认的事件去掉
	             * @type {[type]}
	             */
	            if (filters = eventRelated['eventContentId->' + imageId]) {
	                _.each(filters, function (edata) {
	                    //id不需要
	                    //eventContentId = void 0;
	                    if (edata.eventType == activity.eventType) {
	                        //写入的是伪数据,此行为让多事件抽象接管
	                        eventType = dragdropPara = undefined;
	                    }
	                });
	            }

	            //需要绑定事件的数据
	            var eventData = {
	                'eventContentId': eventContentId,
	                'eventType': eventType,
	                'dragdropPara': dragdropPara,
	                'feedbackBehavior': feedbackBehavior
	            };

	            var actdata = {
	                'noticeComplete': callback, //监听完成
	                'pageIndex': data.pageIndex,
	                'canvasRelated': data.canvasRelated, //父类引用
	                'id': imageId || autoUUID(),
	                "type": 'Content',
	                'pageId': pageId,
	                'activityId': activity._id,
	                '$containsNode': $containsNode,
	                'pageType': compiler['pageType'], //构建类型 page/master
	                'seed': compiler['seed'], //动画表数据 or 视觉差表数据
	                "pid": pid, //页码
	                'eventData': eventData, //事件数据
	                'relatedData': relatedData, //相关数据,所有子作用域Activity对象共享
	                'relatedCallback': relatedCallback //相关回调
	            };

	            //注册引用
	            pageBaseHooks.registerAbstractActivity(new Activity(actdata));
	        };
	    };

	    //制作curry Activity闭包
	    var fnsActivity = [];
	    while (compiler = createActivitys.shift()) {
	        fnsActivity.push(makeActivitys(compiler));
	    }

	    // 递归解析 activitys
	    var recursiveParse = function recursiveParse() {
	        if (!fnsActivity.length) {
	            nextTask();
	            return;
	        }
	        var first = fnsActivity.shift();
	        first(function () {
	            recursiveParse();
	        });
	    };
	    recursiveParse();
	}

	/**
	 * content任务类
	 */

	var TaskContents = function () {
	    function TaskContents(activityData) {
	        classCallCheck(this, TaskContents);


	        _.extend(this, activityData);

	        //只解析content有关的activityData
	        var compileActivitys = activityParser(activityData);

	        //如果有预执行动作
	        //Activity表数据存在
	        if (compileActivitys) {
	            //解析动画表数据结构
	            activityData = contentParser(compileActivitys, activityData);

	            //如果有需要构建的content
	            //开始多线程处理
	            activityData.createContentIds.length ? this._dataAfterCheck(activityData) : this._loadComplete();
	        } else {
	            this._loadComplete();
	        }
	    }

	    /**
	     * 构建完毕
	     * @return {[type]} [description]
	     */


	    createClass(TaskContents, [{
	        key: '_loadComplete',
	        value: function _loadComplete() {
	            this.pageBaseHooks.success();
	        }

	        /**
	         * 任务断言
	         */

	    }, {
	        key: '_assert',
	        value: function _assert(taskName, tasks) {

	            var self = this;

	            //中断方法
	            var suspendTasks = function suspendTasks() {
	                self.suspendQueues = [];
	                self.suspendQueues.push(function () {
	                    tasks.call(self);
	                });
	            };

	            //完成方法
	            var nextTasks = function nextTasks() {
	                tasks.call(self);
	            };

	            self.pageBaseHooks.suspend(taskName, nextTasks, suspendTasks);
	        }

	        /**
	         * 中断一:构建数据之后
	         * @param  {[type]} data [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: '_dataAfterCheck',
	        value: function _dataAfterCheck(data) {

	            this._assert('dataAfter', function () {
	                var _this = this;

	                //浮动模板
	                //用于实现模板上的事件
	                data.floatMaters = {
	                    'ids': [], //浮动id
	                    'container': {}, //浮动容器
	                    'zIndex': {}
	                };

	                //浮动页面
	                //母板事件引起的层级遮挡问题
	                //用于提升最高
	                data.floatPages = {
	                    'ids': [],
	                    'zIndex': {}
	                };

	                //增加点击行为反馈
	                addBehavior(data);

	                //构建页面content类型结构
	                //contentDas, contentStr, containerPrefix, idFix, contentHtmlBoxIds
	                structure(function (userData) {

	                    data.contentHtmlBoxIds = userData.contentHtmlBoxIds;
	                    data.contentsFragment = {};

	                    //iboosk节点预编译
	                    //在执行的时候节点已经存在
	                    //不需要在创建
	                    if (Xut.IBooks.runMode()) {
	                        _.each(userData.idFix, function (id) {
	                            data.contentsFragment[id] = data.$containsNode.find("#" + id)[0];
	                        });
	                    } else {
	                        //构件快速查询节点对象
	                        data.contentsFragment = toObject(userData.contentStr);
	                        delete userData.contentStr;
	                    }

	                    //容器的前缀
	                    data.containerPrefix = userData.containerPrefix;

	                    /* eslint-disable */
	                    //2015.5.6暴露到全局
	                    //提供给音频字幕上下文
	                    if (!Xut.Contents.contentsFragment[data.chapterId]) {
	                        Xut.Contents.contentsFragment[data.chapterId];
	                    }
	                    Xut.Contents.contentsFragment[data.chapterId] = data.contentsFragment;
	                    /* elist-enable */

	                    //开始下一个任务
	                    _this._dataStrCheck(data, userData.contentDas);
	                }, data, this);
	            });
	        }

	        /**
	         * 中断二:构建结构之后
	         * @param  {[type]} data       [description]
	         * @param  {[type]} contentDas [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_dataStrCheck',
	        value: function _dataStrCheck(data, contentDas) {
	            this._assert('strAfter', function () {
	                var _this2 = this;

	                //保留场景的留信息
	                //用做软件制作单页预加载
	                Xut.sceneController.seasonRelated = data.seasonRelated;

	                //初始化content对象
	                bindActivitys(data, contentDas, function (delayHooks) {
	                    return _this2._eventAfterCheck(data, delayHooks);
	                });
	            });
	        }

	        /**
	         * 中断三:绑定事件事件之后
	         * @param  {[type]} iScrollHooks [description]
	         * @return {[type]}              [description]
	         */

	    }, {
	        key: '_eventAfterCheck',
	        value: function _eventAfterCheck(data, delayHooks) {

	            var self = this;

	            this._assert('eventAfter', function () {

	                data.count = 1; //计算回调的成功的次数

	                /**
	                 * 完成钩子函数
	                 * 1 content的卷滚条
	                 * 2 canvas事件绑定
	                 * @return {[type]} [description]
	                 */
	                var completeHooks = function completeHooks() {
	                    var hooks;
	                    _.each(delayHooks, function (fns) {
	                        while (hooks = fns.shift()) {
	                            hooks();
	                        }
	                    });
	                };

	                var nextTask = function nextTask() {
	                    completeHooks();
	                    self._applyAfterCheck();
	                };

	                /**
	                 * 1 页面浮动
	                 * 2 母版浮动
	                 * 3 正常对象
	                 */
	                var complete = function (data) {
	                    return function () {
	                        if (data.count === 1) {
	                            nextTask();
	                            return;
	                        }
	                        data.count--;
	                    };
	                }(data);

	                //浮动页面对
	                //浮动对象比任何层级都都要高
	                //超过母版
	                if (data.floatPages.ids && data.floatPages.ids.length) {
	                    createFloatPage(this, data, complete);
	                }

	                //如果存在母版浮动节点
	                //在创建节点structure中过滤出来，根据参数的tipmost
	                if (data.floatMaters.ids && data.floatMaters.ids.length) {
	                    createFloatMater(this, data, complete);
	                }

	                //iboosk节点预编译
	                //在执行的时候节点已经存在
	                //不需要在创建
	                if (Xut.IBooks.runMode()) {
	                    complete();
	                } else {
	                    //正常对象
	                    nextTick({
	                        'container': data.$containsNode,
	                        'content': toArray$1(data.contentsFragment)
	                    }, complete);
	                }
	            });
	        }

	        /**
	         * 中断四：渲染content
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_applyAfterCheck',
	        value: function _applyAfterCheck() {
	            this._assert('applyAfter', function () {
	                this._loadComplete(true);
	            });
	        }

	        /**
	         * 运行被阻断的线程任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'runSuspendTasks',
	        value: function runSuspendTasks() {
	            if (this.suspendQueues) {
	                var fn;
	                if (fn = this.suspendQueues.pop()) {
	                    fn();
	                }
	                this.suspendQueues = null;
	            }
	        }

	        /**
	         * 清理引用
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'clearReference',
	        value: function clearReference() {
	            //删除字幕用的碎片文档
	            if (Xut.Contents.contentsFragment[this.chapterId]) {
	                delete Xut.Contents.contentsFragment[this.chapterId];
	            }
	            this.canvasRelated = null;
	            this.pageBaseHooks = null;
	            this.$containsNode = null;
	            this.rootNode = null;
	            this.contentsFragment = null;
	        }
	    }]);
	    return TaskContents;
	}();

	/**
	 * 获取访问对象参数
	 * 如果pageObj 不存在，则取当前页面的
	 * @return {[type]} [description]
	 */
	function access$1(pageObj, callback) {
	    var flag = void 0,
	        contents = void 0,
	        components = void 0,
	        pageType = void 0;

	    //如果只提供回调函数
	    if (arguments.length === 1 && _.isFunction(pageObj)) {
	        callback = pageObj;
	        pageObj = Xut.Presentation.GetPageObj();
	    } else {
	        pageObj = pageObj || Xut.Presentation.GetPageObj();
	    }

	    if (pageObj) {
	        contents = pageObj.baseGetContent();
	        components = pageObj.baseGetComponent();
	        pageType = pageObj.pageType || 'page';
	        flag = callback(pageObj, contents.length && contents, components.length && components, pageType);
	    }
	    return flag;
	}

	/**
	 * by 2016.6.30
	 * judgment is backstage run
	 * Take the opposite judgment
	 * @return {[type]} [description]
	 */
	var allowNext = function allowNext() {
	    if (window.MMXCONFIG) {
	        return function () {
	            return !(window.MMXCONFIG.back || Xut.Application.IsBackStage());
	        };
	    } else {
	        return function () {
	            return !false;
	        };
	    }
	};

	var allowNext$1 = allowNext();

	var noop$2 = function noop() {};

	/**
	 * 运行自动的content对象
	 * 延时500毫秒执行
	 * @return {[type]} [description]
	 */
	var autoContents = function autoContents(contentObjs, taskAnimCallback) {

	    var markComplete = function () {
	        var completeStatistics = contentObjs.length; //动画完成统计
	        return function () {
	            if (completeStatistics === 1) {
	                taskAnimCallback && taskAnimCallback();
	                markComplete = null;
	            }
	            completeStatistics--;
	        };
	    }();

	    _.each(contentObjs, function (obj, index) {
	        if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
	            //同一个对象类型
	            //直接调用对象接口
	            obj.autoPlay(markComplete);
	        } else {
	            markComplete();
	        }
	    });
	};

	/**
	 * 运行自动的静态类型
	 * @return {[type]} [description]
	 */
	var autoComponents = function autoComponents(pageObj, pageIndex, autoData, pageType) {

	    var chapterId = pageObj.baseGetPageId(pageIndex);
	    var dir = void 0;

	    if (pageIndex === undefined) {
	        pageIndex = Xut.Presentation.GetPageIndex();
	    }

	    _.each(autoData, function (data, index) {
	        dir = directives[data.actType];
	        //零件类型的接口调用不一致
	        //这里需要转接口处理
	        if (dir && dir.autoPlay) {
	            dir.autoPlay({
	                'id': data.id,
	                'pageType': pageType,
	                'rootNode': pageObj.getContainsNode(),
	                'chapterId': chapterId,
	                'category': data.category,
	                'autoPlay': data.autoPlay,
	                'pageIndex': pageIndex
	            });
	        }
	    });
	};

	/**
	 * 自动动作
	 * @param  {[type]} pageObj          [description]
	 * @param  {[type]} pageIndex        [description]
	 * @param  {[type]} taskAnimCallback [description]
	 * @return {[type]}                  [description]
	 */
	function $$autoRun(pageObj, pageIndex, taskAnimCallback) {

	    /**
	     * 编译IBOOKSCONFIG的时候过滤自动运行的调用
	     * @return {[type]}              [description]
	     */
	    if (Xut.IBooks.compileMode()) {
	        return;
	    }

	    //When the home button by invoking
	    //Does not perform automatic animation
	    //fix 2016.6.29
	    // originalApp
	    // window.miaomiaoxue.back = 1;
	    // activateApp
	    // window.miaomiaoxue.back = 0;
	    if (!allowNext$1()) {
	        taskAnimCallback();
	        return;
	    }

	    //pageType
	    //用于区别触发类型
	    //页面还是母版
	    access$1(pageObj, function (pageObj, contentObjs, componentObjs, pageType) {

	        //如果是母版对象，一次生命周期种只激活一次
	        if (pageObj.pageType === 'master') {
	            if (pageObj.onceMaster) {
	                return;
	            }
	            pageObj.onceMaster = true;
	        }

	        taskAnimCallback = taskAnimCallback || noop$2;

	        var autoData = pageObj.baseAutoRun();
	        if (autoData) {
	            autoComponents(pageObj, pageIndex, autoData, pageType);
	        }

	        if (contentObjs) {
	            autoContents(contentObjs, taskAnimCallback);
	        } else {
	            taskAnimCallback(); //无动画
	        }

	        Xut.log('debug', pageType + '层，第' + (pageIndex + 1) + '页开始,本页面Id为' + pageObj.chapterId);
	    });
	}

	function $$trigger(target, attribute, rootNode, pageIndex) {

	    var key = target.id;

	    if (key) {
	        var tag = key.split('_');
	        var type = tag[0];
	        var id = tag[1];
	        var dir = directives[type];

	        if (dir && dir.trigger) {

	            //获取页面类型
	            var pageType = function () {
	                if (rootNode && rootNode.id) {
	                    return (/page/.test(rootNode.id) ? 'page' : 'master'
	                    );
	                } else {
	                    return 'page';
	                }
	            }();

	            var data = {
	                "id": id,
	                "activityId": id,
	                "key": key,
	                "type": type,
	                "rootNode": rootNode,
	                "target": target,
	                "pageIndex": pageIndex,
	                'pageType': pageType
	            };

	            //如果是重复点击
	            //比如widget零件
	            var instance = void 0;
	            if (instance = Xut.Application.GetSpecifiedObject(pageType, data)) {
	                if (instance.toggle) {
	                    //如果有对应的处理方法
	                    return instance.toggle();
	                }
	            }

	            //委派新的任务
	            dir.trigger(data);
	        }
	    }
	}

	/**
	 * 翻页停止content动作
	 * 翻页时,暂停滑动页面的所有热点动作
	 *
	 * 如果传递了allHandle 停止所有的视频
	 * allHandle 给接口Xut.Application.Original() 使用
	 *
	 * @param  {[type]} pageObj [description]
	 * @param  {[type]} pageId  [description]
	 * @param  {[type]} all     [description]
	 * @return {[type]}         [description]
	 */
	function $$suspend(pageObj, pageId, allHandle) {

	    //零件对象翻页就直接销毁了
	    //无需暂时
	    //这里只处理音频 + content类型
	    access$1(pageObj, function (pageObj, contentObjs) {

	        //多媒体处理
	        if (pageId !== undefined) {
	            //离开页面销毁视频
	            removeVideo(pageId);
	            //翻页停止母板音频
	            if (pageObj.pageType === 'master') {
	                hangUpAudio();
	            }
	        }

	        //content类型
	        contentObjs && _.each(contentObjs, function (obj) {
	            obj.stop && obj.stop();
	        });

	        //如果是外部调用接口
	        //销毁视频
	        //销毁所有的音频
	        if (allHandle) {
	            hangUpVideo();
	            hangUpAudio();
	        }
	    });
	}

	/**
	 * 优化检测
	 * @param  {Function} fn [description]
	 * @return {[type]}      [description]
	 */
	var hasOptimize = function hasOptimize(fn) {
	    if (!Xut.config.visualMode !== 1) {
	        fn && fn();
	    }
	};

	/**
	 * 翻一页处理： 翻页完毕触发
	 * 大量操作DOM结构，所以先隐藏根节点
	 * 1 删除所有widget节点
	 * 2 复位所有content节点
	 * @param  {[type]} pageObj [description]
	 * @return {[type]}         [description]
	 */
	function $$original(pageObj) {

	    access$1(pageObj, function (pageObj, contentObjs, componentObjs) {

	        //母版对象不还原
	        if (pageObj.pageType === 'master') return;

	        var $containsNode;

	        if ($containsNode = pageObj.getContainsNode()) {

	            //隐藏根节点
	            //display:none下刷新
	            hasOptimize(function () {
	                $containsNode.hide();
	            });

	            //content类型复位
	            contentObjs && _.each(contentObjs, function (obj) {
	                if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
	                    obj.reset && obj.reset();
	                }
	            });

	            //销毁所有widget类型的节点
	            if (componentObjs) {
	                _.each(componentObjs, function (obj) {
	                    obj && obj.destroy();
	                });
	                //销毁widget对象管理
	                pageObj.baseRemoveComponent();
	            }

	            hasOptimize(function () {
	                setTimeout(function () {
	                    $containsNode.show();
	                    $containsNode = null;
	                }, 0);
	            });
	        }
	    });
	}

	/**
	 * 停止所有热点动作,并返回状态
	 * 1 content
	 * 2 widget
	 * 动画,视频,音频...........................
	 * 增加场景模式判断
	 *
	 *  skipAudio 是否跳过音频，不处理
	 *    true 跳过
	 *    false 不跳过
	 */

	/**
	 * 复位状态/状态控制
	 * 如果返回false证明有热点
	 * 第一次只能关闭热点不能退出页面
	 * @param  {[type]} pageObj [description]
	 * @return {[type]}         [description]
	 */
	function $$stop() {

	    //清理音频
	    clearAudio();

	    //清理视频
	    clearVideo();

	    //停止热点
	    return access$1(function (pageObj, contentObjs, componentObjs) {

	        //如果返回值是false,则是算热点处理行为
	        var falg = false;

	        //content类型
	        contentObjs && _.each(contentObjs, function (obj) {
	            if (obj.stop && obj.stop()) {
	                falg = true;
	            }
	        });

	        //零件类型
	        componentObjs && _.each(componentObjs, function (obj) {
	            if (obj.stop && obj.stop()) {
	                falg = true;
	            }
	        });

	        return falg;
	    });
	}

	/**
	 * 跳转页面
	 * @param  {[type]} para1 [description]
	 * @return {[type]}       [description]
	 */
	var toPage = function toPage(para1) {
	    para1 = JSON.parse(para1);
	    if (para1.seasonId) {
	        Xut.View.GotoSlide(para1.seasonId, para1.chapterId);
	    } else {
	        //向下兼容
	        Xut.View.GotoSlide(para1);
	    }
	};

	function Action$2(data) {
	    var id = parseInt(data.id);
	    var results = Xut.data.query('Action', id, 'activityId');
	    var para1 = results.para1; //跳转参数
	    var actionType = parseInt(results.actionType);
	    if (actionType == 0) {
	        toPage(para1);
	    }
	}

	var Action$1 = {

	    /**
	     * 创建节点
	     * @return {[type]}
	     */
	    createDom: function createDom() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _id = _ref._id,
	            md5 = _ref.md5,
	            actType = _ref.actType,
	            scaleWidth = _ref.scaleWidth,
	            scaleHeight = _ref.scaleHeight,
	            scaleTop = _ref.scaleTop,
	            scaleLeft = _ref.scaleLeft;

	        var chpaterData = arguments[1];
	        var chapterId = arguments[2];
	        var pageIndex = arguments[3];
	        var zIndex = arguments[4];
	        var pageType = arguments[5];


	        //热点背景图
	        var backgroundImage = '';
	        if (md5) {
	            backgroundImage = "background-image: url(" + Xut.config.pathAddress + md5 + ");";
	        }

	        var id = actType + "_" + _id;

	        var html = '<div id="' + id + '"\n                           data-belong="' + pageType + '"\n                           data-delegate="action"\n                           style="cursor:pointer;\n                                  width:' + scaleWidth + 'px;\n                                  height:' + scaleHeight + 'px;\n                                  left:' + scaleLeft + 'px;\n                                  top:' + scaleTop + 'px;\n                                  background-size:100% 100%;\n                                  position:absolute;\n                                  z-index:' + zIndex + ';\n                                  ' + backgroundImage + '">\n                      </div>';

	        return String.styleFormat(html);
	    }

	    /*
	     * touchEnd 全局派发的点击事件
	     * 如果stopGlobalEvent == ture 事件由全局派发
	     */
	    ,
	    trigger: function trigger(data) {
	        Action$2(data);
	    }
	};

	//临时音频动作数据
	var tempData = {};

	var Media = {
	    createDom: function createDom() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _id = _ref._id,
	            md5 = _ref.md5,
	            actType = _ref.actType,
	            category = _ref.category,
	            itemArray = _ref.itemArray,
	            scaleWidth = _ref.scaleWidth,
	            scaleHeight = _ref.scaleHeight,
	            scaleTop = _ref.scaleTop,
	            scaleLeft = _ref.scaleLeft;

	        var chpaterData = arguments[1];
	        var chapterId = arguments[2];
	        var pageIndex = arguments[3];
	        var zIndex = arguments[4];
	        var pageType = arguments[5];


	        var html = void 0;
	        var mediaIcon = '';
	        var startImage = '';

	        //如果没有宽高则不创建绑定节点
	        if (!scaleWidth || !scaleHeight) return '';

	        //解析音乐动作
	        //冒泡动作靠节点传递数据
	        if (itemArray) {
	            itemArray = parseJSON(itemArray);
	            var start = itemArray[0];
	            var stop = itemArray[1];
	            tempData[_id] = {};
	            if (start) {
	                if (start.startImg) {
	                    startImage = start.startImg;
	                    tempData[_id]['startImg'] = startImage;
	                    startImage = 'background-image:url(' + config.pathAddress + startImage + ');';
	                }
	                if (start.script) {
	                    tempData[_id]['startScript'] = start.script;
	                }
	            }
	            if (stop) {
	                if (stop.stopImg) {
	                    tempData[_id]['stopImg'] = stop.stopImg;
	                }
	                if (stop.script) {
	                    tempData[_id]['stopScript'] = stop.script;
	                }
	            }
	        }

	        //首字母大写
	        var mediaType = category.replace(/(\w)/, function (v) {
	            return v.toUpperCase();
	        });

	        var viewSize = config.viewSize;

	        //只针对网页插件增加单独的点击界面
	        //如果有视频图标
	        if (category == 'webpage' && scaleWidth > 200 && scaleHeight > 100 && scaleWidth <= viewSize.width && scaleHeight <= viewSize.height) {

	            var mediaIconSize = 74;
	            var posX = (scaleWidth - mediaIconSize) / 2;
	            var posY = (scaleHeight - mediaIconSize) / 2;
	            var icon = 'background-image:url(images/icons/web_hotspot.png)';
	            mediaIcon = '<div id="icon_' + _id + '"\n                                  type="icon"\n                                  style="width:' + mediaIconSize + 'px;\n                                         height:' + mediaIconSize + 'px;\n                                         top:' + posY + 'px;\n                                         left:' + posX + 'px;\n                                         position:absolute;\n                                         ' + icon + '">\n                          </div>';
	        }

	        //创建音频对象
	        //Webpage_1
	        //Audio_1
	        //Video_1
	        return String.styleFormat('<div id="' + (mediaType + "_" + _id) + '"\n                      data-belong="' + pageType + '"\n                      data-delegate="' + category + '"\n                      style="width:' + scaleWidth + 'px;\n                             height:' + scaleHeight + 'px;\n                             left:' + scaleLeft + 'px;\n                             top:' + scaleTop + 'px;\n                             z-index:' + zIndex + ';\n                             ' + startImage + '\n                             background-size:100% 100%;\n                             position:absolute;">\n                ' + mediaIcon + '\n            </div>');
	    }

	    /**
	     * 仅创建一次
	     * data传递参数问题
	     * @param  {[type]} id [description]
	     * @return {[type]}    [description]
	     */
	    ,
	    onlyCreateOnce: function onlyCreateOnce(id) {
	        var data;
	        if (data = tempData[id]) {
	            delete tempData[id];
	            return data;
	        }
	    }

	    /**
	     * 自动运行
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    autoPlay: function autoPlay() {
	        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            id = _ref2.id,
	            category = _ref2.category,
	            rootNode = _ref2.rootNode,
	            pageIndex = _ref2.pageIndex,
	            chapterId = _ref2.chapterId;

	        if (!category) return;
	        if (category == 'audio') {
	            autoAudio(chapterId, id, this.onlyCreateOnce(id));
	        } else {
	            autoVideo(chapterId, id, rootNode);
	        }
	    }

	    /**
	     * touchEnd 全局派发的点击事件
	     * 如果stopGlobalEvent == ture 事件由全局派发
	     */
	    ,
	    trigger: function trigger() {
	        var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            id = _ref3.id,
	            target = _ref3.target,
	            rootNode = _ref3.rootNode,
	            pageIndex = _ref3.pageIndex,
	            activityId = _ref3.activityId;

	        var category = target.getAttribute('data-delegate');
	        if (category) {
	            var chapterId = Xut.Presentation.GetPageId(pageIndex);
	            /**
	             * 传入chapterId 页面ID
	             * activityId    视频ID
	             * eleName       节点名  //切换控制
	             * 根节点
	             */
	            if (category == 'audio') {
	                triggerAudio(chapterId, activityId, this.onlyCreateOnce(id));
	            } else {
	                triggerVideo(chapterId, activityId, $(rootNode));
	            }
	        }
	    }
	};

	/**
	 * 路径地址
	 * @param  {[type]} name [description]
	 * @return {[type]}      [description]
	 */
	function path$1(fileName, widgetId) {
	    return config.jsWidgetPath() + widgetId + '/' + fileName;
	}

	/**
	 * 去重加载处理
	 */
	var toRepeat$1 = {};

	var add = function add(path, callback) {
	    //去重复处理
	    //可能同时执行了多个同样的js文件加载
	    if (!toRepeat$1[path]) {
	        toRepeat$1[path] = [];
	    }
	    toRepeat$1[path].push(callback);
	    if (toRepeat$1[path].length > 1) {
	        return;
	    }
	    loadfile(path, function () {
	        _.each(toRepeat$1[path], function (fn) {
	            fn && fn();
	        });
	        toRepeat$1[path] = null;
	        delete toRepeat$1[path];
	    });
	};

	function removeLoad() {
	    toRepeat$1 = {};
	}

	/**
	 * 加载js,css文件
	 * @return {[type]} [description]
	 */
	function loadFile(callback, base) {
	    var jsPath,
	        cssPath,
	        completeCount,
	        widgetId = base.widgetId,

	    //定义css,js的命名
	    jsName = base.widgetName + '.min.js',
	        cssName = base.widgetType == 'page' || base.widgetType == 'js' ? 'style.min.css' : 0;

	    //需要等待完成
	    var completeCount = function () {
	        var count = 0;
	        jsName && count++;
	        cssName && count++;
	        return function () {
	            if (count === 1) {
	                return callback && callback.call(base);
	            }
	            count--;
	        };
	    }();

	    //加载css
	    if (cssName) {
	        cssPath = path$1(cssName, widgetId);
	        add(cssPath, completeCount);
	    }

	    //加载js
	    if (jsName) {
	        jsPath = path$1(jsName, widgetId);
	        add(jsPath, completeCount);
	    }
	}

	/**
	 * 创建数据
	 * @return {[type]} [description]
	 */
	function createData(outputPara, scrollPaintingMode, calculate) {
	    var item,
	        field,
	        source = [],
	        images = Xut.data['Image'],
	        token = null,
	        items = outputPara.source;

	    for (item in items) {
	        if (items.hasOwnProperty(item)) {
	            field = {};
	            token = images.item((parseInt(items[item]) || 1) - 1);
	            field['img'] = token.md5;
	            field['thumb'] = '';
	            field['title'] = token.imageTitle;
	            source.push(field);
	        }
	    }

	    outputPara.source = source;
	    outputPara.scrollPaintingMode = scrollPaintingMode;
	    outputPara.calculate = calculate;

	    /**
	     * 2016.8.3
	     * 给妙妙学的js零件增加前缀
	     * @type {[type]}
	     */
	    outputPara.rootPath = Xut.config.jsWidgetPath();

	    return outputPara;
	}

	/**
	 * 眷顾区域扩展
	 * @type {Boolean}
	 */

	var ScrollArea = function () {
	    function ScrollArea(data, options) {
	        classCallCheck(this, ScrollArea);

	        this.data = data;
	        this.options = options;
	        this.scrolls = [];
	        this._init();
	    }

	    createClass(ScrollArea, [{
	        key: "_init",
	        value: function _init() {
	            var content = this.options;
	            var prefix = this.data.contentPrefix;
	            //创建多个眷滚区域
	            for (var i = 0; i < content.length; i++) {
	                var obj = this._create(content[i], prefix);
	                if (obj) {
	                    this.scrolls.push(obj);
	                }
	            }
	        }
	    }, {
	        key: "_createWrapper",
	        value: function _createWrapper() {
	            return String.styleFormat("<div data-type=\"area-wrapper\"\n                  style=\"position:absolute;width:100%; height:100%;overflow:hidden;\">\n                <ul data-type=\"area-scroller\"\n                     data-behavior=\"disable\"\n                     style=\"position:absolute; width:100%; height:100%;overflow:hidden;\">\n                </ul>\n             </div>");
	        }
	    }, {
	        key: "_create",
	        value: function _create(content, prefix) {

	            var cid = content.id;
	            var contentName = prefix + cid;

	            var theTitle = parseJSON(content.theTitle);

	            //data-widgetscrollareaList
	            //data-widgetscrollareascrolltype
	            var obj = theTitle["data-widgetscrollareaList"].split(",");
	            if (obj.length == 0) {
	                return;
	            }

	            var contentPanle = $("#" + contentName);
	            if (contentPanle.length == 0) {
	                console.log(cid + "not find obj");
	                return;
	            }

	            var scrolltype = theTitle["data-widgetscrollareascrolltype"] ? theTitle["data-widgetscrollareascrolltype"] : "xy";

	            //滚动的方向
	            //x / y /xy
	            scrolltype = scrolltype.toLowerCase();
	            var scrollX = scrolltype.indexOf("x") > -1;
	            var scrollY = scrolltype.indexOf("y") > -1;

	            var $wrapper = void 0;

	            //如果来回翻页
	            //因为子节点的排列关系已经被改变
	            //所以这里直接处理事件
	            var hasIscroll = contentPanle.attr("data-iscroll");
	            if (hasIscroll) {
	                //需要滚动条
	                if (hasIscroll === 'visible') {
	                    $wrapper = contentPanle.children('div[data-type="area-wrapper"]');
	                    return this._bindIscroll($wrapper[0], scrollX, scrollY, cid);
	                }
	                //hidden
	                return;
	            }

	            //去掉默认行为
	            Xut.Contents.ResetDefaultControl("page", contentName, "");

	            var contentSize = {
	                x: parseInt(contentPanle.css("left")),
	                y: parseInt(contentPanle.css("top")),
	                w: parseInt(contentPanle.css("width")),
	                h: parseInt(contentPanle.css("height"))
	            };

	            var size = this._getSize(obj, prefix);
	            var min = size.min;
	            var max = size.max;

	            //创建容器
	            $wrapper = $(this._createWrapper());

	            //滚动容器
	            var $scroller = $wrapper.children();
	            contentPanle.append($wrapper);

	            //设置滚动容器宽高
	            this._setScrollerStyle(max, min, contentSize, scrollX, scrollY, $scroller);

	            //重置各个content的left top值 并得到
	            //x轴方向卷滚：snap容器的宽度 个数以及每个snap容器包含的content个数
	            //y轴方向卷滚：snap容器的高度 个数以及每个snap容器包含的content个数
	            var colsObj = this._resetContents(obj, prefix, contentSize, scrollX, scrollY, min);

	            //创建snap容器
	            var snapContainer = this._createSnapContainer(colsObj, $scroller, cid, scrollX, scrollY);

	            //将content添加到snap容器中
	            if (scrollX) {
	                for (var j = 0; j < obj.length; j++) {
	                    var childId = prefix + obj[j];
	                    var childObj = $("#" + childId);
	                    childObj.appendTo(snapContainer[Math.floor(j / colsObj.contentsPerSnapX)]);
	                }
	            }
	            if (scrollY) {
	                for (var j = 0; j < obj.length; j++) {
	                    var childId = prefix + obj[j];
	                    var childObj = $("#" + childId);
	                    childObj.appendTo(snapContainer[Math.floor(j / colsObj.contentsPerSnapY)]);
	                }
	            }

	            //如果不满足溢出条件
	            var $areaScroller = snapContainer.parent();
	            if (scrollX) {
	                var snapContainerWidth = parseInt($areaScroller.css('width'));
	                if (snapContainerWidth < contentSize.w) {
	                    scrollX = false;
	                }
	            }
	            if (scrollY) {
	                var snapContainerHeight = parseInt($areaScroller.css('height'));
	                if (snapContainerHeight < contentSize.h) {
	                    scrollY = false;
	                }
	            }

	            if (scrollY || scrollX) {
	                contentPanle.attr("data-iscroll", "visible");
	                //只存在一屏 需要卷滚时 不要要snap
	                if (snapContainer.length == 1) {
	                    return this._bindIscroll($wrapper[0], scrollX, scrollY);
	                }
	                return this._bindIscroll($wrapper[0], scrollX, scrollY, cid);
	            } else {
	                contentPanle.attr("data-iscroll", "hidden");
	            }
	        }
	    }, {
	        key: "_bindIscroll",
	        value: function _bindIscroll(wrapper, hasScrollX, hasScrollY, cid) {
	            if (cid) {
	                return new iScroll(wrapper, {
	                    scrollX: hasScrollX ? true : false,
	                    scrollY: hasScrollY ? true : false,
	                    snap: ".contentsContainer" + cid
	                });
	            } else {
	                return new iScroll(wrapper, {
	                    scrollX: hasScrollX ? true : false,
	                    scrollY: hasScrollY ? true : false
	                });
	            }
	        }
	    }, {
	        key: "_getSize",
	        value: function _getSize(objIds, prefix) {
	            //最大区间
	            var max = {
	                l: null,
	                t: null
	            };

	            //最小区间
	            var min = {
	                l: null,
	                t: null
	            };

	            var obj = void 0;
	            for (var i = 0; i < objIds.length; i++) {
	                obj = $("#" + prefix + objIds[i]);
	                if (obj.length == 0) {
	                    console.log(objIds[i] + " not find");
	                    continue;
	                }
	                var width = parseInt(obj.css("width"));
	                var left = parseInt(obj.css("left"));
	                var height = parseInt(obj.css("height"));
	                var top = parseInt(obj.css("top"));

	                //获取最小区间
	                var xMin = left;
	                var yMin = top;
	                if (min.l == null || min.l > xMin) {
	                    min.l = xMin;
	                }
	                if (min.t == null || min.t > yMin) {
	                    min.t = yMin;
	                }

	                //获取最大元素的值
	                var xMax = width + left;
	                var yMax = height + top;
	                if (max.l == null || max.l < xMax) {
	                    max.l = xMax;
	                }
	                if (max.t == null || max.t < yMax) {
	                    max.t = yMax;
	                }
	            }

	            return {
	                min: min,
	                max: max
	            };
	        }

	        /**
	         * 设置scroller标签的宽高
	         * @param {[type]} max         [description]
	         * @param {[type]} min         [description]
	         * @param {[type]} contentSize [description]
	         * @param {[type]} scrollX     [description]
	         * @param {[type]} scrollY     [description]
	         * @param {[type]} $scroller   [description]
	         */

	    }, {
	        key: "_setScrollerStyle",
	        value: function _setScrollerStyle(max, min, contentSize, scrollX, scrollY, $scroller) {
	            var width = 0;
	            var height = 0;
	            var start = { x: 0, y: 0 };
	            var end = { x: 0, y: 0 };

	            if (min.l < contentSize.x) {
	                start.x = min.l;
	            } else {
	                start.x = contentSize.x;
	            }

	            if (min.t < contentSize.y) {
	                start.y = min.t;
	            } else {
	                start.y = contentSize.y;
	            }

	            if (max.l > contentSize.x + contentSize.w) {
	                end.x = max.l;
	            } else {
	                end.x = contentSize.x + contentSize.w;
	            }

	            if (max.t > contentSize.y + contentSize.h) {
	                end.y = max.t;
	            } else {
	                end.y = contentSize.y + contentSize.h;
	            }

	            if (!scrollX && end.x - start.x > contentSize.w) {
	                width = contentSize.w;
	            } else {
	                width = end.x - start.x;
	            }

	            if (!scrollY && end.y - start.y > contentSize.h) {
	                height = contentSize.h;
	            } else {
	                height = end.y - start.y;
	            }

	            $scroller.css({
	                width: width + "px",
	                height: height + "px"
	            });
	        }

	        /**
	         * 重设各个子content的left top值 以包裹他们的父容器为基准
	         * 并且得到snapContainer的个数 宽度 以及每个snapContainer中可以放的content个数
	         * @param  {[type]} obj         [description]
	         * @param  {[type]} prefix      [description]
	         * @param  {[type]} contentSize [description]
	         * @param  {[type]} scrollX     [description]
	         * @param  {[type]} scrollY     [description]
	         * @param  {[type]} min         [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: "_resetContents",
	        value: function _resetContents(obj, prefix, contentSize, scrollX, scrollY, min) {
	            var contentsPerSnapX = void 0,
	                contentsPerSnapY = void 0,
	                snapXCount = void 0,
	                snapYCount = void 0,
	                snapContainerWidth = void 0,
	                snapContainerHeight = void 0;
	            var contentsXTemp = 0;
	            var contentsYTemp = 0;
	            var contentsLength = obj.length;

	            for (var j = 0; j < contentsLength; j++) {
	                var childId = prefix + obj[j];
	                var childObj = $("#" + childId);
	                Xut.Contents.ResetDefaultControl("page", childId, "");
	                if (childObj.attr("data-iscroll") == "true") {
	                    continue;
	                }
	                var childLeft = parseInt(childObj.css("left"));
	                var childTop = parseInt(childObj.css("top"));
	                var childWidth = parseInt(childObj.css("width"));

	                if (min.l < contentSize.x && scrollX) {
	                    childLeft = childLeft - min.l;
	                } else {
	                    childLeft = childLeft - contentSize.x;
	                }

	                if (min.t < contentSize.y && scrollY) {
	                    childTop = childTop - min.t;
	                } else {
	                    childTop = childTop - contentSize.y;
	                }

	                childObj.css("left", childLeft);
	                childObj.css("top", childTop);

	                //x轴卷滚
	                if (scrollX) {
	                    if (childLeft < contentSize.w) {
	                        contentsXTemp++;
	                    } else {
	                        if (!contentsPerSnapX) {
	                            contentsPerSnapX = contentsXTemp;
	                            snapContainerWidth = childLeft;
	                        }
	                    }
	                }
	                //y轴卷滚
	                if (scrollY) {
	                    if (childTop < contentSize.h) {
	                        contentsYTemp++;
	                    } else {
	                        if (!contentsPerSnapY) {
	                            contentsPerSnapY = contentsYTemp;
	                            snapContainerHeight = childTop;
	                        }
	                    }
	                }

	                childObj.css("visibility", "inherit");
	                childObj.attr("data-iscroll", "true");
	            }

	            if (scrollX) {
	                //无需创建卷滚
	                if (!contentsPerSnapX) {
	                    contentsPerSnapX = obj.length;
	                    snapXCount = 1;
	                    snapContainerWidth = contentSize.w;
	                } else {
	                    snapXCount = Math.ceil(obj.length / contentsPerSnapX);
	                }
	            }

	            if (scrollY) {
	                //得到卷滚区域一行可以放多少列
	                var colsPerRow = 1;
	                for (var k = 0; k < contentsLength; k++) {
	                    var childId = prefix + obj[k];
	                    var childObj = $("#" + childId);
	                    var childTop = parseInt(childObj.css("top"));
	                    if (k > 0) {
	                        var prevChildId = prefix + obj[k - 1];
	                        var prevChildObj = $("#" + prevChildId);
	                        var prevChildTop = parseInt(prevChildObj.css("top"));
	                        if (childTop < prevChildTop + 10) {
	                            colsPerRow++;
	                        } else {
	                            break;
	                        }
	                    }
	                }

	                //无需创建卷滚
	                if (!contentsPerSnapY) {
	                    contentsPerSnapY = Math.floor(obj.length / colsPerRow) + 1; ////在不需要卷滚的条件下 只会存在一个snap snap中的行数由content的总数/每行的个数 +1
	                    snapYCount = 1;
	                    snapContainerHeight = contentSize.h;
	                } else {
	                    snapYCount = Math.ceil(obj.length / contentsPerSnapY);
	                }
	            }

	            return {
	                contentsPerSnapX: contentsPerSnapX,
	                snapXCount: snapXCount,
	                snapContainerWidth: snapContainerWidth,
	                contentsPerSnapY: contentsPerSnapY,
	                snapYCount: snapYCount,
	                snapContainerHeight: snapContainerHeight
	            };
	        }

	        /**
	         * 创建snapContainer并添加到scroller中
	         * @param  {[type]} colsObj   [description]
	         * @param  {[type]} $scroller [description]
	         * @param  {[type]} cid       [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: "_createSnapContainer",
	        value: function _createSnapContainer(colsObj, $scroller, cid, scrollX, scrollY) {
	            var snapContainer = '';

	            if (scrollX) {
	                var scrollerWidth = parseInt($scroller.css("width"));
	                var snapXCount = colsObj.snapXCount;
	                var snapContainerWidth = colsObj.snapContainerWidth;
	                var lastSnapContainerWidth = scrollerWidth - (snapXCount - 1) * snapContainerWidth;
	                var containerWidth = void 0;
	                for (var i = 0; i < colsObj.snapXCount; i++) {
	                    //最后一个snap容器的宽度需要单独设置 否则可能所有的snap容器宽度和会大于scroller的宽度
	                    if (i == colsObj.snapXCount - 1) {
	                        containerWidth = lastSnapContainerWidth;
	                    } else {
	                        containerWidth = snapContainerWidth;
	                    }
	                    snapContainer += "<li class=\"contentsContainer" + cid + "\"\n                                      style='width:" + containerWidth + "px;height:100%;float:left;'>\n                                  </li>";
	                }
	            }
	            //Y轴滚动
	            else if (scrollY) {
	                    var scrollerHeight = parseInt($scroller.css("height"));
	                    var snapYCount = colsObj.snapYCount;
	                    var snapContainerHeight = colsObj.snapContainerHeight;
	                    var lastSnapContainerHeight = scrollerHeight - (snapYCount - 1) * snapContainerHeight;
	                    for (var i = 0; i < colsObj.snapYCount; i++) {
	                        snapContainer += "<li class=\"contentsContainer" + cid + "\"\n                                      style='height:" + snapContainerHeight + "px;width:100%;float:left;'>\n                                  </li>";
	                    }
	                }

	            snapContainer = $(snapContainer);
	            snapContainer.appendTo($scroller);
	            return snapContainer;
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            if (this.scrolls.length) {
	                for (var i = 0; i < this.scrolls.length; i++) {
	                    var obj = this.scrolls[i];
	                    if (obj) {
	                        obj.scrollTo(0, 0);
	                        obj.destroy();
	                    }
	                    this.scrolls[i] = null;
	                }
	                this.scrolls = null;
	            }
	            this.data.container = null;
	            this.options = null;
	        }
	    }]);
	    return ScrollArea;
	}();

	/**
	 * 解析数据,获取content对象
	 * @return {[type]} [description]
	 */
	var parseContentObjs = function parseContentObjs(pageType, inputPara) {
	    var contentIds = [];
	    inputPara.content && _.each(inputPara.content, function (contentId) {
	        contentIds.push(contentId);
	    });
	    return Xut.Contents.GetPageWidgetData(pageType, contentIds);
	};

	/**
	 * 页面零件
	 * @param {[type]} data [description]
	 */

	var PageWidget = function () {
	    function PageWidget(data) {
	        classCallCheck(this, PageWidget);

	        _.extend(this, data);
	        this.pageObj = null;
	        this._init();
	    }

	    /**
	     * 获取参数
	     * 得到content对象与数据
	     * @return {[type]} [description]
	     */


	    createClass(PageWidget, [{
	        key: '_getOptions',
	        value: function _getOptions() {
	            return [createData(this.inputPara, this.scrollPaintingMode, this.calculate), parseContentObjs(this.pageType, this.inputPara)];
	        }

	        /**
	         * 初始化,加载文件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_init',
	        value: function _init() {

	            //滚动区域
	            if (this.widgetId == 60 && this.widgetName == "scrollarea") {
	                var arg = this._getOptions();
	                this.pageObj = new ScrollArea(arg[0], arg[1]);
	            }
	            //Load the localized code first
	            //Combined advanced Sprite
	            else if (this.widgetId == 72 && this.widgetName == "spirit") {
	                    var arg = this._getOptions();
	                    this.pageObj = AdvSprite(arg[0], arg[1]);
	                }
	                //直接扩展加载
	                else {
	                        //If there is no
	                        if (typeof window[this.widgetName + "Widget"] != "function") {
	                            this.hasload = true;
	                            loadFile(this._executive, this);
	                        } else {
	                            this._executive();
	                        }
	                    }
	        }

	        /**
	         * 执行函数
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_executive',
	        value: function _executive() {
	            if (typeof window[this.widgetName + "Widget"] == "function") {
	                var arg = this._getOptions();
	                this.pageObj = new window[this.widgetName + "Widget"](arg[0], arg[1]);
	            } else {
	                console.error("Function [" + this.widgetName + "Widget] does not exist.");
	            }
	        }

	        /**
	         * 动画运行
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'play',
	        value: function play() {
	            return this.pageObj.play();
	        }

	        /**
	         * 外部切换调用接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'toggle',
	        value: function toggle() {
	            this.pageObj && this.pageObj.toggle && this.pageObj.toggle();
	        }

	        /**
	         * 动作停止接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            this.pageObj && this.pageObj.stop && this.pageObj.stop();
	        }

	        /**
	         * 销毁页面零件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.hasload && removeLoad();
	            this.pageObj && this.pageObj.destroy && this.pageObj.destroy();
	        }
	    }]);
	    return PageWidget;
	}();

	/**
	 * 创建iframe零件包装器
	 */

	var iframeWidget = function () {
	    function iframeWidget(data) {
	        var _this = this;

	        classCallCheck(this, iframeWidget);

	        _.extend(this, data);
	        this._$wapper = this._createWapper();
	        Xut.nextTick({
	            'container': this.rootNode,
	            'content': this._$wapper
	        }, function () {
	            _this.rootNode = null;
	            _this._bindPMS();
	        });
	        return this;
	    }

	    /**
	     * 创建包含容器
	     * @return {[type]} [description]
	     */


	    createClass(iframeWidget, [{
	        key: '_createWapper',
	        value: function _createWapper() {
	            if (this.zIndex !== 0) {
	                this.zIndex = this.zIndex || Xut.zIndexlevel();
	            }

	            var html = String.styleFormat('<div id="widget_iframe_' + this.id + '"\n                  style="z-index:' + this.zIndex + ';\n                         width:' + this.width + 'px;\n                         height:' + this.height + 'px;\n                         top:' + this.top + 'px;\n                         left:' + this.left + 'px;\n                         position:absolute;">\n             </div>');

	            this._$iframe = this._createIframe();

	            return $(html).append(this._$iframe);
	        }

	        /**
	         * 加载iframe
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createIframe',
	        value: function _createIframe() {
	            var _this2 = this;

	            var ifr = document.createElement('iframe');
	            var rootPath = config.pathAddress.replace('gallery/', '');
	            var path = rootPath + 'widget/' + this.widgetId + '/index.html?xxtParaIn=' + this.key;

	            ifr.id = 'iframe_' + this.id;
	            ifr.src = path;
	            ifr.style.width = '100%';
	            ifr.style.height = '100%';
	            ifr.sandbox = "allow-scripts allow-same-origin";
	            ifr.frameborder = 0;

	            if (ifr.attachEvent) {
	                ifr.attachEvent('onload', function () {
	                    _this2._iframeComplete();
	                });
	            } else {
	                ifr.onload = function () {
	                    _this2._iframeComplete();
	                };
	            }
	            return ifr;
	        }

	        /**
	         * iframe加载完毕回调
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_iframeComplete',
	        value: function _iframeComplete() {

	            var dataSource = this._loadData();
	            var width = this._$iframe.offsetWidth;
	            var height = this._$iframe.offsetHeight;

	            if (dataSource.screenSize.width * 0.98 <= width && dataSource.screenSize.height * 0.98 <= height) {
	                Xut.View.Toolbar({
	                    show: 'button',
	                    hide: 'controlBar'
	                });
	            } else if (dataSource.screenSize.width * 0.7 <= width && dataSource.screenSize.height * 0.7 <= height) {
	                Xut.View.Toolbar({
	                    show: 'button'
	                });
	            }

	            PMS.send({
	                target: this._$iframe.contentWindow,
	                origin: '*',
	                type: 'loadData',
	                data: dataSource,
	                //消息传递完毕后的回调
	                success: function success() {},
	                error: function error() {}
	            });

	            //iframe加载的状态
	            this.state = true;
	        }

	        /**
	         * ifarme内部，请求返回数据
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_loadData',
	        value: function _loadData() {
	            var item,
	                field,
	                source_export = [],
	                images = Xut.data['Image'],
	                token = null,
	                outputPara = this.inputPara,
	                items = outputPara.source;

	            for (item in items) {
	                if (items.hasOwnProperty(item)) {
	                    field = {};
	                    token = images.item((parseInt(items[item]) || 1) - 1);
	                    field['img'] = '../gallery/' + token.md5;
	                    field['thumb'] = '';
	                    field['title'] = token.imageTitle;
	                    source_export.push(field);
	                }
	            }

	            outputPara.source = source_export;

	            return outputPara;
	        }

	        /**
	         * 与iframe通讯接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_bindPMS',
	        value: function _bindPMS() {
	            var _this3 = this;

	            var markId = this.id;
	            var $wapper = this._$wapper;
	            var $iframe = $(this._$iframe);

	            //隐藏widget
	            PMS.bind("onHideWapper" + markId, function () {
	                $wapper.hide();
	                _this3.state = false;
	            }, '*');

	            //全屏操作
	            PMS.bind("onFullscreen" + markId, function (e) {

	                if (!$iframe.length) return;

	                //关闭视频
	                clearVideo();

	                $wapper.css({
	                    width: '100%',
	                    height: '100%',
	                    zIndex: Xut.zIndexlevel(),
	                    top: 0,
	                    left: 0
	                });

	                //Widget全屏尺寸自动调整
	                if (e.full == false) {
	                    var body = document.body,
	                        width = parseInt(body.clientWidth),
	                        height = parseInt(body.clientHeight),
	                        rote = _this3.width / _this3.height,
	                        getRote = function getRote(width, height, rote) {
	                        var w = width,
	                            h = width / rote;
	                        if (h > height) {
	                            h = height;
	                            w = h * rote;
	                        }
	                        return {
	                            w: parseInt(w),
	                            h: parseInt(h)
	                        };
	                    },
	                        size = getRote(width, height, rote),
	                        left = (width - size.w) / 2,
	                        top = (height - size.h) / 2;

	                    $iframe.css({
	                        width: size.w,
	                        height: size.h,
	                        position: 'absolute',
	                        top: top,
	                        left: left
	                    });
	                }
	                //隐藏工作条
	                Xut.View.Toolbar("hide");
	            }, '*');

	            //还原初始窗口操作
	            PMS.bind("onReset" + markId, function () {

	                if (!$iframe.length) return;

	                $wapper.css({
	                    zIndex: _this3.zIndex,
	                    width: _this3.width + 'px',
	                    height: _this3.height + 'px',
	                    top: _this3.top + 'px',
	                    left: _this3.left + 'px'
	                });

	                //还原iframe样式
	                $iframe.css({
	                    width: '100%',
	                    height: '100%',
	                    position: '',
	                    top: '0',
	                    left: '0'
	                });

	                Xut.View.Toolbar("show");
	            }, '*');

	            //显示工作条
	            PMS.bind("onShowToolbar" + markId, function () {
	                // Xut.View.ShowToolBar();
	            }, '*');

	            //隐藏工作条
	            PMS.bind("onHideToolbar" + markId, function () {
	                Xut.View.HideToolBar();
	            }, '*');

	            //跳转页面
	            PMS.bind('scrollToPage' + markId, function (data) {
	                Xut.View.GotoSlide(data['ppts'], data['pageIndex']);
	            }, '*');
	        }

	        /**
	         * 开始
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_start',
	        value: function _start() {
	            var _this4 = this;

	            this._domWapper();
	            PMS.send({
	                target: this._$iframe.contentWindow,
	                url: this._$iframe.src,
	                origin: '*',
	                type: 'onShow',
	                success: function success() {
	                    // alert(123)
	                }
	            });
	            setTimeout(function () {
	                _this4.state = true;
	            }, 0);
	        }

	        /**
	         * 暂停
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_stop',
	        value: function _stop() {
	            var _this5 = this;

	            this._domWapper();
	            PMS.send({
	                target: this._$iframe.contentWindow,
	                url: this._$iframe.src,
	                origin: '*',
	                type: 'onHide',
	                success: function success() {}
	            });
	            setTimeout(function () {
	                _this5.state = false;
	            }, 0);
	        }

	        /**
	         * 处理包装容器的状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_domWapper',
	        value: function _domWapper() {
	            if (this.state) {
	                this._$wapper.hide();
	            } else {
	                this._$wapper.show();
	            }
	        }

	        /**
	         * 停止
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'stop',
	        value: function stop() {
	            this._stop();
	        }

	        /**
	         * 外部调用接口
	         * 显示隐藏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'toggle',
	        value: function toggle() {
	            if (this.state) {
	                this._stop();
	            } else {
	                this._start();
	            }
	        }

	        /**
	         * 销毁接口
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var _this6 = this;

	            //销毁内部事件
	            PMS.send({
	                target: this._$iframe.contentWindow,
	                url: this._$iframe.src,
	                origin: '*',
	                type: 'onDestory',
	                success: function success() {}
	            });

	            //销毁事件绑定
	            PMS.unbind();

	            //销魂节点
	            setTimeout(function () {
	                _this6._$iframe = null;
	                _this6._$wapper.remove();
	                _this6._$wapper = null;
	            }, 0);
	        }
	    }]);
	    return iframeWidget;
	}();

	var FLOOR$3 = Math.floor;
	var CEIL$3 = Math.ceil;

	/**
	 * 注册所有组件对象
	 * 2 widget 包括 视频 音频 Action 子文档 弹出口 类型
	 * 这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
	 * @param  {[type]} regData [description]
	 * @return {[type]}         [description]
	 */
	var injectionComponent = function injectionComponent(regData) {
	    var sceneObj = sceneController.containerObj('current');
	    sceneObj.vm.$injectionComponent = regData;
	};

	var load = function load(type, data, constructor) {
	    injectionComponent({
	        'pageType': data.pageType, //标记类型区分
	        'pageIndex': data.pageIndex,
	        'widget': new constructor(data)
	    });
	};

	/**
	 * 构建5中零件类型
	 *  1、iframe零件
	 *  2、页面零件
	 *  3、SVG零件
	 *  4、canvas零件
	 *  5、webGL零件
	 * @type {Object}
	 */
	var adapterType = {

	    /**
	     * iframe零件类型
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    'iframe': function iframe(data) {
	        load('widget', data, iframeWidget);
	    },
	    'widget': function widget(data) {
	        load('widget', data, iframeWidget);
	    },


	    /**
	     * js零件类型处理
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    'js': function js(data) {
	        load('js', data, PageWidget);
	    },
	    'page': function page(data) {
	        load('page', data, PageWidget);
	    },
	    'svg': function svg(data) {
	        load('svg', data, PageWidget);
	    },
	    'canvas': function canvas(data) {
	        load('canvas', data, PageWidget);
	    },
	    'webgL': function webgL(data) {
	        load('webgL', data, PageWidget);
	    }
	};

	/**
	 * 过滤出数据
	 * @return {[type]} [description]
	 */
	var filterData = function filterData(data) {
	    //直接通过id查询数据
	    if (data.widgetId) {
	        _.extend(data, Xut.data.query('Widget', data.widgetId));
	    } else {
	        //直接通过activityId查询数据
	        _.extend(data, Xut.data.query('Widget', data.activityId, 'activityId'));
	    }
	    return data;
	};

	/**
	 * 计算元素的缩放比
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	var calculateElement = function calculateElement(data) {
	    var data = _.extend({}, data);
	    var proportion = config.proportion;
	    data.width = CEIL$3(data.width * proportion.width);
	    data.height = CEIL$3(data.height * proportion.height);
	    data.top = FLOOR$3(data.top * proportion.top);
	    data.left = FLOOR$3(data.left * proportion.left);
	    return data;
	};

	/**
	 * 获取widget数据
	 * @return {[type]} [description]
	 */
	var filtrateDas = function filtrateDas(data) {
	    data = filterData(data);
	    return calculateElement(data);
	};

	/**
	 * ifarme内部，请求返回数据
	 * @return {[type]} [description]
	 */
	var parsePara = function parsePara(data) {
	    var inputPara, //输入数据
	    outputPara; //输出数据
	    if (inputPara = data.inputPara) {
	        outputPara = parseJSON(inputPara);
	    }
	    return outputPara;
	};

	function Adapter(para) {

	    //获取数据
	    var data = filtrateDas(para);

	    data.id = data.activityId;

	    //解析数据
	    data.inputPara = parsePara(data);

	    if (!data.inputPara) {
	        data.inputPara = {};
	    }

	    //增加属性参数
	    if (data.widgetType === 'page') {
	        data.inputPara.container = data.rootNode;
	    }

	    data.inputPara.uuid = config.appId + '-' + data.activityId; //唯一ID标示
	    data.inputPara.id = data.activityId;
	    data.inputPara.screenSize = config.viewSize;
	    //content的命名前缀
	    data.inputPara.contentPrefix = Xut.Presentation.MakeContentPrefix(data.pageIndex, data.pageType);

	    //画轴模式
	    data.scrollPaintingMode = config.visualMode === 1;
	    data.calculate = config.viewSize;

	    //执行类构建
	    adapterType[(data.widgetType || 'widget').toLowerCase()](data);
	}

	var Widget = {

	    /**
	     * 创建热点元素结构（用于布局可触发点
	     * 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
	     * 根据数据创建自己的热点元素结构（用于拼接结构字符串）
	     * @return {[type]}              [description]
	     */
	    createDom: function createDom() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _id = _ref._id,
	            md5 = _ref.md5,
	            autoPlay = _ref.autoPlay,
	            actType = _ref.actType,
	            scaleWidth = _ref.scaleWidth,
	            scaleHeight = _ref.scaleHeight,
	            scaleTop = _ref.scaleTop,
	            scaleLeft = _ref.scaleLeft;

	        var chpaterData = arguments[1];
	        var chapterId = arguments[2];
	        var pageIndex = arguments[3];
	        var zIndex = arguments[4];
	        var pageType = arguments[5];


	        var backgroundImage = '';

	        //如果是自动播放,则不创建结构
	        if (autoPlay) {
	            return '';
	        }

	        //热点背景图
	        if (md5) {
	            backgroundImage = "background-image: url(" + Xut.config.pathAddress + md5 + ");";
	        }

	        var id = actType + "_" + _id;
	        var html = '<div id="' + id + '"\n                  data-belong="' + pageType + '"\n                  data-delegate="' + actType + '"\n                  style="cursor:pointer;\n                         background-size:100% 100%;\n                         position:absolute;\n                         width:' + scaleWidth + 'px;\n                         height:' + scaleHeight + 'px;\n                         left:' + scaleLeft + 'px;\n                         top:' + scaleTop + 'px;\n                         z-index:' + zIndex + ';\n                         ' + backgroundImage + '">\n            </div>';

	        return String.styleFormat(html);
	    }

	    /**
	     * 自动零件
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    autoPlay: function autoPlay() {
	        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            id = _ref2.id,
	            rootNode = _ref2.rootNode,
	            pageType = _ref2.pageType,
	            pageIndex = _ref2.pageIndex;

	        Adapter({
	            rootNode: rootNode,
	            pageType: pageType,
	            pageIndex: pageIndex,
	            activityId: id,
	            isAutoPlay: true
	        });
	    }

	    /**
	     * 事件委托
	     * 通过点击触发
	     * @param  {[type]} data [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    trigger: function trigger(data) {
	        return Adapter(data);
	    }
	};

	var ShowNote$1 = function () {
	    function ShowNote(data) {
	        classCallCheck(this, ShowNote);

	        data.id = parseInt(data.id);
	        data.actType = data.type;
	        _.extend(this, data);
	        this.setup();
	    }

	    createClass(ShowNote, [{
	        key: 'setup',
	        value: function setup() {
	            var that = this,
	                note = this.data.note,
	                prop = Xut.config.proportion,
	                width = Math.round((prop.width + prop.height) / 2 * Xut.config.iconHeight),
	                space = Math.round(width / 2);
	            var retStr = '<div class="xut-shownote-box" style="z-index:' + Xut.zIndexlevel() + '">' + '<div class="close" style="width:' + width + 'px;height:' + width + 'px;top:-' + space + 'px;right:-' + space + 'px"></div>' + '<div class="content">' + note + '</div>' + '</div>';

	            this._dom = $(retStr);
	            this._dom.find('.close').on("touchend mouseup", function () {
	                that.toggle();
	            });
	            $(this.rootNode).append(this._dom);

	            this.show();

	            this.iscroll = new iScroll(this._dom.find('.content')[0], {
	                scrollbars: true,
	                fadeScrollbars: true
	            });
	            return true;
	        }

	        //外部调用接口

	    }, {
	        key: 'toggle',
	        value: function toggle() {
	            //自动热点 取消关闭
	            if (this.isAutoPlay) return;
	            //当前对象状态
	            this.state ? this.hide() : this.show();
	        }
	    }, {
	        key: 'stop',
	        value: function stop() {
	            if (this.state) {
	                this.toggle();
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'hide',
	        value: function hide() {
	            this.state = false;
	            $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/hideNote.png)');
	            this._dom.hide();
	        }
	    }, {
	        key: 'show',
	        value: function show() {
	            this.state = true;
	            $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/showNote.png)');
	            this._dom.show();
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this._dom) {
	                this._dom.find('.close').off();
	                this._dom && this._dom.hide().remove();
	            }

	            //iscroll销毁
	            if (this.iscroll) {
	                this.iscroll.destroy();
	                this.iscroll = null;
	            }
	        }
	    }]);
	    return ShowNote;
	}();

	var ShowNote = {

	    /**
	     * 创建热点元素结构（用于布局可触发点）
	     * 根据数据创建自己的热点元素结构（用于拼接结构字符串）
	     * 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
	     * actType + "_" + _id
	     * @return {[type]}              [description]
	     */
	    createDom: function createDom(activityData, chpaterData, chapterId, pageIndex, zIndex, pageType) {

	        var id = activityData['_id'];
	        var width = activityData.scaleWidth;
	        var height = activityData.scaleHeight;
	        var newWidth = (width + height) / 2 * config.iconHeight;

	        var html = '<div id="ShowNote_' + id + '"\n                      class="xut-showNote"\n                      data-belong ="' + pageType + '"\n                      data-delegate="shownote"\n                      style="width:' + newWidth + 'px;height:' + newWidth + 'px">\n                 </div>';

	        return String.styleFormat(html);
	    }

	    /**
	     * touchEnd 全局派发的点击事件
	     * 如果stopGlobalEvent == ture 事件由全局派发
	     */
	    ,
	    trigger: function trigger(data) {
	        data.data = Xut.Presentation.GetPageData(data.pageIndex);
	        new ShowNote$1(data);
	    }

	    /**
	     * 自动运行生成Action或者widget触发点对象
	     * @param  {[type]} opts [description]
	     * @return {[type]}      [description]
	     */
	    ,
	    autoPlay: function autoPlay() {}

	    /**
	     * 销毁页面hotspot事件与Action或widget事件
	     * @param  {[type]} activeObejct [需要处理的活动对象]
	     * @param  {[type]} pageIndex    [页码标示]
	     * @param  {[type]} rootEle      [根元素]
	     * @return {[type]}              [description]
	     */
	    ,
	    destroy: function destroy(opts) {
	        this && this.destroy();
	    }
	};

	var directives = {
	    'Video': Media,
	    'Audio': Media,
	    'Webpage': Media,
	    Action: Action$1,
	    Widget: Widget,
	    ShowNote: ShowNote
	};

	function TaskComponents(data, suspendCallback, successCallback) {

	    //预编译模式跳过创建
	    if (Xut.IBooks.runMode()) {
	        successCallback();
	        return;
	    }

	    if (data['activitys'].length) {
	        var str;
	        this.$containsNode = data['$containsNode'];
	        this.callback = {
	            'suspendCallback': suspendCallback,
	            'successCallback': successCallback
	        };
	        str = this.create(data);
	        this.compileSuspend(str);
	    } else {
	        successCallback();
	    }
	}

	TaskComponents.prototype = {

	    clearReference: function clearReference() {
	        this.$containsNode = null;
	    },

	    create: function create(data) {
	        var actType,
	            pageType = data.pageType,
	            createWidgets = data.activitys,
	            chpaterData = data.chpaterData,
	            chapterId = data.chapterId,
	            pid = data.pid,
	            virtualOffset = data.virtualOffset,
	            widgetRetStr = [];

	        //创建
	        function startCreate(actType, activityData) {
	            //创建DOM元素结构
	            //返回是拼接字符串
	            widgetRetStr.push(directives[actType]['createDom'](activityData, chpaterData, chapterId, pid, Xut.zIndexlevel(), pageType));
	        }

	        //需要创建的数据结构
	        createWidgets.forEach(function (activityData, index) {

	            //创建类型
	            actType = activityData.actType || activityData.animation;

	            //特殊类型 showNote
	            if (!actType && activityData.note) {
	                activityData['actType'] = actType = "ShowNote";
	            }

	            switch (actType) {
	                case 'ShowNote':
	                case 'Action':
	                case 'Widget':
	                case 'Audio':
	                case 'Video':

	                    //缩放比
	                    activityData = reviseSize(activityData);

	                    startCreate(actType, activityData);
	                    break;
	            }
	        });

	        return widgetRetStr.join("");
	    },

	    /**
	     * 编译中断函数
	     * @return {[type]} [description]
	     */
	    compileSuspend: function compileSuspend(str) {

	        var nextTasks,
	            suspendTasks,
	            self = this;

	        //继续执行
	        nextTasks = function nextTasks() {
	            Xut.nextTick({
	                container: self.$containsNode,
	                content: $(str)
	            }, function () {
	                self.clearReference();
	                self.callback.successCallback();
	            });
	        };

	        //中断方法
	        suspendTasks = function suspendTasks() {
	            self.suspendQueues = [];
	            self.suspendQueues.push(function () {
	                nextTasks();
	            });
	        };

	        self.callback.suspendCallback(nextTasks, suspendTasks);
	    },

	    //运行被阻断的线程任务
	    runSuspendTasks: function runSuspendTasks() {
	        if (this.suspendQueues) {
	            var fn;
	            if (fn = this.suspendQueues.pop()) {
	                fn();
	            }
	            this.suspendQueues = null;
	        }
	    }
	};

	var transitionDuration = Xut.style.transitionDuration;
	var transform$1 = Xut.style.transform;
	var translateZ = Xut.style.translateZ;

	/**
	 * 切换坐标
	 * 保证只是pageType === page才捕获动作
	 */
	var toTranslate3d = function toTranslate3d(node, distance, speed, callback) {
	    node && Xut.nextTick(function () {
	        node.style[transform$1] = 'translate(' + distance + 'px,0px) ' + translateZ;
	        node.style[transitionDuration] = speed + 'ms';
	        callback && callback();
	    });
	};

	/**
	 * 设置
	 * @param  {[type]} node [description]
	 * @return {[type]}      [description]
	 */
	var set$2 = function set(node, x) {
	    if (node) {
	        node.style[transform$1] = 'translate(' + x + 'px,0px) ' + translateZ;
	    }
	};

	/**
	 * 复位
	 * @return {[type]} [description]
	 */
	var reset = function reset(node) {
	    if (node) {
	        node.style[transform$1] = 'translate(0px,0px) ' + translateZ;
	        node.style[transitionDuration] = '';
	    }
	};

	/**
	 * 移动
	 * @return {[type]} [description]
	 */
	var flipMove = function flipMove() {
	    toTranslate3d.apply(undefined, arguments);
	};

	/**
	 * 移动反弹
	 * @return {[type]} [description]
	 */
	var flipRebound = function flipRebound() {
	    toTranslate3d.apply(undefined, arguments);
	};

	/**
	 * 移动结束
	 * @return {[type]} [description]
	 */
	var flipOver = function flipOver() {
	    toTranslate3d.apply(undefined, arguments);
	};

	/**
	 * translation滑动接口
	 * @type {Object}
	 */
	var translation = {
	    set: set$2,
	    reset: reset,
	    flipMove: flipMove,
	    flipRebound: flipRebound,
	    flipOver: flipOver
	};

	/**
	 * 创建translate初始值
	 * @param  {[type]} offset [description]
	 * @return {[type]}        [description]
	 */
	var createTranslate = function createTranslate(offset) {
	    return 'translate(' + offset + 'px,0px)' + translateZ;
	};

	/**
	 * 修正坐标
	 * @return {[type]} [description]
	 */
	function _fix($node, action) {
	    var viewWidth = config.viewSize.width;
	    var translate = action === 'prevEffect' ? createTranslate(-viewWidth) : createTranslate(viewWidth);
	    $node.css(transform$1, translate);
	}

	//转换页码索引
	//direction 方向
	//pointer 当前页码标示
	//[17 18 19]  pagePointer
	//[18 19 20]  转换后
	// 17 销毁
	// 20 创建
	var getActionPointer = function getActionPointer(direction, leftIndex, rightIndex) {
	    var createPointer = void 0; //创建的页
	    var destroyPointer = void 0; //销毁的页
	    switch (direction) {
	        case 'prev':
	            //前处理
	            createPointer = leftIndex - 1;
	            destroyPointer = rightIndex;
	            break;
	        case 'next':
	            //后处理
	            createPointer = rightIndex + 1;
	            destroyPointer = leftIndex;
	            break;
	    }
	    return {
	        createPointer: createPointer,
	        destroyPointer: destroyPointer
	    };
	};

	/**
	 * 初始化首次范围
	 * @return {[type]} [description]
	 */
	var initPointer = function initPointer(init, pagetotal) {
	    var leftscope = 0,
	        pagePointer = {};

	    if (init === leftscope) {
	        //首页
	        pagePointer['currIndex'] = init;
	        pagePointer['rightIndex'] = init + 1;
	    } else if (init === pagetotal - 1) {
	        //首页
	        pagePointer['currIndex'] = init;
	        pagePointer['leftIndex'] = init - 1;
	    } else {
	        //中间页
	        pagePointer['leftIndex'] = init - 1;
	        pagePointer['currIndex'] = init;
	        pagePointer['rightIndex'] = init + 1;
	    }
	    return pagePointer;
	};

	/**
	 * 兼容事件对象
	 * @return {[type]}   [description]
	 */
	var compatibilityEvent$1 = function compatibilityEvent(e) {
	    var point;
	    if (e.touches && e.touches[0]) {
	        point = e.touches[0];
	    } else {
	        point = e;
	    }
	    return point;
	};

	/**
	 * 计算当前已经创建的页面索引
	 */
	var calculationIndex = function calculationIndex(currIndex, targetIndex, pagetotal) {
	    var i = 0,
	        existpage,
	        createpage,
	        pageIndex,
	        ruleOut = [],
	        create = [],
	        destroy,
	        viewFlip;

	    //存在的页面
	    if (currIndex === 0) {
	        existpage = [currIndex, currIndex + 1];
	    } else if (currIndex === pagetotal - 1) {
	        existpage = [currIndex - 1, currIndex];
	    } else {
	        existpage = [currIndex - 1, currIndex, currIndex + 1];
	    }

	    //需要创建的新页面
	    if (targetIndex === 0) {
	        createpage = [targetIndex, targetIndex + 1];
	    } else if (targetIndex === pagetotal - 1) {
	        createpage = [targetIndex - 1, targetIndex];
	    } else {
	        createpage = [targetIndex - 1, targetIndex, targetIndex + 1];
	    }

	    for (; i < createpage.length; i++) {
	        pageIndex = createpage[i];
	        //跳过存在的页面
	        if (-1 === existpage.indexOf(pageIndex)) {
	            //创建目标的页面
	            create.push(pageIndex);
	        } else {
	            //排除已存在的页面
	            ruleOut.push(pageIndex);
	        }
	    }

	    _.each(ruleOut, function (ruleOutIndex) {
	        existpage.splice(existpage.indexOf(ruleOutIndex), 1);
	    });

	    destroy = existpage;

	    viewFlip = [].concat(create).concat(ruleOut).sort(function (a, b) {
	        return a - b;
	    });

	    return {
	        'create': create,
	        'ruleOut': ruleOut,
	        'destroy': destroy,
	        'viewFlip': viewFlip,
	        'targetIndex': targetIndex,
	        'currIndex': currIndex
	    };
	};

	function api(Swipe) {

	    /**
	     * 获取初始化距离值
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.getInitDistance = function () {
	        return this._initDistance;
	    };

	    /**
	     * 模拟完成状态调用
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.simulationComplete = function () {
	        var _this = this;

	        setTimeout(function () {
	            _this._restore();
	            _this._unlock();
	        });
	    };

	    //允许滑动
	    Swipe.prototype.allowliding = function () {
	        this._unlock();
	    };

	    //禁止滑动
	    Swipe.prototype.bansliding = function () {
	        this._lock();
	    };

	    /**
	     * 停止翻页
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.openSwipe = function () {
	        this._initOperation();
	    };

	    /**
	     * 启动翻页
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.closeSwipe = function () {
	        if (!this._isMoving) {
	            this._off();
	        }
	    };

	    /**
	     * 是否为边界
	     * @param  {[type]}  distance [description]
	     * @return {Boolean}          [description]
	     */
	    Swipe.prototype.isBorder = function () {
	        this._borderBounce.apply(this, arguments);
	    };

	    /**
	     * 检车是否还在移动中
	     * @return {Boolean} [description]
	     */
	    Swipe.prototype.isMoving = function () {
	        return this._isMoving;
	    };

	    /**
	     * 前翻页接口
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.prev = function () {
	        if (!this._borderBounce(1)) {
	            this._slideTo('prev');
	        } else {
	            //边界反弹
	            this._setRebound(this._hindex, 'next');
	        }
	    };

	    /**
	     * 后翻页接口
	     * @return {Function} [description]
	     */
	    Swipe.prototype.next = function () {
	        if (!this._borderBounce(-1)) {
	            this._slideTo('next');
	        } else {
	            //边界反弹
	            this._setRebound(this._hindex, 'prev');
	        }
	    };

	    /**
	     * 获取当前页码
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.getHindex = function () {
	        return this._hindex;
	    };

	    /**
	     * 主动设置页码编号
	     * 因为分栏的关系，内部修改外部
	     * 页面需要拼接
	     */
	    Swipe.prototype.setPointer = function (target, pagetotal) {
	        this.pagePointer = initPointer(target, pagetotal || this.pagetotal);
	    };

	    /**
	     * 获取页面Pointer
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.getPointer = function () {
	        return this.pagePointer;
	    };

	    /**
	     * 跳指定页面
	     * @param  {[type]} targetIndex [description]
	     * @param  {[type]} preMode     [description]
	     * @param  {[type]} complete    [description]
	     * @return {[type]}             [description]
	     */
	    Swipe.prototype.scrollToPage = function (targetIndex) {
	        //目标页面

	        //如果还在翻页中
	        if (this._fliplock) return;

	        var currIndex = this._hindex; //当前页面

	        //相邻页
	        switch (targetIndex) {
	            //前一页
	            case currIndex - 1:
	                if (this.options.multiplePages) {
	                    return this.prev();
	                }
	                break;
	            //首页
	            case currIndex:
	                if (currIndex == 0) {
	                    this.$emit('onDropApp');
	                }
	                return;
	            //后一页
	            case currIndex + 1:
	                if (this.options.multiplePages) {
	                    return this.next();
	                }
	                break;
	        }

	        //算出是相关数据
	        var data = calculationIndex(currIndex, targetIndex, this.pagetotal);

	        //更新页码索引
	        this._updataPointer(data);

	        data.pagePointer = this.pagePointer;

	        this.$emit('onJumpPage', data);
	    };

	    /**
	     * 销毁所有
	     * @return {[type]} [description]
	     */
	    Swipe.prototype.destroy = function () {
	        this._off();
	        this.$off();
	        if (this._bubbleNode) {
	            this._bubbleNode.page = null;
	            this._bubbleNode.master = null;
	        }
	        this.container = null;
	    };

	    /**
	     * 调用动画完成
	     * @param {[type]} element [description]
	     */
	    Swipe.prototype.setTransitionComplete = function () {
	        this._distributed.apply(this, arguments);
	    };

	    /**
	     * 目标元素
	     * 找到li元素
	     * @param  {Function} callback [description]
	     * @return {[type]}            [description]
	     */
	    Swipe.prototype.findBubbleRootNode = function (point, pageType) {
	        var liNode = void 0,
	            map = void 0;
	        var _hindex = this._hindex;
	        var sectionRang = this.options.sectionRang;

	        //找到对应的li
	        var childNodes = this._bubbleNode[pageType].childNodes;
	        var nodeTotal = childNodes.length;

	        while (nodeTotal--) {
	            liNode = childNodes[nodeTotal];
	            map = liNode.getAttribute('data-map');
	            if (sectionRang) {
	                _hindex += sectionRang.start;
	            }
	            if (map == _hindex) {
	                return liNode;
	            }
	            _hindex = this._hindex;
	        }
	    };
	}

	/**
	 * 翻页速率
	 * @type {Number}
	 */
	var SPEED = 600;

	/**
	 * 默认翻页时间
	 * @type {Object}
	 */
	var DEFAULTTIME = {
	    min: 0,
	    mix: 500
	};

	var getDate = function getDate() {
	    return +new Date();
	};
	var transitionDuration$1 = Xut.style.transitionDuration;
	var LINEARTAG = 'data-viewlinear';

	/**
	 * 自定义事件类型
	 * onSwipeDown 触屏点击
	 * onSwipeMove 触屏移动
	 * onSwipeUp   触屏松手
	 * onSwipeUpSlider触屏松手 滑动处理
	 * onFlipSliding 松手动画（反弹）
	 * onFlipRebound 执行反弹
	 * _onAnimComplete 动画完成
	 * onDropApp 退出应用
	 */

	var Swipe = function (_Observer) {
	    inherits(Swipe, _Observer);

	    function Swipe(_ref) {
	        var flipWidth = _ref.flipWidth,
	            initIndex = _ref.initIndex,
	            container = _ref.container,
	            flipMode = _ref.flipMode,
	            pagetotal = _ref.pagetotal,
	            multiplePages = _ref.multiplePages,
	            _ref$stopPropagation = _ref.stopPropagation,
	            stopPropagation = _ref$stopPropagation === undefined ? false : _ref$stopPropagation,
	            preventDefault = _ref.preventDefault,
	            _ref$linear = _ref.linear,
	            linear = _ref$linear === undefined ? false : _ref$linear,
	            _ref$borderBounce = _ref.borderBounce,
	            borderBounce = _ref$borderBounce === undefined ? false : _ref$borderBounce,
	            _ref$extraGap = _ref.extraGap,
	            extraGap = _ref$extraGap === undefined ? 0 : _ref$extraGap,
	            sectionRang = _ref.sectionRang;
	        classCallCheck(this, Swipe);

	        var _this = possibleConstructorReturn(this, (Swipe.__proto__ || Object.getPrototypeOf(Swipe)).call(this));

	        _this.options = {

	            stopPropagation: stopPropagation,

	            /**
	             * 默认阻止所有行为
	             * @type {[type]}
	             */
	            preventDefault: preventDefault ? preventDefault : true,

	            /**
	             * 是否分段处理
	             * 默认是
	             * @type {[type]}
	             */
	            linear: linear,

	            /**
	             * 启动边界反弹
	             * @type {[type]}
	             */
	            borderBounce: borderBounce,

	            /**
	             * flipMode
	             * 1 翻页没有直接效果，速度改为0
	             * 2 翻页后没有动画回调
	             * @type {[type]}
	             */
	            flipMode: flipMode,

	            /**
	             * 是否有多页面
	             */
	            multiplePages: multiplePages,

	            /**
	             * section分段拼接
	             * @type {[type]}
	             */
	            sectionRang: sectionRang
	        };

	        _this._hindex = initIndex;
	        _this.pagetotal = pagetotal;
	        _this.container = container;

	        /**
	         * 视图宽度
	         * @type {[type]}
	         */
	        _this._viewWidth = flipWidth || config.viewSize.width;

	        /**
	         * 翻页时间
	         * @type {[type]}
	         */
	        _this._pageTime = _this.options.flipMode ? DEFAULTTIME.min : DEFAULTTIME.mix;

	        /**
	         * 翻页速率
	         * @type {[type]}
	         */
	        _this._speedRate = _this._originalRate = _this._pageTime / _this._viewWidth;

	        /**
	         * 是否移动中
	         * @type {Boolean}
	         */
	        _this._isMoving = false;

	        /**
	         * 计算初始化页码
	         * @type {[type]}
	         */
	        _this.pagePointer = initPointer(initIndex, pagetotal);

	        //初始化线性翻页
	        //全局只创建一个翻页容器
	        if (linear) {
	            container.setAttribute(LINEARTAG, true);

	            //this._initDistance 提供给flow调用
	            _this._initDistance = -_this._hindex * (_this._viewWidth + extraGap);
	            container.style[Xut.style.transform] = 'translate(' + _this._initDistance + 'px,0px)' + Xut.style.translateZ;
	            container.style.width = _this._viewWidth * _this.pagetotal + 'px';
	        } else {
	            //用于查找跟元素
	            //ul => page
	            //ul => master
	            var ul = container.querySelectorAll('ul');
	            _this._bubbleNode = {
	                page: ul[0],
	                master: ul[1]
	            };
	        }

	        //绑定行为
	        _this._initEvents();
	        return _this;
	    }

	    /**
	     * 绑定事件
	     * @return {[type]} [description]
	     */


	    createClass(Swipe, [{
	        key: '_initEvents',
	        value: function _initEvents() {

	            var callback = {
	                start: this,
	                end: this,
	                cancel: this
	            };

	            //flipMode启动，没有滑动处理
	            if (this.options.flipMode) {
	                //不需要绑定transitionend，会设置手动会触发
	            } else if (this.options.multiplePages) {
	                callback.move = this;
	                callback.transitionend = this;
	            }

	            $$on(this.container, callback);
	        }

	        /**
	         * 触发
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onStart',
	        value: function _onStart(e) {

	            //如果停止滑动
	            //或者多点触发
	            if (this._fliplock || e.touches && e.touches.length > 1) {
	                return;
	            }

	            //判断双击速度
	            //必须要大于350
	            var currtTime = getDate();
	            if (this._clickTime) {
	                if (currtTime - this._clickTime < 350) {
	                    return;
	                }
	            }
	            this._clickTime = currtTime;

	            var interrupt = void 0;
	            var point = compatibilityEvent$1(e);

	            if (!point) {
	                return interrupt = this._preventSwipe = true;
	            }

	            /**
	             * 获取观察对象
	             * 钩子函数
	             * point 事件对象
	             * @return {[type]} [description]
	             */
	            this.$emit('onFilter', function () {
	                interrupt = true;
	            }, point, e);

	            //打断动作
	            if (interrupt) return;

	            this._deltaX = 0;
	            this._deltaY = 0;

	            this._preventSwipe = false; //是否滑动事件受限
	            this._isBounce = false; //是否反弹
	            this._isRollX = false; //是否为X轴滑动
	            this._isRollY = false; //是否为Y轴滑动
	            this._isTap = true; //点击了屏幕

	            this._start = {
	                pageX: point.pageX,
	                pageY: point.pageY,
	                time: getDate()
	            };
	        }

	        /**
	         * 移动
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onMove',
	        value: function _onMove(e) {

	            //如果停止翻页
	            //或者没有点击
	            //或是Y轴滑动
	            //或者是阻止滑动
	            if (this._fliplock || !this._isTap || this._isRollY || this._preventSwipe) return;

	            this._isMoving = true;

	            var point = compatibilityEvent$1(e);
	            var deltaX = point.pageX - this._start.pageX;
	            var deltaY = point.pageY - this._start.pageY;
	            var absDeltaX = Math.abs(deltaX);
	            var absDeltaY = Math.abs(deltaY);

	            //=========Y轴滑动=========
	            if (!this._isRollY) {
	                //Y>X => 为Y轴滑动
	                if (absDeltaY > absDeltaX) {
	                    this._isRollY = true;
	                    return;
	                }
	            }

	            //=========X轴滑动=========

	            //前尾是否允许反弹
	            if (!this.options.borderBounce) {
	                if (this._isBounce = this._borderBounce(deltaX)) return;
	            }

	            //滑动方向
	            //left => 负
	            //rigth => 正
	            this._deltaX = deltaX / (!this._hindex && deltaX > 0 // 在首页
	            || this._hindex == this.pagetotal - 1 // 尾页
	            && deltaX < 0 // 中间
	            ? absDeltaX / this._viewWidth + 1 : 1);

	            if (!this._isRollX && this._deltaX) {
	                this._isRollX = true;
	            }

	            this.direction = this._deltaX > 0 ? 'prev' : 'next';

	            //减少抖动
	            //算一次有效的滑动
	            //移动距离必须20px才开始移动
	            var xWait = 20;
	            if (absDeltaX <= xWait) return;

	            //需要叠加排除值
	            if (this._deltaX > 0) {
	                xWait = -xWait;
	            }

	            this._distributeMove({
	                'pageIndex': this._hindex,
	                'distance': this._deltaX + xWait,
	                'speed': 0,
	                'direction': this.direction,
	                'action': 'flipMove'
	            });
	        }

	        /**
	         * 松手
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onEnd',
	        value: function _onEnd(e) {

	            //停止滑动
	            //或者多点触发
	            if (this._fliplock || e.touches && e.touches.length > 1) {
	                return;
	            }

	            this._isTap = false;
	            this._isMoving = false;

	            if (this._isBounce || this._preventSwipe) return;

	            //点击
	            if (!this._isRollX && !this._isRollY) {
	                var isReturn = false;
	                this.$emit('onTap', this._hindex, function () {
	                    return isReturn = true;
	                }, e);
	                if (isReturn) return;
	            }

	            //如果是左右滑动
	            if (this._isRollX) {

	                var duration = getDate() - this._start.time;
	                var deltaX = Math.abs(this._deltaX);

	                //如果是首尾
	                //如果是liner模式排除
	                var isPastBounds = this.options.linear ? false : !this._hindex && this._deltaX > 0 || this._hindex == this.pagetotal - 1 && this._deltaX < 0;

	                //_slideTo的最低值要求
	                //1 fast: time < 200 && x >30
	                //2 common: x > veiwWidth/6
	                var isValidSlide = Number(duration) < 200 && Math.abs(deltaX) > 30 || Math.abs(deltaX) > this._viewWidth / 6;

	                //跟随移动
	                if (isValidSlide && !isPastBounds) {
	                    //true:right, false:left
	                    this._slideTo(this._deltaX < 0 ? 'next' : 'prev');
	                } else {
	                    //反弹
	                    this._setRebound(this._hindex, this._deltaX > 0 ? 'prev' : 'next');
	                }
	            }
	        }

	        /**
	         * 前尾边界反弹判断
	         * @param  {[type]} deltaX [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_borderBounce',
	        value: function _borderBounce(deltaX) {
	            //首页,并且是左滑动
	            if (this._hindex === 0 && deltaX > 0) {
	                return true;
	                //尾页
	            } else if (this._hindex === this.pagetotal - 1 && deltaX < 0) {
	                return true;
	            }
	        }

	        /**
	         * 设置反弹
	         */

	    }, {
	        key: '_setRebound',
	        value: function _setRebound(pageIndex, direction) {
	            this._distributeMove({
	                'pageIndex': pageIndex,
	                'direction': direction,
	                'distance': 0,
	                'speed': 300,
	                'action': 'flipRebound'
	            });
	        }

	        /**
	         * 处理松手后滑动
	         * pageIndex 页面
	         * distance  移动距离
	         * speed     时间
	         * viewTag   可使区标记
	         * follow    是否为跟随滑动
	         * @return {[type]} [description]
	         * pageIndex: 0, distance: -2, speed: 0, direction: "next", action: "flipMove"
	         */

	    }, {
	        key: '_distributeMove',
	        value: function _distributeMove(data) {
	            var pointer = this.pagePointer;
	            data.leftIndex = pointer.leftIndex;
	            data.rightIndex = pointer.rightIndex;
	            this.$emit('onMove', data);
	        }

	        /**
	         * 边界控制
	         * @param  {[type]} direction [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_isBorder',
	        value: function _isBorder(direction) {
	            var overflow = void 0;
	            var pointer = this.pagePointer;
	            var fillength = Object.keys(pointer).length;

	            switch (direction) {
	                case 'prev':
	                    //前翻页
	                    overflow = pointer.currIndex === 0 && fillength === 2 ? true : false;
	                    break;
	                case 'next':
	                    //后翻页
	                    overflow = pointer.currIndex === this.pagetotal - 1 && fillength === 2 ? true : false;
	                    break;
	            }

	            return overflow;
	        }

	        /**
	         * 复位速率
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_resetRate',
	        value: function _resetRate() {
	            this._speedRate = this._originalRate;
	            this._isQuickTurn = false;
	        }

	        /**
	         * 快速翻页时间计算
	         */

	    }, {
	        key: '_setRate',
	        value: function _setRate() {
	            this._speedRate = 50 / this._viewWidth;
	            this._isQuickTurn = true;
	        }

	        /**
	         * 判断是否快速翻页
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_quickTurn',
	        value: function _quickTurn() {
	            var startDate = getDate();
	            if (this._preTapTime) {
	                if (startDate - this._preTapTime < SPEED) {
	                    this._setRate();
	                }
	            }
	            this._preTapTime = getDate();
	        }

	        /**
	         * 翻页加锁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_lock',
	        value: function _lock() {
	            this._fliplock = true;
	        }

	        /**
	         * 修正页面索引
	         */

	    }, {
	        key: '_fixHindex',
	        value: function _fixHindex(currIndex) {
	            this._hindex = currIndex; //翻页索引
	        }

	        /**
	         * 更新页码标示
	         */

	    }, {
	        key: '_updataPointer',
	        value: function _updataPointer(leftIndex, currIndex, rightIndex) {
	            if (arguments.length === 3) {
	                this.pagePointer = {
	                    'leftIndex': leftIndex,
	                    'currIndex': currIndex,
	                    'rightIndex': rightIndex
	                };
	                return;
	            }
	            if (arguments.length === 1) {
	                var data = leftIndex;
	                var viewFlip = data.viewFlip;
	                this._fixHindex(data.targetIndex);
	                if (viewFlip.length === 3) {
	                    this._updataPointer(viewFlip[0], viewFlip[1], viewFlip[2]);
	                }
	                if (viewFlip.length === 2) {
	                    if (viewFlip[0] === 0) {
	                        //首页
	                        this.pagePointer.rightIndex = viewFlip[1];
	                        this.pagePointer.currIndex = viewFlip[0];
	                        delete this.pagePointer.leftIndex;
	                    } else {
	                        //尾页
	                        this.pagePointer.leftIndex = viewFlip[0];
	                        this.pagePointer.currIndex = viewFlip[1];
	                        delete this.pagePointer.rightIndex;
	                    }
	                }
	                return;
	            }
	        }

	        /**
	         * 增加索引的动作
	         * 修正页码指示
	         */

	    }, {
	        key: '_updateActionPointer',
	        value: function _updateActionPointer(pointer) {

	            //获取动作索引
	            // createPointer
	            // destroyPointer
	            var actionPointer = getActionPointer(this.direction, pointer.leftIndex, pointer.rightIndex);

	            //需要创建的页面
	            var createPointer = actionPointer.createPointer;

	            //需要停止动作的页面索引
	            var stopPointer = pointer.currIndex;

	            switch (this.direction) {
	                case 'prev':
	                    if (-1 < createPointer) {
	                        //首页情况
	                        this._updataPointer(createPointer, pointer.leftIndex, pointer.currIndex);
	                    }
	                    if (-1 === createPointer) {
	                        this.pagePointer.rightIndex = pointer.currIndex;
	                        this.pagePointer.currIndex = pointer.leftIndex;
	                        delete this.pagePointer.leftIndex;
	                    }
	                    break;
	                case 'next':
	                    if (this.pagetotal > createPointer) {
	                        this._updataPointer(pointer.currIndex, pointer.rightIndex, createPointer);
	                    }
	                    if (this.pagetotal === createPointer) {
	                        //如果是尾页
	                        this.pagePointer.leftIndex = pointer.currIndex;
	                        this.pagePointer.currIndex = pointer.rightIndex;
	                        delete this.pagePointer.rightIndex;
	                    }
	                    break;
	            }

	            //更新页面索引标识
	            this.pagePointer.createPointer = createPointer;
	            this.pagePointer.destroyPointer = actionPointer.destroyPointer;
	            this.pagePointer.stopPointer = stopPointer;
	        }

	        /**
	         * 滑动到上下页面
	         * direction
	         *     "perv" / "next"
	         * @param  {[type]} direction [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_slideTo',
	        value: function _slideTo(direction) {
	            var _this2 = this;

	            //如果在忙碌状态,如果翻页还没完毕
	            if (this._fliplock) {
	                return;
	            }

	            //前后边界
	            if (!this.options.linear) {
	                if (this._isBorder(direction)) return;
	            }

	            this._lock();
	            this.direction = direction;
	            this._quickTurn();

	            /**
	             * 计算滑动速度
	             * @return {[type]} [description]
	             */
	            var calculatespeed = function calculatespeed() {
	                return (_this2._viewWidth - Math.abs(_this2._deltaX)) * _this2._speedRate || _this2._pageTime;
	            };

	            this._distributeMove({
	                'pageIndex': this._hindex,
	                'speed': calculatespeed(),
	                'distance': 0,
	                'direction': this.direction,
	                'action': 'flipOver'
	            });

	            setTimeout(function () {
	                //更新this.pagePointer索引
	                //增加处理标记
	                _this2._updateActionPointer(_this2.pagePointer);
	                _this2.$emit('onUpSlider', _this2.pagePointer);
	                _this2._fixHindex(_this2.pagePointer.currIndex);
	            });
	        }

	        /**
	         * 动画结束后处理
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: '_onAnimComplete',
	        value: function _onAnimComplete(e) {
	            var node = e.target;
	            var pageType = node.getAttribute('data-pageType');
	            var view = node.getAttribute('data-view'); //操作的可视窗口
	            var linearView = node.getAttribute(LINEARTAG); //流式布局

	            //去掉动画时间
	            if (node) {
	                node.style[transitionDuration$1] = '';
	            }

	            //流式布局处理
	            if (linearView && !view) {
	                this._distributed(node, view);
	                return;
	            }

	            //反弹效果,未翻页
	            if (!view) {
	                if (!pageType) {
	                    //只针对母板处理
	                    this.$emit('onMasterMove', this._hindex, node);
	                }
	                return;
	            }

	            this._distributed(node, view);
	        }

	        /**
	         * 还原设置
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_restore',
	        value: function _restore(node, view) {

	            this._isMoving = false;

	            //针对拖拽翻页阻止
	            this._preventSwipe = true;
	            this._isTap = false;
	            //恢复速率
	            this._resetRate();
	            view && node.removeAttribute('data-view', 'false');
	        }
	    }, {
	        key: '_distributed',
	        value: function _distributed() {
	            var _this3 = this;

	            this._restore.apply(this, arguments);

	            //延长获取更pagePointer的更新值
	            setTimeout(function () {
	                _this3.$emit('onComplete', _this3.direction, _this3.pagePointer, _this3._unlock.bind(_this3), _this3._isQuickTurn);
	            }, 50);
	        }

	        /**
	         * 解锁翻页
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_unlock',
	        value: function _unlock() {
	            this._fliplock = false;
	        }

	        /**
	         * 销毁事件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_off',
	        value: function _off() {
	            $$off(this.container, {
	                start: this,
	                move: this,
	                end: this,
	                cancel: this,
	                transitionend: this
	            });
	        }

	        /**
	         * 事件处理
	         * @param  {[type]} e [description]
	         * @return {[type]}   [description]
	         */

	    }, {
	        key: 'handleEvent',
	        value: function handleEvent(e) {

	            this.options.preventDefault && e.preventDefault();
	            this.options.stopPropagation && e.stopPropagation();

	            //接受多事件的句柄
	            $$handle({
	                start: function start(e) {
	                    this._onStart(e);
	                },
	                move: function move(e) {
	                    this._onMove(e);
	                },
	                end: function end(e) {
	                    this._onEnd(e);
	                },
	                transitionend: function transitionend(e) {
	                    this._onAnimComplete(e);
	                }
	            }, this, e);
	        }
	    }]);
	    return Swipe;
	}(Observer);

	api(Swipe);

	/**
	 * dom...
	 */
	function render() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        $pinchNode = _ref.$pinchNode,
	        dataNode = _ref.dataNode,
	        chapterId = _ref.chapterId,
	        callback = _ref.callback;

	    var $container = $(dataNode.html());
	    Xut.nextTick({
	        container: $pinchNode,
	        content: $container
	    }, function () {
	        return callback($container);
	    });
	}

	/**
	 * 下一页是否为flow页面
	 * 要根据这个判断来处理翻页的距离
	 * @return {[type]} [description]
	 */
	var checkFlows = function checkFlows(pageIndex) {
	    var pageObj = Xut.Presentation.GetPageObj(pageIndex);
	    return pageObj && pageObj.isFlows;
	};

	/**
	 * 制作钩子收集器
	 * @return {[type]} [description]
	 */
	var makeGather = function makeGather() {
	    var _gather = hash();
	    _gather.$$checkFlows = checkFlows;
	    return _gather;
	};

	/**
	 * 动态计算翻页距离
	 * @return {[type]} [description]
	 */
	function getFlipDistance() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        action = _ref.action,
	        distance = _ref.distance,
	        direction = _ref.direction,
	        leftIndex = _ref.leftIndex,
	        pageIndex = _ref.pageIndex,
	        rightIndex = _ref.rightIndex;

	    var hooks = arguments[1];


	    //区域尺寸
	    var veiwWidth = config.viewSize.width;

	    var offset = {
	        left: undefined,
	        middle: undefined,
	        right: undefined,
	        //当前视图页面
	        //用来处理页面回调
	        view: undefined
	    };

	    /**
	     * 混入钩子
	     * @return {[type]} [description]
	     */
	    var mixHooks = function mixHooks(hook) {
	        if (hook) {
	            var _receiver = makeGather();
	            _receiver.$$leftIndex = leftIndex;
	            _receiver.$$middleIndex = pageIndex;
	            _receiver.$$rightIndex = rightIndex;
	            _receiver.$$right = offset.right;
	            _receiver.$$left = offset.left;
	            hook(_receiver);
	            _.each(_receiver, function (value, key) {
	                offset[key] = value;
	            });
	        }
	    };

	    /**
	     * 滑动
	     * @param  {[type]} action [description]
	     * @return {[type]}        [description]
	     */
	    if (action === 'flipMove') {
	        offset.left = distance - veiwWidth;
	        offset.middle = distance;
	        offset.right = distance + veiwWidth;
	        var flipMove = hooks && hooks.flipMove;
	        if (flipMove) {
	            if (direction === 'prev') {
	                mixHooks(flipMove.left);
	            }
	            if (direction === 'next') {
	                mixHooks(flipMove.right);
	            }
	        }
	    }

	    /**
	     * 反弹
	     * @param  {[type]} action [description]
	     * @return {[type]}        [description]
	     */
	    if (action === 'flipRebound') {
	        offset.left = -veiwWidth;
	        offset.middle = distance;
	        offset.right = veiwWidth;
	        var flipRebound = hooks && hooks.flipRebound;
	        if (flipRebound) {
	            if (direction === 'prev') {
	                mixHooks(flipRebound.left);
	            }
	            if (direction === 'next') {
	                mixHooks(flipRebound.right);
	            }
	        }
	    }

	    /**
	     * 翻页
	     * @param  {[type]} action [description]
	     * @return {[type]}        [description]
	     */
	    if (action === 'flipOver') {

	        var flipOver = hooks && hooks.flipOver;

	        /**
	         * 前翻
	         */
	        if (direction === 'prev') {
	            offset.left = 0;
	            offset.middle = veiwWidth;
	            offset.right = 2 * veiwWidth;
	            flipOver && mixHooks(flipOver.left);
	            offset.view = offset.left;
	        }

	        /**
	         * 后翻
	         */
	        if (direction === 'next') {
	            offset.left = -2 * veiwWidth;
	            offset.middle = -veiwWidth;
	            offset.right = distance;
	            flipOver && mixHooks(flipOver.right);
	            offset.view = offset.right;
	        }
	    }

	    return [offset.left, offset.middle, offset.right, offset.view];
	}

	var flowConfig = {
	    view: function view() {

	        var viewWidth = config.screenSize.width;
	        var viewHeight = config.screenSize.height;
	        var viewTop = 0;
	        var viewLeft = 0;

	        //宽度100%的情况下
	        //如果是flow页面处理,全屏
	        if (config.visualMode === 2) {
	            if (config.pptVertical) {
	                //其他页面上下压缩，左右100%
	                //flows页面宽高都是100%
	                if (config.screenVertical) {
	                    viewWidth = config.screenSize.width;
	                    viewHeight = config.screenSize.height;
	                    viewTop = 0;
	                } else {
	                    viewWidth = config.viewSize.width;
	                    viewHeight = config.viewSize.height;
	                    viewTop = 0;
	                }
	            }
	            return {
	                viewWidth: viewWidth,
	                viewHeight: viewHeight,
	                viewTop: viewTop
	            };
	        }

	        //高度100%的情况下
	        //flow下,设置容易宽度
	        if (config.visualMode === 3) {
	            if (config.pptVertical) {
	                //竖版竖版
	                //存在溢出或者未填满全屏(ipad)的情况
	                if (config.screenVertical) {
	                    //溢出强制全屏
	                    if (config.viewSize.overflowWidth) {
	                        viewWidth = config.screenSize.width;
	                    }
	                    //如果没有填满采用可视区大小
	                    if (config.viewSize.notFillWidth) {
	                        viewWidth = config.viewSize.width;
	                    }
	                } else {}
	            }
	        }

	        return {
	            viewWidth: viewWidth,
	            viewHeight: viewHeight,
	            viewTop: viewTop,
	            viewLeft: viewLeft
	        };
	    }

	    /**
	     * 容器translate的规则
	     * @param  {[type]} data       [description]
	     * @param  {[type]} usefulData [description]
	     * @return {[type]}            [description]
	     */
	    ,
	    translate: function translate(data, usefulData) {
	        if (config.viewSize.overflowWidth) {
	            return {
	                left: function left(offsetLeft) {
	                    var middle = usefulData.getStyle('middle');
	                    if (middle && middle.isFlows) {
	                        return -(middle.viewWidth + middle.offset);
	                    }
	                },
	                middle: function middle(originalOffset) {
	                    if (data.isFlows) {
	                        return -config.viewSize.left;
	                    }
	                },
	                right: function right(originalOffset) {
	                    //获取上一页的styles状态
	                    //如果上一页是通过flow方式处理过的
	                    //当前页面小姐要不去重新处理
	                    var middle = usefulData.getStyle('middle');
	                    if (middle && middle.isFlows) {
	                        return middle.viewWidth + middle.offset;
	                    }
	                }
	            };
	        }
	    }

	    /**
	     * 滑动值
	     * @return {[type]} [description]
	     */
	    ,
	    distance: function distance() {
	        if (config.viewSize.overflowWidth) {
	            return {
	                flipMove: {
	                    left: function left(data) {
	                        var leftFlow = data.$$checkFlows(data.$$leftIndex);
	                        if (leftFlow) {
	                            data.left = data.$$left + Math.abs(config.viewSize.left) * 2;
	                        }
	                    },
	                    right: function right(data) {
	                        var middleFlow = data.$$checkFlows(data.$$middleIndex);
	                        if (middleFlow) {
	                            data.right = data.$$right - Math.abs(config.viewSize.left) * 2;
	                        }
	                    }
	                },
	                /**
	                 * 反弹是反向设置，这个需要注意
	                 * @type {Object}
	                 */
	                flipRebound: {
	                    left: function left(data) {
	                        //往右边滑动反弹，所以left为左边处理
	                        //而且只修正当期那是flow
	                        var middleFlow = data.$$checkFlows(data.$$middleIndex);
	                        if (middleFlow) {
	                            data.middle = Math.abs(config.viewSize.left);
	                        }
	                    },
	                    right: function right(data) {
	                        var middleFlow = data.$$checkFlows(data.$$middleIndex);
	                        if (middleFlow) {
	                            data.middle = Math.abs(config.viewSize.left);
	                        }
	                    }
	                },
	                flipOver: {
	                    left: function left(data) {
	                        var leftFlow = data.$$checkFlows(data.$$leftIndex);
	                        if (leftFlow) {
	                            data.left = -config.viewSize.left;
	                        }
	                    },
	                    right: function right(data) {
	                        var rightFlow = data.$$checkFlows(data.$$rightIndex);
	                        //当前正常页面，下一页flow
	                        if (rightFlow) {
	                            data.right = Math.abs(config.viewSize.left);
	                        }
	                    }
	                }
	            };
	        }
	    }
	};

	/**
	 * 结果缓存
	 * @type {Object}
	 */
	var _cache = {};

	/**
	 * flow类型标记
	 * @type {String}
	 */
	var FLOWTYPE = 'flow';

	/**
	 * 获取flow页面布局数据
	 * @param  {[type]} config         [description]
	 * @param  {[type]} fullProportion [description]
	 * @return {[type]}                [description]
	 */
	function getFlowView() {
	    return _cache[FLOWTYPE] ? _cache[FLOWTYPE] : _cache[FLOWTYPE] = flowConfig.view();
	}

	function setFlowTranslate() {
	    return flowConfig.translate.apply(flowConfig, arguments);
	}

	function getFlowDistance() {
	    return flowConfig.distance.apply(flowConfig, arguments);
	}

	function adapterDestory() {
	    _cache = {};
	}

	/**
	 * 关闭按钮
	 * @param  {[type]} right [description]
	 * @param  {[type]} top   [description]
	 * @return {[type]}       [description]
	 */
	var createCloseIcon$1 = function createCloseIcon(right, top) {
	    var html = "<div class=\"page-pinch-close\" style=\"right:" + right + "px;top:" + top + "px;\">\n           <div class=\"si-icon icomoon icon-close\" style=\"font-size:4vh;background:white;border-radius:4vh;width:4vh;height:4vh;position:absolute;right:0;\"></div>\n        </div>";
	    return $(String.styleFormat(html));
	};

	/**
	 * 创建关闭按钮
	 * @return {[type]} [description]
	 */
	function pinchButton(callback) {
	    var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    var $closeNode = createCloseIcon$1(right, top);
	    $closeNode.on("touchend mouseup", function () {
	        callback();
	    });
	    return $closeNode;
	}

	var transform$2 = Xut.style.transform;
	var transitionDuration$2 = Xut.style.transitionDuration;
	var translateZ$1 = Xut.style.translateZ;

	var START_X = 0;
	var START_Y = 0;

	/**
	 * 缩放、平移操作
	 */

	var PinchPan = function () {
	    function PinchPan(_ref) {
	        var $pagePinch = _ref.$pagePinch,
	            _ref$hasButton = _ref.hasButton,
	            hasButton = _ref$hasButton === undefined ? true : _ref$hasButton,
	            update = _ref.update,
	            doubletap = _ref.doubletap;
	        classCallCheck(this, PinchPan);


	        this.update = update;
	        this.doubletap = doubletap;

	        //是否配置关闭按钮
	        this.hasButton = hasButton;

	        //缩放根节点
	        this.$pinchNode = $pagePinch;
	        this.pinchNode = $pagePinch[0];

	        this._offsetWidth = this.pinchNode.offsetWidth;
	        this._offsetHeight = this.pinchNode.offsetHeight;

	        //初始化状态
	        this._initState();

	        //初始化事件
	        this._initEvent();
	    }

	    createClass(PinchPan, [{
	        key: '_initState',
	        value: function _initState() {

	            //允许溢出值
	            this.overflowValue = 0.3;

	            /**
	             * 缩放中
	             * @type {Boolean}
	             */
	            this.scaleing = false;

	            /**
	             * 最后一个缩放值
	             * @type {Number}
	             */
	            this.lastScale = 1;

	            /**
	             * 是否更新中
	             * @type {Boolean}
	             */
	            this.ticking = false;

	            this.currentX = START_X;
	            this.currentY = START_Y;

	            /**
	             * 需要更新的数据
	             * @type {Object}
	             */
	            this.data = {
	                translate: {
	                    x: START_X,
	                    y: START_Y
	                },
	                scale: 1
	            };

	            this._buttonHide();
	        }

	        /**
	         * 初始化事件
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initEvent',
	        value: function _initEvent() {
	            var _this = this;

	            this.hammer = new Hammer.Manager(this.pinchNode);
	            this.hammer.add(new Hammer.Pan({ threshold: 0, pointers: 0, enable: false }));
	            this.hammer.add(new Hammer.Pinch({ threshold: 0 })).recognizeWith(this.hammer.get('pan'));
	            this.hammer.add(new Hammer.Tap({ event: 'doubletap', taps: 2, posThreshold: 30 }));
	            this.hammer.add(new Hammer.Tap());

	            _.each({
	                'doubletap': '_onDoubletap',
	                'pinchstart': '_onPinchStart',
	                'pinchmove': '_onPinchMove',
	                'pinchend': '_onPinchEnd',
	                'panstart panmove': '_onPan',
	                'panend': '_onPanEnd',
	                'pinchcancel': '_onPinchEnd'
	            }, function (value, key) {
	                _this.hammer.on(key, function (e) {
	                    e.preventDefault();
	                    e.srcEvent.stopPropagation();
	                    _this[value](e);
	                });
	            });
	        }
	    }, {
	        key: '_onDoubletap',
	        value: function _onDoubletap() {
	            if (this.doubletap) {
	                this.doubletap();
	            } else {
	                this._reset();
	            }
	        }
	    }, {
	        key: '_onPinchStart',
	        value: function _onPinchStart(ev) {
	            this.lastScale = this.data.scale || 1;
	        }

	        /**
	         * 缩放移动
	         * @param  {[type]} ev [description]
	         * @return {[type]}    [description]
	         */

	    }, {
	        key: '_onPinchMove',
	        value: function _onPinchMove(ev) {
	            //允许溢出值
	            if (!this.scaleing) {
	                if (ev.scale < this.overflowValue + 1) {
	                    return;
	                }
	                this.scaleing = true;
	            }

	            var scale = ev.scale - this.overflowValue;

	            //新的缩放值
	            this.data.scale = this.lastScale * scale;

	            this._buttonShow();
	            this._isBoundry();
	            this._updateNodeStyle();
	        }

	        /**
	         * 缩放松手
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_onPinchEnd',
	        value: function _onPinchEnd(ev) {
	            var _this2 = this;

	            if (this.data.scale <= 1) {
	                Xut.nextTick(function () {
	                    _this2._initState();
	                    _this2._updateNodeStyle(500);
	                });
	            } else {
	                this.overflowValue = 0;
	            }
	        }

	        /**
	         * 平移
	         * @param  {[type]} ev [description]
	         * @return {[type]}    [description]
	         */

	    }, {
	        key: '_onPan',
	        value: function _onPan(ev) {
	            if (this._isRunning) {
	                if (this.currentX != START_X || this.currentY != START_Y) {
	                    this.data.translate = {
	                        x: this.currentX + ev.deltaX,
	                        y: this.currentY + ev.deltaY
	                    };
	                } else {
	                    this.data.translate = {
	                        x: START_X + ev.deltaX,
	                        y: START_Y + ev.deltaY
	                    };
	                }
	                this._isBoundry();
	                this._updateNodeStyle();
	            }
	        }

	        /**
	         * 平移松手
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_onPanEnd',
	        value: function _onPanEnd() {
	            this.currentX = this.data.translate.x;
	            this.currentY = this.data.translate.y;
	        }

	        /**
	         * 边界反弹
	         * @return {Boolean} [description]
	         */

	    }, {
	        key: '_isBoundry',
	        value: function _isBoundry() {
	            if (this._isRunning) {
	                var horizontalBoundry = (this.data.scale - 1) / 2 * this._offsetWidth;
	                var verticalBoundry = (this.data.scale - 1) / 2 * this._offsetHeight;

	                //左边界
	                if (this.data.translate.x >= horizontalBoundry) {
	                    this.data.translate.x = horizontalBoundry;
	                }
	                //右边界
	                if (this.data.translate.x <= -horizontalBoundry) {
	                    this.data.translate.x = -horizontalBoundry;
	                }
	                //上边界
	                if (this.data.translate.y >= verticalBoundry) {
	                    this.data.translate.y = verticalBoundry;
	                }
	                //下边界
	                if (this.data.translate.y <= -verticalBoundry) {
	                    this.data.translate.y = -verticalBoundry;
	                }
	            } else {
	                this.data.scale = 1;
	                this.data.translate.x = START_X;
	                this.data.translate.y = START_Y;
	            }
	        }

	        /**
	         * 更新节点样式
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_updateNodeStyle',
	        value: function _updateNodeStyle() {
	            var _this3 = this;

	            var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	            if (!this.ticking) {
	                Xut.nextTick(function () {
	                    var data = _this3.data;
	                    var styleText = 'translate(' + data.translate.x + 'px,' + data.translate.y + 'px) ' + translateZ$1 + '\n            scale(' + data.scale + ',' + data.scale + ')';

	                    _this3.pinchNode.style[transform$2] = styleText;
	                    _this3.pinchNode.style[transitionDuration$2] = speed + 'ms';
	                    _this3.update && _this3.update(styleText, speed);
	                    _this3.ticking = false;
	                });
	                this.ticking = true;
	            }
	        }

	        /**
	         * 还原
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_reset',
	        value: function _reset() {
	            this._initState();
	            this._updateNodeStyle(500);
	        }

	        /**
	         * 创建按钮
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createPinchButton',
	        value: function _createPinchButton() {
	            var _this4 = this;

	            var viewSize = config.viewSize;
	            var left = viewSize.overflowWidth && Math.abs(viewSize.left) || 0;
	            var top = viewSize.overflowHeight && Math.abs(viewSize.top) || 0;
	            var $node = pinchButton(function () {
	                _this4._reset();
	            }, left, top);
	            this.$pinchNode.after($node);
	            return $node;
	        }

	        /**
	         * 按钮显示
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_buttonShow',
	        value: function _buttonShow() {
	            var _this5 = this;

	            //to heavy
	            if (this._isRunning) return;
	            if (this.data.scale > 1) {
	                //必须启动配置
	                if (this.hasButton) {
	                    if (this.$buttonNode) {
	                        Xut.nextTick(function () {
	                            _this5.$buttonNode.show();
	                        });
	                    } else {
	                        this.$buttonNode = this._createPinchButton();
	                    }
	                }
	                Xut.Application.Bansliding(); //禁止全局滑动
	                this._isRunning = true;
	                this.hammer.get('pan').set({ enable: true });
	            }
	        }

	        /**
	         * 按钮隐藏
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_buttonHide',
	        value: function _buttonHide() {
	            if (!this._isRunning) return;
	            this.hasButton && this.$buttonNode.hide();
	            this._isRunning = false;
	            Xut.Application.Allowliding(); //全局滑动
	            this.hammer.get('pan').set({ enable: false });
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.hammer.destroy();
	            //关闭按钮
	            this.$buttonNode && this.$buttonNode.off();
	        }
	    }]);
	    return PinchPan;
	}();

	/**
	 * 2017.9.7
	 * 流式排版
	 */

	var Flow = function () {
	    function Flow() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            pageIndex = _ref.pageIndex,
	            $pinchNode = _ref.$pinchNode,
	            seasonId = _ref.seasonId,
	            chapterId = _ref.chapterId,
	            successCallback = _ref.successCallback;

	        classCallCheck(this, Flow);


	        var self = this;
	        var dataNode = $('#chapter-flow-' + chapterId);
	        this.initIndex = pageIndex;
	        this.$pinchNode = $pinchNode;
	        render({
	            $pinchNode: $pinchNode,
	            dataNode: dataNode,
	            chapterId: chapterId,
	            callback: function callback($container) {
	                self._init($container, seasonId, chapterId);
	                successCallback();
	            }
	        });
	    }

	    createClass(Flow, [{
	        key: '_setImage',
	        value: function _setImage(node, img, width, height, src) {
	            var _this = this;

	            //是竖版图片
	            var isVerticalFigure = width < height;
	            var screenWidth = config.screenSize.width;
	            var screenHeight = config.screenSize.height;

	            var prop = void 0;
	            var top = 0;
	            var left = 0;

	            //宽度100%适应宽度
	            var widthFullAdaptiveHeight = function widthFullAdaptiveHeight() {
	                prop = screenWidth / width;
	                width = screenWidth;
	                height = height * prop;
	                top = (screenHeight - height) / 2;
	            };

	            //高度100% 自适应宽度
	            var heightFullAdaptiveWidth = function heightFullAdaptiveWidth() {
	                prop = screenHeight / height;
	                height = screenHeight;
	                width = width * prop;
	                left = (screenWidth - width) / 2;
	            };

	            //竖图
	            if (isVerticalFigure) {
	                //竖屏显示
	                if (config.screenVertical) {
	                    widthFullAdaptiveHeight();
	                }
	                //横版显示
	                else {
	                        heightFullAdaptiveWidth();
	                    }
	            }
	            //横图
	            else {
	                    widthFullAdaptiveHeight();
	                }

	            var pageImageHTML = '<div class="page-pinch-image">\n                    <div style="width:' + width + 'px;\n                                height:' + height + 'px;\n                                top:' + top + 'px;\n                                left:' + left + 'px;\n                                background-image:url(' + src + ');">\n                    </div>\n             </div>';

	            var $pageImage = $(String.styleFormat(pageImageHTML));
	            this.$pinchNode.after($pageImage);

	            this.swipe.bansliding(); //flow滑动
	            Xut.Application.Bansliding(); //全局滑动
	            Xut.View.HideToolBar('pageNumber'); //工具栏

	            //缩放
	            var slide = void 0;

	            //销毁
	            var destory = function destory() {
	                img = null;
	                slide && slide.destroy();
	                $pageImage.remove();
	                node.style.visibility = '';
	                _this._destroyZoomImage = null;
	                _this.swipe.allowliding();
	                Xut.Application.Allowliding();
	                Xut.View.ShowToolBar('pageNumber');
	            };

	            if (Xut.plat.hasTouch && config.saleMode) {
	                slide = new PinchPan({
	                    hasButton: false,
	                    $pagePinch: $pageImage.children(),
	                    doubletap: destory
	                });
	            }

	            //按钮
	            var $buttonNode = pinchButton(function () {
	                return destory();
	            });

	            node.style.visibility = 'hidden';
	            $pageImage.append($buttonNode);
	        }

	        /**
	         * 缩放图片
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_zoomImage',
	        value: function _zoomImage(node) {
	            var _this2 = this;

	            //图片地址
	            var src = Xut.config.pathAddress + node.src.match(/\w+.(jpg|png)/gi);
	            var img = new Image();
	            img.src = src;
	            img.onload = function () {
	                //防止图片为加载完毕
	                _this2._setImage(node, img, img.width, img.height, src);
	            };
	            img.onerror = function () {
	                //失败
	                img = null;
	            };
	        }

	        /**
	         * 初始化
	         * @param  {[type]} $container [description]
	         * @param  {[type]} $content   [description]
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_init',
	        value: function _init($container, seasonId, chapterId) {
	            var _this3 = this;

	            var pagesCount = getFlowCount(seasonId, chapterId);
	            var flowView = getFlowView();

	            var MIN = 0;
	            var MAX = pagesCount - 1;
	            var flipWidth = flowView.viewWidth;
	            var flipLeft = flowView.viewLeft;
	            var viewLeft = config.viewSize.left;
	            var View = Xut.View;
	            var initIndex = this.initIndex;
	            var container = $container[0];

	            /**
	             * 分栏整体控制
	             * @type {[type]}
	             */
	            var swipe = this.swipe = new Swipe({
	                flipWidth: flipWidth,
	                borderBounce: true,
	                linear: true,
	                initIndex: Xut.Presentation.GetPageIndex() > initIndex ? MAX : MIN,
	                container: container,
	                flipMode: 0,
	                multiplePages: 1,
	                stopPropagation: true,
	                pagetotal: pagesCount
	            });

	            var moveDistance = 0;
	            var lastDistance = swipe.getInitDistance();

	            swipe.$watch('onTap', function (pageIndex, hookCallback, ev) {
	                //图片缩放
	                var node = ev.target;
	                if (node && node.nodeName.toLowerCase() === "img") {
	                    _this3._zoomImage(node);
	                }
	                if (!Xut.Contents.Canvas.getIsTap()) {
	                    View.Toolbar();
	                }
	            });

	            swipe.$watch('onMove', function () {
	                var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	                    action = _ref2.action,
	                    speed = _ref2.speed,
	                    distance = _ref2.distance,
	                    leftIndex = _ref2.leftIndex,
	                    pageIndex = _ref2.pageIndex,
	                    rightIndex = _ref2.rightIndex,
	                    direction = _ref2.direction;

	                /**
	                 * 首页边界
	                 * @param  {[type]} this._hindex [description]
	                 * @return {[type]}              [description]
	                 */
	                if (this._hindex === MIN && this.direction === 'prev') {
	                    if (action === 'flipOver') {
	                        View.GotoPrevSlide();
	                        this.simulationComplete();
	                    } else {
	                        if (config.viewSize.overflowWidth) {
	                            //内部页面边间翻页
	                            //要除去被溢出的值
	                            distance -= viewLeft;
	                        }
	                        //前边界前移反弹
	                        View.MovePage(distance, speed, this.direction, action);
	                    }
	                }
	                /**
	                 * 尾页边界
	                 * @param  {[type]} this._hindex [description]
	                 * @return {[type]}              [description]
	                 */
	                else if (this._hindex === MAX && this.direction === 'next') {
	                        if (action === 'flipOver') {
	                            View.GotoNextSlide();
	                            this.simulationComplete();
	                        } else {
	                            //内部页面边间翻页
	                            //要除去被溢出的值
	                            if (config.viewSize.overflowWidth) {
	                                distance -= viewLeft;
	                            }
	                            //后边界前移反弹
	                            View.MovePage(distance, speed, this.direction, action);
	                        }
	                    }
	                    /**
	                     * 中间页面
	                     */
	                    else {

	                            /**
	                             * 修正内部翻页的翻页算法
	                             * @type {Object}
	                             */
	                            var hooks = void 0;
	                            if (config.viewSize.overflowWidth) {
	                                hooks = {
	                                    flipOver: {
	                                        left: function left(data) {
	                                            data.middle = flipWidth;
	                                        },
	                                        right: function right(data) {
	                                            data.middle = -flipWidth;
	                                        }
	                                    }
	                                };
	                            }

	                            var viewBeHideDistance = getFlipDistance({
	                                action: action,
	                                distance: distance,
	                                direction: direction
	                            }, hooks)[1];

	                            moveDistance = viewBeHideDistance;

	                            switch (direction) {
	                                case 'next':
	                                    moveDistance = moveDistance + lastDistance;
	                                    break;
	                                case 'prev':
	                                    moveDistance = moveDistance + lastDistance;
	                                    break;
	                            }

	                            //反弹
	                            if (action === 'flipRebound') {
	                                moveDistance = direction === 'next' ? -flipWidth * this._hindex - this._hindex : -(flipWidth * this._hindex + this._hindex);
	                            }

	                            //更新页码
	                            if (action === 'flipOver') {
	                                Xut.View.PageUpdate({
	                                    parentIndex: initIndex,
	                                    sonIndex: swipe.getHindex() + 1,
	                                    hasSon: true,
	                                    direction: direction
	                                });
	                            }

	                            translation[action](container, moveDistance, speed);
	                        }
	            });

	            swipe.$watch('onComplete', function (direction, pagePointer, unfliplock, isQuickTurn) {
	                lastDistance = moveDistance;
	                unfliplock();
	            });
	        }

	        /**
	         * 销毁
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.swipe && this.swipe.destroy();
	        }
	    }]);
	    return Flow;
	}();

	/**
	 * 2017.9.7
	 * 流式排版
	 */
	function TaskFlow (base, successCallback) {
	    var chapterData = base.chapterData;
	    //只有页面类型支持flow && chpater页存在flow数据
	    if (base.pageType === "page" && isFlowPage(chapterData.seasonId, base.chapterId)) {
	        base._flows.register(new Flow({
	            pageIndex: base.pageIndex,
	            $pinchNode: base.getContainsNode(),
	            seasonId: base.chapterData.seasonId,
	            chapterId: base.chapterId,
	            successCallback: successCallback
	        }));
	    } else {
	        successCallback();
	    }
	}

	/**
	 * 解析canvas配置
	 * contentMode 分为  0 或者 1
	 * 1 是dom模式
	 * 0 是canvas模式
	 * 以后如果其余的在增加
	 * 针对页面chapter中的parameter写入 contentMode   值为 1
	 * 针对每一个content中的parameter写入 contentMode 值为 1
	 * 如果是canvas模式的时候，同时也是能够存在dom模式是
	 * @return {[type]} [description]
	 */
	var parseMode = function parseMode(pageData, base) {
	    var parameter = pageData.parameter;
	    if (parameter) {
	        try {
	            parameter = JSON.parse(parameter);
	            if (parameter) {
	                if (parameter.contentMode && parameter.contentMode == 1) {
	                    //非强制dom模式
	                    if (!Xut.config.onlyDomMode) {
	                        //启动dom模式
	                        base.canvasRelated.enable = true;
	                    }
	                }
	                //如果是最后一页处理
	                if (parameter.lastPage && base.pageType === 'page') {
	                    //运行应用运行时间
	                    base.runLastPageAction = function () {
	                        var runTime = Number(Xut.config.delayTime);
	                        var timeout = void 0;
	                        if (runTime) {
	                            timeout = setTimeout(function () {
	                                Xut.Application.Notify('complete');
	                            }, runTime * 1000); //转成秒
	                        }
	                        return function () {
	                            //返回停止方法
	                            if (timeout) {
	                                clearTimeout(timeout);
	                                timeout = null;
	                            }
	                        };
	                    };
	                }
	            }
	        } catch (e) {
	            console.log('JSON错误,chpterId为', base.chapterId, parameter);
	        }
	    }
	};

	/**
	 * 分配Container构建任务
	 * 1 同步数据
	 * 2 构建容器
	 * 3 给出构建回调,这里不能中断,翻页必须存在节点
	 * 4 等待之后自动创建或者后台空闲创建之后的任务
	 * @return {[type]} [description]
	 */
	var assignedTasks = {

	    /**
	     * 主容器
	     */
	    'Container': function Container(taskCallback, base) {
	        //同步数据
	        updataCache.call(base, [base.pid], function () {
	            var pageData = base.baseData();
	            //contentMode模式
	            parseMode(pageData, base);
	            TaskContainer(base, pageData, taskCallback);
	        });
	    },


	    /**
	     * 流式排版
	     */
	    'Flow': function Flow(taskCallback, base) {
	        TaskFlow(base, taskCallback);
	    },


	    /**
	     *  分配背景构建任务
	     *    1 构建数据与结构,执行中断检测
	     *    2 绘制结构,执行回调
	     *
	     *  提供2组回调
	     *    1 构建数据结构 suspendCallback
	     *    2 执行innerhtml构建完毕 successCallback
	     */
	    'Background': function Background(taskCallback, base) {

	        if (base.checkInstanceTasks('background')) {
	            return;
	        }

	        var data = base.baseData(base.pid);

	        /**
	         * 构建中断回调
	         */
	        var suspendCallback = function suspendCallback(innerNextTasks, innerSuspendTasks) {
	            base.nextTasks({
	                'taskName': '内部background',
	                'outSuspendTasks': innerSuspendTasks,
	                'outNextTasks': innerNextTasks
	            });
	        };

	        /**
	         * 获取数据成功回调
	         * @return {[type]} [description]
	         */
	        var successCallback = function successCallback() {
	            taskCallback();
	        };

	        base.createRelated.cacheTasks['background'] = new TaskBackground({
	            data: data,
	            $containsNode: base.getContainsNode(),
	            suspendCallback: suspendCallback,
	            successCallback: successCallback
	        });
	    },


	    /**
	     * 分配Components构建任务
	     * @return {[type]} [description]
	     */
	    'Components': function Components(taskCallback, base) {

	        if (base.checkInstanceTasks('components')) {
	            return;
	        }

	        var chapterData = base.chapterData;
	        var baseData = base.baseData();

	        /**
	         * 构建中断回调
	         * @param  {[type]} innerNextTasks    [description]
	         * @param  {[type]} innerSuspendTasks [description]
	         * @return {[type]}                   [description]
	         */
	        var suspendCallback = function suspendCallback(innerNextTasks, innerSuspendTasks) {
	            base.nextTasks({
	                'taskName': '内部widgets',
	                'outSuspendTasks': innerSuspendTasks,
	                'outNextTasks': innerNextTasks
	            });
	        };

	        /**
	         * 获取数据成功回调
	         * @return {[type]} [description]
	         */
	        var successCallback = function successCallback() {
	            taskCallback();
	        };

	        base.createRelated.cacheTasks['components'] = new TaskComponents({
	            '$containsNode': base.getContainsNode(),
	            'nodes': chapterData['nodes'],
	            'pageOffset': chapterData['pageOffset'],
	            'activitys': base.baseActivits(),
	            'chpaterData': baseData,
	            'chapterId': baseData['_id'],
	            'pid': base.pid,
	            'pageType': base.pageType,
	            'virtualOffset': base.virtualOffset
	        }, suspendCallback, successCallback);
	    },


	    /**
	     * 分配contetns构建任务
	     * @return {[type]} [description]
	     */
	    'Contents': function Contents(taskCallback, base) {

	        //通过content数据库为空处理
	        if (Xut.data.preventContent) {
	            return taskCallback();
	        }

	        if (base.checkInstanceTasks('contents')) {
	            return;
	        }

	        var chapterData = base.chapterData;
	        var baseData = base.baseData();
	        var chapterId = baseData['_id'];
	        var activitys = base.baseActivits();

	        /**
	         * 生成钩子
	         */
	        var pageBaseHooks = _.extend({}, {
	            /**
	             * 构建中断回调
	             * @return {[type]}                   [description]
	             */
	            suspend: function suspend(taskName, innerNextTasks, innerSuspendTasks) {
	                //如果是当前页面构建,允许打断一次
	                var interrupt;
	                if (base.isAutoRun && taskName === 'strAfter') {
	                    interrupt = true;
	                }
	                base.nextTasks({
	                    'interrupt': interrupt,
	                    'taskName': '内部contents',
	                    'outSuspendTasks': innerSuspendTasks,
	                    'outNextTasks': innerNextTasks
	                });
	            },


	            /**
	             * 获取数据成功回调
	             * @return {[type]} [description]
	             */
	            success: function success() {
	                taskCallback();
	            }
	        }, base.listenerHooks);

	        base.createRelated.cacheTasks['contents'] = new TaskContents({
	            'canvasRelated': base.canvasRelated,
	            'rootNode': base.rootNode,
	            '$containsNode': base.getContainsNode(),
	            'pageType': base.pageType,
	            'nodes': chapterData['nodes'],
	            'pageOffset': chapterData['pageOffset'],
	            'activitys': activitys,
	            'chpaterData': baseData,
	            'chapterId': chapterId,
	            'pageIndex': base.pageIndex,
	            'pid': base.pid,
	            'pageBaseHooks': pageBaseHooks,
	            'virtualOffset': base.virtualOffset,
	            'getStyle': base.getStyle
	        });
	    }
	};

	var noop$3 = function noop() {};

	function initstate$1(instance) {

	  return {
	    /**
	     * 主线任务等待
	     */
	    tasksHang: null,

	    /**
	     * 创建相关的信息
	     * @type {Object}
	     */
	    tasksTimer: 0,

	    /**
	     * 当前任务是否中断
	     * return
	     *     true  中断
	     *     false 没有中断
	     */
	    isTaskSuspend: false,

	    /**
	     * 是否预创建背景中
	     */
	    preCreateTasks: false,

	    /**
	     * 下一个将要运行的任务标示
	     * 1 主容器任务
	     * 2 背景任务
	     * 3 widget热点任务
	     * 4 content对象任务
	     */
	    nextRunTask: 'container',

	    /**
	     * 缓存构建中断回调
	     * 构建分2步骤
	     * 1 构建数据与结构（执行中断处理）
	     * 2 构建绘制页面
	     * @type {Object}
	     */
	    cacheTasks: function () {
	      var cacheTasks = {};
	      _.each(["Flow", "background", "components", "contents"], function (taskName) {
	        cacheTasks[taskName] = false;
	      });
	      return cacheTasks;
	    }(),

	    /**
	     * 预创建
	     * 构建页面主容器完毕后,此时可以翻页
	     * @return {[type]} [description]
	     */
	    preforkComplete: noop$3,

	    /**
	     * 整个页面都构建完毕通知
	     * @return {[type]} [description]
	     */
	    createTasksComplete: noop$3
	  };
	}

	var transform$3 = Xut.style.transform;
	var transitionDuration$3 = Xut.style.transitionDuration;

	/**
	 * 缩放平移
	 * @param {[type]} node [description]
	 */
	function Pinch($pagePinch, pageIndex) {

	    var relatedMasterObj = Xut.Presentation.GetPageObj('master', pageIndex);
	    var pageMasterNode = void 0;
	    if (relatedMasterObj) {
	        pageMasterNode = relatedMasterObj.getContainsNode()[0];
	    }

	    return new PinchPan({
	        $pagePinch: $pagePinch,
	        update: function update(styleText, speed) {
	            if (pageMasterNode) {
	                pageMasterNode.style[transform$3] = styleText;
	                pageMasterNode.style[transitionDuration$3] = speed + 'ms';
	            }
	        }
	    });
	}

	function initTasks (instance) {

	    /**
	     * 创建相关的信息
	     * @type {Object}
	     */
	    var createRelated = instance.createRelated = initstate$1(instance);

	    /**
	     * 设置下一个标记
	     * 用于标记完成度
	     */
	    var setNextRunTask = function setNextRunTask(taskName) {
	        createRelated.nextRunTask = taskName;
	    };

	    var callContextTasks = function callContextTasks(taskName, fn) {
	        return assignedTasks[taskName](fn, instance);
	    };

	    /**
	     * 任务钩子
	     * @type {Object}
	     */
	    instance.threadtasks = {

	        /**
	         * li容器
	         * @return {[type]} [description]
	         */
	        container: function container() {

	            callContextTasks('Container', function ($pageNode, $pseudoElement) {
	                //////////////
	                //li,li-div //
	                //////////////
	                instance.$pageNode = $pageNode;
	                instance.$pseudoElement = $pseudoElement;

	                /**
	                 * 获取根节点
	                 * 获取包含容器
	                 * @return {[type]} [description]
	                 */
	                var $containsElement = $pageNode.children('.page-pinch');
	                instance.getContainsNode = function () {
	                    return $pseudoElement ? $pseudoElement : $containsElement;
	                };

	                setNextRunTask('background');

	                //构建主容器li完毕,可以提前执行翻页动作
	                createRelated.preforkComplete();

	                //视觉差不管
	                if (instance.isMaster) {
	                    instance.nextTasks({
	                        'taskName': '外部Background',
	                        'outNextTasks': function outNextTasks() {
	                            instance.dispatchTasks();
	                        }
	                    });
	                }
	            });
	        },


	        /**
	         * 背景
	         * @return {[type]} [description]
	         */
	        background: function background() {
	            callContextTasks('Background', function () {
	                createRelated.preCreateTasks = false;
	                setNextRunTask('flow');

	                //针对当前页面的检测
	                if (!createRelated.tasksHang || instance.isMaster) {
	                    instance.nextTasks({
	                        'taskName': '外部widgets',
	                        outNextTasks: function outNextTasks() {
	                            instance.dispatchTasks();
	                        }
	                    });
	                }

	                //如果有挂起任务，则继续执行
	                if (createRelated.tasksHang) {
	                    createRelated.tasksHang();
	                }
	            });
	        },


	        /**
	         * 2016.9.7
	         * 特殊的一个内容
	         * 是否为流式排版
	         * @return {[type]} [description]
	         */
	        flow: function flow() {

	            //创建缩放
	            var createPinch = function createPinch(flow) {
	                if (instance.pageType === 'page' && config.saleMode) {
	                    var $pagePinch = instance.getContainsNode();
	                    if (flow) {
	                        //flow页面不处理
	                        //目前只处理图片
	                        // instance._pinchObj = Pinch( $pagePinch.find('.page-flow-pinch'), $pagePinch)
	                    } else {
	                        instance._pinchObj = new Pinch($pagePinch, instance.pageIndex);
	                    }
	                }
	            };

	            //chapter=>note == 'flow'
	            //因为设计chapter只有一个flow效果，所以直接跳过别的创建
	            if (instance.chapterData.note == 'flow') {
	                callContextTasks('Flow', function () {
	                    createPinch('flow');
	                    setNextRunTask('complete');
	                    createRelated.createTasksComplete();
	                });
	            } else {
	                createPinch();
	                setNextRunTask('components');
	                instance.dispatchTasks();
	            }
	        },


	        /**
	         * 组件
	         * @return {[type]} [description]
	         */
	        components: function components() {
	            //构件零件类型任务
	            callContextTasks('Components', function () {
	                setNextRunTask('contents');
	                instance.nextTasks({
	                    'taskName': '外部contents',
	                    outNextTasks: function outNextTasks() {
	                        instance.dispatchTasks();
	                    }
	                });
	            });
	        },


	        /**
	         * content
	         * @return {[type]} [description]
	         */
	        contents: function contents() {
	            callContextTasks('Contents', function () {
	                setNextRunTask('complete');
	                createRelated.createTasksComplete();
	            });
	        }
	    };
	}

	/**
	 * canvas相关处理
	 * 启动canvas,pixi库
	 * 事件，动画等
	 * 需要收集所有content的执行
	 * 因为canvas只能绘制一次
	 * cnavas模式下 category === "Sprite" 转化cid
	 */

	var Factory = function (_Observer) {
	        inherits(Factory, _Observer);

	        function Factory() {
	                classCallCheck(this, Factory);

	                /**
	                 * 是否启动模式
	                 * @type {Boolean}
	                 */
	                var _this = possibleConstructorReturn(this, (Factory.__proto__ || Object.getPrototypeOf(Factory)).call(this));

	                _this.enable = false;

	                /**
	                 * CompSprite非常特殊
	                 * 可以在dom的情况下使用
	                 * 所以如果是dom模式要强制开始enable‘
	                 * 这样会导致 精灵等动画强制转canvas
	                 * 这是错误的，所以增加一个判断
	                 *
	                 */
	                _this.onlyCompSprite = false;

	                /**
	                 * 加载失败content列表
	                 * @type {Array}
	                 */
	                _this.failCid = [];

	                //所有contentId
	                _this.cid = [];

	                //开启了contentMode的节点
	                //对应的content转化成canvas模式
	                //普通精灵动画
	                //ppt动画=>转化
	                _this.pptId = [];

	                //普通灵精
	                _this.spiritId = [];

	                //widget零件保存的content id
	                //高级精灵动画
	                _this.widgetId = [];

	                //复杂精灵动画
	                _this.compSpriteId = [];

	                //默认canvas容器的层级
	                //取精灵动画最高层级
	                //2016.2.25
	                _this.containerIndex = 1;

	                /**
	                 * cid=>wid
	                 * 对应的pixi对象容器
	                 * @type {Object}
	                 */
	                _this.collections = {};
	                return _this;
	        }

	        return Factory;
	}(Observer);

	function initstate (baseProto) {

	    /**
	     * 初始化多线程任务
	     * @return {[type]} [description]
	     */
	    baseProto.initState = function (options) {

	        var instance = this;

	        _.extend(instance, options);

	        /**
	         * 数据缓存容器
	         * @type {Object}
	         */
	        this._dataCache = {};
	        this.scenarioId = this.chapterData.seasonId;
	        this.chapterId = this.chapterData._id;

	        /**
	         * 是否开启多线程,默认开启
	         * 如果是非线性，则关闭多线程创建
	         * 启动 true
	         * 关闭 false
	         * @type {[type]}
	         */
	        this.isMultithread = this.multiplePages ? true : false;

	        //母版处理
	        if (instance.pageType === 'master') {
	            this.isMaster = true;
	        }

	        //canvas模式
	        this.canvasRelated = new Factory();

	        /**
	         * 内部钩子相关
	         * 监听状态的钩子
	         * 注册所有content对象管理
	         * 收集所有content对象
	         * 构建li主结构后,即可翻页
	         * 构建所有对象完毕后处理
	         */

	        /**
	         * 抽象activtiys合集,用于关联各自的content
	         * 划分各自的子作用域
	         * 1对多的关系
	         * @type {Collection}
	         */
	        this._abActivitys = new Collection();

	        /**
	         * widget热点处理类
	         * 只存在当前页面
	         * 1 iframe零件
	         * 2 页面零件
	         * @type {Collection}
	         */
	        this._components = new Collection();

	        /**
	         * 缓存所有的content对象引用
	         * 1对1的关系
	         * @type {Object}
	         */
	        this._contentsCollector = {};

	        /**
	         * 2016.9.7
	         * flow热点对象
	         * @type {Collection}
	         */
	        this._flows = new Collection();

	        /**
	         * 流式布局页面
	         * 排除母版
	         * @param  {[type]} instance.pageType [description]
	         * @return {[type]}                   [description]
	         */
	        if (this.pageType === 'master' && this.isFlows) {
	            this.isFlows = false;
	        }

	        /**
	         * 浮动对象
	         * 1 母版中
	         * 2 页面中
	         * 页面中是最高的
	         * @type {Object}
	         */
	        var floatContents = this.floatContents = {

	            /**
	             * 页面浮动对象容器
	             * @type {[type]}
	             */
	            PageContainer: null,

	            /**
	             * 浮动页面对象
	             * @type {Object}
	             */
	            Page: {},

	            /**
	             * 浮动母版容器
	             */
	            MasterContainer: null,

	            /**
	             * 浮动母版的content对象
	             * 用于边界切换,自动加上移动
	             * @type {Object}
	             *     1：Object {}      //空对象,零件
	             *     2: PPTeffect  {}  //行为对象
	             */
	            Master: {}
	        };

	        /**
	         * 对象的处理情况的内部钩子方法
	         * @type {Object}
	         */
	        this.listenerHooks = {

	            /**
	             * 注册抽象Activity类content(大类,总content对象)
	             * @param  {[type]} contentsObjs [description]
	             * @return {[type]}              [description]
	             */
	            registerAbstractActivity: function registerAbstractActivity(contentsObjs) {
	                instance._abActivitys.register(contentsObjs);
	            },


	            /**
	             * 收集器
	             * @type {Object}
	             */
	            collector: {
	                //搜集所有的content(每一个content对象)
	                //因为content多页面共享的,所以content的合集需要保存在pageMgr中（特殊处理）
	                contents: function contents(pid, id, contentScope) {
	                    var scope = instance.baseGetContentObject[id];
	                    //特殊处理,如果注册了事件ID,上面还有动画,需要覆盖
	                    if (scope && scope.isBindEventHooks) {
	                        instance._contentsCollector[id] = contentScope;
	                    }
	                    if (!scope) {
	                        instance._contentsCollector[id] = contentScope;
	                    }
	                },


	                //2014.11.7
	                //新概念，浮动页面对象
	                //用于是最顶层的，比母版浮动对象还要高
	                //所以这个浮动对象需要跟随页面动
	                floatPages: function floatPages(data) {
	                    //浮动页面对象容器
	                    var contentObj = void 0;
	                    floatContents.PageContainer = data.container;
	                    _.each(data.ids, function (id) {
	                        if (contentObj = instance.baseGetContentObject(id)) {
	                            //初始视察坐标
	                            if (contentObj.parallax) {
	                                contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
	                            }
	                            floatContents.Page[id] = contentObj;
	                        } else {
	                            console.log('页面浮动对象找不到');
	                        }
	                    });
	                },


	                //浮动母版对象
	                //1 浮动的对象是有动画数据或者视觉差数据
	                //2 浮动的对象是用于零件类型,这边只提供创建
	                //  所以需要制造一个空的容器，用于母版交界动
	                floatMaters: function floatMaters(data) {
	                    var prefix = void 0;
	                    var contentObj = void 0;
	                    var contentNode = void 0;
	                    var contentsFragment = void 0;

	                    //浮动容器
	                    floatContents.MasterContainer = data.container;
	                    //浮动对象
	                    _.each(data.ids, function (id) {
	                        //转化成实际操作的浮动对象,保存
	                        if (contentObj = instance.baseGetContentObject(id)) {
	                            //初始视察坐标
	                            if (contentObj.parallax) {
	                                contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
	                            }
	                            floatContents.Master[id] = contentObj;
	                        } else {
	                            Xut.plat.isBrowser && console.log('浮动母版对象数据不存在原始对象,制作伪对象母版移动', id);
	                            //获取DOM节点
	                            if (contentsFragment = instance.createRelated.cacheTasks.contents.contentsFragment) {
	                                prefix = 'Content_' + instance.pid + "_";
	                                _.each(contentsFragment, function (dom) {
	                                    var makePrefix = prefix + id;
	                                    if (dom.id == makePrefix) {
	                                        contentNode = dom;
	                                    }
	                                });
	                            }
	                            //制作一个伪数据
	                            //作为零件类型的空content处理
	                            floatContents.Master[id] = {
	                                id: id,
	                                pid: instance.pid,
	                                $contentNode: $(contentNode),
	                                'empty': true //空类型
	                            };
	                        }
	                    });
	                }
	            },

	            /**
	             * 多事件钩子
	             * 执行多事件绑定
	             * @param  {[type]} eventRelated [description]
	             * @return {[type]}              [description]
	             */
	            eventBinding: function eventBinding(eventRelated) {
	                create(instance, eventRelated);
	            }
	        };

	        /**
	         * 初始化任务
	         * 等待状态初始化，比如_isFlows
	         */
	        initTasks(instance);
	    };
	}

	/**
	 *  对外接口
	 *  1 开始调用任务
	 *  2 调用自动运行任务
	 *  3 设置中断
	 *  4 取消中断设置
	 */

	function threadExternal (baseProto) {

	    /**
	     * 开始调用任务
	     * dispatch=>index=>create=>startThreadTask
	     * @return {[type]} [description]
	     */
	    baseProto.startThreadTask = function (flipOver, callback) {
	        var _this = this;

	        //制作回调
	        //如果是快速翻页,立刻调用
	        //构建container调用preforkComplete
	        this.createRelated.preforkComplete = function () {
	            return function () {
	                //1 滑动允许打断创建
	                //
	                //swich
	                //2 所有继续分解任务
	                flipOver ? callback() : _this._checkTasksCreate(callback, _this);
	            };
	        }();

	        //继续构建任务
	        this.dispatchTasks();
	    };

	    /**
	     * 任务调度
	     * @return {[type]} [description]
	     */
	    baseProto.dispatchTasks = function () {
	        var threadtasks = void 0;
	        if (threadtasks = this.threadtasks[this.createRelated.nextRunTask]) {
	            threadtasks();
	        }
	    };

	    /**
	     * 处理最后一页动作
	     * [destroyPageAction description]
	     * @return {[type]} [description]
	     */
	    baseProto.destroyPageAction = function () {
	        if (this.stopLastPageAction) {
	            this.stopLastPageAction();
	            this.stopLastPageAction = null;
	        }
	    };

	    /**
	     * 创建最后一次页面动作
	     * @return {[type]} [description]
	     */
	    baseProto.createPageAction = function () {
	        //如果有最后一个动作触发
	        //2016.10.13 给妙妙学增加watch('complete')
	        if (this.runLastPageAction) {
	            //返回停止方法
	            this.stopLastPageAction = this.runLastPageAction();
	        }
	    };

	    /**
	     * 检测任务是否完成
	     * page => autoRun中需要保证任务完成后才能执行
	     * 快速翻页中遇到
	     * actTasksCallback 活动任务完成
	     * @return {[type]} [description]
	     */
	    baseProto.checkThreadTask = function (actTasksCallback) {
	        var _this2 = this;

	        this.isAutoRun = true;
	        this._checkTasksCreate(function () {
	            _this2.isAutoRun = false;
	            actTasksCallback();
	        });
	    };

	    /**
	     * 开始执行下一个线程任务,检测是否中断
	     * outSuspendTasks,
	     * outNextTasks
	     * taskName
	     * @return {[type]} [description]
	     */
	    baseProto.nextTasks = function (callback) {
	        this._asyTasks({
	            suspendCallback: function suspendCallback() {
	                callback.outSuspendTasks && callback.outSuspendTasks();
	            },
	            nextTaskCallback: function nextTaskCallback() {
	                callback.outNextTasks && callback.outNextTasks();
	            }
	        }, callback.interrupt);
	    };

	    /**
	     * 设置任务中断
	     */
	    baseProto.setTaskSuspend = function () {
	        this.isAutoRun = false;
	        this.canvasRelated.isTaskSuspend = true;
	        this.createRelated.preCreateTasks = false;
	        this.createRelated.tasksHang = null;
	    };

	    /**
	     * 后台预创建任务
	     * @param  {[type]} tasksTimer [时间间隔]
	     * @return {[type]}            [description]
	     */
	    baseProto.createPreforkTasks = function (callback, isPreCreate) {
	        var self = this;
	        //2个预创建间隔太短
	        //背景预创建还在进行中，先挂起来等待
	        if (this.createRelated.preCreateTasks) {
	            this.createRelated.tasksHang = function (callback) {
	                return function () {
	                    self._checkTasksCreate(callback);
	                };
	            }(callback);
	            return;
	        }

	        /**
	         * 翻页完毕后
	         * 预创建背景
	         */
	        if (isPreCreate) {
	            this.createRelated.preCreateTasks = true;
	        }

	        this._checkTasksCreate(callback);
	    };

	    /**
	     * 自动运行：检测是否需要开始创建任务
	     * 1 如果任务全部完成了毕
	     * 2 如果有中断任务,就需要继续创建未完成的任务
	     * 3 如果任务未中断,还在继续创建
	     * currtask 是否为当前任务，加速创建
	     */
	    baseProto._checkTasksCreate = function (callback, context) {

	        //如果任务全部完成
	        if (this.createRelated.nextRunTask === 'complete') {
	            return callback.call(context);
	        }

	        var self = this;

	        //开始构未完成的任务
	        this._cancelTaskSuspend();

	        //完毕回调
	        this.createRelated.createTasksComplete = function () {
	            callback.call(context);
	        };

	        //派发任务
	        this.nextTasks({
	            outNextTasks: function outNextTasks() {
	                self.dispatchTasks();
	            }
	        });
	    };

	    /**
	     * 取消任务中断
	     * @return {[type]} [description]
	     */
	    baseProto._cancelTaskSuspend = function () {
	        this.canvasRelated.isTaskSuspend = false;
	    };

	    /**
	     * 检测任务是否需要中断
	     * @return {[type]} [description]
	     */
	    baseProto._checkTaskSuspend = function () {
	        return this.canvasRelated.isTaskSuspend;
	    };

	    /**
	     * 多线程检测
	     * @return {[type]} [description]
	     */
	    baseProto._multithreadCheck = function (callbacks, interrupt) {
	        var _this3 = this;

	        var check = function check() {
	            if (_this3._checkTaskSuspend()) {
	                _this3.tasksTimeOutId && clearTimeout(_this3.tasksTimeOutId);
	                callbacks.suspendCallback.call(_this3);
	            } else {
	                callbacks.nextTaskCallback.call(_this3);
	            }
	        };

	        var next = function next() {
	            _this3.tasksTimeOutId = setTimeout(function () {
	                check();
	            }, _this3.canvasRelated.tasksTimer);
	        };

	        //自动运行页面构建
	        if (this.isAutoRun) {
	            //自动运行content中断检测 打断一次
	            if (interrupt) {
	                next();
	            } else {
	                check();
	            }
	        } else {
	            //后台构建
	            next();
	        }
	    };

	    /**
	     * 任务队列挂起
	     * nextTaskCallback 成功回调
	     * suspendCallback  中断回调
	     * @return {[type]} [description]
	     */
	    baseProto._asyTasks = function (callbacks, interrupt) {

	        //如果关闭多线程,不检测任务调度
	        if (!this.isMultithread) {
	            return callbacks.nextTaskCallback.call(this);
	        }

	        //多线程检测
	        this._multithreadCheck(callbacks, interrupt);
	    };
	}

	/**
	 * 构建模块任务对象
	 * taskCallback 每个模块任务完毕后的回调
	 * 用于继续往下个任务构建
	 */
	function dataExternal (baseProto) {

	    /**
	     * 对象实例内部构建
	     * @return {[type]} [description]
	     */
	    baseProto.checkInstanceTasks = function (taskName) {
	        var tasksObj;
	        if (tasksObj = this.createRelated.cacheTasks[taskName]) {
	            tasksObj.runSuspendTasks();
	            return true;
	        }
	    };

	    /**
	     * 获取页面数据
	     * @return {[type]} [description]
	     */
	    baseProto.baseData = function () {
	        return this._dataCache[this.pageType];
	    };

	    /**
	     * 获取热点数据信息
	     * @return {[type]} [description]
	     */
	    baseProto.baseActivits = function () {
	        return this._dataCache['activitys'];
	    };

	    /**
	     * 获取自动运行数据
	     * @return {[type]} [description]
	     */
	    baseProto.baseAutoRun = function () {
	        var data = this._dataCache['auto'];
	        return data && data;
	    };

	    /**
	     * 获取chapterid
	     * @param  {[type]} pid [description]
	     * @return {[type]}     [description]
	     */
	    baseProto.baseGetPageId = function (pid) {
	        return this.baseData(pid)['_id'];
	    };

	    /**
	     * 找到对象的content对象
	     * @param  {[type]}   contentId [description]
	     * @param  {Function} callback  [description]
	     * @return {[type]}             [description]
	     */
	    baseProto.baseGetContentObject = function (contentId) {
	        var contentsObj;
	        if (contentsObj = this._contentsCollector[contentId]) {
	            return contentsObj;
	        } else {
	            //查找浮动母版
	            return this.floatContents.Master[contentId];
	        }
	    };

	    /**
	     * Xut.Content.show/hide 针对互斥效果增加接口
	     * 扩充，显示，隐藏，动画控制接口
	     * @param  {[type]} name [description]
	     * @return {[type]}      [description]
	     */
	    baseProto.baseContentMutex = function (contentId, type) {
	        var contentObj = void 0;
	        if (contentObj = this.baseGetContentObject(contentId)) {
	            (function () {
	                var $contentElement = contentObj.$contentNode.view ? contentObj.$contentNode.view : contentObj.$contentNode;

	                var handle = {
	                    'Show': function Show() {
	                        if (contentObj.type === 'dom') {
	                            $contentElement.css({
	                                'display': 'blcok',
	                                'visibility': 'visible'
	                            }).prop("mutex", false);
	                        } else {
	                            $contentElement.visible = true;
	                        }
	                    },
	                    'Hide': function Hide() {
	                        if (contentObj.type === 'dom') {
	                            $contentElement.css({
	                                'display': 'none',
	                                'visibility': 'hidden'
	                            }).prop("mutex", true);
	                        } else {
	                            $contentElement.visible = false;
	                        }
	                    },
	                    'StopAnim': function StopAnim() {
	                        contentObj.stopAnims && contentObj.stopAnims();
	                    }
	                };
	                handle[type]();
	            })();
	        }
	    };

	    //content接口
	    _.each(["Get", "Specified"], function (type) {
	        baseProto['base' + type + 'Content'] = function (data) {
	            switch (type) {
	                case 'Get':
	                    return this._abActivitys.get();
	                case 'Specified':
	                    return this._abActivitys.specified(data);
	            }
	        };
	    });

	    //components零件类型处理
	    //baseGetComponent
	    //baseRemoveComponent
	    //baseRegisterComponent
	    //baseSpecifiedComponent
	    _.each(["Get", "Remove", "Register", "Specified"], function (type) {
	        baseProto['base' + type + 'Component'] = function (data) {
	            switch (type) {
	                case 'Register':
	                    return this._components.register(data);
	                case 'Get':
	                    return this._components.get();
	                case 'Specified':
	                    return this._components.specified(data);
	                case 'Remove':
	                    return this._components.remove();
	            }
	        };
	    });

	    /**
	     *  运行辅助对象事件
	     * @param  {[type]} activityId  [description]
	     * @param  {[type]} outCallBack [description]
	     * @param  {[type]} actionName  [description]
	     * @return {[type]}             [description]
	     */
	    baseProto.baseAssistRun = function (activityId, outCallBack, actionName) {
	        var activity;
	        if (activity = this._abActivitys) {
	            _.each(activity.get(), function (contentObj, index) {
	                if (activityId == contentObj.activityId) {
	                    if (actionName == 'Run') {
	                        contentObj.runAnimation(outCallBack, true);
	                    }
	                    if (actionName == 'Stop') {
	                        contentObj.stopAnimation(outCallBack);
	                    }
	                }
	            }, this);
	        }
	    };
	}

	function destroy (baseProto) {

	    /**
	     * 销毁页面对象
	     * @return {[type]} [description]
	     */
	    baseProto.baseDestroy = function () {

	        // //清理图片缓存
	        // //读库快速退出模式下报错修正
	        // try {
	        //     this.$pageNode.hide().find('img').each(function(aaa, img) {
	        //         img.src = 'images/icons/clearmem.png'
	        //     })
	        // } catch (e) {
	        //     console.log('销毁图片出错')
	        // }

	        //最后一页动作处理
	        //for miaomiaoxue
	        this.destroyPageAction();

	        //2016/9/30
	        //for flow
	        //销毁缩放动作
	        if (this._pinchObj) {
	            this._pinchObj.destroy();
	        }

	        //流式布局对象
	        //2016.9.10
	        var _flows = this._flows.get();
	        if (_flows.length) {
	            _flows.forEach(function (flowObj) {
	                flowObj.destroy();
	                flowObj = null;
	            });
	            this._flows = null;
	        }

	        //清理线程任务块
	        var cacheTasks = void 0,
	            key = void 0,
	            tasks = void 0;
	        if (cacheTasks = this.createRelated.cacheTasks) {
	            for (key in cacheTasks) {
	                if (tasks = cacheTasks[key]) {
	                    tasks.clearReference();
	                }
	            }
	        }

	        //浮动对象
	        var floatMaterContents = this.floatContents.Master;

	        //是否有浮动对象
	        var hasFloatMater = !_.isEmpty(floatMaterContents);

	        //清理content类型对象
	        var contents = void 0;
	        if (contents = this._abActivitys.get()) {
	            contents.forEach(function (contentObj) {
	                contentObj.destroy(function (destroyObj) {
	                    //如果不是浮动对象,清理元素引用
	                    if (!hasFloatMater || destroyObj && !floatMaterContents[destroyObj.id]) {
	                        destroyObj.$contentNode = null;
	                    }
	                });
	            });
	        }

	        //清除母版浮动容器
	        if (hasFloatMater && this.floatContents.MasterContainer) {
	            this.floatContents.MasterContainer.remove();
	        }

	        //清除浮动页面对象
	        if (this.floatContents.Page && this.floatContents.PageContainer) {
	            this.floatContents.PageContainer.remove();
	        }

	        //清理零件类型对象
	        var _components = void 0;
	        if (_components = this.baseGetComponent()) {
	            _components.length && _components.forEach(function (componentObj) {
	                componentObj.destroy && componentObj.destroy();
	            });
	        }

	        //多事件销毁
	        _destroy(this);

	        //伪li节点
	        if (this.$pseudoElement) {
	            this.$pseudoElement = null;
	        }

	        //移除li容器节点节点
	        this.$pageNode.remove();
	        this.rootNode = null;
	        this.$pageNode = null;
	    };
	}

	var transitionDuration$4 = Xut.style.transitionDuration;
	var transform$4 = Xut.style.transform;
	var setTranslateZ$1 = Xut.style.setTranslateZ;

	var hasValue$2 = function hasValue(value) {
	    return value != undefined;
	};

	/**
	 * transform转化成相对应的偏移量
	 */
	function _transformConversion(property, distance, nodes) {
	    var temp = {},
	        i;

	    for (i in property) {
	        switch (i) {
	            case 'translateX':
	            case 'translateZ':
	                temp[i] = distance * nodes * property[i];
	                break;
	            case 'translateY':
	                temp[i] = distance * (config.viewSize.height / config.viewSize.width) * nodes * property[i];
	                break;
	            case 'opacityStart':
	                temp[i] = property.opacityStart;
	                break;
	            default:
	                //乘以-1是为了向右翻页时取值为正,位移不需这样做
	                temp[i] = -1 * distance / config.viewSize.width * property[i] * nodes;
	        }
	    }
	    return temp;
	}

	/**
	 * 移动叠加值
	 * @param  {[type]} property       [description]
	 * @param  {[type]} repairProperty [description]
	 * @return {[type]}                [description]
	 */
	function _flipMove(property, repairProperty) {
	    var temp = {};
	    var start = property.opacityStart;
	    for (var i in property) {
	        temp[i] = property[i] + repairProperty[i];
	    }
	    if (start > -1) temp.opacityStart = start;
	    return temp;
	}

	/**
	 * 翻页结束
	 * @param  {[type]} property       [description]
	 * @param  {[type]} repairProperty [description]
	 * @return {[type]}                [description]
	 */
	function _flipOver(property, repairProperty) {
	    return _flipMove(property, repairProperty);
	}

	/**
	 * 反弹
	 * @param  {[type]} property       [description]
	 * @param  {[type]} repairProperty [description]
	 * @return {[type]}                [description]
	 */
	function _flipRebound(property, repairProperty) {
	    var temp = {};
	    for (var i in property) {
	        temp[i] = repairProperty[i] || property[i];
	    }
	    return temp;
	}

	/**
	 * 结束后缓存上一个记录
	 * @param  {[type]} property       [description]
	 * @param  {[type]} repairProperty [description]
	 * @return {[type]}                [description]
	 */
	function _overMemory(property, repairProperty) {
	    for (var i in property) {
	        repairProperty[i] = property[i];
	    }
	}

	/**
	 * 变化节点的css3transform属性
	 * @param  {[type]} $containsNode     [description]
	 * @param  {[type]} speed        [description]
	 * @param  {[type]} property     [description]
	 * @param  {[type]} opacityStart [description]
	 * @return {[type]}              [description]
	 */
	function _transformNodes($contentNode, speed, property, opacityStart) {
	    var style = {},
	        effect = '',
	        x = 0,
	        y = 0,
	        z = 0,
	        round = Math.round;

	    if (hasValue$2(property.translateX) || hasValue$2(property.translateY) || hasValue$2(property.translateZ)) {
	        x = round(property.translateX) || 0;
	        y = round(property.translateY) || 0;
	        z = round(property.translateZ) || 0;
	        var translateZ = setTranslateZ$1(z);
	        effect += 'translate(' + x + 'px,' + y + 'px) ' + translateZ;
	    }

	    if (hasValue$2(property.rotateX) || hasValue$2(property.rotateY) || hasValue$2(property.rotateZ)) {
	        x = round(property.rotateX);
	        y = round(property.rotateY);
	        z = round(property.rotateZ);
	        effect += x ? 'rotateX(' + x + 'deg) ' : '';
	        effect += y ? 'rotateY(' + y + 'deg) ' : '';
	        effect += z ? 'rotateZ(' + z + 'deg) ' : '';
	    }

	    if (hasValue$2(property.scaleX) || hasValue$2(property.scaleY) || hasValue$2(property.scaleZ)) {
	        x = round(property.scaleX * 100) / 100 || 1;
	        y = round(property.scaleY * 100) / 100 || 1;
	        z = round(property.scaleZ * 100) / 100 || 1;
	        effect += String.format('scale3d({0},{1},{2}) ', x, y, z);
	    }

	    if (property.opacity != undefined) {
	        style.opacity = round(property.opacity * 100) / 100 + opacityStart;
	        effect += ';';
	    }

	    ////////////////
	    //最终改变视觉对象的坐标 //
	    ////////////////
	    if (effect) {
	        style[transitionDuration$4] = speed + 'ms';
	        style[transform$4] = effect;
	        $contentNode.css(style);
	    }
	}

	/**
	 * 移动视觉差对象
	 */
	var _translate = function _translate($contentNode, scope, direction, action, speed, nodes, distance) {

	    var translate = scope.translate;
	    var offsetTranslate = scope.offsetTranslate;
	    var nodes_1 = void 0;

	    //往前翻页
	    if (direction === 'prev') {
	        //分割的比例
	        nodes_1 = scope.nodeProportion;
	        //如果往前溢出则取0
	        nodes = nodes == nodes_1 ? 0 : nodes_1;
	    }

	    //视觉对象移动的距离
	    var moveTranslate = _transformConversion(translate, distance, nodes);

	    switch (action) {
	        //移动中
	        case 'flipMove':
	            moveTranslate = _flipMove(moveTranslate, offsetTranslate);
	            break;
	        //反弹
	        case 'flipRebound':
	            moveTranslate = _flipRebound(moveTranslate, offsetTranslate);
	            break;
	        //翻页结束,记录上一页的坐标
	        case 'flipOver':
	            if (direction === 'prev') {
	                moveTranslate = _flipOver(moveTranslate, offsetTranslate);
	            }
	            _overMemory(moveTranslate, offsetTranslate);
	            break;
	    }

	    //直接操作元素
	    _transformNodes($contentNode, speed, moveTranslate, offsetTranslate.opacityStart || 0);
	};

	/**
	 * 滑动
	 * @param  {[type]} baseProto [description]
	 * @return {[type]}           [description]
	 */
	function translation$1 (baseProto) {

	    /**
	     * 页面移动
	     * @return {[type]} [description]
	     */
	    baseProto.toMove = function (action, distance, speed, viewOffset) {

	        var pageNode = this.$pageNode[0];

	        //浮动页面
	        if (this.pageType === 'page') {
	            //移动浮动页面容器
	            var $floatElement = this.floatContents.PageContainer;
	            if ($floatElement) {
	                translation[action]($floatElement[0], distance, speed);
	            }
	        }

	        //浮动母版
	        if (this.pageType === 'master') {
	            //母版交接判断
	            //用户事件的触发
	            this.onceMaster = false;

	            //移动浮动容器
	            var $masterElement = this.floatContents.MasterContainer;
	            if ($masterElement) {
	                translation[action]($masterElement[0], distance, speed);
	            }
	        }

	        //过滤多个动画回调，
	        //保证指向始终是当前页面
	        //翻页 && 是母版页 && 是当前页面
	        var isVisual = false; // 是可视页面
	        if (action === 'flipOver' && this.pageType === 'page' && distance === viewOffset) {
	            //增加可视页面标记
	            pageNode.setAttribute('data-view', true);
	            isVisual = true;
	        }

	        //当前页面
	        translation[action](pageNode, distance, speed, function () {
	            //修正flipMode切换页面的处理
	            //没有翻页效果
	            //强制给动画结束触发
	            //可视区页面
	            //排除母版的情况
	            if (config.flipMode && isVisual) {
	                //设置动画完成
	                Xut.Application.SetTransitionComplete(pageNode, pageNode.getAttribute('data-view'));
	                return true;
	            }
	        });
	    };

	    /**
	     * 移动视察对象
	     */
	    baseProto.moveParallax = function (action, direction, moveDist, speed, nodes, parallaxProcessedContetns) {

	        var base = this;

	        var baseContents = this.baseGetContent();
	        if (baseContents) {
	            (function () {
	                //移动距离
	                var distance = moveDist[1];
	                //遍历所有活动对象
	                _.each(baseContents, function (content) {
	                    content.eachAssistContents(function (scope) {
	                        //如果是视察对象移动
	                        if (scope.parallax) {
	                            var $contentNode = scope.parallax.$contentNode;
	                            var contentObj = base.baseGetContentObject(scope.id);

	                            /////////////////////
	                            //如果有这个动画效果 //
	                            //先停止否则通过视觉差移动会出问题
	                            // //影响，摩天轮转动APK
	                            // * 重新激动视觉差对象
	                            // * 因为视察滑动对象有动画
	                            // * 2个CSS3动画冲突的
	                            // * 所以在视察滑动的情况下先停止动画
	                            // * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
	                            // * 通过动画回调在重新加载动画
	                            /////////////////////
	                            if (action === "flipMove" && contentObj.anminInstance && !contentObj.parallaxProcessed) {
	                                //标记
	                                var actName = contentObj.actName;
	                                contentObj.stopAnimations();
	                                //视觉差处理一次,停止过动画
	                                contentObj.parallaxProcessed = true;
	                                //增加标记
	                                $contentNode.attr('data-parallaxProcessed', actName);
	                                //记录
	                                parallaxProcessedContetns[actName] = contentObj;
	                            }

	                            //移动视觉差对象
	                            _translate($contentNode, scope.parallax, direction, action, speed, nodes, distance);
	                        }
	                    });
	                });
	            })();
	        }
	    };
	}

	var Pagebase = function Pagebase(options) {
	    classCallCheck(this, Pagebase);

	    this.initState(options);
	};

	var baseProto = Pagebase.prototype;

	initstate(baseProto);
	threadExternal(baseProto);
	dataExternal(baseProto);
	destroy(baseProto);
	translation$1(baseProto);

	/**
	 * 利用canvas绘制出蒙板效果替换，需要蒙板效果的图片先用一个canvas占位，绘制是异步的
	 */

	function _getCanvas(className) {
	    var children = document.getElementsByTagName('canvas'),
	        elements = new Array(),
	        i = 0,
	        child,
	        classNames,
	        j = 0;
	    for (i = 0; i < children.length; i++) {
	        child = children[i];
	        classNames = child.className.split(' ');
	        for (var j = 0; j < classNames.length; j++) {
	            if (classNames[j] == className) {
	                elements.push(child);
	                break;
	            }
	        }
	    }
	    return elements;
	}

	function _addEdge(canvas) {

	    var img = new Image(),
	        maskimg = new Image();

	    var classNames = canvas.className.split(' ');
	    var context = canvas.getContext("2d");
	    img.addEventListener("load", loadimg);
	    maskimg.addEventListener("load", loadmask);

	    function loadimg() {
	        context.clearRect(0, 0, canvas.width, canvas.height);
	        context.globalCompositeOperation = "source-over";
	        context.drawImage(img, 0, 0, canvas.width, canvas.height);
	        maskimg.src = canvas.getAttribute("mask");
	        img.removeEventListener("load", loadimg);
	        img.src = null;
	        img = null;
	    }

	    function loadmask() {
	        context.globalCompositeOperation = "destination-atop";
	        context.drawImage(maskimg, 0, 0, canvas.width, canvas.height);
	        canvas.style.opacity = 1;
	        maskimg.removeEventListener("load", loadmask);
	        maskimg.src = null;
	        maskimg = null;
	        context = null;
	        classNames = null;
	        canvas.className = canvas.className.replace("edges", "");
	    }
	    img.src = canvas.getAttribute("src");
	}

	function addEdges() {
	    var thecanvas = _getCanvas('edges'),
	        i;
	    for (i = 0; i < thecanvas.length; i++) {
	        _addEdge(thecanvas[i]);
	    }
	}

	/**
	 * 检测脚本注入
	 * @return {[type]} [description]
	 */
	var runScript = function runScript(pageObject, type) {
	    var code = pageObject.chapterData[type];
	    if (code) {
	        execScript(code, type);
	    }
	};

	var PageMgr = function (_Abstract) {
	    inherits(PageMgr, _Abstract);

	    function PageMgr(vm) {
	        classCallCheck(this, PageMgr);

	        var _this = possibleConstructorReturn(this, (PageMgr.__proto__ || Object.getPrototypeOf(PageMgr)).call(this));

	        _this.pageType = 'page';

	        //页面根节点
	        _this.pagesNode = vm.options.rootPage;

	        //创建合集容器
	        _this.abstractCreateCollection();
	        return _this;
	    }

	    /**
	     * 创建页新的页面
	     * @param  {[type]} dataOpts  [description]
	     * @param  {[type]} pageIndex [description]
	     * @return {[type]}           [description]
	     */


	    createClass(PageMgr, [{
	        key: 'create',
	        value: function create(dataOpts, pageIndex) {

	            //生成指定页面对象
	            var pageObjs = new Pagebase(_.extend(dataOpts, {
	                'pageType': this.pageType, //创建页面的类型
	                'rootNode': this.pagesNode //根元素
	            }));

	            //增加页面管理
	            this.abstractAddCollection(pageIndex, pageObjs);

	            return pageObjs;
	        }

	        /**
	         * 移动页面
	         * @return {[type]}
	         */

	    }, {
	        key: 'move',
	        value: function move(_ref) {
	            var nodes = _ref.nodes,
	                speed = _ref.speed,
	                action = _ref.action,
	                moveDist = _ref.moveDist,
	                leftIndex = _ref.leftIndex,
	                currIndex = _ref.currIndex,
	                rightIndex = _ref.rightIndex,
	                direction = _ref.direction;

	            if (this.swipe) {
	                this.swipe.move(action, speed, currIndex, moveDist);
	            } else {
	                _.each([this.abstractGetPageObj(leftIndex), this.abstractGetPageObj(currIndex), this.abstractGetPageObj(rightIndex)], function (pageObj, index) {
	                    if (pageObj) {
	                        var distance = moveDist[index];
	                        pageObj.toMove(action, distance, speed, moveDist[3]);
	                    }
	                });
	            }
	        }

	        /**
	         * 触屏翻页开始
	         * 1 中断所有任务
	         * 2 停止热点对象运行
	         *     停止动画,视频音频等等
	         */

	    }, {
	        key: 'suspend',
	        value: function suspend(pointers) {
	            var stopPointer = pointers.stopPointer,
	                suspendPageObj = this.abstractGetPageObj(stopPointer),
	                prveChpterId = suspendPageObj.baseGetPageId(stopPointer);

	            //翻页结束脚本
	            runScript(suspendPageObj, 'postCode');

	            //中断节点创建任务
	            this.$$suspendInnerCreateTasks(pointers);

	            //停止活动对象活动
	            suspendPageObj.destroyPageAction();
	            $$suspend(suspendPageObj, prveChpterId);
	        }

	        /**
	         * 复位初始状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'resetOriginal',
	        value: function resetOriginal(pageIndex) {
	            var originalPageObj, floatNode;
	            if (originalPageObj = this.abstractGetPageObj(pageIndex)) {
	                if (floatNode = originalPageObj.floatContents.PageContainer) {
	                    //floatPages设置的content溢出后处理
	                    //在非视区增加overflow:hidden
	                    //可视区域overflow:''
	                    floatNode.css({
	                        'zIndex': 2000,
	                        'overflow': 'hidden'
	                    });
	                }
	                $$original(originalPageObj);
	            }
	        }

	        /**
	         * 触屏翻页完成
	         * 1 停止热点动作
	         * 2 触发新的页面动作
	         * @param  {[type]} prevPageIndex [上一页面]
	         * @param  {[type]} currPageIndex [当前页码]
	         * @param  {[type]} nextPageIndex [下一页页码]
	         * @param  {[type]} suspendIndex  [停止动作的页码]因为要区分滑动的方向
	         * @param  {[type]} createPointer [正在创建的页面]
	         * @param  {[type]} direction     [滑动方向]
	         */

	    }, {
	        key: 'autoRun',
	        value: function autoRun(data) {

	            var self = this;

	            /**
	             * 预执行背景创建
	             * 支持多线程快速翻页
	             * 1 初始化,或者快速翻页补全前后页面
	             * 2 正常翻页创建前后
	             */
	            var preCreate = function preCreate(preCreateTask) {
	                var resumePointer;
	                if (data.isQuickTurn || !data.direction) {
	                    resumePointer = [data.prevIndex, data.nextIndex];
	                } else {
	                    resumePointer = data.createPointer || data.nextIndex || data.prevIndex;
	                }
	                self._checkPreforkTasks(resumePointer, preCreateTask);
	            };

	            //激活自动运行对象
	            var startAutoRun = function startAutoRun(currPageObj, data) {

	                //结束通知
	                function complete() {
	                    data.processComplete();
	                    preCreate();
	                }

	                //如果页面容器存在,才处理自动运行
	                var currpagesNode = currPageObj.getContainsNode();
	                if (!currpagesNode) {
	                    return complete();
	                }

	                //运行动作
	                function startRun() {
	                    $$autoRun(currPageObj, data.currIndex, complete);
	                }

	                //运行如果被中断,则等待
	                if (data.suspendCallback) {
	                    data.suspendCallback(startRun);
	                } else {
	                    startRun();
	                }
	            };

	            //检测当前页面构建任务的情况
	            //如果任务没有完成，则等待任务完成
	            this._checkTaskCompleted(data.currIndex, function (currPageObj) {

	                currPageObj.createPageAction();

	                //提升当前页面浮动对象的层级
	                //因为浮动对象可以是并联的
	                var floatNode;
	                if (floatNode = currPageObj.floatContents.PageContainer) {
	                    floatNode.css({
	                        'zIndex': 2001,
	                        'overflow': ''
	                    });
	                }

	                //IE上不支持蒙版效果的处理
	                if (Xut.style.noMaskBoxImage) {
	                    addEdges();
	                }

	                //构件完成通知
	                data.buildComplete(currPageObj.scenarioId);

	                //执行自动动作之前的脚本
	                runScript(currPageObj, 'preCode');

	                //热点状态复位
	                self.resetOriginal(data.suspendIndex);

	                //预构建背景
	                preCreate('background');

	                //等待动画结束后构建
	                startAutoRun(currPageObj, data);
	            });
	        }

	        /**
	         * 销毁整个页面管理对象
	         * @param  {[type]} clearPageIndex [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: 'clearPage',
	        value: function clearPage(clearPageIndex) {
	            var pageObj = this.abstractGetPageObj(clearPageIndex);
	            //销毁页面对象事件
	            if (pageObj) {
	                //移除事件
	                pageObj.baseDestroy();
	                //移除列表
	                this.abstractRemoveCollection(clearPageIndex);
	            }
	        }

	        /**
	         * 销毁整个页面管理对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            //清理视频
	            var pageId = Xut.Presentation.GetPageId(Xut.Presentation.GetPageIndex());

	            removeVideo(pageId);

	            //清理对象
	            this.abstractDestroyCollection();
	            //清理节点
	            this.pagesNode = null;
	        }

	        /**
	         * 设置中断正在创建的页面对象任务
	         * @param {[type]}   currIndex [description]
	         * @param {Function} callback  [description]
	         */

	    }, {
	        key: '$$suspendInnerCreateTasks',
	        value: function $$suspendInnerCreateTasks(pointers) {
	            var pageObj,
	                self = this;
	            [pointers.leftIndex, pointers.currIndex, pointers.rightIndex].forEach(function (pointer) {
	                if (pageObj = self.abstractGetPageObj(pointer)) {
	                    pageObj.setTaskSuspend();
	                }
	            });
	        }

	        /**
	         * 检测活动窗口任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_checkTaskCompleted',
	        value: function _checkTaskCompleted(currIndex, callback) {
	            var currPageObj,
	                self = this;
	            // console.log('激活活动任务',currIndex)
	            if (currPageObj = self.abstractGetPageObj(currIndex)) {
	                currPageObj.checkThreadTask(function () {
	                    // console.log('11111111111当前页面创建完毕',currIndex+1)
	                    callback(currPageObj);
	                });
	            }
	        }

	        /**
	         * 检测后台预创建任务
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_checkPreforkTasks',
	        value: function _checkPreforkTasks(resumePointer, preCreateTask) {
	            var resumeObj, resumeCount;
	            if (!resumePointer.length) {
	                resumePointer = [resumePointer];
	            }
	            resumeCount = resumePointer.length;
	            while (resumeCount--) {
	                if (resumeObj = this.abstractGetPageObj(resumePointer[resumeCount])) {
	                    resumeObj.createPreforkTasks(function () {
	                        // console.log('后台处理完毕')
	                    }, preCreateTask);
	                }
	            }
	        }
	    }]);
	    return PageMgr;
	}(Abstract);

	/**
	 * 扁平化对象到数组
	 * @param  {[type]} filter [description]
	 * @return {[type]}        [description]
	 */
	var toArray$2 = function toArray(filter) {
	    var arr = [];
	    if (!filter.length) {
	        for (var key in filter) {
	            arr.push(filter[key]);
	        }
	        filter = arr;
	    }
	    return filter;
	};

	var rword = "-";
	var transitionDuration$5 = Xut.style.transitionDuration;
	var transform$5 = Xut.style.transform;
	var translateZ$2 = Xut.style.translateZ;

	/**
	 * parallaObjsCollection: Object
	 *      0: Page
	 *      1: Page
	 *
	 *  recordMasterId: Object
	 *      0: 9001
	 *      1: 9001
	 *
	 *  recordMasterscope: Object
	 *      9001: Array[2]
	 *
	 *  rootNode: ul # parallax.xut - parallax xut - flip
	 *
	 *  currMasterId: 9001 //实际的可使区
	 */

	var MasterMgr = function (_Abstract) {
	    inherits(MasterMgr, _Abstract);

	    function MasterMgr(vm) {
	        classCallCheck(this, MasterMgr);

	        var _this = possibleConstructorReturn(this, (MasterMgr.__proto__ || Object.getPrototypeOf(MasterMgr)).call(this));

	        _this.viewWidth = config.viewSize.width;
	        _this.viewHeight = config.viewSize.height;

	        _this.pageType = 'master';

	        _this.rootNode = vm.options.rootMaster;
	        _this.recordMasterscope = {}; //记录master区域范围
	        _this.recordMasterId = {}; //记录页面与母板对应的编号
	        _this.currMasterId = null; //可视区母板编号

	        /**
	         * 记录视察处理的对象
	         * @type {Object}
	         */
	        _this.parallaxProcessedContetns = {};

	        /**
	         * 抽象方法
	         * 创建视觉差容器
	         */
	        _this.abstractCreateCollection();
	        return _this;
	    }

	    /**
	     * 注册状态管理
	     * @param  {[type]} pageIndex  [description]
	     * @param  {[type]} type       [description]
	     * @param  {[type]} hotspotObj [description]
	     * @return {[type]}            [description]
	     */


	    createClass(MasterMgr, [{
	        key: 'register',
	        value: function register(pageIndex, type, hotspotObj) {
	            var parallaxObj = this.abstractGetPageObj(this._conversionMasterId(pageIndex));
	            if (parallaxObj) {
	                parallaxObj.registerCotents.apply(parallaxObj, arguments);
	            }
	        }

	        /**
	         * 创建
	         * @param  {[type]} dataOpts       [description]
	         * @param  {[type]} pageIndex      [description]
	         * @param  {[type]} createCallBack [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: 'create',
	        value: function create(dataOpts, pageIndex, createCallBack) {
	            var masterObj, reuseMasterId, reuseMasterKey;
	            var pptMaster = dataOpts.chapterData.pptMaster;
	            var pageOffset = dataOpts.chapterData.pageOffset;

	            //母板复用的标示
	            reuseMasterId = pageOffset && pageOffset.split(rword);

	            //组合下标
	            if (reuseMasterId && reuseMasterId.length === 3) {
	                reuseMasterKey = pptMaster + rword + reuseMasterId[2];
	            } else {
	                reuseMasterKey = pptMaster;
	            }

	            //检测视觉差对象是否重复创建
	            if (this._checkRepeat(reuseMasterKey, pageOffset, pageIndex)) {
	                return;
	            }

	            //通知外部,需要创建的母版
	            createCallBack();

	            masterObj = new Pagebase(_.extend(dataOpts, {
	                'pageType': this.pageType, //创建页面的类型
	                'rootNode': this.rootNode, //根元素
	                'pptMaster': pptMaster //ppt母板ID
	            }));

	            //增加页面管理
	            this.abstractAddCollection(reuseMasterKey, masterObj);

	            return masterObj;
	        }

	        /**
	         * 页面滑动处理
	         * 1 母版之间的切换
	         * 2 浮动对象的切换
	         */

	    }, {
	        key: 'move',
	        value: function move() {
	            var _this2 = this;

	            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	                nodes = _ref.nodes,
	                speed = _ref.speed,
	                action = _ref.action,
	                moveDist = _ref.moveDist,
	                leftIndex = _ref.leftIndex,
	                currIndex = _ref.currIndex,
	                rightIndex = _ref.rightIndex,
	                direction = _ref.direction;

	            var isBoundary = false; //是边界处理

	            //找到需要滑动的母版
	            var masterObjs = this._findMaster(leftIndex, currIndex, rightIndex, direction, action);

	            _.each(masterObjs, function (pageObj, index) {
	                if (pageObj) {
	                    isBoundary = true;
	                    var dist = moveDist[index];
	                    pageObj.toMove(action, dist, speed, moveDist[3]);
	                }
	            });

	            //越界不需要处理内部视察对象
	            this.isBoundary = isBoundary;
	            if (isBoundary) {
	                return;
	            }

	            //移动视察对象
	            var moveParallaxObject = function moveParallaxObject(nodes) {
	                _this2._moveParallaxs(currIndex, action, direction, moveDist, speed, nodes, _this2.parallaxProcessedContetns);
	            };

	            //移动视察对象
	            switch (direction) {
	                case 'prev':
	                    moveParallaxObject();
	                    break;
	                case 'next':
	                    nodes && moveParallaxObject(nodes);
	                    break;
	            }
	        }

	        /**
	         * 停止行为
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'suspend',
	        value: function suspend(pointers) {
	            //如果未越界不需要处理行为
	            if (!this.isBoundary) return;
	            var masterObj,
	                stopPointer = pointers.stopPointer;
	            if (masterObj = this.abstractGetPageObj(stopPointer)) {
	                var pageId = masterObj.baseGetPageId(stopPointer);
	                //停止活动对象活动
	                $$suspend(masterObj, pageId);
	            }
	        }

	        /**
	         * 复位初始状态
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'resetOriginal',
	        value: function resetOriginal(pageIndex) {
	            var originalPageObj;
	            if (originalPageObj = this.abstractGetPageObj(pageIndex)) {
	                $$original(originalPageObj);
	            }
	        }

	        /**
	         *  母版自动运行
	         */

	    }, {
	        key: 'autoRun',
	        value: function autoRun(data) {
	            var masterObj;
	            if (masterObj = this.abstractGetPageObj(data.currIndex)) {
	                //热点状态复位
	                this.resetOriginal(data.suspendIndex);
	                $$autoRun(masterObj, data.currIndex);
	            }
	        }

	        /**
	         * 重新激动视觉差对象
	         * 因为视察滑动对象有动画
	         * 2个CSS3动画冲突的
	         * 所以在视察滑动的情况下先停止动画
	         * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
	         * 通过动画回调在重新加载动画
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'reactivation',
	        value: function reactivation(target) {
	            if (this.parallaxProcessedContetns) {
	                var actName = target.id;
	                var contentObj = this.parallaxProcessedContetns[actName];
	                if (contentObj) {
	                    contentObj.runAnimations();
	                    //视觉差处理一次,停止过动画
	                    contentObj.parallaxProcessed = false;
	                    //移除标记
	                    target.removeAttribute('data-parallaxProcessed');
	                    //记录
	                    delete this.parallaxProcessedContetns[actName];
	                }
	            }
	        }

	        /**
	         * 制作处理器
	         * 针对跳转页面
	         * @param  {[type]} data [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: 'makeJumpPocesss',
	        value: function makeJumpPocesss(data) {
	            var filter;
	            var master = this;
	            return {
	                pre: function pre() {
	                    var targetIndex = data.targetIndex;
	                    //目标母板对象
	                    var targetkey = master._conversionMasterId(targetIndex);
	                    //得到过滤的边界keys
	                    //在filter中的页面为过滤
	                    filter = master._scanBounds(targetIndex, targetkey);
	                    //清理多余母板
	                    //filter 需要保留的范围
	                    master._checkClear(filter, true);
	                    //更新可视母板编号
	                    master.currMasterId = targetkey;
	                },
	                //修正位置
	                clean: function clean(currIndex, targetIndex) {
	                    master._fixPosition(filter);
	                    master._checkParallaxPox(currIndex, targetIndex);
	                }
	            };
	        }

	        /**
	         * 销毁整个页面对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.rootNode = null;
	            //销毁对象
	            this.abstractDestroyCollection();
	        }

	        /**
	         * 找到当前页面的可以需要滑动是视觉页面对象
	         * @return {[type]}            [description]
	         */

	    }, {
	        key: '_findMaster',
	        value: function _findMaster(leftIndex, currIndex, rightIndex, direction, action) {
	            var prevFlag,
	                nextFlag,
	                prevMasterObj,
	                currMasterObj,
	                nextMasterObj,
	                prevMasterId = this._conversionMasterId(leftIndex),
	                currMasterId = this._conversionMasterId(currIndex),
	                nextMasterId = this._conversionMasterId(rightIndex);

	            switch (direction) {
	                case 'prev':
	                    if (prevFlag = currMasterId !== prevMasterId) {
	                        currMasterObj = this.abstractGetPageObj(currMasterId);
	                    }
	                    if (prevMasterId && prevFlag) {
	                        action === 'flipOver' && this._checkClear([currMasterId, prevMasterId]); //边界清理
	                        prevMasterObj = this.abstractGetPageObj(prevMasterId);
	                    }
	                    break;
	                case 'next':
	                    if (nextFlag = currMasterId !== nextMasterId) {
	                        currMasterObj = this.abstractGetPageObj(currMasterId);
	                    }
	                    if (nextMasterId && nextFlag) {
	                        action === 'flipOver' && this._checkClear([currMasterId, nextMasterId]); //边界清理
	                        nextMasterObj = this.abstractGetPageObj(nextMasterId);
	                    }
	                    break;
	            }
	            return [prevMasterObj, currMasterObj, nextMasterObj];
	        }

	        /**
	         * 移动内部的视察对象
	         * 处理当前页面内的视觉差对象效果
	         */

	    }, {
	        key: '_moveParallaxs',
	        value: function _moveParallaxs(currIndex) {
	            var getMasterId = this._conversionMasterId(currIndex);
	            var currParallaxObj = this.abstractGetPageObj(getMasterId);

	            //处理当前页面内的视觉差对象效果
	            if (currParallaxObj) {
	                for (var _len = arguments.length, arg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	                    arg[_key - 1] = arguments[_key];
	                }

	                currParallaxObj.moveParallax.apply(currParallaxObj, arg);
	            }
	        }

	        //扫描边界
	        //扫描key的左右边界
	        //当前页面的左右边

	    }, {
	        key: '_scanBounds',
	        value: function _scanBounds(currPage, currkey) {
	            var currKey = this._conversionMasterId(currPage),
	                filter = {},
	                i = currPage,
	                prevKey,
	                nextKey;

	            //往前
	            while (i--) {
	                prevKey = this._conversionMasterId(i);
	                if (prevKey && prevKey !== currkey) {
	                    filter['prev'] = prevKey;
	                    break;
	                }
	            }

	            //往后
	            nextKey = this._conversionMasterId(currPage + 1);

	            //如果有下一条记录
	            if (nextKey && nextKey !== currkey) {
	                //如果不是当期页面满足范围要求
	                filter['next'] = nextKey;
	            }

	            //当前页面
	            if (currKey) {
	                filter['curr'] = currKey;
	            }
	            return filter;
	        }

	        /**
	         * 修正位置
	         * @param  {[type]} filter [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_fixPosition',
	        value: function _fixPosition(filter) {

	            var self = this;

	            var setPosition = function setPosition(parallaxObj, position) {

	                /**
	                 * 设置移动
	                 */
	                var toMove = function toMove(distance, speed) {
	                    var $pageNode = parallaxObj.$pageNode;
	                    if ($pageNode) {
	                        $pageNode.css(transitionDuration$5, speed + 'ms');
	                        $pageNode.css(transform$5, 'translate(' + distance + 'px,0px)' + translateZ$2);
	                    }
	                };

	                if (position === 'prev') {
	                    toMove(-self.viewWidth);
	                } else if (position === 'next') {
	                    toMove(self.viewWidth);
	                } else if (position === 'curr') {
	                    toMove(0);
	                }
	            };

	            for (var key in filter) {
	                switch (key) {
	                    case 'prev':
	                        setPosition(this.abstractGetPageObj(filter[key]), 'prev');
	                        break;
	                    case 'curr':
	                        setPosition(this.abstractGetPageObj(filter[key]), 'curr');
	                        break;
	                    case 'next':
	                        setPosition(this.abstractGetPageObj(filter[key]), 'next');
	                        break;
	                }
	            }
	        }
	    }, {
	        key: '_checkParallaxPox',
	        value: function _checkParallaxPox(currPageIndex, targetIndex) {
	            var key,
	                pageObj,
	                pageCollection = this.abstractGetCollection();
	            for (key in pageCollection) {
	                pageObj = pageCollection[key];
	                //跳跃过的视觉容器处理
	                this._fixParallaxPox(pageObj, currPageIndex, targetIndex);
	            }
	        }

	        /**
	         * 当前同一视觉页面作用的范围
	         * @param  {[type]} reuseMasterKey [description]
	         * @param  {[type]} pageIndex      [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_toRepeat',
	        value: function _toRepeat(reuseMasterKey, pageIndex) {
	            var temp;
	            if (temp = this.recordMasterscope[reuseMasterKey]) {
	                return temp;
	            }
	            return false;
	        }

	        //更新母板作用域范围
	        //recordMasterscope:{
	        //   9001-1:[0,1], master 对应记录的页码
	        //   9002-1:[2,3]
	        //   9001-2:[4,5]
	        //}

	    }, {
	        key: '_updataMasterscope',
	        value: function _updataMasterscope(reuseMasterKey, pageIndex) {
	            var scope;
	            if (scope = this.recordMasterscope[reuseMasterKey]) {
	                if (-1 === scope.indexOf(pageIndex)) {
	                    scope.push(pageIndex);
	                }
	            } else {
	                this.recordMasterscope[reuseMasterKey] = [pageIndex];
	            }
	        }

	        /**
	         * 记录页面与模板标示的映射
	         * @param  {[type]} reuseMasterKey [description]
	         * @param  {[type]} pageIndex      [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_updatadParallaxMaster',
	        value: function _updatadParallaxMaster(reuseMasterKey, pageIndex) {
	            //记录页面与模板标示的映射
	            this.recordMasterId[pageIndex] = reuseMasterKey;
	            //更新可视区母板的编号
	            this.currMasterId = this._conversionMasterId(Xut.Presentation.GetPageIndex());
	        }

	        /**
	         * 检测是否需要创建视觉差
	         * @param  {[type]} reuseMasterKey [description]
	         * @param  {[type]} pageOffset     [description]
	         * @param  {[type]} pageIndex      [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_checkRepeat',
	        value: function _checkRepeat(reuseMasterKey, pageOffset, pageIndex) {
	            var tag = this._toRepeat(reuseMasterKey, pageIndex); //false就是没找到视察对象
	            this._updataMasterscope(reuseMasterKey, pageIndex);
	            this._updatadParallaxMaster(reuseMasterKey, pageIndex);
	            return tag;
	        }

	        /**
	         * 修正跳转后视觉对象坐标
	         * @param  {[type]} parallaxObj   [description]
	         * @param  {[type]} currPageIndex [description]
	         * @param  {[type]} targetIndex   [description]
	         * @return {[type]}               [description]
	         */

	    }, {
	        key: '_fixParallaxPox',
	        value: function _fixParallaxPox(parallaxObj, currPageIndex, targetIndex) {
	            var self = this;
	            var contentObjs = void 0;
	            var prevNodes = void 0;
	            var nodes = void 0;

	            var repairNodes = function repairNodes(scope, currPageIndex, targetIndex) {
	                var rangePage = scope.calculateRangePage(),
	                    $contentNode = scope.$contentNode,
	                    translate = scope.translate,
	                    offsetTranslate = scope.offsetTranslate,
	                    moveTranslate,
	                    nodes = Xut.Presentation.GetPageNode(targetIndex - 1);

	                if (targetIndex > currPageIndex) {
	                    //next
	                    if (targetIndex > rangePage['end']) {
	                        nodes = 1;
	                    }
	                } else {
	                    //prev
	                    if (targetIndex < rangePage['start']) {
	                        nodes = 0;
	                    }
	                }

	                moveTranslate = _transformConversion(translate, -self.viewWidth, nodes);
	                _transformNodes($contentNode, 300, moveTranslate, offsetTranslate.opacityStart);
	                _overMemory(moveTranslate, offsetTranslate);
	            };

	            if (contentObjs = parallaxObj.baseGetContent()) {
	                contentObjs.forEach(function (contentObj) {
	                    contentObj.eachAssistContents(function (scope) {
	                        if (scope.parallax) {
	                            repairNodes.call(self, scope.parallax, currPageIndex, targetIndex);
	                        }
	                    });
	                });
	            }
	        }

	        //检测是否需要清理
	        // 1 普通翻页清理  【数组过滤条件】
	        // 2 跳转页面清理  【对象过滤条件】

	    }, {
	        key: '_checkClear',
	        value: function _checkClear(filter, toPage) {
	            var key,
	                indexOf,
	                removeMasterId = _.keys(this.abstractGetCollection());

	            // 如果有2个以上的母板对象,就需要清理
	            if (removeMasterId.length > 2 || toPage) {
	                //或者是跳转页面
	                //解析对象
	                filter = toArray$2(filter);
	                //过滤
	                _.each(filter, function (masterId) {
	                    if (masterId !== undefined) {
	                        indexOf = removeMasterId.indexOf(masterId.toString());
	                        if (-1 !== indexOf) {
	                            //过滤需要删除的对象
	                            removeMasterId.splice(indexOf, 1);
	                        }
	                    }
	                });
	                this._clearMemory(removeMasterId);
	            }
	        }

	        /**
	         * 清理内存
	         * 需要清理的key合集
	         * @param  {[type]} removeMasterId [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_clearMemory',
	        value: function _clearMemory(removeMasterId) {
	            var pageObj,
	                self = this;
	            _.each(removeMasterId, function (removekey) {
	                //销毁页面对象事件
	                if (pageObj = self.abstractGetPageObj(removekey)) {
	                    //移除事件
	                    pageObj.baseDestroy();
	                    //移除列表
	                    self.abstractRemoveCollection(removekey);
	                    self._removeRecordMasterscope(removekey);
	                }
	                //清理作用域缓存
	                delete self.recordMasterscope[removekey];
	            });
	        }

	        /**
	         * page转化成母版ID
	         * @param  {[type]} pageIndex [description]
	         * @return {[type]}           [description]
	         */

	    }, {
	        key: '_conversionMasterId',
	        value: function _conversionMasterId(pageIndex) {
	            return this.recordMasterId ? this.recordMasterId[pageIndex] : undefined;
	        }
	    }, {
	        key: '_removeRecordMasterscope',
	        value: function _removeRecordMasterscope(removekey) {
	            var me = this;
	            var recordMasterscope = me.recordMasterscope[removekey];
	            //清理页码指示标记
	            recordMasterscope.forEach(function (scope) {
	                delete me.recordMasterId[scope];
	            });
	        }
	    }]);
	    return MasterMgr;
	}(Abstract);

	/**
	 * 跳转之前提高层级问题
	 * @return {[type]}          [description]
	 */
	var improveIndex = function improveIndex(complier) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        currIndex = _ref.currIndex;

	    //提高page层级
	    complier.pageMgr.abstractAssistPocess(currIndex, function (pageObj) {
	        pageObj.$pageNode.css({
	            'z-index': 9997
	        });
	    });

	    //提高mater层级
	    complier.masterContext(function () {
	        this.abstractAssistPocess(currIndex, function (pageObj) {
	            pageObj.$pageNode.css({
	                'z-index': 1
	            });
	        });
	    });
	};

	/**
	 * 处理跳转逻辑
	 * @param  {[type]} complier       [description]
	 * @param  {[type]} data           [description]
	 * @param  {[type]} createCallback [description]
	 * @return {[type]}                [description]
	 */
	var calculateFlip = function calculateFlip(complier, data, createCallback) {
	    //缓存当前页面索引用于销毁
	    var pageIndex,
	        i = 0,
	        collectContainers = [],
	        create = data.create,
	        targetIndex = data.targetIndex;

	    //需要创建的页面闭包器
	    for (; i < create.length; i++) {
	        pageIndex = create[i];
	        collectContainers.push(function (targetIndex, pageIndex) {
	            return function (callback) {
	                //创建新结构
	                complier.createPageBase([pageIndex], targetIndex, 'toPage', callback, {
	                    'opacity': 0 //同页面切换,规定切换的样式
	                });
	            };
	        }(targetIndex, pageIndex));
	    }

	    /**
	     * 二维数组保存，创建返回的对象
	     * 1 page对象
	     * 2 母版对象
	     * @type {Array}
	     */
	    data.pageBaseCollect = [];

	    var i = 0,
	        collectLength,
	        count,
	        count = collectLength = collectContainers.length;

	    if (collectContainers && collectLength) {
	        for (; i < collectLength; i++) {
	            //收集创建的根节点,异步等待容器的创建
	            collectContainers[i].call(complier, function (callbackPageBase) {
	                if (count === 1) {
	                    collectContainers = null;
	                    setTimeout(function () {
	                        createCallback(data);
	                    }, 100);
	                }
	                //接受创建后返回的页面对象
	                data.pageBaseCollect.push(callbackPageBase);
	                count--;
	            });
	        }
	    }
	};

	/**
	 * 节点创建完毕后，切换页面动，执行动作
	 * @param  {[type]} complier [description]
	 * @param  {[type]} data     [description]
	 * @return {[type]}          [description]
	 */
	var createContainerView = function createContainerView(complier, data) {

	    var prveHindex = data.currIndex;
	    var pageMgr = complier.pageMgr;

	    //停止当前页面动作
	    complier.suspendPageBase({
	        'stopPointer': prveHindex
	    });

	    //========处理跳转中逻辑=========

	    /**
	     * 清除掉不需要的页面
	     * 排除掉当前提高层次页面
	     */
	    _.each(data['destroy'], function (destroyIndex) {
	        if (destroyIndex !== data.currIndex) {
	            pageMgr.clearPage(destroyIndex);
	        }
	    });

	    //修正翻页2页的页面坐标值
	    _.each(data['ruleOut'], function (pageIndex) {
	        if (pageIndex > data['targetIndex']) {
	            pageMgr.abstractAssistAppoint(pageIndex, function (pageObj) {
	                _fix(pageObj.$pageNode, 'nextEffect');
	            });
	        }
	        if (pageIndex < data['targetIndex']) {
	            pageMgr.abstractAssistAppoint(pageIndex, function (pageObj) {
	                _fix(pageObj.$pageNode, 'prevEffect');
	            });
	        }
	    });

	    var jumpPocesss = void 0;

	    //母版
	    complier.masterContext(function () {
	        jumpPocesss = this.makeJumpPocesss(data);
	        jumpPocesss.pre();
	    });

	    //===========跳槽后逻辑========================
	    pageMgr.clearPage(prveHindex);

	    jumpPocesss && jumpPocesss.clean(data.currIndex, data.targetIndex);

	    /**
	     * 同页面切换,规定切换的样式复位
	     * @param  {[type]} pageBase [description]
	     * @return {[type]}          [description]
	     */
	    _.each(data.pageBaseCollect, function (pageBase) {
	        _.each(pageBase, function (pageObj) {
	            pageObj.$pageNode && pageObj.$pageNode.css({
	                'opacity': 1
	            });
	        });
	    });

	    data.pageBaseCollect = null;
	    jumpPocesss = null;
	};

	/**
	 * 跳转页面逻辑处理
	 * @param  {[type]} complier [description]
	 * @param  {[type]} data     [description]
	 * @param  {[type]} success  [description]
	 * @return {[type]}          [description]
	 */
	function goToPage(complier, data, success) {
	    //跳前逻辑
	    improveIndex(complier, data);
	    //处理逻辑
	    calculateFlip(complier, data, function (data) {
	        createContainerView(complier, data);
	        success.call(complier, data);
	    });
	}

	var translateZ$3 = Xut.style.translateZ;

	/**
	 * 创建translate初始值
	 * @param  {[type]} offset [description]
	 * @return {[type]}        [description]
	 */
	var createTranslate$1 = function createTranslate(offset) {
	    return 'translate(' + offset + 'px,0px)' + translateZ$3;
	};

	/**
	 * 混入钩子处理
	 * @param  {[type]} original [description]
	 * @param  {[type]} hook     [description]
	 * @return {[type]}          [description]
	 */
	var mixHooks = function mixHooks(original, hook) {
	    if (hook) {
	        var newValue = hook(original);
	        if (newValue !== undefined) {
	            return newValue;
	        }
	    }
	    return original;
	};

	/**
	 * 创建li的translate起始坐标信息
	 * flowType 如果是flow类型
	 * @return {[type]}
	 */
	var defaultContainer = {

	    /**
	     * 默认视图
	     * @return {[type]} [description]
	     */
	    view: function view() {
	        var viewSize = config.viewSize;
	        return {
	            viewWidth: viewSize.width,
	            viewHeight: viewSize.height,
	            viewTop: viewSize.top,
	            viewLeft: 0
	        };
	    }

	    /**
	     * 默认样式
	     * @param  {Object} options.hooks [description]
	     * @param  {[type]} createIndex   [description]
	     * @param  {Object} currIndex                     } [description]
	     * @return {[type]}               [description]
	     */
	    ,
	    translate: function translate() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _ref$hooks = _ref.hooks,
	            hooks = _ref$hooks === undefined ? {} : _ref$hooks,
	            createIndex = _ref.createIndex,
	            currIndex = _ref.currIndex,
	            direction = _ref.direction;

	        var translate = void 0;
	        var offset = void 0;
	        var offsetLeft = void 0;
	        var offsetMiddle = void 0;
	        var offsetRight = void 0;

	        var viewWidth = config.viewSize.width;

	        switch (direction) {
	            case 'before':
	                offsetLeft = -viewWidth;
	                offsetLeft = mixHooks(offsetLeft, hooks.left);
	                translate = createTranslate$1(offsetLeft);
	                offset = offsetLeft;
	                break;
	            case 'middle':
	                offsetMiddle = 0;
	                offsetMiddle = mixHooks(offsetMiddle, hooks.middle);
	                translate = createTranslate$1(offsetMiddle);
	                offset = offsetMiddle;
	                break;
	            case 'after':
	                offsetRight = viewWidth;
	                offsetRight = mixHooks(offsetRight, hooks.right);
	                translate = createTranslate$1(offsetRight);
	                offset = offsetRight;
	                break;
	        }

	        return {
	            translate: translate,
	            offset: offset
	        };
	    }
	};

	/**
	 * 加入数组处理
	 */
	var Stack = function () {
	    function Stack() {
	        classCallCheck(this, Stack);

	        this._cache = [];
	    }

	    /**
	     * 加入首部
	     * @return {[type]} [description]
	     */


	    createClass(Stack, [{
	        key: "shift",
	        value: function shift(fn) {
	            this._cache.unshift(fn);
	        }

	        /**
	         * 加入尾部
	         * @param  {Function} fn [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: "push",
	        value: function push(fn) {
	            this._cache.push(fn);
	        }

	        /**
	         * 从头部取出全部执行
	         * @return {[type]} [description]
	         */

	    }, {
	        key: "shiftAll",
	        value: function shiftAll() {
	            if (this._cache.length) {
	                var fn = void 0;
	                while (fn = this._cache.shift()) {
	                    fn.apply(null, arguments);
	                }
	            }
	            return this;
	        }

	        /**
	         * 尾部取出执行
	         * @return {[type]} [description]
	         */

	    }, {
	        key: "popAll",
	        value: function popAll() {
	            if (this._cache.length) {
	                var fn = void 0;
	                while (fn = this._cache.pop()) {
	                    fn.apply(null, arguments);
	                }
	            }
	            return this;
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            this._cache = null;
	        }
	    }]);
	    return Stack;
	}();

	/**
	 * 自定义样式页面容器的样式
	 * 创建页面的样式，与布局
	 * 1 创建页面的初始化的Transform值
	 * 是否初始化创建
	 * @return {[type]} [description]
	 */
	function styleConfig(_ref) {
	    var action = _ref.action,
	        hasFlow = _ref.hasFlow,
	        usefulData = _ref.usefulData;


	    /**
	     * 获取指定页面样式
	     * @return {[type]} [description]
	     */
	    usefulData.getStyle = function (pageName) {
	        return this[this['_' + pageName]];
	    };

	    var compile = new Stack();

	    _.each(usefulData, function (data, index) {

	        //跳过getStyle方法
	        if (_.isFunction(data)) {
	            return;
	        }

	        //只处理页面的样式对象
	        //确保中间页第一个解析
	        compile[data.direction == 'middle' ? 'shift' : 'push'](function () {

	            //容器默认默认尺寸
	            _.extend(data, defaultContainer.view());

	            //提供可自定义配置接口
	            if (data.isFlows) {
	                _.extend(data, getFlowView());
	            }

	            //设置容器样式
	            var translate = defaultContainer.translate({
	                //提供容器的样式钩子
	                hooks: hasFlow ? setFlowTranslate(data, usefulData) : {},
	                createIndex: data.pid,
	                currIndex: data.visiblePid,
	                direction: data.direction
	            });

	            //提供快速索引
	            usefulData['_' + data.direction] = data.pid;
	            _.extend(data, translate);
	        });
	    });

	    compile.shiftAll().destroy();

	    return usefulData;
	}

	/**
	 * 计算数据偏移量
	 * @param  {[type]} tableName [description]
	 * @return {[type]}           [description]
	 */
	var dataOffset = function dataOffset(dataCache) {

	    var set = function set(tableName) {
	        var start = void 0;
	        var data = dataCache[tableName];
	        if (data.length) {
	            if (data.item(0)) {
	                if (start = data.item(0)._id) {
	                    dataCache[tableName].start = start;
	                }
	            }
	        }
	    };

	    //数据段标记
	    for (var key in dataCache) {
	        if (dataCache[key].item) {
	            set(key);
	        }
	    }

	    return dataCache;
	};

	/**
	 * 转化video的activtiy信息
	 * 因为Video不是靠id关联的 是靠activtiy关联
	 * [description]
	 * @return {[type]} [description]
	 */
	var transformVideoActivity = function transformVideoActivity(dataCache) {
	    var data = void 0;
	    var activityIds = {};
	    var video = dataCache.Video;
	    _.each(video, function (_, index) {
	        data = video.item(index);

	        //确保activityIdID是有值，
	        //这样才是靠activity关联的video,
	        //而不是动画的video
	        if (data && data.activityId) {
	            activityIds[data.activityId] = data._id;
	        }
	    });
	    return activityIds;
	};

	/**
	 * chpater分段
	 * 转化section信息
	 * 带有场景处理
	 * @return {[type]} [description]
	 */
	var transformSectionRelated = function transformSectionRelated(dataCache) {
	    var seasonId,
	        start,
	        length,
	        sid,
	        i,
	        id,
	        seasonInfo,
	        toolbar,
	        Chapters,
	        container = {},
	        Chapter = dataCache.Chapter,
	        l = Chapter.length,
	        end = 0;

	    //找到指定的season信息
	    var findSeasonInfo = function findSeasonInfo(seasonId) {
	        var temp,
	            seasonNum = dataCache.Season.length;
	        while (seasonNum--) {
	            if (temp = dataCache.Season.item(seasonNum)) {
	                if (temp._id == seasonId) {
	                    return temp;
	                }
	            }
	        }
	    };

	    for (i = 0; i < l; i++) {
	        Chapters = Chapter.item(i);
	        if (Chapters) {
	            id = Chapters._id - 1; //保存兼容性,用0开头
	            seasonId = Chapters.seasonId;
	            sid = 'seasonId->' + seasonId;
	            //如果不在集合,先创建
	            if (!container[sid]) {
	                //场景工具栏配置信息
	                if (seasonInfo = findSeasonInfo(seasonId)) {
	                    toolbar = seasonInfo.parameter;
	                }
	                container[sid] = {
	                    start: id,
	                    length: 1,
	                    end: id,
	                    toolbar: toolbar
	                };
	            } else {
	                container[sid].end = id;
	                container[sid].length = container[sid].length + 1;
	            }
	        }
	    }

	    return container;
	};

	/**
	 * 数据库缓存结果集
	 */
	var result = void 0;

	/**
	 * 设置数据缓存
	 * 1 去掉全局挂着
	 * 2 缓存
	 */
	function importDatabase(callback) {
	    //如果外联指定路径json数据
	    var path = window.DYNAMICCONFIGT && window.DYNAMICCONFIGT.database;
	    if (path) {
	        //add window.SQLResult database
	        request(path, function () {
	            result = window.SQLResult;
	            window.SQLResult = null;
	            callback();
	        });
	    }
	    //如果外联index.html路径json数据
	    else if (window.SQLResult) {
	            result = window.SQLResult;
	            window.SQLResult = null;
	            callback();
	        } else {
	            callback();
	        }
	}

	/**
	 * 获取数据缓存
	 * @return {[type]} [description]
	 */
	function getResults() {
	    return result;
	}

	/**
	 * 移除缓存数据
	 * @return {[type]} [description]
	 */
	function removeResults() {
	    result = null;
	}

	/**
	 * 创建执行方法
	 * @return {[type]} [description]
	 */
	function createfactory(sql, fn) {
	    var key;
	    if (typeof sql === 'string') {
	        fn(key, sql);
	    } else {
	        for (key in sql) {
	            fn(key, sql[key]);
	        }
	    }
	}

	/**
	 * 模拟database获取数据
	 * @return {[type]}            [description]
	 */
	function executeDB(sql, callback, errorCB, tName) {
	    var jsonResult = getResults();
	    var data = void 0;
	    var resultObj = void 0;

	    //如果json格式数据
	    if (jsonResult) {
	        if (jsonResult[tName]) {
	            data = jsonResult[tName];
	            resultObj = {
	                length: Object.keys(data).length,
	                item: function item(num) {
	                    return data[num];
	                }
	            };
	            callback(resultObj);
	        } else {
	            errorCB({
	                tName: ':table not exist!!'
	            });
	        }
	    }
	    //否则直接ajax php
	    else {
	            $.ajax({
	                url: config.onlineModeUrl,
	                dataType: 'json',
	                data: {
	                    xxtsql: sql
	                },
	                success: function success(rs) {
	                    data = rs;
	                    resultObj = {
	                        length: rs.length,
	                        item: function item(num) {
	                            return data[num];
	                        }
	                    };
	                    callback(resultObj);
	                },

	                error: errorCB
	            });
	        }
	}

	//建立sql查询
	function execute(selectSql, callback) {

	    var database = config.db,
	        tableName,
	        //表名
	    successResults = {},
	        //成功的数据
	    tempClosure = [],
	        //临时收集器
	    collectError = [],
	        //收集错误查询
	    buildTotal = function () {
	        //如果只有一条
	        if (typeof selectSql === 'string') {
	            return 1;
	        } else {
	            return Object.keys(selectSql).length;
	        }
	    }();

	    createfactory(selectSql, function (key, value) {
	        //开始执行查询
	        createSelect(key || 'results', value);
	    });

	    /**
	     * 创建查询
	     */
	    function createSelect(key, value) {
	        buildTotal--;
	        tempClosure.push(executeTemplate(key, value));
	        0 === buildTotal && executeBuild();
	    }

	    /**
	     * 执行查询
	     * @return {[type]} [description]
	     */
	    function executeBuild() {
	        if (tempClosure.length) {
	            var temp = tempClosure.shift();
	            tableName = temp.tableName;
	            temp.execute();
	        } else {
	            //successResults['results'] 成功表数据
	            //collectError 失败表
	            callback(successResults['results'] ? successResults['results'] : successResults, collectError);
	        }
	    }

	    //成功后方法
	    function success() {
	        executeBuild();
	    }

	    //失败
	    function errorCB(error) {
	        collectError.push(tableName);
	        console.log("数据查询错误 " + error.message, '类型', tableName);
	        executeBuild();
	    }

	    /**
	     * 构建执行作用域
	     */
	    function executeTemplate(tName, sql) {
	        return {
	            tableName: tName,
	            execute: function execute() {
	                //支持本地查询
	                if (database) {
	                    database.transaction(function (tx) {
	                        tx.executeSql(sql, [], function (tx, result) {
	                            successResults[tName] = result.rows;
	                        });
	                    }, errorCB, success);
	                }
	                //json与ajax
	                else {
	                        executeDB(sql, function (result) {
	                            successResults[tName] = result;
	                            success();
	                        }, errorCB, tName);
	                    }
	            }
	        };
	    }
	};

	var statement = {};

	'Setting,Parallax,Master,Activity,Content,Video,Image,Action,Animation,Widget,Novel,Season,Chapter'.replace(/[^, ]+/g, function (name) {
	    statement[name] = 'select * FROM ' + name + ' order by _id ASC';
	});

	/**
	 * 查询单一的数据
	 * @return {[type]} [description]
	 */
	function oneQuery(tableName, callback) {
	    execute('select * FROM ' + tableName + ' order by _id ASC', function (successRet, collectError) {
	        callback(successRet, collectError);
	    });
	}

	/**
	 * 查询总数据
	 */
	function dataQuery(callback) {
	    //ibook模式，数据库外部注入的
	    if (Xut.IBooks.CONFIG) {
	        callback(Xut.IBooks.CONFIG.data);
	    } else {
	        //查询所有数据
	        execute(statement, function (successRet, collectError) {
	            callback(successRet, collectError);
	        });
	    }
	}

	/**
	 * 删除数据
	 * @type {[type]}
	 */
	function dataRemove(tableName, id, success, fail) {
	    var sql = 'delete from ' + tableName + ' where _id = ' + id;
	    //查询所有数据
	    execute(sql, function (success, failure) {
	        if (success) {
	            //成功回调
	            success();
	        } else if (failure) {
	            //失败回调
	            fail();
	        }
	    });
	}

	/**
	 * 数据缓存
	 */
	var dataCache = void 0;

	/**
	 * 带有场景信息存数
	 */
	var sectionRelated = void 0;

	/**
	 * 音频的ActivityId信息
	 */
	var videoActivityIdCache = void 0;

	/**
	 * 错误表
	 */
	var errortables = void 0;

	/**
	 * 错误表
	 * @return {[type]} [description]
	 */
	function errorTable() {
	    return errortables;
	}

	/**
	 * 保存缓存
	 * @param {[type]} results [description]
	 */
	function saveCache(results, collectError) {
	    //错表
	    errortables = collectError || [];

	    //数据结果集
	    Xut.data = dataCache = results;
	}

	/**
	 * 销毁数据
	 * @return {[type]} [description]
	 */
	function removeCache() {
	    dataCache = null;
	    sectionRelated = null;
	    videoActivityIdCache = null;
	    Xut.data = null;
	}

	/**
	 * 转化缓存
	 */
	function convertCache() {

	    /**
	     * 计算数据偏移量
	     */
	    dataOffset(dataCache);

	    /**
	     * vidoe特殊处理，需要记录chapterId范围
	     */
	    if (dataCache.Video) {
	        videoActivityIdCache = transformVideoActivity(dataCache);
	    }

	    /**
	     * 带有场景处理
	     * @type {[type]}
	     */
	    sectionRelated = transformSectionRelated(dataCache);
	}

	/**
	 *  查询数据接口
	 *  1 video表传递是activityId关联
	 *  2 其余表都是传递当前表的id
	 *  type 查询ID的类型, 数据的id或者activityId
	 *  callback 提供给chapterId使用
	 * @return {[type]} [description]
	 */
	function setApi(novelId) {

	    /**
	     * 标记应用ID
	     * @type {[type]}
	     */
	    dataCache.novelId = novelId;

	    /**
	     * 针对数据库content为空的处理
	     * @return {[type]} [description]
	     */
	    dataCache.preventContent = function () {
	        return dataCache.Content.length ? false : true;
	    }();

	    /**
	     * 通过ID查询方式
	     * @param  {[type]}  tableName [description]
	     */
	    dataCache.query = function (tableName, id, type, callback) {
	        /**
	         * 特殊的字段关联
	         * 1 activityId
	         * 2 chpaterId
	         */
	        switch (type) {
	            /**
	             * 通过activityId查询的方式
	             *
	             * 表名,ID,类型
	             * Xut.data.query('Action', id, 'activityId');
	             *
	             * @type {[type]}
	             */
	            case 'activityId':
	                var item;
	                var activityId = id;
	                var data = dataCache[tableName];
	                for (var i = 0, len = data.length; i < len; i++) {
	                    item = data.item(i);
	                    if (item) {
	                        if (item[type] == activityId) {
	                            return item;
	                        }
	                    }
	                }
	                return;

	            /**
	             * 通过chpaterId查询方式
	             * parser中的scanActivity过滤处理
	             */
	            case 'chapterId':
	            case 'seasonId':
	                var chapterId = id;
	                var data = dataCache[tableName];
	                if (data) {
	                    var item;
	                    for (var i = 0, len = data.length; i < len; i++) {
	                        item = data.item(i);
	                        if (item) {
	                            if (item[type] == chapterId) {
	                                callback && callback(item);
	                            }
	                        }
	                    }
	                }
	                return;
	        }

	        /**
	         * 数据信息
	         * @return {[type]} [description]
	         */
	        var Query = function Query() {
	            var data = dataCache[tableName];
	            if (id) {
	                var index = id - data.start;
	                return data.item(index);
	            } else {
	                return data.length ? data.item(0) : null;
	            }
	        };

	        /**
	         * 通过id查询的方式
	         */
	        switch (tableName) {
	            //获取整个一个用的chapter数据
	            case 'appPage':
	                return dataCache.Chapter;
	            ///获取整个一个用的Section数据 
	            case 'appSection':
	                return dataCache.Season;
	            //如果是是section信息
	            case 'sectionRelated':
	                return sectionRelated['seasonId->' + id];
	            //如果是音频
	            case 'Video':
	                if (type) {
	                    return Query();
	                } else {
	                    //传递的id是activityId
	                    var id = videoActivityIdCache[id];
	                    return dataCache.query('Video', id, true);
	                }

	            default:
	                //默认其余所有表
	                return Query();
	        }
	    };

	    /**
	     * 针对动态表查询
	     * 每次需要重新取数据
	     * Xut.data.oneQuery('Image',function(){});
	     * @return {[type]} [description]
	     */
	    dataCache.oneQuery = function (tableName, callback) {
	        oneQuery(tableName, function (data) {
	            callback && callback(data);
	        });
	    };

	    /**
	     * 删除数据
	     * 表名,表ID
	     * @return {[type]} [description]
	     */
	    dataCache.remove = function (tableName, id, success, failure) {
	        dataRemove(tableName, id, success, failure);
	    };
	}

	/**
	 * 页面之间关系
	 * @param  {[type]} createIndex [description]
	 * @param  {[type]} currIndex   [description]
	 * @return {[type]}             [description]
	 */
	function getDirection(createIndex, currIndex) {
	    var direction = void 0;
	    if (createIndex < currIndex) {
	        direction = 'before';
	    } else if (createIndex > currIndex) {
	        direction = 'after';
	    } else if (currIndex == createIndex) {
	        direction = 'middle';
	    }
	    return direction;
	}

	var mixRang = function mixRang(pageIndex, start) {
	    return pageIndex.map(function (oldPageIndex) {
	        return oldPageIndex - start;
	    });
	};

	/**
	 * 如果是场景加载，转化页码数
	 * 转化按0开始
	 * pageIndex 页码
	 * visiblePid 可见页面chpaterId
	 */
	function converVisiblePid(pageIndex, visiblePid) {
	    //转化可视区域值viewPageIndex
	    if (this.options.multiScenario) {
	        var sectionRang = this.options.sectionRang;
	        //如果传入的是数组数据
	        if (!visiblePid && _.isArray(pageIndex)) {
	            return mixRang(pageIndex, sectionRang.start);
	        }
	        pageIndex -= sectionRang.start;
	        visiblePid += sectionRang.start;
	    } else {
	        //pageIndex是数组，并且realPage为空
	        if (_.isArray(pageIndex)) {
	            return pageIndex;
	        }
	    }

	    return {
	        pageIndex: pageIndex,
	        visiblePid: visiblePid
	    };
	}

	/**
	 * 计算初始化页码
	 */
	function initPointer$1(targetIndex, pageTotal, multiplePages) {

	    var leftscope = 0,
	        initPointer = {},
	        createPointer = [];

	    function setValue(index) {
	        if (index.leftIndex !== undefined) {
	            initPointer.leftIndex = index.leftIndex;
	            createPointer.push(index.leftIndex);
	        }
	        if (index.currIndex !== undefined) {
	            initPointer.currIndex = index.currIndex;
	            createPointer.push(index.currIndex);
	        }
	        if (index.rightIndex !== undefined) {
	            initPointer.rightIndex = index.rightIndex;
	            createPointer.push(index.rightIndex);
	        }
	    }

	    //如果只有一页 or  非线性,只创建一个页面
	    if (pageTotal === 1 || !multiplePages) {
	        setValue({
	            'currIndex': targetIndex
	        });
	    } else {
	        //多页情况
	        if (targetIndex === leftscope) {
	            //首页
	            setValue({
	                'currIndex': targetIndex,
	                'rightIndex': targetIndex + 1
	            });
	        } else if (targetIndex === pageTotal - 1) {
	            //尾页
	            setValue({
	                'currIndex': targetIndex,
	                'leftIndex': targetIndex - 1
	            });
	        } else {
	            //中间页
	            setValue({
	                'currIndex': targetIndex,
	                'leftIndex': targetIndex - 1,
	                'rightIndex': targetIndex + 1
	            });
	        }
	    }

	    return {
	        createPointer: createPointer,
	        initPointer: initPointer
	    };
	}

	/**
	 * 索引转化成chapter ID
	 * 确保解析的正确排序
	 * 保证可视页面第一个分解
	 * createPage 需要创建的页面 [0,1,2]
	 * visualPage 可视区页面       [1]
	 * @param  {[type]} createPage [description]
	 * @param  {[type]} visualPage [description]
	 * @return {[type]}            [description]
	 */
	function indexConverChapterId(createPage, visualPage) {
	    var _this = this;

	    //如果第一个不是可视区域
	    //切换位置
	    //加快创建速度
	    if (createPage[0] !== visualPage) {
	        var indexOf = createPage.indexOf(visualPage);
	        var less = createPage.splice(indexOf, 1);
	        createPage = less.concat(createPage);
	    }

	    //场景加载模式,计算正确的chapter顺序
	    //多场景的模式chpater分段后
	    //叠加起始段落
	    if (this.options.multiScenario) {
	        (function () {
	            //需要提前解析数据库的排列方式
	            //chpater的开始位置
	            var start = _this.options.sectionRang.start;
	            //拼接位置
	            createPage.forEach(function (page, index) {
	                createPage.splice(index, 1, page + start);
	            });
	        })();
	    }

	    // [0,1,2] => [73,74,75]
	    return createPage;
	}

	/**
	 * 页码转化成相对应的chpater表数据
	 * @param  {[type]} createPage [description]
	 * @return {[type]}            [description]
	 */
	function indexConverChapterData(createPage) {
	    return query('chapter', createPage);
	}

	/**
	 * 检测是否构建母板模块处理
	 * @return {[type]} [description]
	 */
	function checkMasterCreate() {
	    var table = errorTable();
	    //如果没有Master数据,直接过滤
	    if (-1 !== table.indexOf('Master') || !Xut.data['Master'] || !Xut.data['Master'].length) {
	        return false;
	    }
	    return true;
	}

	var Dispatcher = function () {
	    function Dispatcher(vm) {
	        classCallCheck(this, Dispatcher);

	        this.vm = vm;

	        this.options = vm.options;

	        /**
	         * 创建前景页面管理模块
	         * @type {PageMgr}
	         */
	        this.pageMgr = new PageMgr(vm);

	        /**
	         * 检测是否需要创母版模块
	         * @return {[type]} [description]
	         */
	        if (checkMasterCreate()) {
	            this.masterMgr = new MasterMgr(vm);
	        }
	    }

	    /**
	     * 初始化页面创建
	     * 因为多个页面的问题，所以不是创建调用
	     * 统一回调
	     * @return {[type]} [description]
	     */


	    createClass(Dispatcher, [{
	        key: 'initCreate',
	        value: function initCreate() {
	            var options = this.options;

	            //pointer
	            //  createPointer
	            //  initPointer
	            var pointer = initPointer$1(options.initIndex, options.pagetotal, options.multiplePages);

	            this.pagePointer = pointer.initPointer;

	            //初始化
	            if (this.pageMgr.swipe) {
	                this.pageMgr.swipe.initTranslation(pointer.createPointer, options.initIndex);
	            }

	            //始化构建页面容器对象
	            this.createPageBase(pointer.createPointer, options.initIndex, 'init');
	        }

	        /**
	         *  创建普通页面
	         *  创建母版页面
	         *  createPointer     需要创建的页面索引
	         *  visiblePageIndex  当前可视区页面索引
	         *  action            创建的动作：toPage/init/flipOver
	         *  toPageCallback    跳转页面支持回调通知
	         *  userStyle         规定创建的style属性
	         **/

	    }, {
	        key: 'createPageBase',
	        value: function createPageBase(createPageIndex, visiblePageIndex, action, toPageCallback, userStyle) {

	            //2016.1.20
	            //修正苗苗学问题 确保createPage不是undefined
	            if (createPageIndex[0] === undefined) {
	                return;
	            }

	            var self = this;
	            var multiplePages = this.options.multiplePages; //是否线性
	            var createTotal = createPageIndex.length; //需要创建的总页面
	            var toPageAction = action === 'toPage'; //如果是跳转
	            var filpOverAction = action === 'flipOver'; //如果是翻页

	            //将页码pageIndex转化成对应的chapter && 使用第一个是分解可见页面
	            //不同场景会自动转化chapter的下标
	            //createChapterIndexs
	            //  创建的页码ID合集
	            //  代表数据库chpaterID的索引
	            var createChapterIndexs = indexConverChapterId.call(this, createPageIndex, visiblePageIndex);

	            //收集创建的页面对象
	            //用于处理2个页面在切换的时候闪屏问题
	            //主要是传递createStyle自定义样式的处理
	            var collectPageBase = [];

	            //是否触发母版的自动时间
	            //因为页面每次翻页都会驱动auto事件
	            //但是母版可能是共享的
	            var createMaster = false;

	            //收集完成回调
	            var collectCallback = function () {
	                //收集创建页码的数量
	                var createContent = 0;
	                return function (callback) {
	                    ++createContent;
	                    if (createContent === createTotal) {
	                        callback();
	                    }
	                };
	            }();

	            //构建执行代码
	            var callbackAction = {
	                //初始化
	                init: function init() {
	                    collectCallback(function () {
	                        self._loadPage('init');
	                    });
	                },

	                //翻页
	                flipOver: function flipOver() {
	                    collectCallback(function () {
	                        self._autoRun({ //翻页
	                            'createPointer': createChapterIndexs,
	                            'createMaster': createMaster
	                        });
	                    });
	                },

	                //跳转
	                toPage: function toPage() {
	                    collectCallback(function () {
	                        toPageCallback(collectPageBase);
	                    });
	                }
	            };

	            //chapter页码，转化成页面chapter数据集合
	            var chpaterResults = indexConverChapterData(createChapterIndexs);

	            /**
	             * 预编译
	             * 因为要需要对多个页面进行预处理
	             * 需要同步多个页面数据判断
	             * 这样需要预编译出数据，做了中间处理后再执行后续动作
	             * @type {Array}
	             */
	            var compile = new Stack();

	            //收集有用的数据
	            var usefulData = hash();
	            var hasFlow = false;
	            _.each(chpaterResults, function (chapterData, index) {
	                compile.push(function () {

	                    //创建的页面索引
	                    var createChapterIndex = createChapterIndexs[index];

	                    //转化可视区页码对应的chapter的索引号
	                    //获取出实际的pageIndex号
	                    var conversion = converVisiblePid.call(self, createChapterIndex, visiblePageIndex);
	                    var visibleChapterIndex = conversion.visiblePid;
	                    var pageIndex = conversion.pageIndex;

	                    if (createTotal === 1) {
	                        self.options.chapterId = chapterData._id;
	                    }

	                    //确定存在flows类型页面
	                    var isFlows = chapterData.note === 'flow';
	                    if (isFlows) {
	                        hasFlow = true;
	                    }

	                    //跳转的时候，创建新页面可以自动样式信息
	                    //优化设置，只是改变当前页面即可
	                    if (toPageAction && visibleChapterIndex !== createChapterIndex) {
	                        userStyle = undefined;
	                    }

	                    //收集页面之间可配置数据
	                    usefulData[createChapterIndex] = {
	                        isFlows: isFlows,
	                        pid: createChapterIndex,
	                        visiblePid: visibleChapterIndex,
	                        userStyle: userStyle,
	                        direction: getDirection(createChapterIndex, visibleChapterIndex)
	                    };

	                    //延迟创建
	                    //先处理style规则
	                    return function (newstyle) {
	                        //构件新的页面
	                        //masterFilter 母板过滤器回调函数
	                        var _createPageBase = function _createPageBase(masterFilter) {
	                            //初始化构建页面对象
	                            //1:page
	                            //2:master
	                            var pageBase = this.create({
	                                'pid': createChapterIndex,
	                                'visiblePid': visibleChapterIndex,
	                                'chapterData': chapterData,
	                                'isFlows': isFlows,
	                                'getStyle': newstyle[createChapterIndex],
	                                'pageIndex': pageIndex,
	                                'multiplePages': multiplePages
	                            }, pageIndex, masterFilter);

	                            //构建页面对象后
	                            //开始执行
	                            if (pageBase) {
	                                //开始线程任务
	                                //当为滑动模式,支持快速创建
	                                pageBase.startThreadTask(filpOverAction, function () {
	                                    callbackAction[action]();
	                                });

	                                //收集自定义样式的页面对象
	                                if (userStyle) {
	                                    collectPageBase.push(pageBase);
	                                }
	                            }
	                        };

	                        //母版层
	                        if (chapterData.pptMaster && self.masterMgr) {
	                            _createPageBase.call(self.masterMgr, function () {
	                                //母版是否创建等待通知
	                                //母版是共享的所以不一定每次翻页都会创建
	                                //如果需要创建,则叠加总数
	                                ++createTotal;
	                                createMaster = true;
	                            });
	                        }

	                        //页面层
	                        _createPageBase.call(self.pageMgr);
	                    };
	                }());
	            });

	            /**
	             * 创建页面的样式与翻页的布局
	             * 存在存在flows页面处理
	             * 这里创建处理的Transfrom
	             * @param  {[type]} hasFlows [description]
	             * @return {[type]}            [description]
	             */
	            var newstyle = styleConfig({
	                action: action,
	                hasFlow: hasFlow,
	                usefulData: usefulData
	            });

	            /**
	             * 执行编译
	             */
	            compile.shiftAll(newstyle).destroy();
	        }

	        /**
	         * 滑动处理
	         *  1 滑动
	         *  2 反弹
	         *  3 翻页
	         */

	    }, {
	        key: 'movePageBase',
	        value: function movePageBase(_ref) {
	            var _this = this;

	            var action = _ref.action,
	                speed = _ref.speed,
	                distance = _ref.distance,
	                leftIndex = _ref.leftIndex,
	                pageIndex = _ref.pageIndex,
	                rightIndex = _ref.rightIndex,
	                direction = _ref.direction;


	            //用户强制直接切换模式
	            //禁止页面跟随滑动
	            if (this.options.flipMode && action == 'flipMove') {
	                return;
	            }

	            var currIndex = pageIndex;

	            //移动的距离
	            var moveDist = getFlipDistance({
	                action: action,
	                distance: distance,
	                direction: direction,
	                leftIndex: leftIndex,
	                pageIndex: pageIndex,
	                rightIndex: rightIndex
	            }, getFlowDistance());

	            //视觉差页面滑动
	            var currObj = this.pageMgr.abstractGetPageObj(currIndex);
	            var chapterData = currObj.chapterData;
	            var nodes = chapterData && chapterData.nodes ? chapterData.nodes : undefined;

	            var data = {
	                nodes: nodes,
	                speed: speed,
	                action: action,
	                moveDist: moveDist,
	                leftIndex: leftIndex,
	                currIndex: currIndex,
	                rightIndex: rightIndex,
	                direction: direction
	            };

	            this.pageMgr.move(data);
	            this.masterContext(function () {
	                this.move(data);
	            });

	            //更新页码
	            if (action === 'flipOver') {
	                Xut.nextTick(function () {
	                    _this.vm.$emit('change:pageUpdate', {
	                        action: action,
	                        parentIndex: direction === 'next' ? rightIndex : leftIndex,
	                        direction: direction
	                    });
	                });
	            }
	        }

	        /**
	         * 翻页松手后
	         * 暂停页面的各种活动动作
	         * @param  {[type]} pointers [description]
	         * @return {[type]}          [description]
	         */

	    }, {
	        key: 'suspendPageBase',
	        value: function suspendPageBase(pointers) {
	            //关闭层事件
	            this.pageMgr.suspend(pointers);
	            this.masterContext(function () {
	                this.suspend(pointers);
	            });

	            //复位工具栏
	            this.vm.$emit('change:resetToolbar');
	        }

	        /**
	         * 翻页动画完毕后
	         * @return {[type]}              [description]
	         */

	    }, {
	        key: 'completePageBase',
	        value: function completePageBase(direction, pagePointer, unfliplock, isQuickTurn) {
	            //方向
	            this.direction = direction;
	            //是否快速翻页
	            this.isQuickTurn = isQuickTurn || false;
	            //解锁
	            this.unfliplock = unfliplock;
	            //清理上一个页面
	            this._clearPage(pagePointer.destroyPointer);
	            this._updatePointer(pagePointer);
	            //预创建下一页
	            this._advanceCreate(direction, pagePointer);
	        }

	        /**
	         * 页面跳转
	         * @param  {[type]} data [description]
	         * @return {[type]}      [description]
	         */

	    }, {
	        key: 'gotoPageBase',
	        value: function gotoPageBase(data) {

	            Xut.View.ShowBusy();

	            //如果是非线性,创建页面修改
	            if (!this.options.multiplePages) {
	                data.create = [data.targetIndex];
	                data.destroy = [data.currIndex];
	                data.ruleOut = [data.targetIndex];
	                data.pagePointer = {
	                    currIndex: data.targetIndex
	                };
	            }

	            //执行页面切换
	            goToPage(this, data, function (data) {
	                this._updatePointer(data.pagePointer);
	                this._autoRun({
	                    'action': 'toPage',
	                    'createPointer': data['create']
	                });
	                Xut.View.HideBusy();
	            });
	        }

	        /**
	         * 调用母版管理器
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'masterContext',
	        value: function masterContext(callback) {
	            if (this.masterMgr) {
	                callback.call(this.masterMgr);
	            }
	        }

	        /**
	         * 销毁接口
	         * 对应多场景操作
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroyPageBase',
	        value: function destroyPageBase() {
	            this.pageMgr.destroy();
	            this.masterContext(function () {
	                this.destroy();
	            });
	        }

	        /**
	         * 自动运行处理
	         *  流程四:执行自动触发动作
	         *   1.初始化创建页面完毕
	         *   2.翻页完毕
	         */

	    }, {
	        key: '_autoRun',
	        value: function _autoRun(para) {
	            var options = this.options;
	            var pagePointer = this.pagePointer;
	            var prevIndex = pagePointer.leftIndex;
	            var currIndex = pagePointer.currIndex;
	            var nextIndex = pagePointer.rightIndex;
	            var action = para ? para.action : '';
	            var createPointer = para ? para.createPointer : '';
	            var direction = this.direction;

	            //暂停的页面索引autorun
	            var suspendIndex = action === 'init' ? '' : direction === 'next' ? prevIndex : nextIndex;

	            /**
	             * 存在2中模式的情况下
	             * 转化页码标记
	             */
	            if (createPointer) {
	                createPointer = converVisiblePid.call(this, createPointer);
	            }

	            var data = {
	                'prevIndex': prevIndex,
	                'currIndex': currIndex,
	                'nextIndex': nextIndex,
	                'suspendIndex': suspendIndex,
	                'createPointer': createPointer,
	                'direction': direction,
	                'isQuickTurn': this.isQuickTurn,
	                //中断通知
	                'suspendCallback': options.suspendAutoCallback,
	                //构建完毕通知
	                'buildComplete': function buildComplete(scenarioId) {
	                    /**
	                     * 构建完成通知,用于处理历史缓存记录
	                     * 如果是调试模式 && 不是收费提示页面 && 多场景应用
	                     */
	                    if (config.recordHistory && !options.isInApp && options.multiScenario) {
	                        var history;
	                        if (history = sceneController.sequence(scenarioId, currIndex)) {
	                            $$set("history", history);
	                        }
	                    }
	                },

	                //流程结束通知
	                //包括动画都已经结束了
	                'processComplete': function processComplete() {}
	            };

	            //页面自动运行
	            this.pageMgr.autoRun(data);

	            //模板自动运行
	            this.masterContext(function () {
	                //如果动作是初始化，或者触发了母版自动运行
	                //如果是越界处理
	                //console.log(action,this.isBoundary,para.createMaster)
	                if (action || this.isBoundary) {
	                    this.autoRun(data);
	                }
	            });

	            /**
	             * 触发自动通知
	             * @type {[type]}
	             */
	            var vm = this.vm;

	            /**
	             * 初始化与跳转针对翻页案例的设置逻辑
	             * @return {[type]} [description]
	             */
	            var setToolbar = function setToolbar() {
	                //不显示首尾对应的按钮
	                if (currIndex == 0) {
	                    vm.$emit('change:hidePrev');
	                } else if (currIndex == options.pagetotal - 1) {
	                    vm.$emit('change:hideNext');
	                    vm.$emit('change:showPrev');
	                } else {
	                    vm.$emit('change:showNext');
	                    vm.$emit('change:showPrev');
	                }
	            };

	            switch (action) {
	                case 'init':
	                    //更新页码标示
	                    vm.$emit('change:pageUpdate', {
	                        action: action,
	                        parentIndex: currIndex,
	                        direction: direction
	                    });
	                    setToolbar.call(this);
	                    break;
	                case 'toPage':
	                    //更新页码标示
	                    vm.$emit('change:pageUpdate', {
	                        action: action,
	                        parentIndex: currIndex,
	                        direction: direction
	                    });
	                    setToolbar.call(this);
	                    break;
	            }

	            /**
	             * 线性结构
	             * 保存目录索引
	             */
	            if (!options.multiScenario) {
	                $$set("pageIndex", currIndex);
	            }

	            /**
	             * 解锁翻页
	             * 允许继续执行下一个翻页作用
	             */
	            if (this.unfliplock) {
	                this.unfliplock();
	                this.unfliplock = null;
	            }

	            //关闭快速翻页
	            this.isQuickTurn = false;
	        }

	        /**
	         * 清理页面结构
	         * @param  {[type]} clearPageIndex [description]
	         * @return {[type]}                [description]
	         */

	    }, {
	        key: '_clearPage',
	        value: function _clearPage(clearPageIndex) {
	            this.pageMgr.clearPage(clearPageIndex);
	        }

	        /**
	         * 更新页码索引标示
	         * @param  {[type]} pagePointer [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_updatePointer',
	        value: function _updatePointer(pagePointer) {
	            this.pagePointer = pagePointer;
	        }

	        /**
	         * 预创建新页面
	         * @param  {[type]} direction   [description]
	         * @param  {[type]} pagePointer [description]
	         * @return {[type]}             [description]
	         */

	    }, {
	        key: '_advanceCreate',
	        value: function _advanceCreate(direction, pagePointer) {
	            var _this2 = this;

	            var pagetotal = this.options.pagetotal;
	            var vm = this.vm;
	            var createPointer = pagePointer.createPointer;

	            //清理页码
	            var clearPointer = function clearPointer() {
	                delete pagePointer.createPointer;
	                delete pagePointer.destroyPointer;
	            };

	            //创建新的页面对象
	            var createNextPageBase = function createNextPageBase(currIndex) {
	                return _this2.createPageBase([createPointer], currIndex, 'flipOver');
	            };

	            //如果是左边翻页
	            if (direction === 'prev') {
	                //首尾无须创建页面
	                if (pagePointer.currIndex === 0) {
	                    this._autoRun();
	                    if (pagetotal == 2) {
	                        //如果总数只有2页，那么首页的按钮是关闭的，需要显示
	                        vm.$emit('change:showNext');
	                    }
	                    vm.$emit('change:hidePrev');
	                    return;
	                }
	                if (pagePointer.currIndex > -1) {
	                    //创建的页面
	                    createNextPageBase(pagePointer.currIndex);
	                    clearPointer();
	                    vm.$emit('change:showNext');
	                    return;
	                }
	            }

	            //如果是右边翻页
	            if (direction === 'next') {
	                //首尾无须创建页面
	                if (pagePointer.currIndex === pagetotal - 1) {
	                    this._autoRun();
	                    if (pagetotal == 2) {
	                        //如果总数只有2页，那么首页的按钮是关闭的，需要显示
	                        vm.$emit('change:showPrev');
	                    }
	                    //多页处理
	                    vm.$emit('change:hideNext');
	                    return;
	                }
	                if (createPointer < pagetotal) {
	                    //创建的页面
	                    createNextPageBase(pagePointer.currIndex);
	                    clearPointer();
	                    vm.$emit('change:showPrev');
	                    return;
	                }
	            }

	            clearPointer();

	            return;
	        }

	        /**
	         * 加载页面事件与动作
	         * @param  {[type]} action [description]
	         * @return {[type]}        [description]
	         */

	    }, {
	        key: '_loadPage',
	        value: function _loadPage(action) {
	            var _this3 = this;

	            var self = this;

	            //触发自动任务
	            var triggerAuto = function triggerAuto() {
	                var $cover = $(".xut-cover");
	                if ($cover.length) {
	                    $cover.animate({
	                        opacity: 0
	                    }, 1000, function () {
	                        $cover.hide().remove();
	                        self._autoRun({
	                            'action': action
	                        });
	                    });
	                } else {
	                    self._autoRun({
	                        'action': action
	                    });
	                    $cover = null;
	                    self = null;
	                }
	            };

	            //创建完成回调
	            this.vm.$emit('change:createComplete', function () {
	                if (_this3.options.multiScenario) {
	                    triggerAuto();
	                }
	                //第一次加载
	                //进入应用
	                else {
	                        if (window.GLOBALIFRAME) {
	                            triggerAuto();
	                            return;
	                        }
	                        //获取应用的状态
	                        if (Xut.Application.getAppState()) {
	                            //保留启动方法
	                            var pre = Xut.Application.LaunchApp;
	                            Xut.Application.LaunchApp = function () {
	                                pre();
	                                triggerAuto();
	                            };
	                        } else {
	                            triggerAuto();
	                        }
	                    }
	            });
	        }
	    }]);
	    return Dispatcher;
	}();

	//委托事件处理钩子
	var delegateHooks = {

	    /**
	     * 超连接,跳转
	     * svg内嵌跳转标记处理
	     */
	    'data-xxtlink': function dataXxtlink(target, attribute, rootNode, pageIndex) {
	        try {
	            var para = attribute.split('-');
	            if (para.length > 1) {
	                //如果有多个就是多场景的组合
	                Xut.View.GotoSlide(para[0], para[1]);
	            } else {
	                Xut.View.GotoSlide(para[0]);
	            }
	        } catch (err) {
	            console.log('跳转错误');
	        }
	    },


	    /**
	     * Action', 'Widget', 'Video', 'ShowNote', 'SubDoc'委托
	     * arg
	     *   target, attribute, rootNode, pageIndex
	     */
	    'data-delegate': function dataDelegate(target, attribute, rootNode, pageIndex) {
	        $$trigger.apply(null, arguments);
	    },


	    /**
	     * 有效,可滑动
	     */
	    'data-flow': function dataFlow() {},


	    /**
	     * 如果是canvas节点
	     */
	    'data-canvas': function dataCanvas(cur) {
	        // alert(1)
	    }
	};

	/**
	 * 简化委托处理，默认一层元素只能绑定一个委托事件
	 */
	function closestProcessor(event, pageType) {

	    var i,
	        k,
	        attribute,
	        attributes,
	        value,
	        cur = event.target;

	    if (cur.nodeType) {
	        //如果触发点直接是li
	        if (cur === this) {
	            return {
	                'rootNode': this,
	                'elem': cur,
	                'handlers': delegateHooks['data-container']
	            };
	        }
	        //否则是内部的节点
	        try {
	            for (; cur !== this; cur = cur.parentNode || this) {
	                //如果是canvas节点
	                if (cur.nodeName && cur.nodeName.toLowerCase() === 'canvas') {
	                    //是否为滑动行为
	                    if (Xut.Contents.Canvas.getSupportState()) {
	                        return true;
	                    } else {
	                        return false;
	                    }
	                }
	                //如果是dom节点
	                attributes = cur['attributes'];
	                for (k in delegateHooks) {
	                    if (attribute = attributes[k]) {
	                        value = attribute['value' || 'nodeValue'];
	                        return {
	                            'rootNode': this,
	                            'elem': cur,
	                            'attribute': value,
	                            'pageType': pageType,
	                            'handlers': delegateHooks[k]
	                        };
	                    }
	                }
	            }
	        } catch (err) {
	            // config.isBrowser && console.log('默认事件跟踪', err)
	        }
	    }
	}

	var typeFilter = ['page', 'master'];

	/**
	 * 合并参数设置
	 * 1 pageMgr
	 * 2 masterMgr
	 * 3 修正pageType
	 * 4 args参数
	 * 5 回调每一个上下文
	 */
	var createaAccess = function createaAccess(mgr) {
	    return function (callback, pageType, args, eachContext) {
	        //如果第一个参数不是pageType模式
	        //参数移位
	        if (pageType !== undefined && -1 === typeFilter.indexOf(pageType)) {
	            var temp = args;
	            args = pageType;
	            eachContext = temp;
	            pageType = 'page';
	        }

	        //pageIndex为pageType参数
	        if (-1 !== typeFilter.indexOf(args)) {
	            pageType = args;
	            args = null;
	        }

	        pageType = pageType || 'page';

	        if (mgr[pageType]) {
	            return callback(mgr[pageType], pageType, args, eachContext);
	        } else {
	            // console.log('传递到access的pageType错误！')
	        }
	    };
	};

	/**
	 * 判断是否存在页码索引
	 * 如果不存在默认取当前页面
	 */
	var createExistIndex = function createExistIndex($globalEvent) {
	    return function (pageIndex) {
	        //如果不存在
	        if (pageIndex == undefined) {
	            pageIndex = $globalEvent.getHindex(); //当前页面
	        }
	        return pageIndex;
	    };
	};

	function setDynamicApi(vm) {

	    var $globalEvent = vm.$globalEvent;
	    var options = vm.options;
	    var $dispatcher = vm.$dispatcher;

	    //页面与母版的管理器
	    var access = createaAccess({
	        page: $dispatcher.pageMgr,
	        master: $dispatcher.masterMgr
	    });

	    var isExistIndex = createExistIndex($globalEvent);

	    /**
	     * 获取当前页码
	     */
	    Xut.Presentation.GetPageIndex = function () {
	        return $globalEvent.getHindex();
	    };

	    /**
	     * 获取页面的总数据
	     * 1 chapter数据
	     * 2 section数据
	     * @return {[type]}
	     */
	    _.each(["Section", "Page"], function (apiName) {
	        Xut.Presentation['GetApp' + apiName + 'Data'] = function (callback) {
	            var i = 0,
	                temp = [],
	                cps = Xut.data.query('app' + apiName),
	                cpsLength = cps.length;
	            for (i; i < cpsLength; i++) {
	                temp.push(cps.item(i));
	            }
	            return temp;
	        };
	    });

	    /**
	     * 获取首页的pageId
	     * @param {[type]} seasonId [description]
	     */
	    Xut.Presentation.GetFirstPageId = function (seasonId) {
	        var sectionRang = Xut.data.query('sectionRelated', seasonId);
	        var pageData = Xut.data.query('appPage');
	        return pageData.item(sectionRang.start);
	    };

	    /**
	     *  四大数据接口
	     *  快速获取一个页面的nodes值
	     *  获取当前页面的页码编号 - chapterId
	     *  快速获取指定页面的chapter数据
	     *  pagebase页面管理对象
	     * @return {[type]}            [description]
	     */
	    _.each(["GetPageId", "GetPageNode", "GetPageData", "GetPageObj"], function (apiName) {
	        Xut.Presentation[apiName] = function (pageType, pageIndex) {
	            return access(function (manager, pageType, pageIndex) {
	                pageIndex = isExistIndex(pageIndex);
	                return manager["abstract" + apiName](pageIndex, pageType);
	            }, pageType, pageIndex);
	        };
	    });

	    /**
	     * 得到页面根节点
	     * li节点
	     */
	    Xut.Presentation.GetPageElement = function () {
	        var obj = Xut.Presentation.GetPageObj();
	        return obj.$pageNode;
	    };

	    /**
	     * 获取页码标记
	     * 因为非线性的关系，页面都是按chpater组合的
	     * page_0
	     * page_10
	     * 但是每一个章节页面的索引是从0开始的
	     * 区分pageIndex
	     */
	    Xut.Presentation.GetPagePrefix = function (pageType, pageIndex) {
	        var pageObj = Xut.Presentation.GetPageObj(pageType, pageIndex);
	        return pageObj.pid;
	    };

	    //命名前缀
	    var prefix = 'Content_';

	    /**
	     * 创建一个content的命名规则
	     */
	    Xut.Presentation.MakeContentPrefix = function (pageIndex) {
	        return prefix + Xut.Presentation.GetPagePrefix(pageIndex) + "_";
	    };

	    /**
	     * 获取命名规则
	     */
	    Xut.Presentation.GetContentName = function (id) {
	        if (id) {
	            return prefix + Xut.Presentation.GetPagePrefix() + "_" + id;
	        } else {
	            return prefix + Xut.Presentation.GetPagePrefix();
	        }
	    };

	    /**
	     * 设置页面的potion编码
	     * 为分栏修改
	     */
	    Xut.View.setPointer = function (pageIndex) {
	        $globalEvent.setPointer(pageIndex);
	    };

	    /**
	     * 更新页码
	     * @param {[type]} point [description]
	     *   parentIndex  父索引
	     *   subIndex     子索引
	     */
	    Xut.View.PageUpdate = function () {
	        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
	            arg[_key] = arguments[_key];
	        }

	        vm.$emit.apply(vm, ['change:pageUpdate'].concat(arg));
	    };

	    /**
	     * 显示工具栏
	     * 没有参数显示 工具栏与控制翻页按钮
	     * 有参数单独显示指定的
	     */
	    Xut.View.ShowToolBar = function (point) {
	        vm.$emit('change:toggleToolbar', 'show', point);
	    };

	    /**
	     * 隐藏工具栏
	     * 没有参数隐藏 工具栏与控制翻页按钮
	     * 有参数单独隐藏指定
	     */
	    Xut.View.HideToolBar = function (point) {
	        vm.$emit('change:toggleToolbar', 'hide', point);
	    };

	    /**
	     * 指定特定的显示与隐藏
	     *  Xut.View.Toolbar({
	     *       show :'bottom',
	     *       hide :'controlBar'
	     *   })
	     *
	     *  //工具栏与翻页按钮全部显示/隐藏
	     *  Xut.View.Toolbar('show')
	     *  Xut.View.Toolbar('hide')
	     *
	     * @return {[type]} [description]
	     */
	    Xut.View.Toolbar = function (cfg) {
	        vm.$emit('change:toggleToolbar', cfg);
	    };

	    /**
	     * 跳转到上一个页面
	     */
	    Xut.View.GotoPrevSlide = function (seasonId, chapterId) {
	        if (seasonId && chapterId) {
	            Xut.View.LoadScenario({
	                'scenarioId': seasonId,
	                'chapterId': chapterId
	            });
	            return;
	        }

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
	            location.href = Xut.IBooks.pageIndex - 1 + ".xhtml";
	            return;
	        }

	        options.multiplePages && $globalEvent.prev();
	    };

	    /**
	     * 跳转到下一个页面
	     */
	    Xut.View.GotoNextSlide = function (seasonId, chapterId) {
	        if (seasonId && chapterId) {
	            Xut.View.LoadScenario({
	                'scenarioId': seasonId,
	                'chapterId': chapterId
	            });
	            return;
	        }

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
	            location.href = Xut.IBooks.pageIndex + 1 + ".xhtml";
	            return;
	        }

	        options.multiplePages && $globalEvent.next();
	    };

	    /**
	     * 跳转页面
	     * 场景内部切换
	     * 跳转到指定编号的页面
	     * Action 类型跳转
	     * xxtlink 超连接跳转,svg内嵌跳转标记处理
	     * 文本框跳转
	     * ........
	     */
	    Xut.View.GotoSlide = function (seasonId, chapterId) {

	        //修正参数
	        var fixParameter = function fixParameter(pageIndex) {
	            pageIndex = Number(pageIndex) - 1;
	            if (pageIndex < 0) {
	                pageIndex = 0;
	            }
	            return pageIndex;
	        };

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (Xut.IBooks.Enabled && Xut.IBooks.runMode() && chapterId) {
	            location.href = chapterId + ".xhtml";
	            return;
	        }

	        //兼容数据错误
	        if (!seasonId && !chapterId) return;

	        //如果是一个参数是传递页码数,则为内部跳转
	        if (arguments.length === 1) {
	            //复位翻页按钮
	            vm.$emit('change:showNext');
	            return $globalEvent.scrollToPage(fixParameter(seasonId));
	        }

	        //场景模式内部跳转
	        if (options.scenarioId == seasonId) {
	            //chpaterId 转化成实际页码
	            var sectionRang = Xut.data.query('sectionRelated', seasonId);
	            var pageIndex = chapterId - sectionRang.start;
	            vm.$emit('change:showNext');
	            return $globalEvent.scrollToPage(fixParameter(pageIndex));
	        }

	        //场景与场景的跳转
	        return Xut.View.LoadScenario({
	            'scenarioId': seasonId,
	            'chapterId': chapterId
	        });
	    };

	    /**
	     * 是否为翻页的边界
	     * @return {Boolean} [description]
	     */
	    Xut.View.isFlipBorderBounce = function (distance) {
	        return $globalEvent.isBorder(distance);
	    };

	    /**
	     * 页面滑动
	     * @param {[type]} distance  [description]
	     * @param {[type]} speed     [description]
	     * @param {[type]} direction [description]
	     * @param {[type]} action    [description]
	     */
	    Xut.View.MovePage = function (distance, speed, direction, action) {

	        //如果禁止翻页模式 || 如果是滑动,不是边界
	        if (!options.multiplePages || $globalEvent.isMoving() || action === 'flipMove' && $globalEvent.isBorder(distance)) {
	            return;
	        }

	        var pagePointer = $globalEvent.getPointer();
	        var data = {
	            'distance': distance,
	            'speed': speed,
	            'direction': direction,
	            'action': action,
	            'leftIndex': pagePointer.leftIndex,
	            'pageIndex': pagePointer.currIndex,
	            'rightIndex': pagePointer.rightIndex
	        };
	        $dispatcher.movePageBase(data);
	    };

	    /**
	     * 辅助对象的控制接口
	     * 运行辅助动画
	     * 辅助对象的activityId,或者合集activityId
	     * Run
	     * stop
	     * 1 零件
	     * 2 音频动画
	     */
	    _.each(["Run", "Stop"], function (apiName) {
	        Xut.Assist[apiName] = function (pageType, activityId, outCallBack) {
	            access(function (manager, pageType, activityId, outCallBack) {
	                //数组
	                if (_.isArray(activityId)) {
	                    //完成通知
	                    var markComplete = function () {
	                        var completeStatistics = activityId.length; //动画完成统计
	                        return function () {
	                            if (completeStatistics === 1) {
	                                outCallBack && outCallBack();
	                                markComplete = null;
	                            }
	                            completeStatistics--;
	                        };
	                    }();
	                    _.each(activityId, function (id) {
	                        manager.abstractAssistAppoint(id, $globalEvent.getHindex(), markComplete, apiName);
	                    });
	                } else {
	                    manager.abstractAssistAppoint(activityId, $globalEvent.getHindex(), outCallBack, apiName);
	                }
	            }, pageType, activityId, outCallBack);
	        };
	    });

	    /**
	     * 针对page页面的content类型操作接口
	     * @type {[type]}
	     */

	    /**
	     * 获取指定的对象
	     * 传递参数
	     * 单一 id
	     * 数据id合集 [1,2,4,5,6]
	     * @param {[type]}   contentIds  [description]
	     * @param {Function} eachContext 回调遍历每一个上下文
	     */
	    Xut.Contents.Get = function (pageType, contentIds, eachContext) {

	        return access(function (manager, pageType, contentIds, eachContext) {

	            var contentObj,
	                contentObjs,
	                pageIndex = Xut.Presentation.GetPageIndex();

	            function findContent(currIndex, contentId) {
	                var pageObj;
	                if (pageObj = manager.abstractGetPageObj(currIndex)) {
	                    return pageObj.baseGetContentObject(contentId);
	                }
	            }

	            //如果传递是数组合集
	            if (_.isArray(contentIds)) {
	                contentObjs = [];
	                _.each(contentIds, function (id) {
	                    contentObj = findContent(pageIndex, id);
	                    if (eachContext) {
	                        //传递每一个处理的上下文
	                        eachContext(id, contentObj);
	                    } else {
	                        if (contentObj) {
	                            contentObjs.push(contentObj);
	                        } else {
	                            Xut.log('error', '找不到对应的content数据' + id);
	                        }
	                    }
	                });
	                return contentObjs;
	            }

	            //如果传递的是Content_1_3组合情况
	            if (/_/.test(contentIds)) {
	                var expr = contentIds.split('_');
	                if (expr.length > 1) {
	                    return findContent(expr[1], expr[2]);
	                }
	            }

	            //单一content id
	            contentObj = findContent(pageIndex, contentIds);

	            if (eachContext) {
	                eachContext(contentObj);
	            } else {
	                return contentObj;
	            }
	        }, pageType, contentIds, eachContext);
	    };

	    /**
	     * 得到指定页面零件的数据
	     * 获取指定的content数据
	     * @param  {[type]} contentId [description]
	     * @return {[type]}           [description]
	     */
	    Xut.Contents.GetPageWidgetData = function (pageType, contentId) {

	        //如果没有传递pageType取默认
	        if (-1 === typeFilter.indexOf(pageType)) {
	            contentId = pageType;
	            pageType = 'page';
	        }

	        //必须有数据
	        if (!contentId || !contentId.length) {
	            return;
	        }

	        //保证是数组格式
	        if (_.isString(contentId)) {
	            contentId = [contentId];
	        }

	        var contentDas,
	            contents = [];

	        Xut.Contents.Get(pageType, contentId, function (cid, content) {
	            //是内部对象
	            if (content && (contentDas = content.contentDas)) {
	                //通过内部管理获取对象
	                contents.push({
	                    'id': content.id,
	                    'idName': content.actName,
	                    'element': content.$contentNode,
	                    'theTitle': contentDas.theTitle,
	                    'scaleHeight': contentDas.scaleHeight,
	                    'scaleLeft': contentDas.scaleLeft,
	                    'scaleTop': contentDas.scaleTop,
	                    'scaleWidth': contentDas.scaleWidth,
	                    'contentData': contentDas,
	                    'source': 'innerObjet' //获取方式内部对象
	                });
	            } else {
	                //如果通过内部找不到对象的content数据,则直接查找数据库
	                //可能是一个事件的钩子对象
	                if (contentDas = seekQuery(cid)) {
	                    var actName = Xut.Presentation.GetContentName(cid);
	                    var element;
	                    //如果对象是事件钩子或者是浮动对象
	                    //没有具体的数据
	                    if (content && content.$contentNode) {
	                        element = content.$contentNode;
	                    } else {
	                        element = $('#' + actName);
	                    }
	                    contents.push({
	                        'id': cid,
	                        'idName': actName,
	                        'element': element,
	                        'theTitle': contentDas.theTitle,
	                        'scaleHeight': contentDas.scaleHeight,
	                        'scaleLeft': contentDas.scaleLeft,
	                        'scaleTop': contentDas.scaleTop,
	                        'scaleWidth': contentDas.scaleWidth,
	                        'contentData': contentDas,
	                        'source': 'dataBase'
	                    });
	                } else {
	                    Xut.log('error', '找不到对应的GetPageWidgetData数据' + cid);
	                }
	            }
	        });
	        return contents;
	    };

	    //数据库查找
	    function seekQuery(id) {
	        var contentData = Xut.data.query('Content', id);
	        if (contentData) {
	            return reviseSize(_.extend({}, contentData));
	        }
	    }

	    /**
	     * 互斥接口
	     * 直接显示\隐藏\停止动画
	     */

	    //检测类型为字符串
	    function typeCheck(objNameList) {
	        return !objNameList || typeof objNameList !== 'string' ? true : false;
	    }

	    /**
	     * 针对文本对象的直接操作
	     * 显示
	     * 隐藏
	     * 停止动画
	     */
	    _.each(["Show", "Hide", "StopAnim"], function (operate) {
	        Xut.Contents[operate] = function (pageType, nameList) {
	            access(function (manager, pageType, nameList) {
	                if (typeCheck(nameList)) return;
	                var pageBaseObj;
	                if (!(pageBaseObj = manager.abstractAssistPocess($globalEvent.getHindex()))) {
	                    console.log('注入互斥接口数据错误！');
	                    return;
	                }
	                _.each(nameList.split(','), function (contentId) {
	                    pageBaseObj.baseContentMutex(contentId, operate);
	                });
	            }, pageType, nameList);
	        };
	    });

	    /**
	     * 获取一个存在的实例对象
	     * 区分不同层级page/master
	     * 不同类型    content/widget
	     */
	    Xut.Application.GetSpecifiedObject = function (pageType, data) {
	        return access(function (manager, pageType) {
	            var pageObj;
	            if (pageObj = manager.abstractGetPageObj(data.pageIndex)) {
	                if (data.type === 'Content') {
	                    return pageObj.baseSpecifiedContent(data);
	                } else {
	                    return pageObj.baseSpecifiedComponent(data);
	                }
	            }
	        }, pageType);
	    };

	    /**
	     * 应用滑动接口
	     * @return {[type]}
	     */

	    /**
	     * 是否翻页中
	     * @return {Boolean} [description]
	     */
	    Xut.Application.Swiping = function () {
	        return $globalEvent.isMoving();
	    };

	    /**
	     * 禁止滑动
	     */
	    Xut.Application.Bansliding = function () {
	        $globalEvent.bansliding();
	    };

	    /**
	     * 允许滑动
	     */
	    Xut.Application.Allowliding = function () {
	        $globalEvent.allowliding();
	    };

	    /**
	     * 设置翻页完成
	     */
	    Xut.Application.SetTransitionComplete = function () {
	        $globalEvent.setTransitionComplete();
	    };

	    _.each(["closeSwipe", "openSwipe"], function (operate) {
	        Xut.Application[operate] = function () {
	            $globalEvent[operate]();
	        };
	    });

	    return function () {
	        $globalEvent = null;
	        $dispatcher = null;
	        access = null;
	        isExistIndex = null;
	    };
	}

	/**
	 * 配置多页面参数
	 * @return {[type]} [description]
	 */
	var configMultiple = function configMultiple(options) {
	    //如果是epub,强制转换为单页面
	    if (Xut.IBooks.Enabled) {
	        options.multiplePages = false;
	    } else {
	        //判断多页面情况
	        //1 数据库定义
	        //2 系统优化
	        options.multiplePages = options.flipMode ? options.flipMode : options.pageMode ? true : false;
	    }
	};

	/**
	 * 判断处理那个页面层次
	 * 找到pageType类型
	 * 项目分4个层
	 * page mater page浮动 mater浮动
	 * 通过
	 * 因为冒泡的元素，可能是页面层，也可能是母板上的
	 * @return {Boolean} [description]
	 */
	var isBelong = function isBelong(target) {
	    var pageType = 'page';
	    if (target.dataset && target.dataset.belong) {
	        pageType = target.dataset.belong;
	    }
	    return pageType;
	};

	/**
	 * 阻止元素的默认行为
	 * 在火狐下面image带有href的行为
	 * 会自动触发另存为
	 * @return {[type]} [description]
	 *
	 * 2016.3.18
	 * 妙妙学 滚动插件默认行为被阻止
	 *
	 * 2016.7.26
	 * 读库强制PC模式了
	 */
	var preventDefault = function preventDefault(evtObj, target) {
	    //var tagName = target.nodeName.toLowerCase();
	    if (Xut.plat.isBrowser && !Xut.IBooks.Enabled && !window.MMXCONFIG && !window.DUKUCONFIG) {
	        evtObj.preventDefault && evtObj.preventDefault();
	    }
	};

	var Mediator = function (_Observer) {
	    inherits(Mediator, _Observer);

	    function Mediator(parameter) {
	        classCallCheck(this, Mediator);

	        var _this = possibleConstructorReturn(this, (Mediator.__proto__ || Object.getPrototypeOf(Mediator)).call(this));

	        var vm = _this;

	        //配置文件
	        var options = vm.options = _.extend({
	            //是否多场景加载
	            //单页场景 false
	            //多场景   true
	            'multiScenario': false,
	            //是否为连续页面
	            //通过pageMode的参数定义
	            'multiplePages': false
	        }, parameter, {
	            flipMode: Xut.config.flipMode
	        });

	        //配置多页面参数
	        configMultiple(options);

	        var $globalEvent = vm.$globalEvent = new Swipe(options);
	        var $dispatcher = vm.$dispatcher = new Dispatcher(vm);

	        //如果是主场景,才能切换系统工具栏
	        if (options.multiplePages) {
	            _this.addTools(vm);
	        }

	        //事件句柄对象
	        var handlerObj = null;

	        /**
	         * 过滤器.全局控制函数
	         * return true 阻止页面滑动
	         */
	        $globalEvent.$watch('onFilter', function (hookCallback, point, evtObj) {
	            var target = point.target;
	            //阻止默认行为
	            preventDefault(evtObj, target);
	            //页面类型
	            var pageType = isBelong(target);
	            //冒泡的ul根节点
	            var parentNode = $globalEvent.findBubbleRootNode(point, pageType);
	            //执行过滤处理
	            handlerObj = closestProcessor.call(parentNode, point, pageType);
	            //停止翻页,针对content对象可以拖动,滑动的情况处理
	            if (!handlerObj || handlerObj.attribute === 'disable') {
	                hookCallback();
	            }
	        });

	        /**
	         * 触屏滑动,通知pageMgr处理页面移动
	         * @return {[type]} [description]
	         */
	        $globalEvent.$watch('onMove', function (data) {
	            $dispatcher.movePageBase(data);
	        });

	        /**
	         * 触屏松手点击
	         * 无滑动
	         */
	        $globalEvent.$watch('onTap', function (pageIndex, hookCallback) {
	            if (handlerObj) {
	                if (handlerObj.handlers) {
	                    handlerObj.handlers(handlerObj.elem, handlerObj.attribute, handlerObj.rootNode, pageIndex);
	                } else {
	                    if (!Xut.Contents.Canvas.getIsTap()) {
	                        vm.$emit('change:toggleToolbar');
	                    }
	                }
	                handlerObj = null;
	                hookCallback();
	            }
	        });

	        /**
	         * 触屏滑动,通知ProcessMgr关闭所有激活的热点
	         * @return {[type]}          [description]
	         */
	        $globalEvent.$watch('onUpSlider', function (pointers) {
	            $dispatcher.suspendPageBase(pointers);
	        });

	        /**
	         * 翻页动画完成回调
	         * @return {[type]}              [description]
	         */
	        $globalEvent.$watch('onComplete', function () {
	            $dispatcher.completePageBase.apply($dispatcher, arguments);
	        });

	        /**
	         * 切换页面
	         * @return {[type]}      [description]
	         */
	        $globalEvent.$watch('onJumpPage', function (data) {
	            $dispatcher.gotoPageBase(data);
	        });

	        /**
	         * 退出应用
	         * @return {[type]}      [description]
	         */
	        $globalEvent.$watch('onDropApp', function (data) {
	            window.GLOBALIFRAME && Xut.publish('magazine:dropApp');
	        });

	        /**
	         * 母板移动反馈
	         * 只有存在data-parallaxProcessed
	         * 才需要重新激活对象
	         * 删除parallaxProcessed
	         */
	        $globalEvent.$watch('onMasterMove', function (hindex, target) {
	            if (/Content/i.test(target.id) && target.getAttribute('data-parallaxProcessed')) {
	                $dispatcher.masterMgr && $dispatcher.masterMgr.reactivation(target);
	            }
	        });

	        /**
	         * 销毁接口api
	         * @type {[type]}
	         */
	        _this.destoryDynamicApi = setDynamicApi(_this);
	        return _this;
	    }

	    /**
	     * 系统工具栏
	     */


	    createClass(Mediator, [{
	        key: 'addTools',
	        value: function addTools(vm) {

	            _.extend(delegateHooks, {

	                /**
	                 * li节点,多线程创建的时候处理滑动
	                 */
	                'data-container': function dataContainer() {
	                    vm.$emit('change:toggleToolbar');
	                },


	                /**
	                 * 是背景层
	                 */
	                'data-multilayer': function dataMultilayer() {
	                    //改变工具条状态
	                    vm.$emit('change:toggleToolbar');
	                },


	                /**
	                 * 默认content元素可以翻页
	                 */
	                'data-behavior': function dataBehavior(target, attribute, rootNode, pageIndex) {
	                    //没有事件的元素,即可翻页又可点击切换工具栏
	                    if (attribute == 'click-swipe') {
	                        vm.$emit('change:toggleToolbar');
	                    }
	                }
	            });
	        }
	    }]);
	    return Mediator;
	}(Observer);

	defAccess(Mediator.prototype, '$multiScenario', {
	    get: function get() {
	        return this.options.multiScenario;
	    }
	});

	/**
	 * 动态注入对象接口
	 * 注入对象管理,注册所有widget组件对象
	 *  content类型  创建时注册
	 *  widget类型   执行时注册
	 *  widget 包括 视频 音频 Action 子文档 弹出口 类型
	 *  这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
	 */
	defAccess(Mediator.prototype, '$injectionComponent', {
	    set: function set(regData) {
	        var injection;
	        if (injection = this.$dispatcher[regData.pageType + 'Mgr']) {
	            injection.abstractAssistPocess(regData.pageIndex, function (pageObj) {
	                pageObj.baseRegisterComponent.call(pageObj, regData.widget);
	            });
	        } else {
	            console.log('注册injection失败,regData=' + regData);
	        }
	    }
	});

	/**
	 * 得到当前的视图页面
	 * @return {[type]}   [description]
	 */
	defAccess(Mediator.prototype, '$curVmPage', {
	    get: function get() {
	        return this.$dispatcher.pageMgr.abstractGetPageObj(this.$globalEvent.getHindex());
	    }
	});

	/**
	 *  监听viewmodel内部的状态的改变,触发后传入值
	 *
	 *  与状态有关的change:
	 *      翻页
	 *          'flipOver' : function(pageIndex) {},
	 *
	 *      切换工具栏
	 *          'toggleToolbar' : function(state, pointer) {},
	 *
	 *      复位工具栏
	 *          'resetToolbar'  : function() {},
	 *
	 *      隐藏下一页按钮
	 *          'hideNext'   : function(state) {},
	 *
	 *      显示下一页按钮
	 *          'showNext'   : function() {}
	 *
	 *  与创建相关
	 *      创建完毕回调
	 *          'createComplete': null,
	 *      创建后中断自动运行回调
	 *          'suspendAutoCallback': null
	 *
	 */
	def$1(Mediator.prototype, '$bind', function (key, callback) {
	    var vm = this;
	    vm.$watch('change:' + key, function () {
	        callback.apply(vm, arguments);
	    });
	});

	/**
	 * 创建页面
	 * @return {[type]} [description]
	 */
	def$1(Mediator.prototype, '$init', function () {
	    this.$dispatcher.initCreate();
	});

	/**
	 * 运动动画
	 * @return {[type]} [description]
	 */
	def$1(Mediator.prototype, '$run', function () {
	    var vm = this;
	    vm.$dispatcher.pageMgr.activateAutoRuns(vm.$globalEvent.getHindex(), Xut.Presentation.GetPageObj());
	});

	/**
	 * 复位对象
	 * @return {[type]} [description]
	 */
	def$1(Mediator.prototype, '$reset', function () {
	    return this.$dispatcher.pageMgr.resetOriginal(this.$globalEvent.getHindex());
	});

	/**
	 * 停止所有任务
	 * @return {[type]} [description]
	 */
	def$1(Mediator.prototype, '$suspend', function () {
	    Xut.Application.Stop({
	        skipAudio: true //跨页面不处理
	    });
	});

	/**
	 * 销毁场景内部对象
	 * @return {[type]} [description]
	 */
	def$1(Mediator.prototype, '$destroy', function () {
	    this.$off(); //观察事件
	    this.$globalEvent.destroy(); //全局事件
	    this.$dispatcher.destroyPageBase(); //派发器
	    this.$dispatcher = null;
	    this.$globalEvent = null;
	    this.destoryDynamicApi(); //动态api
	});

	var round$1 = Math.round;
	var ratio$1 = 6;
	var isIOS$5 = Xut.plat.isIOS;
	var TOP$1 = isIOS$5 ? 20 : 0;

	/**
	 * 主场景
	 * @return {[type]} [description]
	 */
	function mainScene() {

	    var iconHeight = config.iconHeight;
	    var proportion = config.proportion;

	    var sWidth = config.viewSize.width;
	    var sHeight = config.viewSize.height;

	    //横版模式
	    var isHorizontal = config.layoutMode == 'horizontal';

	    proportion = isHorizontal ? proportion.width : proportion.height;
	    iconHeight = isIOS$5 ? iconHeight : round$1(proportion * iconHeight);

	    var navBarWidth = isHorizontal ? '100%' : Math.min(sWidth, sHeight) / (isIOS$5 ? 8 : 3) + 'px';
	    var navBarHeight = isHorizontal ? round$1(sHeight / ratio$1) : round$1((sHeight - iconHeight - TOP$1) * 0.96);
	    var navBarTop = isHorizontal ? '' : 'top:' + (iconHeight + TOP$1 + 2) + 'px;';
	    var navBarLeft = isHorizontal ? '' : 'left:' + iconHeight + 'px;';
	    var navBarBottom = isHorizontal ? 'bottom:4px;' : '';
	    var navBaroOverflow = isHorizontal ? 'hidden' : 'visible';

	    //导航
	    var navBarHTML = '<div class="xut-nav-bar"\n              style="width:' + navBarWidth + ';\n                     height:' + navBarHeight + 'px;\n                     ' + navBarTop + '\n                     ' + navBarLeft + '\n                     ' + navBarBottom + '\n                     background-color:white;\n                     border-top:1px solid rgba(0,0,0,0.1);\n                     overflow:' + navBaroOverflow + ';">\n        </div>';

	    var homeWidth = config.viewSize.width;
	    // const homeHeight = config.viewSize.height
	    var homeLeft = config.viewSize.left;
	    var homeIndex = Xut.sceneController.createIndex();
	    var homeOverflow = config.visualMode === 1 ? 'visible' : 'hidden';

	    //主体
	    var homeHTML = '<div id="xut-main-scene"\n              style="width:' + homeWidth + 'px;\n                     height:100%;\n                     top:0;\n                     left:' + homeLeft + 'px;\n                     position:absolute;\n                     z-index:' + homeIndex + ';\n                     overflow:' + homeOverflow + ';">\n\n            <div id="xut-control-bar" class="xut-control-bar"></div>\n            <ul id="xut-page-container" class="xut-flip"></ul>\n            <ul id="xut-master-container" class="xut-master xut-flip"></ul>\n            ' + navBarHTML + '\n            <div id="xut-tool-tip"></div>\n        </div>';

	    return String.styleFormat(homeHTML);
	}

	/**
	 * 副场景
	 * @param  {[type]} options [description]
	 * @return {[type]}         [description]
	 */
	function deputyScene(id) {

	    var scenarioId = 'scenario-' + id;
	    var overflow = config.visualMode === 1 ? 'visible' : 'hidden';
	    var pageId = 'scenarioPage-' + id;
	    var masterId = 'scenarioMaster-' + id;

	    var html = '<div id="' + scenarioId + '"\n              style="width:' + config.viewSize.width + 'px;\n                     height:100%;\n                     left:' + config.viewSize.left + 'px;\n                     z-index:' + Xut.sceneController.createIndex() + ';\n                     position:absolute;\n                     overflow:' + overflow + ';">\n            <ul id="' + pageId + '" class="xut-flip" style="z-index:2"></ul>\n            <ul id="' + masterId + '" class="xut-flip" style="z-index:1"></ul>\n        </div>';

	    return String.styleFormat(html);
	}

	/**
	 *
	 * 配置工具栏行为
	 *  1.  工具栏类型
	 *  tbType：(如果用户没有选择任何工具栏信息处理，tbType字段就为空)
	 *   0  禁止工具栏
	 *   1  系统工具栏   - 显示IOS系统工具栏
	 *   2  场景工具栏   - 显示关闭按钮
	 *   3  场景工具栏   - 显示返回按钮
	 *   4  场景工具栏   - 显示顶部小圆点式标示
	 *
	 *  2.  翻页模式
	 *  pageMode：(如果用户没有选择任何处理，pageMode字段就为空)
	 *   0 禁止滑动
	 *   1 允许滑动无翻页按钮
	 *   2 允许滑动带翻页按钮
	 *
	 * @return {[type]} [description]
	 */

	/**
	 * 分解工具栏配置文件
	 * @return {[type]}          [description]
	 */
	var parseTooBar = function parseTooBar(toolbar, toolType, pageMode) {
	    if (toolbar = parseJSON(toolbar)) {
	        //兼容数据库中未指定的情况
	        var n = Number(toolbar.pageMode);
	        pageMode = _.isFinite(n) ? n : pageMode;
	        if (_.isString(toolbar.tbType)) {
	            toolType = _.map(toolbar.tbType.split(','), function (num) {
	                return Number(num);
	            });
	        }
	    }
	    return {
	        'toolType': toolType,
	        'pageMode': pageMode
	    };
	};

	/**
	 * 主场景工具栏配置
	 * pageMode:默认2 允许滑动,带翻页按钮
	 * @param  {[type]} scenarioId [description]
	 * @return {[type]}            [description]
	 */
	function pMainBar(scenarioId) {
	    var sectionRang = Xut.data.query('sectionRelated', scenarioId);

	    //场景工具栏配置信息
	    var toolbar = sectionRang.toolbar;
	    var pagetotal = sectionRang.length;

	    //默认显示系统工具栏
	    var toolType = [1];

	    //默认2 允许滑动,带翻页按钮
	    var pageMode = pagetotal > 1 ? 2 : 0;

	    return parseTooBar(toolbar, toolType, pageMode);
	}

	/**
	 * 副场景工具栏配置
	 * pageMode 是否支持滑动翻页  0禁止滑动 1允许滑动
	 * toolType   工具栏显示的类型 [0-5]
	 */
	function pDeputyBar(toolbar, pagetotal) {
	    var toolType = [0];
	    var pageMode = pagetotal > 1 ? 1 : 0;
	    return parseTooBar(toolbar, toolType, pageMode);
	}

	/**
	 * 找到对应容器
	 * @return {[type]}            [description]
	 */
	var findContainer = function findContainer($rootNode, scenarioId, isMain) {
	    return function (pane, parallax) {
	        var node;
	        if (isMain) {
	            node = '#' + pane;
	        } else {
	            node = '#' + parallax + scenarioId;
	        }
	        return $rootNode.find(node)[0];
	    };
	};

	/**
	 * 如果启动了缓存记录
	 * 加载新的场景
	 * @return {[type]} [description]
	 */
	var checkHistory = function checkHistory(history) {

	    //直接启用快捷调试模式
	    if (config.deBugHistory) {
	        Xut.View.LoadScenario(config.deBugHistory);
	        return true;
	    }

	    //如果有历史记录
	    if (history) {
	        var scenarioInfo = sceneController.seqReverse(history);
	        if (scenarioInfo) {
	            scenarioInfo = scenarioInfo.split('-');
	            Xut.View.LoadScenario({
	                'scenarioId': scenarioInfo[0],
	                'chapterId': scenarioInfo[1],
	                'pageIndex': scenarioInfo[2]
	            });
	            return true;
	        } else {
	            return false;
	        }
	    }
	};

	/**
	 * 场景创建类
	 * @param  {[type]} seasonId               [description]
	 * @param  {[type]} chapterId              [description]
	 * @param  {[type]} createCompleteCallback [创建完毕通知回调]
	 * @param  {[type]} createMode             [创建模式]
	 * @param  {[type]} sceneChainId           [场景ID链,用于后退按钮加载前一个场景]
	 * @return {[type]}                        [description]
	 */
	var SceneFactory = function () {
	    function SceneFactory(data) {
	        var _this = this;

	        classCallCheck(this, SceneFactory);


	        //基本配置信息
	        var seasonId = data.seasonId;
	        var chapterId = data.chapterId;

	        var options = _.extend(this, data, {
	            'scenarioId': seasonId,
	            'chapterId': chapterId,
	            '$container': $('.xut-scene-container')
	        });

	        //创建主场景
	        this._createHTML(options, function () {
	            //配置工具栏行为
	            if (!Xut.IBooks.Enabled) {
	                _.extend(_this, _this._initToolBar());
	            }
	            //构建Mediator对象
	            _this._createMediator();
	            //注入场景管理
	            sceneController.add(seasonId, chapterId, _this);
	        });
	    }

	    /**
	     * 创建场景
	     * @return {[type]} [description]
	     */


	    createClass(SceneFactory, [{
	        key: '_createHTML',
	        value: function _createHTML(options, callback) {

	            //如果是静态文件执行期
	            //支持Xut.IBooks模式
	            //都不需要创建节点
	            if (Xut.IBooks.runMode()) {
	                this.$rootNode = $('#xut-main-scene');
	                callback();
	                return;
	            }

	            var layout = void 0;

	            if (options.isMain) {
	                layout = mainScene();
	            } else {
	                layout = deputyScene(this.scenarioId);
	            }

	            this.$rootNode = $(layout);

	            Xut.nextTick({
	                'container': this.$container,
	                'content': this.$rootNode
	            }, callback);
	        }

	        /**
	         * 初始化工具栏
	         * 1 主场景，系统工具栏
	         * 2 副场景，函数工具栏
	         * 3 全场景，页码显示（右下角）
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_initToolBar',
	        value: function _initToolBar() {
	            var scenarioId = this.scenarioId;
	            var pageTotal = this.pageTotal;
	            var pageIndex = this.pageIndex;
	            var $rootNode = this.$rootNode;
	            var findControlBar = function findControlBar() {
	                return $rootNode.find('.xut-control-bar');
	            };

	            //配置文件
	            var barConfig = {};

	            //主场景工具栏设置
	            if (this.isMain) {
	                barConfig = pMainBar(scenarioId, pageTotal);
	                if (config.visualMode === 1) {
	                    //word模式,自动启动工具条
	                    this.mainToolbar = new BookBar({
	                        sceneNode: $rootNode,
	                        controlNode: findControlBar(),
	                        pageMode: barConfig.pageMode
	                    });
	                }
	                //如果工具拦提供可配置
	                //或者config.pageMode 带翻页按钮
	                else if (_.some(barConfig.toolType)) {
	                        //普通模式
	                        this.mainToolbar = new sysBar({
	                            sceneNode: $rootNode,
	                            controlNode: findControlBar(),
	                            pageTotal: pageTotal,
	                            currentPage: pageIndex + 1,
	                            pageMode: barConfig.pageMode,
	                            toolType: barConfig.toolType
	                        });
	                    }
	            }
	            //副场景
	            else {
	                    //副场工具栏配置
	                    barConfig = pDeputyBar(this.barInfo, pageTotal);
	                    if (_.some(barConfig.toolType)) {
	                        this.deputyToolbar = new fnBar({
	                            sceneNode: $rootNode,
	                            toolType: barConfig.toolType,
	                            pageTotal: pageTotal,
	                            currentPage: pageIndex,
	                            pageMode: barConfig.pageMode
	                        });
	                    }
	                }

	            //2016.9.29
	            //新增页码显示
	            //如果有分栏
	            var flowCounts = getFlowCount(this.seasonId);
	            if (config.toolType.number !== false && flowCounts) {
	                //获取分栏的chapter数，总数需要减去
	                var flowChpterCount = getFlowChpaterCount(this.seasonId);
	                this.numberToolbar = new NumberBar({
	                    $rootNode: $rootNode,
	                    currentPage: pageIndex,
	                    pageTotal: pageTotal + flowCounts - flowChpterCount
	                });
	            }

	            return barConfig;
	        }

	        /**
	         * 构建创建对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: '_createMediator',
	        value: function _createMediator() {
	            var _this2 = this;

	            var self = this;
	            var scenarioId = this.scenarioId;
	            var pageTotal = this.pageTotal;
	            var pageIndex = this.pageIndex;
	            var $rootNode = this.$rootNode;
	            var isMain = this.isMain;
	            var tempfind = findContainer($rootNode, scenarioId, isMain);

	            //页面容器
	            var scenarioPage = tempfind('xut-page-container', 'scenarioPage-');
	            //视差容器
	            var scenarioMaster = tempfind('xut-master-container', 'scenarioMaster-');

	            //场景容器对象
	            var vm = this.vm = new Mediator({
	                'pageMode': this.pageMode,
	                'container': this.$rootNode[0],
	                'multiScenario': !isMain,
	                'rootPage': scenarioPage,
	                'rootMaster': scenarioMaster,
	                'initIndex': pageIndex, //保存索引从0开始
	                'pagetotal': pageTotal,
	                'sectionRang': this.sectionRang,
	                'scenarioId': scenarioId,
	                'chapterId': this.chapterId,
	                'isInApp': this.isInApp //提示页面
	            });

	            /**
	             * 配置选项
	             * @type {[type]}
	             */
	            var isToolbar = this.isToolbar = this.deputyToolbar ? this.deputyToolbar : this.mainToolbar;

	            /**
	             * 监听翻页
	             * 用于更新页码
	             *   parentIndex  父索引
	             *   subIndex     子索引
	             * @return {[type]} [description]
	             */
	            vm.$bind('pageUpdate', function () {
	                isToolbar && isToolbar.updatePointer.apply(isToolbar, arguments);
	                if (_this2.numberToolbar) {
	                    var _numberToolbar;

	                    _this2.numberToolbar && (_numberToolbar = _this2.numberToolbar).updatePointer.apply(_numberToolbar, arguments);
	                }
	            });

	            /**
	             * 显示下一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('showNext', function () {
	                isToolbar && isToolbar.showNext();
	            });

	            /**
	             * 隐藏下一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('hideNext', function () {
	                isToolbar && isToolbar.hideNext();
	            });

	            /**
	             * 显示上一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('showPrev', function () {
	                isToolbar && isToolbar.showPrev();
	            });

	            /**
	             * 隐藏上一页按钮
	             * @return {[type]} [description]
	             */
	            vm.$bind('hidePrev', function () {
	                isToolbar && isToolbar.hidePrev();
	            });

	            /**
	             * 切换工具栏
	             * state, pointer
	             * @return {[type]} [description]
	             */
	            vm.$bind('toggleToolbar', function () {
	                isToolbar && isToolbar.toggle.apply(isToolbar, arguments);
	                if (_this2.numberToolbar) {
	                    var _numberToolbar2;

	                    _this2.numberToolbar && (_numberToolbar2 = _this2.numberToolbar).toggle.apply(_numberToolbar2, arguments);
	                }
	            });

	            /**
	             * 复位工具栏
	             * @return {[type]} [description]
	             */
	            vm.$bind('resetToolbar', function () {
	                if (_this2.mainToolbar) {
	                    _this2.mainToolbar.resetArrow(); //左右翻页按钮
	                    _this2.mainToolbar.hideNavbar(); //导航栏
	                }
	            });

	            /**
	             * 监听创建完成
	             * @return {[type]} [description]
	             */
	            vm.$bind('createComplete', function (nextAction) {
	                self.complete && setTimeout(function () {
	                    if (isMain) {
	                        self.complete(function () {
	                            Xut.View.HideBusy();
	                            //检测是不是有缓存加载
	                            if (!checkHistory(self.history)) {
	                                //指定自动运行的动作
	                                nextAction && nextAction();
	                            }
	                            //全局接口,应用加载完毕
	                            Xut.Application.AddEventListener();
	                        });
	                    } else {
	                        self.complete(nextAction);
	                    }
	                }, 200);
	            });

	            //如果是读酷端加载
	            if (window.DUKUCONFIG && isMain && window.DUKUCONFIG.success) {
	                window.DUKUCONFIG.success();
	                vm.$init();
	                //如果是客户端加载
	            } else if (window.CLIENTCONFIGT && isMain && window.CLIENTCONFIGT.success) {
	                window.CLIENTCONFIGT.success();
	                vm.$init();
	            } else {
	                //正常加载
	                vm.$init();
	            }
	        }

	        /**
	         * 销毁场景对象
	         * @return {[type]} [description]
	         */

	    }, {
	        key: 'destroy',
	        value: function destroy() {

	            //销毁当前场景
	            this.vm.$destroy();

	            //销毁工具栏
	            if (this.isToolbar) {
	                this.isToolbar.destroy();
	                this.isToolbar = null;
	            }

	            this.$container = null;

	            //销毁节点
	            this.$rootNode.off();
	            this.$rootNode.remove();
	            this.$rootNode = null;

	            //销毁引用
	            sceneController.remove(this.scenarioId);
	        }
	    }]);
	    return SceneFactory;
	}();

	/**
	 * 销毁缓存
	 */
	function destroyCache(isRefresh) {
	  removeCache(); //userCache
	}

	/**
	 * 销毁结果集
	 * @param  {Boolean} isRefresh [description]
	 * @return {[type]}            [description]
	 */
	function destroyResult(isRefresh) {
	  removeResults(); //json database
	}

	/**
	 * 销毁接口
	 * action 可能是
	 * 1 destory 默认，单页面切换，只做销毁。但是代码还是同一份
	 * 2 refresh 刷新，旋转切换（需要做一些数据保留，比如外联json数据）
	 * 3 exit 退出应用，所以这个应该是全销毁
	 * @param {[type]} action [description]
	 */
	function Destroy() {
	    var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'destory';


	    //销毁所有场景
	    sceneController.destroyAllScene();

	    //销毁只创建一次的对象
	    //修复的音频对象
	    //数据的结果集
	    if (action === 'exit') {
	        if (Xut.plat.isBrowser) {
	            $(document).off(); //左右按钮
	            $(window).off(); //横竖切换
	        }
	        //修复的音频对象
	        destroyFixAudio();
	    }

	    //refresh状态不删除结果集
	    if (action === 'destory' || action === 'exit') {
	        destroyResult();
	    }

	    //config路径缓存
	    destroyConfig();

	    //删除数据匹配缓存
	    destroyCache();

	    //音视频
	    clearAudio();

	    //音频
	    clearVideo();

	    //expand销毁
	    //flow的一些接口缓存
	    adapterDestory();

	    /**
	     * 重设缓存的UUID
	     * 为了只计算一次
	     * @return {[type]} [description]
	     */
	    $$resetUUID();

	    Xut.TransformFilter = null;
	    Xut.CreateFilter = null;

	    //销毁节点
	    Xut.Application.$$removeNode();
	}

	/**
	 * 设置缓存
	 * @param {[type]} parameter [description]
	 */
	var setDataToStorage = function setDataToStorage(parameter) {
	    config.pageIndex = parameter.pageIndex;
	    config.novelId = parameter.novelId;
	    $$set({
	        "pageIndex": parameter.pageIndex,
	        "novelId": parameter.novelId
	    });
	};

	/**
	 * 初始化值
	 * @param {[type]} options [description]
	 */
	var initDefaultValues = function initDefaultValues(options) {
	    return {
	        'novelId': Number(options.novelId),
	        'pageIndex': Number(options.pageIndex),
	        'history': options.history
	    };
	};

	/**
	 * 检测脚本注入
	 * @return {[type]} [description]
	 */
	var runScript$1 = function runScript() {
	    var preCode,
	        novels = Xut.data.query('Novel');
	    if (preCode = novels.preCode) {
	        execScript(preCode, 'novelpre脚本');
	    }
	};

	function loadScene (options) {

	    options = initDefaultValues(options || {});

	    //设置缓存
	    setDataToStorage(options);

	    //应用脚本注入
	    runScript$1();

	    //检测下scenarioId的正确性
	    //scenarioId = 1 找不到chapter数据
	    //通过sectionRelated递归检测下一条数据
	    var scenarioId, seasondata, i;
	    for (i = 0; i < Xut.data.Season.length; i++) {
	        seasondata = Xut.data.Season.item(i);
	        if (Xut.data.query('sectionRelated', seasondata._id)) {
	            scenarioId = seasondata._id;
	            break;
	        }
	    }

	    //加载新的场景
	    Xut.View.LoadScenario({
	        'main': true, //主场景入口
	        'scenarioId': scenarioId,
	        'pageIndex': options.pageIndex,
	        'history': options.history
	    });
	}

	/**
	 * 用css3实现的忙碌光标
	 * @return {[type]} [description]
	 */
	var transform$7 = Xut.style.transform;
	var animationDelay = Xut.style.animationDelay;

	/**
	 * 延时加载
	 * @type {Number}
	 */
	var delay = 500;

	/**
	 * 光标对象
	 * @type {[type]}
	 */
	var node = null;

	/**
	 * 是否禁用忙了光标
	 * @type {Boolean}
	 */
	var isDisable = false;

	/**
	 * 光标状态
	 * 调用隐藏
	 * @type {Boolean}
	 */
	var isCallHide = false;

	/**
	 * setTimouet
	 * @type {[type]}
	 */
	var timer = null;

	/**
	 * create
	 * @return {[type]} [description]
	 */
	function createCursor() {
	    if (isDisable) return;
	    var sWidth = config.viewSize.width;
	    var sHeight = config.viewSize.height;
	    var width = Math.min(sWidth, sHeight) / 4;
	    var space = Math.round((sHeight - width) / 2);
	    var delay = [0, 0.9167, 0.833, 0.75, 0.667, 0.5833, 0.5, 0.41667, 0.333, 0.25, 0.1667, 0.0833];
	    var deg = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];

	    var count = 12;
	    var html = '';
	    var container = '';

	    while (count--) {
	        container += '<div class="xut-busy-spinner"\n                  style="' + transform$7 + ':rotate(' + deg[count] + 'deg) translate(0,-142%);' + animationDelay + ':-' + delay[count] + 's">\n            </div>';
	    }

	    html = '<div style="width:' + width + 'px;height:' + width + 'px;margin:' + space + 'px auto;margin-top:' + (config.viewSize.top + space) + 'px;">\n            <div style="height:30%;"></div>\n            <div class="xut-busy-middle">' + container + '</div>\n            <div class="xut-busy-text"></div>\n        </div>';

	    node = $('.xut-busy-icon').html(String.styleFormat(html));
	}

	var clear = function clear() {
	    clearTimeout(timer);
	    timer = null;
	};

	/**
	 * 显示光标
	 */
	var ShowBusy = function ShowBusy() {
	    if (isDisable || Xut.IBooks.Enabled || timer) return;
	    timer = setTimeout(function () {
	        node.show();
	        clear();
	        if (isCallHide) {
	            HideBusy();
	            isCallHide = false;
	        }
	    }, delay);
	};

	/**
	 * 隐藏光标
	 */
	var HideBusy = function HideBusy() {
	    //显示忙碌加锁，用于不处理hideBusy
	    if (isDisable || Xut.IBooks.Enabled || ShowBusy.lock) return;
	    if (!timer) {
	        node.hide();
	    } else {
	        isCallHide = true;
	    }
	};

	/**
	 * 显示光标
	 * @param {[type]} txt [description]
	 */
	var ShowTextBusy = function ShowTextBusy(txt) {
	    if (isDisable || Xut.IBooks.Enabled) return;
	    node.css('pointer-events', 'none').find('.xut-busy-text').html(txt);
	    ShowBusy();
	};

	/**
	 * 禁用光标
	 * isDisable 是否禁用
	 * @return {[type]} [description]
	 */
	var disable = function disable(state) {
	    isDisable = state;
	};

	var Presentation = Xut.Presentation = hash();
	var _View = Xut.View = hash();
	var Contents = Xut.Contents = hash();
	var Application = Xut.Application = hash();

	Xut.Assist = hash();

	/**
	 * 忙碌光标
	 * */
	$$extend(_View, {
	    ShowBusy: ShowBusy,
	    HideBusy: HideBusy,
	    ShowTextBusy: ShowTextBusy
	});

	//重复点击
	var repeatClick = false;

	/**
	 * 场景
	 * */
	$$extend(_View, {

	    /**
	     * 关闭场景
	     */
	    CloseScenario: function CloseScenario() {
	        if (repeatClick) return;
	        repeatClick = true;
	        var serial = sceneController.takeOutPrevChainId();
	        _View.LoadScenario({
	            'scenarioId': serial.scenarioId,
	            'chapterId': serial.chapterId,
	            'createMode': 'sysClose'
	        }, function () {
	            repeatClick = false;
	        });
	    },


	    /**
	     * 加载一个新的场景
	     * 1 节与节跳
	     *    单场景情况
	     *    多场景情况
	     * 2 章与章跳
	     * useUnlockCallBack 用来解锁回调,重复判断
	     * isInApp 是否跳转到提示页面
	     */
	    LoadScenario: function LoadScenario(options, useUnlockCallBack) {

	        var seasonId = toNumber(options.scenarioId),
	            chapterId = toNumber(options.chapterId),
	            pageIndex = toNumber(options.pageIndex),
	            createMode = options.createMode,
	            isInApp = options.isInApp;

	        //ibooks模式下的跳转
	        //全部转化成超链接
	        if (!options.main && Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
	            location.href = chapterId + ".xhtml";
	            return;
	        }

	        //用户指定的跳转入口，而不是通过内部关闭按钮处理的
	        var userAssign = createMode === 'sysClose' ? false : true,

	        //当前活动场景容器对象
	        current = sceneController.containerObj('current');

	        //获取到当前的页面对象
	        //用于跳转去重复
	        if (current && current.vm) {
	            var curVmPage;
	            if (curVmPage = current.vm.$curVmPage) {
	                if (curVmPage.scenarioId == seasonId && curVmPage.chapterId == chapterId) {
	                    console.log('过滤多次重复点击加载页面');
	                    return;
	                }
	            }
	        }

	        /**
	         * 场景内部跳转
	         * 节相同，章与章的跳转
	         * 用户指定跳转模式,如果目标对象是当前应用页面，按内部跳转处理
	         * @return {[type]}            [description]
	         */
	        if (userAssign && current && current.scenarioId === seasonId) {
	            _View.GotoSlide(seasonId, chapterId);
	            return;
	        }

	        /**
	         * 场景外部跳转
	         * 节与节的跳转,需要对场景的处理
	         */
	        //清理热点动作
	        current && current.vm.$suspend();

	        //通过内部关闭按钮加载新场景处理
	        if (current && userAssign) {
	            //检测是不是往回跳转,重复处理
	            sceneController.checkToRepeat(seasonId);
	        }

	        /**
	         * 加载新的场景
	         */

	        //读酷启动时不需要忙碌光标
	        if (window.DUKUCONFIG && options.main) {
	            _View.HideBusy();
	        } else {
	            _View.ShowBusy();
	        }

	        /**
	         * 跳出去
	         * $multiScenario
	         * 场景模式
	         * $multiScenario
	         *      true  多场景
	         *      false 单场景模式
	         * 如果当前是从主场景加载副场景
	         * 关闭系统工具栏
	         */
	        if (current && !current.vm.$multiScenario) {
	            _View.HideToolBar();
	        }

	        /**
	         * 重写场景的顺序编号
	         * 用于记录场景最后记录
	         */
	        var pageId;
	        if (current && (pageId = Xut.Presentation.GetPageId())) {
	            sceneController.rewrite(current.scenarioId, pageId);
	        }

	        /**
	         * 场景信息
	         * @type {[type]}
	         */
	        var sectionRang = Xut.data.query('sectionRelated', seasonId);
	        var barInfo = sectionRang.toolbar; //场景工具栏配置信息
	        var pageTotal = sectionRang.length;

	        /**
	         * 通过chapterId转化为实际页码指标
	         * season 2 {
	         *     chapterId : 1  => 0
	         *     chpaterId : 2  => 1
	         *  }
	         * [description]
	         * @return {[type]} [description]
	         */
	        var parseInitIndex = function parseInitIndex() {
	            return chapterId ? function () {
	                //如果节点内部跳转方式加载,无需转化页码
	                if (createMode === 'GotoSlide') {
	                    return chapterId;
	                }
	                //初始页从0开始，减去下标1
	                return chapterId - sectionRang.start - 1;
	            }() : 0;
	        };

	        /**
	         * 传递的参数
	         * seasonId    节ID
	         * chapterId   页面ID
	         * pageIndex   指定页码
	         * isInApp     是否跳到收费提示页
	         * pageTotal   页面总数
	         * barInfo     工具栏配置文件
	         * history     历史记录
	         * sectionRang 节信息
	         * complete    构件完毕回调
	         * @type {Object}
	         */
	        var data = {
	            seasonId: seasonId,
	            chapterId: chapterId,
	            pageIndex: pageIndex || parseInitIndex(),
	            isInApp: isInApp,
	            pageTotal: pageTotal,
	            barInfo: barInfo,
	            history: options.history,
	            sectionRang: sectionRang,
	            //制作场景切换后处理
	            complete: function complete(nextBack) {
	                //销毁多余场景
	                current && current.destroy();
	                //下一个任务存在,执行切换回调后,在执行页面任务
	                nextBack && nextBack();
	                //去掉忙碌
	                _View.HideBusy();
	                //解锁回调
	                useUnlockCallBack && useUnlockCallBack();
	            }
	        };

	        //主场景判断（第一个节,因为工具栏的配置不同）
	        if (options.main || sceneController.mianId === seasonId) {
	            //清理缓存
	            $$remove("history");
	            //确定主场景
	            sceneController.mianId = seasonId;
	            //是否主场景
	            data.isMain = true;
	        }

	        new SceneFactory(data);
	    }
	});

	/**
	 * 行为
	 * */
	$$extend(_View, {
	    /**
	     * 通过插件打开一个新view窗口
	     */
	    Open: function Open(pageUrl, width, height, left, top) {
	        Xut.Plugin.WebView.open(pageUrl, left, top, height, width, 1);
	    },


	    //关闭view窗口
	    Close: function Close() {
	        Xut.Plugin.WebView.close();
	    }
	});

	/**
	 * content
	 * */
	$$extend(Contents, {

	    //存在文档碎片
	    //针对音频字幕增加的快捷查找
	    contentsFragment: {},

	    /**
	     * 是否为canvas元素
	     * 用来判断事件冒泡
	     * 判断当前元素是否支持滑动
	     * 默认任何元素都支持滑动
	     * @type {Boolean}
	     */
	    Canvas: {

	        /**
	         * 是否允许滑动
	         * @type {Boolean}
	         */
	        SupportSwipe: true,

	        /**
	         * 对象是否滑动
	         * @type {Boolean}
	         */
	        isSwipe: false,

	        /**
	         * 对象是否点击
	         */
	        isTap: false,

	        /**
	         * 复位标记
	         */
	        Reset: function Reset() {
	            Contents.Canvas.SupportSwipe = true;
	            Contents.Canvas.isSwipe = false;
	        },


	        /**
	         * 判断是否可以滑动
	         * @return {[type]} [description]
	         */
	        getSupportState: function getSupportState() {
	            var state;
	            if (Contents.Canvas.SupportSwipe) {
	                state = true;
	            } else {
	                state = false;
	            }
	            //清空状态
	            Contents.Canvas.Reset();
	            return state;
	        },


	        /**
	         * 判断是否绑定了滑动事件
	         * @return {Boolean} [description]
	         */
	        getIsSwipe: function getIsSwipe() {
	            var state;
	            if (Contents.Canvas.isSwipe) {
	                state = true;
	            } else {
	                state = false;
	            }
	            //清空状态
	            Contents.Canvas.Reset();
	            return state;
	        },


	        /**
	         * 是否绑定了点击事件
	         */
	        getIsTap: function getIsTap() {
	            var state = Contents.Canvas.isTap;
	            Contents.Canvas.isTap = false;
	            return state;
	        }
	    },

	    /**
	     * 恢复节点的默认控制
	     * 默认是系统接管
	     * 如果'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'等事件会重写
	     * 还需要考虑第三方调用，所以需要给一个重写的接口
	     * @return {[type]} [description]
	     * Content_1_3
	     * [Content_1_3,Content_1_4,Content_1_5]
	     */
	    ResetDefaultControl: function ResetDefaultControl(pageType, id, value) {
	        if (!id) return;
	        var elements;
	        var handle = function handle(ele) {
	            if (value) {
	                ele.attr('data-behavior', value);
	            } else {
	                ele.attr('data-behavior', 'disable');
	            }
	        };
	        if ((elements = Contents.Get(pageType, id)) && elements.$contentNode) {
	            handle(elements.$contentNode);
	        } else {
	            elements = $("#" + id);
	            elements.length && handle(elements);
	        }
	    },


	    /**
	     * 针对SVG无节点操作
	     * 关闭控制
	     */
	    DisableControl: function DisableControl(callback) {
	        return {
	            behavior: 'data-behavior',
	            value: 'disable'
	        };
	    },


	    /**
	     * 针对SVG无节点操作
	     * 启动控制
	     */
	    EnableControl: function EnableControl(Value) {
	        return {
	            behavior: 'data-behavior',
	            value: Value || 'click-swipe'
	        };
	    }
	});

	/**
	 * 应用事件监听
	 * 1 完成
	 * Xut.Application.Watch('complete',fn)
	 */
	var __app__ = new Observer();
	Application.Watch = function (event, callback) {
	    __app__.$watch('app:' + event, function () {
	        callback.apply(__app__, arguments);
	    });
	};
	Application.Notify = function (event, options) {
	    __app__.$emit('app:' + event, options);
	};

	/**
	 * 后台运行
	 * @type {Number}
	 */
	var backstage = 0;

	/**
	 * 应用加载状态
	 * false未加载
	 * true 已加载
	 * @type {Boolean}
	 */
	var appState = false;

	$$extend(Application, {

	    /**
	     * 后台运行
	     * @type {Number}
	     */
	    IsBackStage: function IsBackStage() {
	        return backstage;
	    },


	    /**
	     * home隐藏
	     * 后台运行的时候,恢复到初始化状态
	     * 用于进来的时候激活Activate
	     */
	    Original: function Original() {
	        backstage = 1;

	        //传递一个完全关闭的参数
	        $$suspend('', '', true);
	        $$original();
	    },


	    /**
	     * home显示
	     * 后台弹回来
	     * 激活应用行为
	     */
	    Activate: function Activate() {
	        backstage = 0;
	        $$autoRun();
	    },


	    /**
	     * 销毁应用
	     */
	    Destroy: function Destroy$$() {
	        Destroy('destroy');
	    },


	    /**
	     * 2016.10.11
	     * 刷新程序
	     * 这个与销毁有点区别
	     * 比如外联的数据，不需要删除
	     */
	    Refresh: function Refresh() {
	        Destroy('refresh');
	    },


	    /**
	     * 退出app
	     * 提供给iframe方式加载后退出app处理接口
	     */
	    DropApp: function DropApp() {

	        /**
	         * 并且是安卓情况下
	         * 安卓销毁按键事件
	         * @return {[type]} [description]
	         */
	        var unEvent = function unEvent() {
	            if (Xut.plat.isAndroid) {
	                window.GLOBALCONTEXT.document.removeEventListener("backbutton", config._event.back, false);
	                window.GLOBALCONTEXT.document.removeEventListener("pause", config._event.pause, false);
	            }
	        };

	        /**
	         * iframe模式,退出处理
	         * @return {[type]} [description]
	         */
	        var destroy = function destroy() {
	            __app__.$off();
	            //退出应用
	            Destroy('exit');
	            window.GLOBALCONTEXT = null;
	        };

	        /**
	         * 动态配置
	         * @param  {[type]} window.DYNAMICCONFIGT [description]
	         * @return {[type]}                       [description]
	         */
	        if (window.DYNAMICCONFIGT) {
	            unEvent();
	            destroy();
	            return;
	        }

	        //如果读酷
	        if (window.DUKUCONFIG) {
	            //外部回调通知
	            if (window.DUKUCONFIG.iframeDrop) {
	                var appId = $$get('appId');
	                window.DUKUCONFIG.iframeDrop(['appId-' + appId, 'novelId-' + appId, 'pageIndex-' + appId]);
	            }
	            window.DUKUCONFIG = null;
	            unEvent();
	            destroy();
	            return;
	        }

	        //客户端模式
	        if (window.CLIENTCONFIGT) {
	            //外部回调通知
	            if (window.CLIENTCONFIGT.iframeDrop) {
	                window.CLIENTCONFIGT.iframeDrop();
	            }
	            window.CLIENTCONFIGT = null;
	            unEvent();
	            destroy();
	            return;
	        }

	        //妙妙学客户端
	        if (window.MMXCONFIG) {
	            //外部回调通知
	            if (window.MMXCONFIG.iframeDrop) {
	                window.MMXCONFIG.iframeDrop();
	            }
	            window.MMXCONFIG = null;
	            destroy();
	            return;
	        }
	    },


	    /**
	     * 停止应用
	     * skipMedia 跳过音频你处理(跨页面)
	     * dispose   成功处理回调
	     * processed 处理完毕回调
	     */
	    Stop: function Stop(_ref) {
	        var skipAudio = _ref.skipAudio,
	            dispose = _ref.dispose,
	            processed = _ref.processed;

	        //是否存在动作
	        var hasAction = $$stop(skipAudio);
	        if (hasAction) {
	            if (dispose) {
	                dispose();
	            } else {
	                processed && processed();
	            }
	        } else {
	            processed && processed();
	        }
	    },


	    //stop引用
	    Suspend: Application.Stop

	});

	$$extend(Application, {

	    /**
	     * 启动应用
	     */
	    Launch: function Launch() {},


	    /**
	     * 设置应用状态
	     */
	    setAppState: function setAppState() {
	        appState = true;
	    },


	    /**
	     * 删除应用状态
	     * @return {[type]} [description]
	     */
	    delAppState: function delAppState() {
	        appState = false;
	    },


	    /**
	     * 获取应用加载状态
	     * @return {[type]} [description]
	     */
	    getAppState: function getAppState() {
	        return appState;
	    },


	    /**
	     * 延时APP运用
	     * 一般是在等待视频先加载完毕
	     * @return {[type]} [description]
	     */
	    delayAppRun: function delayAppRun() {
	        Application.setAppState();
	    },


	    /**
	     * 启动app
	     * 重载启动方法
	     * 如果调用在重载之前，就删除，
	     * 否则被启动方法重载
	     * @type {[type]}
	     */
	    LaunchApp: function LaunchApp() {
	        Application.delAppState();
	    },


	    /**
	     * 应用加载完毕
	     */
	    AddEventListener: function AddEventListener() {}
	});

	/**
	 * u3d接口
	 */
	Xut.U3d = {
	    /**
	     * 跳转接口
	     * @param {[type]} seasonId  [description]
	     * @param {[type]} chapterId [description]
	     */
	    View: function View(seasonId, chapterId) {
	        _View.LoadScenario({
	            'scenarioId': seasonId,
	            'chapterId': chapterId
	        });
	    }
	};

	/**
	 * 脚本注入接口
	 * @type {Object}
	 */
	window.XXTAPI = {

	    /**
	     *读取系统中保存的变量的值。
	     *如果变量不存在，则新建这个全局变量
	     *如果系统中没有保存的值，用默认值进行赋值
	     *这个函数，将是创建全局变量的默认函数。
	     */
	    ReadVar: function ReadVar(variable, defaultValue) {
	        var temp;
	        if (temp = $$get(variable)) {
	            return temp;
	        } else {
	            $$set(variable, defaultValue);
	            return defaultValue;
	        }
	    },


	    /**
	     * 将变量的值保存起来
	     */
	    SaveVar: function SaveVar(variable, value) {
	        $$set(variable, value);
	    },


	    /*
	     *对变量赋值，然后保存变量的值
	     *对于全局变量，这个函数将是主要使用的，替代简单的“=”赋值
	     */
	    SetVar: function SetVar(variable, value) {
	        $$set(variable, value);
	    }
	};

	var preloadVideo = {

	    //播放状态
	    state: false,

	    //地址
	    path: window.DUKUCONFIG ? window.DUKUCONFIG.path + "duku.mp4" : 'android.resource://#packagename#/raw/duku',

	    //加载视频
	    load: function load() {
	        // if (window.localStorage.getItem("videoPlayer") == 'error') {
	        //       alert("error")
	        //     return preloadVideo.launchApp();
	        // }
	        this.play();
	        this.state = true;
	    },


	    //播放视频
	    play: function play() {
	        //延时应用加载
	        Xut.Application.delayAppRun();
	        Xut.Plugin.VideoPlayer.play(function () {
	            preloadVideo.launchApp();
	        }, function () {
	            //捕获出错,下次不进入了,,暂无ID号
	            // window.localStorage.setItem("videoPlayer", "error")
	            preloadVideo.launchApp();
	        }, preloadVideo.path, 1, 0, 0, window.innerHeight, window.innerWidth);
	    },


	    //清理视频
	    closeVideo: function closeVideo() {
	        Xut.Plugin.VideoPlayer.close(function () {
	            preloadVideo.launchApp();
	        });
	    },


	    //加载应用
	    launchApp: function launchApp() {
	        this.state = false;
	        Xut.Application.LaunchApp();
	    }
	};

	/**
	 * 获取插件视频状态
	 */
	function getPlugVideoState() {
	    return preloadVideo.state;
	}

	/**
	 * 关闭插件视频
	 */
	function closePlugVideo() {
	    preloadVideo.closeVideo();
	}

	/**
	 * 播放视频插件
	 */
	function plugVideo() {
	    preloadVideo.load();
	}

	/**
	 *  创建播放器
	 *  IOS，PC端执行
	 */
	function html5Video() {
	    //延时应用开始
	    Xut.Application.delayAppRun();
	    Video5({
	        url: 'duku.mp4',
	        startBoot: function startBoot() {
	            Xut.Application.LaunchApp();
	        }
	    });
	}

	/**
	 * content对象的创建过滤器
	 * 用于阻断对象的创建
	 */
	function contentFilter(filterName) {

	    //过滤的节点
	    var listFilters = function () {
	        var values = getCache();
	        var h = hash();
	        if (values) {
	            //keep the listFilters has no property
	            _.each(values, function (v, i) {
	                h[i] = v;
	            });
	        }
	        return h;
	    }();

	    function setCache(listFilters) {
	        $$save(filterName, listFilters);
	    }

	    function getCache() {
	        var jsonStr = $$get(filterName);
	        return parseJSON(jsonStr);
	    }

	    function access(callback, pageId, contentId) {
	        //如果是transformFilter,不需要pageIndex处理
	        if (filterName === 'transformFilter' && contentId === undefined) {
	            contentId = pageId;
	            pageId = 'transformFilter';
	        }
	        return callback(pageId, Number(contentId));
	    }

	    return {
	        add: function add(pageId, contentId) {
	            access(function (pageId, contentId) {
	                if (!listFilters[pageId]) {
	                    listFilters[pageId] = [];
	                }
	                //去重
	                if (-1 === listFilters[pageId].indexOf(contentId)) {
	                    listFilters[pageId].push(contentId);
	                    setCache(listFilters);
	                }
	            }, pageId, contentId);
	        },
	        remove: function remove(pageId, contentId) {
	            access(function (pageId, contentId) {
	                var target = listFilters[pageId] || [],
	                    index = target.indexOf(contentId);
	                if (-1 !== index) {
	                    target.splice(index, 1);
	                    setCache(listFilters);
	                }
	            }, pageId, contentId);
	        },
	        has: function has(pageId, contentId) {
	            return access(function (pageId, contentId) {
	                var target = listFilters[pageId];
	                return target ? -1 !== target.indexOf(contentId) ? true : false : false;
	            }, pageId, contentId);
	        },


	        /**
	         * 创建过滤器
	         * @param  {[type]} pageId [description]
	         * @return {[type]}        [description]
	         */
	        each: function each(pageId) {
	            return access(function (pageId, contentId) {
	                var target, indexOf;
	                if (target = listFilters[pageId]) {
	                    return function (contentIds, callback) {
	                        _.each(target, function (ids) {
	                            var indexOf = contentIds.indexOf(ids);
	                            if (-1 !== indexOf) {
	                                callback(indexOf); //如果找到的过滤项目
	                            }
	                        });
	                    };
	                }
	            }, pageId);
	        },


	        //过滤器数量
	        size: function size() {
	            return _.keys(listFilters).length;
	        },
	        empty: function empty() {
	            $$remove(filterName);
	            listFilters = {};
	        }
	    };
	}

	/**
	 * 初始化数据类
	 * 获取ppt总数
	 * @return {[type]} [description]
	 */
	function createStore(callback) {
	    dataQuery(function (results, collectError) {
	        //保存缓存
	        saveCache(results, collectError);
	        //数据缓存转化
	        convertCache();
	        //设置API
	        setApi(results.Novel.item(0)['_id']);
	        callback(results);
	    });
	}

	/**
	 * 默认工具栏配置
	 * @type {Object}
	 */
	var defaults$1 = {
	    ToolbarPos: 0, //工具栏[0顶部,1底部]
	    NavbarPos: 1, //左右翻页按钮[0顶部, 1中间, 2底部]
	    HomeBut: 1, //主页按钮[0不显示,1显示]
	    ContentBut: 1, //目录按钮[0不显示,1显示]
	    PageBut: 1, //页码按钮[0不显示,1显示]
	    NavLeft: 1, //左翻页按钮[0不显示,1显示]
	    NavRight: 1, //右翻页按钮[0不显示,1显示]
	    customButton: 0, //自定义翻页按钮
	    CloseBut: window.SUbDOCCONTEXT ? 1 : 0 //关闭按钮[0不显示,1显示]
	};

	/**
	 * 配置默认数据
	 * @return {[type]} [description]
	 */
	var initDefaults = function initDefaults(setData) {

	    var rs = void 0;
	    var data = {};
	    var setConfig = {};

	    _.each(setData, function (key, index) {
	        rs = setData.item(index);
	        data[rs.name] = rs.value;
	    });

	    _.defaults(data, defaults$1);

	    for (var i in defaults$1) {
	        setConfig[i] = Number(data[i]);
	    }

	    config.settings = setConfig;
	    config.appId = data.appId; //应用配置唯一标示符
	    config.shortName = data.shortName;
	    config.Inapp = data.Inapp; //是否为应用内购买
	    config.delayTime = data.delayTime;

	    //应用的唯一标识符
	    //生成时间+appid
	    config.appUUID = data.adUpdateTime ? data.appId + '-' + /\S*/.exec(data.adUpdateTime)[0] : data.adUpdateTime;

	    //缓存应用ID
	    $$set({
	        'appId': data.appId
	    });

	    //广告Id
	    //2014.9.2
	    Xut.Presentation.AdsId = data.adsId;

	    return data;
	};

	/**
	 * 根据set表初始化数据
	 * @return {[type]} [description]
	 */
	var setStore = function setStore(callback) {
	    createStore(function (dataRet) {
	        var novelData = dataRet.Novel.item(0);
	        callback(novelData, initDefaults(dataRet.Setting));
	    });
	};

	/**
	 * 数据库支持
	 * @return {[type]} [description]
	 */
	var supportTransaction = function supportTransaction(callback) {
	    if (window.openDatabase) {
	        try {
	            //数据库链接对象
	            Xut.config.db = window.openDatabase(config.dbName, "1.0", "Xxtebook Database", config.dbSize);
	        } catch (err) {
	            console.log('window.openDatabase出错');
	        }
	    }
	    //如果读不出数据
	    if (Xut.config.db) {
	        Xut.config.db.transaction(function (tx) {
	            tx.executeSql('SELECT * FROM Novel', [], function (tx, rs) {
	                callback();
	            }, function () {
	                Xut.config.db = null;
	                callback();
	            });
	        });
	    } else {
	        callback();
	    }
	};

	/**
	 * 初始化
	 * 数据结构
	 */
	function initTooBar (callback) {
	    supportTransaction(function () {
	        return setStore(callback);
	    });
	}

	var COLUMNWIDTH = Xut.style.columnWidth;
	var COLUMNTAP = Xut.style.columnGap;

	/**
	 * 高度marginTop - marginBottom处理了
	 * 不一定等于设备高度
	 * @type {Number}
	 */
	var newViewHight = 0;

	/**
	 * create dom...
	 */
	var createStr = function createStr(chapterId, data, viewWidth, viewHeight, margin) {

	    var percentageTop = Number(margin[0]);
	    var percentageLeft = Number(margin[1]);
	    var percentageBottom = Number(margin[2]);
	    var percentageRight = Number(margin[3]);

	    //减去的宽度值
	    var negativeWidth = viewWidth / 100 * (percentageLeft + percentageRight);
	    //减去的高度值
	    var negativeHeight = viewHeight / 100 * (percentageTop + percentageBottom);

	    //容器宽度 = 宽度 - 左右距离比值
	    var containerWidth = viewWidth - negativeWidth;
	    //容器高度值 = 宽度 - 上下距离比值
	    var containerHeight = viewHeight - negativeHeight;
	    //容器左边偏移量
	    var containerLeft = negativeWidth / 2;
	    //容器上偏移量
	    var containerTop = viewHeight / 100 * percentageTop;

	    //重复加载杂志
	    //不刷新的情况处理
	    if (/fix-transform/.test(data)) {
	        data = $(data).find("#columns-content").html();
	    }

	    var columnGap = COLUMNTAP + ':' + negativeWidth + 'px';
	    var columnWidth = COLUMNWIDTH + ':' + containerWidth + 'px';
	    var container = '\n            <section class="fix-transform" data-flow="true">\n                <div class="page-flow-pinch" data-role="margin" style="width:' + containerWidth + 'px;height:' + containerHeight + 'px;margin-top:' + containerTop + 'px;margin-left:' + containerLeft + 'px;">\n                    <div data-role="column" id="columns-content" style="' + columnWidth + ';height:100%;' + columnGap + '">\n                        ' + data + '\n                    </div>\n                </div>\n            </section>';

	    newViewHight = containerHeight;

	    return String.styleFormat(container);
	};

	var resolveCount = function resolveCount($content) {
	    var theChildren = $content.find('#columns-content').children();
	    var paraHeight = 0;
	    for (var i = 0; i < theChildren.length; i++) {
	        paraHeight += $(theChildren[i]).height();
	    }
	    return Math.ceil(paraHeight / newViewHight);
	};

	var insertColumn = function insertColumn(seasonNode, seasonsId, vWidth, vHeight, flowCounts) {
	    for (var i = 0; i < seasonNode.childNodes.length; i++) {
	        var chapterNode = seasonNode.childNodes[i];
	        if (chapterNode.nodeType == 1) {
	            var tag = chapterNode.id;
	            var id = tag.match(/\d/)[0];

	            //传递的数据
	            var margin = chapterNode.getAttribute('data-margin');
	            if (margin) {
	                margin = margin.split(",");
	            } else {
	                margin = [0, 0, 0, 0];
	            }
	            chapterNode.innerHTML = createStr(id, chapterNode.innerHTML, vWidth, vHeight, margin);
	            flowCounts[seasonsId][id] = 0;
	        }
	    }
	};

	/**
	 * 构建flow页面代码结构
	 * @return {[type]} [description]
	 */
	function initFlows() {

	    var $container = $("#xut-stream-flow");
	    if (!$container.length) return;
	    var $seasons = $container.children();
	    if (!$seasons.length) return;

	    /**
	     * seasonId:{
	     *    chpaterID:count
	     * }
	     * @type {[type]}
	     */
	    var flowCounts = Object.create(null);

	    /**
	     * 容器尺寸设置
	     * @type {[type]}
	     */
	    var flowView = getFlowView();

	    var vWidth = flowView.viewWidth;
	    var vHeight = newViewHight = flowView.viewHeight;

	    $seasons.each(function (index, node) {
	        var tag = node.id;
	        var seasonsId = tag.match(/\d/)[0];
	        var $chapters = $seasons.children();
	        flowCounts[seasonsId] = Object.create(null);
	        insertColumn(node, seasonsId, vWidth, vHeight, flowCounts);
	    });

	    $container.css({
	        width: vWidth,
	        height: vHeight,
	        overflow: 'hidden'
	    }).show();

	    $seasons.each(function (index, node) {
	        var tag = node.id;
	        var seasonsId = tag.match(/\d/)[0];
	        var $chapters = $seasons.children();

	        $chapters.each(function (index, node) {
	            var tag = node.id;
	            var chpaterId = tag.match(/\d/)[0];
	            var count = resolveCount($(node));
	            flowCounts[seasonsId][chpaterId] = Number(count);
	        });
	    });

	    $container.hide();

	    set$1(flowCounts);
	}

	/**
	 * 加载css
	 * @return {[type]} [description]
	 */
	var loadStyle = function loadStyle(callback) {

	    var svgsheet = window.DYNAMICCONFIGT ? window.DYNAMICCONFIGT.resource + '/gallery/svgsheet.css' : config.pathAddress + 'svgsheet.css';

	    //加载横版或者竖版css
	    //nodeBuildMode 是node build下的test.html文件
	    //加载build/*.css压缩文件
	    //否则就是默认的css/*.css
	    var baseCss = window.nodeBuildMode ? window.nodeBuildMode.csspath : './css/' + config.layoutMode + '.css';
	    var cssArr = [baseCss, svgsheet];

	    //是否需要加载svg
	    //如果是ibooks模式
	    //并且没有svg
	    //兼容安卓2.x
	    if (Xut.IBooks.Enabled && !Xut.IBooks.existSvg) {
	        cssArr = [baseCss];
	    }

	    loader.load(cssArr, callback, null, true);
	};

	/**
	 * 新增模式,用于记录浏览器退出记录
	 * 默认启动
	 * 是否回到退出的页面
	 * set表中写一个recordHistory
	 * 是   1
	 * 否   0
	 * [description]
	 * @param  {[type]} data [description]
	 * @return {[type]}      [description]
	 */
	var setHistory = function setHistory(data) {
	    var recordHistory = 1; //默认启动
	    if (data.recordHistory !== undefined) {
	        recordHistory = Number(data.recordHistory);
	    }

	    //如果启动桌面调试模式
	    //自动打开缓存加载
	    if (!recordHistory && config.isBrowser && config.debugMode) {
	        recordHistory = 1;
	    }

	    config.recordHistory = recordHistory;
	};

	var setMode = function setMode(data) {
	    //如果没有config配置，默认数据库
	    if (!config.visualMode && Number(data.scrollPaintingMode)) {
	        config.visualMode = 1;
	    }
	};

	/**
	 * 动态代码变动区域
	 */
	function dynamic(callback) {

	    //导入数据缓存
	    importDatabase(function () {

	        //初始化工具栏
	        //与数据库setting数据
	        initTooBar(function (novelData, tempSettingData) {

	            //创建过滤器
	            Xut.CreateFilter = contentFilter('createFilter');
	            Xut.TransformFilter = contentFilter('transformFilter');

	            //初始化配置一些信息
	            initConfig(novelData.pptWidth, novelData.pptHeight);

	            //新增模式,用于记录浏览器退出记录
	            setHistory(tempSettingData);

	            //2015.2.26
	            //启动画轴模式
	            setMode(tempSettingData);

	            //创建忙碌光标
	            if (!Xut.IBooks.Enabled) {
	                createCursor();
	            }

	            //初始资源地址
	            initPathAddress();

	            /**
	             * 初始flows排版
	             * 嵌入index
	             */
	            initFlows();

	            //iframe要要Xut.config
	            loadStyle(function () {
	                return callback(novelData);
	            });
	        });
	    });
	}

	/**
	 * 回退按钮状态控制器
	 * @param  {[type]} state [description]
	 * @return {[type]}       [description]
	 */
	var controller = function controller(state) {
	    //如果是子文档处理
	    if (Xut.isRunSubDoc) {
	        //通过Action动作激活的,需要到Action类中处理
	        Xut.publish('subdoc:dropApp');
	        return;
	    }
	    window.GLOBALCONTEXT.navigator.notification.confirm('您确认要退出吗？', function (button) {
	        if (1 == button) {
	            Xut.Application.Stop({
	                processed: function processed() {
	                    window.GLOBALCONTEXT.navigator.app.exitApp();
	                }
	            });
	        }
	    }, '退出', '确定,取消');
	};

	/**
	 * 绑定控制案例事件
	 * @param  {[type]} config [description]
	 * @return {[type]}        [description]
	 */
	function button(config) {
	    /**
	     * 存放绑定事件
	     * @type {Object}
	     */
	    config._event = {

	        /**
	         * 回退键
	         * @return {[type]} [description]
	         */
	        back: function back() {
	            //如果是预加载视频
	            if (getPlugVideoState()) {
	                closePlugVideo();
	            } else {
	                controller('back');
	            }
	        },


	        /**
	         * 暂停键
	         * @return {[type]} [description]
	         */
	        pause: function pause() {
	            controller('pause');
	        }
	    };
	}

	var getCache = function getCache(name) {
	    return parseInt($$get(name));
	};

	/**
	 * 进入主页面
	 * @return {[type]} [description]
	 */
	var initMain = function initMain(novelData) {

	    var novelId = void 0;
	    var parameter = void 0;
	    var pageIndex = getCache('pageIndex');
	    var flipMode = getCache('flipMode') || 0;

	    /**
	     * IBOOS模式
	     */
	    if (Xut.IBooks.Enabled) {
	        //删除背景图
	        $(".xut-cover").remove();
	        loadScene({
	            "pageIndex": Xut.IBooks.CONFIG.pageIndex
	        });
	        return;
	    }

	    /**
	     * 多模式判断
	     * 全局翻页模式
	     * 0 滑动翻页
	     * 1 直接换
	     * 所以pageFlip只有在左面的情况下
	     */
	    if (parameter = novelData.parameter) {
	        parameter = parseJSON(parameter);

	        //配置全局翻页模式
	        //flipMode可以为0
	        //兼容flipMode错误,强制转化成数字类型
	        if (parameter.pageflip !== undefined) {
	            flipMode = Number(parameter.pageflip);
	            $$set({ 'flipMode': flipMode });
	        }
	    }

	    /**
	     * 设置全局翻页模式
	     * @return {[type]} [description]
	     */
	    if (flipMode) {
	        config.flipMode = Number(flipMode);
	    }

	    /**
	     * 缓存加载
	     * 如果启动recordHistory记录
	     * [if description]
	     */
	    if (config.recordHistory && pageIndex !== undefined) {
	        //加强判断
	        if (novelId = getCache("novelId")) {
	            return loadScene({
	                "novelId": novelId,
	                "pageIndex": pageIndex,
	                'history': $$get('history')
	            });
	        }
	    }

	    //第一次加载
	    //没有缓存
	    loadScene({
	        "novelId": novelData._id,
	        "pageIndex": 0
	    });
	};

	/**
	 * 加载app应用
	 * @param  {[type]} config [description]
	 * @return {[type]}        [description]
	 */
	var initApp = function initApp() {
	    return dynamic(initMain);
	};

	/**
	 * 如果是安卓桌面端
	 * 绑定事件
	 * @return {[type]} [description]
	 */
	var operation = function operation() {
	    //安卓上
	    if (Xut.plat.isAndroid) {
	        //预加载处理视频
	        //妙妙学不加载视频
	        //读库不加载视频
	        if (!window.MMXCONFIG && !window.DUKUCONFIG) {
	            plugVideo();
	        }

	        //不是子文档指定绑定按键
	        if (!window.SUbCONFIGT) {
	            Xut.Application.AddEventListener = function () {
	                window.GLOBALCONTEXT.document.addEventListener("backbutton", config._event.back, false);
	                window.GLOBALCONTEXT.document.addEventListener("pause", config._event.pause, false);
	            };
	        }
	    }

	    if (window.DUKUCONFIG) {
	        PMS.bind("MagazineExit", function () {
	            PMS.unbind();
	            Xut.Application.DropApp();
	        }, "*");
	    }
	    initApp();
	};

	function init() {

	    //安卓按键
	    button(config);

	    //如果不是读库模式
	    //播放HTML5视频
	    //在IOS
	    if (!window.DUKUCONFIG && !window.GLOBALIFRAME && Xut.plat.isIOS) {
	        html5Video();
	    }

	    //Ifarme嵌套处理
	    //1 新阅读
	    //2 子文档
	    //3 pc
	    //4 ios/android
	    if (window.GLOBALIFRAME) {
	        operation();
	    } else {

	        //brower or mobile(apk or ipa)
	        if (config.isBrowser) {
	            initApp();
	        } else {
	            window.openDatabase(config.dbName, "1.0", "Xxtebook Database", config.dbSize);
	            document.addEventListener("deviceready", function () {
	                Xut.plat.hasPlugin = true; //支持插件
	                Xut.Plugin.XXTEbookInit.startup(config.dbName, operation, function () {});
	            }, false);
	        }
	    }
	}

	Xut.Version = 862;

	if (Xut.plat.isBrowser) {
	    //Mobile browser automatically broadcast platform media processing
	    if (Xut.plat.noAutoPlayMedia) {
	        fixAudio();
	    }
	    //Desktop binding mouse control
	    $(document).keyup(function (event) {
	        switch (event.keyCode) {
	            case 37:
	                Xut.View.GotoPrevSlide();
	                break;
	            case 39:
	                Xut.View.GotoNextSlide();
	                break;
	        }
	    });
	}

	/**
	 * 接口接在参数
	 * 用户横竖切换刷新
	 * @type {Array}
	 */
	var lauchOptions = void 0;

	/**
	 * 创建基本结构
	 * @return {[type]} [description]
	 */
	var createHTML = function createHTML() {
	    var nodeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#xxtppt-app-container';
	    var cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    //默认需要忙了光标

	    var $rootNode = void 0;
	    if (nodeName) {
	        $rootNode = $(nodeName);
	    }

	    if (!$rootNode.length) {
	        //如果没有传递节点名，直接放到body下面
	        nodeName = '';
	        $rootNode = $('body');
	    }

	    //忙碌可配置
	    var busyIcon = '<div class="xut-busy-icon xut-fullscreen"></div>';
	    if (!cursor) {
	        disable(true);
	        busyIcon = '';
	    }

	    //基本结构
	    //默认背景图
	    var cover = window.DYNAMICCONFIGT && window.DYNAMICCONFIGT.resource ? window.DYNAMICCONFIGT.resource + '/gallery/cover.jpg' : './content/gallery/cover.jpg';
	    var commonHTML = '<div class="xut-cover xut-fullscreen" style="background-image: url(' + cover + ');"></div>\n         <div class="xut-scene-container xut-fullscreen xut-overflow-hidden"></div>';

	    var html = '' + busyIcon + commonHTML;

	    //如果根节点不存在,配置根节点
	    if (!nodeName) {
	        html = '<div id="xxtppt-app-container" class="xut-fullscreen xut-overflow-hidden "> ' + html + '</div>';
	    }

	    var $appNode = $(String.styleFormat(html));

	    Xut.Application.$$removeNode = function () {
	        lauchOptions = null;
	        $appNode.remove();
	        $rootNode = null;
	        $appNode = null;
	        Xut.Application.$$removeNode = null;
	    };

	    nextTick({
	        container: $rootNode,
	        content: $appNode
	    }, init);
	};

	/**
	 * 加载应用app
	 * @return {[type]} [description]
	 */
	var loadApp = function loadApp() {
	    //清理旧节点
	    if (document.getElementById('sceneContainer')) {
	        "busyIcon message removelayer startupPage sceneContainer".split(' ').forEach(function (id) {
	            $('#' + id).hide().remove();
	        });
	    }
	    //创建新节点
	    createHTML.apply(undefined, arguments);
	};

	// $('body').on('dblclick', () => {
	//     Xut.Application.Refresh()
	//     loadApp()
	// })

	//横竖切换
	Xut.plat.isBrowser && $(window).on('orientationchange', function () {
	    //如果启动了这个模式
	    if (config.orientateMode) {
	        var temp = lauchOptions;
	        Xut.Application.Refresh();
	        if (temp.length) {
	            Xut.Application.Launch.apply(null, temp.pop());
	            temp = null;
	        } else {
	            loadApp();
	        }
	    }
	});

	/**
	 * 提供全局配置文件
	 * @return {[type]} [description]
	 */
	var configMode = function configMode(setConfig) {
	    if (setConfig) {
	        Xut.extend(config, setConfig);
	    }
	};

	//新版本加载
	Xut.Application.Launch = function (_ref) {
	    var el = _ref.el,
	        paths = _ref.paths,
	        cursor = _ref.cursor;

	    var setConfig = Xut.Application.setConfig;
	    if (setConfig && setConfig.lauchMode === 1) {
	        configMode(setConfig);
	        (lauchOptions = []).push(arguments);
	        window.DYNAMICCONFIGT = { //外部配置文件
	            resource: paths.resource,
	            database: paths.database
	        };
	        loadApp(el, cursor);
	    }
	};

	//老版本加载
	setTimeout(function () {

	    var setConfig = Xut.Application.setConfig;
	    if (!setConfig || setConfig && !setConfig.lauchMode) {
	        configMode(setConfig);
	        loadApp();
	    }
	}, 100);

}));