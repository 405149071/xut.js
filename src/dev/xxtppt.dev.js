//===========判断加载环境 是否嵌套iframe
//
//   1 单独杂志
//   2 新阅读加载
//   3 子文档加载
//   4 客户端模式  add 2014.11.26 
//   
//   GLOBALCONTEXT 插件全局调用接口
//   GLOBALIFRAME  是否iframe加载
//
//
//   //提供给iframe内的配置文件
//   window.XXTIFRAME = {
//       path: "sdcard/" + config.appId + "/content/gallery/",
//       iframeDrop: function () {
//            //iframe退出的处理方法
//       }
//   }
		
//常量
;(function(top) {

	//上文环境
	//1 新阅读
	//2 子文档
	//3 本身
	//插件的上下文永远是GLOBALCONTEXT调用
	window.GLOBALCONTEXT = top.context;  //全局上下文(兼容iframe父容器与本身执行环境)
	window.GLOBALIFRAME  = top.iframeMode;   //是否为iframe加载

	//读酷配置文件
	window.DUKUCONFIG    = top.dukuConfig;
	//await
	//path
	//ifrmeDrop

	//嵌套子文档上下文
	window.SUbDOCCONTEXT = top.subContext;
	window.SUbCONFIGT    = top.subConfig;

	//2014.11.26
	//新客户端模式Client
	//地址:url
	//ifrmeDrop
	//path
	//success
	window.CLIENTCONFIGT = top.clientConfig;

	//2015.3.11
	//秒秒学客户端配置
	window.MMXCONFIG = top.mmxConfig;
 
})(function() {

	var iframeMode = false, //是否为iframe加载
		topGlobal, //最外层上下文
		dukuConfig, //读库配置文件
		clientConfig, //客户端配置文件
		mmxConfig, // 秒秒学客户端配置文件
		subContext, //子容器上下
		subConfig; //子文档模式


	//兼容ios处理
	//妙妙客户端版处理问题ios版
    if (top && top.audioHandler) {
        audioHandler = top.audioHandler;
    }


	function testPalt(context){
		try {
			//如果是读库iframe加载
			if (context && context.XXTIFRAME) {
				dukuConfig = context.XXTIFRAME; //取出配置配置文件
				topGlobal  = context;
				iframeMode = true;
			}

			//如果是子文档加载
			if (context && context.XXTSUbDOC) {
				if (!topGlobal) {
					topGlobal = context;
				}
				subContext = context;
				iframeMode = true;
				subConfig  = context.XXTSUbDOC; //取出配置配置文件
			}

			//如果是客户端模式
			//通过零件动态加载iframe
			if (context && context.XXTClient) {
				clientConfig = context.XXTClient; //取出配置配置文件
				topGlobal    = context;
				iframeMode   = true;
			}

			//pc调试模式
			if(!iframeMode && context.iframe){
				iframeMode = true;
			}

			//如果是秒秒学在线客户端加载
			if(context && context.miaomiaoxue){
				mmxConfig  = context.miaomiaoxue
				topGlobal  = context;
				iframeMode = true;
			}
		} catch (er) {

		}		
	}

	//搜索2层作用域
	//1 top
	//2 parent
	testPalt(parent)
	testPalt(top)

	return {
		context      : topGlobal || window,
		iframeMode   : iframeMode,
		subContext   : subContext,
		dukuConfig   : dukuConfig,
		mmxConfig    : mmxConfig,
		clientConfig : clientConfig,
		subConfig    : subConfig
	};
}());
/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

  if ( typeof module === "object" && typeof module.exports === "object" ) {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ?
      factory( global, true ) :
      function( w ) {
        if ( !w.document ) {
          throw new Error( "jQuery requires a window with a document" );
        }
        return factory( w );
      };
  } else {
    factory( global );
  }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
  // Use the correct document accordingly with window argument (sandbox)
  document = window.document,

  version = "2.1.3",

  // Define a local copy of jQuery
  jQuery = function( selector, context ) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init( selector, context );
  },

  // Support: Android<4.1
  // Make sure we trim BOM and NBSP
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

  // Matches dashed string for camelizing
  rmsPrefix = /^-ms-/,
  rdashAlpha = /-([\da-z])/gi,

  // Used by jQuery.camelCase as callback to replace()
  fcamelCase = function( all, letter ) {
    return letter.toUpperCase();
  };

jQuery.fn = jQuery.prototype = {
  // The current version of jQuery being used
  jquery: version,

  constructor: jQuery,

  // Start with an empty selector
  selector: "",

  // The default length of a jQuery object is 0
  length: 0,

  toArray: function() {
    return slice.call( this );
  },

  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function( num ) {
    return num != null ?

      // Return just the one element from the set
      ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

      // Return all the elements in a clean array
      slice.call( this );
  },

  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function( elems ) {

    // Build a new jQuery matched element set
    var ret = jQuery.merge( this.constructor(), elems );

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;
    ret.context = this.context;

    // Return the newly-formed element set
    return ret;
  },

  // Execute a callback for every element in the matched set.
  // (You can seed the arguments with an array of args, but this is
  // only used internally.)
  each: function( callback, args ) {
    return jQuery.each( this, callback, args );
  },

  map: function( callback ) {
    return this.pushStack( jQuery.map(this, function( elem, i ) {
      return callback.call( elem, i, elem );
    }));
  },

  slice: function() {
    return this.pushStack( slice.apply( this, arguments ) );
  },

  first: function() {
    return this.eq( 0 );
  },

  last: function() {
    return this.eq( -1 );
  },

  eq: function( i ) {
    var len = this.length,
      j = +i + ( i < 0 ? len : 0 );
    return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
  },

  end: function() {
    return this.prevObject || this.constructor(null);
  },

  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push: push,
  sort: arr.sort,
  splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
  var options, name, src, copy, copyIsArray, clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // Handle a deep copy situation
  if ( typeof target === "boolean" ) {
    deep = target;

    // Skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
    target = {};
  }

  // Extend jQuery itself if only one argument is passed
  if ( i === length ) {
    target = this;
    i--;
  }

  for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
      // Extend the base object
      for ( name in options ) {
        src = target[ name ];
        copy = options[ name ];

        // Prevent never-ending loop
        if ( target === copy ) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
          if ( copyIsArray ) {
            copyIsArray = false;
            clone = src && jQuery.isArray(src) ? src : [];

          } else {
            clone = src && jQuery.isPlainObject(src) ? src : {};
          }

          // Never move original objects, clone them
          target[ name ] = jQuery.extend( deep, clone, copy );

        // Don't bring in undefined values
        } else if ( copy !== undefined ) {
          target[ name ] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

jQuery.extend({
  // Unique for each copy of jQuery on the page
  expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  // Assume jQuery is ready without the ready module
  isReady: true,

  error: function( msg ) {
    throw new Error( msg );
  },

  noop: function() {},

  isFunction: function( obj ) {
    return jQuery.type(obj) === "function";
  },

  isArray: Array.isArray,

  isWindow: function( obj ) {
    return obj != null && obj === obj.window;
  },

  isNumeric: function( obj ) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
  },

  isPlainObject: function( obj ) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
      return false;
    }

    if ( obj.constructor &&
        !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
      return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
  },

  isEmptyObject: function( obj ) {
    var name;
    for ( name in obj ) {
      return false;
    }
    return true;
  },

  type: function( obj ) {
    if ( obj == null ) {
      return obj + "";
    }
    // Support: Android<4.0, iOS<6 (functionish RegExp)
    return typeof obj === "object" || typeof obj === "function" ?
      class2type[ toString.call(obj) ] || "object" :
      typeof obj;
  },

  // Evaluates a script in a global context
  globalEval: function( code ) {
    var script,
      indirect = eval;

    code = jQuery.trim( code );

    if ( code ) {
      // If the code includes a valid, prologue position
      // strict mode pragma, execute code by injecting a
      // script tag into the document.
      if ( code.indexOf("use strict") === 1 ) {
        script = document.createElement("script");
        script.text = code;
        document.head.appendChild( script ).parentNode.removeChild( script );
      } else {
      // Otherwise, avoid the DOM node creation, insertion
      // and removal by using an indirect global eval
        indirect( code );
      }
    }
  },

  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE9-11+
  // Microsoft forgot to hump their vendor prefix (#9572)
  camelCase: function( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  },

  nodeName: function( elem, name ) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  },

  // args is for internal usage only
  each: function( obj, callback, args ) {
    var value,
      i = 0,
      length = obj.length,
      isArray = isArraylike( obj );

    if ( args ) {
      if ( isArray ) {
        for ( ; i < length; i++ ) {
          value = callback.apply( obj[ i ], args );

          if ( value === false ) {
            break;
          }
        }
      } else {
        for ( i in obj ) {
          value = callback.apply( obj[ i ], args );

          if ( value === false ) {
            break;
          }
        }
      }

    // A special, fast, case for the most common use of each
    } else {
      if ( isArray ) {
        for ( ; i < length; i++ ) {
          value = callback.call( obj[ i ], i, obj[ i ] );

          if ( value === false ) {
            break;
          }
        }
      } else {
        for ( i in obj ) {
          value = callback.call( obj[ i ], i, obj[ i ] );

          if ( value === false ) {
            break;
          }
        }
      }
    }

    return obj;
  },

  // Support: Android<4.1
  trim: function( text ) {
    return text == null ?
      "" :
      ( text + "" ).replace( rtrim, "" );
  },

  // results is for internal usage only
  makeArray: function( arr, results ) {
    var ret = results || [];

    if ( arr != null ) {
      if ( isArraylike( Object(arr) ) ) {
        jQuery.merge( ret,
          typeof arr === "string" ?
          [ arr ] : arr
        );
      } else {
        push.call( ret, arr );
      }
    }

    return ret;
  },

  inArray: function( elem, arr, i ) {
    return arr == null ? -1 : indexOf.call( arr, elem, i );
  },

  merge: function( first, second ) {
    var len = +second.length,
      j = 0,
      i = first.length;

    for ( ; j < len; j++ ) {
      first[ i++ ] = second[ j ];
    }

    first.length = i;

    return first;
  },

  grep: function( elems, callback, invert ) {
    var callbackInverse,
      matches = [],
      i = 0,
      length = elems.length,
      callbackExpect = !invert;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( ; i < length; i++ ) {
      callbackInverse = !callback( elems[ i ], i );
      if ( callbackInverse !== callbackExpect ) {
        matches.push( elems[ i ] );
      }
    }

    return matches;
  },

  // arg is for internal usage only
  map: function( elems, callback, arg ) {
    var value,
      i = 0,
      length = elems.length,
      isArray = isArraylike( elems ),
      ret = [];

    // Go through the array, translating each of the items to their new values
    if ( isArray ) {
      for ( ; i < length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret.push( value );
        }
      }

    // Go through every key on the object,
    } else {
      for ( i in elems ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret.push( value );
        }
      }
    }

    // Flatten any nested arrays
    return concat.apply( [], ret );
  },

  // A global GUID counter for objects
  guid: 1,

  // Bind a function to a context, optionally partially applying any
  // arguments.
  proxy: function( fn, context ) {
    var tmp, args, proxy;

    if ( typeof context === "string" ) {
      tmp = fn[ context ];
      context = fn;
      fn = tmp;
    }

    // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.
    if ( !jQuery.isFunction( fn ) ) {
      return undefined;
    }

    // Simulated bind
    args = slice.call( arguments, 2 );
    proxy = function() {
      return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
    };

    // Set the guid of unique handler to the same of original handler, so it can be removed
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

    return proxy;
  },

  now: Date.now,

  // jQuery.support is not used in Core but other projects attach their
  // properties to it so it needs to exist.
  support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
  class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
  var length = obj.length,
    type = jQuery.type( obj );

  if ( type === "function" || jQuery.isWindow( obj ) ) {
    return false;
  }

  if ( obj.nodeType === 1 && length ) {
    return true;
  }

  return type === "array" || length === 0 ||
    typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
  support,
  Expr,
  getText,
  isXML,
  tokenize,
  compile,
  select,
  outermostContext,
  sortInput,
  hasDuplicate,

  // Local document vars
  setDocument,
  document,
  docElem,
  documentIsHTML,
  rbuggyQSA,
  rbuggyMatches,
  matches,
  contains,

  // Instance-specific data
  expando = "sizzle" + 1 * new Date(),
  preferredDoc = window.document,
  dirruns = 0,
  done = 0,
  classCache = createCache(),
  tokenCache = createCache(),
  compilerCache = createCache(),
  sortOrder = function( a, b ) {
    if ( a === b ) {
      hasDuplicate = true;
    }
    return 0;
  },

  // General-purpose constants
  MAX_NEGATIVE = 1 << 31,

  // Instance methods
  hasOwn = ({}).hasOwnProperty,
  arr = [],
  pop = arr.pop,
  push_native = arr.push,
  push = arr.push,
  slice = arr.slice,
  // Use a stripped-down indexOf as it's faster than native
  // http://jsperf.com/thor-indexof-vs-for/5
  indexOf = function( list, elem ) {
    var i = 0,
      len = list.length;
    for ( ; i < len; i++ ) {
      if ( list[i] === elem ) {
        return i;
      }
    }
    return -1;
  },

  booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

  // Regular expressions

  // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
  whitespace = "[\\x20\\t\\r\\n\\f]",
  // http://www.w3.org/TR/css3-syntax/#characters
  characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

  // Loosely modeled on CSS identifier characters
  // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
  // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  identifier = characterEncoding.replace( "w", "w#" ),

  // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
    // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace +
    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
    "*\\]",

  pseudos = ":(" + characterEncoding + ")(?:\\((" +
    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
    // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
    // 3. anything else (capture 2)
    ".*" +
    ")\\)|)",

  // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  rwhitespace = new RegExp( whitespace + "+", "g" ),
  rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

  rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

  rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

  rpseudo = new RegExp( pseudos ),
  ridentifier = new RegExp( "^" + identifier + "$" ),

  matchExpr = {
    "ID": new RegExp( "^#(" + characterEncoding + ")" ),
    "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
    "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
    "ATTR": new RegExp( "^" + attributes ),
    "PSEUDO": new RegExp( "^" + pseudos ),
    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
      "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
      "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
    // For use in libraries implementing .is()
    // We use this for POS matching in `select`
    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
      whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  },

  rinputs = /^(?:input|select|textarea|button)$/i,
  rheader = /^h\d$/i,

  rnative = /^[^{]+\{\s*\[native \w/,

  // Easily-parseable/retrievable ID or TAG or CLASS selectors
  rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  rsibling = /[+~]/,
  rescape = /'|\\/g,

  // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
  funescape = function( _, escaped, escapedWhitespace ) {
    var high = "0x" + escaped - 0x10000;
    // NaN means non-codepoint
    // Support: Firefox<24
    // Workaround erroneous numeric interpretation of +"0x"
    return high !== high || escapedWhitespace ?
      escaped :
      high < 0 ?
        // BMP codepoint
        String.fromCharCode( high + 0x10000 ) :
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  },

  // Used for iframes
  // See setDocument()
  // Removing the function wrapper causes a "Permission Denied"
  // error in IE
  unloadHandler = function() {
    setDocument();
  };

// Optimize for push.apply( _, NodeList )
try {
  push.apply(
    (arr = slice.call( preferredDoc.childNodes )),
    preferredDoc.childNodes
  );
  // Support: Android<4.0
  // Detect silently failing push.apply
  arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
  push = { apply: arr.length ?

    // Leverage slice if possible
    function( target, els ) {
      push_native.apply( target, slice.call(els) );
    } :

    // Support: IE<9
    // Otherwise append directly
    function( target, els ) {
      var j = target.length,
        i = 0;
      // Can't trust NodeList.length
      while ( (target[j++] = els[i++]) ) {}
      target.length = j - 1;
    }
  };
}

function Sizzle( selector, context, results, seed ) {
  var match, elem, m, nodeType,
    // QSA vars
    i, groups, old, nid, newContext, newSelector;

  if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
    setDocument( context );
  }

  context = context || document;
  results = results || [];
  nodeType = context.nodeType;

  if ( typeof selector !== "string" || !selector ||
    nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

    return results;
  }

  if ( !seed && documentIsHTML ) {

    // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
    if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
      // Speed-up: Sizzle("#ID")
      if ( (m = match[1]) ) {
        if ( nodeType === 9 ) {
          elem = context.getElementById( m );
          // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document (jQuery #6963)
          if ( elem && elem.parentNode ) {
            // Handle the case where IE, Opera, and Webkit return items
            // by name instead of ID
            if ( elem.id === m ) {
              results.push( elem );
              return results;
            }
          } else {
            return results;
          }
        } else {
          // Context is not a document
          if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
            contains( context, elem ) && elem.id === m ) {
            results.push( elem );
            return results;
          }
        }

      // Speed-up: Sizzle("TAG")
      } else if ( match[2] ) {
        push.apply( results, context.getElementsByTagName( selector ) );
        return results;

      // Speed-up: Sizzle(".CLASS")
      } else if ( (m = match[3]) && support.getElementsByClassName ) {
        push.apply( results, context.getElementsByClassName( m ) );
        return results;
      }
    }

    // QSA path
    if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
      nid = old = expando;
      newContext = context;
      newSelector = nodeType !== 1 && selector;

      // qSA works strangely on Element-rooted queries
      // We can work around this by specifying an extra ID on the root
      // and working up from there (Thanks to Andrew Dupont for the technique)
      // IE 8 doesn't work on object elements
      if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
        groups = tokenize( selector );

        if ( (old = context.getAttribute("id")) ) {
          nid = old.replace( rescape, "\\$&" );
        } else {
          context.setAttribute( "id", nid );
        }
        nid = "[id='" + nid + "'] ";

        i = groups.length;
        while ( i-- ) {
          groups[i] = nid + toSelector( groups[i] );
        }
        newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
        newSelector = groups.join(",");
      }

      if ( newSelector ) {
        try {
          push.apply( results,
            newContext.querySelectorAll( newSelector )
          );
          return results;
        } catch(qsaError) {
        } finally {
          if ( !old ) {
            context.removeAttribute("id");
          }
        }
      }
    }
  }

  // All others
  return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *  deleting the oldest entry
 */
function createCache() {
  var keys = [];

  function cache( key, value ) {
    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
    if ( keys.push( key + " " ) > Expr.cacheLength ) {
      // Only keep the most recent entries
      delete cache[ keys.shift() ];
    }
    return (cache[ key + " " ] = value);
  }
  return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
  fn[ expando ] = true;
  return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
  var div = document.createElement("div");

  try {
    return !!fn( div );
  } catch (e) {
    return false;
  } finally {
    // Remove from its parent by default
    if ( div.parentNode ) {
      div.parentNode.removeChild( div );
    }
    // release memory in IE
    div = null;
  }
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
  var arr = attrs.split("|"),
    i = attrs.length;

  while ( i-- ) {
    Expr.attrHandle[ arr[i] ] = handler;
  }
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
  var cur = b && a,
    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
      ( ~b.sourceIndex || MAX_NEGATIVE ) -
      ( ~a.sourceIndex || MAX_NEGATIVE );

  // Use IE sourceIndex if available on both nodes
  if ( diff ) {
    return diff;
  }

  // Check if b follows a
  if ( cur ) {
    while ( (cur = cur.nextSibling) ) {
      if ( cur === b ) {
        return -1;
      }
    }
  }

  return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return name === "input" && elem.type === type;
  };
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return (name === "input" || name === "button") && elem.type === type;
  };
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
  return markFunction(function( argument ) {
    argument = +argument;
    return markFunction(function( seed, matches ) {
      var j,
        matchIndexes = fn( [], seed.length, argument ),
        i = matchIndexes.length;

      // Match elements found at the specified indexes
      while ( i-- ) {
        if ( seed[ (j = matchIndexes[i]) ] ) {
          seed[j] = !(matches[j] = seed[j]);
        }
      }
    });
  });
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
  return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
  // documentElement is verified for cases where it doesn't yet exist
  // (such as loading iframes in IE - #4833)
  var documentElement = elem && (elem.ownerDocument || elem).documentElement;
  return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
  var hasCompare, parent,
    doc = node ? node.ownerDocument || node : preferredDoc;

  // If no document and documentElement is available, return
  if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
    return document;
  }

  // Set our document
  document = doc;
  docElem = doc.documentElement;
  parent = doc.defaultView;

  // Support: IE>8
  // If iframe document is assigned to "document" variable and if iframe has been reloaded,
  // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
  // IE6-8 do not support the defaultView property so parent will be undefined
  if ( parent && parent !== parent.top ) {
    // IE11 does not have attachEvent, so all must suffer
    if ( parent.addEventListener ) {
      parent.addEventListener( "unload", unloadHandler, false );
    } else if ( parent.attachEvent ) {
      parent.attachEvent( "onunload", unloadHandler );
    }
  }

  /* Support tests
  ---------------------------------------------------------------------- */
  documentIsHTML = !isXML( doc );

  /* Attributes
  ---------------------------------------------------------------------- */

  // Support: IE<8
  // Verify that getAttribute really returns attributes and not properties
  // (excepting IE8 booleans)
  support.attributes = assert(function( div ) {
    div.className = "i";
    return !div.getAttribute("className");
  });

  /* getElement(s)By*
  ---------------------------------------------------------------------- */

  // Check if getElementsByTagName("*") returns only elements
  support.getElementsByTagName = assert(function( div ) {
    div.appendChild( doc.createComment("") );
    return !div.getElementsByTagName("*").length;
  });

  // Support: IE<9
  support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

  // Support: IE<10
  // Check if getElementById returns elements by name
  // The broken getElementById methods don't pick up programatically-set names,
  // so use a roundabout getElementsByName test
  support.getById = assert(function( div ) {
    docElem.appendChild( div ).id = expando;
    return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
  });

  // ID find and filter
  if ( support.getById ) {
    Expr.find["ID"] = function( id, context ) {
      if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
        var m = context.getElementById( id );
        // Check parentNode to catch when Blackberry 4.6 returns
        // nodes that are no longer in the document #6963
        return m && m.parentNode ? [ m ] : [];
      }
    };
    Expr.filter["ID"] = function( id ) {
      var attrId = id.replace( runescape, funescape );
      return function( elem ) {
        return elem.getAttribute("id") === attrId;
      };
    };
  } else {
    // Support: IE6/7
    // getElementById is not reliable as a find shortcut
    delete Expr.find["ID"];

    Expr.filter["ID"] =  function( id ) {
      var attrId = id.replace( runescape, funescape );
      return function( elem ) {
        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
        return node && node.value === attrId;
      };
    };
  }

  // Tag
  Expr.find["TAG"] = support.getElementsByTagName ?
    function( tag, context ) {
      if ( typeof context.getElementsByTagName !== "undefined" ) {
        return context.getElementsByTagName( tag );

      // DocumentFragment nodes don't have gEBTN
      } else if ( support.qsa ) {
        return context.querySelectorAll( tag );
      }
    } :

    function( tag, context ) {
      var elem,
        tmp = [],
        i = 0,
        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName( tag );

      // Filter out possible comments
      if ( tag === "*" ) {
        while ( (elem = results[i++]) ) {
          if ( elem.nodeType === 1 ) {
            tmp.push( elem );
          }
        }

        return tmp;
      }
      return results;
    };

  // Class
  Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
    if ( documentIsHTML ) {
      return context.getElementsByClassName( className );
    }
  };

  /* QSA/matchesSelector
  ---------------------------------------------------------------------- */

  // QSA and matchesSelector support

  // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  rbuggyMatches = [];

  // qSa(:focus) reports false when true (Chrome 21)
  // We allow this because of a bug in IE8/9 that throws an error
  // whenever `document.activeElement` is accessed on an iframe
  // So, we allow :focus to pass through QSA all the time to avoid the IE error
  // See http://bugs.jquery.com/ticket/13378
  rbuggyQSA = [];

  if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
    // Build QSA regex
    // Regex strategy adopted from Diego Perini
    assert(function( div ) {
      // Select is set to empty string on purpose
      // This is to test IE's treatment of not explicitly
      // setting a boolean content attribute,
      // since its presence should be enough
      // http://bugs.jquery.com/ticket/12359
      docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
        "<select id='" + expando + "-\f]' msallowcapture=''>" +
        "<option selected=''></option></select>";

      // Support: IE8, Opera 11-12.16
      // Nothing should be selected when empty strings follow ^= or $= or *=
      // The test attribute must be unknown in Opera but "safe" for WinRT
      // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
      if ( div.querySelectorAll("[msallowcapture^='']").length ) {
        rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
      }

      // Support: IE8
      // Boolean attributes and "value" are not treated correctly
      if ( !div.querySelectorAll("[selected]").length ) {
        rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
      }

      // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
      if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
        rbuggyQSA.push("~=");
      }

      // Webkit/Opera - :checked should return selected option elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      // IE8 throws error here and will not see later tests
      if ( !div.querySelectorAll(":checked").length ) {
        rbuggyQSA.push(":checked");
      }

      // Support: Safari 8+, iOS 8+
      // https://bugs.webkit.org/show_bug.cgi?id=136851
      // In-page `selector#id sibing-combinator selector` fails
      if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
        rbuggyQSA.push(".#.+[+~]");
      }
    });

    assert(function( div ) {
      // Support: Windows 8 Native Apps
      // The type and name attributes are restricted during .innerHTML assignment
      var input = doc.createElement("input");
      input.setAttribute( "type", "hidden" );
      div.appendChild( input ).setAttribute( "name", "D" );

      // Support: IE8
      // Enforce case-sensitivity of name attribute
      if ( div.querySelectorAll("[name=d]").length ) {
        rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
      }

      // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
      // IE8 throws error here and will not see later tests
      if ( !div.querySelectorAll(":enabled").length ) {
        rbuggyQSA.push( ":enabled", ":disabled" );
      }

      // Opera 10-11 does not throw on post-comma invalid pseudos
      div.querySelectorAll("*,:x");
      rbuggyQSA.push(",.*:");
    });
  }

  if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
    docElem.webkitMatchesSelector ||
    docElem.mozMatchesSelector ||
    docElem.oMatchesSelector ||
    docElem.msMatchesSelector) )) ) {

    assert(function( div ) {
      // Check to see if it's possible to do matchesSelector
      // on a disconnected node (IE 9)
      support.disconnectedMatch = matches.call( div, "div" );

      // This should fail with an exception
      // Gecko does not error, returns false instead
      matches.call( div, "[s!='']:x" );
      rbuggyMatches.push( "!=", pseudos );
    });
  }

  rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
  rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

  /* Contains
  ---------------------------------------------------------------------- */
  hasCompare = rnative.test( docElem.compareDocumentPosition );

  // Element contains another
  // Purposefully does not implement inclusive descendent
  // As in, an element does not contain itself
  contains = hasCompare || rnative.test( docElem.contains ) ?
    function( a, b ) {
      var adown = a.nodeType === 9 ? a.documentElement : a,
        bup = b && b.parentNode;
      return a === bup || !!( bup && bup.nodeType === 1 && (
        adown.contains ?
          adown.contains( bup ) :
          a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
      ));
    } :
    function( a, b ) {
      if ( b ) {
        while ( (b = b.parentNode) ) {
          if ( b === a ) {
            return true;
          }
        }
      }
      return false;
    };

  /* Sorting
  ---------------------------------------------------------------------- */

  // Document order sorting
  sortOrder = hasCompare ?
  function( a, b ) {

    // Flag for duplicate removal
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    // Sort on method existence if only one input has compareDocumentPosition
    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    if ( compare ) {
      return compare;
    }

    // Calculate position if both inputs belong to the same document
    compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
      a.compareDocumentPosition( b ) :

      // Otherwise we know they are disconnected
      1;

    // Disconnected nodes
    if ( compare & 1 ||
      (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

      // Choose the first element that is related to our preferred document
      if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
        return -1;
      }
      if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
        return 1;
      }

      // Maintain original order
      return sortInput ?
        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
        0;
    }

    return compare & 4 ? -1 : 1;
  } :
  function( a, b ) {
    // Exit early if the nodes are identical
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    var cur,
      i = 0,
      aup = a.parentNode,
      bup = b.parentNode,
      ap = [ a ],
      bp = [ b ];

    // Parentless nodes are either documents or disconnected
    if ( !aup || !bup ) {
      return a === doc ? -1 :
        b === doc ? 1 :
        aup ? -1 :
        bup ? 1 :
        sortInput ?
        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
        0;

    // If the nodes are siblings, we can do a quick check
    } else if ( aup === bup ) {
      return siblingCheck( a, b );
    }

    // Otherwise we need full lists of their ancestors for comparison
    cur = a;
    while ( (cur = cur.parentNode) ) {
      ap.unshift( cur );
    }
    cur = b;
    while ( (cur = cur.parentNode) ) {
      bp.unshift( cur );
    }

    // Walk down the tree looking for a discrepancy
    while ( ap[i] === bp[i] ) {
      i++;
    }

    return i ?
      // Do a sibling check if the nodes have a common ancestor
      siblingCheck( ap[i], bp[i] ) :

      // Otherwise nodes in our document sort first
      ap[i] === preferredDoc ? -1 :
      bp[i] === preferredDoc ? 1 :
      0;
  };

  return doc;
};

Sizzle.matches = function( expr, elements ) {
  return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
  // Set document vars if needed
  if ( ( elem.ownerDocument || elem ) !== document ) {
    setDocument( elem );
  }

  // Make sure that attribute selectors are quoted
  expr = expr.replace( rattributeQuotes, "='$1']" );

  if ( support.matchesSelector && documentIsHTML &&
    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

    try {
      var ret = matches.call( elem, expr );

      // IE 9's matchesSelector returns false on disconnected nodes
      if ( ret || support.disconnectedMatch ||
          // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11 ) {
        return ret;
      }
    } catch (e) {}
  }

  return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
  // Set document vars if needed
  if ( ( context.ownerDocument || context ) !== document ) {
    setDocument( context );
  }
  return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
  // Set document vars if needed
  if ( ( elem.ownerDocument || elem ) !== document ) {
    setDocument( elem );
  }

  var fn = Expr.attrHandle[ name.toLowerCase() ],
    // Don't get fooled by Object.prototype properties (jQuery #13807)
    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
      fn( elem, name, !documentIsHTML ) :
      undefined;

  return val !== undefined ?
    val :
    support.attributes || !documentIsHTML ?
      elem.getAttribute( name ) :
      (val = elem.getAttributeNode(name)) && val.specified ?
        val.value :
        null;
};

Sizzle.error = function( msg ) {
  throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
  var elem,
    duplicates = [],
    j = 0,
    i = 0;

  // Unless we *know* we can detect duplicates, assume their presence
  hasDuplicate = !support.detectDuplicates;
  sortInput = !support.sortStable && results.slice( 0 );
  results.sort( sortOrder );

  if ( hasDuplicate ) {
    while ( (elem = results[i++]) ) {
      if ( elem === results[ i ] ) {
        j = duplicates.push( i );
      }
    }
    while ( j-- ) {
      results.splice( duplicates[ j ], 1 );
    }
  }

  // Clear input after sorting to release objects
  // See https://github.com/jquery/sizzle/pull/225
  sortInput = null;

  return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
  var node,
    ret = "",
    i = 0,
    nodeType = elem.nodeType;

  if ( !nodeType ) {
    // If no nodeType, this is expected to be an array
    while ( (node = elem[i++]) ) {
      // Do not traverse comment nodes
      ret += getText( node );
    }
  } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
    // Use textContent for elements
    // innerText usage removed for consistency of new lines (jQuery #11153)
    if ( typeof elem.textContent === "string" ) {
      return elem.textContent;
    } else {
      // Traverse its children
      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
        ret += getText( elem );
      }
    }
  } else if ( nodeType === 3 || nodeType === 4 ) {
    return elem.nodeValue;
  }
  // Do not include comment or processing instruction nodes

  return ret;
};

Expr = Sizzle.selectors = {

  // Can be adjusted by the user
  cacheLength: 50,

  createPseudo: markFunction,

  match: matchExpr,

  attrHandle: {},

  find: {},

  relative: {
    ">": { dir: "parentNode", first: true },
    " ": { dir: "parentNode" },
    "+": { dir: "previousSibling", first: true },
    "~": { dir: "previousSibling" }
  },

  preFilter: {
    "ATTR": function( match ) {
      match[1] = match[1].replace( runescape, funescape );

      // Move the given value to match[3] whether quoted or unquoted
      match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

      if ( match[2] === "~=" ) {
        match[3] = " " + match[3] + " ";
      }

      return match.slice( 0, 4 );
    },

    "CHILD": function( match ) {
      /* matches from matchExpr["CHILD"]
        1 type (only|nth|...)
        2 what (child|of-type)
        3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
        4 xn-component of xn+y argument ([+-]?\d*n|)
        5 sign of xn-component
        6 x of xn-component
        7 sign of y-component
        8 y of y-component
      */
      match[1] = match[1].toLowerCase();

      if ( match[1].slice( 0, 3 ) === "nth" ) {
        // nth-* requires argument
        if ( !match[3] ) {
          Sizzle.error( match[0] );
        }

        // numeric x and y parameters for Expr.filter.CHILD
        // remember that false/true cast respectively to 0/1
        match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
        match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

      // other types prohibit arguments
      } else if ( match[3] ) {
        Sizzle.error( match[0] );
      }

      return match;
    },

    "PSEUDO": function( match ) {
      var excess,
        unquoted = !match[6] && match[2];

      if ( matchExpr["CHILD"].test( match[0] ) ) {
        return null;
      }

      // Accept quoted arguments as-is
      if ( match[3] ) {
        match[2] = match[4] || match[5] || "";

      // Strip excess characters from unquoted arguments
      } else if ( unquoted && rpseudo.test( unquoted ) &&
        // Get excess from tokenize (recursively)
        (excess = tokenize( unquoted, true )) &&
        // advance to the next closing parenthesis
        (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

        // excess is a negative index
        match[0] = match[0].slice( 0, excess );
        match[2] = unquoted.slice( 0, excess );
      }

      // Return only captures needed by the pseudo filter method (type and argument)
      return match.slice( 0, 3 );
    }
  },

  filter: {

    "TAG": function( nodeNameSelector ) {
      var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
      return nodeNameSelector === "*" ?
        function() { return true; } :
        function( elem ) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
    },

    "CLASS": function( className ) {
      var pattern = classCache[ className + " " ];

      return pattern ||
        (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
        classCache( className, function( elem ) {
          return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
        });
    },

    "ATTR": function( name, operator, check ) {
      return function( elem ) {
        var result = Sizzle.attr( elem, name );

        if ( result == null ) {
          return operator === "!=";
        }
        if ( !operator ) {
          return true;
        }

        result += "";

        return operator === "=" ? result === check :
          operator === "!=" ? result !== check :
          operator === "^=" ? check && result.indexOf( check ) === 0 :
          operator === "*=" ? check && result.indexOf( check ) > -1 :
          operator === "$=" ? check && result.slice( -check.length ) === check :
          operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
          operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
          false;
      };
    },

    "CHILD": function( type, what, argument, first, last ) {
      var simple = type.slice( 0, 3 ) !== "nth",
        forward = type.slice( -4 ) !== "last",
        ofType = what === "of-type";

      return first === 1 && last === 0 ?

        // Shortcut for :nth-*(n)
        function( elem ) {
          return !!elem.parentNode;
        } :

        function( elem, context, xml ) {
          var cache, outerCache, node, diff, nodeIndex, start,
            dir = simple !== forward ? "nextSibling" : "previousSibling",
            parent = elem.parentNode,
            name = ofType && elem.nodeName.toLowerCase(),
            useCache = !xml && !ofType;

          if ( parent ) {

            // :(first|last|only)-(child|of-type)
            if ( simple ) {
              while ( dir ) {
                node = elem;
                while ( (node = node[ dir ]) ) {
                  if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                    return false;
                  }
                }
                // Reverse direction for :only-* (if we haven't yet done so)
                start = dir = type === "only" && !start && "nextSibling";
              }
              return true;
            }

            start = [ forward ? parent.firstChild : parent.lastChild ];

            // non-xml :nth-child(...) stores cache data on `parent`
            if ( forward && useCache ) {
              // Seek `elem` from a previously-cached index
              outerCache = parent[ expando ] || (parent[ expando ] = {});
              cache = outerCache[ type ] || [];
              nodeIndex = cache[0] === dirruns && cache[1];
              diff = cache[0] === dirruns && cache[2];
              node = nodeIndex && parent.childNodes[ nodeIndex ];

              while ( (node = ++nodeIndex && node && node[ dir ] ||

                // Fallback to seeking `elem` from the start
                (diff = nodeIndex = 0) || start.pop()) ) {

                // When found, cache indexes on `parent` and break
                if ( node.nodeType === 1 && ++diff && node === elem ) {
                  outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                  break;
                }
              }

            // Use previously-cached element index if available
            } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
              diff = cache[1];

            // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
            } else {
              // Use the same loop as above to seek `elem` from the start
              while ( (node = ++nodeIndex && node && node[ dir ] ||
                (diff = nodeIndex = 0) || start.pop()) ) {

                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                  // Cache the index of each encountered element
                  if ( useCache ) {
                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                  }

                  if ( node === elem ) {
                    break;
                  }
                }
              }
            }

            // Incorporate the offset, then check against cycle size
            diff -= last;
            return diff === first || ( diff % first === 0 && diff / first >= 0 );
          }
        };
    },

    "PSEUDO": function( pseudo, argument ) {
      // pseudo-class names are case-insensitive
      // http://www.w3.org/TR/selectors/#pseudo-classes
      // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
      // Remember that setFilters inherits from pseudos
      var args,
        fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
          Sizzle.error( "unsupported pseudo: " + pseudo );

      // The user may use createPseudo to indicate that
      // arguments are needed to create the filter function
      // just as Sizzle does
      if ( fn[ expando ] ) {
        return fn( argument );
      }

      // But maintain support for old signatures
      if ( fn.length > 1 ) {
        args = [ pseudo, pseudo, "", argument ];
        return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
          markFunction(function( seed, matches ) {
            var idx,
              matched = fn( seed, argument ),
              i = matched.length;
            while ( i-- ) {
              idx = indexOf( seed, matched[i] );
              seed[ idx ] = !( matches[ idx ] = matched[i] );
            }
          }) :
          function( elem ) {
            return fn( elem, 0, args );
          };
      }

      return fn;
    }
  },

  pseudos: {
    // Potentially complex pseudos
    "not": markFunction(function( selector ) {
      // Trim the selector passed to compile
      // to avoid treating leading and trailing
      // spaces as combinators
      var input = [],
        results = [],
        matcher = compile( selector.replace( rtrim, "$1" ) );

      return matcher[ expando ] ?
        markFunction(function( seed, matches, context, xml ) {
          var elem,
            unmatched = matcher( seed, null, xml, [] ),
            i = seed.length;

          // Match elements unmatched by `matcher`
          while ( i-- ) {
            if ( (elem = unmatched[i]) ) {
              seed[i] = !(matches[i] = elem);
            }
          }
        }) :
        function( elem, context, xml ) {
          input[0] = elem;
          matcher( input, null, xml, results );
          // Don't keep the element (issue #299)
          input[0] = null;
          return !results.pop();
        };
    }),

    "has": markFunction(function( selector ) {
      return function( elem ) {
        return Sizzle( selector, elem ).length > 0;
      };
    }),

    "contains": markFunction(function( text ) {
      text = text.replace( runescape, funescape );
      return function( elem ) {
        return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
      };
    }),

    // "Whether an element is represented by a :lang() selector
    // is based solely on the element's language value
    // being equal to the identifier C,
    // or beginning with the identifier C immediately followed by "-".
    // The matching of C against the element's language value is performed case-insensitively.
    // The identifier C does not have to be a valid language name."
    // http://www.w3.org/TR/selectors/#lang-pseudo
    "lang": markFunction( function( lang ) {
      // lang value must be a valid identifier
      if ( !ridentifier.test(lang || "") ) {
        Sizzle.error( "unsupported lang: " + lang );
      }
      lang = lang.replace( runescape, funescape ).toLowerCase();
      return function( elem ) {
        var elemLang;
        do {
          if ( (elemLang = documentIsHTML ?
            elem.lang :
            elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

            elemLang = elemLang.toLowerCase();
            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
          }
        } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
        return false;
      };
    }),

    // Miscellaneous
    "target": function( elem ) {
      var hash = window.location && window.location.hash;
      return hash && hash.slice( 1 ) === elem.id;
    },

    "root": function( elem ) {
      return elem === docElem;
    },

    "focus": function( elem ) {
      return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
    },

    // Boolean properties
    "enabled": function( elem ) {
      return elem.disabled === false;
    },

    "disabled": function( elem ) {
      return elem.disabled === true;
    },

    "checked": function( elem ) {
      // In CSS3, :checked should return both checked and selected elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      var nodeName = elem.nodeName.toLowerCase();
      return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
    },

    "selected": function( elem ) {
      // Accessing this property makes selected-by-default
      // options in Safari work properly
      if ( elem.parentNode ) {
        elem.parentNode.selectedIndex;
      }

      return elem.selected === true;
    },

    // Contents
    "empty": function( elem ) {
      // http://www.w3.org/TR/selectors/#empty-pseudo
      // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
      //   but not by others (comment: 8; processing instruction: 7; etc.)
      // nodeType < 6 works because attributes (2) do not appear as children
      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
        if ( elem.nodeType < 6 ) {
          return false;
        }
      }
      return true;
    },

    "parent": function( elem ) {
      return !Expr.pseudos["empty"]( elem );
    },

    // Element/input types
    "header": function( elem ) {
      return rheader.test( elem.nodeName );
    },

    "input": function( elem ) {
      return rinputs.test( elem.nodeName );
    },

    "button": function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === "button" || name === "button";
    },

    "text": function( elem ) {
      var attr;
      return elem.nodeName.toLowerCase() === "input" &&
        elem.type === "text" &&

        // Support: IE<8
        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
        ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
    },

    // Position-in-collection
    "first": createPositionalPseudo(function() {
      return [ 0 ];
    }),

    "last": createPositionalPseudo(function( matchIndexes, length ) {
      return [ length - 1 ];
    }),

    "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
      return [ argument < 0 ? argument + length : argument ];
    }),

    "even": createPositionalPseudo(function( matchIndexes, length ) {
      var i = 0;
      for ( ; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "odd": createPositionalPseudo(function( matchIndexes, length ) {
      var i = 1;
      for ( ; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
      var i = argument < 0 ? argument + length : argument;
      for ( ; --i >= 0; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
      var i = argument < 0 ? argument + length : argument;
      for ( ; ++i < length; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    })
  }
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
  Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
  var matched, match, tokens, type,
    soFar, groups, preFilters,
    cached = tokenCache[ selector + " " ];

  if ( cached ) {
    return parseOnly ? 0 : cached.slice( 0 );
  }

  soFar = selector;
  groups = [];
  preFilters = Expr.preFilter;

  while ( soFar ) {

    // Comma and first run
    if ( !matched || (match = rcomma.exec( soFar )) ) {
      if ( match ) {
        // Don't consume trailing commas as valid
        soFar = soFar.slice( match[0].length ) || soFar;
      }
      groups.push( (tokens = []) );
    }

    matched = false;

    // Combinators
    if ( (match = rcombinators.exec( soFar )) ) {
      matched = match.shift();
      tokens.push({
        value: matched,
        // Cast descendant combinators to space
        type: match[0].replace( rtrim, " " )
      });
      soFar = soFar.slice( matched.length );
    }

    // Filters
    for ( type in Expr.filter ) {
      if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
        (match = preFilters[ type ]( match ))) ) {
        matched = match.shift();
        tokens.push({
          value: matched,
          type: type,
          matches: match
        });
        soFar = soFar.slice( matched.length );
      }
    }

    if ( !matched ) {
      break;
    }
  }

  // Return the length of the invalid excess
  // if we're just parsing
  // Otherwise, throw an error or return tokens
  return parseOnly ?
    soFar.length :
    soFar ?
      Sizzle.error( selector ) :
      // Cache the tokens
      tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
  var i = 0,
    len = tokens.length,
    selector = "";
  for ( ; i < len; i++ ) {
    selector += tokens[i].value;
  }
  return selector;
}

function addCombinator( matcher, combinator, base ) {
  var dir = combinator.dir,
    checkNonElements = base && dir === "parentNode",
    doneName = done++;

  return combinator.first ?
    // Check against closest ancestor/preceding element
    function( elem, context, xml ) {
      while ( (elem = elem[ dir ]) ) {
        if ( elem.nodeType === 1 || checkNonElements ) {
          return matcher( elem, context, xml );
        }
      }
    } :

    // Check against all ancestor/preceding elements
    function( elem, context, xml ) {
      var oldCache, outerCache,
        newCache = [ dirruns, doneName ];

      // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
      if ( xml ) {
        while ( (elem = elem[ dir ]) ) {
          if ( elem.nodeType === 1 || checkNonElements ) {
            if ( matcher( elem, context, xml ) ) {
              return true;
            }
          }
        }
      } else {
        while ( (elem = elem[ dir ]) ) {
          if ( elem.nodeType === 1 || checkNonElements ) {
            outerCache = elem[ expando ] || (elem[ expando ] = {});
            if ( (oldCache = outerCache[ dir ]) &&
              oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

              // Assign to newCache so results back-propagate to previous elements
              return (newCache[ 2 ] = oldCache[ 2 ]);
            } else {
              // Reuse newcache so results back-propagate to previous elements
              outerCache[ dir ] = newCache;

              // A match means we're done; a fail means we have to keep checking
              if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                return true;
              }
            }
          }
        }
      }
    };
}

function elementMatcher( matchers ) {
  return matchers.length > 1 ?
    function( elem, context, xml ) {
      var i = matchers.length;
      while ( i-- ) {
        if ( !matchers[i]( elem, context, xml ) ) {
          return false;
        }
      }
      return true;
    } :
    matchers[0];
}

function multipleContexts( selector, contexts, results ) {
  var i = 0,
    len = contexts.length;
  for ( ; i < len; i++ ) {
    Sizzle( selector, contexts[i], results );
  }
  return results;
}

function condense( unmatched, map, filter, context, xml ) {
  var elem,
    newUnmatched = [],
    i = 0,
    len = unmatched.length,
    mapped = map != null;

  for ( ; i < len; i++ ) {
    if ( (elem = unmatched[i]) ) {
      if ( !filter || filter( elem, context, xml ) ) {
        newUnmatched.push( elem );
        if ( mapped ) {
          map.push( i );
        }
      }
    }
  }

  return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  if ( postFilter && !postFilter[ expando ] ) {
    postFilter = setMatcher( postFilter );
  }
  if ( postFinder && !postFinder[ expando ] ) {
    postFinder = setMatcher( postFinder, postSelector );
  }
  return markFunction(function( seed, results, context, xml ) {
    var temp, i, elem,
      preMap = [],
      postMap = [],
      preexisting = results.length,

      // Get initial elements from seed or context
      elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

      // Prefilter to get matcher input, preserving a map for seed-results synchronization
      matcherIn = preFilter && ( seed || !selector ) ?
        condense( elems, preMap, preFilter, context, xml ) :
        elems,

      matcherOut = matcher ?
        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

          // ...intermediate processing is necessary
          [] :

          // ...otherwise use results directly
          results :
        matcherIn;

    // Find primary matches
    if ( matcher ) {
      matcher( matcherIn, matcherOut, context, xml );
    }

    // Apply postFilter
    if ( postFilter ) {
      temp = condense( matcherOut, postMap );
      postFilter( temp, [], context, xml );

      // Un-match failing elements by moving them back to matcherIn
      i = temp.length;
      while ( i-- ) {
        if ( (elem = temp[i]) ) {
          matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
        }
      }
    }

    if ( seed ) {
      if ( postFinder || preFilter ) {
        if ( postFinder ) {
          // Get the final matcherOut by condensing this intermediate into postFinder contexts
          temp = [];
          i = matcherOut.length;
          while ( i-- ) {
            if ( (elem = matcherOut[i]) ) {
              // Restore matcherIn since elem is not yet a final match
              temp.push( (matcherIn[i] = elem) );
            }
          }
          postFinder( null, (matcherOut = []), temp, xml );
        }

        // Move matched elements from seed to results to keep them synchronized
        i = matcherOut.length;
        while ( i-- ) {
          if ( (elem = matcherOut[i]) &&
            (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

            seed[temp] = !(results[temp] = elem);
          }
        }
      }

    // Add elements to results, through postFinder if defined
    } else {
      matcherOut = condense(
        matcherOut === results ?
          matcherOut.splice( preexisting, matcherOut.length ) :
          matcherOut
      );
      if ( postFinder ) {
        postFinder( null, results, matcherOut, xml );
      } else {
        push.apply( results, matcherOut );
      }
    }
  });
}

function matcherFromTokens( tokens ) {
  var checkContext, matcher, j,
    len = tokens.length,
    leadingRelative = Expr.relative[ tokens[0].type ],
    implicitRelative = leadingRelative || Expr.relative[" "],
    i = leadingRelative ? 1 : 0,

    // The foundational matcher ensures that elements are reachable from top-level context(s)
    matchContext = addCombinator( function( elem ) {
      return elem === checkContext;
    }, implicitRelative, true ),
    matchAnyContext = addCombinator( function( elem ) {
      return indexOf( checkContext, elem ) > -1;
    }, implicitRelative, true ),
    matchers = [ function( elem, context, xml ) {
      var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
        (checkContext = context).nodeType ?
          matchContext( elem, context, xml ) :
          matchAnyContext( elem, context, xml ) );
      // Avoid hanging onto element (issue #299)
      checkContext = null;
      return ret;
    } ];

  for ( ; i < len; i++ ) {
    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
      matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
    } else {
      matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

      // Return special upon seeing a positional matcher
      if ( matcher[ expando ] ) {
        // Find the next relative operator (if any) for proper handling
        j = ++i;
        for ( ; j < len; j++ ) {
          if ( Expr.relative[ tokens[j].type ] ) {
            break;
          }
        }
        return setMatcher(
          i > 1 && elementMatcher( matchers ),
          i > 1 && toSelector(
            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
          ).replace( rtrim, "$1" ),
          matcher,
          i < j && matcherFromTokens( tokens.slice( i, j ) ),
          j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
          j < len && toSelector( tokens )
        );
      }
      matchers.push( matcher );
    }
  }

  return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  var bySet = setMatchers.length > 0,
    byElement = elementMatchers.length > 0,
    superMatcher = function( seed, context, xml, results, outermost ) {
      var elem, j, matcher,
        matchedCount = 0,
        i = "0",
        unmatched = seed && [],
        setMatched = [],
        contextBackup = outermostContext,
        // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
        // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
        len = elems.length;

      if ( outermost ) {
        outermostContext = context !== document && context;
      }

      // Add elements passing elementMatchers directly to results
      // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
      // Support: IE<9, Safari
      // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
      for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
        if ( byElement && elem ) {
          j = 0;
          while ( (matcher = elementMatchers[j++]) ) {
            if ( matcher( elem, context, xml ) ) {
              results.push( elem );
              break;
            }
          }
          if ( outermost ) {
            dirruns = dirrunsUnique;
          }
        }

        // Track unmatched elements for set filters
        if ( bySet ) {
          // They will have gone through all possible matchers
          if ( (elem = !matcher && elem) ) {
            matchedCount--;
          }

          // Lengthen the array for every element, matched or not
          if ( seed ) {
            unmatched.push( elem );
          }
        }
      }

      // Apply set filters to unmatched elements
      matchedCount += i;
      if ( bySet && i !== matchedCount ) {
        j = 0;
        while ( (matcher = setMatchers[j++]) ) {
          matcher( unmatched, setMatched, context, xml );
        }

        if ( seed ) {
          // Reintegrate element matches to eliminate the need for sorting
          if ( matchedCount > 0 ) {
            while ( i-- ) {
              if ( !(unmatched[i] || setMatched[i]) ) {
                setMatched[i] = pop.call( results );
              }
            }
          }

          // Discard index placeholder values to get only actual matches
          setMatched = condense( setMatched );
        }

        // Add matches to results
        push.apply( results, setMatched );

        // Seedless set matches succeeding multiple successful matchers stipulate sorting
        if ( outermost && !seed && setMatched.length > 0 &&
          ( matchedCount + setMatchers.length ) > 1 ) {

          Sizzle.uniqueSort( results );
        }
      }

      // Override manipulation of globals by nested matchers
      if ( outermost ) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }

      return unmatched;
    };

  return bySet ?
    markFunction( superMatcher ) :
    superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
  var i,
    setMatchers = [],
    elementMatchers = [],
    cached = compilerCache[ selector + " " ];

  if ( !cached ) {
    // Generate a function of recursive functions that can be used to check each element
    if ( !match ) {
      match = tokenize( selector );
    }
    i = match.length;
    while ( i-- ) {
      cached = matcherFromTokens( match[i] );
      if ( cached[ expando ] ) {
        setMatchers.push( cached );
      } else {
        elementMatchers.push( cached );
      }
    }

    // Cache the compiled function
    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

    // Save selector and tokenization
    cached.selector = selector;
  }
  return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
  var i, tokens, token, type, find,
    compiled = typeof selector === "function" && selector,
    match = !seed && tokenize( (selector = compiled.selector || selector) );

  results = results || [];

  // Try to minimize operations if there is no seed and only one group
  if ( match.length === 1 ) {

    // Take a shortcut and set the context if the root selector is an ID
    tokens = match[0] = match[0].slice( 0 );
    if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
        support.getById && context.nodeType === 9 && documentIsHTML &&
        Expr.relative[ tokens[1].type ] ) {

      context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
      if ( !context ) {
        return results;

      // Precompiled matchers will still verify ancestry, so step up a level
      } else if ( compiled ) {
        context = context.parentNode;
      }

      selector = selector.slice( tokens.shift().value.length );
    }

    // Fetch a seed set for right-to-left matching
    i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
    while ( i-- ) {
      token = tokens[i];

      // Abort if we hit a combinator
      if ( Expr.relative[ (type = token.type) ] ) {
        break;
      }
      if ( (find = Expr.find[ type ]) ) {
        // Search, expanding context for leading sibling combinators
        if ( (seed = find(
          token.matches[0].replace( runescape, funescape ),
          rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
        )) ) {

          // If seed is empty or no tokens remain, we can return early
          tokens.splice( i, 1 );
          selector = seed.length && toSelector( tokens );
          if ( !selector ) {
            push.apply( results, seed );
            return results;
          }

          break;
        }
      }
    }
  }

  // Compile and execute a filtering function if one is not provided
  // Provide `match` to avoid retokenization if we modified the selector above
  ( compiled || compile( selector, match ) )(
    seed,
    context,
    !documentIsHTML,
    results,
    rsibling.test( selector ) && testContext( context.parentNode ) || context
  );
  return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
  // Should return 1, but returns 4 (following)
  return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
  div.innerHTML = "<a href='#'></a>";
  return div.firstChild.getAttribute("href") === "#" ;
}) ) {
  addHandle( "type|href|height|width", function( elem, name, isXML ) {
    if ( !isXML ) {
      return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
    }
  });
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
  div.innerHTML = "<input/>";
  div.firstChild.setAttribute( "value", "" );
  return div.firstChild.getAttribute( "value" ) === "";
}) ) {
  addHandle( "value", function( elem, name, isXML ) {
    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
      return elem.defaultValue;
    }
  });
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
  return div.getAttribute("disabled") == null;
}) ) {
  addHandle( booleans, function( elem, name, isXML ) {
    var val;
    if ( !isXML ) {
      return elem[ name ] === true ? name.toLowerCase() :
          (val = elem.getAttributeNode( name )) && val.specified ?
          val.value :
        null;
    }
  });
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
  if ( jQuery.isFunction( qualifier ) ) {
    return jQuery.grep( elements, function( elem, i ) {
      /* jshint -W018 */
      return !!qualifier.call( elem, i, elem ) !== not;
    });

  }

  if ( qualifier.nodeType ) {
    return jQuery.grep( elements, function( elem ) {
      return ( elem === qualifier ) !== not;
    });

  }

  if ( typeof qualifier === "string" ) {
    if ( risSimple.test( qualifier ) ) {
      return jQuery.filter( qualifier, elements, not );
    }

    qualifier = jQuery.filter( qualifier, elements );
  }

  return jQuery.grep( elements, function( elem ) {
    return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
  });
}

jQuery.filter = function( expr, elems, not ) {
  var elem = elems[ 0 ];

  if ( not ) {
    expr = ":not(" + expr + ")";
  }

  return elems.length === 1 && elem.nodeType === 1 ?
    jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
    jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
      return elem.nodeType === 1;
    }));
};

jQuery.fn.extend({
  find: function( selector ) {
    var i,
      len = this.length,
      ret = [],
      self = this;

    if ( typeof selector !== "string" ) {
      return this.pushStack( jQuery( selector ).filter(function() {
        for ( i = 0; i < len; i++ ) {
          if ( jQuery.contains( self[ i ], this ) ) {
            return true;
          }
        }
      }) );
    }

    for ( i = 0; i < len; i++ ) {
      jQuery.find( selector, self[ i ], ret );
    }

    // Needed because $( selector, context ) becomes $( context ).find( selector )
    ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
    ret.selector = this.selector ? this.selector + " " + selector : selector;
    return ret;
  },
  filter: function( selector ) {
    return this.pushStack( winnow(this, selector || [], false) );
  },
  not: function( selector ) {
    return this.pushStack( winnow(this, selector || [], true) );
  },
  is: function( selector ) {
    return !!winnow(
      this,

      // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test( selector ) ?
        jQuery( selector ) :
        selector || [],
      false
    ).length;
  }
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

  // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

  init = jQuery.fn.init = function( selector, context ) {
    var match, elem;

    // HANDLE: $(""), $(null), $(undefined), $(false)
    if ( !selector ) {
      return this;
    }

    // Handle HTML strings
    if ( typeof selector === "string" ) {
      if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [ null, selector, null ];

      } else {
        match = rquickExpr.exec( selector );
      }

      // Match html or make sure no context is specified for #id
      if ( match && (match[1] || !context) ) {

        // HANDLE: $(html) -> $(array)
        if ( match[1] ) {
          context = context instanceof jQuery ? context[0] : context;

          // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present
          jQuery.merge( this, jQuery.parseHTML(
            match[1],
            context && context.nodeType ? context.ownerDocument || context : document,
            true
          ) );

          // HANDLE: $(html, props)
          if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
            for ( match in context ) {
              // Properties of context are called as methods if possible
              if ( jQuery.isFunction( this[ match ] ) ) {
                this[ match ]( context[ match ] );

              // ...and otherwise set as attributes
              } else {
                this.attr( match, context[ match ] );
              }
            }
          }

          return this;

        // HANDLE: $(#id)
        } else {
          elem = document.getElementById( match[2] );

          // Support: Blackberry 4.6
          // gEBID returns nodes no longer in the document (#6963)
          if ( elem && elem.parentNode ) {
            // Inject the element directly into the jQuery object
            this.length = 1;
            this[0] = elem;
          }

          this.context = document;
          this.selector = selector;
          return this;
        }

      // HANDLE: $(expr, $(...))
      } else if ( !context || context.jquery ) {
        return ( context || rootjQuery ).find( selector );

      // HANDLE: $(expr, context)
      // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor( context ).find( selector );
      }

    // HANDLE: $(DOMElement)
    } else if ( selector.nodeType ) {
      this.context = this[0] = selector;
      this.length = 1;
      return this;

    // HANDLE: $(function)
    // Shortcut for document ready
    } else if ( jQuery.isFunction( selector ) ) {
      return typeof rootjQuery.ready !== "undefined" ?
        rootjQuery.ready( selector ) :
        // Execute immediately if ready is not present
        selector( jQuery );
    }

    if ( selector.selector !== undefined ) {
      this.selector = selector.selector;
      this.context = selector.context;
    }

    return jQuery.makeArray( selector, this );
  };

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
  // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };

jQuery.extend({
  dir: function( elem, dir, until ) {
    var matched = [],
      truncate = until !== undefined;

    while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
      if ( elem.nodeType === 1 ) {
        if ( truncate && jQuery( elem ).is( until ) ) {
          break;
        }
        matched.push( elem );
      }
    }
    return matched;
  },

  sibling: function( n, elem ) {
    var matched = [];

    for ( ; n; n = n.nextSibling ) {
      if ( n.nodeType === 1 && n !== elem ) {
        matched.push( n );
      }
    }

    return matched;
  }
});

jQuery.fn.extend({
  has: function( target ) {
    var targets = jQuery( target, this ),
      l = targets.length;

    return this.filter(function() {
      var i = 0;
      for ( ; i < l; i++ ) {
        if ( jQuery.contains( this, targets[i] ) ) {
          return true;
        }
      }
    });
  },

  closest: function( selectors, context ) {
    var cur,
      i = 0,
      l = this.length,
      matched = [],
      pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
        jQuery( selectors, context || this.context ) :
        0;

    for ( ; i < l; i++ ) {
      for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
        // Always skip document fragments
        if ( cur.nodeType < 11 && (pos ?
          pos.index(cur) > -1 :

          // Don't pass non-elements to Sizzle
          cur.nodeType === 1 &&
            jQuery.find.matchesSelector(cur, selectors)) ) {

          matched.push( cur );
          break;
        }
      }
    }

    return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
  },

  // Determine the position of an element within the set
  index: function( elem ) {

    // No argument, return index in parent
    if ( !elem ) {
      return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
    }

    // Index in selector
    if ( typeof elem === "string" ) {
      return indexOf.call( jQuery( elem ), this[ 0 ] );
    }

    // Locate the position of the desired element
    return indexOf.call( this,

      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[ 0 ] : elem
    );
  },

  add: function( selector, context ) {
    return this.pushStack(
      jQuery.unique(
        jQuery.merge( this.get(), jQuery( selector, context ) )
      )
    );
  },

  addBack: function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter(selector)
    );
  }
});

function sibling( cur, dir ) {
  while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
  return cur;
}

jQuery.each({
  parent: function( elem ) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function( elem ) {
    return jQuery.dir( elem, "parentNode" );
  },
  parentsUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "parentNode", until );
  },
  next: function( elem ) {
    return sibling( elem, "nextSibling" );
  },
  prev: function( elem ) {
    return sibling( elem, "previousSibling" );
  },
  nextAll: function( elem ) {
    return jQuery.dir( elem, "nextSibling" );
  },
  prevAll: function( elem ) {
    return jQuery.dir( elem, "previousSibling" );
  },
  nextUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "nextSibling", until );
  },
  prevUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "previousSibling", until );
  },
  siblings: function( elem ) {
    return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
  },
  children: function( elem ) {
    return jQuery.sibling( elem.firstChild );
  },
  contents: function( elem ) {
    return elem.contentDocument || jQuery.merge( [], elem.childNodes );
  }
}, function( name, fn ) {
  jQuery.fn[ name ] = function( until, selector ) {
    var matched = jQuery.map( this, fn, until );

    if ( name.slice( -5 ) !== "Until" ) {
      selector = until;
    }

    if ( selector && typeof selector === "string" ) {
      matched = jQuery.filter( selector, matched );
    }

    if ( this.length > 1 ) {
      // Remove duplicates
      if ( !guaranteedUnique[ name ] ) {
        jQuery.unique( matched );
      }

      // Reverse order for parents* and prev-derivatives
      if ( rparentsprev.test( name ) ) {
        matched.reverse();
      }
    }

    return this.pushStack( matched );
  };
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
  var object = optionsCache[ options ] = {};
  jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
    object[ flag ] = true;
  });
  return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *      the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:     will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:     will keep track of previous values and will call any callback added
 *          after the list has been fired right away with the latest "memorized"
 *          values (like a Deferred)
 *
 *  unique:     will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:  interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

  // Convert options from String-formatted to Object-formatted if needed
  // (we check in cache first)
  options = typeof options === "string" ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );

  var // Last fire value (for non-forgettable lists)
    memory,
    // Flag to know if list was already fired
    fired,
    // Flag to know if list is currently firing
    firing,
    // First callback to fire (used internally by add and fireWith)
    firingStart,
    // End of the loop when firing
    firingLength,
    // Index of currently firing callback (modified by remove if needed)
    firingIndex,
    // Actual callback list
    list = [],
    // Stack of fire calls for repeatable lists
    stack = !options.once && [],
    // Fire callbacks
    fire = function( data ) {
      memory = options.memory && data;
      fired = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      firing = true;
      for ( ; list && firingIndex < firingLength; firingIndex++ ) {
        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
          memory = false; // To prevent further calls using add
          break;
        }
      }
      firing = false;
      if ( list ) {
        if ( stack ) {
          if ( stack.length ) {
            fire( stack.shift() );
          }
        } else if ( memory ) {
          list = [];
        } else {
          self.disable();
        }
      }
    },
    // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function() {
        if ( list ) {
          // First, we save the current length
          var start = list.length;
          (function add( args ) {
            jQuery.each( args, function( _, arg ) {
              var type = jQuery.type( arg );
              if ( type === "function" ) {
                if ( !options.unique || !self.has( arg ) ) {
                  list.push( arg );
                }
              } else if ( arg && arg.length && type !== "string" ) {
                // Inspect recursively
                add( arg );
              }
            });
          })( arguments );
          // Do we need to add the callbacks to the
          // current firing batch?
          if ( firing ) {
            firingLength = list.length;
          // With memory, if we're not firing then
          // we should call right away
          } else if ( memory ) {
            firingStart = start;
            fire( memory );
          }
        }
        return this;
      },
      // Remove a callback from the list
      remove: function() {
        if ( list ) {
          jQuery.each( arguments, function( _, arg ) {
            var index;
            while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
              list.splice( index, 1 );
              // Handle firing indexes
              if ( firing ) {
                if ( index <= firingLength ) {
                  firingLength--;
                }
                if ( index <= firingIndex ) {
                  firingIndex--;
                }
              }
            }
          });
        }
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function( fn ) {
        return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
      },
      // Remove all callbacks from the list
      empty: function() {
        list = [];
        firingLength = 0;
        return this;
      },
      // Have the list do nothing anymore
      disable: function() {
        list = stack = memory = undefined;
        return this;
      },
      // Is it disabled?
      disabled: function() {
        return !list;
      },
      // Lock the list in its current state
      lock: function() {
        stack = undefined;
        if ( !memory ) {
          self.disable();
        }
        return this;
      },
      // Is it locked?
      locked: function() {
        return !stack;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function( context, args ) {
        if ( list && ( !fired || stack ) ) {
          args = args || [];
          args = [ context, args.slice ? args.slice() : args ];
          if ( firing ) {
            stack.push( args );
          } else {
            fire( args );
          }
        }
        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function() {
        self.fireWith( this, arguments );
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function() {
        return !!fired;
      }
    };

  return self;
};


jQuery.extend({

  Deferred: function( func ) {
    var tuples = [
        // action, add listener, listener list, final state
        [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
        [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
        [ "notify", "progress", jQuery.Callbacks("memory") ]
      ],
      state = "pending",
      promise = {
        state: function() {
          return state;
        },
        always: function() {
          deferred.done( arguments ).fail( arguments );
          return this;
        },
        then: function( /* fnDone, fnFail, fnProgress */ ) {
          var fns = arguments;
          return jQuery.Deferred(function( newDefer ) {
            jQuery.each( tuples, function( i, tuple ) {
              var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
              // deferred[ done | fail | progress ] for forwarding actions to newDefer
              deferred[ tuple[1] ](function() {
                var returned = fn && fn.apply( this, arguments );
                if ( returned && jQuery.isFunction( returned.promise ) ) {
                  returned.promise()
                    .done( newDefer.resolve )
                    .fail( newDefer.reject )
                    .progress( newDefer.notify );
                } else {
                  newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                }
              });
            });
            fns = null;
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function( obj ) {
          return obj != null ? jQuery.extend( obj, promise ) : promise;
        }
      },
      deferred = {};

    // Keep pipe for back-compat
    promise.pipe = promise.then;

    // Add list-specific methods
    jQuery.each( tuples, function( i, tuple ) {
      var list = tuple[ 2 ],
        stateString = tuple[ 3 ];

      // promise[ done | fail | progress ] = list.add
      promise[ tuple[1] ] = list.add;

      // Handle state
      if ( stateString ) {
        list.add(function() {
          // state = [ resolved | rejected ]
          state = stateString;

        // [ reject_list | resolve_list ].disable; progress_list.lock
        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
      }

      // deferred[ resolve | reject | notify ]
      deferred[ tuple[0] ] = function() {
        deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
        return this;
      };
      deferred[ tuple[0] + "With" ] = list.fireWith;
    });

    // Make the deferred a promise
    promise.promise( deferred );

    // Call given func if any
    if ( func ) {
      func.call( deferred, deferred );
    }

    // All done!
    return deferred;
  },

  // Deferred helper
  when: function( subordinate /* , ..., subordinateN */ ) {
    var i = 0,
      resolveValues = slice.call( arguments ),
      length = resolveValues.length,

      // the count of uncompleted subordinates
      remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

      // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

      // Update function for both resolve and progress values
      updateFunc = function( i, contexts, values ) {
        return function( value ) {
          contexts[ i ] = this;
          values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
          if ( values === progressValues ) {
            deferred.notifyWith( contexts, values );
          } else if ( !( --remaining ) ) {
            deferred.resolveWith( contexts, values );
          }
        };
      },

      progressValues, progressContexts, resolveContexts;

    // Add listeners to Deferred subordinates; treat others as resolved
    if ( length > 1 ) {
      progressValues = new Array( length );
      progressContexts = new Array( length );
      resolveContexts = new Array( length );
      for ( ; i < length; i++ ) {
        if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
          resolveValues[ i ].promise()
            .done( updateFunc( i, resolveContexts, resolveValues ) )
            .fail( deferred.reject )
            .progress( updateFunc( i, progressContexts, progressValues ) );
        } else {
          --remaining;
        }
      }
    }

    // If we're not waiting on anything, resolve the master
    if ( !remaining ) {
      deferred.resolveWith( resolveContexts, resolveValues );
    }

    return deferred.promise();
  }
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
  // Add the callback
  jQuery.ready.promise().done( fn );

  return this;
};

jQuery.extend({
  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,

  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,

  // Hold (or release) the ready event
  holdReady: function( hold ) {
    if ( hold ) {
      jQuery.readyWait++;
    } else {
      jQuery.ready( true );
    }
  },

  // Handle when the DOM is ready
  ready: function( wait ) {

    // Abort if there are pending holds or we're already ready
    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
      return;
    }

    // Remember that the DOM is ready
    jQuery.isReady = true;

    // If a normal DOM Ready event fired, decrement, and wait if need be
    if ( wait !== true && --jQuery.readyWait > 0 ) {
      return;
    }

    // If there are functions bound, to execute
    readyList.resolveWith( document, [ jQuery ] );

    // Trigger any bound ready events
    if ( jQuery.fn.triggerHandler ) {
      jQuery( document ).triggerHandler( "ready" );
      jQuery( document ).off( "ready" );
    }
  }
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
  document.removeEventListener( "DOMContentLoaded", completed, false );
  window.removeEventListener( "load", completed, false );
  jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
  if ( !readyList ) {

    readyList = jQuery.Deferred();

    // Catch cases where $(document).ready() is called after the browser event has already occurred.
    // We once tried to use readyState "interactive" here, but it caused issues like the one
    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
    if ( document.readyState === "complete" ) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      setTimeout( jQuery.ready );

    } else {

      // Use the handy event callback
      document.addEventListener( "DOMContentLoaded", completed, false );

      // A fallback to window.onload, that will always work
      window.addEventListener( "load", completed, false );
    }
  }
  return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  var i = 0,
    len = elems.length,
    bulk = key == null;

  // Sets many values
  if ( jQuery.type( key ) === "object" ) {
    chainable = true;
    for ( i in key ) {
      jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
    }

  // Sets one value
  } else if ( value !== undefined ) {
    chainable = true;

    if ( !jQuery.isFunction( value ) ) {
      raw = true;
    }

    if ( bulk ) {
      // Bulk operations run against the entire set
      if ( raw ) {
        fn.call( elems, value );
        fn = null;

      // ...except when executing function values
      } else {
        bulk = fn;
        fn = function( elem, key, value ) {
          return bulk.call( jQuery( elem ), value );
        };
      }
    }

    if ( fn ) {
      for ( ; i < len; i++ ) {
        fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
      }
    }
  }

  return chainable ?
    elems :

    // Gets
    bulk ?
      fn.call( elems ) :
      len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
  // Accepts only:
  //  - Node
  //    - Node.ELEMENT_NODE
  //    - Node.DOCUMENT_NODE
  //  - Object
  //    - Any
  /* jshint -W018 */
  return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
  // Support: Android<4,
  // Old WebKit does not have Object.preventExtensions/freeze method,
  // return new empty object instead with no [[set]] accessor
  Object.defineProperty( this.cache = {}, 0, {
    get: function() {
      return {};
    }
  });

  this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
  key: function( owner ) {
    // We can accept data for non-element nodes in modern browsers,
    // but we should not, see #8335.
    // Always return the key for a frozen object.
    if ( !Data.accepts( owner ) ) {
      return 0;
    }

    var descriptor = {},
      // Check if the owner object already has a cache key
      unlock = owner[ this.expando ];

    // If not, create one
    if ( !unlock ) {
      unlock = Data.uid++;

      // Secure it in a non-enumerable, non-writable property
      try {
        descriptor[ this.expando ] = { value: unlock };
        Object.defineProperties( owner, descriptor );

      // Support: Android<4
      // Fallback to a less secure definition
      } catch ( e ) {
        descriptor[ this.expando ] = unlock;
        jQuery.extend( owner, descriptor );
      }
    }

    // Ensure the cache object
    if ( !this.cache[ unlock ] ) {
      this.cache[ unlock ] = {};
    }

    return unlock;
  },
  set: function( owner, data, value ) {
    var prop,
      // There may be an unlock assigned to this node,
      // if there is no entry for this "owner", create one inline
      // and set the unlock as though an owner entry had always existed
      unlock = this.key( owner ),
      cache = this.cache[ unlock ];

    // Handle: [ owner, key, value ] args
    if ( typeof data === "string" ) {
      cache[ data ] = value;

    // Handle: [ owner, { properties } ] args
    } else {
      // Fresh assignments by object are shallow copied
      if ( jQuery.isEmptyObject( cache ) ) {
        jQuery.extend( this.cache[ unlock ], data );
      // Otherwise, copy the properties one-by-one to the cache object
      } else {
        for ( prop in data ) {
          cache[ prop ] = data[ prop ];
        }
      }
    }
    return cache;
  },
  get: function( owner, key ) {
    // Either a valid cache is found, or will be created.
    // New caches will be created and the unlock returned,
    // allowing direct access to the newly created
    // empty data object. A valid owner object must be provided.
    var cache = this.cache[ this.key( owner ) ];

    return key === undefined ?
      cache : cache[ key ];
  },
  access: function( owner, key, value ) {
    var stored;
    // In cases where either:
    //
    //   1. No key was specified
    //   2. A string key was specified, but no value provided
    //
    // Take the "read" path and allow the get method to determine
    // which value to return, respectively either:
    //
    //   1. The entire cache object
    //   2. The data stored at the key
    //
    if ( key === undefined ||
        ((key && typeof key === "string") && value === undefined) ) {

      stored = this.get( owner, key );

      return stored !== undefined ?
        stored : this.get( owner, jQuery.camelCase(key) );
    }

    // [*]When the key is not a string, or both a key and value
    // are specified, set or extend (existing objects) with either:
    //
    //   1. An object of properties
    //   2. A key and value
    //
    this.set( owner, key, value );

    // Since the "set" path can have two possible entry points
    // return the expected data based on which path was taken[*]
    return value !== undefined ? value : key;
  },
  remove: function( owner, key ) {
    var i, name, camel,
      unlock = this.key( owner ),
      cache = this.cache[ unlock ];

    if ( key === undefined ) {
      this.cache[ unlock ] = {};

    } else {
      // Support array or space separated string of keys
      if ( jQuery.isArray( key ) ) {
        // If "name" is an array of keys...
        // When data is initially created, via ("key", "val") signature,
        // keys will be converted to camelCase.
        // Since there is no way to tell _how_ a key was added, remove
        // both plain key and camelCase key. #12786
        // This will only penalize the array argument path.
        name = key.concat( key.map( jQuery.camelCase ) );
      } else {
        camel = jQuery.camelCase( key );
        // Try the string as a key before any manipulation
        if ( key in cache ) {
          name = [ key, camel ];
        } else {
          // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace
          name = camel;
          name = name in cache ?
            [ name ] : ( name.match( rnotwhite ) || [] );
        }
      }

      i = name.length;
      while ( i-- ) {
        delete cache[ name[ i ] ];
      }
    }
  },
  hasData: function( owner ) {
    return !jQuery.isEmptyObject(
      this.cache[ owner[ this.expando ] ] || {}
    );
  },
  discard: function( owner ) {
    if ( owner[ this.expando ] ) {
      delete this.cache[ owner[ this.expando ] ];
    }
  }
};
var data_priv = new Data();

var data_user = new Data();



//  Implementation Summary
//
//  1. Enforce API surface and semantic compatibility with 1.9.x branch
//  2. Improve the module's maintainability by reducing the storage
//    paths to a single mechanism.
//  3. Use the same single mechanism to support "private" and "user" data.
//  4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//  5. Avoid exposing implementation details on user objects (eg. expando properties)
//  6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
  var name;

  // If nothing was found internally, try to fetch any
  // data from the HTML5 data-* attribute
  if ( data === undefined && elem.nodeType === 1 ) {
    name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
    data = elem.getAttribute( name );

    if ( typeof data === "string" ) {
      try {
        data = data === "true" ? true :
          data === "false" ? false :
          data === "null" ? null :
          // Only convert to a number if it doesn't change the string
          +data + "" === data ? +data :
          rbrace.test( data ) ? jQuery.parseJSON( data ) :
          data;
      } catch( e ) {}

      // Make sure we set the data so it isn't changed later
      data_user.set( elem, key, data );
    } else {
      data = undefined;
    }
  }
  return data;
}

jQuery.extend({
  hasData: function( elem ) {
    return data_user.hasData( elem ) || data_priv.hasData( elem );
  },

  data: function( elem, name, data ) {
    return data_user.access( elem, name, data );
  },

  removeData: function( elem, name ) {
    data_user.remove( elem, name );
  },

  // TODO: Now that all calls to _data and _removeData have been replaced
  // with direct calls to data_priv methods, these can be deprecated.
  _data: function( elem, name, data ) {
    return data_priv.access( elem, name, data );
  },

  _removeData: function( elem, name ) {
    data_priv.remove( elem, name );
  }
});

jQuery.fn.extend({
  data: function( key, value ) {
    var i, name, data,
      elem = this[ 0 ],
      attrs = elem && elem.attributes;

    // Gets all values
    if ( key === undefined ) {
      if ( this.length ) {
        data = data_user.get( elem );

        if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
          i = attrs.length;
          while ( i-- ) {

            // Support: IE11+
            // The attrs elements can be null (#14894)
            if ( attrs[ i ] ) {
              name = attrs[ i ].name;
              if ( name.indexOf( "data-" ) === 0 ) {
                name = jQuery.camelCase( name.slice(5) );
                dataAttr( elem, name, data[ name ] );
              }
            }
          }
          data_priv.set( elem, "hasDataAttrs", true );
        }
      }

      return data;
    }

    // Sets multiple values
    if ( typeof key === "object" ) {
      return this.each(function() {
        data_user.set( this, key );
      });
    }

    return access( this, function( value ) {
      var data,
        camelKey = jQuery.camelCase( key );

      // The calling jQuery object (element matches) is not empty
      // (and therefore has an element appears at this[ 0 ]) and the
      // `value` parameter was not undefined. An empty jQuery object
      // will result in `undefined` for elem = this[ 0 ] which will
      // throw an exception if an attempt to read a data cache is made.
      if ( elem && value === undefined ) {
        // Attempt to get data from the cache
        // with the key as-is
        data = data_user.get( elem, key );
        if ( data !== undefined ) {
          return data;
        }

        // Attempt to get data from the cache
        // with the key camelized
        data = data_user.get( elem, camelKey );
        if ( data !== undefined ) {
          return data;
        }

        // Attempt to "discover" the data in
        // HTML5 custom data-* attrs
        data = dataAttr( elem, camelKey, undefined );
        if ( data !== undefined ) {
          return data;
        }

        // We tried really hard, but the data doesn't exist.
        return;
      }

      // Set the data...
      this.each(function() {
        // First, attempt to store a copy or reference of any
        // data that might've been store with a camelCased key.
        var data = data_user.get( this, camelKey );

        // For HTML5 data-* attribute interop, we have to
        // store property names with dashes in a camelCase form.
        // This might not apply to all properties...*
        data_user.set( this, camelKey, value );

        // *... In the case of properties that might _actually_
        // have dashes, we need to also store a copy of that
        // unchanged property.
        if ( key.indexOf("-") !== -1 && data !== undefined ) {
          data_user.set( this, key, value );
        }
      });
    }, null, value, arguments.length > 1, null, true );
  },

  removeData: function( key ) {
    return this.each(function() {
      data_user.remove( this, key );
    });
  }
});


jQuery.extend({
  queue: function( elem, type, data ) {
    var queue;

    if ( elem ) {
      type = ( type || "fx" ) + "queue";
      queue = data_priv.get( elem, type );

      // Speed up dequeue by getting out quickly if this is just a lookup
      if ( data ) {
        if ( !queue || jQuery.isArray( data ) ) {
          queue = data_priv.access( elem, type, jQuery.makeArray(data) );
        } else {
          queue.push( data );
        }
      }
      return queue || [];
    }
  },

  dequeue: function( elem, type ) {
    type = type || "fx";

    var queue = jQuery.queue( elem, type ),
      startLength = queue.length,
      fn = queue.shift(),
      hooks = jQuery._queueHooks( elem, type ),
      next = function() {
        jQuery.dequeue( elem, type );
      };

    // If the fx queue is dequeued, always remove the progress sentinel
    if ( fn === "inprogress" ) {
      fn = queue.shift();
      startLength--;
    }

    if ( fn ) {

      // Add a progress sentinel to prevent the fx queue from being
      // automatically dequeued
      if ( type === "fx" ) {
        queue.unshift( "inprogress" );
      }

      // Clear up the last queue stop function
      delete hooks.stop;
      fn.call( elem, next, hooks );
    }

    if ( !startLength && hooks ) {
      hooks.empty.fire();
    }
  },

  // Not public - generate a queueHooks object, or return the current one
  _queueHooks: function( elem, type ) {
    var key = type + "queueHooks";
    return data_priv.get( elem, key ) || data_priv.access( elem, key, {
      empty: jQuery.Callbacks("once memory").add(function() {
        data_priv.remove( elem, [ type + "queue", key ] );
      })
    });
  }
});

jQuery.fn.extend({
  queue: function( type, data ) {
    var setter = 2;

    if ( typeof type !== "string" ) {
      data = type;
      type = "fx";
      setter--;
    }

    if ( arguments.length < setter ) {
      return jQuery.queue( this[0], type );
    }

    return data === undefined ?
      this :
      this.each(function() {
        var queue = jQuery.queue( this, type, data );

        // Ensure a hooks for this queue
        jQuery._queueHooks( this, type );

        if ( type === "fx" && queue[0] !== "inprogress" ) {
          jQuery.dequeue( this, type );
        }
      });
  },
  dequeue: function( type ) {
    return this.each(function() {
      jQuery.dequeue( this, type );
    });
  },
  clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
  },
  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function( type, obj ) {
    var tmp,
      count = 1,
      defer = jQuery.Deferred(),
      elements = this,
      i = this.length,
      resolve = function() {
        if ( !( --count ) ) {
          defer.resolveWith( elements, [ elements ] );
        }
      };

    if ( typeof type !== "string" ) {
      obj = type;
      type = undefined;
    }
    type = type || "fx";

    while ( i-- ) {
      tmp = data_priv.get( elements[ i ], type + "queueHooks" );
      if ( tmp && tmp.empty ) {
        count++;
        tmp.empty.add( resolve );
      }
    }
    resolve();
    return defer.promise( obj );
  }
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
  };

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
  var fragment = document.createDocumentFragment(),
    div = fragment.appendChild( document.createElement( "div" ) ),
    input = document.createElement( "input" );

  // Support: Safari<=5.1
  // Check state lost if the name is set (#11217)
  // Support: Windows Web Apps (WWA)
  // `name` and `type` must use .setAttribute for WWA (#14901)
  input.setAttribute( "type", "radio" );
  input.setAttribute( "checked", "checked" );
  input.setAttribute( "name", "t" );

  div.appendChild( input );

  // Support: Safari<=5.1, Android<4.2
  // Older WebKit doesn't clone checked state correctly in fragments
  support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  // Support: IE<=11+
  // Make sure textarea (and checkbox) defaultValue is properly cloned
  div.innerHTML = "<textarea>x</textarea>";
  support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
  rkeyEvent = /^key/,
  rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
  rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
  return true;
}

function returnFalse() {
  return false;
}

function safeActiveElement() {
  try {
    return document.activeElement;
  } catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

  global: {},

  add: function( elem, types, handler, data, selector ) {

    var handleObjIn, eventHandle, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = data_priv.get( elem );

    // Don't attach events to noData or text/comment nodes (but allow plain objects)
    if ( !elemData ) {
      return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if ( handler.handler ) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if ( !handler.guid ) {
      handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    if ( !(events = elemData.events) ) {
      events = elemData.events = {};
    }
    if ( !(eventHandle = elemData.handle) ) {
      eventHandle = elemData.handle = function( e ) {
        // Discard the second event of a jQuery.event.trigger() and
        // when an event is called after a page has unloaded
        return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
          jQuery.event.dispatch.apply( elem, arguments ) : undefined;
      };
    }

    // Handle multiple events separated by a space
    types = ( types || "" ).match( rnotwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
      tmp = rtypenamespace.exec( types[t] ) || [];
      type = origType = tmp[1];
      namespaces = ( tmp[2] || "" ).split( "." ).sort();

      // There *must* be a type, no attaching namespace-only handlers
      if ( !type ) {
        continue;
      }

      // If event changes its type, use the special event handlers for the changed type
      special = jQuery.event.special[ type ] || {};

      // If selector defined, determine special event api type, otherwise given type
      type = ( selector ? special.delegateType : special.bindType ) || type;

      // Update special based on newly reset type
      special = jQuery.event.special[ type ] || {};

      // handleObj is passed to all event handlers
      handleObj = jQuery.extend({
        type: type,
        origType: origType,
        data: data,
        handler: handler,
        guid: handler.guid,
        selector: selector,
        needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
        namespace: namespaces.join(".")
      }, handleObjIn );

      // Init the event handler queue if we're the first
      if ( !(handlers = events[ type ]) ) {
        handlers = events[ type ] = [];
        handlers.delegateCount = 0;

        // Only use addEventListener if the special events handler returns false
        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
          if ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, false );
          }
        }
      }

      if ( special.add ) {
        special.add.call( elem, handleObj );

        if ( !handleObj.handler.guid ) {
          handleObj.handler.guid = handler.guid;
        }
      }

      // Add to the element's handler list, delegates in front
      if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
      } else {
        handlers.push( handleObj );
      }

      // Keep track of which events have ever been used, for event optimization
      jQuery.event.global[ type ] = true;
    }

  },

  // Detach an event or set of events from an element
  remove: function( elem, types, handler, selector, mappedTypes ) {

    var j, origCount, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = data_priv.hasData( elem ) && data_priv.get( elem );

    if ( !elemData || !(events = elemData.events) ) {
      return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = ( types || "" ).match( rnotwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
      tmp = rtypenamespace.exec( types[t] ) || [];
      type = origType = tmp[1];
      namespaces = ( tmp[2] || "" ).split( "." ).sort();

      // Unbind all events (on this namespace, if provided) for the element
      if ( !type ) {
        for ( type in events ) {
          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
        }
        continue;
      }

      special = jQuery.event.special[ type ] || {};
      type = ( selector ? special.delegateType : special.bindType ) || type;
      handlers = events[ type ] || [];
      tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

      // Remove matching events
      origCount = j = handlers.length;
      while ( j-- ) {
        handleObj = handlers[ j ];

        if ( ( mappedTypes || origType === handleObj.origType ) &&
          ( !handler || handler.guid === handleObj.guid ) &&
          ( !tmp || tmp.test( handleObj.namespace ) ) &&
          ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
          handlers.splice( j, 1 );

          if ( handleObj.selector ) {
            handlers.delegateCount--;
          }
          if ( special.remove ) {
            special.remove.call( elem, handleObj );
          }
        }
      }

      // Remove generic event handler if we removed something and no more handlers exist
      // (avoids potential for endless recursion during removal of special event handlers)
      if ( origCount && !handlers.length ) {
        if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
          jQuery.removeEvent( elem, type, elemData.handle );
        }

        delete events[ type ];
      }
    }

    // Remove the expando if it's no longer used
    if ( jQuery.isEmptyObject( events ) ) {
      delete elemData.handle;
      data_priv.remove( elem, "events" );
    }
  },

  trigger: function( event, data, elem, onlyHandlers ) {

    var i, cur, tmp, bubbleType, ontype, handle, special,
      eventPath = [ elem || document ],
      type = hasOwn.call( event, "type" ) ? event.type : event,
      namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

    cur = tmp = elem = elem || document;

    // Don't do events on text and comment nodes
    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
      return;
    }

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
      return;
    }

    if ( type.indexOf(".") >= 0 ) {
      // Namespaced trigger; create a regexp to match event type in handle()
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }
    ontype = type.indexOf(":") < 0 && "on" + type;

    // Caller can pass in a jQuery.Event object, Object, or just an event type string
    event = event[ jQuery.expando ] ?
      event :
      new jQuery.Event( type, typeof event === "object" && event );

    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    event.isTrigger = onlyHandlers ? 2 : 3;
    event.namespace = namespaces.join(".");
    event.namespace_re = event.namespace ?
      new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
      null;

    // Clean up the event in case it is being reused
    event.result = undefined;
    if ( !event.target ) {
      event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data == null ?
      [ event ] :
      jQuery.makeArray( data, [ event ] );

    // Allow special events to draw outside the lines
    special = jQuery.event.special[ type ] || {};
    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
      return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

      bubbleType = special.delegateType || type;
      if ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
      }
      for ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
      }

      // Only add window if we got to document (e.g., not plain obj or detached DOM)
      if ( tmp === (elem.ownerDocument || document) ) {
        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
      }
    }

    // Fire handlers on the event path
    i = 0;
    while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

      event.type = i > 1 ?
        bubbleType :
        special.bindType || type;

      // jQuery handler
      handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
      if ( handle ) {
        handle.apply( cur, data );
      }

      // Native handler
      handle = ontype && cur[ ontype ];
      if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
        event.result = handle.apply( cur, data );
        if ( event.result === false ) {
          event.preventDefault();
        }
      }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

      if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
        jQuery.acceptData( elem ) ) {

        // Call a native DOM method on the target with the same name name as the event.
        // Don't do default actions on window, that's where global variables be (#6170)
        if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

          // Don't re-trigger an onFOO event when we call its FOO() method
          tmp = elem[ ontype ];

          if ( tmp ) {
            elem[ ontype ] = null;
          }

          // Prevent re-triggering of the same event, since we already bubbled it above
          jQuery.event.triggered = type;
          elem[ type ]();
          jQuery.event.triggered = undefined;

          if ( tmp ) {
            elem[ ontype ] = tmp;
          }
        }
      }
    }

    return event.result;
  },

  dispatch: function( event ) {

    // Make a writable jQuery.Event from the native event object
    event = jQuery.event.fix( event );

    var i, j, ret, matched, handleObj,
      handlerQueue = [],
      args = slice.call( arguments ),
      handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
      special = jQuery.event.special[ event.type ] || {};

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[0] = event;
    event.delegateTarget = this;

    // Call the preDispatch hook for the mapped type, and let it bail if desired
    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
      return;
    }

    // Determine handlers
    handlerQueue = jQuery.event.handlers.call( this, event, handlers );

    // Run delegates first; they may want to stop propagation beneath us
    i = 0;
    while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
      event.currentTarget = matched.elem;

      j = 0;
      while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

        // Triggered event must either 1) have no namespace, or 2) have namespace(s)
        // a subset or equal to those in the bound event (both can have no namespace).
        if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

          event.handleObj = handleObj;
          event.data = handleObj.data;

          ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
              .apply( matched.elem, args );

          if ( ret !== undefined ) {
            if ( (event.result = ret) === false ) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }

    // Call the postDispatch hook for the mapped type
    if ( special.postDispatch ) {
      special.postDispatch.call( this, event );
    }

    return event.result;
  },

  handlers: function( event, handlers ) {
    var i, matches, sel, handleObj,
      handlerQueue = [],
      delegateCount = handlers.delegateCount,
      cur = event.target;

    // Find delegate handlers
    // Black-hole SVG <use> instance trees (#13180)
    // Avoid non-left-click bubbling in Firefox (#3861)
    if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

      for ( ; cur !== this; cur = cur.parentNode || this ) {

        // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
        if ( cur.disabled !== true || event.type !== "click" ) {
          matches = [];
          for ( i = 0; i < delegateCount; i++ ) {
            handleObj = handlers[ i ];

            // Don't conflict with Object.prototype properties (#13203)
            sel = handleObj.selector + " ";

            if ( matches[ sel ] === undefined ) {
              matches[ sel ] = handleObj.needsContext ?
                jQuery( sel, this ).index( cur ) >= 0 :
                jQuery.find( sel, this, null, [ cur ] ).length;
            }
            if ( matches[ sel ] ) {
              matches.push( handleObj );
            }
          }
          if ( matches.length ) {
            handlerQueue.push({ elem: cur, handlers: matches });
          }
        }
      }
    }

    // Add the remaining (directly-bound) handlers
    if ( delegateCount < handlers.length ) {
      handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
    }

    return handlerQueue;
  },

  // Includes some event props shared by KeyEvent and MouseEvent
  props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

  fixHooks: {},

  keyHooks: {
    props: "char charCode key keyCode".split(" "),
    filter: function( event, original ) {

      // Add which for key events
      if ( event.which == null ) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
      }

      return event;
    }
  },

  mouseHooks: {
    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter: function( event, original ) {
      var eventDoc, doc, body,
        button = original.button;

      // Calculate pageX/Y if missing and clientX/Y available
      if ( event.pageX == null && original.clientX != null ) {
        eventDoc = event.target.ownerDocument || document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;

        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
      }

      // Add which for click: 1 === left; 2 === middle; 3 === right
      // Note: button is not normalized, so don't use it
      if ( !event.which && button !== undefined ) {
        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
      }

      return event;
    }
  },

  fix: function( event ) {
    if ( event[ jQuery.expando ] ) {
      return event;
    }

    // Create a writable copy of the event object and normalize some properties
    var i, prop, copy,
      type = event.type,
      originalEvent = event,
      fixHook = this.fixHooks[ type ];

    if ( !fixHook ) {
      this.fixHooks[ type ] = fixHook =
        rmouseEvent.test( type ) ? this.mouseHooks :
        rkeyEvent.test( type ) ? this.keyHooks :
        {};
    }
    copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

    event = new jQuery.Event( originalEvent );

    i = copy.length;
    while ( i-- ) {
      prop = copy[ i ];
      event[ prop ] = originalEvent[ prop ];
    }

    // Support: Cordova 2.5 (WebKit) (#13255)
    // All events should have a target; Cordova deviceready doesn't
    if ( !event.target ) {
      event.target = document;
    }

    // Support: Safari 6.0+, Chrome<28
    // Target should not be a text node (#504, #13143)
    if ( event.target.nodeType === 3 ) {
      event.target = event.target.parentNode;
    }

    return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
  },

  special: {
    load: {
      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },
    focus: {
      // Fire native event if possible so blur/focus sequence is correct
      trigger: function() {
        if ( this !== safeActiveElement() && this.focus ) {
          this.focus();
          return false;
        }
      },
      delegateType: "focusin"
    },
    blur: {
      trigger: function() {
        if ( this === safeActiveElement() && this.blur ) {
          this.blur();
          return false;
        }
      },
      delegateType: "focusout"
    },
    click: {
      // For checkbox, fire native event so checked state will be right
      trigger: function() {
        if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
          this.click();
          return false;
        }
      },

      // For cross-browser consistency, don't fire native .click() on links
      _default: function( event ) {
        return jQuery.nodeName( event.target, "a" );
      }
    },

    beforeunload: {
      postDispatch: function( event ) {

        // Support: Firefox 20+
        // Firefox doesn't alert if the returnValue field is not set.
        if ( event.result !== undefined && event.originalEvent ) {
          event.originalEvent.returnValue = event.result;
        }
      }
    }
  },

  simulate: function( type, elem, event, bubble ) {
    // Piggyback on a donor event to simulate a different one.
    // Fake originalEvent to avoid donor's stopPropagation, but if the
    // simulated event prevents default then we do the same on the donor.
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      {
        type: type,
        isSimulated: true,
        originalEvent: {}
      }
    );
    if ( bubble ) {
      jQuery.event.trigger( e, null, elem );
    } else {
      jQuery.event.dispatch.call( elem, e );
    }
    if ( e.isDefaultPrevented() ) {
      event.preventDefault();
    }
  }
};

jQuery.removeEvent = function( elem, type, handle ) {
  if ( elem.removeEventListener ) {
    elem.removeEventListener( type, handle, false );
  }
};

jQuery.Event = function( src, props ) {
  // Allow instantiation without the 'new' keyword
  if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = src.defaultPrevented ||
        src.defaultPrevented === undefined &&
        // Support: Android<4.0
        src.returnValue === false ?
      returnTrue :
      returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    jQuery.extend( this, props );
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || jQuery.now();

  // Mark it as fixed
  this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse,

  preventDefault: function() {
    var e = this.originalEvent;

    this.isDefaultPrevented = returnTrue;

    if ( e && e.preventDefault ) {
      e.preventDefault();
    }
  },
  stopPropagation: function() {
    var e = this.originalEvent;

    this.isPropagationStopped = returnTrue;

    if ( e && e.stopPropagation ) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function() {
    var e = this.originalEvent;

    this.isImmediatePropagationStopped = returnTrue;

    if ( e && e.stopImmediatePropagation ) {
      e.stopImmediatePropagation();
    }

    this.stopPropagation();
  }
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
}, function( orig, fix ) {
  jQuery.event.special[ orig ] = {
    delegateType: fix,
    bindType: fix,

    handle: function( event ) {
      var ret,
        target = this,
        related = event.relatedTarget,
        handleObj = event.handleObj;

      // For mousenter/leave call the handler if related is outside the target.
      // NB: No relatedTarget if the mouse left/entered the browser window
      if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply( this, arguments );
        event.type = fix;
      }
      return ret;
    }
  };
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
  jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

    // Attach a single capturing handler on the document while someone wants focusin/focusout
    var handler = function( event ) {
        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
      };

    jQuery.event.special[ fix ] = {
      setup: function() {
        var doc = this.ownerDocument || this,
          attaches = data_priv.access( doc, fix );

        if ( !attaches ) {
          doc.addEventListener( orig, handler, true );
        }
        data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
      },
      teardown: function() {
        var doc = this.ownerDocument || this,
          attaches = data_priv.access( doc, fix ) - 1;

        if ( !attaches ) {
          doc.removeEventListener( orig, handler, true );
          data_priv.remove( doc, fix );

        } else {
          data_priv.access( doc, fix, attaches );
        }
      }
    };
  });
}

jQuery.fn.extend({

  on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
    var origFn, type;

    // Types can be a map of types/handlers
    if ( typeof types === "object" ) {
      // ( types-Object, selector, data )
      if ( typeof selector !== "string" ) {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for ( type in types ) {
        this.on( type, selector, data, types[ type ], one );
      }
      return this;
    }

    if ( data == null && fn == null ) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if ( fn == null ) {
      if ( typeof selector === "string" ) {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if ( fn === false ) {
      fn = returnFalse;
    } else if ( !fn ) {
      return this;
    }

    if ( one === 1 ) {
      origFn = fn;
      fn = function( event ) {
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
      };
      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    }
    return this.each( function() {
      jQuery.event.add( this, types, fn, data, selector );
    });
  },
  one: function( types, selector, data, fn ) {
    return this.on( types, selector, data, fn, 1 );
  },
  off: function( types, selector, fn ) {
    var handleObj, type;
    if ( types && types.preventDefault && types.handleObj ) {
      // ( event )  dispatched jQuery.Event
      handleObj = types.handleObj;
      jQuery( types.delegateTarget ).off(
        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if ( typeof types === "object" ) {
      // ( types-object [, selector] )
      for ( type in types ) {
        this.off( type, selector, types[ type ] );
      }
      return this;
    }
    if ( selector === false || typeof selector === "function" ) {
      // ( types [, fn] )
      fn = selector;
      selector = undefined;
    }
    if ( fn === false ) {
      fn = returnFalse;
    }
    return this.each(function() {
      jQuery.event.remove( this, types, fn, selector );
    });
  },

  trigger: function( type, data ) {
    return this.each(function() {
      jQuery.event.trigger( type, data, this );
    });
  },
  triggerHandler: function( type, data ) {
    var elem = this[0];
    if ( elem ) {
      return jQuery.event.trigger( type, data, elem, true );
    }
  }
});


var
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
  rtagName = /<([\w:]+)/,
  rhtml = /<|&#?\w+;/,
  rnoInnerhtml = /<(?:script|style|link)/i,
  // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  rscriptType = /^$|\/(?:java|ecma)script/i,
  rscriptTypeMasked = /^true\/(.*)/,
  rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

  // We have to close these tags to support XHTML (#13200)
  wrapMap = {

    // Support: IE9
    option: [ 1, "<select multiple='multiple'>", "</select>" ],

    thead: [ 1, "<table>", "</table>" ],
    col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

    _default: [ 0, "", "" ]
  };

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
  return jQuery.nodeName( elem, "table" ) &&
    jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

    elem.getElementsByTagName("tbody")[0] ||
      elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
    elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
  elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
  return elem;
}
function restoreScript( elem ) {
  var match = rscriptTypeMasked.exec( elem.type );

  if ( match ) {
    elem.type = match[ 1 ];
  } else {
    elem.removeAttribute("type");
  }

  return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
  var i = 0,
    l = elems.length;

  for ( ; i < l; i++ ) {
    data_priv.set(
      elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
    );
  }
}

function cloneCopyEvent( src, dest ) {
  var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

  if ( dest.nodeType !== 1 ) {
    return;
  }

  // 1. Copy private data: events, handlers, etc.
  if ( data_priv.hasData( src ) ) {
    pdataOld = data_priv.access( src );
    pdataCur = data_priv.set( dest, pdataOld );
    events = pdataOld.events;

    if ( events ) {
      delete pdataCur.handle;
      pdataCur.events = {};

      for ( type in events ) {
        for ( i = 0, l = events[ type ].length; i < l; i++ ) {
          jQuery.event.add( dest, type, events[ type ][ i ] );
        }
      }
    }
  }

  // 2. Copy user data
  if ( data_user.hasData( src ) ) {
    udataOld = data_user.access( src );
    udataCur = jQuery.extend( {}, udataOld );

    data_user.set( dest, udataCur );
  }
}

function getAll( context, tag ) {
  var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
      context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
      [];

  return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
    jQuery.merge( [ context ], ret ) :
    ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
  var nodeName = dest.nodeName.toLowerCase();

  // Fails to persist the checked state of a cloned checkbox or radio button.
  if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
    dest.checked = src.checked;

  // Fails to return the selected option to the default selected state when cloning options
  } else if ( nodeName === "input" || nodeName === "textarea" ) {
    dest.defaultValue = src.defaultValue;
  }
}

jQuery.extend({
  clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    var i, l, srcElements, destElements,
      clone = elem.cloneNode( true ),
      inPage = jQuery.contains( elem.ownerDocument, elem );

    // Fix IE cloning issues
    if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
        !jQuery.isXMLDoc( elem ) ) {

      // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
      destElements = getAll( clone );
      srcElements = getAll( elem );

      for ( i = 0, l = srcElements.length; i < l; i++ ) {
        fixInput( srcElements[ i ], destElements[ i ] );
      }
    }

    // Copy the events from the original to the clone
    if ( dataAndEvents ) {
      if ( deepDataAndEvents ) {
        srcElements = srcElements || getAll( elem );
        destElements = destElements || getAll( clone );

        for ( i = 0, l = srcElements.length; i < l; i++ ) {
          cloneCopyEvent( srcElements[ i ], destElements[ i ] );
        }
      } else {
        cloneCopyEvent( elem, clone );
      }
    }

    // Preserve script evaluation history
    destElements = getAll( clone, "script" );
    if ( destElements.length > 0 ) {
      setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
    }

    // Return the cloned set
    return clone;
  },

  buildFragment: function( elems, context, scripts, selection ) {
    var elem, tmp, tag, wrap, contains, j,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i = 0,
      l = elems.length;

    for ( ; i < l; i++ ) {
      elem = elems[ i ];

      if ( elem || elem === 0 ) {

        // Add nodes directly
        if ( jQuery.type( elem ) === "object" ) {
          // Support: QtWebKit, PhantomJS
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

        // Convert non-html into a text node
        } else if ( !rhtml.test( elem ) ) {
          nodes.push( context.createTextNode( elem ) );

        // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild( context.createElement("div") );

          // Deserialize a standard representation
          tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
          wrap = wrapMap[ tag ] || wrapMap._default;

          if (Xut.IBooks.Enabled) {
              try {
                  tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
              } catch (e) {
                  console.log(wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2])
              }
          } else {
              tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
          }

          // Descend through wrappers to the right content
          j = wrap[ 0 ];
          while ( j-- ) {
            tmp = tmp.lastChild;
          }

          // Support: QtWebKit, PhantomJS
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge( nodes, tmp.childNodes );

          // Remember the top-level container
          tmp = fragment.firstChild;

          // Ensure the created nodes are orphaned (#12392)
          tmp.textContent = "";
        }
      }
    }

    // Remove wrapper from fragment
    fragment.textContent = "";

    i = 0;
    while ( (elem = nodes[ i++ ]) ) {

      // #4087 - If origin and destination elements are the same, and this is
      // that element, do not do anything
      if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
        continue;
      }

      contains = jQuery.contains( elem.ownerDocument, elem );

      // Append to fragment
      tmp = getAll( fragment.appendChild( elem ), "script" );

      // Preserve script evaluation history
      if ( contains ) {
        setGlobalEval( tmp );
      }

      // Capture executables
      if ( scripts ) {
        j = 0;
        while ( (elem = tmp[ j++ ]) ) {
          if ( rscriptType.test( elem.type || "" ) ) {
            scripts.push( elem );
          }
        }
      }
    }

    return fragment;
  },

  cleanData: function( elems ) {
    var data, elem, type, key,
      special = jQuery.event.special,
      i = 0;

    for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
      if ( jQuery.acceptData( elem ) ) {
        key = elem[ data_priv.expando ];

        if ( key && (data = data_priv.cache[ key ]) ) {
          if ( data.events ) {
            for ( type in data.events ) {
              if ( special[ type ] ) {
                jQuery.event.remove( elem, type );

              // This is a shortcut to avoid jQuery.event.remove's overhead
              } else {
                jQuery.removeEvent( elem, type, data.handle );
              }
            }
          }
          if ( data_priv.cache[ key ] ) {
            // Discard any remaining `private` data
            delete data_priv.cache[ key ];
          }
        }
      }
      // Discard any remaining `user` data
      delete data_user.cache[ elem[ data_user.expando ] ];
    }
  }
});

jQuery.fn.extend({
  text: function( value ) {
    return access( this, function( value ) {
      return value === undefined ?
        jQuery.text( this ) :
        this.empty().each(function() {
          if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
            this.textContent = value;
          }
        });
    }, null, value, arguments.length );
  },

  append: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
        var target = manipulationTarget( this, elem );
        target.appendChild( elem );
      }
    });
  },

  prepend: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
        var target = manipulationTarget( this, elem );
        target.insertBefore( elem, target.firstChild );
      }
    });
  },

  before: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.parentNode ) {
        this.parentNode.insertBefore( elem, this );
      }
    });
  },

  after: function() {
    return this.domManip( arguments, function( elem ) {
      if ( this.parentNode ) {
        this.parentNode.insertBefore( elem, this.nextSibling );
      }
    });
  },

  remove: function( selector, keepData /* Internal Use Only */ ) {
    var elem,
      elems = selector ? jQuery.filter( selector, this ) : this,
      i = 0;

    for ( ; (elem = elems[i]) != null; i++ ) {
      if ( !keepData && elem.nodeType === 1 ) {
        jQuery.cleanData( getAll( elem ) );
      }

      if ( elem.parentNode ) {
        if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
          setGlobalEval( getAll( elem, "script" ) );
        }
        elem.parentNode.removeChild( elem );
      }
    }

    return this;
  },

  empty: function() {
    var elem,
      i = 0;

    for ( ; (elem = this[i]) != null; i++ ) {
      if ( elem.nodeType === 1 ) {

        // Prevent memory leaks
        jQuery.cleanData( getAll( elem, false ) );

        // Remove any remaining nodes
        elem.textContent = "";
      }
    }

    return this;
  },

  clone: function( dataAndEvents, deepDataAndEvents ) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map(function() {
      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    });
  },

  html: function( value ) {
    return access( this, function( value ) {
      var elem = this[ 0 ] || {},
        i = 0,
        l = this.length;

      if ( value === undefined && elem.nodeType === 1 ) {
        return elem.innerHTML;
      }

      // See if we can take a shortcut and just use innerHTML
      if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
        !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

        value = value.replace( rxhtmlTag, "<$1></$2>" );

        try {
          for ( ; i < l; i++ ) {
            elem = this[ i ] || {};

            // Remove element nodes and prevent memory leaks
            if ( elem.nodeType === 1 ) {
              jQuery.cleanData( getAll( elem, false ) );
              elem.innerHTML = value;
            }
          }

          elem = 0;

        // If using innerHTML throws an exception, use the fallback method
        } catch( e ) {}
      }

      if ( elem ) {
        this.empty().append( value );
      }
    }, null, value, arguments.length );
  },

  replaceWith: function() {
    var arg = arguments[ 0 ];

    // Make the changes, replacing each context element with the new content
    this.domManip( arguments, function( elem ) {
      arg = this.parentNode;

      jQuery.cleanData( getAll( this ) );

      if ( arg ) {
        arg.replaceChild( elem, this );
      }
    });

    // Force removal if there was no new content (e.g., from empty arguments)
    return arg && (arg.length || arg.nodeType) ? this : this.remove();
  },

  detach: function( selector ) {
    return this.remove( selector, true );
  },

  domManip: function( args, callback ) {

    // Flatten any nested arrays
    args = concat.apply( [], args );

    var fragment, first, scripts, hasScripts, node, doc,
      i = 0,
      l = this.length,
      set = this,
      iNoClone = l - 1,
      value = args[ 0 ],
      isFunction = jQuery.isFunction( value );

    // We can't cloneNode fragments that contain checked, in WebKit
    if ( isFunction ||
        ( l > 1 && typeof value === "string" &&
          !support.checkClone && rchecked.test( value ) ) ) {
      return this.each(function( index ) {
        var self = set.eq( index );
        if ( isFunction ) {
          args[ 0 ] = value.call( this, index, self.html() );
        }
        self.domManip( args, callback );
      });
    }

    if ( l ) {
      fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
      first = fragment.firstChild;

      if ( fragment.childNodes.length === 1 ) {
        fragment = first;
      }

      if ( first ) {
        scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
        hasScripts = scripts.length;

        // Use the original fragment for the last item instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).
        for ( ; i < l; i++ ) {
          node = fragment;

          if ( i !== iNoClone ) {
            node = jQuery.clone( node, true, true );

            // Keep references to cloned scripts for later restoration
            if ( hasScripts ) {
              // Support: QtWebKit
              // jQuery.merge because push.apply(_, arraylike) throws
              jQuery.merge( scripts, getAll( node, "script" ) );
            }
          }

          callback.call( this[ i ], node, i );
        }

        if ( hasScripts ) {
          doc = scripts[ scripts.length - 1 ].ownerDocument;

          // Reenable scripts
          jQuery.map( scripts, restoreScript );

          // Evaluate executable scripts on first document insertion
          for ( i = 0; i < hasScripts; i++ ) {
            node = scripts[ i ];
            if ( rscriptType.test( node.type || "" ) &&
              !data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

              if ( node.src ) {
                // Optional AJAX dependency, but won't run scripts if not present
                if ( jQuery._evalUrl ) {
                  jQuery._evalUrl( node.src );
                }
              } else {
                jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
              }
            }
          }
        }
      }
    }

    return this;
  }
});

jQuery.each({
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function( name, original ) {
  jQuery.fn[ name ] = function( selector ) {
    var elems,
      ret = [],
      insert = jQuery( selector ),
      last = insert.length - 1,
      i = 0;

    for ( ; i <= last; i++ ) {
      elems = i === last ? this : this.clone( true );
      jQuery( insert[ i ] )[ original ]( elems );

      // Support: QtWebKit
      // .get() because push.apply(_, arraylike) throws
      push.apply( ret, elems.get() );
    }

    return this.pushStack( ret );
  };
});


var iframe,
  elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
  var style,
    elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

    // getDefaultComputedStyle might be reliably used only on attached element
    display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

      // Use of this method is a temporary fix (more like optimization) until something better comes along,
      // since it was removed from specification and supported only in FF
      style.display : jQuery.css( elem[ 0 ], "display" );

  // We don't have any data stored on the element,
  // so use "detach" method as fast way to get rid of the element
  elem.detach();

  return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
  var doc = document,
    display = elemdisplay[ nodeName ];

  if ( !display ) {
    display = actualDisplay( nodeName, doc );

    // If the simple way fails, read from inside an iframe
    if ( display === "none" || !display ) {

      // Use the already-created iframe if possible
      iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

      // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
      doc = iframe[ 0 ].contentDocument;

      // Support: IE
      doc.write();
      doc.close();

      display = actualDisplay( nodeName, doc );
      iframe.detach();
    }

    // Store the correct default display
    elemdisplay[ nodeName ] = display;
  }

  return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    if ( elem.ownerDocument.defaultView.opener ) {
      return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
    }

    return window.getComputedStyle( elem, null );
  };



function curCSS( elem, name, computed ) {
  var width, minWidth, maxWidth, ret,
    style = elem.style;

  computed = computed || getStyles( elem );

  // Support: IE9
  // getPropertyValue is only needed for .css('filter') (#12537)
  if ( computed ) {
    ret = computed.getPropertyValue( name ) || computed[ name ];
  }

  if ( computed ) {

    if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
      ret = jQuery.style( elem, name );
    }

    // Support: iOS < 6
    // A tribute to the "awesome hack by Dean Edwards"
    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
    if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

      // Remember the original values
      width = style.width;
      minWidth = style.minWidth;
      maxWidth = style.maxWidth;

      // Put in the new values to get a computed value out
      style.minWidth = style.maxWidth = style.width = ret;
      ret = computed.width;

      // Revert the changed values
      style.width = width;
      style.minWidth = minWidth;
      style.maxWidth = maxWidth;
    }
  }

  return ret !== undefined ?
    // Support: IE
    // IE returns zIndex value as an integer.
    ret + "" :
    ret;
}


function addGetHookIf( conditionFn, hookFn ) {
  // Define the hook, we'll check on the first run if it's really needed.
  return {
    get: function() {
      if ( conditionFn() ) {
        // Hook not needed (or it's not possible to use it due
        // to missing dependency), remove it.
        delete this.get;
        return;
      }

      // Hook needed; redefine it so that the support test is not executed again.
      return (this.get = hookFn).apply( this, arguments );
    }
  };
}


(function() {
  var pixelPositionVal, boxSizingReliableVal,
    docElem = document.documentElement,
    container = document.createElement( "div" ),
    div = document.createElement( "div" );

  if ( !div.style ) {
    return;
  }

  // Support: IE9-11+
  // Style of cloned element affects source element cloned (#8908)
  div.style.backgroundClip = "content-box";
  div.cloneNode( true ).style.backgroundClip = "";
  support.clearCloneStyle = div.style.backgroundClip === "content-box";

  container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
    "position:absolute";
  container.appendChild( div );

  // Executing both pixelPosition & boxSizingReliable tests require only one layout
  // so they're executed at the same time to save the second computation.
  function computePixelPositionAndBoxSizingReliable() {
    div.style.cssText =
      // Support: Firefox<29, Android 2.3
      // Vendor-prefix box-sizing
      "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
      "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
      "border:1px;padding:1px;width:4px;position:absolute";
    div.innerHTML = "";
    docElem.appendChild( container );

    var divStyle = window.getComputedStyle( div, null );
    pixelPositionVal = divStyle.top !== "1%";
    boxSizingReliableVal = divStyle.width === "4px";

    docElem.removeChild( container );
  }

  // Support: node.js jsdom
  // Don't assume that getComputedStyle is a property of the global object
  if ( window.getComputedStyle ) {
    jQuery.extend( support, {
      pixelPosition: function() {

        // This test is executed only once but we still do memoizing
        // since we can use the boxSizingReliable pre-computing.
        // No need to check if the test was already performed, though.
        computePixelPositionAndBoxSizingReliable();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        if ( boxSizingReliableVal == null ) {
          computePixelPositionAndBoxSizingReliable();
        }
        return boxSizingReliableVal;
      },
      reliableMarginRight: function() {

        // Support: Android 2.3
        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. (#3333)
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        // This support function is only executed once so no memoizing is needed.
        var ret,
          marginDiv = div.appendChild( document.createElement( "div" ) );

        // Reset CSS: box-sizing; display; margin; border; padding
        marginDiv.style.cssText = div.style.cssText =
          // Support: Firefox<29, Android 2.3
          // Vendor-prefix box-sizing
          "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
          "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
        marginDiv.style.marginRight = marginDiv.style.width = "0";
        div.style.width = "1px";
        docElem.appendChild( container );

        ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

        docElem.removeChild( container );
        div.removeChild( marginDiv );

        return ret;
      }
    });
  }
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
  var ret, name,
    old = {};

  // Remember the old values, and insert the new ones
  for ( name in options ) {
    old[ name ] = elem.style[ name ];
    elem.style[ name ] = options[ name ];
  }

  ret = callback.apply( elem, args || [] );

  // Revert the old values
  for ( name in options ) {
    elem.style[ name ] = old[ name ];
  }

  return ret;
};


var
  // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
  rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

  cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  },

  cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

  // Shortcut for names that are not vendor prefixed
  if ( name in style ) {
    return name;
  }

  // Check for vendor prefixed names
  var capName = name[0].toUpperCase() + name.slice(1),
    origName = name,
    i = cssPrefixes.length;

  while ( i-- ) {
    name = cssPrefixes[ i ] + capName;
    if ( name in style ) {
      return name;
    }
  }

  return origName;
}

function setPositiveNumber( elem, value, subtract ) {
  var matches = rnumsplit.exec( value );
  return matches ?
    // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
    value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
  var i = extra === ( isBorderBox ? "border" : "content" ) ?
    // If we already have the right measurement, avoid augmentation
    4 :
    // Otherwise initialize for horizontal or vertical properties
    name === "width" ? 1 : 0,

    val = 0;

  for ( ; i < 4; i += 2 ) {
    // Both box models exclude margin, so add it if we want it
    if ( extra === "margin" ) {
      val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
    }

    if ( isBorderBox ) {
      // border-box includes padding, so remove it if we want content
      if ( extra === "content" ) {
        val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
      }

      // At this point, extra isn't border nor margin, so remove border
      if ( extra !== "margin" ) {
        val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
      }
    } else {
      // At this point, extra isn't content, so add padding
      val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

      // At this point, extra isn't content nor padding, so add border
      if ( extra !== "padding" ) {
        val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
      }
    }
  }

  return val;
}

function getWidthOrHeight( elem, name, extra ) {

  // Start with offset property, which is equivalent to the border-box value
  var valueIsBorderBox = true,
    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    styles = getStyles( elem ),
    isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  // Some non-html elements return undefined for offsetWidth, so check for null/undefined
  // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
  // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
  if ( val <= 0 || val == null ) {
    // Fall back to computed then uncomputed css if necessary
    val = curCSS( elem, name, styles );
    if ( val < 0 || val == null ) {
      val = elem.style[ name ];
    }

    // Computed unit is not pixels. Stop here and return.
    if ( rnumnonpx.test(val) ) {
      return val;
    }

    // Check for style in case a browser which returns unreliable values
    // for getComputedStyle silently falls back to the reliable elem.style
    valueIsBorderBox = isBorderBox &&
      ( support.boxSizingReliable() || val === elem.style[ name ] );

    // Normalize "", auto, and prepare for extra
    val = parseFloat( val ) || 0;
  }

  // Use the active box-sizing model to add/subtract irrelevant styles
  return ( val +
    augmentWidthOrHeight(
      elem,
      name,
      extra || ( isBorderBox ? "border" : "content" ),
      valueIsBorderBox,
      styles
    )
  ) + "px";
}

function showHide( elements, show ) {
  var display, elem, hidden,
    values = [],
    index = 0,
    length = elements.length;

  for ( ; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
      continue;
    }

    values[ index ] = data_priv.get( elem, "olddisplay" );
    display = elem.style.display;
    if ( show ) {
      // Reset the inline display of this element to learn if it is
      // being hidden by cascaded rules or not
      if ( !values[ index ] && display === "none" ) {
        elem.style.display = "";
      }

      // Set elements which have been overridden with display: none
      // in a stylesheet to whatever the default browser style is
      // for such an element
      if ( elem.style.display === "" && isHidden( elem ) ) {
        values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
      }
    } else {
      hidden = isHidden( elem );

      if ( display !== "none" || !hidden ) {
        data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
      }
    }
  }

  // Set the display of most of the elements in a second loop
  // to avoid the constant reflow
  for ( index = 0; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
      continue;
    }
    if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
      elem.style.display = show ? values[ index ] || "" : "none";
    }
  }

  return elements;
}

jQuery.extend({

  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function( elem, computed ) {
        if ( computed ) {

          // We should always get a number back from opacity
          var ret = curCSS( elem, "opacity" );
          return ret === "" ? "1" : ret;
        }
      }
    }
  },

  // Don't automatically add "px" to these possibly-unitless properties
  cssNumber: {
    "columnCount": true,
    "fillOpacity": true,
    "flexGrow": true,
    "flexShrink": true,
    "fontWeight": true,
    "lineHeight": true,
    "opacity": true,
    "order": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },

  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {
    "float": "cssFloat"
  },

  // Get and set the style property on a DOM Node
  style: function( elem, name, value, extra ) {

    // Don't set styles on text and comment nodes
    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
      return;
    }

    // Make sure that we're working with the right name
    var ret, type, hooks,
      origName = jQuery.camelCase( name ),
      style = elem.style;

    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

    // Gets hook for the prefixed version, then unprefixed version
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // Check if we're setting a value
    if ( value !== undefined ) {
      type = typeof value;

      // Convert "+=" or "-=" to relative numbers (#7345)
      if ( type === "string" && (ret = rrelNum.exec( value )) ) {
        value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
        // Fixes bug #9237
        type = "number";
      }

      // Make sure that null and NaN values aren't set (#7116)
      if ( value == null || value !== value ) {
        return;
      }

      // If a number, add 'px' to the (except for certain CSS properties)
      if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
        value += "px";
      }

      // Support: IE9-11+
      // background-* props affect original clone's values
      if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
        style[ name ] = "inherit";
      }

      // If a hook was provided, use that value, otherwise just set the specified value
      if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
        style[ name ] = value;
      }

    } else {
      // If a hook was provided get the non-computed value from there
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
        return ret;
      }

      // Otherwise just get the value from the style object
      return style[ name ];
    }
  },

  css: function( elem, name, extra, styles ) {
    var val, num, hooks,
      origName = jQuery.camelCase( name );

    // Make sure that we're working with the right name
    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

    // Try prefixed name followed by the unprefixed name
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // If a hook was provided get the computed value from there
    if ( hooks && "get" in hooks ) {
      val = hooks.get( elem, true, extra );
    }

    // Otherwise, if a way to get the computed value exists, use that
    if ( val === undefined ) {
      val = curCSS( elem, name, styles );
    }

    // Convert "normal" to computed value
    if ( val === "normal" && name in cssNormalTransform ) {
      val = cssNormalTransform[ name ];
    }

    // Make numeric if forced or a qualifier was provided and val looks numeric
    if ( extra === "" || extra ) {
      num = parseFloat( val );
      return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
    }
    return val;
  }
});

jQuery.each([ "height", "width" ], function( i, name ) {
  jQuery.cssHooks[ name ] = {
    get: function( elem, computed, extra ) {
      if ( computed ) {

        // Certain elements can have dimension info if we invisibly show them
        // but it must have a current display style that would benefit
        return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
          jQuery.swap( elem, cssShow, function() {
            return getWidthOrHeight( elem, name, extra );
          }) :
          getWidthOrHeight( elem, name, extra );
      }
    },

    set: function( elem, value, extra ) {
      var styles = extra && getStyles( elem );
      return setPositiveNumber( elem, value, extra ?
        augmentWidthOrHeight(
          elem,
          name,
          extra,
          jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
          styles
        ) : 0
      );
    }
  };
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
  function( elem, computed ) {
    if ( computed ) {
      return jQuery.swap( elem, { "display": "inline-block" },
        curCSS, [ elem, "marginRight" ] );
    }
  }
);

// These hooks are used by animate to expand properties
jQuery.each({
  margin: "",
  padding: "",
  border: "Width"
}, function( prefix, suffix ) {
  jQuery.cssHooks[ prefix + suffix ] = {
    expand: function( value ) {
      var i = 0,
        expanded = {},

        // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [ value ];

      for ( ; i < 4; i++ ) {
        expanded[ prefix + cssExpand[ i ] + suffix ] =
          parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
      }

      return expanded;
    }
  };

  if ( !rmargin.test( prefix ) ) {
    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  }
});

jQuery.fn.extend({
  css: function( name, value ) {
    return access( this, function( elem, name, value ) {
      var styles, len,
        map = {},
        i = 0;

      if ( jQuery.isArray( name ) ) {
        styles = getStyles( elem );
        len = name.length;

        for ( ; i < len; i++ ) {
          map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
        }

        return map;
      }

      return value !== undefined ?
        jQuery.style( elem, name, value ) :
        jQuery.css( elem, name );
    }, name, value, arguments.length > 1 );
  },
  show: function() {
    return showHide( this, true );
  },
  hide: function() {
    return showHide( this );
  },
  toggle: function( state ) {
    if ( typeof state === "boolean" ) {
      return state ? this.show() : this.hide();
    }

    return this.each(function() {
      if ( isHidden( this ) ) {
        jQuery( this ).show();
      } else {
        jQuery( this ).hide();
      }
    });
  }
});


function Tween( elem, options, prop, end, easing ) {
  return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
  constructor: Tween,
  init: function( elem, options, prop, end, easing, unit ) {
    this.elem = elem;
    this.prop = prop;
    this.easing = easing || "swing";
    this.options = options;
    this.start = this.now = this.cur();
    this.end = end;
    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  },
  cur: function() {
    var hooks = Tween.propHooks[ this.prop ];

    return hooks && hooks.get ?
      hooks.get( this ) :
      Tween.propHooks._default.get( this );
  },
  run: function( percent ) {
    var eased,
      hooks = Tween.propHooks[ this.prop ];

    if ( this.options.duration ) {
      this.pos = eased = jQuery.easing[ this.easing ](
        percent, this.options.duration * percent, 0, 1, this.options.duration
      );
    } else {
      this.pos = eased = percent;
    }
    this.now = ( this.end - this.start ) * eased + this.start;

    if ( this.options.step ) {
      this.options.step.call( this.elem, this.now, this );
    }

    if ( hooks && hooks.set ) {
      hooks.set( this );
    } else {
      Tween.propHooks._default.set( this );
    }
    return this;
  }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
  _default: {
    get: function( tween ) {
      var result;

      if ( tween.elem[ tween.prop ] != null &&
        (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
        return tween.elem[ tween.prop ];
      }

      // Passing an empty string as a 3rd parameter to .css will automatically
      // attempt a parseFloat and fallback to a string if the parse fails.
      // Simple values such as "10px" are parsed to Float;
      // complex values such as "rotate(1rad)" are returned as-is.
      result = jQuery.css( tween.elem, tween.prop, "" );
      // Empty strings, null, undefined and "auto" are converted to 0.
      return !result || result === "auto" ? 0 : result;
    },
    set: function( tween ) {
      // Use step hook for back compat.
      // Use cssHook if its there.
      // Use .style if available and use plain properties where available.
      if ( jQuery.fx.step[ tween.prop ] ) {
        jQuery.fx.step[ tween.prop ]( tween );
      } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
        jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
      } else {
        tween.elem[ tween.prop ] = tween.now;
      }
    }
  }
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  set: function( tween ) {
    if ( tween.elem.nodeType && tween.elem.parentNode ) {
      tween.elem[ tween.prop ] = tween.now;
    }
  }
};

jQuery.easing = {
  linear: function( p ) {
    return p;
  },
  swing: function( p ) {
    return 0.5 - Math.cos( p * Math.PI ) / 2;
  }
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
  fxNow, timerId,
  rfxtypes = /^(?:toggle|show|hide)$/,
  rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
  rrun = /queueHooks$/,
  animationPrefilters = [ defaultPrefilter ],
  tweeners = {
    "*": [ function( prop, value ) {
      var tween = this.createTween( prop, value ),
        target = tween.cur(),
        parts = rfxnum.exec( value ),
        unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

        // Starting value computation is required for potential unit mismatches
        start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
          rfxnum.exec( jQuery.css( tween.elem, prop ) ),
        scale = 1,
        maxIterations = 20;

      if ( start && start[ 3 ] !== unit ) {
        // Trust units reported by jQuery.css
        unit = unit || start[ 3 ];

        // Make sure we update the tween properties later on
        parts = parts || [];

        // Iteratively approximate from a nonzero starting point
        start = +target || 1;

        do {
          // If previous iteration zeroed out, double until we get *something*.
          // Use string for doubling so we don't accidentally see scale as unchanged below
          scale = scale || ".5";

          // Adjust and apply
          start = start / scale;
          jQuery.style( tween.elem, prop, start + unit );

        // Update scale, tolerating zero or NaN from tween.cur(),
        // break the loop if scale is unchanged or perfect, or if we've just had enough
        } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
      }

      // Update tween properties
      if ( parts ) {
        start = tween.start = +start || +target || 0;
        tween.unit = unit;
        // If a +=/-= token was provided, we're doing a relative animation
        tween.end = parts[ 1 ] ?
          start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
          +parts[ 2 ];
      }

      return tween;
    } ]
  };

// Animations created synchronously will run synchronously
function createFxNow() {
  setTimeout(function() {
    fxNow = undefined;
  });
  return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
  var which,
    i = 0,
    attrs = { height: type };

  // If we include width, step value is 1 to do all cssExpand values,
  // otherwise step value is 2 to skip over Left and Right
  includeWidth = includeWidth ? 1 : 0;
  for ( ; i < 4 ; i += 2 - includeWidth ) {
    which = cssExpand[ i ];
    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  }

  if ( includeWidth ) {
    attrs.opacity = attrs.width = type;
  }

  return attrs;
}

function createTween( value, prop, animation ) {
  var tween,
    collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
    index = 0,
    length = collection.length;
  for ( ; index < length; index++ ) {
    if ( (tween = collection[ index ].call( animation, prop, value )) ) {

      // We're done with this property
      return tween;
    }
  }
}

function defaultPrefilter( elem, props, opts ) {
  /* jshint validthis: true */
  var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
    anim = this,
    orig = {},
    style = elem.style,
    hidden = elem.nodeType && isHidden( elem ),
    dataShow = data_priv.get( elem, "fxshow" );

  // Handle queue: false promises
  if ( !opts.queue ) {
    hooks = jQuery._queueHooks( elem, "fx" );
    if ( hooks.unqueued == null ) {
      hooks.unqueued = 0;
      oldfire = hooks.empty.fire;
      hooks.empty.fire = function() {
        if ( !hooks.unqueued ) {
          oldfire();
        }
      };
    }
    hooks.unqueued++;

    anim.always(function() {
      // Ensure the complete handler is called before this completes
      anim.always(function() {
        hooks.unqueued--;
        if ( !jQuery.queue( elem, "fx" ).length ) {
          hooks.empty.fire();
        }
      });
    });
  }

  // Height/width overflow pass
  if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
    // Make sure that nothing sneaks out
    // Record all 3 overflow attributes because IE9-10 do not
    // change the overflow attribute when overflowX and
    // overflowY are set to the same value
    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

    // Set display property to inline-block for height/width
    // animations on inline elements that are having width/height animated
    display = jQuery.css( elem, "display" );

    // Test default display if display is currently "none"
    checkDisplay = display === "none" ?
      data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

    if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
      style.display = "inline-block";
    }
  }

  if ( opts.overflow ) {
    style.overflow = "hidden";
    anim.always(function() {
      style.overflow = opts.overflow[ 0 ];
      style.overflowX = opts.overflow[ 1 ];
      style.overflowY = opts.overflow[ 2 ];
    });
  }

  // show/hide pass
  for ( prop in props ) {
    value = props[ prop ];
    if ( rfxtypes.exec( value ) ) {
      delete props[ prop ];
      toggle = toggle || value === "toggle";
      if ( value === ( hidden ? "hide" : "show" ) ) {

        // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
        if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
          hidden = true;
        } else {
          continue;
        }
      }
      orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

    // Any non-fx value stops us from restoring the original display value
    } else {
      display = undefined;
    }
  }

  if ( !jQuery.isEmptyObject( orig ) ) {
    if ( dataShow ) {
      if ( "hidden" in dataShow ) {
        hidden = dataShow.hidden;
      }
    } else {
      dataShow = data_priv.access( elem, "fxshow", {} );
    }

    // Store state if its toggle - enables .stop().toggle() to "reverse"
    if ( toggle ) {
      dataShow.hidden = !hidden;
    }
    if ( hidden ) {
      jQuery( elem ).show();
    } else {
      anim.done(function() {
        jQuery( elem ).hide();
      });
    }
    anim.done(function() {
      var prop;

      data_priv.remove( elem, "fxshow" );
      for ( prop in orig ) {
        jQuery.style( elem, prop, orig[ prop ] );
      }
    });
    for ( prop in orig ) {
      tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

      if ( !( prop in dataShow ) ) {
        dataShow[ prop ] = tween.start;
        if ( hidden ) {
          tween.end = tween.start;
          tween.start = prop === "width" || prop === "height" ? 1 : 0;
        }
      }
    }

  // If this is a noop like .hide().hide(), restore an overwritten display value
  } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
    style.display = display;
  }
}

function propFilter( props, specialEasing ) {
  var index, name, easing, value, hooks;

  // camelCase, specialEasing and expand cssHook pass
  for ( index in props ) {
    name = jQuery.camelCase( index );
    easing = specialEasing[ name ];
    value = props[ index ];
    if ( jQuery.isArray( value ) ) {
      easing = value[ 1 ];
      value = props[ index ] = value[ 0 ];
    }

    if ( index !== name ) {
      props[ name ] = value;
      delete props[ index ];
    }

    hooks = jQuery.cssHooks[ name ];
    if ( hooks && "expand" in hooks ) {
      value = hooks.expand( value );
      delete props[ name ];

      // Not quite $.extend, this won't overwrite existing keys.
      // Reusing 'index' because we have the correct "name"
      for ( index in value ) {
        if ( !( index in props ) ) {
          props[ index ] = value[ index ];
          specialEasing[ index ] = easing;
        }
      }
    } else {
      specialEasing[ name ] = easing;
    }
  }
}

function Animation( elem, properties, options ) {
  var result,
    stopped,
    index = 0,
    length = animationPrefilters.length,
    deferred = jQuery.Deferred().always( function() {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
    tick = function() {
      if ( stopped ) {
        return false;
      }
      var currentTime = fxNow || createFxNow(),
        remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
        // Support: Android 2.3
        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
        temp = remaining / animation.duration || 0,
        percent = 1 - temp,
        index = 0,
        length = animation.tweens.length;

      for ( ; index < length ; index++ ) {
        animation.tweens[ index ].run( percent );
      }

      deferred.notifyWith( elem, [ animation, percent, remaining ]);

      if ( percent < 1 && length ) {
        return remaining;
      } else {
        deferred.resolveWith( elem, [ animation ] );
        return false;
      }
    },
    animation = deferred.promise({
      elem: elem,
      props: jQuery.extend( {}, properties ),
      opts: jQuery.extend( true, { specialEasing: {} }, options ),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function( prop, end ) {
        var tween = jQuery.Tween( elem, animation.opts, prop, end,
            animation.opts.specialEasing[ prop ] || animation.opts.easing );
        animation.tweens.push( tween );
        return tween;
      },
      stop: function( gotoEnd ) {
        var index = 0,
          // If we are going to the end, we want to run all the tweens
          // otherwise we skip this part
          length = gotoEnd ? animation.tweens.length : 0;
        if ( stopped ) {
          return this;
        }
        stopped = true;
        for ( ; index < length ; index++ ) {
          animation.tweens[ index ].run( 1 );
        }

        // Resolve when we played the last frame; otherwise, reject
        if ( gotoEnd ) {
          deferred.resolveWith( elem, [ animation, gotoEnd ] );
        } else {
          deferred.rejectWith( elem, [ animation, gotoEnd ] );
        }
        return this;
      }
    }),
    props = animation.props;

  propFilter( props, animation.opts.specialEasing );

  for ( ; index < length ; index++ ) {
    result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
    if ( result ) {
      return result;
    }
  }

  jQuery.map( props, createTween, animation );

  if ( jQuery.isFunction( animation.opts.start ) ) {
    animation.opts.start.call( elem, animation );
  }

  jQuery.fx.timer(
    jQuery.extend( tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    })
  );

  // attach callbacks from options
  return animation.progress( animation.opts.progress )
    .done( animation.opts.done, animation.opts.complete )
    .fail( animation.opts.fail )
    .always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

  tweener: function( props, callback ) {
    if ( jQuery.isFunction( props ) ) {
      callback = props;
      props = [ "*" ];
    } else {
      props = props.split(" ");
    }

    var prop,
      index = 0,
      length = props.length;

    for ( ; index < length ; index++ ) {
      prop = props[ index ];
      tweeners[ prop ] = tweeners[ prop ] || [];
      tweeners[ prop ].unshift( callback );
    }
  },

  prefilter: function( callback, prepend ) {
    if ( prepend ) {
      animationPrefilters.unshift( callback );
    } else {
      animationPrefilters.push( callback );
    }
  }
});

jQuery.speed = function( speed, easing, fn ) {
  var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    complete: fn || !fn && easing ||
      jQuery.isFunction( speed ) && speed,
    duration: speed,
    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
  };

  opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
    opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

  // Normalize opt.queue - true/undefined/null -> "fx"
  if ( opt.queue == null || opt.queue === true ) {
    opt.queue = "fx";
  }

  // Queueing
  opt.old = opt.complete;

  opt.complete = function() {
    if ( jQuery.isFunction( opt.old ) ) {
      opt.old.call( this );
    }

    if ( opt.queue ) {
      jQuery.dequeue( this, opt.queue );
    }
  };

  return opt;
};

jQuery.fn.extend({
  fadeTo: function( speed, to, easing, callback ) {

    // Show any hidden elements after setting opacity to 0
    return this.filter( isHidden ).css( "opacity", 0 ).show()

      // Animate to the value specified
      .end().animate({ opacity: to }, speed, easing, callback );
  },
  animate: function( prop, speed, easing, callback ) {
    var empty = jQuery.isEmptyObject( prop ),
      optall = jQuery.speed( speed, easing, callback ),
      doAnimation = function() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation( this, jQuery.extend( {}, prop ), optall );

        // Empty animations, or finishing resolves immediately
        if ( empty || data_priv.get( this, "finish" ) ) {
          anim.stop( true );
        }
      };
      doAnimation.finish = doAnimation;

    return empty || optall.queue === false ?
      this.each( doAnimation ) :
      this.queue( optall.queue, doAnimation );
  },
  stop: function( type, clearQueue, gotoEnd ) {
    var stopQueue = function( hooks ) {
      var stop = hooks.stop;
      delete hooks.stop;
      stop( gotoEnd );
    };

    if ( typeof type !== "string" ) {
      gotoEnd = clearQueue;
      clearQueue = type;
      type = undefined;
    }
    if ( clearQueue && type !== false ) {
      this.queue( type || "fx", [] );
    }

    return this.each(function() {
      var dequeue = true,
        index = type != null && type + "queueHooks",
        timers = jQuery.timers,
        data = data_priv.get( this );

      if ( index ) {
        if ( data[ index ] && data[ index ].stop ) {
          stopQueue( data[ index ] );
        }
      } else {
        for ( index in data ) {
          if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
            stopQueue( data[ index ] );
          }
        }
      }

      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
          timers[ index ].anim.stop( gotoEnd );
          dequeue = false;
          timers.splice( index, 1 );
        }
      }

      // Start the next in the queue if the last step wasn't forced.
      // Timers currently will call their complete callbacks, which
      // will dequeue but only if they were gotoEnd.
      if ( dequeue || !gotoEnd ) {
        jQuery.dequeue( this, type );
      }
    });
  },
  finish: function( type ) {
    if ( type !== false ) {
      type = type || "fx";
    }
    return this.each(function() {
      var index,
        data = data_priv.get( this ),
        queue = data[ type + "queue" ],
        hooks = data[ type + "queueHooks" ],
        timers = jQuery.timers,
        length = queue ? queue.length : 0;

      // Enable finishing flag on private data
      data.finish = true;

      // Empty the queue first
      jQuery.queue( this, type, [] );

      if ( hooks && hooks.stop ) {
        hooks.stop.call( this, true );
      }

      // Look for any active animations, and finish them
      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
          timers[ index ].anim.stop( true );
          timers.splice( index, 1 );
        }
      }

      // Look for any animations in the old queue and finish them
      for ( index = 0; index < length; index++ ) {
        if ( queue[ index ] && queue[ index ].finish ) {
          queue[ index ].finish.call( this );
        }
      }

      // Turn off finishing flag
      delete data.finish;
    });
  }
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
  var cssFn = jQuery.fn[ name ];
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return speed == null || typeof speed === "boolean" ?
      cssFn.apply( this, arguments ) :
      this.animate( genFx( name, true ), speed, easing, callback );
  };
});

// Generate shortcuts for custom animations
jQuery.each({
  slideDown: genFx("show"),
  slideUp: genFx("hide"),
  slideToggle: genFx("toggle"),
  fadeIn: { opacity: "show" },
  fadeOut: { opacity: "hide" },
  fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return this.animate( props, speed, easing, callback );
  };
});

jQuery.timers = [];
jQuery.fx.tick = function() {
  var timer,
    i = 0,
    timers = jQuery.timers;

  fxNow = jQuery.now();

  for ( ; i < timers.length; i++ ) {
    timer = timers[ i ];
    // Checks the timer has not already been removed
    if ( !timer() && timers[ i ] === timer ) {
      timers.splice( i--, 1 );
    }
  }

  if ( !timers.length ) {
    jQuery.fx.stop();
  }
  fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
  jQuery.timers.push( timer );
  if ( timer() ) {
    jQuery.fx.start();
  } else {
    jQuery.timers.pop();
  }
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
  if ( !timerId ) {
    timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
  }
};

jQuery.fx.stop = function() {
  clearInterval( timerId );
  timerId = null;
};

jQuery.fx.speeds = {
  slow: 600,
  fast: 200,
  // Default speed
  _default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
  time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  type = type || "fx";

  return this.queue( type, function( next, hooks ) {
    var timeout = setTimeout( next, time );
    hooks.stop = function() {
      clearTimeout( timeout );
    };
  });
};


(function() {
  var input = document.createElement( "input" ),
    select = document.createElement( "select" ),
    opt = select.appendChild( document.createElement( "option" ) );

  input.type = "checkbox";

  // Support: iOS<=5.1, Android<=4.2+
  // Default value for a checkbox should be "on"
  support.checkOn = input.value !== "";

  // Support: IE<=11+
  // Must access selectedIndex to make default options select
  support.optSelected = opt.selected;

  // Support: Android<=2.3
  // Options inside disabled selects are incorrectly marked as disabled
  select.disabled = true;
  support.optDisabled = !opt.disabled;

  // Support: IE<=11+
  // An input loses its value after becoming a radio
  input = document.createElement( "input" );
  input.value = "t";
  input.type = "radio";
  support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
  attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
  attr: function( name, value ) {
    return access( this, jQuery.attr, name, value, arguments.length > 1 );
  },

  removeAttr: function( name ) {
    return this.each(function() {
      jQuery.removeAttr( this, name );
    });
  }
});

jQuery.extend({
  attr: function( elem, name, value ) {
    var hooks, ret,
      nType = elem.nodeType;

    // don't get/set attributes on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    // Fallback to prop when attributes are not supported
    if ( typeof elem.getAttribute === strundefined ) {
      return jQuery.prop( elem, name, value );
    }

    // All attributes are lowercase
    // Grab necessary hook if one is defined
    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
      name = name.toLowerCase();
      hooks = jQuery.attrHooks[ name ] ||
        ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
    }

    if ( value !== undefined ) {

      if ( value === null ) {
        jQuery.removeAttr( elem, name );

      } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        elem.setAttribute( name, value + "" );
        return value;
      }

    } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
      return ret;

    } else {
      ret = jQuery.find.attr( elem, name );

      // Non-existent attributes return null, we normalize to undefined
      return ret == null ?
        undefined :
        ret;
    }
  },

  removeAttr: function( elem, value ) {
    var name, propName,
      i = 0,
      attrNames = value && value.match( rnotwhite );

    if ( attrNames && elem.nodeType === 1 ) {
      while ( (name = attrNames[i++]) ) {
        propName = jQuery.propFix[ name ] || name;

        // Boolean attributes get special treatment (#10870)
        if ( jQuery.expr.match.bool.test( name ) ) {
          // Set corresponding property to false
          elem[ propName ] = false;
        }

        elem.removeAttribute( name );
      }
    }
  },

  attrHooks: {
    type: {
      set: function( elem, value ) {
        if ( !support.radioValue && value === "radio" &&
          jQuery.nodeName( elem, "input" ) ) {
          var val = elem.value;
          elem.setAttribute( "type", value );
          if ( val ) {
            elem.value = val;
          }
          return value;
        }
      }
    }
  }
});

// Hooks for boolean attributes
boolHook = {
  set: function( elem, value, name ) {
    if ( value === false ) {
      // Remove boolean attributes when set to false
      jQuery.removeAttr( elem, name );
    } else {
      elem.setAttribute( name, name );
    }
    return name;
  }
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
  var getter = attrHandle[ name ] || jQuery.find.attr;

  attrHandle[ name ] = function( elem, name, isXML ) {
    var ret, handle;
    if ( !isXML ) {
      // Avoid an infinite loop by temporarily removing this function from the getter
      handle = attrHandle[ name ];
      attrHandle[ name ] = ret;
      ret = getter( elem, name, isXML ) != null ?
        name.toLowerCase() :
        null;
      attrHandle[ name ] = handle;
    }
    return ret;
  };
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
  prop: function( name, value ) {
    return access( this, jQuery.prop, name, value, arguments.length > 1 );
  },

  removeProp: function( name ) {
    return this.each(function() {
      delete this[ jQuery.propFix[ name ] || name ];
    });
  }
});

jQuery.extend({
  propFix: {
    "for": "htmlFor",
    "class": "className"
  },

  prop: function( elem, name, value ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // Don't get/set properties on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    if ( notxml ) {
      // Fix name and attach hooks
      name = jQuery.propFix[ name ] || name;
      hooks = jQuery.propHooks[ name ];
    }

    if ( value !== undefined ) {
      return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
        ret :
        ( elem[ name ] = value );

    } else {
      return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
        ret :
        elem[ name ];
    }
  },

  propHooks: {
    tabIndex: {
      get: function( elem ) {
        return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
          elem.tabIndex :
          -1;
      }
    }
  }
});

if ( !support.optSelected ) {
  jQuery.propHooks.selected = {
    get: function( elem ) {
      var parent = elem.parentNode;
      if ( parent && parent.parentNode ) {
        parent.parentNode.selectedIndex;
      }
      return null;
    }
  };
}

jQuery.each([
  "tabIndex",
  "readOnly",
  "maxLength",
  "cellSpacing",
  "cellPadding",
  "rowSpan",
  "colSpan",
  "useMap",
  "frameBorder",
  "contentEditable"
], function() {
  jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
  addClass: function( value ) {
    var classes, elem, cur, clazz, j, finalValue,
      proceed = typeof value === "string" && value,
      i = 0,
      len = this.length;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).addClass( value.call( this, j, this.className ) );
      });
    }

    if ( proceed ) {
      // The disjunction here is for better compressibility (see removeClass)
      classes = ( value || "" ).match( rnotwhite ) || [];

      for ( ; i < len; i++ ) {
        elem = this[ i ];
        cur = elem.nodeType === 1 && ( elem.className ?
          ( " " + elem.className + " " ).replace( rclass, " " ) :
          " "
        );

        if ( cur ) {
          j = 0;
          while ( (clazz = classes[j++]) ) {
            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
              cur += clazz + " ";
            }
          }

          // only assign if different to avoid unneeded rendering.
          finalValue = jQuery.trim( cur );
          if ( elem.className !== finalValue ) {
            elem.className = finalValue;
          }
        }
      }
    }

    return this;
  },

  removeClass: function( value ) {
    var classes, elem, cur, clazz, j, finalValue,
      proceed = arguments.length === 0 || typeof value === "string" && value,
      i = 0,
      len = this.length;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).removeClass( value.call( this, j, this.className ) );
      });
    }
    if ( proceed ) {
      classes = ( value || "" ).match( rnotwhite ) || [];

      for ( ; i < len; i++ ) {
        elem = this[ i ];
        // This expression is here for better compressibility (see addClass)
        cur = elem.nodeType === 1 && ( elem.className ?
          ( " " + elem.className + " " ).replace( rclass, " " ) :
          ""
        );

        if ( cur ) {
          j = 0;
          while ( (clazz = classes[j++]) ) {
            // Remove *all* instances
            while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
              cur = cur.replace( " " + clazz + " ", " " );
            }
          }

          // Only assign if different to avoid unneeded rendering.
          finalValue = value ? jQuery.trim( cur ) : "";
          if ( elem.className !== finalValue ) {
            elem.className = finalValue;
          }
        }
      }
    }

    return this;
  },

  toggleClass: function( value, stateVal ) {
    var type = typeof value;

    if ( typeof stateVal === "boolean" && type === "string" ) {
      return stateVal ? this.addClass( value ) : this.removeClass( value );
    }

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( i ) {
        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
      });
    }

    return this.each(function() {
      if ( type === "string" ) {
        // Toggle individual class names
        var className,
          i = 0,
          self = jQuery( this ),
          classNames = value.match( rnotwhite ) || [];

        while ( (className = classNames[ i++ ]) ) {
          // Check each className given, space separated list
          if ( self.hasClass( className ) ) {
            self.removeClass( className );
          } else {
            self.addClass( className );
          }
        }

      // Toggle whole class name
      } else if ( type === strundefined || type === "boolean" ) {
        if ( this.className ) {
          // store className if set
          data_priv.set( this, "__className__", this.className );
        }

        // If the element has a class name or if we're passed `false`,
        // then remove the whole classname (if there was one, the above saved it).
        // Otherwise bring back whatever was previously saved (if anything),
        // falling back to the empty string if nothing was stored.
        this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
      }
    });
  },

  hasClass: function( selector ) {
    var className = " " + selector + " ",
      i = 0,
      l = this.length;
    for ( ; i < l; i++ ) {
      if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
        return true;
      }
    }

    return false;
  }
});




var rreturn = /\r/g;

jQuery.fn.extend({
  val: function( value ) {
    var hooks, ret, isFunction,
      elem = this[0];

    if ( !arguments.length ) {
      if ( elem ) {
        hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

        if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
          return ret;
        }

        ret = elem.value;

        return typeof ret === "string" ?
          // Handle most common string cases
          ret.replace(rreturn, "") :
          // Handle cases where value is null/undef or number
          ret == null ? "" : ret;
      }

      return;
    }

    isFunction = jQuery.isFunction( value );

    return this.each(function( i ) {
      var val;

      if ( this.nodeType !== 1 ) {
        return;
      }

      if ( isFunction ) {
        val = value.call( this, i, jQuery( this ).val() );
      } else {
        val = value;
      }

      // Treat null/undefined as ""; convert numbers to string
      if ( val == null ) {
        val = "";

      } else if ( typeof val === "number" ) {
        val += "";

      } else if ( jQuery.isArray( val ) ) {
        val = jQuery.map( val, function( value ) {
          return value == null ? "" : value + "";
        });
      }

      hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

      // If set returns undefined, fall back to normal setting
      if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
        this.value = val;
      }
    });
  }
});

jQuery.extend({
  valHooks: {
    option: {
      get: function( elem ) {
        var val = jQuery.find.attr( elem, "value" );
        return val != null ?
          val :
          // Support: IE10-11+
          // option.text throws exceptions (#14686, #14858)
          jQuery.trim( jQuery.text( elem ) );
      }
    },
    select: {
      get: function( elem ) {
        var value, option,
          options = elem.options,
          index = elem.selectedIndex,
          one = elem.type === "select-one" || index < 0,
          values = one ? null : [],
          max = one ? index + 1 : options.length,
          i = index < 0 ?
            max :
            one ? index : 0;

        // Loop through all the selected options
        for ( ; i < max; i++ ) {
          option = options[ i ];

          // IE6-9 doesn't update selected after form reset (#2551)
          if ( ( option.selected || i === index ) &&
              // Don't return options that are disabled or in a disabled optgroup
              ( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
              ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

            // Get the specific value for the option
            value = jQuery( option ).val();

            // We don't need an array for one selects
            if ( one ) {
              return value;
            }

            // Multi-Selects return an array
            values.push( value );
          }
        }

        return values;
      },

      set: function( elem, value ) {
        var optionSet, option,
          options = elem.options,
          values = jQuery.makeArray( value ),
          i = options.length;

        while ( i-- ) {
          option = options[ i ];
          if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
            optionSet = true;
          }
        }

        // Force browsers to behave consistently when non-matching value is set
        if ( !optionSet ) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  }
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
  jQuery.valHooks[ this ] = {
    set: function( elem, value ) {
      if ( jQuery.isArray( value ) ) {
        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
      }
    }
  };
  if ( !support.checkOn ) {
    jQuery.valHooks[ this ].get = function( elem ) {
      return elem.getAttribute("value") === null ? "on" : elem.value;
    };
  }
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

  // Handle event binding
  jQuery.fn[ name ] = function( data, fn ) {
    return arguments.length > 0 ?
      this.on( name, null, data, fn ) :
      this.trigger( name );
  };
});

jQuery.fn.extend({
  hover: function( fnOver, fnOut ) {
    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  },

  bind: function( types, data, fn ) {
    return this.on( types, null, data, fn );
  },
  unbind: function( types, fn ) {
    return this.off( types, null, fn );
  },

  delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
  },
  undelegate: function( selector, types, fn ) {
    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
  }
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
  return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
  var xml, tmp;
  if ( !data || typeof data !== "string" ) {
    return null;
  }

  // Support: IE9
  try {
    tmp = new DOMParser();
    xml = tmp.parseFromString( data, "text/xml" );
  } catch ( e ) {
    xml = undefined;
  }

  if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
    jQuery.error( "Invalid XML: " + data );
  }
  return xml;
};


var
  rhash = /#.*$/,
  rts = /([?&])_=[^&]*/,
  rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  rnoContent = /^(?:GET|HEAD)$/,
  rprotocol = /^\/\//,
  rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},

  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat( "*" ),

  // Document location
  ajaxLocation = window.location.href,

  // Segment location into parts
  ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

  // dataTypeExpression is optional and defaults to "*"
  return function( dataTypeExpression, func ) {

    if ( typeof dataTypeExpression !== "string" ) {
      func = dataTypeExpression;
      dataTypeExpression = "*";
    }

    var dataType,
      i = 0,
      dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

    if ( jQuery.isFunction( func ) ) {
      // For each dataType in the dataTypeExpression
      while ( (dataType = dataTypes[i++]) ) {
        // Prepend if requested
        if ( dataType[0] === "+" ) {
          dataType = dataType.slice( 1 ) || "*";
          (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

        // Otherwise append
        } else {
          (structure[ dataType ] = structure[ dataType ] || []).push( func );
        }
      }
    }
  };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  var inspected = {},
    seekingTransport = ( structure === transports );

  function inspect( dataType ) {
    var selected;
    inspected[ dataType ] = true;
    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
      var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
      if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
        options.dataTypes.unshift( dataTypeOrTransport );
        inspect( dataTypeOrTransport );
        return false;
      } else if ( seekingTransport ) {
        return !( selected = dataTypeOrTransport );
      }
    });
    return selected;
  }

  return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
  var key, deep,
    flatOptions = jQuery.ajaxSettings.flatOptions || {};

  for ( key in src ) {
    if ( src[ key ] !== undefined ) {
      ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
    }
  }
  if ( deep ) {
    jQuery.extend( true, target, deep );
  }

  return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

  var ct, type, finalDataType, firstDataType,
    contents = s.contents,
    dataTypes = s.dataTypes;

  // Remove auto dataType and get content-type in the process
  while ( dataTypes[ 0 ] === "*" ) {
    dataTypes.shift();
    if ( ct === undefined ) {
      ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
    }
  }

  // Check if we're dealing with a known content-type
  if ( ct ) {
    for ( type in contents ) {
      if ( contents[ type ] && contents[ type ].test( ct ) ) {
        dataTypes.unshift( type );
        break;
      }
    }
  }

  // Check to see if we have a response for the expected dataType
  if ( dataTypes[ 0 ] in responses ) {
    finalDataType = dataTypes[ 0 ];
  } else {
    // Try convertible dataTypes
    for ( type in responses ) {
      if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
        finalDataType = type;
        break;
      }
      if ( !firstDataType ) {
        firstDataType = type;
      }
    }
    // Or just use first one
    finalDataType = finalDataType || firstDataType;
  }

  // If we found a dataType
  // We add the dataType to the list if needed
  // and return the corresponding response
  if ( finalDataType ) {
    if ( finalDataType !== dataTypes[ 0 ] ) {
      dataTypes.unshift( finalDataType );
    }
    return responses[ finalDataType ];
  }
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
  var conv2, current, conv, tmp, prev,
    converters = {},
    // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice();

  // Create converters map with lowercased keys
  if ( dataTypes[ 1 ] ) {
    for ( conv in s.converters ) {
      converters[ conv.toLowerCase() ] = s.converters[ conv ];
    }
  }

  current = dataTypes.shift();

  // Convert to each sequential dataType
  while ( current ) {

    if ( s.responseFields[ current ] ) {
      jqXHR[ s.responseFields[ current ] ] = response;
    }

    // Apply the dataFilter if provided
    if ( !prev && isSuccess && s.dataFilter ) {
      response = s.dataFilter( response, s.dataType );
    }

    prev = current;
    current = dataTypes.shift();

    if ( current ) {

    // There's only work to do if current dataType is non-auto
      if ( current === "*" ) {

        current = prev;

      // Convert response if prev dataType is non-auto and differs from current
      } else if ( prev !== "*" && prev !== current ) {

        // Seek a direct converter
        conv = converters[ prev + " " + current ] || converters[ "* " + current ];

        // If none found, seek a pair
        if ( !conv ) {
          for ( conv2 in converters ) {

            // If conv2 outputs current
            tmp = conv2.split( " " );
            if ( tmp[ 1 ] === current ) {

              // If prev can be converted to accepted input
              conv = converters[ prev + " " + tmp[ 0 ] ] ||
                converters[ "* " + tmp[ 0 ] ];
              if ( conv ) {
                // Condense equivalence converters
                if ( conv === true ) {
                  conv = converters[ conv2 ];

                // Otherwise, insert the intermediate dataType
                } else if ( converters[ conv2 ] !== true ) {
                  current = tmp[ 0 ];
                  dataTypes.unshift( tmp[ 1 ] );
                }
                break;
              }
            }
          }
        }

        // Apply converter (if not an equivalence)
        if ( conv !== true ) {

          // Unless errors are allowed to bubble, catch and return them
          if ( conv && s[ "throws" ] ) {
            response = conv( response );
          } else {
            try {
              response = conv( response );
            } catch ( e ) {
              return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
            }
          }
        }
      }
    }
  }

  return { state: "success", data: response };
}

jQuery.extend({

  // Counter for holding the number of active queries
  active: 0,

  // Last-Modified header cache for next request
  lastModified: {},
  etag: {},

  ajaxSettings: {
    url: ajaxLocation,
    type: "GET",
    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
    global: true,
    processData: true,
    async: true,
    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
    /*
    timeout: 0,
    data: null,
    dataType: null,
    username: null,
    password: null,
    cache: null,
    throws: false,
    traditional: false,
    headers: {},
    */

    accepts: {
      "*": allTypes,
      text: "text/plain",
      html: "text/html",
      xml: "application/xml, text/xml",
      json: "application/json, text/javascript"
    },

    contents: {
      xml: /xml/,
      html: /html/,
      json: /json/
    },

    responseFields: {
      xml: "responseXML",
      text: "responseText",
      json: "responseJSON"
    },

    // Data converters
    // Keys separate source (or catchall "*") and destination types with a single space
    converters: {

      // Convert anything to text
      "* text": String,

      // Text to html (true = no transformation)
      "text html": true,

      // Evaluate text as a json expression
      "text json": jQuery.parseJSON,

      // Parse text as xml
      "text xml": jQuery.parseXML
    },

    // For options that shouldn't be deep extended:
    // you can add your own custom options here if
    // and when you create one that shouldn't be
    // deep extended (see ajaxExtend)
    flatOptions: {
      url: true,
      context: true
    }
  },

  // Creates a full fledged settings object into target
  // with both ajaxSettings and settings fields.
  // If target is omitted, writes into ajaxSettings.
  ajaxSetup: function( target, settings ) {
    return settings ?

      // Building a settings object
      ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

      // Extending ajaxSettings
      ajaxExtend( jQuery.ajaxSettings, target );
  },

  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  ajaxTransport: addToPrefiltersOrTransports( transports ),

  // Main method
  ajax: function( url, options ) {

    // If url is an object, simulate pre-1.5 signature
    if ( typeof url === "object" ) {
      options = url;
      url = undefined;
    }

    // Force options to be an object
    options = options || {};

    var transport,
      // URL without anti-cache param
      cacheURL,
      // Response headers
      responseHeadersString,
      responseHeaders,
      // timeout handle
      timeoutTimer,
      // Cross-domain detection vars
      parts,
      // To know if global events are to be dispatched
      fireGlobals,
      // Loop variable
      i,
      // Create the final options object
      s = jQuery.ajaxSetup( {}, options ),
      // Callbacks context
      callbackContext = s.context || s,
      // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
        jQuery( callbackContext ) :
        jQuery.event,
      // Deferreds
      deferred = jQuery.Deferred(),
      completeDeferred = jQuery.Callbacks("once memory"),
      // Status-dependent callbacks
      statusCode = s.statusCode || {},
      // Headers (they are sent all at once)
      requestHeaders = {},
      requestHeadersNames = {},
      // The jqXHR state
      state = 0,
      // Default abort message
      strAbort = "canceled",
      // Fake xhr
      jqXHR = {
        readyState: 0,

        // Builds headers hashtable if needed
        getResponseHeader: function( key ) {
          var match;
          if ( state === 2 ) {
            if ( !responseHeaders ) {
              responseHeaders = {};
              while ( (match = rheaders.exec( responseHeadersString )) ) {
                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
              }
            }
            match = responseHeaders[ key.toLowerCase() ];
          }
          return match == null ? null : match;
        },

        // Raw string
        getAllResponseHeaders: function() {
          return state === 2 ? responseHeadersString : null;
        },

        // Caches the header
        setRequestHeader: function( name, value ) {
          var lname = name.toLowerCase();
          if ( !state ) {
            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
            requestHeaders[ name ] = value;
          }
          return this;
        },

        // Overrides response content-type header
        overrideMimeType: function( type ) {
          if ( !state ) {
            s.mimeType = type;
          }
          return this;
        },

        // Status-dependent callbacks
        statusCode: function( map ) {
          var code;
          if ( map ) {
            if ( state < 2 ) {
              for ( code in map ) {
                // Lazy-add the new callback in a way that preserves old ones
                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
              }
            } else {
              // Execute the appropriate callbacks
              jqXHR.always( map[ jqXHR.status ] );
            }
          }
          return this;
        },

        // Cancel the request
        abort: function( statusText ) {
          var finalText = statusText || strAbort;
          if ( transport ) {
            transport.abort( finalText );
          }
          done( 0, finalText );
          return this;
        }
      };

    // Attach deferreds
    deferred.promise( jqXHR ).complete = completeDeferred.add;
    jqXHR.success = jqXHR.done;
    jqXHR.error = jqXHR.fail;

    // Remove hash character (#7531: and string promotion)
    // Add protocol if not provided (prefilters might expect it)
    // Handle falsy url in the settings object (#10093: consistency with old signature)
    // We also use the url parameter if available
    s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
      .replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

    // Alias method option to type as per ticket #12004
    s.type = options.method || options.type || s.method || s.type;

    // Extract dataTypes list
    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

    // A cross-domain request is in order when we have a protocol:host:port mismatch
    if ( s.crossDomain == null ) {
      parts = rurl.exec( s.url.toLowerCase() );
      s.crossDomain = !!( parts &&
        ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
          ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
      );
    }

    // Convert data if not already a string
    if ( s.data && s.processData && typeof s.data !== "string" ) {
      s.data = jQuery.param( s.data, s.traditional );
    }

    // Apply prefilters
    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    // If request was aborted inside a prefilter, stop there
    if ( state === 2 ) {
      return jqXHR;
    }

    // We can fire global events as of now if asked to
    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
    fireGlobals = jQuery.event && s.global;

    // Watch for a new set of requests
    if ( fireGlobals && jQuery.active++ === 0 ) {
      jQuery.event.trigger("ajaxStart");
    }

    // Uppercase the type
    s.type = s.type.toUpperCase();

    // Determine if request has content
    s.hasContent = !rnoContent.test( s.type );

    // Save the URL in case we're toying with the If-Modified-Since
    // and/or If-None-Match header later on
    cacheURL = s.url;

    // More options handling for requests with no content
    if ( !s.hasContent ) {

      // If data is available, append data to url
      if ( s.data ) {
        cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
        // #9682: remove data so that it's not used in an eventual retry
        delete s.data;
      }

      // Add anti-cache in url if needed
      if ( s.cache === false ) {
        s.url = rts.test( cacheURL ) ?

          // If there is already a '_' parameter, set its value
          cacheURL.replace( rts, "$1_=" + nonce++ ) :

          // Otherwise add one to the end
          cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
      }
    }

    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    if ( s.ifModified ) {
      if ( jQuery.lastModified[ cacheURL ] ) {
        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
      }
      if ( jQuery.etag[ cacheURL ] ) {
        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
      }
    }

    // Set the correct header, if data is being sent
    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
      jqXHR.setRequestHeader( "Content-Type", s.contentType );
    }

    // Set the Accepts header for the server, depending on the dataType
    jqXHR.setRequestHeader(
      "Accept",
      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
        s.accepts[ "*" ]
    );

    // Check for headers option
    for ( i in s.headers ) {
      jqXHR.setRequestHeader( i, s.headers[ i ] );
    }

    // Allow custom headers/mimetypes and early abort
    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
      // Abort if not done already and return
      return jqXHR.abort();
    }

    // Aborting is no longer a cancellation
    strAbort = "abort";

    // Install callbacks on deferreds
    for ( i in { success: 1, error: 1, complete: 1 } ) {
      jqXHR[ i ]( s[ i ] );
    }

    // Get transport
    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    // If no transport, we auto-abort
    if ( !transport ) {
      done( -1, "No Transport" );
    } else {
      jqXHR.readyState = 1;

      // Send global event
      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
      }
      // Timeout
      if ( s.async && s.timeout > 0 ) {
        timeoutTimer = setTimeout(function() {
          jqXHR.abort("timeout");
        }, s.timeout );
      }

      try {
        state = 1;
        transport.send( requestHeaders, done );
      } catch ( e ) {
        // Propagate exception as error if not done
        if ( state < 2 ) {
          done( -1, e );
        // Simply rethrow otherwise
        } else {
          throw e;
        }
      }
    }

    // Callback for when everything is done
    function done( status, nativeStatusText, responses, headers ) {
      var isSuccess, success, error, response, modified,
        statusText = nativeStatusText;

      // Called once
      if ( state === 2 ) {
        return;
      }

      // State is "done" now
      state = 2;

      // Clear timeout if it exists
      if ( timeoutTimer ) {
        clearTimeout( timeoutTimer );
      }

      // Dereference transport for early garbage collection
      // (no matter how long the jqXHR object will be used)
      transport = undefined;

      // Cache response headers
      responseHeadersString = headers || "";

      // Set readyState
      jqXHR.readyState = status > 0 ? 4 : 0;

      // Determine if successful
      isSuccess = status >= 200 && status < 300 || status === 304;

      // Get response data
      if ( responses ) {
        response = ajaxHandleResponses( s, jqXHR, responses );
      }

      // Convert no matter what (that way responseXXX fields are always set)
      response = ajaxConvert( s, response, jqXHR, isSuccess );

      // If successful, handle type chaining
      if ( isSuccess ) {

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
          modified = jqXHR.getResponseHeader("Last-Modified");
          if ( modified ) {
            jQuery.lastModified[ cacheURL ] = modified;
          }
          modified = jqXHR.getResponseHeader("etag");
          if ( modified ) {
            jQuery.etag[ cacheURL ] = modified;
          }
        }

        // if no content
        if ( status === 204 || s.type === "HEAD" ) {
          statusText = "nocontent";

        // if not modified
        } else if ( status === 304 ) {
          statusText = "notmodified";

        // If we have data, let's convert it
        } else {
          statusText = response.state;
          success = response.data;
          error = response.error;
          isSuccess = !error;
        }
      } else {
        // Extract error from statusText and normalize for non-aborts
        error = statusText;
        if ( status || !statusText ) {
          statusText = "error";
          if ( status < 0 ) {
            status = 0;
          }
        }
      }

      // Set data for the fake xhr object
      jqXHR.status = status;
      jqXHR.statusText = ( nativeStatusText || statusText ) + "";

      // Success/Error
      if ( isSuccess ) {
        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
      } else {
        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
      }

      // Status-dependent callbacks
      jqXHR.statusCode( statusCode );
      statusCode = undefined;

      if ( fireGlobals ) {
        globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
          [ jqXHR, s, isSuccess ? success : error ] );
      }

      // Complete
      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
        // Handle the global AJAX counter
        if ( !( --jQuery.active ) ) {
          jQuery.event.trigger("ajaxStop");
        }
      }
    }

    return jqXHR;
  },

  getJSON: function( url, data, callback ) {
    return jQuery.get( url, data, callback, "json" );
  },

  getScript: function( url, callback ) {
    return jQuery.get( url, undefined, callback, "script" );
  }
});

jQuery.each( [ "get", "post" ], function( i, method ) {
  jQuery[ method ] = function( url, data, callback, type ) {
    // Shift arguments if data argument was omitted
    if ( jQuery.isFunction( data ) ) {
      type = type || callback;
      callback = data;
      data = undefined;
    }

    return jQuery.ajax({
      url: url,
      type: method,
      dataType: type,
      data: data,
      success: callback
    });
  };
});


jQuery._evalUrl = function( url ) {
  return jQuery.ajax({
    url: url,
    type: "GET",
    dataType: "script",
    async: false,
    global: false,
    "throws": true
  });
};


jQuery.fn.extend({
  wrapAll: function( html ) {
    var wrap;

    if ( jQuery.isFunction( html ) ) {
      return this.each(function( i ) {
        jQuery( this ).wrapAll( html.call(this, i) );
      });
    }

    if ( this[ 0 ] ) {

      // The elements to wrap the target around
      wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

      if ( this[ 0 ].parentNode ) {
        wrap.insertBefore( this[ 0 ] );
      }

      wrap.map(function() {
        var elem = this;

        while ( elem.firstElementChild ) {
          elem = elem.firstElementChild;
        }

        return elem;
      }).append( this );
    }

    return this;
  },

  wrapInner: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function( i ) {
        jQuery( this ).wrapInner( html.call(this, i) );
      });
    }

    return this.each(function() {
      var self = jQuery( this ),
        contents = self.contents();

      if ( contents.length ) {
        contents.wrapAll( html );

      } else {
        self.append( html );
      }
    });
  },

  wrap: function( html ) {
    var isFunction = jQuery.isFunction( html );

    return this.each(function( i ) {
      jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
    });
  },

  unwrap: function() {
    return this.parent().each(function() {
      if ( !jQuery.nodeName( this, "body" ) ) {
        jQuery( this ).replaceWith( this.childNodes );
      }
    }).end();
  }
});


jQuery.expr.filters.hidden = function( elem ) {
  // Support: Opera <= 12.12
  // Opera reports offsetWidths and offsetHeights less than zero on some elements
  return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
  return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
  rbracket = /\[\]$/,
  rCRLF = /\r?\n/g,
  rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
  var name;

  if ( jQuery.isArray( obj ) ) {
    // Serialize array item.
    jQuery.each( obj, function( i, v ) {
      if ( traditional || rbracket.test( prefix ) ) {
        // Treat each array item as a scalar.
        add( prefix, v );

      } else {
        // Item is non-scalar (array or object), encode its numeric index.
        buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
      }
    });

  } else if ( !traditional && jQuery.type( obj ) === "object" ) {
    // Serialize object item.
    for ( name in obj ) {
      buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    }

  } else {
    // Serialize scalar item.
    add( prefix, obj );
  }
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
  var prefix,
    s = [],
    add = function( key, value ) {
      // If value is a function, invoke it and return its value
      value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
      s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
    };

  // Set traditional to true for jQuery <= 1.3.2 behavior.
  if ( traditional === undefined ) {
    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
  }

  // If an array was passed in, assume that it is an array of form elements.
  if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
    // Serialize the form elements
    jQuery.each( a, function() {
      add( this.name, this.value );
    });

  } else {
    // If traditional, encode the "old" way (the way 1.3.2 or older
    // did it), otherwise encode params recursively.
    for ( prefix in a ) {
      buildParams( prefix, a[ prefix ], traditional, add );
    }
  }

  // Return the resulting serialization
  return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
  serialize: function() {
    return jQuery.param( this.serializeArray() );
  },
  serializeArray: function() {
    return this.map(function() {
      // Can add propHook for "elements" to filter or add form elements
      var elements = jQuery.prop( this, "elements" );
      return elements ? jQuery.makeArray( elements ) : this;
    })
    .filter(function() {
      var type = this.type;

      // Use .is( ":disabled" ) so that fieldset[disabled] works
      return this.name && !jQuery( this ).is( ":disabled" ) &&
        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
        ( this.checked || !rcheckableType.test( type ) );
    })
    .map(function( i, elem ) {
      var val = jQuery( this ).val();

      return val == null ?
        null :
        jQuery.isArray( val ) ?
          jQuery.map( val, function( val ) {
            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          }) :
          { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    }).get();
  }
});


jQuery.ajaxSettings.xhr = function() {
  try {
    return new XMLHttpRequest();
  } catch( e ) {}
};

var xhrId = 0,
  xhrCallbacks = {},
  xhrSuccessStatus = {
    // file protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE9
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
  xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
  window.attachEvent( "onunload", function() {
    for ( var key in xhrCallbacks ) {
      xhrCallbacks[ key ]();
    }
  });
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
  var callback;

  // Cross domain only allowed if supported through XMLHttpRequest
  if ( support.cors || xhrSupported && !options.crossDomain ) {
    return {
      send: function( headers, complete ) {
        var i,
          xhr = options.xhr(),
          id = ++xhrId;

        xhr.open( options.type, options.url, options.async, options.username, options.password );

        // Apply custom fields if provided
        if ( options.xhrFields ) {
          for ( i in options.xhrFields ) {
            xhr[ i ] = options.xhrFields[ i ];
          }
        }

        // Override mime type if needed
        if ( options.mimeType && xhr.overrideMimeType ) {
          xhr.overrideMimeType( options.mimeType );
        }

        // X-Requested-With header
        // For cross-domain requests, seeing as conditions for a preflight are
        // akin to a jigsaw puzzle, we simply never set it to be sure.
        // (it can always be set on a per-request basis or even using ajaxSetup)
        // For same-domain requests, won't change header if already provided.
        if ( !options.crossDomain && !headers["X-Requested-With"] ) {
          headers["X-Requested-With"] = "XMLHttpRequest";
        }

        // Set headers
        for ( i in headers ) {
          xhr.setRequestHeader( i, headers[ i ] );
        }

        // Callback
        callback = function( type ) {
          return function() {
            if ( callback ) {
              delete xhrCallbacks[ id ];
              callback = xhr.onload = xhr.onerror = null;

              if ( type === "abort" ) {
                xhr.abort();
              } else if ( type === "error" ) {
                complete(
                  // file: protocol always yields status 0; see #8605, #14207
                  xhr.status,
                  xhr.statusText
                );
              } else {
                complete(
                  xhrSuccessStatus[ xhr.status ] || xhr.status,
                  xhr.statusText,
                  // Support: IE9
                  // Accessing binary-data responseText throws an exception
                  // (#11426)
                  typeof xhr.responseText === "string" ? {
                    text: xhr.responseText
                  } : undefined,
                  xhr.getAllResponseHeaders()
                );
              }
            }
          };
        };

        // Listen to events
        xhr.onload = callback();
        xhr.onerror = callback("error");

        // Create the abort callback
        callback = xhrCallbacks[ id ] = callback("abort");

        try {
          // Do send the request (this may raise an exception)
          xhr.send( options.hasContent && options.data || null );
        } catch ( e ) {
          // #14683: Only rethrow if this hasn't been notified as an error yet
          if ( callback ) {
            throw e;
          }
        }
      },

      abort: function() {
        if ( callback ) {
          callback();
        }
      }
    };
  }
});




// Install script dataType
jQuery.ajaxSetup({
  accepts: {
    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
  },
  contents: {
    script: /(?:java|ecma)script/
  },
  converters: {
    "text script": function( text ) {
      jQuery.globalEval( text );
      return text;
    }
  }
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
  if ( s.cache === undefined ) {
    s.cache = false;
  }
  if ( s.crossDomain ) {
    s.type = "GET";
  }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
  // This transport only deals with cross domain requests
  if ( s.crossDomain ) {
    var script, callback;
    return {
      send: function( _, complete ) {
        script = jQuery("<script>").prop({
          async: true,
          charset: s.scriptCharset,
          src: s.url
        }).on(
          "load error",
          callback = function( evt ) {
            script.remove();
            callback = null;
            if ( evt ) {
              complete( evt.type === "error" ? 404 : 200, evt.type );
            }
          }
        );
        document.head.appendChild( script[ 0 ] );
      },
      abort: function() {
        if ( callback ) {
          callback();
        }
      }
    };
  }
});




var oldCallbacks = [],
  rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
  jsonp: "callback",
  jsonpCallback: function() {
    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
    this[ callback ] = true;
    return callback;
  }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  var callbackName, overwritten, responseContainer,
    jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
      "url" :
      typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
    );

  // Handle iff the expected data type is "jsonp" or we have a parameter to set
  if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

    // Get callback name, remembering preexisting value associated with it
    callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
      s.jsonpCallback() :
      s.jsonpCallback;

    // Insert callback into url or form data
    if ( jsonProp ) {
      s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
    } else if ( s.jsonp !== false ) {
      s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
    }

    // Use data converter to retrieve json after script execution
    s.converters["script json"] = function() {
      if ( !responseContainer ) {
        jQuery.error( callbackName + " was not called" );
      }
      return responseContainer[ 0 ];
    };

    // force json dataType
    s.dataTypes[ 0 ] = "json";

    // Install callback
    overwritten = window[ callbackName ];
    window[ callbackName ] = function() {
      responseContainer = arguments;
    };

    // Clean-up function (fires after converters)
    jqXHR.always(function() {
      // Restore preexisting value
      window[ callbackName ] = overwritten;

      // Save back as free
      if ( s[ callbackName ] ) {
        // make sure that re-using the options doesn't screw things around
        s.jsonpCallback = originalSettings.jsonpCallback;

        // save the callback name for future use
        oldCallbacks.push( callbackName );
      }

      // Call if it was a function and we have a response
      if ( responseContainer && jQuery.isFunction( overwritten ) ) {
        overwritten( responseContainer[ 0 ] );
      }

      responseContainer = overwritten = undefined;
    });

    // Delegate to script
    return "script";
  }
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
  if ( !data || typeof data !== "string" ) {
    return null;
  }
  if ( typeof context === "boolean" ) {
    keepScripts = context;
    context = false;
  }
  context = context || document;

  var parsed = rsingleTag.exec( data ),
    scripts = !keepScripts && [];

  // Single tag
  if ( parsed ) {
    return [ context.createElement( parsed[1] ) ];
  }

  parsed = jQuery.buildFragment( [ data ], context, scripts );

  if ( scripts && scripts.length ) {
    jQuery( scripts ).remove();
  }

  return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
  if ( typeof url !== "string" && _load ) {
    return _load.apply( this, arguments );
  }

  var selector, type, response,
    self = this,
    off = url.indexOf(" ");

  if ( off >= 0 ) {
    selector = jQuery.trim( url.slice( off ) );
    url = url.slice( 0, off );
  }

  // If it's a function
  if ( jQuery.isFunction( params ) ) {

    // We assume that it's the callback
    callback = params;
    params = undefined;

  // Otherwise, build a param string
  } else if ( params && typeof params === "object" ) {
    type = "POST";
  }

  // If we have elements to modify, make the request
  if ( self.length > 0 ) {
    jQuery.ajax({
      url: url,

      // if "type" variable is undefined, then "GET" method will be used
      type: type,
      dataType: "html",
      data: params
    }).done(function( responseText ) {

      // Save response for use in complete callback
      response = arguments;

      self.html( selector ?

        // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

        // Otherwise use the full result
        responseText );

    }).complete( callback && function( jqXHR, status ) {
      self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
    });
  }

  return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
  jQuery.fn[ type ] = function( fn ) {
    return this.on( type, fn );
  };
});




jQuery.expr.filters.animated = function( elem ) {
  return jQuery.grep(jQuery.timers, function( fn ) {
    return elem === fn.elem;
  }).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
  return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
  setOffset: function( elem, options, i ) {
    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
      position = jQuery.css( elem, "position" ),
      curElem = jQuery( elem ),
      props = {};

    // Set position first, in-case top/left are set even on static elem
    if ( position === "static" ) {
      elem.style.position = "relative";
    }

    curOffset = curElem.offset();
    curCSSTop = jQuery.css( elem, "top" );
    curCSSLeft = jQuery.css( elem, "left" );
    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
      ( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

    // Need to be able to calculate position if either
    // top or left is auto and position is either absolute or fixed
    if ( calculatePosition ) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;

    } else {
      curTop = parseFloat( curCSSTop ) || 0;
      curLeft = parseFloat( curCSSLeft ) || 0;
    }

    if ( jQuery.isFunction( options ) ) {
      options = options.call( elem, i, curOffset );
    }

    if ( options.top != null ) {
      props.top = ( options.top - curOffset.top ) + curTop;
    }
    if ( options.left != null ) {
      props.left = ( options.left - curOffset.left ) + curLeft;
    }

    if ( "using" in options ) {
      options.using.call( elem, props );

    } else {
      curElem.css( props );
    }
  }
};

jQuery.fn.extend({
  offset: function( options ) {
    if ( arguments.length ) {
      return options === undefined ?
        this :
        this.each(function( i ) {
          jQuery.offset.setOffset( this, options, i );
        });
    }

    var docElem, win,
      elem = this[ 0 ],
      box = { top: 0, left: 0 },
      doc = elem && elem.ownerDocument;

    if ( !doc ) {
      return;
    }

    docElem = doc.documentElement;

    // Make sure it's not a disconnected DOM node
    if ( !jQuery.contains( docElem, elem ) ) {
      return box;
    }

    // Support: BlackBerry 5, iOS 3 (original iPhone)
    // If we don't have gBCR, just use 0,0 rather than error
    if ( typeof elem.getBoundingClientRect !== strundefined ) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow( doc );
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  },

  position: function() {
    if ( !this[ 0 ] ) {
      return;
    }

    var offsetParent, offset,
      elem = this[ 0 ],
      parentOffset = { top: 0, left: 0 };

    // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
    if ( jQuery.css( elem, "position" ) === "fixed" ) {
      // Assume getBoundingClientRect is there when computed position is fixed
      offset = elem.getBoundingClientRect();

    } else {
      // Get *real* offsetParent
      offsetParent = this.offsetParent();

      // Get correct offsets
      offset = this.offset();
      if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
        parentOffset = offsetParent.offset();
      }

      // Add offsetParent borders
      parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
      parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
    }

    // Subtract parent offsets and element margins
    return {
      top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
      left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
    };
  },

  offsetParent: function() {
    return this.map(function() {
      var offsetParent = this.offsetParent || docElem;

      while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
        offsetParent = offsetParent.offsetParent;
      }

      return offsetParent || docElem;
    });
  }
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  var top = "pageYOffset" === prop;

  jQuery.fn[ method ] = function( val ) {
    return access( this, function( elem, method, val ) {
      var win = getWindow( elem );

      if ( val === undefined ) {
        return win ? win[ prop ] : elem[ method ];
      }

      if ( win ) {
        win.scrollTo(
          !top ? val : window.pageXOffset,
          top ? val : window.pageYOffset
        );

      } else {
        elem[ method ] = val;
      }
    }, method, val, arguments.length, null );
  };
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
  jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
    function( elem, computed ) {
      if ( computed ) {
        computed = curCSS( elem, prop );
        // If curCSS returns percentage, fallback to offset
        return rnumnonpx.test( computed ) ?
          jQuery( elem ).position()[ prop ] + "px" :
          computed;
      }
    }
  );
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
    // Margin is only for outerHeight, outerWidth
    jQuery.fn[ funcName ] = function( margin, value ) {
      var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

      return access( this, function( elem, type, value ) {
        var doc;

        if ( jQuery.isWindow( elem ) ) {
          // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
          // isn't a whole lot we can do. See pull request at this URL for discussion:
          // https://github.com/jquery/jquery/pull/764
          return elem.document.documentElement[ "client" + name ];
        }

        // Get document width or height
        if ( elem.nodeType === 9 ) {
          doc = elem.documentElement;

          // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
          // whichever is greatest
          return Math.max(
            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
            elem.body[ "offset" + name ], doc[ "offset" + name ],
            doc[ "client" + name ]
          );
        }

        return value === undefined ?
          // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css( elem, type, extra ) :

          // Set width or height on the element
          jQuery.style( elem, type, value, extra );
      }, type, chainable ? margin : undefined, chainable, null );
    };
  });
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
  return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
  define( "jquery", [], function() {
    return jQuery;
  });
}




var
  // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,

  // Map over the $ in case of overwrite
  _$ = window.$;

jQuery.noConflict = function( deep ) {
  if ( window.$ === jQuery ) {
    window.$ = _$;
  }

  if ( deep && window.jQuery === jQuery ) {
    window.jQuery = _jQuery;
  }

  return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
  window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  //use the faster Date.now if available.
  var getTime = (Date.now || function() {
    return new Date().getTime();
  });

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = value == null ? _.identity : lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : getTime();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = getTime();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = getTime();
      var later = function() {
        var last = getTime() - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

//vjs.Component.prototype.dispose
// 为了减少体积，移除了字幕组件
// 修改了一处代码:line to 1630
/**
 * @fileoverview Main function src.
 */

// HTML5 Shiv. Must be in <head> to support older browsers.
document.createElement('video');
document.createElement('audio');
//document.createElement('track');

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 *
 * **ALIASES** videojs, _V_ (deprecated)
 *
 * The `vjs` function can be used to initialize or retrieve a player.
 *
 *     var myPlayer = vjs('my_video_id');
 *
 * @param  {String|Element} id      Video element or video element ID
 * @param  {Object=} options        Optional options object for config/settings
 * @param  {Function=} ready        Optional ready callback
 * @return {vjs.Player}             A player instance
 * @namespace
 */
var vjs = function(id, options, ready){
  var tag; // Element of ID

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (vjs.players[id]) {
      return vjs.players[id];

    // Otherwise get element for ID
    } else {
      tag = vjs.el(id);
    }

  // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  if (!tag || !tag.nodeName) { // re: nodeName, could be a box div also
    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
  }

  // Element may have a player attr referring to an already created player instance.
  // If not, set up a new player and return the instance.
  return tag['player'] || new vjs.Player(tag, options, ready);
};

// Extended name, also available externally, window.videojs
var videojs = window['videojs'] = vjs;

// CDN Version. Used to target right flash swf.
vjs.CDN_VERSION = '4.10';
vjs.ACCESS_PROTOCOL = ('https:' == document.location.protocol ? 'https://' : 'http://');

/**
 * Global Player instance options, surfaced from vjs.Player.prototype.options_
 * vjs.options = vjs.Player.prototype.options_
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 */
vjs.options = {
  // Default order of fallback technology
  'techOrder': ['html5','flash'],
  // techOrder: ['flash','html5'],

  'html5': {},
  'flash': {},

  // Default of web browser is 300x150. Should rely on source width/height.
  'width': 300,
  'height': 150,
  // defaultVolume: 0.85,
  'defaultVolume': 0.00, // The freakin seaguls are driving me crazy!

  // default playback rates
  //'playbackRates': [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // default inactivity timeout
  'inactivityTimeout': 2000,

  // Included control sets
  'children': {
    'mediaLoader': {},
    'loadingSpinner': {},
    'controlBar': {},
    'errorDisplay': {}
  },

  'language': document.getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

  // locales and their language translations
  'languages': {},

  // Default message to show when a video cannot be played.
  'notSupportedMessage': 'No compatible source was found for this video.'
};

// Set CDN Version of swf
// The added (+) blocks the replace from changing this 4.10 string
if (vjs.CDN_VERSION !== 'GENERATED'+'_CDN_VSN') {
  videojs.options['flash']['swf'] = vjs.ACCESS_PROTOCOL + 'vjs.zencdn.net/'+vjs.CDN_VERSION+'/video-js.swf';
}

/**
 * Utility function for adding languages to the default options. Useful for
 * amending multiple language support at runtime.
 *
 * Example: vjs.addLanguage('es', {'Hello':'Hola'});
 *
 * @param  {String} code The language code or dictionary property
 * @param  {Object} data The data values to be translated
 * @return {Object} The resulting global languages dictionary object
 */
vjs.addLanguage = function(code, data){
  if(vjs.options['languages'][code] !== undefined) {
    vjs.options['languages'][code] = vjs.util.mergeOptions(vjs.options['languages'][code], data);
  } else {
    vjs.options['languages'][code] = data;
  }
  return vjs.options['languages'];
};

/**
 * Global player list
 * @type {Object}
 */
vjs.players = {};

/**
 * Core Object/Class for objects that use inheritance + contstructors
 *
 * To create a class that can be subclassed itself, extend the CoreObject class.
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * The constructor can be defined through the init property of an object argument.
 *
 *     var Animal = CoreObject.extend({
 *       init: function(name, sound){
 *         this.name = name;
 *       }
 *     });
 *
 * Other methods and properties can be added the same way, or directly to the
 * prototype.
 *
 *    var Animal = CoreObject.extend({
 *       init: function(name){
 *         this.name = name;
 *       },
 *       getName: function(){
 *         return this.name;
 *       },
 *       sound: '...'
 *    });
 *
 *    Animal.prototype.makeSound = function(){
 *      alert(this.sound);
 *    };
 *
 * To create an instance of a class, use the create method.
 *
 *    var fluffy = Animal.create('Fluffy');
 *    fluffy.getName(); // -> Fluffy
 *
 * Methods and properties can be overridden in subclasses.
 *
 *     var Horse = Animal.extend({
 *       sound: 'Neighhhhh!'
 *     });
 *
 *     var horsey = Horse.create('Horsey');
 *     horsey.getName(); // -> Horsey
 *     horsey.makeSound(); // -> Alert: Neighhhhh!
 *
 * @class
 * @constructor
 */
vjs.CoreObject = vjs['CoreObject'] = function(){};
// Manually exporting vjs['CoreObject'] here for Closure Compiler
// because of the use of the extend/create class methods
// If we didn't do this, those functions would get flattend to something like
// `a = ...` and `this.prototype` would refer to the global object instead of
// CoreObject

/**
 * Create a new object that inherits from this Object
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * @param {Object} props Functions and properties to be applied to the
 *                       new object's prototype
 * @return {vjs.CoreObject} An object that inherits from CoreObject
 * @this {*}
 */
vjs.CoreObject.extend = function(props){
  var init, subObj;

  props = props || {};
  // Set up the constructor using the supplied init method
  // or using the init of the parent object
  // Make sure to check the unobfuscated version for external libs
  init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function(){};
  // In Resig's simple class inheritance (previously used) the constructor
  //  is a function that calls `this.init.apply(arguments)`
  // However that would prevent us from using `ParentObject.call(this);`
  //  in a Child constuctor because the `this` in `this.init`
  //  would still refer to the Child and cause an inifinite loop.
  // We would instead have to do
  //    `ParentObject.prototype.init.apply(this, argumnents);`
  //  Bleh. We're not creating a _super() function, so it's good to keep
  //  the parent constructor reference simple.
  subObj = function(){
    init.apply(this, arguments);
  };

  // Inherit from this object's prototype
  subObj.prototype = vjs.obj.create(this.prototype);
  // Reset the constructor property for subObj otherwise
  // instances of subObj would have the constructor of the parent Object
  subObj.prototype.constructor = subObj;

  // Make the class extendable
  subObj.extend = vjs.CoreObject.extend;
  // Make a function for creating instances
  subObj.create = vjs.CoreObject.create;

  // Extend subObj's prototype with functions and other properties from props
  for (var name in props) {
    if (props.hasOwnProperty(name)) {
      subObj.prototype[name] = props[name];
    }
  }

  return subObj;
};

/**
 * Create a new instace of this Object class
 *
 *     var myAnimal = Animal.create();
 *
 * @return {vjs.CoreObject} An instance of a CoreObject subclass
 * @this {*}
 */
vjs.CoreObject.create = function(){
  // Create a new object that inherits from this object's prototype
  var inst = vjs.obj.create(this.prototype);

  // Apply this constructor function to the new object
  this.apply(inst, arguments);

  // Return the new object
  return inst;
};
/**
 * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 */

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 * @param  {Element|Object}   elem Element or object to bind listeners to
 * @param  {String|Array}   type Type of event to bind to.
 * @param  {Function} fn   Event listener.
 * @private
 */
vjs.on = function(elem, type, fn){
  if (vjs.obj.isArray(type)) {
    return _handleMultipleEvents(vjs.on, elem, type, fn);
  }

  var data = vjs.getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) data.handlers = {};

  if (!data.handlers[type]) data.handlers[type] = [];

  if (!fn.guid) fn.guid = vjs.guid++;

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event){

      if (data.disabled) return;
      event = vjs.fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            handlersCopy[m].call(elem, event);
          }
        }
      }
    };
  }

  if (data.handlers[type].length == 1) {
    if (elem.addEventListener) {
      elem.addEventListener(type, data.dispatcher, false);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
};

/**
 * Removes event listeners from an element
 * @param  {Element|Object}   elem Object to remove listeners from
 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
 * @private
 */
vjs.off = function(elem, type, fn) {
  // Don't want to add a cache object through getData if not needed
  if (!vjs.hasData(elem)) return;

  var data = vjs.getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) { return; }

  if (vjs.obj.isArray(type)) {
    return _handleMultipleEvents(vjs.off, elem, type, fn);
  }

  // Utility function
  var removeType = function(t){
     data.handlers[t] = [];
     vjs.cleanUpEvents(elem,t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) removeType(t);
    return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) return;

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  vjs.cleanUpEvents(elem, type);
};

/**
 * Clean up the listener cache and dispatchers
 * @param  {Element|Object} elem Element to clean up
 * @param  {String} type Type of event to clean up
 * @private
 */
vjs.cleanUpEvents = function(elem, type) {
  var data = vjs.getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (vjs.isEmpty(data.handlers)) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;

    // data.handlers = null;
    // data.dispatcher = null;
    // data.disabled = null;
  }

  // Finally remove the expando if there is no data left
  if (vjs.isEmpty(data)) {
    vjs.removeData(elem);
  }
};

/**
 * Fix a native event to have standard property values
 * @param  {Object} event Event object to fix
 * @return {Object}
 * @private
 */
vjs.fixEvent = function(event) {

  function returnTrue() { return true; }
  function returnFalse() { return false; }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || window.event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key == 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document;
    }

    // Handle which other element the event is related to
    event.relatedTarget = event.fromElement === event.target ?
      event.toElement :
      event.fromElement;

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      event.isDefaultPrevented = returnTrue;
      event.defaultPrevented = true;
    };

    event.isDefaultPrevented = returnFalse;
    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX != null) {
      var doc = document.documentElement, body = document.body;

      event.pageX = event.clientX +
        (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
        (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY +
        (doc && doc.scrollTop || body && body.scrollTop || 0) -
        (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button != null) {
      event.button = (event.button & 1 ? 0 :
        (event.button & 4 ? 1 :
          (event.button & 2 ? 2 : 0)));
    }
  }

  // Returns fixed-up instance
  return event;
};

/**
 * Trigger an event for an element
 * @param  {Element|Object}      elem  Element to trigger an event on
 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
 * @private
 */
vjs.trigger = function(elem, event) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasData first.
  var elemData = (vjs.hasData(elem)) ? vjs.getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
      // type = event.type || event,
      // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type:event, target:elem };
  }
  // Normalizes the event properties.
  event = vjs.fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
    // recursively calls this function to bubble the event up the DOM.
    if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
    vjs.trigger(parent, event);

  // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = vjs.getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
  /* Original version of js ninja events wasn't complete.
   * We've since updated to the latest version, but keeping this around
   * for now just in case.
   */
  // // Added in attion to book. Book code was broke.
  // event = typeof event === 'object' ?
  //   event[vjs.expando] ?
  //     event :
  //     new vjs.Event(type, event) :
  //   new vjs.Event(type);

  // event.type = type;
  // if (handler) {
  //   handler.call(elem, event);
  // }

  // // Clean up the event in case it is being reused
  // event.result = undefined;
  // event.target = elem;
};

/**
 * Trigger a listener only once for an event
 * @param  {Element|Object}   elem Element or object to
 * @param  {String|Array}   type
 * @param  {Function} fn
 * @private
 */
vjs.one = function(elem, type, fn) {
  if (vjs.obj.isArray(type)) {
    return _handleMultipleEvents(vjs.one, elem, type, fn);
  }
  var func = function(){
    vjs.off(elem, type, func);
    fn.apply(this, arguments);
  };
  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || vjs.guid++;
  vjs.on(elem, type, func);
};

/**
 * Loops through an array of event types and calls the requested method for each type.
 * @param  {Function} fn   The event method we want to use.
 * @param  {Element|Object} elem Element or object to bind listeners to
 * @param  {String}   type Type of event to bind to.
 * @param  {Function} callback   Event listener.
 * @private
 */
function _handleMultipleEvents(fn, elem, type, callback) {
  vjs.arr.forEach(type, function(type) {
    fn(elem, type, callback); //Call the event method for each one of the types
  });
}
var hasOwnProp = Object.prototype.hasOwnProperty;

/**
 * Creates an element and applies properties.
 * @param  {String=} tagName    Name of tag to be created.
 * @param  {Object=} properties Element properties to be applied.
 * @return {Element}
 * @private
 */
vjs.createEl = function(tagName, properties){
  var el;

  tagName = tagName || 'div';
  properties = properties || {};

  el = document.createElement(tagName);

  vjs.obj.each(properties, function(propName, val){
    // Not remembering why we were checking for dash
    // but using setAttribute means you have to use getAttribute

    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
    // The additional check for "role" is because the default method for adding attributes does not
    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
    if (propName.indexOf('aria-') !== -1 || propName == 'role') {
     el.setAttribute(propName, val);
    } else {
     el[propName] = val;
    }
  });

  return el;
};

/**
 * Uppercase the first letter of a string
 * @param  {String} string String to be uppercased
 * @return {String}
 * @private
 */
vjs.capitalize = function(string){
  return string.charAt(0).toUpperCase() + string.slice(1);
};

/**
 * Object functions container
 * @type {Object}
 * @private
 */
vjs.obj = {};

/**
 * Object.create shim for prototypal inheritance
 *
 * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
 *
 * @function
 * @param  {Object}   obj Object to use as prototype
 * @private
 */
vjs.obj.create = Object.create || function(obj){
  //Create a new function called 'F' which is just an empty object.
  function F() {}

  //the prototype of the 'F' function should point to the
  //parameter of the anonymous function.
  F.prototype = obj;

  //create a new constructor function based off of the 'F' function.
  return new F();
};

/**
 * Loop through each property in an object and call a function
 * whose arguments are (key,value)
 * @param  {Object}   obj Object of properties
 * @param  {Function} fn  Function to be called on each property.
 * @this {*}
 * @private
 */
vjs.obj.each = function(obj, fn, context){
  for (var key in obj) {
    if (hasOwnProp.call(obj, key)) {
      fn.call(context || this, key, obj[key]);
    }
  }
};

/**
 * Merge two objects together and return the original.
 * @param  {Object} obj1
 * @param  {Object} obj2
 * @return {Object}
 * @private
 */
vjs.obj.merge = function(obj1, obj2){
  if (!obj2) { return obj1; }
  for (var key in obj2){
    if (hasOwnProp.call(obj2, key)) {
      obj1[key] = obj2[key];
    }
  }
  return obj1;
};

/**
 * Merge two objects, and merge any properties that are objects
 * instead of just overwriting one. Uses to merge options hashes
 * where deeper default settings are important.
 * @param  {Object} obj1 Object to override
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object. Obj1 and Obj2 will be untouched.
 * @private
 */
vjs.obj.deepMerge = function(obj1, obj2){
  var key, val1, val2;

  // make a copy of obj1 so we're not ovewriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = vjs.obj.copy(obj1);

  for (key in obj2){
    if (hasOwnProp.call(obj2, key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
        obj1[key] = vjs.obj.deepMerge(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
};

/**
 * Make a copy of the supplied object
 * @param  {Object} obj Object to copy
 * @return {Object}     Copy of object
 * @private
 */
vjs.obj.copy = function(obj){
  return vjs.obj.merge({}, obj);
};

/**
 * Check if an object is plain, and not a dom node or any object sub-instance
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
vjs.obj.isPlain = function(obj){
  return !!obj
    && typeof obj === 'object'
    && obj.toString() === '[object Object]'
    && obj.constructor === Object;
};

/**
 * Check if an object is Array
*  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
vjs.obj.isArray = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
};

/**
 * Check to see whether the input is NaN or not.
 * NaN is the only JavaScript construct that isn't equal to itself
 * @param {Number} num Number to check
 * @return {Boolean} True if NaN, false otherwise
 * @private
 */
vjs.isNaN = function(num) {
  return num !== num;
};

/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
   It also stores a unique id on the function so it can be easily removed from events
 * @param  {*}   context The object to bind as scope
 * @param  {Function} fn      The function to be bound to a scope
 * @param  {Number=}   uid     An optional unique ID for the function to be set
 * @return {Function}
 * @private
 */
vjs.bind = function(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) { fn.guid = vjs.guid++; }

  // Create the new function that changes the context
  var ret = function() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  ret.guid = (uid) ? uid + '_' + fn.guid : fn.guid;

  return ret;
};

/**
 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
 * Ex. Event listneres are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 * @type {Object}
 * @private
 */
vjs.cache = {};

/**
 * Unique ID for an element or function
 * @type {Number}
 * @private
 */
vjs.guid = 1;

/**
 * Unique attribute name to store an element's guid in
 * @type {String}
 * @constant
 * @private
 */
vjs.expando = 'vdata' + (new Date()).getTime();

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
vjs.getData = function(el){
  var id = el[vjs.expando];
  if (!id) {
    id = el[vjs.expando] = vjs.guid++;
    vjs.cache[id] = {};
  }
  return vjs.cache[id];
};

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
vjs.hasData = function(el){
  var id = el[vjs.expando];
  return !(!id || vjs.isEmpty(vjs.cache[id]));
};

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 * @param  {Element} el Remove data for an element
 * @private
 */
vjs.removeData = function(el){
  var id = el[vjs.expando];
  if (!id) { return; }
  // Remove all stored data
  // Changed to = null
  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
  // vjs.cache[id] = null;
  delete vjs.cache[id];

  // Remove the expando property from the DOM node
  try {
    delete el[vjs.expando];
  } catch(e) {
    if (el.removeAttribute) {
      el.removeAttribute(vjs.expando);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[vjs.expando] = null;
    }
  }
};

/**
 * Check if an object is empty
 * @param  {Object}  obj The object to check for emptiness
 * @return {Boolean}
 * @private
 */
vjs.isEmpty = function(obj) {
  for (var prop in obj) {
    // Inlude null properties as empty.
    if (obj[prop] !== null) {
      return false;
    }
  }
  return true;
};

/**
 * Check if an element has a CSS class
 * @param {Element} element Element to check
 * @param {String} classToCheck Classname to check
 * @private
 */
vjs.hasClass = function(element, classToCheck){
  return ((' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1);
};


/**
 * Add a CSS class name to an element
 * @param {Element} element    Element to add class name to
 * @param {String} classToAdd Classname to add
 * @private
 */
vjs.addClass = function(element, classToAdd){
  if (!vjs.hasClass(element, classToAdd)) {
    element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
  }
};

/**
 * Remove a CSS class name from an element
 * @param {Element} element    Element to remove from class name
 * @param {String} classToAdd Classname to remove
 * @private
 */
vjs.removeClass = function(element, classToRemove){
  var classNames, i;

  if (!vjs.hasClass(element, classToRemove)) {return;}

  classNames = element.className.split(' ');

  // no arr.indexOf in ie8, and we don't want to add a big shim
  for (i = classNames.length - 1; i >= 0; i--) {
    if (classNames[i] === classToRemove) {
      classNames.splice(i,1);
    }
  }

  element.className = classNames.join(' ');
};

/**
 * Element for testing browser HTML5 video capabilities
 * @type {Element}
 * @constant
 * @private
 */
vjs.TEST_VID = vjs.createEl('video');

/**
 * Useragent for browser testing.
 * @type {String}
 * @constant
 * @private
 */
vjs.USER_AGENT = navigator.userAgent;

/**
 * Device is an iPhone
 * @type {Boolean}
 * @constant
 * @private
 */
vjs.IS_IPHONE = (/iPhone/i).test(vjs.USER_AGENT);
vjs.IS_IPAD = (/iPad/i).test(vjs.USER_AGENT);
vjs.IS_IPOD = (/iPod/i).test(vjs.USER_AGENT);
vjs.IS_IOS = vjs.IS_IPHONE || vjs.IS_IPAD || vjs.IS_IPOD;

vjs.IOS_VERSION = (function(){
  var match = vjs.USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) { return match[1]; }
})();

vjs.IS_ANDROID = (/Android/i).test(vjs.USER_AGENT);
vjs.ANDROID_VERSION = (function() {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = vjs.USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
    major,
    minor;

  if (!match) {
    return null;
  }

  major = match[1] && parseFloat(match[1]);
  minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  } else {
    return null;
  }
})();
// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
vjs.IS_OLD_ANDROID = vjs.IS_ANDROID && (/webkit/i).test(vjs.USER_AGENT) && vjs.ANDROID_VERSION < 2.3;

vjs.IS_FIREFOX = (/Firefox/i).test(vjs.USER_AGENT);
vjs.IS_CHROME = (/Chrome/i).test(vjs.USER_AGENT);

vjs.TOUCH_ENABLED = !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch);
vjs.BACKGROUND_SIZE_SUPPORTED = 'backgroundSize' in vjs.TEST_VID.style;

/**
 * Apply attributes to an HTML element.
 * @param  {Element} el         Target element.
 * @param  {Object=} attributes Element attributes to be applied.
 * @private
 */
vjs.setElementAttributes = function(el, attributes){
  vjs.obj.each(attributes, function(attrName, attrValue) {
    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, (attrValue === true ? '' : attrValue));
    }
  });
};

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributs are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 * @param  {Element} tag Element from which to get tag attributes
 * @return {Object}
 * @private
 */
vjs.getElementAttributes = function(tag){
  var obj, knownBooleans, attrs, attrName, attrVal;

  obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  knownBooleans = ','+'autoplay,controls,loop,muted,default'+',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      attrName = attrs[i].name;
      attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(','+attrName+',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = (attrVal !== null) ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
};

/**
 * Get the computed style value for an element
 * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
 * @param  {Element} el        Element to get style value for
 * @param  {String} strCssRule Style name
 * @return {String}            Style value
 * @private
 */
vjs.getComputedDimension = function(el, strCssRule){
  var strValue = '';
  if(document.defaultView && document.defaultView.getComputedStyle){
    strValue = document.defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);

  } else if(el.currentStyle){
    // IE8 Width/Height support
    strValue = el['client'+strCssRule.substr(0,1).toUpperCase() + strCssRule.substr(1)] + 'px';
  }
  return strValue;
};

/**
 * Insert an element as the first child node of another
 * @param  {Element} child   Element to insert
 * @param  {[type]} parent Element to insert child into
 * @private
 */
vjs.insertFirst = function(child, parent){
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
};

/**
 * Object to hold browser support information
 * @type {Object}
 * @private
 */
vjs.browser = {};

/**
 * Shorthand for document.getElementById()
 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
 * @param  {String} id  Element ID
 * @return {Element}    Element with supplied ID
 * @private
 */
vjs.el = function(id){
  if (id.indexOf('#') === 0) {
    id = id.slice(1);
  }

  return document.getElementById(id);
};

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 * @param  {Number} seconds Number of seconds to be turned into a string
 * @param  {Number} guide   Number (in seconds) to model the string after
 * @return {String}         Time formatted as H:MM:SS or M:SS
 * @private
 */
vjs.formatTime = function(seconds, guide) {
  // Default to using seconds as guide
  guide = guide || seconds;
  var s = Math.floor(seconds % 60),
      m = Math.floor(seconds / 60 % 60),
      h = Math.floor(seconds / 3600),
      gm = Math.floor(guide / 60 % 60),
      gh = Math.floor(guide / 3600);

  // handle invalid times
  if (isNaN(seconds) || seconds === Infinity) {
    // '-' is false for all relational operators (e.g. <, >=) so this setting
    // will add the minimum number of fields specified by the guide
    h = m = s = '-';
  }

  // Check if we need to show hours
  h = (h > 0 || gh > 0) ? h + ':' : '';

  // If hours are showing, we may need to add a leading zero.
  // Always show at least one digit of minutes.
  m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';

  // Check if leading zero is need for seconds
  s = (s < 10) ? '0' + s : s;

  return h + m + s;
};

// Attempt to block the ability to select text while dragging controls
vjs.blockTextSelection = function(){
  document.body.focus();
  document.onselectstart = function () { return false; };
};
// Turn off text selection blocking
vjs.unblockTextSelection = function(){ document.onselectstart = function () { return true; }; };

/**
 * Trim whitespace from the ends of a string.
 * @param  {String} string String to trim
 * @return {String}        Trimmed string
 * @private
 */
vjs.trim = function(str){
  return (str+'').replace(/^\s+|\s+$/g, '');
};

/**
 * Should round off a number to a decimal place
 * @param  {Number} num Number to round
 * @param  {Number} dec Number of decimal places to round to
 * @return {Number}     Rounded number
 * @private
 */
vjs.round = function(num, dec) {
  if (!dec) { dec = 0; }
  return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
};

/**
 * Should create a fake TimeRange object
 * Mimics an HTML5 time range instance, which has functions that
 * return the start and end times for a range
 * TimeRanges are returned by the buffered() method
 * @param  {Number} start Start time in seconds
 * @param  {Number} end   End time in seconds
 * @return {Object}       Fake TimeRange object
 * @private
 */
vjs.createTimeRange = function(start, end){
  return {
    length: 1,
    start: function() { return start; },
    end: function() { return end; }
  };
};


/**
 * Add to local storage (may removeable)
 * @private
 */
vjs.setLocalStorage = function(key, value){
  try {
    // IE was throwing errors referencing the var anywhere without this
    var localStorage = window.localStorage || false;
    if (!localStorage) { return; }
    localStorage[key] = value;
  } catch(e) {
    if (e.code == 22 || e.code == 1014) { // Webkit == 22 / Firefox == 1014
      vjs.log('LocalStorage Full (VideoJS)', e);
    } else {
      if (e.code == 18) {
        vjs.log('LocalStorage not allowed (VideoJS)', e);
      } else {
        vjs.log('LocalStorage Error (VideoJS)', e);
      }
    }
  }
};

/**
 * Get abosolute version of relative URL. Used to tell flash correct URL.
 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 * @param  {String} url URL to make absolute
 * @return {String}     Absolute URL
 * @private
 */
vjs.getAbsoluteURL = function(url){

  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    url = vjs.createEl('div', {
      innerHTML: '<a href="'+url+'">x</a>'
    }).firstChild.href;
  }

  return url;
};


/**
 * Resolve and parse the elements of a URL
 * @param  {String} url The url to parse
 * @return {Object}     An object of url details
 */
vjs.parseUrl = function(url) {
  var div, a, addToBody, props, details;

  props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  a = vjs.createEl('a', { href: url });

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  addToBody = (a.host === '' && a.protocol !== 'file:');
  if (addToBody) {
    div = vjs.createEl('div');
    div.innerHTML = '<a href="'+url+'"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    document.body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  if (addToBody) {
    document.body.removeChild(div);
  }

  return details;
};

/**
 * Log messags to the console and history based on the type of message
 *
 * @param  {String} type The type of message, or `null` for `log`
 * @param  {[type]} args The args to be passed to the log
 * @private
 */
function _logType(type, args){
  var argsArray, noop, console;

  // convert args to an array to get array functions
  argsArray = Array.prototype.slice.call(args);
  // if there's no console then don't try to output messages
  // they will still be stored in vjs.log.history
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  noop = function(){};
  console = window['console'] || {
    'log': noop,
    'warn': noop,
    'error': noop
  };

  if (type) {
    // add the type to the front of the message
    argsArray.unshift(type.toUpperCase()+':');
  } else {
    // default to log with no prefix
    type = 'log';
  }

  // add to history
  vjs.log.history.push(argsArray);

  // add console prefix after adding to history
  argsArray.unshift('VIDEOJS:');

  // call appropriate log function
  if (console[type].apply) {
    console[type].apply(console, argsArray);
  } else {
    // ie8 doesn't allow error.apply, but it will just join() the array anyway
    console[type](argsArray.join(' '));
  }
}

/**
 * Log plain debug messages
 */
vjs.log = function(){
  _logType(null, arguments);
};

/**
 * Keep a history of log messages
 * @type {Array}
 */
vjs.log.history = [];

/**
 * Log error messages
 */
vjs.log.error = function(){
  _logType('error', arguments);
};

/**
 * Log warning messages
 */
vjs.log.warn = function(){
  _logType('warn', arguments);
};

// Offset Left
// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
vjs.findPosition = function(el) {
  var box, docEl, body, clientLeft, scrollLeft, left, clientTop, scrollTop, top;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  docEl = document.documentElement;
  body = document.body;

  clientLeft = docEl.clientLeft || body.clientLeft || 0;
  scrollLeft = window.pageXOffset || body.scrollLeft;
  left = box.left + scrollLeft - clientLeft;

  clientTop = docEl.clientTop || body.clientTop || 0;
  scrollTop = window.pageYOffset || body.scrollTop;
  top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: vjs.round(left),
    top: vjs.round(top)
  };
};

/**
 * Array functions container
 * @type {Object}
 * @private
 */
vjs.arr = {};

/*
 * Loops through an array and runs a function for each item inside it.
 * @param  {Array}    array       The array
 * @param  {Function} callback    The function to be run for each item
 * @param  {*}        thisArg     The `this` binding of callback
 * @returns {Array}               The array
 * @private
 */
vjs.arr.forEach = function(array, callback, thisArg) {
  if (vjs.obj.isArray(array) && callback instanceof Function) {
    for (var i = 0, len = array.length; i < len; ++i) {
      callback.call(thisArg || vjs, array[i], i, array);
    }
  }

  return array;
};
/**
 * Utility functions namespace
 * @namespace
 * @type {Object}
 */
vjs.util = {};

/**
 * Merge two options objects, recursively merging any plain object properties as
 * well.  Previously `deepMerge`
 *
 * @param  {Object} obj1 Object to override values in
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object -- obj1 and obj2 will be untouched
 */
vjs.util.mergeOptions = function(obj1, obj2){
  var key, val1, val2;

  // make a copy of obj1 so we're not overwriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = vjs.obj.copy(obj1);

  for (key in obj2){
    if (obj2.hasOwnProperty(key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
        obj1[key] = vjs.util.mergeOptions(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
};/**
 * @fileoverview Player Component - Base class for all UI objects
 *
 */

/**
 * Base UI Component class
 *
 * Components are embeddable UI objects that are represented by both a
 * javascript object and an element in the DOM. They can be children of other
 * components, and can have many children themselves.
 *
 *     // adding a button to the player
 *     var button = player.addChild('button');
 *     button.el(); // -> button element
 *
 *     <div class="video-js">
 *       <div class="vjs-button">Button</div>
 *     </div>
 *
 * Components are also event emitters.
 *
 *     button.on('click', function(){
 *       console.log('Button Clicked!');
 *     });
 *
 *     button.trigger('customevent');
 *
 * @param {Object} player  Main Player
 * @param {Object=} options
 * @class
 * @constructor
 * @extends vjs.CoreObject
 */
vjs.Component = vjs.CoreObject.extend({
  /**
   * the constructor function for the class
   *
   * @constructor
   */
  init: function(player, options, ready){
    this.player_ = player;

    // Make a copy of prototype.options_ to protect against overriding global defaults
    this.options_ = vjs.obj.copy(this.options_);

    // Updated options with supplied options
    options = this.options(options);

    // Get ID from options or options element if one is supplied
    this.id_ = options['id'] || (options['el'] && options['el']['id']);

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      this.id_ = ((player.id && player.id()) || 'no_player') + '_component_' + vjs.guid++;
    }

    this.name_ = options['name'] || null;

    // Create element if one wasn't provided in options
    this.el_ = options['el'] || this.createEl();

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    this.initChildren();

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }
});

/**
 * Dispose of the component and all child components
 */
vjs.Component.prototype.dispose = function(){
  this.trigger({ type: 'dispose', 'bubbles': false });

  // Dispose all children.
  if (this.children_) {
    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i].dispose) {
        this.children_[i].dispose();
      }
    }
  }

  // Delete child references
  this.children_ = null;
  this.childIndex_ = null;
  this.childNameIndex_ = null;

  // Remove all event listeners.
  this.off();

  // Remove element from DOM
  if (this.el_.parentNode) {
    this.el_.parentNode.removeChild(this.el_);
  }

  vjs.removeData(this.el_);
  //防止IE报错：modify 278500368@qq.com
  if(vjs.IS_CHROME){
    this.el_ = null;
  }

};

/**
 * Reference to main player instance
 *
 * @type {vjs.Player}
 * @private
 */
vjs.Component.prototype.player_ = true;

/**
 * Return the component's player
 *
 * @return {vjs.Player}
 */
vjs.Component.prototype.player = function(){
  return this.player_;
};

/**
 * The component's options object
 *
 * @type {Object}
 * @private
 */
vjs.Component.prototype.options_;

/**
 * Deep merge of options objects
 *
 * Whenever a property is an object on both options objects
 * the two properties will be merged using vjs.obj.deepMerge.
 *
 * This is used for merging options for child components. We
 * want it to be easy to override individual options on a child
 * component without having to rewrite all the other default options.
 *
 *     Parent.prototype.options_ = {
 *       children: {
 *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
 *         'childTwo': {},
 *         'childThree': {}
 *       }
 *     }
 *     newOptions = {
 *       children: {
 *         'childOne': { 'foo': 'baz', 'abc': '123' }
 *         'childTwo': null,
 *         'childFour': {}
 *       }
 *     }
 *
 *     this.options(newOptions);
 *
 * RESULT
 *
 *     {
 *       children: {
 *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
 *         'childTwo': null, // Disabled. Won't be initialized.
 *         'childThree': {},
 *         'childFour': {}
 *       }
 *     }
 *
 * @param  {Object} obj Object of new option values
 * @return {Object}     A NEW object of this.options_ and obj merged
 */
vjs.Component.prototype.options = function(obj){
  if (obj === undefined) return this.options_;

  return this.options_ = vjs.util.mergeOptions(this.options_, obj);
};

/**
 * The DOM element for the component
 *
 * @type {Element}
 * @private
 */
vjs.Component.prototype.el_;

/**
 * Create the component's DOM element
 *
 * @param  {String=} tagName  Element's node type. e.g. 'div'
 * @param  {Object=} attributes An object of element attributes that should be set on the element
 * @return {Element}
 */
vjs.Component.prototype.createEl = function(tagName, attributes){
  return vjs.createEl(tagName, attributes);
};

vjs.Component.prototype.localize = function(string){
  var lang = this.player_.language(),
      languages = this.player_.languages();
  if (languages && languages[lang] && languages[lang][string]) {
    return languages[lang][string];
  }
  return string;
};

/**
 * Get the component's DOM element
 *
 *     var domEl = myComponent.el();
 *
 * @return {Element}
 */
vjs.Component.prototype.el = function(){
  return this.el_;
};

/**
 * An optional element where, if defined, children will be inserted instead of
 * directly in `el_`
 *
 * @type {Element}
 * @private
 */
vjs.Component.prototype.contentEl_;

/**
 * Return the component's DOM element for embedding content.
 * Will either be el_ or a new element defined in createEl.
 *
 * @return {Element}
 */
vjs.Component.prototype.contentEl = function(){
  return this.contentEl_ || this.el_;
};

/**
 * The ID for the component
 *
 * @type {String}
 * @private
 */
vjs.Component.prototype.id_;

/**
 * Get the component's ID
 *
 *     var id = myComponent.id();
 *
 * @return {String}
 */
vjs.Component.prototype.id = function(){
  return this.id_;
};

/**
 * The name for the component. Often used to reference the component.
 *
 * @type {String}
 * @private
 */
vjs.Component.prototype.name_;

/**
 * Get the component's name. The name is often used to reference the component.
 *
 *     var name = myComponent.name();
 *
 * @return {String}
 */
vjs.Component.prototype.name = function(){
  return this.name_;
};

/**
 * Array of child components
 *
 * @type {Array}
 * @private
 */
vjs.Component.prototype.children_;

/**
 * Get an array of all child components
 *
 *     var kids = myComponent.children();
 *
 * @return {Array} The children
 */
vjs.Component.prototype.children = function(){
  return this.children_;
};

/**
 * Object of child components by ID
 *
 * @type {Object}
 * @private
 */
vjs.Component.prototype.childIndex_;

/**
 * Returns a child component with the provided ID
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.getChildById = function(id){
  return this.childIndex_[id];
};

/**
 * Object of child components by name
 *
 * @type {Object}
 * @private
 */
vjs.Component.prototype.childNameIndex_;

/**
 * Returns a child component with the provided name
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.getChild = function(name){
  return this.childNameIndex_[name];
};

/**
 * Adds a child component inside this component
 *
 *     myComponent.el();
 *     // -> <div class='my-component'></div>
 *     myComonent.children();
 *     // [empty array]
 *
 *     var myButton = myComponent.addChild('MyButton');
 *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
 *     // -> myButton === myComonent.children()[0];
 *
 * Pass in options for child constructors and options for children of the child
 *
 *     var myButton = myComponent.addChild('MyButton', {
 *       text: 'Press Me',
 *       children: {
 *         buttonChildExample: {
 *           buttonChildOption: true
 *         }
 *       }
 *     });
 *
 * @param {String|vjs.Component} child The class name or instance of a child to add
 * @param {Object=} options Options, including options to be passed to children of the child.
 * @return {vjs.Component} The child component (created by this process if a string was used)
 * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
 */
vjs.Component.prototype.addChild = function(child, options){
  var component, componentClass, componentName;

  // If child is a string, create new component with options
  if (typeof child === 'string') {
    componentName = child;

    // Make sure options is at least an empty object to protect against errors
    options = options || {};

    // If no componentClass in options, assume componentClass is the name lowercased
    // (e.g. playButton)
    componentClass = options['componentClass'] || vjs.capitalize(componentName);

    // Set name through options
    options['name'] = componentName;

    // Create a new object & element for this controls set
    // If there's no .player_, this is a player
    // Closure Compiler throws an 'incomplete alias' warning if we use the vjs variable directly.
    // Every class should be exported, so this should never be a problem here.
    component = new window['videojs'][componentClass](this.player_ || this, options);

  // child is a component instance
  } else {
    component = child;
  }

  this.children_.push(component);

  if (typeof component.id === 'function') {
    this.childIndex_[component.id()] = component;
  }

  // If a name wasn't used to create the component, check if we can use the
  // name function of the component
  componentName = componentName || (component.name && component.name());

  if (componentName) {
    this.childNameIndex_[componentName] = component;
  }

  // Add the UI object's element to the container div (box)
  // Having an element is not required
  if (typeof component['el'] === 'function' && component['el']()) {
    this.contentEl().appendChild(component['el']());
  }

  // Return so it can stored on parent object if desired.
  return component;
};

/**
 * Remove a child component from this component's list of children, and the
 * child component's element from this component's element
 *
 * @param  {vjs.Component} component Component to remove
 */
vjs.Component.prototype.removeChild = function(component){
  if (typeof component === 'string') {
    component = this.getChild(component);
  }

  if (!component || !this.children_) return;

  var childFound = false;
  for (var i = this.children_.length - 1; i >= 0; i--) {
    if (this.children_[i] === component) {
      childFound = true;
      this.children_.splice(i,1);
      break;
    }
  }

  if (!childFound) return;

  this.childIndex_[component.id] = null;
  this.childNameIndex_[component.name] = null;

  var compEl = component.el();
  if (compEl && compEl.parentNode === this.contentEl()) {
    this.contentEl().removeChild(component.el());
  }
};

/**
 * Add and initialize default child components from options
 *
 *     // when an instance of MyComponent is created, all children in options
 *     // will be added to the instance by their name strings and options
 *     MyComponent.prototype.options_.children = {
 *       myChildComponent: {
 *         myChildOption: true
 *       }
 *     }
 *
 *     // Or when creating the component
 *     var myComp = new MyComponent(player, {
 *       children: {
 *         myChildComponent: {
 *           myChildOption: true
 *         }
 *       }
 *     });
 *
 * The children option can also be an Array of child names or
 * child options objects (that also include a 'name' key).
 *
 *     var myComp = new MyComponent(player, {
 *       children: [
 *         'button',
 *         {
 *           name: 'button',
 *           someOtherOption: true
 *         }
 *       ]
 *     });
 *
 */
vjs.Component.prototype.initChildren = function(){
  var parent, parentOptions, children, child, name, opts, handleAdd;

  parent = this;
  parentOptions = parent.options();
  children = parentOptions['children'];

  if (children) {
    handleAdd = function(name, opts){
      // Allow options for children to be set at the parent options
      // e.g. videojs(id, { controlBar: false });
      // instead of videojs(id, { children: { controlBar: false });
      if (parentOptions[name] !== undefined) {
        opts = parentOptions[name];
      }

      // Allow for disabling default components
      // e.g. vjs.options['children']['posterImage'] = false
      if (opts === false) return;

      // Create and add the child component.
      // Add a direct reference to the child by name on the parent instance.
      // If two of the same component are used, different names should be supplied
      // for each
      parent[name] = parent.addChild(name, opts);
    };

    // Allow for an array of children details to passed in the options
    if (vjs.obj.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        child = children[i];

        if (typeof child == 'string') {
          // ['myComponent']
          name = child;
          opts = {};
        } else {
          // [{ name: 'myComponent', otherOption: true }]
          name = child.name;
          opts = child;
        }

        handleAdd(name, opts);
      }
    } else {
      vjs.obj.each(children, handleAdd);
    }
  }
};

/**
 * Allows sub components to stack CSS class names
 *
 * @return {String} The constructed class name
 */
vjs.Component.prototype.buildCSSClass = function(){
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
};

/* Events
============================================================================= */

/**
 * Add an event listener to this component's element
 *
 *     var myFunc = function(){
 *       var myComponent = this;
 *       // Do something when the event is fired
 *     };
 *
 *     myComponent.on('eventType', myFunc);
 *
 * The context of myFunc will be myComponent unless previously bound.
 *
 * Alternatively, you can add a listener to another element or component.
 *
 *     myComponent.on(otherElement, 'eventName', myFunc);
 *     myComponent.on(otherComponent, 'eventName', myFunc);
 *
 * The benefit of using this over `vjs.on(otherElement, 'eventName', myFunc)`
 * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
 * will be automatically cleaned up when either component is diposed.
 * It will also bind myComponent as the context of myFunc.
 *
 * **NOTE**: When using this on elements in the page other than window
 * and document (both permanent), if you remove the element from the DOM
 * you need to call `vjs.trigger(el, 'dispose')` on it to clean up
 * references to it and allow the browser to garbage collect it.
 *
 * @param  {String|vjs.Component} first   The event type or other component
 * @param  {Function|String}      second  The event handler or event type
 * @param  {Function}             third   The event handler
 * @return {vjs.Component}        self
 */
vjs.Component.prototype.on = function(first, second, third){
  var target, type, fn, removeOnDispose, cleanRemover, thisComponent;

  if (typeof first === 'string' || vjs.obj.isArray(first)) {
    vjs.on(this.el_, first, vjs.bind(this, second));

  // Targeting another component or element
  } else {
    target = first;
    type = second;
    fn = vjs.bind(this, third);
    thisComponent = this;

    // When this component is disposed, remove the listener from the other component
    removeOnDispose = function(){
      thisComponent.off(target, type, fn);
    };
    // Use the same function ID so we can remove it later it using the ID
    // of the original listener
    removeOnDispose.guid = fn.guid;
    this.on('dispose', removeOnDispose);

    // If the other component is disposed first we need to clean the reference
    // to the other component in this component's removeOnDispose listener
    // Otherwise we create a memory leak.
    cleanRemover = function(){
      thisComponent.off('dispose', removeOnDispose);
    };
    // Add the same function ID so we can easily remove it later
    cleanRemover.guid = fn.guid;

    // Check if this is a DOM node
    if (first.nodeName) {
      // Add the listener to the other element
      vjs.on(target, type, fn);
      vjs.on(target, 'dispose', cleanRemover);

    // Should be a component
    // Not using `instanceof vjs.Component` because it makes mock players difficult
    } else if (typeof first.on === 'function') {
      // Add the listener to the other component
      target.on(type, fn);
      target.on('dispose', cleanRemover);
    }
  }

  return this;
};

/**
 * Remove an event listener from this component's element
 *
 *     myComponent.off('eventType', myFunc);
 *
 * If myFunc is excluded, ALL listeners for the event type will be removed.
 * If eventType is excluded, ALL listeners will be removed from the component.
 *
 * Alternatively you can use `off` to remove listeners that were added to other
 * elements or components using `myComponent.on(otherComponent...`.
 * In this case both the event type and listener function are REQUIRED.
 *
 *     myComponent.off(otherElement, 'eventType', myFunc);
 *     myComponent.off(otherComponent, 'eventType', myFunc);
 *
 * @param  {String=|vjs.Component}  first  The event type or other component
 * @param  {Function=|String}       second The listener function or event type
 * @param  {Function=}              third  The listener for other component
 * @return {vjs.Component}
 */
vjs.Component.prototype.off = function(first, second, third){
  var target, otherComponent, type, fn, otherEl;

  if (!first || typeof first === 'string' || vjs.obj.isArray(first)) {
    vjs.off(this.el_, first, second);
  } else {
    target = first;
    type = second;
    // Ensure there's at least a guid, even if the function hasn't been used
    fn = vjs.bind(this, third);

    // Remove the dispose listener on this component,
    // which was given the same guid as the event listener
    this.off('dispose', fn);

    if (first.nodeName) {
      // Remove the listener
      vjs.off(target, type, fn);
      // Remove the listener for cleaning the dispose listener
      vjs.off(target, 'dispose', fn);
    } else {
      target.off(type, fn);
      target.off('dispose', fn);
    }
  }

  return this;
};

/**
 * Add an event listener to be triggered only once and then removed
 *
 *     myComponent.one('eventName', myFunc);
 *
 * Alternatively you can add a listener to another element or component
 * that will be triggered only once.
 *
 *     myComponent.one(otherElement, 'eventName', myFunc);
 *     myComponent.one(otherComponent, 'eventName', myFunc);
 *
 * @param  {String|vjs.Component}  first   The event type or other component
 * @param  {Function|String}       second  The listener function or event type
 * @param  {Function=}             third   The listener function for other component
 * @return {vjs.Component}
 */
vjs.Component.prototype.one = function(first, second, third) {
  var target, type, fn, thisComponent, newFunc;

  if (typeof first === 'string' || vjs.obj.isArray(first)) {
    vjs.one(this.el_, first, vjs.bind(this, second));
  } else {
    target = first;
    type = second;
    fn = vjs.bind(this, third);
    thisComponent = this;

    newFunc = function(){
      thisComponent.off(target, type, newFunc);
      fn.apply(this, arguments);
    };
    // Keep the same function ID so we can remove it later
    newFunc.guid = fn.guid;

    this.on(target, type, newFunc);
  }

  return this;
};

/**
 * Trigger an event on an element
 *
 *     myComponent.trigger('eventName');
 *     myComponent.trigger({'type':'eventName'});
 *
 * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
 * @return {vjs.Component}       self
 */
vjs.Component.prototype.trigger = function(event){
  vjs.trigger(this.el_, event);
  return this;
};

/* Ready
================================================================================ */
/**
 * Is the component loaded
 * This can mean different things depending on the component.
 *
 * @private
 * @type {Boolean}
 */
vjs.Component.prototype.isReady_;

/**
 * Trigger ready as soon as initialization is finished
 *
 * Allows for delaying ready. Override on a sub class prototype.
 * If you set this.isReadyOnInitFinish_ it will affect all components.
 * Specially used when waiting for the Flash player to asynchrnously load.
 *
 * @type {Boolean}
 * @private
 */
vjs.Component.prototype.isReadyOnInitFinish_ = true;

/**
 * List of ready listeners
 *
 * @type {Array}
 * @private
 */
vjs.Component.prototype.readyQueue_;

/**
 * Bind a listener to the component's ready state
 *
 * Different from event listeners in that if the ready event has already happend
 * it will trigger the function immediately.
 *
 * @param  {Function} fn Ready listener
 * @return {vjs.Component}
 */
vjs.Component.prototype.ready = function(fn){
  if (fn) {
    if (this.isReady_) {
      fn.call(this);
    } else {
      if (this.readyQueue_ === undefined) {
        this.readyQueue_ = [];
      }
      this.readyQueue_.push(fn);
    }
  }
  return this;
};

/**
 * Trigger the ready listeners
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.triggerReady = function(){
  this.isReady_ = true;

  var readyQueue = this.readyQueue_;

  if (readyQueue && readyQueue.length > 0) {

    for (var i = 0, j = readyQueue.length; i < j; i++) {
      readyQueue[i].call(this);
    }

    // Reset Ready Queue
    this.readyQueue_ = [];

    // Allow for using event listeners also, in case you want to do something everytime a source is ready.
    this.trigger('ready');
  }
};

/* Display
============================================================================= */

/**
 * Check if a component's element has a CSS class name
 *
 * @param {String} classToCheck Classname to check
 * @return {vjs.Component}
 */
vjs.Component.prototype.hasClass = function(classToCheck){
  return vjs.hasClass(this.el_, classToCheck);
};

/**
 * Add a CSS class name to the component's element
 *
 * @param {String} classToAdd Classname to add
 * @return {vjs.Component}
 */
vjs.Component.prototype.addClass = function(classToAdd){
  vjs.addClass(this.el_, classToAdd);
  return this;
};

/**
 * Remove a CSS class name from the component's element
 *
 * @param {String} classToRemove Classname to remove
 * @return {vjs.Component}
 */
vjs.Component.prototype.removeClass = function(classToRemove){
  vjs.removeClass(this.el_, classToRemove);
  return this;
};

/**
 * Show the component element if hidden
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.show = function(){
  this.el_.style.display = 'block';
  return this;
};

/**
 * Hide the component element if currently showing
 *
 * @return {vjs.Component}
 */
vjs.Component.prototype.hide = function(){
  this.el_.style.display = 'none';
  return this;
};

/**
 * Lock an item in its visible state
 * To be used with fadeIn/fadeOut.
 *
 * @return {vjs.Component}
 * @private
 */
vjs.Component.prototype.lockShowing = function(){
  this.addClass('vjs-lock-showing');
  return this;
};

/**
 * Unlock an item to be hidden
 * To be used with fadeIn/fadeOut.
 *
 * @return {vjs.Component}
 * @private
 */
vjs.Component.prototype.unlockShowing = function(){
  this.removeClass('vjs-lock-showing');
  return this;
};

/**
 * Disable component by making it unshowable
 *
 * Currently private because we're movign towards more css-based states.
 * @private
 */
vjs.Component.prototype.disable = function(){
  this.hide();
  this.show = function(){};
};

/**
 * Set or get the width of the component (CSS values)
 *
 * Setting the video tag dimension values only works with values in pixels.
 * Percent values will not work.
 * Some percents can be used, but width()/height() will return the number + %,
 * not the actual computed width/height.
 *
 * @param  {Number|String=} num   Optional width number
 * @param  {Boolean} skipListeners Skip the 'resize' event trigger
 * @return {vjs.Component} This component, when setting the width
 * @return {Number|String} The width, when getting
 */
vjs.Component.prototype.width = function(num, skipListeners){
  return this.dimension('width', num, skipListeners);
};

/**
 * Get or set the height of the component (CSS values)
 *
 * Setting the video tag dimension values only works with values in pixels.
 * Percent values will not work.
 * Some percents can be used, but width()/height() will return the number + %,
 * not the actual computed width/height.
 *
 * @param  {Number|String=} num     New component height
 * @param  {Boolean=} skipListeners Skip the resize event trigger
 * @return {vjs.Component} This component, when setting the height
 * @return {Number|String} The height, when getting
 */
vjs.Component.prototype.height = function(num, skipListeners){
  return this.dimension('height', num, skipListeners);
};

/**
 * Set both width and height at the same time
 *
 * @param  {Number|String} width
 * @param  {Number|String} height
 * @return {vjs.Component} The component
 */
vjs.Component.prototype.dimensions = function(width, height){
  // Skip resize listeners on width for optimization
  return this.width(width, true).height(height);
};

/**
 * Get or set width or height
 *
 * This is the shared code for the width() and height() methods.
 * All for an integer, integer + 'px' or integer + '%';
 *
 * Known issue: Hidden elements officially have a width of 0. We're defaulting
 * to the style.width value and falling back to computedStyle which has the
 * hidden element issue. Info, but probably not an efficient fix:
 * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
 *
 * @param  {String} widthOrHeight  'width' or 'height'
 * @param  {Number|String=} num     New dimension
 * @param  {Boolean=} skipListeners Skip resize event trigger
 * @return {vjs.Component} The component if a dimension was set
 * @return {Number|String} The dimension if nothing was set
 * @private
 */
vjs.Component.prototype.dimension = function(widthOrHeight, num, skipListeners){
  if (num !== undefined) {
    if (num === null || vjs.isNaN(num)) {
      num = 0;
    }

    // Check if using css width/height (% or px) and adjust
    if ((''+num).indexOf('%') !== -1 || (''+num).indexOf('px') !== -1) {
      this.el_.style[widthOrHeight] = num;
    } else if (num === 'auto') {
      this.el_.style[widthOrHeight] = '';
    } else {
      this.el_.style[widthOrHeight] = num+'px';
    }

    // skipListeners allows us to avoid triggering the resize event when setting both width and height
    if (!skipListeners) { this.trigger('resize'); }

    // Return component
    return this;
  }

  // Not setting a value, so getting it
  // Make sure element exists
  if (!this.el_) return 0;

  // Get dimension value from style
  var val = this.el_.style[widthOrHeight];
  var pxIndex = val.indexOf('px');
  if (pxIndex !== -1) {
    // Return the pixel value with no 'px'
    return parseInt(val.slice(0,pxIndex), 10);

  // No px so using % or no style was set, so falling back to offsetWidth/height
  // If component has display:none, offset will return 0
  // TODO: handle display:none and no dimension style using px
  } else {

    return parseInt(this.el_['offset'+vjs.capitalize(widthOrHeight)], 10);

    // ComputedStyle version.
    // Only difference is if the element is hidden it will return
    // the percent value (e.g. '100%'')
    // instead of zero like offsetWidth returns.
    // var val = vjs.getComputedStyleValue(this.el_, widthOrHeight);
    // var pxIndex = val.indexOf('px');

    // if (pxIndex !== -1) {
    //   return val.slice(0, pxIndex);
    // } else {
    //   return val;
    // }
  }
};

/**
 * Fired when the width and/or height of the component changes
 * @event resize
 */
vjs.Component.prototype.onResize;

/**
 * Emit 'tap' events when touch events are supported
 *
 * This is used to support toggling the controls through a tap on the video.
 *
 * We're requireing them to be enabled because otherwise every component would
 * have this extra overhead unnecessarily, on mobile devices where extra
 * overhead is especially bad.
 * @private
 */
vjs.Component.prototype.emitTapEvents = function(){
  var touchStart, firstTouch, touchTime, couldBeTap, noTap,
      xdiff, ydiff, touchDistance, tapMovementThreshold;

  // Track the start time so we can determine how long the touch lasted
  touchStart = 0;
  firstTouch = null;

  // Maximum movement allowed during a touch event to still be considered a tap
  tapMovementThreshold = 22;

  this.on('touchstart', function(event) {
    // If more than one finger, don't consider treating this as a click
    if (event.touches.length === 1) {
      firstTouch = event.touches[0];
      // Record start time so we can detect a tap vs. "touch and hold"
      touchStart = new Date().getTime();
      // Reset couldBeTap tracking
      couldBeTap = true;
    }
  });

  this.on('touchmove', function(event) {
    // If more than one finger, don't consider treating this as a click
    if (event.touches.length > 1) {
      couldBeTap = false;
    } else if (firstTouch) {
      // Some devices will throw touchmoves for all but the slightest of taps.
      // So, if we moved only a small distance, this could still be a tap
      xdiff = event.touches[0].pageX - firstTouch.pageX;
      ydiff = event.touches[0].pageY - firstTouch.pageY;
      touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
      if (touchDistance > tapMovementThreshold) {
        couldBeTap = false;
      }
    }
  });

  noTap = function(){
    couldBeTap = false;
  };
  // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
  this.on('touchleave', noTap);
  this.on('touchcancel', noTap);

  // When the touch ends, measure how long it took and trigger the appropriate
  // event
  this.on('touchend', function(event) {
    firstTouch = null;
    // Proceed only if the touchmove/leave/cancel event didn't happen
    if (couldBeTap === true) {
      // Measure how long the touch lasted
      touchTime = new Date().getTime() - touchStart;
      // The touch needs to be quick in order to consider it a tap
      if (touchTime < 250) {
        event.preventDefault(); // Don't let browser turn this into a click
        this.trigger('tap');
        // It may be good to copy the touchend event object and change the
        // type to tap, if the other event properties aren't exact after
        // vjs.fixEvent runs (e.g. event.target)
      }
    }
  });
};

/**
 * Report user touch activity when touch events occur
 *
 * User activity is used to determine when controls should show/hide. It's
 * relatively simple when it comes to mouse events, because any mouse event
 * should show the controls. So we capture mouse events that bubble up to the
 * player and report activity when that happens.
 *
 * With touch events it isn't as easy. We can't rely on touch events at the
 * player level, because a tap (touchstart + touchend) on the video itself on
 * mobile devices is meant to turn controls off (and on). User activity is
 * checked asynchronously, so what could happen is a tap event on the video
 * turns the controls off, then the touchend event bubbles up to the player,
 * which if it reported user activity, would turn the controls right back on.
 * (We also don't want to completely block touch events from bubbling up)
 *
 * Also a touchmove, touch+hold, and anything other than a tap is not supposed
 * to turn the controls back on on a mobile device.
 *
 * Here we're setting the default component behavior to report user activity
 * whenever touch events happen, and this can be turned off by components that
 * want touch events to act differently.
 */
vjs.Component.prototype.enableTouchActivity = function() {
  var report, touchHolding, touchEnd;

  // Don't continue if the root player doesn't support reporting user activity
  if (!this.player().reportUserActivity) {
    return;
  }

  // listener for reporting that the user is active
  report = vjs.bind(this.player(), this.player().reportUserActivity);

  this.on('touchstart', function() {
    report();
    // For as long as the they are touching the device or have their mouse down,
    // we consider them active even if they're not moving their finger or mouse.
    // So we want to continue to update that they are active
    clearInterval(touchHolding);
    // report at the same interval as activityCheck
    touchHolding = setInterval(report, 250);
  });

  touchEnd = function(event) {
    report();
    // stop the interval that maintains activity if the touch is holding
    clearInterval(touchHolding);
  };

  this.on('touchmove', report);
  this.on('touchend', touchEnd);
  this.on('touchcancel', touchEnd);
};

/* Button - Base class for all buttons
================================================================================ */
/**
 * Base class for all buttons
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */
vjs.Button = vjs.Component.extend({
  /**
   * @constructor
   * @inheritDoc
   */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    this.emitTapEvents();

    this.on('tap', this.onClick);
    this.on('click', this.onClick);
    this.on('focus', this.onFocus);
    this.on('blur', this.onBlur);
  }
});

vjs.Button.prototype.createEl = function(type, props){
  var el;

  // Add standard Aria and Tabindex info
  props = vjs.obj.merge({
    className: this.buildCSSClass(),
    'role': 'button',
    'aria-live': 'polite', // let the screen reader user know that the text of the button may change
    tabIndex: 0
  }, props);

  el = vjs.Component.prototype.createEl.call(this, type, props);

  // if innerHTML hasn't been overridden (bigPlayButton), add content elements
  if (!props.innerHTML) {
    this.contentEl_ = vjs.createEl('div', {
      className: 'vjs-control-content'
    });

    this.controlText_ = vjs.createEl('span', {
      className: 'vjs-control-text',
      innerHTML: this.localize(this.buttonText) || 'Need Text'
    });

    this.contentEl_.appendChild(this.controlText_);
    el.appendChild(this.contentEl_);
  }

  return el;
};

vjs.Button.prototype.buildCSSClass = function(){
  // TODO: Change vjs-control to vjs-button?
  return 'vjs-control ' + vjs.Component.prototype.buildCSSClass.call(this);
};

  // Click - Override with specific functionality for button
vjs.Button.prototype.onClick = function(){};

  // Focus - Add keyboard functionality to element
vjs.Button.prototype.onFocus = function(){
  vjs.on(document, 'keydown', vjs.bind(this, this.onKeyPress));
};

  // KeyPress (document level) - Trigger click when keys are pressed
vjs.Button.prototype.onKeyPress = function(event){
  // Check for space bar (32) or enter (13) keys
  if (event.which == 32 || event.which == 13) {
    event.preventDefault();
    this.onClick();
  }
};

// Blur - Remove keyboard triggers
vjs.Button.prototype.onBlur = function(){
  vjs.off(document, 'keydown', vjs.bind(this, this.onKeyPress));
};
/* Slider
================================================================================ */
/**
 * The base functionality for sliders like the volume bar and seek bar
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.Slider = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    // Set property names to bar and handle to match with the child Slider class is looking for
    this.bar = this.getChild(this.options_['barName']);
    this.handle = this.getChild(this.options_['handleName']);

    this.on('mousedown', this.onMouseDown);
    this.on('touchstart', this.onMouseDown);
    this.on('focus', this.onFocus);
    this.on('blur', this.onBlur);
    this.on('click', this.onClick);

    this.on(player, 'controlsvisible', this.update);
    this.on(player, this.playerEvent, this.update);

    this.boundEvents = {};
    this.boundEvents.move = vjs.bind(this, this.onMouseMove);
    this.boundEvents.end = vjs.bind(this, this.onMouseUp);
  }
});

vjs.Slider.prototype.dispose = function() {
  vjs.off(document, 'mousemove', this.boundEvents.move, false);
  vjs.off(document, 'mouseup', this.boundEvents.end, false);
  vjs.off(document, 'touchmove', this.boundEvents.move, false);
  vjs.off(document, 'touchend', this.boundEvents.end, false);

  vjs.off(document, 'keyup', vjs.bind(this, this.onKeyPress));

  vjs.Component.prototype.dispose.call(this);
};

vjs.Slider.prototype.createEl = function(type, props) {
  props = props || {};
  // Add the slider element class to all sub classes
  props.className = props.className + ' vjs-slider';
  props = vjs.obj.merge({
    'role': 'slider',
    'aria-valuenow': 0,
    'aria-valuemin': 0,
    'aria-valuemax': 100,
    tabIndex: 0
  }, props);

  return vjs.Component.prototype.createEl.call(this, type, props);
};

vjs.Slider.prototype.onMouseDown = function(event){
  event.preventDefault();
  vjs.blockTextSelection();
  this.addClass('vjs-sliding');

  vjs.on(document, 'mousemove', this.boundEvents.move);
  vjs.on(document, 'mouseup', this.boundEvents.end);
  vjs.on(document, 'touchmove', this.boundEvents.move);
  vjs.on(document, 'touchend', this.boundEvents.end);

  this.onMouseMove(event);
};

// To be overridden by a subclass
vjs.Slider.prototype.onMouseMove = function(){};

vjs.Slider.prototype.onMouseUp = function() {
  vjs.unblockTextSelection();
  this.removeClass('vjs-sliding');

  vjs.off(document, 'mousemove', this.boundEvents.move, false);
  vjs.off(document, 'mouseup', this.boundEvents.end, false);
  vjs.off(document, 'touchmove', this.boundEvents.move, false);
  vjs.off(document, 'touchend', this.boundEvents.end, false);

  this.update();
};

vjs.Slider.prototype.update = function(){
  // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
  // execution stack. The player is destroyed before then update will cause an error
  if (!this.el_) return;

  // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
  // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
  // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();

  var barProgress,
      progress = this.getPercent(),
      handle = this.handle,
      bar = this.bar;

  // Protect against no duration and other division issues
  if (isNaN(progress)) { progress = 0; }

  barProgress = progress;

  // If there is a handle, we need to account for the handle in our calculation for progress bar
  // so that it doesn't fall short of or extend past the handle.
  if (handle) {

    var box = this.el_,
        boxWidth = box.offsetWidth,

        handleWidth = handle.el().offsetWidth,

        // The width of the handle in percent of the containing box
        // In IE, widths may not be ready yet causing NaN
        handlePercent = (handleWidth) ? handleWidth / boxWidth : 0,

        // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
        // There is a margin of half the handle's width on both sides.
        boxAdjustedPercent = 1 - handlePercent,

        // Adjust the progress that we'll use to set widths to the new adjusted box width
        adjustedProgress = progress * boxAdjustedPercent;

    // The bar does reach the left side, so we need to account for this in the bar's width
    barProgress = adjustedProgress + (handlePercent / 2);

    // Move the handle from the left based on the adjected progress
    handle.el().style.left = vjs.round(adjustedProgress * 100, 2) + '%';
  }

  // Set the new bar width
  if (bar) {
    bar.el().style.width = vjs.round(barProgress * 100, 2) + '%';
  }
};

vjs.Slider.prototype.calculateDistance = function(event){
  var el, box, boxX, boxY, boxW, boxH, handle, pageX, pageY;

  el = this.el_;
  box = vjs.findPosition(el);
  boxW = boxH = el.offsetWidth;
  handle = this.handle;

  if (this.options()['vertical']) {
    boxY = box.top;

    if (event.changedTouches) {
      pageY = event.changedTouches[0].pageY;
    } else {
      pageY = event.pageY;
    }

    if (handle) {
      var handleH = handle.el().offsetHeight;
      // Adjusted X and Width, so handle doesn't go outside the bar
      boxY = boxY + (handleH / 2);
      boxH = boxH - handleH;
    }

    // Percent that the click is through the adjusted area
    return Math.max(0, Math.min(1, ((boxY - pageY) + boxH) / boxH));

  } else {
    boxX = box.left;

    if (event.changedTouches) {
      pageX = event.changedTouches[0].pageX;
    } else {
      pageX = event.pageX;
    }

    if (handle) {
      var handleW = handle.el().offsetWidth;

      // Adjusted X and Width, so handle doesn't go outside the bar
      boxX = boxX + (handleW / 2);
      boxW = boxW - handleW;
    }

    // Percent that the click is through the adjusted area
    return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
  }
};

vjs.Slider.prototype.onFocus = function(){
  vjs.on(document, 'keyup', vjs.bind(this, this.onKeyPress));
};

vjs.Slider.prototype.onKeyPress = function(event){
  if (event.which == 37 || event.which == 40) { // Left and Down Arrows
    event.preventDefault();
    this.stepBack();
  } else if (event.which == 38 || event.which == 39) { // Up and Right Arrows
    event.preventDefault();
    this.stepForward();
  }
};

vjs.Slider.prototype.onBlur = function(){
  vjs.off(document, 'keyup', vjs.bind(this, this.onKeyPress));
};

/**
 * Listener for click events on slider, used to prevent clicks
 *   from bubbling up to parent elements like button menus.
 * @param  {Object} event Event object
 */
vjs.Slider.prototype.onClick = function(event){
  event.stopImmediatePropagation();
  event.preventDefault();
};

/**
 * SeekBar Behavior includes play progress bar, and seek handle
 * Needed so it can determine seek position based on handle position/size
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.SliderHandle = vjs.Component.extend();

/**
 * Default value of the slider
 *
 * @type {Number}
 * @private
 */
vjs.SliderHandle.prototype.defaultValue = 0;

/** @inheritDoc */
vjs.SliderHandle.prototype.createEl = function(type, props) {
  props = props || {};
  // Add the slider element class to all sub classes
  props.className = props.className + ' vjs-slider-handle';
  props = vjs.obj.merge({
    innerHTML: '<span class="vjs-control-text">'+this.defaultValue+'</span>'
  }, props);

  return vjs.Component.prototype.createEl.call(this, 'div', props);
};


/**
 * Custom MediaError to mimic the HTML5 MediaError
 * @param {Number} code The media error code
 */
vjs.MediaError = function(code){
  if (typeof code === 'number') {
    this.code = code;
  } else if (typeof code === 'string') {
    // default code is zero, so this is a custom error
    this.message = code;
  } else if (typeof code === 'object') { // object
    vjs.obj.merge(this, code);
  }

  if (!this.message) {
    this.message = vjs.MediaError.defaultMessages[this.code] || '';
  }
};

/**
 * The error code that refers two one of the defined
 * MediaError types
 * @type {Number}
 */
vjs.MediaError.prototype.code = 0;

/**
 * An optional message to be shown with the error.
 * Message is not part of the HTML5 video spec
 * but allows for more informative custom errors.
 * @type {String}
 */
vjs.MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins
 * to allow even more detail about the error.
 * For example the HLS plugin might provide the specific
 * HTTP status code that was returned when the error
 * occurred, then allowing a custom error overlay
 * to display more information.
 * @type {[type]}
 */
vjs.MediaError.prototype.status = null;

vjs.MediaError.errorTypes = [
  'MEDIA_ERR_CUSTOM',            // = 0
  'MEDIA_ERR_ABORTED',           // = 1
  'MEDIA_ERR_NETWORK',           // = 2
  'MEDIA_ERR_DECODE',            // = 3
  'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
  'MEDIA_ERR_ENCRYPTED'          // = 5
];

vjs.MediaError.defaultMessages = {
  1: 'You aborted the video playback',
  2: 'A network error caused the video download to fail part-way.',
  3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
  4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The video is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < vjs.MediaError.errorTypes.length; errNum++) {
  vjs.MediaError[vjs.MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  vjs.MediaError.prototype[vjs.MediaError.errorTypes[errNum]] = errNum;
}
(function(){
  var apiMap, specApi, browserApi, i;

  /**
   * Store the browser-specifc methods for the fullscreen API
   * @type {Object|undefined}
   * @private
   */
  vjs.browser.fullscreenAPI;

  // browser API methods
  // map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
  apiMap = [
    // Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
    [
      'requestFullscreen',
      'exitFullscreen',
      'fullscreenElement',
      'fullscreenEnabled',
      'fullscreenchange',
      'fullscreenerror'
    ],
    // WebKit
    [
      'webkitRequestFullscreen',
      'webkitExitFullscreen',
      'webkitFullscreenElement',
      'webkitFullscreenEnabled',
      'webkitfullscreenchange',
      'webkitfullscreenerror'
    ],
    // Old WebKit (Safari 5.1)
    [
      'webkitRequestFullScreen',
      'webkitCancelFullScreen',
      'webkitCurrentFullScreenElement',
      'webkitCancelFullScreen',
      'webkitfullscreenchange',
      'webkitfullscreenerror'
    ],
    // Mozilla
    [
      'mozRequestFullScreen',
      'mozCancelFullScreen',
      'mozFullScreenElement',
      'mozFullScreenEnabled',
      'mozfullscreenchange',
      'mozfullscreenerror'
    ],
    // Microsoft
    [
      'msRequestFullscreen',
      'msExitFullscreen',
      'msFullscreenElement',
      'msFullscreenEnabled',
      'MSFullscreenChange',
      'MSFullscreenError'
    ]
  ];

  specApi = apiMap[0];

  // determine the supported set of functions
  for (i=0; i<apiMap.length; i++) {
    // check for exitFullscreen function
    if (apiMap[i][1] in document) {
      browserApi = apiMap[i];
      break;
    }
  }

  // map the browser API names to the spec API names
  // or leave vjs.browser.fullscreenAPI undefined
  if (browserApi) {
    vjs.browser.fullscreenAPI = {};

    for (i=0; i<browserApi.length; i++) {
      vjs.browser.fullscreenAPI[specApi[i]] = browserApi[i];
    }
  }

})();
/**
 * An instance of the `vjs.Player` class is created when any of the Video.js setup methods are used to initialize a video.
 *
 * ```js
 * var myPlayer = videojs('example_video_1');
 * ```
 *
 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
 *
 * ```html
 * <video id="example_video_1" data-setup='{}' controls>
 *   <source src="my-source.mp4" type="video/mp4">
 * </video>
 * ```
 *
 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
 *
 * @class
 * @extends vjs.Component
 */
vjs.Player = vjs.Component.extend({

  /**
   * player's constructor function
   *
   * @constructs
   * @method init
   * @param {Element} tag        The original video tag used for configuring options
   * @param {Object=} options    Player options
   * @param {Function=} ready    Ready callback function
   */
  init: function(tag, options, ready){
    this.tag = tag; // Store the original tag used to set options

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + vjs.guid++;

    // Store the tag attributes used to restore html5 element
    this.tagAttributes = tag && vjs.getElementAttributes(tag);

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = vjs.obj.merge(this.getTagSettings(tag), options);

    // Update Current Language
    this.language_ = options['language'] || vjs.options['language'];

    // Update Supported Languages
    this.languages_ = options['languages'] || vjs.options['languages'];

    // Cache for video property values.
    this.cache_ = {};

    // Set controls
    this.controls_ = !!options['controls'];
    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // Set isAudio based on whether or not an audio tag was used
    this.isAudio(this.tag.nodeName.toLowerCase() === 'audio');

    // Run base component initializing with new options.
    // Builds the element through createEl()
    // Inits and embeds any child components in opts
    vjs.Component.call(this, this, options, ready);

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (this.controls()) {
      this.addClass('vjs-controls-enabled');
    } else {
      this.addClass('vjs-controls-disabled');
    }

    if (this.isAudio()) {
      this.addClass('vjs-audio');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (vjs.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // Make player easily findable by ID
    vjs.players[this.id_] = this;

    if (options['plugins']) {
      vjs.obj.each(options['plugins'], function(key, val){
        this[key](val);
      }, this);
    }

    this.listenForUserActivity();
  }
});

/**
 * The players's stored language code
 *
 * @type {String}
 * @private
 */
vjs.Player.prototype.language_;

/**
 * The player's language code
 * @param  {String} languageCode  The locale string
 * @return {String}             The locale string when getting
 * @return {vjs.Player}         self, when setting
 */
vjs.Player.prototype.language = function (languageCode) {
  if (languageCode === undefined) {
    return this.language_;
  }

  this.language_ = languageCode;
  return this;
};

/**
 * The players's stored language dictionary
 *
 * @type {Object}
 * @private
 */
vjs.Player.prototype.languages_;

vjs.Player.prototype.languages = function(){
  return this.languages_;
};

/**
 * Player instance options, surfaced using vjs.options
 * vjs.options = vjs.Player.prototype.options_
 * Make changes in vjs.options, not here.
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 * @private
 */
vjs.Player.prototype.options_ = vjs.options;

/**
 * Destroys the video player and does any necessary cleanup
 *
 *     myPlayer.dispose();
 *
 * This is especially helpful if you are dynamically adding and removing videos
 * to/from the DOM.
 */
vjs.Player.prototype.dispose = function(){
  this.trigger('dispose');
  // prevent dispose from being called twice
  this.off('dispose');

  // Kill reference to this player
  vjs.players[this.id_] = null;
  if (this.tag && this.tag['player']) { this.tag['player'] = null; }
  if (this.el_ && this.el_['player']) { this.el_['player'] = null; }

  if (this.tech) { this.tech.dispose(); }

  // Component dispose
  vjs.Component.prototype.dispose.call(this);
};

vjs.Player.prototype.getTagSettings = function(tag){
  var tagOptions,
      dataSetup,
      options = {
        'sources': []
        //'tracks': []
      };

  tagOptions = vjs.getElementAttributes(tag);
  dataSetup = tagOptions['data-setup'];

  // Check if data-setup attr exists.
  if (dataSetup !== null){
    // Parse options JSON
    // If empty string, make it a parsable json object.
    vjs.obj.merge(tagOptions, vjs.JSON.parse(dataSetup || '{}'));
  }

  vjs.obj.merge(options, tagOptions);

  // Get tag children settings
  if (tag.hasChildNodes()) {
    var children, child, childName, i, j;

    children = tag.childNodes;

    for (i=0,j=children.length; i<j; i++) {
      child = children[i];
      // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
      childName = child.nodeName.toLowerCase();
      if (childName === 'source') {
        options['sources'].push(vjs.getElementAttributes(child));
      }
    }
  }

  return options;
};

vjs.Player.prototype.createEl = function(){
  var
    el = this.el_ = vjs.Component.prototype.createEl.call(this, 'div'),
    tag = this.tag,
    attrs;

  // Remove width/height attrs from tag so CSS can make it 100% width/height
  tag.removeAttribute('width');
  tag.removeAttribute('height');
  // Empty video tag tracks so the built-in player doesn't use them also.
  // This may not be fast enough to stop HTML5 browsers from reading the tags
  // so we'll need to turn off any default tracks if we're manually doing
  // captions and subtitles. videoElement.textTracks
  if (tag.hasChildNodes()) {
    var nodes, nodesLength, i, node, nodeName, removeNodes;

    nodes = tag.childNodes;
    nodesLength = nodes.length;
    removeNodes = [];

    while (nodesLength--) {
      node = nodes[nodesLength];
      nodeName = node.nodeName.toLowerCase();
      if (nodeName === 'track') {
        removeNodes.push(node);
      }
    }

    for (i=0; i<removeNodes.length; i++) {
      tag.removeChild(removeNodes[i]);
    }
  }

  // Copy over all the attributes from the tag, including ID and class
  // ID will now reference player box, not the video tag
  attrs = vjs.getElementAttributes(tag);
  vjs.obj.each(attrs, function(attr) {
    // workaround so we don't totally break IE7
    // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
    if (attr == 'class') {
      el.className = attrs[attr];
    } else {
      el.setAttribute(attr, attrs[attr]);
    }
  });

  // Update tag id/class for use as HTML5 playback tech
  // Might think we should do this after embedding in container so .vjs-tech class
  // doesn't flash 100% width/height, but class only applies with .video-js parent
  tag.id += '_html5_api';
  tag.className = 'vjs-tech';

  // Make player findable on elements
  tag['player'] = el['player'] = this;
  // Default state of video is paused
  this.addClass('vjs-paused');

  // Make box use width/height of tag, or rely on default implementation
  // Enforce with CSS since width/height attrs don't work on divs
  this.width(this.options_['width'], true); // (true) Skip resize listener on load
  this.height(this.options_['height'], true);

  // vjs.insertFirst seems to cause the networkState to flicker from 3 to 2, so
  // keep track of the original for later so we can know if the source originally failed
  tag.initNetworkState_ = tag.networkState;

  // Wrap video tag in div (el/box) container
  if (tag.parentNode) {
    tag.parentNode.insertBefore(el, tag);
  }
  vjs.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

  // The event listeners need to be added before the children are added
  // in the component init because the tech (loaded with mediaLoader) may
  // fire events, like loadstart, that these events need to capture.
  // Long term it might be better to expose a way to do this in component.init
  // like component.initEventListeners() that runs between el creation and
  // adding children
  this.el_ = el;
  this.on('loadstart', this.onLoadStart);
  this.on('waiting', this.onWaiting);
  this.on(['canplay', 'canplaythrough', 'playing', 'ended'], this.onWaitEnd);
  this.on('seeking', this.onSeeking);
  this.on('seeked', this.onSeeked);
  this.on('ended', this.onEnded);
  this.on('play', this.onPlay);
  this.on('firstplay', this.onFirstPlay);
  this.on('pause', this.onPause);
  this.on('progress', this.onProgress);
  this.on('durationchange', this.onDurationChange);
  this.on('fullscreenchange', this.onFullscreenChange);

  return el;
};

// /* Media Technology (tech)
// ================================================================================ */
// Load/Create an instance of playback technlogy including element and API methods
// And append playback element in player div.
vjs.Player.prototype.loadTech = function(techName, source){

  // Pause and remove current playback technology
  if (this.tech) {
    this.unloadTech();
  }

  // get rid of the HTML5 video tag as soon as we are using another tech
  if (techName !== 'Html5' && this.tag) {
    vjs.Html5.disposeMediaElement(this.tag);
    this.tag = null;
  }

  this.techName = techName;

  // Turn off API access because we're loading a new tech that might load asynchronously
  this.isReady_ = false;

  var techReady = function(){
    this.player_.triggerReady();
  };

  // Grab tech-specific options from player options and add source and parent element to use.
  var techOptions = vjs.obj.merge({ 'source': source, 'parentEl': this.el_ }, this.options_[techName.toLowerCase()]);

  if (source) {
    this.currentType_ = source.type;
    if (source.src == this.cache_.src && this.cache_.currentTime > 0) {
      techOptions['startTime'] = this.cache_.currentTime;
    }

    this.cache_.src = source.src;
  }

  // Initialize tech instance
  this.tech = new window['videojs'][techName](this, techOptions);

  this.tech.ready(techReady);
};

vjs.Player.prototype.unloadTech = function(){
  this.isReady_ = false;

  this.tech.dispose();

  this.tech = false;
};

// There's many issues around changing the size of a Flash (or other plugin) object.
// First is a plugin reload issue in Firefox that has been around for 11 years: https://bugzilla.mozilla.org/show_bug.cgi?id=90268
// Then with the new fullscreen API, Mozilla and webkit browsers will reload the flash object after going to fullscreen.
// To get around this, we're unloading the tech, caching source and currentTime values, and reloading the tech once the plugin is resized.
// reloadTech: function(betweenFn){
//   vjs.log('unloadingTech')
//   this.unloadTech();
//   vjs.log('unloadedTech')
//   if (betweenFn) { betweenFn.call(); }
//   vjs.log('LoadingTech')
//   this.loadTech(this.techName, { src: this.cache_.src })
//   vjs.log('loadedTech')
// },

// /* Player event handlers (how the player reacts to certain events)
// ================================================================================ */

/**
 * Fired when the user agent begins looking for media data
 * @event loadstart
 */
vjs.Player.prototype.onLoadStart = function() {
  // TODO: Update to use `emptied` event instead. See #1277.

  // reset the error state
  this.error(null);

  // If it's already playing we want to trigger a firstplay event now.
  // The firstplay event relies on both the play and loadstart events
  // which can happen in any order for a new source
  if (!this.paused()) {
    this.trigger('firstplay');
  } else {
    // reset the hasStarted state
    this.hasStarted(false);
    this.one('play', function(){
      this.hasStarted(true);
    });
  }
};

vjs.Player.prototype.hasStarted_ = false;

vjs.Player.prototype.hasStarted = function(hasStarted){
  if (hasStarted !== undefined) {
    // only update if this is a new value
    if (this.hasStarted_ !== hasStarted) {
      this.hasStarted_ = hasStarted;
      if (hasStarted) {
        this.addClass('vjs-has-started');
        // trigger the firstplay event if this newly has played
        this.trigger('firstplay');
      } else {
        this.removeClass('vjs-has-started');
      }
    }
    return this;
  }
  return this.hasStarted_;
};

/**
 * Fired when the player has initial duration and dimension information
 * @event loadedmetadata
 */
vjs.Player.prototype.onLoadedMetaData;

/**
 * Fired when the player has downloaded data at the current playback position
 * @event loadeddata
 */
vjs.Player.prototype.onLoadedData;

/**
 * Fired when the player has finished downloading the source data
 * @event loadedalldata
 */
vjs.Player.prototype.onLoadedAllData;

/**
 * Fired whenever the media begins or resumes playback
 * @event play
 */
vjs.Player.prototype.onPlay = function(){
  this.removeClass('vjs-paused');
  this.addClass('vjs-playing');
};

/**
 * Fired whenever the media begins wating
 * @event waiting
 */
vjs.Player.prototype.onWaiting = function(){
  this.addClass('vjs-waiting');
};

/**
 * A handler for events that signal that waiting has eneded
 * which is not consistent between browsers. See #1351
 * @private
 */
vjs.Player.prototype.onWaitEnd = function(){
  this.removeClass('vjs-waiting');
};

/**
 * Fired whenever the player is jumping to a new time
 * @event seeking
 */
vjs.Player.prototype.onSeeking = function(){
  this.addClass('vjs-seeking');
};

/**
 * Fired when the player has finished jumping to a new time
 * @event seeked
 */
vjs.Player.prototype.onSeeked = function(){
  this.removeClass('vjs-seeking');
};

/**
 * Fired the first time a video is played
 *
 * Not part of the HLS spec, and we're not sure if this is the best
 * implementation yet, so use sparingly. If you don't have a reason to
 * prevent playback, use `myPlayer.one('play');` instead.
 *
 * @event firstplay
 */
vjs.Player.prototype.onFirstPlay = function(){
    //If the first starttime attribute is specified
    //then we will start at the given offset in seconds
    if(this.options_['starttime']){
      this.currentTime(this.options_['starttime']);
    }

    this.addClass('vjs-has-started');
};

/**
 * Fired whenever the media has been paused
 * @event pause
 */
vjs.Player.prototype.onPause = function(){
  this.removeClass('vjs-playing');
  this.addClass('vjs-paused');
};

/**
 * Fired when the current playback position has changed
 *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 * @event timeupdate
 */
vjs.Player.prototype.onTimeUpdate;

/**
 * Fired while the user agent is downloading media data
 * @event progress
 */
vjs.Player.prototype.onProgress = function(){
  // Add custom event for when source is finished downloading.
  if (this.bufferedPercent() == 1) {
    this.trigger('loadedalldata');
  }
};

/**
 * Fired when the end of the media resource is reached (currentTime == duration)
 * @event ended
 */
vjs.Player.prototype.onEnded = function(){
  if (this.options_['loop']) {
    this.currentTime(0);
    this.play();
  } else if (!this.paused()) {
    this.pause();
  }
};

/**
 * Fired when the duration of the media resource is first known or changed
 * @event durationchange
 */
vjs.Player.prototype.onDurationChange = function(){
  // Allows for cacheing value instead of asking player each time.
  // We need to get the techGet response and check for a value so we don't
  // accidentally cause the stack to blow up.
  var duration = this.techGet('duration');
  if (duration) {
    if (duration < 0) {
      duration = Infinity;
    }
    this.duration(duration);
    // Determine if the stream is live and propagate styles down to UI.
    if (duration === Infinity) {
      this.addClass('vjs-live');
    } else {
      this.removeClass('vjs-live');
    }
  }
};

/**
 * Fired when the volume changes
 * @event volumechange
 */
vjs.Player.prototype.onVolumeChange;

/**
 * Fired when the player switches in or out of fullscreen mode
 * @event fullscreenchange
 */
vjs.Player.prototype.onFullscreenChange = function() {
  if (this.isFullscreen()) {
    this.addClass('vjs-fullscreen');
  } else {
    this.removeClass('vjs-fullscreen');
  }
};

// /* Player API
// ================================================================================ */

/**
 * Object for cached values.
 * @private
 */
vjs.Player.prototype.cache_;

vjs.Player.prototype.getCache = function(){
  return this.cache_;
};

// Pass values to the playback tech
vjs.Player.prototype.techCall = function(method, arg){
  // If it's not ready yet, call method when it is
  if (this.tech && !this.tech.isReady_) {
    this.tech.ready(function(){
      this[method](arg);
    });

  // Otherwise call method now
  } else {
    try {
      this.tech[method](arg);
    } catch(e) {
      vjs.log(e);
      throw e;
    }
  }
};

// Get calls can't wait for the tech, and sometimes don't need to.
vjs.Player.prototype.techGet = function(method){
  if (this.tech && this.tech.isReady_) {

    // Flash likes to die and reload when you hide or reposition it.
    // In these cases the object methods go away and we get errors.
    // When that happens we'll catch the errors and inform tech that it's not ready any more.
    try {
      return this.tech[method]();
    } catch(e) {
      // When building additional tech libs, an expected method may not be defined yet
      if (this.tech[method] === undefined) {
        vjs.log('Video.js: ' + method + ' method not defined for '+this.techName+' playback technology.', e);
      } else {
        // When a method isn't available on the object it throws a TypeError
        if (e.name == 'TypeError') {
          vjs.log('Video.js: ' + method + ' unavailable on '+this.techName+' playback technology element.', e);
          this.tech.isReady_ = false;
        } else {
          vjs.log(e);
        }
      }
      throw e;
    }
  }

  return;
};

/**
 * start media playback
 *
 *     myPlayer.play();
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.play = function(){
  this.techCall('play');
  return this;
};

/**
 * Pause the video playback
 *
 *     myPlayer.pause();
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.pause = function(){
  this.techCall('pause');
  return this;
};

/**
 * Check if the player is paused
 *
 *     var isPaused = myPlayer.paused();
 *     var isPlaying = !myPlayer.paused();
 *
 * @return {Boolean} false if the media is currently playing, or true otherwise
 */
vjs.Player.prototype.paused = function(){
  // The initial state of paused should be true (in Safari it's actually false)
  return (this.techGet('paused') === false) ? false : true;
};

/**
 * Get or set the current time (in seconds)
 *
 *     // get
 *     var whereYouAt = myPlayer.currentTime();
 *
 *     // set
 *     myPlayer.currentTime(120); // 2 minutes into the video
 *
 * @param  {Number|String=} seconds The time to seek to
 * @return {Number}        The time in seconds, when not setting
 * @return {vjs.Player}    self, when the current time is set
 */
vjs.Player.prototype.currentTime = function(seconds){
  if (seconds !== undefined) {

    this.techCall('setCurrentTime', seconds);

    return this;
  }

  // cache last currentTime and return. default to 0 seconds
  //
  // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
  // currentTime when scrubbing, but may not provide much performace benefit afterall.
  // Should be tested. Also something has to read the actual current time or the cache will
  // never get updated.
  return this.cache_.currentTime = (this.techGet('currentTime') || 0);
};

/**
 * Get the length in time of the video in seconds
 *
 *     var lengthOfVideo = myPlayer.duration();
 *
 * **NOTE**: The video must have started loading before the duration can be
 * known, and in the case of Flash, may not be known until the video starts
 * playing.
 *
 * @return {Number} The duration of the video in seconds
 */
vjs.Player.prototype.duration = function(seconds){
  if (seconds !== undefined) {

    // cache the last set value for optimiized scrubbing (esp. Flash)
    this.cache_.duration = parseFloat(seconds);

    return this;
  }

  if (this.cache_.duration === undefined) {
    this.onDurationChange();
  }

  return this.cache_.duration || 0;
};

/**
 * Calculates how much time is left.
 *
 *     var timeLeft = myPlayer.remainingTime();
 *
 * Not a native video element function, but useful
 * @return {Number} The time remaining in seconds
 */
vjs.Player.prototype.remainingTime = function(){
  return this.duration() - this.currentTime();
};

// http://dev.w3.org/html5/spec/video.html#dom-media-buffered
// Buffered returns a timerange object.
// Kind of like an array of portions of the video that have been downloaded.

/**
 * Get a TimeRange object with the times of the video that have been downloaded
 *
 * If you just want the percent of the video that's been downloaded,
 * use bufferedPercent.
 *
 *     // Number of different ranges of time have been buffered. Usually 1.
 *     numberOfRanges = bufferedTimeRange.length,
 *
 *     // Time in seconds when the first range starts. Usually 0.
 *     firstRangeStart = bufferedTimeRange.start(0),
 *
 *     // Time in seconds when the first range ends
 *     firstRangeEnd = bufferedTimeRange.end(0),
 *
 *     // Length in seconds of the first time range
 *     firstRangeLength = firstRangeEnd - firstRangeStart;
 *
 * @return {Object} A mock TimeRange object (following HTML spec)
 */
vjs.Player.prototype.buffered = function(){
  var buffered = this.techGet('buffered');

  if (!buffered || !buffered.length) {
    buffered = vjs.createTimeRange(0,0);
  }

  return buffered;
};

/**
 * Get the percent (as a decimal) of the video that's been downloaded
 *
 *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
 *
 * 0 means none, 1 means all.
 * (This method isn't in the HTML5 spec, but it's very convenient)
 *
 * @return {Number} A decimal between 0 and 1 representing the percent
 */
vjs.Player.prototype.bufferedPercent = function(){
  var duration = this.duration(),
      buffered = this.buffered(),
      bufferedDuration = 0,
      start, end;

  if (!duration) {
    return 0;
  }

  for (var i=0; i<buffered.length; i++){
    start = buffered.start(i);
    end   = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
};

/**
 * Get the ending time of the last buffered time range
 *
 * This is used in the progress bar to encapsulate all time ranges.
 * @return {Number} The end of the last buffered time range
 */
vjs.Player.prototype.bufferedEnd = function(){
  var buffered = this.buffered(),
      duration = this.duration(),
      end = buffered.end(buffered.length-1);

  if (end > duration) {
    end = duration;
  }

  return end;
};

/**
 * Get or set the current volume of the media
 *
 *     // get
 *     var howLoudIsIt = myPlayer.volume();
 *
 *     // set
 *     myPlayer.volume(0.5); // Set volume to half
 *
 * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
 *
 * @param  {Number} percentAsDecimal The new volume as a decimal percent
 * @return {Number}                  The current volume, when getting
 * @return {vjs.Player}              self, when setting
 */
vjs.Player.prototype.volume = function(percentAsDecimal){
  var vol;

  if (percentAsDecimal !== undefined) {
    vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
    this.cache_.volume = vol;
    this.techCall('setVolume', vol);
    vjs.setLocalStorage('volume', vol);
    return this;
  }

  // Default to 1 when returning current volume.
  vol = parseFloat(this.techGet('volume'));
  return (isNaN(vol)) ? 1 : vol;
};


/**
 * Get the current muted state, or turn mute on or off
 *
 *     // get
 *     var isVolumeMuted = myPlayer.muted();
 *
 *     // set
 *     myPlayer.muted(true); // mute the volume
 *
 * @param  {Boolean=} muted True to mute, false to unmute
 * @return {Boolean} True if mute is on, false if not, when getting
 * @return {vjs.Player} self, when setting mute
 */
vjs.Player.prototype.muted = function(muted){
  if (muted !== undefined) {
    this.techCall('setMuted', muted);
    return this;
  }
  return this.techGet('muted') || false; // Default to false
};

// Check if current tech can support native fullscreen
// (e.g. with built in controls lik iOS, so not our flash swf)
vjs.Player.prototype.supportsFullScreen = function(){
  return this.techGet('supportsFullScreen') || false;
};

/**
 * is the player in fullscreen
 * @type {Boolean}
 * @private
 */
vjs.Player.prototype.isFullscreen_ = false;

/**
 * Check if the player is in fullscreen mode
 *
 *     // get
 *     var fullscreenOrNot = myPlayer.isFullscreen();
 *
 *     // set
 *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
 *
 * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
 * property and instead document.fullscreenElement is used. But isFullscreen is
 * still a valuable property for internal player workings.
 *
 * @param  {Boolean=} isFS Update the player's fullscreen state
 * @return {Boolean} true if fullscreen, false if not
 * @return {vjs.Player} self, when setting
 */
vjs.Player.prototype.isFullscreen = function(isFS){
  if (isFS !== undefined) {
    this.isFullscreen_ = !!isFS;
    return this;
  }
  return this.isFullscreen_;
};

/**
 * Old naming for isFullscreen()
 * @deprecated for lowercase 's' version
 */
vjs.Player.prototype.isFullScreen = function(isFS){
  vjs.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
  return this.isFullscreen(isFS);
};

/**
 * Increase the size of the video to full screen
 *
 *     myPlayer.requestFullscreen();
 *
 * In some browsers, full screen is not supported natively, so it enters
 * "full window mode", where the video fills the browser window.
 * In browsers and devices that support native full screen, sometimes the
 * browser's default controls will be shown, and not the Video.js custom skin.
 * This includes most mobile devices (iOS, Android) and older versions of
 * Safari.
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.requestFullscreen = function(){
  var fsApi = vjs.browser.fullscreenAPI;

  this.isFullscreen(true);

  if (fsApi) {
    // the browser supports going fullscreen at the element level so we can
    // take the controls fullscreen as well as the video

    // Trigger fullscreenchange event after change
    // We have to specifically add this each time, and remove
    // when cancelling fullscreen. Otherwise if there's multiple
    // players on a page, they would all be reacting to the same fullscreen
    // events
    vjs.on(document, fsApi['fullscreenchange'], vjs.bind(this, function(e){
      this.isFullscreen(document[fsApi.fullscreenElement]);

      // If cancelling fullscreen, remove event listener.
      if (this.isFullscreen() === false) {
        vjs.off(document, fsApi['fullscreenchange'], arguments.callee);
      }

      this.trigger('fullscreenchange');
    }));

    this.el_[fsApi.requestFullscreen]();

  } else if (this.tech.supportsFullScreen()) {
    // we can't take the video.js controls fullscreen but we can go fullscreen
    // with native controls
    this.techCall('enterFullScreen');
  } else {
    // fullscreen isn't supported so we'll just stretch the video element to
    // fill the viewport
    this.enterFullWindow();
    this.trigger('fullscreenchange');
  }

  return this;
};

/**
 * Old naming for requestFullscreen
 * @deprecated for lower case 's' version
 */
vjs.Player.prototype.requestFullScreen = function(){
  vjs.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
  return this.requestFullscreen();
};


/**
 * Return the video to its normal size after having been in full screen mode
 *
 *     myPlayer.exitFullscreen();
 *
 * @return {vjs.Player} self
 */
vjs.Player.prototype.exitFullscreen = function(){
  var fsApi = vjs.browser.fullscreenAPI;
  this.isFullscreen(false);

  // Check for browser element fullscreen support
  if (fsApi) {
    document[fsApi.exitFullscreen]();
  } else if (this.tech.supportsFullScreen()) {
   this.techCall('exitFullScreen');
  } else {
   this.exitFullWindow();
   this.trigger('fullscreenchange');
  }

  return this;
};

/**
 * Old naming for exitFullscreen
 * @deprecated for exitFullscreen
 */
vjs.Player.prototype.cancelFullScreen = function(){
  vjs.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
  return this.exitFullscreen();
};

// When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
vjs.Player.prototype.enterFullWindow = function(){
  this.isFullWindow = true;

  // Storing original doc overflow value to return to when fullscreen is off
  this.docOrigOverflow = document.documentElement.style.overflow;

  // Add listener for esc key to exit fullscreen
  vjs.on(document, 'keydown', vjs.bind(this, this.fullWindowOnEscKey));

  // Hide any scroll bars
  document.documentElement.style.overflow = 'hidden';

  // Apply fullscreen styles
  vjs.addClass(document.body, 'vjs-full-window');

  this.trigger('enterFullWindow');
};
vjs.Player.prototype.fullWindowOnEscKey = function(event){
  if (event.keyCode === 27) {
    if (this.isFullscreen() === true) {
      this.exitFullscreen();
    } else {
      this.exitFullWindow();
    }
  }
};

vjs.Player.prototype.exitFullWindow = function(){
  this.isFullWindow = false;
  vjs.off(document, 'keydown', this.fullWindowOnEscKey);

  // Unhide scroll bars.
  document.documentElement.style.overflow = this.docOrigOverflow;

  // Remove fullscreen styles
  vjs.removeClass(document.body, 'vjs-full-window');

  // this.positionAll();
  this.trigger('exitFullWindow');
};

vjs.Player.prototype.selectSource = function(sources){

  // Loop through each playback technology in the options order
  for (var i=0,j=this.options_['techOrder'];i<j.length;i++) {
    var techName = vjs.capitalize(j[i]),
        tech = window['videojs'][techName];

    // Check if the current tech is defined before continuing
    if (!tech) {
      vjs.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      continue;
    }

    // Check if the browser supports this technology
    if (tech.isSupported()) {
      // Loop through each source object
      for (var a=0,b=sources;a<b.length;a++) {
        var source = b[a];

        // Check if source can be played with this technology
        if (tech['canPlaySource'](source)) {
          return { source: source, tech: techName };
        }
      }
    }
  }

  return false;
};

/**
 * The source function updates the video source
 *
 * There are three types of variables you can pass as the argument.
 *
 * **URL String**: A URL to the the video file. Use this method if you are sure
 * the current playback technology (HTML5/Flash) can support the source you
 * provide. Currently only MP4 files can be used in both HTML5 and Flash.
 *
 *     myPlayer.src("http://www.example.com/path/to/video.mp4");
 *
 * **Source Object (or element):** A javascript object containing information
 * about the source file. Use this method if you want the player to determine if
 * it can support the file using the type information.
 *
 *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
 *
 * **Array of Source Objects:** To provide multiple versions of the source so
 * that it can be played using HTML5 across browsers you can use an array of
 * source objects. Video.js will detect which version is supported and load that
 * file.
 *
 *     myPlayer.src([
 *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
 *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
 *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
 *     ]);
 *
 * @param  {String|Object|Array=} source The source URL, object, or array of sources
 * @return {String} The current video source when getting
 * @return {String} The player when setting
 */
vjs.Player.prototype.src = function(source){
  if (source === undefined) {
    return this.techGet('src');
  }

  // case: Array of source objects to choose from and pick the best to play
  if (vjs.obj.isArray(source)) {
    this.sourceList_(source);

  // case: URL String (http://myvideo...)
  } else if (typeof source === 'string') {
    // create a source object from the string
    this.src({ src: source });

  // case: Source object { src: '', type: '' ... }
  } else if (source instanceof Object) {
    // check if the source has a type and the loaded tech cannot play the source
    // if there's no type we'll just try the current tech
    if (source.type && !window['videojs'][this.techName]['canPlaySource'](source)) {
      // create a source list with the current source and send through
      // the tech loop to check for a compatible technology
      this.sourceList_([source]);
    } else {
      this.cache_.src = source.src;
      this.currentType_ = source.type || '';

      // wait until the tech is ready to set the source
      this.ready(function(){
        this.techCall('src', source.src);

        if (this.options_['preload'] == 'auto') {
          this.load();
        }

        if (this.options_['autoplay']) {
          this.play();
        }
      });
    }
  }

  return this;
};

/**
 * Handle an array of source objects
 * @param  {[type]} sources Array of source objects
 * @private
 */
vjs.Player.prototype.sourceList_ = function(sources){
  var sourceTech = this.selectSource(sources),
      errorTimeout;

  if (sourceTech) {
    if (sourceTech.tech === this.techName) {
      // if this technology is already loaded, set the source
      this.src(sourceTech.source);
    } else {
      // load this technology with the chosen source
      this.loadTech(sourceTech.tech, sourceTech.source);
    }
  } else {
    // We need to wrap this in a timeout to give folks a chance to add error event handlers
    errorTimeout = setTimeout(vjs.bind(this, function() {
      this.error({ code: 4, message: this.localize(this.options()['notSupportedMessage']) });
    }), 0);

    // we could not find an appropriate tech, but let's still notify the delegate that this is it
    // this needs a better comment about why this is needed
    this.triggerReady();

    this.on('dispose', function() {
      clearTimeout(errorTimeout);
    });
  }
};

/**
 * Begin loading the src data.
 * @return {vjs.Player} Returns the player
 */
vjs.Player.prototype.load = function(){
  this.techCall('load');
  return this;
};

/**
 * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
 * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
 * @return {String} The current source
 */
vjs.Player.prototype.currentSrc = function(){
  return this.techGet('currentSrc') || this.cache_.src || '';
};

/**
 * Get the current source type e.g. video/mp4
 * This can allow you rebuild the current source object so that you could load the same
 * source and tech later
 * @return {String} The source MIME type
 */
vjs.Player.prototype.currentType = function(){
    return this.currentType_ || '';
};

/**
 * Get or set the preload attribute.
 * @return {String} The preload attribute value when getting
 * @return {vjs.Player} Returns the player when setting
 */
vjs.Player.prototype.preload = function(value){
  if (value !== undefined) {
    this.techCall('setPreload', value);
    this.options_['preload'] = value;
    return this;
  }
  return this.techGet('preload');
};

/**
 * Get or set the autoplay attribute.
 * @return {String} The autoplay attribute value when getting
 * @return {vjs.Player} Returns the player when setting
 */
vjs.Player.prototype.autoplay = function(value){
  if (value !== undefined) {
    this.techCall('setAutoplay', value);
    this.options_['autoplay'] = value;
    return this;
  }
  return this.techGet('autoplay', value);
};

/**
 * Get or set the loop attribute on the video element.
 * @return {String} The loop attribute value when getting
 * @return {vjs.Player} Returns the player when setting
 */
vjs.Player.prototype.loop = function(value){
  if (value !== undefined) {
    this.techCall('setLoop', value);
    this.options_['loop'] = value;
    return this;
  }
  return this.techGet('loop');
};



/**
 * Whether or not the controls are showing
 * @type {Boolean}
 * @private
 */
vjs.Player.prototype.controls_;

/**
 * Get or set whether or not the controls are showing.
 * @param  {Boolean} controls Set controls to showing or not
 * @return {Boolean}    Controls are showing
 */
vjs.Player.prototype.controls = function(bool){
  if (bool !== undefined) {
    bool = !!bool; // force boolean
    // Don't trigger a change event unless it actually changed
    if (this.controls_ !== bool) {
      this.controls_ = bool;
      if (bool) {
        this.removeClass('vjs-controls-disabled');
        this.addClass('vjs-controls-enabled');
        this.trigger('controlsenabled');
      } else {
        this.removeClass('vjs-controls-enabled');
        this.addClass('vjs-controls-disabled');
        this.trigger('controlsdisabled');
      }
    }
    return this;
  }
  return this.controls_;
};

vjs.Player.prototype.usingNativeControls_;

/**
 * Toggle native controls on/off. Native controls are the controls built into
 * devices (e.g. default iPhone controls), Flash, or other techs
 * (e.g. Vimeo Controls)
 *
 * **This should only be set by the current tech, because only the tech knows
 * if it can support native controls**
 *
 * @param  {Boolean} bool    True signals that native controls are on
 * @return {vjs.Player}      Returns the player
 * @private
 */
vjs.Player.prototype.usingNativeControls = function(bool){
  if (bool !== undefined) {
    bool = !!bool; // force boolean
    // Don't trigger a change event unless it actually changed
    if (this.usingNativeControls_ !== bool) {
      this.usingNativeControls_ = bool;
      if (bool) {
        this.addClass('vjs-using-native-controls');

        /**
         * player is using the native device controls
         *
         * @event usingnativecontrols
         * @memberof vjs.Player
         * @instance
         * @private
         */
        this.trigger('usingnativecontrols');
      } else {
        this.removeClass('vjs-using-native-controls');

        /**
         * player is using the custom HTML controls
         *
         * @event usingcustomcontrols
         * @memberof vjs.Player
         * @instance
         * @private
         */
        this.trigger('usingcustomcontrols');
      }
    }
    return this;
  }
  return this.usingNativeControls_;
};

/**
 * Store the current media error
 * @type {Object}
 * @private
 */
vjs.Player.prototype.error_ = null;

/**
 * Set or get the current MediaError
 * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
 * @return {vjs.MediaError|null}     when getting
 * @return {vjs.Player}              when setting
 */
vjs.Player.prototype.error = function(err){
  if (err === undefined) {
    return this.error_;
  }

  // restoring to default
  if (err === null) {
    this.error_ = err;
    this.removeClass('vjs-error');
    return this;
  }

  // error instance
  if (err instanceof vjs.MediaError) {
    this.error_ = err;
  } else {
    this.error_ = new vjs.MediaError(err);
  }

  // fire an error event on the player
  this.trigger('error');

  // add the vjs-error classname to the player
  this.addClass('vjs-error');

  // log the name of the error type and any message
  // ie8 just logs "[object object]" if you just log the error object
  vjs.log.error('(CODE:'+this.error_.code+' '+vjs.MediaError.errorTypes[this.error_.code]+')', this.error_.message, this.error_);

  return this;
};

/**
 * Returns whether or not the player is in the "ended" state.
 * @return {Boolean} True if the player is in the ended state, false if not.
 */
vjs.Player.prototype.ended = function(){ return this.techGet('ended'); };

/**
 * Returns whether or not the player is in the "seeking" state.
 * @return {Boolean} True if the player is in the seeking state, false if not.
 */
vjs.Player.prototype.seeking = function(){ return this.techGet('seeking'); };

// When the player is first initialized, trigger activity so components
// like the control bar show themselves if needed
vjs.Player.prototype.userActivity_ = true;
vjs.Player.prototype.reportUserActivity = function(event){
  this.userActivity_ = true;
};

vjs.Player.prototype.userActive_ = true;
vjs.Player.prototype.userActive = function(bool){
  if (bool !== undefined) {
    bool = !!bool;
    if (bool !== this.userActive_) {
      this.userActive_ = bool;
      if (bool) {
        // If the user was inactive and is now active we want to reset the
        // inactivity timer
        this.userActivity_ = true;
        this.removeClass('vjs-user-inactive');
        this.addClass('vjs-user-active');
        this.trigger('useractive');
      } else {
        // We're switching the state to inactive manually, so erase any other
        // activity
        this.userActivity_ = false;

        // Chrome/Safari/IE have bugs where when you change the cursor it can
        // trigger a mousemove event. This causes an issue when you're hiding
        // the cursor when the user is inactive, and a mousemove signals user
        // activity. Making it impossible to go into inactive mode. Specifically
        // this happens in fullscreen when we really need to hide the cursor.
        //
        // When this gets resolved in ALL browsers it can be removed
        // https://code.google.com/p/chromium/issues/detail?id=103041
        if(this.tech) {
          this.tech.one('mousemove', function(e){
            e.stopPropagation();
            e.preventDefault();
          });
        }

        this.removeClass('vjs-user-active');
        this.addClass('vjs-user-inactive');
        this.trigger('userinactive');
      }
    }
    return this;
  }
  return this.userActive_;
};

vjs.Player.prototype.listenForUserActivity = function(){
  var onActivity, onMouseMove, onMouseDown, mouseInProgress, onMouseUp,
      activityCheck, inactivityTimeout, lastMoveX, lastMoveY;

  onActivity = vjs.bind(this, this.reportUserActivity);

  onMouseMove = function(e) {
    // #1068 - Prevent mousemove spamming
    // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
    if(e.screenX != lastMoveX || e.screenY != lastMoveY) {
      lastMoveX = e.screenX;
      lastMoveY = e.screenY;
      onActivity();
    }
  };

  onMouseDown = function() {
    onActivity();
    // For as long as the they are touching the device or have their mouse down,
    // we consider them active even if they're not moving their finger or mouse.
    // So we want to continue to update that they are active
    clearInterval(mouseInProgress);
    // Setting userActivity=true now and setting the interval to the same time
    // as the activityCheck interval (250) should ensure we never miss the
    // next activityCheck
    mouseInProgress = setInterval(onActivity, 250);
  };

  onMouseUp = function(event) {
    onActivity();
    // Stop the interval that maintains activity if the mouse/touch is down
    clearInterval(mouseInProgress);
  };

  // Any mouse movement will be considered user activity
  this.on('mousedown', onMouseDown);
  this.on('mousemove', onMouseMove);
  this.on('mouseup', onMouseUp);

  // Listen for keyboard navigation
  // Shouldn't need to use inProgress interval because of key repeat
  this.on('keydown', onActivity);
  this.on('keyup', onActivity);

  // Run an interval every 250 milliseconds instead of stuffing everything into
  // the mousemove/touchmove function itself, to prevent performance degradation.
  // `this.reportUserActivity` simply sets this.userActivity_ to true, which
  // then gets picked up by this loop
  // http://ejohn.org/blog/learning-from-twitter/
  activityCheck = setInterval(vjs.bind(this, function() {
    // Check to see if mouse/touch activity has happened
    if (this.userActivity_) {
      // Reset the activity tracker
      this.userActivity_ = false;

      // If the user state was inactive, set the state to active
      this.userActive(true);

      // Clear any existing inactivity timeout to start the timer over
      clearTimeout(inactivityTimeout);

      var timeout = this.options()['inactivityTimeout'];
      if (timeout > 0) {
          // In <timeout> milliseconds, if no more activity has occurred the
          // user will be considered inactive
          inactivityTimeout = setTimeout(vjs.bind(this, function () {
              // Protect against the case where the inactivityTimeout can trigger just
              // before the next user activity is picked up by the activityCheck loop
              // causing a flicker
              if (!this.userActivity_) {
                  this.userActive(false);
              }
          }), timeout);
      }
    }
  }), 250);

  // Clean up the intervals when we kill the player
  this.on('dispose', function(){
    clearInterval(activityCheck);
    clearTimeout(inactivityTimeout);
  });
};

/**
 * Gets or sets the current playback rate.
 * @param  {Boolean} rate   New playback rate to set.
 * @return {Number}         Returns the new playback rate when setting
 * @return {Number}         Returns the current playback rate when getting
 */
vjs.Player.prototype.playbackRate = function(rate) {
  if (rate !== undefined) {
    this.techCall('setPlaybackRate', rate);
    return this;
  }

  if (this.tech && this.tech['featuresPlaybackRate']) {
    return this.techGet('playbackRate');
  } else {
    return 1.0;
  }

};

/**
 * Store the current audio state
 * @type {Boolean}
 * @private
 */
vjs.Player.prototype.isAudio_ = false;

/**
 * Gets or sets the audio flag
 *
 * @param  {Boolean} bool    True signals that this is an audio player.
 * @return {Boolean}         Returns true if player is audio, false if not when getting
 * @return {vjs.Player}      Returns the player if setting
 * @private
 */
vjs.Player.prototype.isAudio = function(bool) {
  if (bool !== undefined) {
    this.isAudio_ = !!bool;
    return this;
  }

  return this.isAudio_;
};

// Methods to add support for
// networkState: function(){ return this.techCall('networkState'); },
// readyState: function(){ return this.techCall('readyState'); },
// initialTime: function(){ return this.techCall('initialTime'); },
// startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
// played: function(){ return this.techCall('played'); },
// seekable: function(){ return this.techCall('seekable'); },
// videoTracks: function(){ return this.techCall('videoTracks'); },
// audioTracks: function(){ return this.techCall('audioTracks'); },
// videoWidth: function(){ return this.techCall('videoWidth'); },
// videoHeight: function(){ return this.techCall('videoHeight'); },
// defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
// mediaGroup: function(){ return this.techCall('mediaGroup'); },
// controller: function(){ return this.techCall('controller'); },
// defaultMuted: function(){ return this.techCall('defaultMuted'); }

// TODO
// currentSrcList: the array of sources including other formats and bitrates
// playList: array of source lists in order of playback
/**
 * Container of main controls
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 * @extends vjs.Component
 */
vjs.ControlBar = vjs.Component.extend();

vjs.ControlBar.prototype.options_ = {
  loadEvent: 'play',
  children: {
    'playToggle': {},
    'progressControl': {},
    'fullscreenToggle': {},
    'volumeControl': {},
    'muteToggle': {},
    'playbackRateMenuButton': {}
  }
};

vjs.ControlBar.prototype.createEl = function(){
  return vjs.createEl('div', {
    className: 'vjs-control-bar'
  });
};

/**
 * Button to toggle between play and pause
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */
vjs.PlayToggle = vjs.Button.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Button.call(this, player, options);

    this.on(player, 'play', this.onPlay);
    this.on(player, 'pause', this.onPause);
  }
});

vjs.PlayToggle.prototype.buttonText = 'Play';

vjs.PlayToggle.prototype.buildCSSClass = function(){
  return 'vjs-play-control ' + vjs.Button.prototype.buildCSSClass.call(this);
};

// OnClick - Toggle between play and pause
vjs.PlayToggle.prototype.onClick = function(){
  if (this.player_.paused()) {
    this.player_.play();
  } else {
    this.player_.pause();
  }
};

  // OnPlay - Add the vjs-playing class to the element so it can change appearance
vjs.PlayToggle.prototype.onPlay = function(){
  this.removeClass('vjs-paused');
  this.addClass('vjs-playing');
  this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
};

  // OnPause - Add the vjs-paused class to the element so it can change appearance
vjs.PlayToggle.prototype.onPause = function(){
  this.removeClass('vjs-playing');
  this.addClass('vjs-paused');
  this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
};


/**
 * Toggle fullscreen video
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @extends vjs.Button
 */
vjs.FullscreenToggle = vjs.Button.extend({
  /**
   * @constructor
   * @memberof vjs.FullscreenToggle
   * @instance
   */
  init: function(player, options){
    vjs.Button.call(this, player, options);
  }
});

vjs.FullscreenToggle.prototype.buttonText = 'Fullscreen';

vjs.FullscreenToggle.prototype.buildCSSClass = function(){
  return 'vjs-fullscreen-control ' + vjs.Button.prototype.buildCSSClass.call(this);
};

vjs.FullscreenToggle.prototype.onClick = function(){
  // if (!this.player_.isFullscreen()) {
  //   this.player_.requestFullscreen();
  //   this.controlText_.innerHTML = this.localize('Non-Fullscreen');
  // } else {
  //   this.player_.exitFullscreen();
  //   this.controlText_.innerHTML = this.localize('Fullscreen');
  // }
};
/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.ProgressControl = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
  }
});

vjs.ProgressControl.prototype.options_ = {
  children: {
    'seekBar': {}
  }
};

vjs.ProgressControl.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-progress-control vjs-control'
  });
};

/**
 * Seek Bar and holder for the progress bars
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.SeekBar = vjs.Slider.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Slider.call(this, player, options);
    this.on(player, 'timeupdate', this.updateARIAAttributes);
    player.ready(vjs.bind(this, this.updateARIAAttributes));
  }
});

vjs.SeekBar.prototype.options_ = {
  children: {
    'loadProgressBar': {},
    'playProgressBar': {},
    'seekHandle': {}
  },
  'barName': 'playProgressBar',
  'handleName': 'seekHandle'
};

vjs.SeekBar.prototype.playerEvent = 'timeupdate';

vjs.SeekBar.prototype.createEl = function(){
  return vjs.Slider.prototype.createEl.call(this, 'div', {
    className: 'vjs-progress-holder',
    'aria-label': 'video progress bar'
  });
};

vjs.SeekBar.prototype.updateARIAAttributes = function(){
    // Allows for smooth scrubbing, when player can't keep up.
    var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
    this.el_.setAttribute('aria-valuenow',vjs.round(this.getPercent()*100, 2)); // machine readable value of progress bar (percentage complete)
    this.el_.setAttribute('aria-valuetext',vjs.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)
};

vjs.SeekBar.prototype.getPercent = function(){
  return this.player_.currentTime() / this.player_.duration();
};

vjs.SeekBar.prototype.onMouseDown = function(event){
  vjs.Slider.prototype.onMouseDown.call(this, event);

  this.player_.scrubbing = true;

  this.videoWasPlaying = !this.player_.paused();
  this.player_.pause();
};

vjs.SeekBar.prototype.onMouseMove = function(event){
  var newTime = this.calculateDistance(event) * this.player_.duration();

  // Don't let video end while scrubbing.
  if (newTime == this.player_.duration()) { newTime = newTime - 0.1; }

  // Set new time (tell player to seek to new time)
  this.player_.currentTime(newTime);
};

vjs.SeekBar.prototype.onMouseUp = function(event){
  vjs.Slider.prototype.onMouseUp.call(this, event);

  this.player_.scrubbing = false;
  if (this.videoWasPlaying) {
    this.player_.play();
  }
};

vjs.SeekBar.prototype.stepForward = function(){
  this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
};

vjs.SeekBar.prototype.stepBack = function(){
  this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users
};

/**
 * Shows load progress
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.LoadProgressBar = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
    this.on(player, 'progress', this.update);
  }
});

vjs.LoadProgressBar.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-load-progress',
    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
  });
};

vjs.LoadProgressBar.prototype.update = function(){
  var i, start, end, part,
      buffered = this.player_.buffered(),
      duration = this.player_.duration(),
      bufferedEnd = this.player_.bufferedEnd(),
      children = this.el_.children,
      // get the percent width of a time compared to the total end
      percentify = function (time, end){
        var percent = (time / end) || 0; // no NaN
        return (percent * 100) + '%';
      };

  // update the width of the progress bar
  this.el_.style.width = percentify(bufferedEnd, duration);

  // add child elements to represent the individual buffered time ranges
  for (i = 0; i < buffered.length; i++) {
    start = buffered.start(i),
    end = buffered.end(i),
    part = children[i];

    if (!part) {
      part = this.el_.appendChild(vjs.createEl())
    };

    // set the percent based on the width of the progress bar (bufferedEnd)
    part.style.left = percentify(start, bufferedEnd);
    part.style.width = percentify(end - start, bufferedEnd);
  };

  // remove unused buffered range elements
  for (i = children.length; i > buffered.length; i--) {
    this.el_.removeChild(children[i-1]);
  }
};

/**
 * Shows play progress
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.PlayProgressBar = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
  }
});

vjs.PlayProgressBar.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-play-progress',
    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
  });
};

/**
 * The Seek Handle shows the current position of the playhead during playback,
 * and can be dragged to adjust the playhead.
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.SeekHandle = vjs.SliderHandle.extend({
  init: function(player, options) {
    vjs.SliderHandle.call(this, player, options);
    this.on(player, 'timeupdate', this.updateContent);
  }
});

/**
 * The default value for the handle content, which may be read by screen readers
 *
 * @type {String}
 * @private
 */
vjs.SeekHandle.prototype.defaultValue = '00:00';

/** @inheritDoc */
vjs.SeekHandle.prototype.createEl = function() {
  return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
    className: 'vjs-seek-handle',
    'aria-live': 'off'
  });
};

vjs.SeekHandle.prototype.updateContent = function() {
  var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
  this.el_.innerHTML = '<span class="vjs-control-text">' + vjs.formatTime(time, this.player_.duration()) + '</span>';
};
/**
 * The component for controlling the volume level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.VolumeControl = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    // hide volume controls when they're not supported by the current tech
    if (player.tech && player.tech['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function(){
      if (player.tech['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }
});

vjs.VolumeControl.prototype.options_ = {
  children: {
    'volumeBar': {}
  }
};

vjs.VolumeControl.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-volume-control vjs-control'
  });
};

/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.VolumeBar = vjs.Slider.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Slider.call(this, player, options);
    this.on(player, 'volumechange', this.updateARIAAttributes);
    player.ready(vjs.bind(this, this.updateARIAAttributes));
  }
});

vjs.VolumeBar.prototype.updateARIAAttributes = function(){
  // Current value of volume bar as a percentage
  this.el_.setAttribute('aria-valuenow',vjs.round(this.player_.volume()*100, 2));
  this.el_.setAttribute('aria-valuetext',vjs.round(this.player_.volume()*100, 2)+'%');
};

vjs.VolumeBar.prototype.options_ = {
  children: {
    'volumeLevel': {},
    'volumeHandle': {}
  },
  'barName': 'volumeLevel',
  'handleName': 'volumeHandle'
};

vjs.VolumeBar.prototype.playerEvent = 'volumechange';

vjs.VolumeBar.prototype.createEl = function(){
  return vjs.Slider.prototype.createEl.call(this, 'div', {
    className: 'vjs-volume-bar',
    'aria-label': 'volume level'
  });
};

vjs.VolumeBar.prototype.onMouseMove = function(event) {
  if (this.player_.muted()) {
    this.player_.muted(false);
  }

  this.player_.volume(this.calculateDistance(event));
};

vjs.VolumeBar.prototype.getPercent = function(){
  if (this.player_.muted()) {
    return 0;
  } else {
    return this.player_.volume();
  }
};

vjs.VolumeBar.prototype.stepForward = function(){
  this.player_.volume(this.player_.volume() + 0.1);
};

vjs.VolumeBar.prototype.stepBack = function(){
  this.player_.volume(this.player_.volume() - 0.1);
};

/**
 * Shows volume level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.VolumeLevel = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);
  }
});

vjs.VolumeLevel.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-volume-level',
    innerHTML: '<span class="vjs-control-text"></span>'
  });
};

/**
 * The volume handle can be dragged to adjust the volume level
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
 vjs.VolumeHandle = vjs.SliderHandle.extend();

 vjs.VolumeHandle.prototype.defaultValue = '00:00';

 /** @inheritDoc */
 vjs.VolumeHandle.prototype.createEl = function(){
   return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
     className: 'vjs-volume-handle'
   });
 };
/**
 * A button component for muting the audio
 *
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.MuteToggle = vjs.Button.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Button.call(this, player, options);

    this.on(player, 'volumechange', this.update);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }

    this.on(player, 'loadstart', function(){
      if (player.tech['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }
});

vjs.MuteToggle.prototype.createEl = function(){
  return vjs.Button.prototype.createEl.call(this, 'div', {
    className: 'vjs-mute-control vjs-control',
    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
  });
};

vjs.MuteToggle.prototype.onClick = function(){
  this.player_.muted( this.player_.muted() ? false : true );
};

vjs.MuteToggle.prototype.update = function(){
  var vol = this.player_.volume(),
      level = 3;

  if (vol === 0 || this.player_.muted()) {
    level = 0;
  } else if (vol < 0.33) {
    level = 1;
  } else if (vol < 0.67) {
    level = 2;
  }

  // Don't rewrite the button text if the actual text doesn't change.
  // This causes unnecessary and confusing information for screen reader users.
  // This check is needed because this function gets called every time the volume level is changed.
  if(this.player_.muted()){
      if(this.el_.children[0].children[0].innerHTML!=this.localize('Unmute')){
          this.el_.children[0].children[0].innerHTML = this.localize('Unmute'); // change the button text to "Unmute"
      }
  } else {
      if(this.el_.children[0].children[0].innerHTML!=this.localize('Mute')){
          this.el_.children[0].children[0].innerHTML = this.localize('Mute'); // change the button text to "Mute"
      }
  }

  /* TODO improve muted icon classes */
  for (var i = 0; i < 4; i++) {
    vjs.removeClass(this.el_, 'vjs-vol-'+i);
  }
  vjs.addClass(this.el_, 'vjs-vol-'+level);
};

/* Loading Spinner
================================================================================ */
/**
 * Loading spinner for waiting events
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */
vjs.LoadingSpinner = vjs.Component.extend({
  /** @constructor */
  init: function(player, options){
    vjs.Component.call(this, player, options);

    // MOVING DISPLAY HANDLING TO CSS

    // player.on('canplay', vjs.bind(this, this.hide));
    // player.on('canplaythrough', vjs.bind(this, this.hide));
    // player.on('playing', vjs.bind(this, this.hide));
    // player.on('seeking', vjs.bind(this, this.show));

    // in some browsers seeking does not trigger the 'playing' event,
    // so we also need to trap 'seeked' if we are going to set a
    // 'seeking' event
    // player.on('seeked', vjs.bind(this, this.hide));

    // player.on('ended', vjs.bind(this, this.hide));

    // Not showing spinner on stalled any more. Browsers may stall and then not trigger any events that would remove the spinner.
    // Checked in Chrome 16 and Safari 5.1.2. http://help.videojs.com/discussions/problems/883-why-is-the-download-progress-showing
    // player.on('stalled', vjs.bind(this, this.show));

    // player.on('waiting', vjs.bind(this, this.show));
  }
});

vjs.LoadingSpinner.prototype.createEl = function(){
  return vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-loading-spinner'
  });
};

/**
 * Display that an error has occurred making the video unplayable
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @constructor
 */
vjs.ErrorDisplay = vjs.Component.extend({
  init: function(player, options){
    vjs.Component.call(this, player, options);

    this.update();
    this.on(player, 'error', this.update);
  }
});

vjs.ErrorDisplay.prototype.createEl = function(){
  var el = vjs.Component.prototype.createEl.call(this, 'div', {
    className: 'vjs-error-display'
  });

  this.contentEl_ = vjs.createEl('div');
  el.appendChild(this.contentEl_);

  return el;
};

vjs.ErrorDisplay.prototype.update = function(){
  if (this.player().error()) {
    this.contentEl_.innerHTML = this.localize(this.player().error().message);
  }
};
/**
 * @fileoverview Media Technology Controller - Base class for media playback
 * technology controllers like Flash and HTML5
 */

/**
 * Base class for media (HTML5 Video, Flash) controllers
 * @param {vjs.Player|Object} player  Central player instance
 * @param {Object=} options Options object
 * @constructor
 */
vjs.MediaTechController = vjs.Component.extend({
  /** @constructor */
  init: function(player, options, ready){
    options = options || {};
    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;
    vjs.Component.call(this, player, options, ready);

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!this['featuresProgressEvents']) {
      this.manualProgressOn();
    }

    // Manually track timeudpates in cases where the browser/flash player doesn't report it.
    if (!this['featuresTimeupdateEvents']) {
      this.manualTimeUpdatesOn();
    }

    this.initControlsListeners();
  }
});

/**
 * Set up click and touch listeners for the playback element
 * On desktops, a click on the video itself will toggle playback,
 * on a mobile device a click on the video toggles controls.
 * (toggling controls is done by toggling the user state between active and
 * inactive)
 *
 * A tap can signal that a user has become active, or has become inactive
 * e.g. a quick tap on an iPhone movie should reveal the controls. Another
 * quick tap should hide them again (signaling the user is in an inactive
 * viewing state)
 *
 * In addition to this, we still want the user to be considered inactive after
 * a few seconds of inactivity.
 *
 * Note: the only part of iOS interaction we can't mimic with this setup
 * is a touch and hold on the video element counting as activity in order to
 * keep the controls showing, but that shouldn't be an issue. A touch and hold on
 * any controls will still keep the user active
 */
vjs.MediaTechController.prototype.initControlsListeners = function(){
  var player, activateControls;

  player = this.player();

  activateControls = function(){
    if (player.controls() && !player.usingNativeControls()) {
      this.addControlsListeners();
    }
  };

  // Set up event listeners once the tech is ready and has an element to apply
  // listeners to
  this.ready(activateControls);
  this.on(player, 'controlsenabled', activateControls);
  this.on(player, 'controlsdisabled', this.removeControlsListeners);

  // if we're loading the playback object after it has started loading or playing the
  // video (often with autoplay on) then the loadstart event has already fired and we
  // need to fire it manually because many things rely on it.
  // Long term we might consider how we would do this for other events like 'canplay'
  // that may also have fired.
  this.ready(function(){
    if (this.networkState && this.networkState() > 0) {
      this.player().trigger('loadstart');
    }
  });
};

vjs.MediaTechController.prototype.addControlsListeners = function(){
  var userWasActive;

  // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
  // trigger mousedown/up.
  // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
  // Any touch events are set to block the mousedown event from happening
  this.on('mousedown', this.onClick);

  // If the controls were hidden we don't want that to change without a tap event
  // so we'll check if the controls were already showing before reporting user
  // activity
  this.on('touchstart', function(event) {
    userWasActive = this.player_.userActive();
  });

  this.on('touchmove', function(event) {
    if (userWasActive){
      this.player().reportUserActivity();
    }
  });

  this.on('touchend', function(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  });

  // Turn on component tap events
  this.emitTapEvents();

  // The tap listener needs to come after the touchend listener because the tap
  // listener cancels out any reportedUserActivity when setting userActive(false)
  this.on('tap', this.onTap);
};

/**
 * Remove the listeners used for click and tap controls. This is needed for
 * toggling to controls disabled, where a tap/touch should do nothing.
 */
vjs.MediaTechController.prototype.removeControlsListeners = function(){
  // We don't want to just use `this.off()` because there might be other needed
  // listeners added by techs that extend this.
  this.off('tap');
  this.off('touchstart');
  this.off('touchmove');
  this.off('touchleave');
  this.off('touchcancel');
  this.off('touchend');
  this.off('click');
  this.off('mousedown');
};

/**
 * Handle a click on the media element. By default will play/pause the media.
 */
vjs.MediaTechController.prototype.onClick = function(event){
  // We're using mousedown to detect clicks thanks to Flash, but mousedown
  // will also be triggered with right-clicks, so we need to prevent that
  if (event.button !== 0) return;

  // When controls are disabled a click should not toggle playback because
  // the click is considered a control
  if (this.player().controls()) {
    if (this.player().paused()) {
      this.player().play();
    } else {
      this.player().pause();
    }
  }
};

/**
 * Handle a tap on the media element. By default it will toggle the user
 * activity state, which hides and shows the controls.
 */
vjs.MediaTechController.prototype.onTap = function(){
  this.player().userActive(!this.player().userActive());
};

/* Fallbacks for unsupported event types
================================================================================ */
// Manually trigger progress events based on changes to the buffered amount
// Many flash players and older HTML5 browsers don't send progress or progress-like events
vjs.MediaTechController.prototype.manualProgressOn = function(){
  this.manualProgress = true;

  // Trigger progress watching when a source begins loading
  this.trackProgress();
};

vjs.MediaTechController.prototype.manualProgressOff = function(){
  this.manualProgress = false;
  this.stopTrackingProgress();
};

vjs.MediaTechController.prototype.trackProgress = function(){

  this.progressInterval = setInterval(vjs.bind(this, function(){
    // Don't trigger unless buffered amount is greater than last time

    var bufferedPercent = this.player().bufferedPercent();

    if (this.bufferedPercent_ != bufferedPercent) {
      this.player().trigger('progress');
    }

    this.bufferedPercent_ = bufferedPercent;

    if (bufferedPercent === 1) {
      this.stopTrackingProgress();
    }
  }), 500);
};
vjs.MediaTechController.prototype.stopTrackingProgress = function(){ clearInterval(this.progressInterval); };

/*! Time Tracking -------------------------------------------------------------- */
vjs.MediaTechController.prototype.manualTimeUpdatesOn = function(){
  var player = this.player_;

  this.manualTimeUpdates = true;

  this.on(player, 'play', this.trackCurrentTime);
  this.on(player, 'pause', this.stopTrackingCurrentTime);
  // timeupdate is also called by .currentTime whenever current time is set

  // Watch for native timeupdate event
  this.one('timeupdate', function(){
    // Update known progress support for this playback technology
    this['featuresTimeupdateEvents'] = true;
    // Turn off manual progress tracking
    this.manualTimeUpdatesOff();
  });
};

vjs.MediaTechController.prototype.manualTimeUpdatesOff = function(){
  this.manualTimeUpdates = false;
  this.stopTrackingCurrentTime();
  this.off('play', this.trackCurrentTime);
  this.off('pause', this.stopTrackingCurrentTime);
};

vjs.MediaTechController.prototype.trackCurrentTime = function(){
  if (this.currentTimeInterval) { this.stopTrackingCurrentTime(); }
  this.currentTimeInterval = setInterval(vjs.bind(this, function(){
    this.player().trigger('timeupdate');
  }), 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
};

// Turn off play progress tracking (when paused or dragging)
vjs.MediaTechController.prototype.stopTrackingCurrentTime = function(){
  clearInterval(this.currentTimeInterval);

  // #1002 - if the video ends right before the next timeupdate would happen,
  // the progress bar won't make it all the way to the end
  this.player().trigger('timeupdate');
};

vjs.MediaTechController.prototype.dispose = function() {
  // Turn off any manual progress or timeupdate tracking
  if (this.manualProgress) { this.manualProgressOff(); }

  if (this.manualTimeUpdates) { this.manualTimeUpdatesOff(); }

  vjs.Component.prototype.dispose.call(this);
};

vjs.MediaTechController.prototype.setCurrentTime = function() {
  // improve the accuracy of manual timeupdates
  if (this.manualTimeUpdates) { this.player().trigger('timeupdate'); }
};

/**
 * Provide a default setPoster method for techs
 *
 */

vjs.MediaTechController.prototype['featuresVolumeControl'] = true;

// Resizing plugins using request fullscreen reloads the plugin
vjs.MediaTechController.prototype['featuresFullscreenResize'] = false;
vjs.MediaTechController.prototype['featuresPlaybackRate'] = false;

// Optional events that we can manually mimic with timers
// currently not triggered by video-js-swf
vjs.MediaTechController.prototype['featuresProgressEvents'] = false;
vjs.MediaTechController.prototype['featuresTimeupdateEvents'] = false;

vjs.media = {};
/**
 * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
 */

/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 * @param {vjs.Player|Object} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */
vjs.Html5 = vjs.MediaTechController.extend({
  /** @constructor */
  init: function(player, options, ready){
    // volume cannot be changed from 1 on iOS
    this['featuresVolumeControl'] = vjs.Html5.canControlVolume();

    // just in case; or is it excessively...
    this['featuresPlaybackRate'] = vjs.Html5.canControlPlaybackRate();

    // In iOS, if you move a video element in the DOM, it breaks video playback.
    this['movingMediaElementInDOM'] = !vjs.IS_IOS;

    // HTML video is able to automatically resize when going to fullscreen
    this['featuresFullscreenResize'] = true;

    // HTML video supports progress events
    this['featuresProgressEvents'] = true;

    vjs.MediaTechController.call(this, player, options, ready);
    this.setupTriggers();

    var source = options['source'];

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (this.el_.currentSrc !== source.src) || (player.tag && player.tag.initNetworkState_ === 3)) {
      this.el_.src = source.src;
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if (vjs.TOUCH_ENABLED && player.options()['nativeControlsForTouch'] === true) {
      this.useNativeControls();
    }

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    player.ready(function(){
      if (this.tag && this.options_['autoplay'] && this.paused()) {
        this.play();
      }
    });

    this.triggerReady();
  }
});

vjs.Html5.prototype.dispose = function(){
  vjs.Html5.disposeMediaElement(this.el_);
  vjs.MediaTechController.prototype.dispose.call(this);
};

vjs.Html5.prototype.createEl = function(){
  var player = this.player_,
      // If possible, reuse original tag for HTML5 playback technology element
      el = player.tag,
      newEl,
      clone;

  // Check if this browser supports moving the element into the box.
  // On the iPhone video will break if you move the element,
  // So we have to create a brand new element.
  if (!el || this['movingMediaElementInDOM'] === false) {

    // If the original tag is still there, clone and remove it.
    if (el) {
      clone = el.cloneNode(false);
      vjs.Html5.disposeMediaElement(el);
      el = clone;
      player.tag = null;
    } else {
      el = vjs.createEl('video');
      vjs.setElementAttributes(el,
        vjs.obj.merge(player.tagAttributes || {}, {
          id:player.id() + '_html5_api',
          'class':'vjs-tech'
        })
      );
    }
    // associate the player with the new tag
    el['player'] = player;

    vjs.insertFirst(el, player.el());
  }

  // Update specific tag settings, in case they were overridden
  var settingsAttrs = ['autoplay','preload','loop','muted'];
  for (var i = settingsAttrs.length - 1; i >= 0; i--) {
    var attr = settingsAttrs[i];
    var overwriteAttrs = {};
    if (typeof player.options_[attr] !== 'undefined') {
      overwriteAttrs[attr] = player.options_[attr];
    }
    vjs.setElementAttributes(el, overwriteAttrs);
  }

  return el;
  // jenniisawesome = true;
};

// Make video events trigger player events
// May seem verbose here, but makes other APIs possible.
// Triggers removed using this.off when disposed
vjs.Html5.prototype.setupTriggers = function(){
  for (var i = vjs.Html5.Events.length - 1; i >= 0; i--) {
    this.on(vjs.Html5.Events[i], this.eventHandler);
  }
};

vjs.Html5.prototype.eventHandler = function(evt){
  // In the case of an error on the video element, set the error prop
  // on the player and let the player handle triggering the event. On
  // some platforms, error events fire that do not cause the error
  // property on the video element to be set. See #1465 for an example.
  if (evt.type == 'error' && this.error()) {
    this.player().error(this.error().code);

  // in some cases we pass the event directly to the player
  } else {
    // No need for media events to bubble up.
    evt.bubbles = false;

    this.player().trigger(evt);
  }
};

vjs.Html5.prototype.useNativeControls = function(){
  var tech, player, controlsOn, controlsOff, cleanUp;

  tech = this;
  player = this.player();

  // If the player controls are enabled turn on the native controls
  tech.setControls(player.controls());

  // Update the native controls when player controls state is updated
  controlsOn = function(){
    tech.setControls(true);
  };
  controlsOff = function(){
    tech.setControls(false);
  };
  player.on('controlsenabled', controlsOn);
  player.on('controlsdisabled', controlsOff);

  // Clean up when not using native controls anymore
  cleanUp = function(){
    player.off('controlsenabled', controlsOn);
    player.off('controlsdisabled', controlsOff);
  };
  tech.on('dispose', cleanUp);
  player.on('usingcustomcontrols', cleanUp);

  // Update the state of the player to using native controls
  player.usingNativeControls(true);
};


vjs.Html5.prototype.play = function(){ this.el_.play(); };
vjs.Html5.prototype.pause = function(){ this.el_.pause(); };
vjs.Html5.prototype.paused = function(){ return this.el_.paused; };

vjs.Html5.prototype.currentTime = function(){ return this.el_.currentTime; };
vjs.Html5.prototype.setCurrentTime = function(seconds){
  try {
    this.el_.currentTime = seconds;
  } catch(e) {
    vjs.log(e, 'Video is not ready. (Video.js)');
    // this.warning(VideoJS.warnings.videoNotReady);
  }
};

vjs.Html5.prototype.duration = function(){ return this.el_.duration || 0; };
vjs.Html5.prototype.buffered = function(){ return this.el_.buffered; };

vjs.Html5.prototype.volume = function(){ return this.el_.volume; };
vjs.Html5.prototype.setVolume = function(percentAsDecimal){ this.el_.volume = percentAsDecimal; };
vjs.Html5.prototype.muted = function(){ return this.el_.muted; };
vjs.Html5.prototype.setMuted = function(muted){ this.el_.muted = muted; };

vjs.Html5.prototype.width = function(){ return this.el_.offsetWidth; };
vjs.Html5.prototype.height = function(){ return this.el_.offsetHeight; };

vjs.Html5.prototype.supportsFullScreen = function(){
  if (typeof this.el_.webkitEnterFullScreen == 'function') {

    // Seems to be broken in Chromium/Chrome && Safari in Leopard
    if (/Android/.test(vjs.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(vjs.USER_AGENT)) {
      return true;
    }
  }
  return false;
};

vjs.Html5.prototype.enterFullScreen = function(){
  var video = this.el_;

  if ('webkitDisplayingFullscreen' in video) {
    this.one('webkitbeginfullscreen', function() {
      this.player_.isFullscreen(true);

      this.one('webkitendfullscreen', function() {
        this.player_.isFullscreen(false);
        this.player_.trigger('fullscreenchange');
      });

      this.player_.trigger('fullscreenchange');
    });
  }

  if (video.paused && video.networkState <= video.HAVE_METADATA) {
    // attempt to prime the video element for programmatic access
    // this isn't necessary on the desktop but shouldn't hurt
    this.el_.play();

    // playing and pausing synchronously during the transition to fullscreen
    // can get iOS ~6.1 devices into a play/pause loop
    setTimeout(function(){
      video.pause();
      video.webkitEnterFullScreen();
    }, 0);
  } else {
    video.webkitEnterFullScreen();
  }
};
vjs.Html5.prototype.exitFullScreen = function(){
  this.el_.webkitExitFullScreen();
};
vjs.Html5.prototype.src = function(src) {
  if (src === undefined) {
    return this.el_.src;
  } else {
    this.el_.src = src;
  }
};
vjs.Html5.prototype.load = function(){ this.el_.load(); };
vjs.Html5.prototype.currentSrc = function(){ return this.el_.currentSrc; };

vjs.Html5.prototype.preload = function(){ return this.el_.preload; };
vjs.Html5.prototype.setPreload = function(val){ this.el_.preload = val; };

vjs.Html5.prototype.autoplay = function(){ return this.el_.autoplay; };
vjs.Html5.prototype.setAutoplay = function(val){ this.el_.autoplay = val; };

vjs.Html5.prototype.controls = function(){ return this.el_.controls; };
vjs.Html5.prototype.setControls = function(val){ this.el_.controls = !!val; };

vjs.Html5.prototype.loop = function(){ return this.el_.loop; };
vjs.Html5.prototype.setLoop = function(val){ this.el_.loop = val; };

vjs.Html5.prototype.error = function(){ return this.el_.error; };
vjs.Html5.prototype.seeking = function(){ return this.el_.seeking; };
vjs.Html5.prototype.ended = function(){ return this.el_.ended; };
vjs.Html5.prototype.defaultMuted = function(){ return this.el_.defaultMuted; };

vjs.Html5.prototype.playbackRate = function(){ return this.el_.playbackRate; };
vjs.Html5.prototype.setPlaybackRate = function(val){ this.el_.playbackRate = val; };

vjs.Html5.prototype.networkState = function(){ return this.el_.networkState; };

/* HTML5 Support Testing ---------------------------------------------------- */

vjs.Html5.isSupported = function(){
  // ie9 with no Media Player is a LIAR! (#984)
  try {
    vjs.TEST_VID['volume'] = 0.5;
  } catch (e) {
    return false;
  }

  return !!vjs.TEST_VID.canPlayType;
};

vjs.Html5.canPlaySource = function(srcObj){
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return !!vjs.TEST_VID.canPlayType(srcObj.type);
  } catch(e) {
    return '';
  }
  // TODO: Check Type
  // If no Type, check ext
  // Check Media Type
};

vjs.Html5.canControlVolume = function(){
  var volume =  vjs.TEST_VID.volume;
  vjs.TEST_VID.volume = (volume / 2) + 0.1;
  return volume !== vjs.TEST_VID.volume;
};

vjs.Html5.canControlPlaybackRate = function(){
  var playbackRate =  vjs.TEST_VID.playbackRate;
  vjs.TEST_VID.playbackRate = (playbackRate / 2) + 0.1;
  return playbackRate !== vjs.TEST_VID.playbackRate;
};

// HTML5 Feature detection and Device Fixes --------------------------------- //
(function() {
  var canPlayType,
      mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i,
      mp4RE = /^video\/mp4/i;

  vjs.Html5.patchCanPlayType = function() {
    // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
    if (vjs.ANDROID_VERSION >= 4.0) {
      if (!canPlayType) {
        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
      }

      vjs.TEST_VID.constructor.prototype.canPlayType = function(type) {
        if (type && mpegurlRE.test(type)) {
          return 'maybe';
        }
        return canPlayType.call(this, type);
      };
    }

    // Override Android 2.2 and less canPlayType method which is broken
    if (vjs.IS_OLD_ANDROID) {
      if (!canPlayType) {
        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
      }

      vjs.TEST_VID.constructor.prototype.canPlayType = function(type){
        if (type && mp4RE.test(type)) {
          return 'maybe';
        }
        return canPlayType.call(this, type);
      };
    }
  };

  vjs.Html5.unpatchCanPlayType = function() {
    var r = vjs.TEST_VID.constructor.prototype.canPlayType;
    vjs.TEST_VID.constructor.prototype.canPlayType = canPlayType;
    canPlayType = null;
    return r;
  };

  // by default, patch the video element
  vjs.Html5.patchCanPlayType();
})();

// List of all HTML5 events (various uses).
vjs.Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');

vjs.Html5.disposeMediaElement = function(el){
  if (!el) { return; }

  el['player'] = null;

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while(el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function() {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};
/**
 * @fileoverview VideoJS-SWF - Custom Flash Player with HTML5-ish API
 * https://github.com/zencoder/video-js-swf
 * Not using setupTriggers. Using global onEvent func to distribute events
 */

/**
 * Flash Media Controller - Wrapper for fallback SWF API
 *
 * @param {vjs.Player} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */
vjs.Flash = vjs.MediaTechController.extend({
  /** @constructor */
  init: function(player, options, ready){
    vjs.MediaTechController.call(this, player, options, ready);

    var source = options['source'],

        // Which element to embed in
        parentEl = options['parentEl'],

        // Create a temporary element to be replaced by swf object
        placeHolder = this.el_ = vjs.createEl('div', { id: player.id() + '_temp_flash' }),

        // Generate ID for swf object
        objId = player.id()+'_flash_api',

        // Store player options in local var for optimization
        // TODO: switch to using player methods instead of options
        // e.g. player.autoplay();
        playerOptions = player.options_,

        // Merge default flashvars with ones passed in to init
        flashVars = vjs.obj.merge({

          // SWF Callback Functions
          'readyFunction': 'videojs.Flash.onReady',
          'eventProxyFunction': 'videojs.Flash.onEvent',
          'errorEventProxyFunction': 'videojs.Flash.onError',

          // Player Settings
          'autoplay': playerOptions.autoplay,
          'preload': playerOptions.preload,
          'loop': playerOptions.loop,
          'muted': playerOptions.muted

        }, options['flashVars']),

        // Merge default parames with ones passed in
        params = vjs.obj.merge({
          'wmode': 'opaque', // Opaque is needed to overlay controls, but can affect playback performance
          'bgcolor': '#000000' // Using bgcolor prevents a white flash when the object is loading
        }, options['params']),

        // Merge default attributes with ones passed in
        attributes = vjs.obj.merge({
          'id': objId,
          'name': objId, // Both ID and Name needed or swf to identifty itself
          'class': 'vjs-tech'
        }, options['attributes'])
    ;

    // If source was supplied pass as a flash var.
    if (source) {
      if (source.type && vjs.Flash.isStreamingType(source.type)) {
        var parts = vjs.Flash.streamToParts(source.src);
        flashVars['rtmpConnection'] = encodeURIComponent(parts.connection);
        flashVars['rtmpStream'] = encodeURIComponent(parts.stream);
      }
      else {
        flashVars['src'] = encodeURIComponent(vjs.getAbsoluteURL(source.src));
      }
    }

    // Add placeholder to player div
    vjs.insertFirst(placeHolder, parentEl);

    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers
    // This allows resetting the playhead when we catch the reload
    if (options['startTime']) {
      this.ready(function(){
        this.load();
        this.play();
        this['currentTime'](options['startTime']);
      });
    }

    // firefox doesn't bubble mousemove events to parent. videojs/video-js-swf#37
    // bugzilla bug: https://bugzilla.mozilla.org/show_bug.cgi?id=836786
    if (vjs.IS_FIREFOX) {
      this.ready(function(){
        this.on('mousemove', function(){
          // since it's a custom event, don't bubble higher than the player
          this.player().trigger({ 'type':'mousemove', 'bubbles': false });
        });
      });
    }

    // native click events on the SWF aren't triggered on IE11, Win8.1RT
    // use stageclick events triggered from inside the SWF instead
    player.on('stageclick', player.reportUserActivity);

    this.el_ = vjs.Flash.embed(options['swf'], placeHolder, flashVars, params, attributes);
  }
});

vjs.Flash.prototype.dispose = function(){
  vjs.MediaTechController.prototype.dispose.call(this);
};

vjs.Flash.prototype.play = function(){
  this.el_.vjs_play();
};

vjs.Flash.prototype.pause = function(){
  this.el_.vjs_pause();
};

vjs.Flash.prototype.src = function(src){
  if (src === undefined) {
    return this['currentSrc']();
  }

  if (vjs.Flash.isStreamingSrc(src)) {
    src = vjs.Flash.streamToParts(src);
    this.setRtmpConnection(src.connection);
    this.setRtmpStream(src.stream);
  } else {
    // Make sure source URL is abosolute.
    src = vjs.getAbsoluteURL(src);
    this.el_.vjs_src(src);
  }

  // Currently the SWF doesn't autoplay if you load a source later.
  // e.g. Load player w/ no source, wait 2s, set src.
  if (this.player_.autoplay()) {
    var tech = this;
    setTimeout(function(){ tech.play(); }, 0);
  }
};

vjs.Flash.prototype['setCurrentTime'] = function(time){
  this.lastSeekTarget_ = time;
  this.el_.vjs_setProperty('currentTime', time);
  vjs.MediaTechController.prototype.setCurrentTime.call(this);
};

vjs.Flash.prototype['currentTime'] = function(time){
  // when seeking make the reported time keep up with the requested time
  // by reading the time we're seeking to
  if (this.seeking()) {
    return this.lastSeekTarget_ || 0;
  }
  return this.el_.vjs_getProperty('currentTime');
};

vjs.Flash.prototype['currentSrc'] = function(){
  var src = this.el_.vjs_getProperty('currentSrc');
  // no src, check and see if RTMP
  if (src == null) {
    var connection = this['rtmpConnection'](),
        stream = this['rtmpStream']();

    if (connection && stream) {
      src = vjs.Flash.streamFromParts(connection, stream);
    }
  }
  return src;
};

vjs.Flash.prototype.load = function(){
  this.el_.vjs_load();
};

vjs.Flash.prototype.buffered = function(){
  return vjs.createTimeRange(0, this.el_.vjs_getProperty('buffered'));
};

vjs.Flash.prototype.supportsFullScreen = function(){
  return false; // Flash does not allow fullscreen through javascript
};

vjs.Flash.prototype.enterFullScreen = function(){
  return false;
};

(function(){
  // Create setters and getters for attributes
  var api = vjs.Flash.prototype,
    readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(','),
    readOnly = 'error,networkState,readyState,seeking,initialTime,duration,startOffsetTime,paused,played,seekable,ended,videoTracks,audioTracks,videoWidth,videoHeight,textTracks'.split(','),
    // Overridden: buffered, currentTime, currentSrc
    i;

  function createSetter(attr){
    var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);
    api['set'+attrUpper] = function(val){ return this.el_.vjs_setProperty(attr, val); };
  };
  function createGetter(attr) {
    api[attr] = function(){ return this.el_.vjs_getProperty(attr); };
  };

  // Create getter and setters for all read/write attributes
  for (i = 0; i < readWrite.length; i++) {
    createGetter(readWrite[i]);
    createSetter(readWrite[i]);
  }

  // Create getters for read-only attributes
  for (i = 0; i < readOnly.length; i++) {
    createGetter(readOnly[i]);
  }
})();

/* Flash Support Testing -------------------------------------------------------- */

vjs.Flash.isSupported = function(){
  return vjs.Flash.version()[0] >= 10;
  // return swfobject.hasFlashPlayerVersion('10');
};

vjs.Flash.canPlaySource = function(srcObj){
  var type;

  if (!srcObj.type) {
    return '';
  }

  type = srcObj.type.replace(/;.*/,'').toLowerCase();
  if (type in vjs.Flash.formats || type in vjs.Flash.streamingFormats) {
    return 'maybe';
  }
};

vjs.Flash.formats = {
  'video/flv': 'FLV',
  'video/x-flv': 'FLV',
  'video/mp4': 'MP4',
  'video/m4v': 'MP4'
};

vjs.Flash.streamingFormats = {
  'rtmp/mp4': 'MP4',
  'rtmp/flv': 'FLV'
};

vjs.Flash['onReady'] = function(currSwf){
  var el, player;

  el = vjs.el(currSwf);

  // get player from the player div property
  player = el && el.parentNode && el.parentNode['player'];

  // if there is no el or player then the tech has been disposed
  // and the tech element was removed from the player div
  if (player) {
    // reference player on tech element
    el['player'] = player;
    // check that the flash object is really ready
    vjs.Flash['checkReady'](player.tech);
  }
};

// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.
// If it's not ready, we set a timeout to check again shortly.
vjs.Flash['checkReady'] = function(tech){
  // stop worrying if the tech has been disposed
  if (!tech.el()) {
    return;
  }

  // check if API property exists
  if (tech.el().vjs_getProperty) {
    // tell tech it's ready
    tech.triggerReady();
  } else {
    // wait longer
    setTimeout(function(){
      vjs.Flash['checkReady'](tech);
    }, 50);
  }
};

// Trigger events from the swf on the player
vjs.Flash['onEvent'] = function(swfID, eventName){
  var player = vjs.el(swfID)['player'];
  player.trigger(eventName);
};

// Log errors from the swf
vjs.Flash['onError'] = function(swfID, err){
  var player = vjs.el(swfID)['player'];
  var msg = 'FLASH: '+err;

  if (err == 'srcnotfound') {
    player.error({ code: 4, message: msg });

  // errors we haven't categorized into the media errors
  } else {
    player.error(msg);
  }
};

// Flash Version Check
vjs.Flash.version = function(){
  var version = '0,0,0';

  // IE
  try {
    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

  // other browsers
  } catch(e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin){
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch(err) {}
  }
  return version.split(',');
};

// Flash embedding method. Only used in non-iframe mode
vjs.Flash.embed = function(swf, placeHolder, flashVars, params, attributes){
  var code = vjs.Flash.getEmbedCode(swf, flashVars, params, attributes),

      // Get element by embedding code and retrieving created element
      obj = vjs.createEl('div', { innerHTML: code }).childNodes[0],

      par = placeHolder.parentNode
  ;

  placeHolder.parentNode.replaceChild(obj, placeHolder);

  // IE6 seems to have an issue where it won't initialize the swf object after injecting it.
  // This is a dumb fix
  var newObj = par.childNodes[0];
  setTimeout(function(){
    newObj.style.display = 'block';
  }, 1000);

  return obj;

};

vjs.Flash.getEmbedCode = function(swf, flashVars, params, attributes){

  var objTag = '<object type="application/x-shockwave-flash"',
      flashVarsString = '',
      paramsString = '',
      attrsString = '';

  // Convert flash vars to string
  if (flashVars) {
    vjs.obj.each(flashVars, function(key, val){
      flashVarsString += (key + '=' + val + '&amp;');
    });
  }

  // Add swf, flashVars, and other default params
  params = vjs.obj.merge({
    'movie': swf,
    'flashvars': flashVarsString,
    'allowScriptAccess': 'always', // Required to talk to swf
    'allowNetworking': 'all' // All should be default, but having security issues.
  }, params);

  // Create param tags string
  vjs.obj.each(params, function(key, val){
    paramsString += '<param name="'+key+'" value="'+val+'" />';
  });

  attributes = vjs.obj.merge({
    // Add swf to attributes (need both for IE and Others to work)
    'data': swf,

    // Default to 100% width/height
    'width': '100%',
    'height': '100%'

  }, attributes);

  // Create Attributes string
  vjs.obj.each(attributes, function(key, val){
    attrsString += (key + '="' + val + '" ');
  });

  return objTag + attrsString + '>' + paramsString + '</object>';
};

vjs.Flash.streamFromParts = function(connection, stream) {
  return connection + '&' + stream;
};

vjs.Flash.streamToParts = function(src) {
  var parts = {
    connection: '',
    stream: ''
  };

  if (! src) {
    return parts;
  }

  // Look for the normal URL separator we expect, '&'.
  // If found, we split the URL into two pieces around the
  // first '&'.
  var connEnd = src.indexOf('&');
  var streamBegin;
  if (connEnd !== -1) {
    streamBegin = connEnd + 1;
  }
  else {
    // If there's not a '&', we use the last '/' as the delimiter.
    connEnd = streamBegin = src.lastIndexOf('/') + 1;
    if (connEnd === 0) {
      // really, there's not a '/'?
      connEnd = streamBegin = src.length;
    }
  }
  parts.connection = src.substring(0, connEnd);
  parts.stream = src.substring(streamBegin, src.length);

  return parts;
};

vjs.Flash.isStreamingType = function(srcType) {
  return srcType in vjs.Flash.streamingFormats;
};

// RTMP has four variations, any string starting
// with one of these protocols should be valid
vjs.Flash.RTMP_RE = /^rtmp[set]?:\/\//i;

vjs.Flash.isStreamingSrc = function(src) {
  return vjs.Flash.RTMP_RE.test(src);
};

/**
 * The Media Loader is the component that decides which playback technology to load
 * when the player is initialized.
 *
 * @constructor
 */
vjs.MediaLoader = vjs.Component.extend({
  /** @constructor */
  init: function(player, options, ready){
    vjs.Component.call(this, player, options, ready);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.
    if (!player.options_['sources'] || player.options_['sources'].length === 0) {
      for (var i=0,j=player.options_['techOrder']; i<j.length; i++) {
        var techName = vjs.capitalize(j[i]),
            tech = window['videojs'][techName];

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech(techName);
          break;
        }
      }
    } else {
      // // Loop through playback technologies (HTML5, Flash) and check for support.
      // // Then load the best source.
      // // A few assumptions here:
      // //   All playback technologies respect preload false.
      player.src(player.options_['sources']);
    }
  }
});


/**
 * Javascript JSON implementation
 * (Parse Method Only)
 * https://github.com/douglascrockford/JSON-js/blob/master/json2.js
 * Only using for parse method when parsing data-setup attribute JSON.
 * @suppress {undefinedVars}
 * @namespace
 * @private
 */
vjs.JSON;

if (typeof window.JSON !== 'undefined' && typeof window.JSON.parse === 'function') {
  vjs.JSON = window.JSON;
} else {
  vjs.JSON = {};
}

/*!
 * Audio5js: HTML5 Audio Compatibility Layer
 * https://github.com/zohararad/audio5js
 * License MIT (c) Zohar Arad 2013
 */
;(function ($win, ns, factory) {
  "use strict";
  /*global define */
  /*global swfobject */

  if (typeof (module) !== 'undefined' && module.exports) { // CommonJS
    module.exports = factory(ns, $win);
  } else if (typeof (define) === 'function' && define.amd) { // AMD
    define(function () {
      return factory(ns, $win);
    });
  } else { // <script>
    $win[ns] = factory(ns, $win);
  }

}(window, 'Audio5js', function (ns, $win) {

  "use strict";

  var ActiveXObject = $win.ActiveXObject;

  /**
   * AudioError Class
   * @param {String} message error message
   * @constructor
   */
  function AudioError(message) {
    this.message = message;
  }

  AudioError.prototype = new Error();

  /**
   * Clones an object
   * @param obj object to clone
   * @return {Object} cloned object
   */
  function cloneObject(obj) {
    var clone = {}, i;
    for (i in obj) {
      if (typeof (obj[i]) === "object") {
        clone[i] = cloneObject(obj[i]);
      } else {
        clone[i] = obj[i];
      }
    }
    return clone;
  }

  /**
   * Extend an object with a mixin
   * @param {Object} target target object to extend
   * @param {Object} mixin object to mix into target
   * @return {*} extended object
   */
  var extend = function (target, mixin) {
    var name, m = cloneObject(mixin);
    for (name in m) {
      if (m.hasOwnProperty(name)) {
        target[name] = m[name];
      }
    }
    return target;
  };

  /**
   * Extend an object's prototype with a mixin
   * @param {Object} target target object to extend
   * @param {Object} mixin object to mix into target
   * @return {*} extended object
   */
  var include = function (target, mixin) {
    return extend(target.prototype, mixin);
  };

  var Pubsub = {
    /**
     * Subscribe to event on a channel
     * @param {String} evt name of channel / event to subscribe
     * @param {Function} fn the callback to execute on message publishing
     * @param {Object} ctx the context in which the callback should be executed
     */
    on: function (evt, fn, ctx) {
      this.subscribe(evt, fn, ctx, false);
    },
    /**
     * Subscribe to a one-time event on a channel
     * @param {String} evt name of channel / event to subscribe
     * @param {Function} fn the callback to execute on message publishing
     * @param {Object} ctx the context in which the callback should be executed
     */
    one: function(evt, fn, ctx) {
      this.subscribe(evt, fn, ctx, true);
    },
    /**
     * Unsubscribe from an event on a channel
     * @param {String} evt name of channel / event to unsubscribe
     * @param {Function} fn the callback used when subscribing to the event
     */
    off: function (evt, fn) {
      if (this.channels[evt] === undefined) { return; }
      var i, l;
      for (i = 0, l = this.channels[evt].length; i  < l; i++) {
        var sub = this.channels[evt][i].fn;
        if (sub === fn) {
          this.channels[evt].splice(i, 1);
          break;
        }
      }
    },
    /**
     * Add event subscription to channel. Called by `on` and `one`
     * @param {String} evt name of channel / event to subscribe
     * @param {Function} fn the callback to execute on message publishing
     * @param {Object} ctx the context in which the callback should be executed
     * @param {Boolean} once indicate if event should be triggered once or not
     */
    subscribe: function (evt, fn, ctx, once) {
      if (this.channels === undefined) {
        this.channels = {};
      }
      this.channels[evt] = this.channels[evt] || [];
      this.channels[evt].push({fn: fn, ctx: ctx, once: (once || false)});
    },
    /**
     * Publish a message on a channel. Accepts **args** after event name
     * @param {String} evt name of channel / event to trigger
     */
    trigger: function (evt) {
      if (this.channels && this.channels.hasOwnProperty(evt)) {
        var args = Array.prototype.slice.call(arguments, 1);
        var a = [];
        while(this.channels[evt].length > 0) {
          var sub = this.channels[evt].shift();
          if (typeof (sub.fn) === 'function') {
            sub.fn.apply(sub.ctx, args);
          }
          if ( !sub.once ){
            a.push(sub);
          }
        }
        this.channels[evt] = a;
      }
    }
  };

  var util = {
    /**
     * Flash embed code string with cross-browser support.
     */
  flash_embed_code: function (id, swf_location, ts) {
      var prefix;
      var s = '<param name="movie" value="' + swf_location + '?playerInstance=window.' + ns + '_flash.instances[\'' + id + '\']&datetime=' + ts + '"/>' +
        '<param name="wmode" value="transparent"/>' +
        '<param name="allowscriptaccess" value="always" />' +
        '</object>';
      if (ActiveXObject) {
        prefix = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="1" height="1" id="' + id + '">';
      } else {
        prefix = '<object type="application/x-shockwave-flash" data="' + swf_location + '?playerInstance=window.' + ns + '_flash.instances[\'' + id + '\']&datetime=' + ts + '" width="1" height="1" id="' + id + '" >';
      }
      return prefix + s;
    },
    /**
     * Check if browser supports audio mime type.
     * @param {String} mime_type audio mime type to check
     * @return {Boolean} whether browser supports passed audio mime type
     */
    can_play: function (mime_type) {
      var a = document.createElement('audio');
      var mime_str;
      switch (mime_type) {
        case 'mp3':
          mime_str = 'audio/mpeg;';
          break;
        case 'vorbis':
          mime_str = 'audio/ogg; codecs="vorbis"';
          break;
        case 'opus':
          mime_str = 'audio/ogg; codecs="opus"';
          break;
        case 'webm':
          mime_str = 'audio/webm; codecs="vorbis"';
          break;
        case 'mp4':
          mime_str = 'audio/mp4; codecs="mp4a.40.5"';
          break;
        case 'wav':
          mime_str = 'audio/wav; codecs="1"';
          break;
      }
      if (mime_str !== undefined) {
        if (mime_type === 'mp3' && navigator.userAgent.match(/Android/i) && navigator.userAgent.match(/Firefox/i)) {
          return true;
        }
        try {
          return !!a.canPlayType && a.canPlayType(mime_str) !== '';
        } catch (e) {
          return false;
        }
      }
      return false;
    },
    /**
     * Boolean flag indicating whether the browser has Flash installed or not
     */
    has_flash: (function () {
      var r = false;
      if (navigator.plugins && navigator.plugins.length && navigator.plugins['Shockwave Flash']) {
        r = true;
      } else if (navigator.mimeTypes && navigator.mimeTypes.length) {
        var mimeType = navigator.mimeTypes['application/x-shockwave-flash'];
        r = mimeType && mimeType.enabledPlugin;
      } else {
        try {
          var ax = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
          r = typeof (ax) === 'object';
        } catch (e) {}
      }
      return r;
    }()),
    /**
     * Embed Flash MP3 player SWF to DOM
     * @param {String} swf_location location of MP3 player SWF
     * @param {String} id swf unique ID used for resolving callbacks from ExternalInterface to Javascript
     */
    embedFlash: function (swf_location, id) {
      var d = document.createElement('div');
      d.style.position = 'absolute';
      d.style.width = '1px';
      d.style.height = '1px';
      d.style.top = '1px';
      document.body.appendChild(d);
      if(typeof($win.swfobject) === 'object'){
        var fv = {
          playerInstance: 'window.'+ ns + '_flash.instances[\''+id+'\']'
        };
        var params = {
          allowscriptaccess: 'always',
          wmode: 'transparent'
        };
        d.innerHTML = '<div id="'+id+'"></div>';
        swfobject.embedSWF(swf_location + '?ts='+(new Date().getTime() + Math.random()), id, "1", "1", "9.0.0", null, fv, params);
      } else {
        var ts = new Date().getTime() + Math.random(); // Ensure swf is not pulled from cache
        d.innerHTML = this.flash_embed_code(id, swf_location, ts);
      }
      return document.getElementById(id);
    },
    /**
     * Formats seconds into a time string hh:mm:ss.
     * @param {Number} seconds seconds to format as string
     * @return {String} formatted time string
     */
    formatTime: function (seconds) {
      var hours = parseInt(seconds / 3600, 10) % 24;
      var minutes = parseInt(seconds / 60, 10) % 60;
      var secs = parseInt(seconds % 60, 10);
      var result, fragment = (minutes < 10 ? "0" + minutes : minutes) + ":" + (secs  < 10 ? "0" + secs : secs);
      if (hours > 0) {
        result = (hours < 10 ? "0" + hours : hours) + ":" + fragment;
      } else {
        result = fragment;
      }
      return result;
    }
  };

  util.use_flash = util.can_play('mp3');

  var Audio5js, FlashAudioPlayer, HTML5AudioPlayer;

  /**
   * Common audio attributes object. Mixed into audio players.
   * @type {Object}
   */
  var AudioAttributes = {
    playing: false, /** {Boolean} player playback state  */
    vol: 1, /** {Float} audio volume */
    duration: 0, /** {Float} audio duration (sec) */
    position: 0, /** {Float} audio position (sec) */
    load_percent: 0, /** {Float} audio file load percent (%) */
    seekable: false, /** {Boolean} is loaded audio seekable */
    ready: null /** {Boolean} is loaded audio seekable */
  };

  /**
   * Global object holding flash-based player instances.
   * Used to create a bridge between Flash's ExternalInterface calls and FlashAudioPlayer instances
   * @type {Object}
   */
  var globalAudio5Flash = $win[ns + '_flash'] = $win[ns + '_flash'] || {
    instances: { }, /** FlashAudioPlayer instance hash */
    count: 0 /** FlashAudioPlayer instance count */
  };

  /**
   * Flash MP3 Audio Player Class
   * @constructor
   */
  FlashAudioPlayer = function () {
    if (util.use_flash && !util.has_flash) {
      throw new Error('Flash Plugin Missing');
    }
  };

  FlashAudioPlayer.prototype = {
    /**
     * Initialize the player
     * @param {String} swf_src path to audio player SWF file
     */
    init: function (swf_src) {
      globalAudio5Flash.count += 1;
      this.id = ns + globalAudio5Flash.count;
      globalAudio5Flash.instances[this.id] = this;
      this.embed(swf_src);
    },
    /**
     * Embed audio player SWF in page and assign reference to audio instance variable
     * @param {String} swf_src path to audio player SWF file
     */
    embed: function (swf_src) {
      util.embedFlash(swf_src, this.id);
    },
    /**
     * ExternalInterface callback indicating SWF is ready
     */
    eiReady: function () {
      this.audio = document.getElementById(this.id);
      this.trigger('ready');
    },
    /**
     * ExternalInterface audio load started callback. Fires when audio starts loading.
     */
    eiLoadStart: function(){
      this.trigger('loadstart');
    },
    /**
     * ExternalInterface audio metadata loaded callback. Fires when audio ID3 tags have been loaded.
     */
    eiLoadedMetadata: function(){
      this.trigger('loadedmetadata');
    },
    /**
     * ExternalInterface audio can play callback. Fires when audio can be played.
     */
    eiCanPlay: function () {
      this.trigger('canplay');
    },
    /**
     * ExternalInterface timeupdate callback. Fires as long as playhead position is updated (audio is being played).
     * @param {Float} position audio playback position (sec)
     * @param {Float} duration audio total duration (sec)
     * @param {Boolean} seekable is audio seekable or not (download or streaming)
     */
    eiTimeUpdate: function (position, duration, seekable) {
      this.position = position;
      this.duration = duration;
      this.seekable = seekable;
      this.trigger('timeupdate', position, (this.seekable ? duration : null));
    },
    /**
     * ExternalInterface download progress callback. Fires as long as audio file is downloaded by browser.
     * @param {Float} percent audio download percent
     * @param {Float} duration audio total duration (sec)
     * * @param {Boolean} seekable is audio seekable or not (download or streaming)
     */
    eiProgress: function (percent, duration, seekable) {
      this.load_percent = percent;
      this.duration = duration;
      this.seekable = seekable;
      this.trigger('progress', percent);
    },
    /**
     * ExternalInterface audio load error callback.
     * @param {String} msg error message
     */
    eiLoadError: function (msg) {
      this.trigger('error', msg);
    },
    /**
     * ExternalInterface audio play callback. Fires when audio starts playing.
     */
    eiPlay: function () {
      this.playing = true;
      this.trigger('play');
      this.trigger('playing');
    },
    /**
     * ExternalInterface audio pause callback. Fires when audio is paused.
     */
    eiPause: function () {
      this.playing = false;
      this.trigger('pause');
    },
    /**
     * ExternalInterface audio ended callback. Fires when audio playback ended.
     */
    eiEnded: function () {
      this.pause();
      this.trigger('ended');
    },
    /**
     * ExternalInterface audio seeking callback. Fires when audio is being seeked.
     */
    eiSeeking: function(){
      this.trigger('seeking');
    },
    /**
     * ExternalInterface audio seeked callback. Fires when audio has been seeked.
     */
    eiSeeked: function(){
      this.trigger('seeked');
    },
    /**
     * Resets audio position and parameters. Invoked once audio is loaded.
     */
    reset: function () {
      this.seekable = false;
      this.duration = 0;
      this.position = 0;
      this.load_percent = 0;
    },
    /**
     * Load audio from url.
     * @param {String} url URL of audio to load
     */
    load: function (url) {
      this.reset();
      this.audio.load(url);
    },
    /**
     * Play audio
     */
    play: function () {
      this.audio.pplay();
    },
    /**
     * Pause audio
     */
    pause: function () {
      this.audio.ppause();
    },
    /**
     * Get / Set audio volume
     * @param {Float} v audio volume to set between 0 - 1.
     * @return {Float} current audio volume
     */
    volume: function (v) {
      if (v !== undefined && !isNaN(parseInt(v, 10))) {
        this.audio.setVolume(v);
        this.vol = v;
      } else {
        return this.vol;
      }
    },
    /**
     * Seek audio to position
     * @param {Float} position audio position in seconds to seek to.
     */
    seek: function (position) {
      try {
        this.audio.seekTo(position);
        this.position = position;
      } catch (e) {}
    },
    /**
     * Destroy audio object and remove from DOM
     */
    destroyAudio: function() {
      if(this.audio){
        this.pause();
        this.audio.parentNode.removeChild(this.audio);
        delete globalAudio5Flash.instances[this.id];
        delete this.audio;
      }
    }
  };

  include(FlashAudioPlayer, Pubsub);
  include(FlashAudioPlayer, AudioAttributes);

  /**
   * HTML5 Audio Player
   * @constructor
   */
  HTML5AudioPlayer = function () {};

  HTML5AudioPlayer.prototype = {
    /**
     * Initialize the player instance
     */
    init: function () {
      this.trigger('ready');
    },
    /**
     * Create new audio instance
     */
    createAudio: function(){
      this.audio = new Audio();
      this.audio.autoplay = false;
      this.audio.preload = 'auto';
      this.audio.autobuffer = true;
      this.bindEvents();
    },
    /**
     * Destroy current audio instance
     */
    destroyAudio: function(){
      if(this.audio){
        this.pause();
        this.unbindEvents();
        try {
          this.audio.setAttribute('src', '');
        } finally {
          delete this.audio;
        }
      }
    },
    /**
     * Sets up audio event listeners once so adding / removing event listeners is always done
     * on the same callbacks.
     */
    setupEventListeners: function(){
      this.listeners = {
        loadstart: this.onLoadStart.bind(this),
        canplay: this.onLoad.bind(this),
        loadedmetadata: this.onLoadedMetadata.bind(this),
        play: this.onPlay.bind(this),
        playing: this.onPlaying.bind(this),
        pause: this.onPause.bind(this),
        ended: this.onEnded.bind(this),
        error: this.onError.bind(this),
        timeupdate: this.onTimeUpdate.bind(this),
        seeking: this.onSeeking.bind(this),
        seeked: this.onSeeked.bind(this)
      };
    },
    /**
     * Bind DOM events to Audio object
     */
    bindEvents: function() {
      if(this.listeners === undefined){
        this.setupEventListeners();
      }
      this.audio.addEventListener('loadstart', this.listeners.loadstart, false);
      this.audio.addEventListener('canplay', this.listeners.canplay, false);
      this.audio.addEventListener('loadedmetadata', this.listeners.loadedmetadata, false);
      this.audio.addEventListener('play', this.listeners.play, false);
      this.audio.addEventListener('playing', this.listeners.playing, false);
      this.audio.addEventListener('pause', this.listeners.pause, false);
      this.audio.addEventListener('ended', this.listeners.ended, false);
      this.audio.addEventListener('error', this.listeners.error, false);
      this.audio.addEventListener('timeupdate', this.listeners.timeupdate, false);
      this.audio.addEventListener('seeking', this.listeners.seeking, false);
      this.audio.addEventListener('seeked', this.listeners.seeked, false);
    },
    /**
     * Unbind DOM events from Audio object
     */
    unbindEvents: function() {
      this.audio.removeEventListener('loadstart', this.listeners.loadstart);
      this.audio.removeEventListener('canplay', this.listeners.canplay);
      this.audio.removeEventListener('loadedmetadata', this.listeners.loadedmetadata);
      this.audio.removeEventListener('play', this.listeners.play);
      this.audio.removeEventListener('playing', this.listeners.playing);
      this.audio.removeEventListener('pause', this.listeners.pause);
      this.audio.removeEventListener('ended', this.listeners.ended);
      this.audio.removeEventListener('error', this.listeners.error);
      this.audio.removeEventListener('timeupdate', this.listeners.timeupdate);
      this.audio.removeEventListener('seeking', this.listeners.seeking);
      this.audio.removeEventListener('seeked', this.listeners.seeked);
    },
    /**
     * Audio load start event handler. Triggered when audio starts loading
     */
    onLoadStart: function(){
      this.trigger('loadstart');
    },
    /**
     * Audio canplay event handler. Triggered when audio is loaded and can be played.
     * Resets player parameters and starts audio download progress timer.
     */
    onLoad: function () {
      if(!this.audio){
        return setTimeout(this.onLoad.bind(this), 100);
      }
      this.seekable = this.audio.seekable && this.audio.seekable.length > 0;
      if (this.seekable) {
        this.timer = setInterval(this.onProgress.bind(this), 250);
      }
      this.trigger('canplay');
    },
    /**
     * Audio ID3 load event handler. Triggered when ID3 metadata is loaded.
     */
    onLoadedMetadata: function(){
      this.trigger('loadedmetadata');
    },
    /**
     * Audio play event handler. Triggered when audio starts playing.
     */
    onPlay: function () {
      this.playing = true;
      this.trigger('play');
    },
    /**
     * Audio play event handler. Triggered when audio starts playing.
     */
    onPlaying: function () {
      this.playing = true;
      this.trigger('playing');
    },
    /**
     * Audio pause event handler. Triggered when audio is paused.
     */
    onPause: function () {
      this.playing = false;
      this.trigger('pause');
    },
    /**
     * Audio ended event handler. Triggered when audio playback has ended.
     */
    onEnded: function () {
      this.playing = false;
      this.trigger('ended');
    },
    /**
     * Audio timeupdate event handler. Triggered as long as playhead position is updated (audio is being played).
     */
    onTimeUpdate: function () {
      if (this.audio && this.playing) {
        try{
          this.position = this.audio.currentTime;
          this.duration = this.audio.duration === Infinity ? null : this.audio.duration;
        } catch (e){}
        this.trigger('timeupdate', this.position, this.duration);
      }
    },
    /**
     * Audio download progress timer callback. Check audio's download percentage.
     * Called periodically as soon as the audio loads and can be played.
     * Cancelled when audio has fully download or when a new audio file has been loaded to the player.
     */
    onProgress: function () {
      if (this.audio && this.audio.buffered !== null && this.audio.buffered.length) {
        this.duration = this.audio.duration === Infinity ? null : this.audio.duration;
        this.load_percent = parseInt(((this.audio.buffered.end(this.audio.buffered.length - 1) / this.duration) * 100), 10);
        this.trigger('progress', this.load_percent);
        if (this.load_percent >= 100) {
          this.clearLoadProgress();
        }
      }
    },
    /**
     * Audio error event handler
     * @param e error event
     */
    onError: function (e) {
      this.trigger('error', e);
    },
    /**
     * Audio seeking event handler. Triggered when audio seek starts.
     */
    onSeeking: function(){
      this.trigger('seeking');
    },
    /**
     * Audio seeked event handler. Triggered when audio has been seeked.
     */
    onSeeked: function(){
      this.trigger('seeked');
    },
    /**
     * Clears periodical audio download progress callback.
     */
    clearLoadProgress: function () {
      if (this.timer !== undefined) {
        clearInterval(this.timer);
        delete this.timer;
      }
    },
    /**
     * Resets audio position and parameters.
     */
    reset: function () {
      this.clearLoadProgress();
      this.seekable = false;
      this.duration = 0;
      this.position = 0;
      this.load_percent = 0;
    },
    /**
     * Load audio from url.
     * @param {String} url URL of audio to load
     */
    load: function (url) {
      this.reset();
      this.trigger('pause');
      //this.destroyAudio();
      if(this.audio === undefined){
        this.createAudio();
      }
      this.audio.setAttribute('src', url);
      this.audio.load();
    },
    /**
     * Play audio
     */
    play: function () {
      if(this.audio) {
        this.audio.play();
      }
    },
    /**
     * Pause audio
     */
    pause: function () {
      if(this.audio) {
        this.audio.pause();
      }
    },
    /**
     * Get / Set audio volume
     * @param {Float} v audio volume to set between 0 - 1.
     * @return {Float} current audio volume
     */
    volume: function (v) {
      if (v !== undefined && !isNaN(parseInt(v, 10))) {
        var vol = v < 0 ? 0 : Math.min(1, v);
        this.audio.volume = vol;
        this.vol = vol;
      } else {
        return this.vol;
      }
    },
    /**
     * Seek audio to position
     * @param {Float} position audio position in seconds to seek to.
     */
    seek: function (position) {
      var playing = this.playing;
      this.position = position;
      this.audio.currentTime = position;
      if (playing) {
        this.play();
      } else {
        if (this.audio.buffered !== null && this.audio.buffered.length) {
          this.trigger('timeupdate', this.position, this.duration);
        }
      }
    }
  };

  include(HTML5AudioPlayer, Pubsub);
  include(HTML5AudioPlayer, AudioAttributes);

  /**
   * Default settings object
   * @type {Object}
   */
  var settings = {
    /**
     * {String} path to Flash audio player SWF file
     */
    swf_path: '/swf/audiojs.swf',
    /**
     * {Boolean} flag indicating whether to throw errors to the page or trigger an error event
     */
    throw_errors: true,
    /**
     * {Boolean} flag indicating whether to format player duration and position to hh:mm:ss or pass as raw seconds
     */
    format_time: true,
    /**
     * {Array} list of codecs to try and use when initializing the player. Used to selectively initialize the internal audio player based on codec support
     */
    codecs: ['mp3']
  };

  /**
   * Audio5js Audio Player
   * @param {Object} s player settings object
   * @constructor
   */
  Audio5js = function (s) {
    s = s || {};
    var k;
    for (k in settings) {
      if (settings.hasOwnProperty(k) && !s.hasOwnProperty(k)) {
        s[k] = settings[k];
      }
    }
    this.init(s);
  };

  /**
   * Check if browser can play a given audio mime type.
   * @param {String} mime_type audio mime type to check.
   * @return {Boolean} is audio mime type supported by browser or not
   */
  Audio5js.can_play = function (mime_type) {
    return util.can_play(mime_type);
  };

  Audio5js.prototype = {
    /**
     * Initialize player instance.
     * @param {Object} s player settings object
     */
    init: function (s) {
      this.ready = false;
      this.settings = s;
      this.audio = this.getPlayer();
      this.bindAudioEvents();
      if (this.settings.use_flash) {
        this.audio.init(s.swf_path);
      } else {
        this.audio.init();
      }
    },
    /**
     * Gets a new audio player instance based on codec support as defined in settings.codecs array.
     * Defaults to MP3 player either HTML or Flash based.
     * @return {FlashAudioPlayer,HTML5AudioPlayer} audio player instance
     */
    getPlayer: function () {
      var i, l, player, codec;
      if(this.settings.use_flash){
        player = new FlashAudioPlayer();
        this.settings.player = {
          engine: 'flash',
          codec: 'mp3'
        };
      } else {
        for (i = 0, l = this.settings.codecs.length; i < l; i++) {
          codec = this.settings.codecs[i];
          if (Audio5js.can_play(codec)) {
            player = new HTML5AudioPlayer();
            this.settings.use_flash = false;
            this.settings.player = {
              engine: 'html',
              codec: codec
            };
            break;
          }
        }
        if (player === undefined) {
          // here we double check for mp3 support instead of defaulting to Flash in case user overrode the settings.codecs array with an empty array.
          this.settings.use_flash = !Audio5js.can_play('mp3');
          player = this.settings.use_flash ? new FlashAudioPlayer() : new HTML5AudioPlayer();
          this.settings.player = {
            engine: (this.settings.use_flash ? 'flash' : 'html'),
            codec: 'mp3'
          };
        }
      }
      return player;
    },
    /**
     * Bind events from audio object to internal callbacks
     */
    bindAudioEvents: function () {
      this.audio.on('ready', this.onReady, this);
      this.audio.on('loadstart', this.onLoadStart, this);
      this.audio.on('loadedmetadata', this.onLoadedMetadata, this);
      this.audio.on('play', this.onPlay, this);
      this.audio.on('pause', this.onPause, this);
      this.audio.on('ended', this.onEnded, this);
      this.audio.on('canplay', this.onCanPlay, this);
      this.audio.on('timeupdate', this.onTimeUpdate, this);
      this.audio.on('progress', this.onProgress, this);
      this.audio.on('error', this.onError, this);
      this.audio.on('seeking', this.onSeeking, this);
      this.audio.on('seeked', this.onSeeked, this);
    },
    /**
     * Bind events from audio object to internal callbacks
     */
    unbindAudioEvents: function () {
      this.audio.off('ready', this.onReady);
      this.audio.off('loadstart', this.onLoadStart);
      this.audio.off('loadedmetadata', this.onLoadedMetadata);
      this.audio.off('play', this.onPlay);
      this.audio.off('pause', this.onPause);
      this.audio.off('ended', this.onEnded);
      this.audio.off('canplay', this.onCanPlay);
      this.audio.off('timeupdate', this.onTimeUpdate);
      this.audio.off('progress', this.onProgress);
      this.audio.off('error', this.onError);
      this.audio.off('seeking', this.onSeeking);
      this.audio.off('seeked', this.onSeeked);
    },
    /**
     * Load audio from URL
     * @param {String} url URL of audio to load
     */
    load: function (url) {
      var that = this,
          f = function(u){
            that.audio.load(u);
            that.trigger('load');
          };

      if(this.ready){
        f(url);
      } else {
        this.on('ready', f);
      }
    },
    /**
     * Play audio
     */
    play: function () {
      if(!this.playing){
        this.audio.play();
      }
    },
    /**
     * Pause audio
     */
    pause: function () {
      if(this.playing){
        this.audio.pause();
      }
    },
    /**
     * Toggle audio play / pause
     */
    playPause: function () {
      this[this.playing ? 'pause' : 'play']();
    },
    /**
     * Get / Set audio volume
     * @param {Float} v audio volume to set between 0 - 1.
     * @return {Float} current audio volume
     */
    volume: function (v) {
      if (v !== undefined && !isNaN(parseInt(v, 10))) {
        this.audio.volume(v);
        this.vol = v;
      } else {
        return this.vol;
      }
    },
    /**
     * Seek audio to position
     * @param {Float} position audio position in seconds to seek to.
     */
    seek: function (position) {
      this.audio.seek(position);
      this.position = position;
    },
    /**
     * Destroy audio object and remove from DOM
     */
    destroy: function() {
      this.unbindAudioEvents();
      this.audio.destroyAudio();
    },
    /**
     * Callback for audio ready event. Indicates audio is ready for playback.
     * Looks for ready callback in settings object and invokes it in the context of player instance
     */
    onReady: function () {
      this.ready = true;
      if (typeof (this.settings.ready) === 'function') {
        this.settings.ready.call(this, this.settings.player);
      }
      this.trigger('ready');
    },
    /**
     * Audio load start event handler
     */
    onLoadStart: function(){
      this.trigger('loadstart');
    },
    /**
     * Audio metadata loaded event handler
     */
    onLoadedMetadata: function(){
      this.trigger('loadedmetadata');
    },
    /**
     * Audio play event handler
     */
    onPlay: function () {
      this.playing = true;
      this.trigger('play');
    },
    /**
     * Audio pause event handler
     */
    onPause: function () {
      this.playing = false;
      this.trigger('pause');
    },
    /**
     * Playback end event handler
     */
    onEnded: function () {
      this.playing = false;
      this.trigger('ended');
    },
    /**
     * Audio error event handler
     */
    onError: function () {
      var error = new AudioError('Audio Error. Failed to Load Audio');
      if (this.settings.throw_errors) {
        throw error;
      } else {
        this.trigger('error', error);
      }
    },
    /**
     * Audio canplay event handler. Triggered when enough audio has been loaded to by played.
     */
    onCanPlay: function () {
      this.trigger('canplay');
    },
    /**
     * Audio seeking event handler
     */
    onSeeking: function(){
      this.trigger('seeking');
    },
    /**
     * Audio seeked event handler
     */
    onSeeked: function(){
      this.trigger('seeked');
    },
    /**
     * Playback time update event handler
     * @param {Float} position play head position (sec)
     * @param {Float} duration audio duration (sec)
     */
    onTimeUpdate: function (position, duration) {
      this.position = this.settings.format_time ? util.formatTime(position) : position;
      if (this.duration !== duration) {
        this.duration = this.settings.format_time && duration !== null ? util.formatTime(duration) : duration;
      }
      this.trigger('timeupdate', this.position, this.duration);
    },
    /**
     * Audio download progress event handler
     * @param {Float} loaded audio download percent
     */
    onProgress: function (loaded) {
      this.duration = this.audio.duration;
      this.load_percent = loaded;
      this.trigger('progress', loaded);
    }
  };

  include(Audio5js, Pubsub);
  include(Audio5js, AudioAttributes);

  return Audio5js;

}));

/*! iScroll v5.1.1 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */
;(function (window, document, Math) {
var rAF = window.requestAnimationFrame	||
	window.webkitRequestAnimationFrame	||
	window.mozRequestAnimationFrame		||
	window.oRequestAnimationFrame		||
	window.msRequestAnimationFrame		||
	function (callback) { window.setTimeout(callback, 1000 / 60); };

var utils = (function () {
	var me = {};

	var _elementStyle = document.createElement('div').style;
	var _vendor = (function () {
		var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			transform,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			transform = vendors[i] + 'ransform';
			if ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);
		}

		return false;
	})();

	function _prefixStyle (style) {
		if ( _vendor === false ) return false;
		if ( _vendor === '' ) return style;
		return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
	}

	me.getTime = Date.now || function getTime () { return new Date().getTime(); };

	me.extend = function (target, obj) {
		for ( var i in obj ) {
			target[i] = obj[i];
		}
	};

	me.addEvent = function (el, type, fn, capture) {
		el.addEventListener(type, fn, !!capture);
	};

	me.removeEvent = function (el, type, fn, capture) {
		el.removeEventListener(type, fn, !!capture);
	};

	me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
		var distance = current - start,
			speed = Math.abs(distance) / time,
			destination,
			duration;

		deceleration = deceleration === undefined ? 0.0006 : deceleration;

		destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );
		duration = speed / deceleration;

		if ( destination < lowerMargin ) {
			destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;
			distance = Math.abs(destination - current);
			duration = distance / speed;
		} else if ( destination > 0 ) {
			destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;
			distance = Math.abs(current) + destination;
			duration = distance / speed;
		}

		return {
			destination: Math.round(destination),
			duration: duration
		};
	};

	var _transform = _prefixStyle('transform');

	me.extend(me, {
		hasTransform: _transform !== false,
		hasPerspective: _prefixStyle('perspective') in _elementStyle,
		hasTouch: 'ontouchstart' in window,
		hasPointer: navigator.msPointerEnabled,
		hasTransition: _prefixStyle('transition') in _elementStyle
	});

	// This should find all Android browsers lower than build 535.19 (both stock browser and webview)
	me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !(/Chrome\/\d/.test(window.navigator.appVersion));

	me.extend(me.style = {}, {
		transform: _transform,
		transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
		transitionDuration: _prefixStyle('transitionDuration'),
		transitionDelay: _prefixStyle('transitionDelay'),
		transformOrigin: _prefixStyle('transformOrigin')
	});

	me.hasClass = function (e, c) {
		var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
		return re.test(e.className);
	};

	me.addClass = function (e, c) {
		if ( me.hasClass(e, c) ) {
			return;
		}

		var newclass = e.className.split(' ');
		newclass.push(c);
		e.className = newclass.join(' ');
	};

	me.removeClass = function (e, c) {
		if ( !me.hasClass(e, c) ) {
			return;
		}

		var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
		e.className = e.className.replace(re, ' ');
	};

	me.offset = function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;

		// jshint -W084
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		// jshint +W084

		return {
			left: left,
			top: top
		};
	};

	me.preventDefaultException = function (el, exceptions) {
		for ( var i in exceptions ) {
			if ( exceptions[i].test(el[i]) ) {
				return true;
			}
		}

		return false;
	};

	me.extend(me.eventType = {}, {
		touchstart: 1,
		touchmove: 1,
		touchend: 1,

		mousedown: 2,
		mousemove: 2,
		mouseup: 2,

		MSPointerDown: 3,
		MSPointerMove: 3,
		MSPointerUp: 3
	});

	me.extend(me.ease = {}, {
		quadratic: {
			style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
			fn: function (k) {
				return k * ( 2 - k );
			}
		},
		circular: {
			style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',	// Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
			fn: function (k) {
				return Math.sqrt( 1 - ( --k * k ) );
			}
		},
		back: {
			style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
			fn: function (k) {
				var b = 4;
				return ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;
			}
		},
		bounce: {
			style: '',
			fn: function (k) {
				if ( ( k /= 1 ) < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k;
				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
				}
			}
		},
		elastic: {
			style: '',
			fn: function (k) {
				var f = 0.22,
					e = 0.4;

				if ( k === 0 ) { return 0; }
				if ( k == 1 ) { return 1; }

				return ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );
			}
		}
	});

	me.tap = function (e, eventName) {
		var ev = document.createEvent('Event');
		ev.initEvent(eventName, true, true);
		ev.pageX = e.pageX;
		ev.pageY = e.pageY;
		e.target.dispatchEvent(ev);
	};

	me.click = function (e) {
		var target = e.target,
			ev;

		if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {
			ev = document.createEvent('MouseEvents');
			ev.initMouseEvent('click', true, true, e.view, 1,
				target.screenX, target.screenY, target.clientX, target.clientY,
				e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
				0, null);

			ev._constructed = true;
			target.dispatchEvent(ev);
		}
	};

	return me;
})();

function IScroll (el, options) {
	this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
	this.scroller = this.wrapper.children[0];
	this.scrollerStyle = this.scroller.style;		// cache style for better performance

	this.options = {

		resizeScrollbars: true,

		mouseWheelSpeed: 20,

		snapThreshold: 0.334,

// INSERT POINT: OPTIONS

		startX: 0,
		startY: 0,
		scrollY: true,
		directionLockThreshold: 5,
		momentum: true,

		bounce: true,
		bounceTime: 600,
		bounceEasing: '',

		preventDefault: true,
		preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|TSPAN)$/ },

		HWCompositing: true,
		useTransition: true,
		useTransform: true
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	// Normalize options
	this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

	this.options.useTransition = utils.hasTransition && this.options.useTransition;
	this.options.useTransform = utils.hasTransform && this.options.useTransform;

	this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
	this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

	// If you want eventPassthrough I have to lock one of the axes
	this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
	this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

	// With eventPassthrough we also need lockDirection mechanism
	this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
	this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

	this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

	this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

	if ( this.options.tap === true ) {
		this.options.tap = 'tap';
	}

	if ( this.options.shrinkScrollbars == 'scale' ) {
		this.options.useTransition = false;
	}

	this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

	if ( this.options.probeType == 3 ) {
		this.options.useTransition = false;	}

// INSERT POINT: NORMALIZATION

	// Some defaults
	this.x = 0;
	this.y = 0;
	this.directionX = 0;
	this.directionY = 0;
	this._events = {};

// INSERT POINT: DEFAULTS

	this._init();
	this.refresh();

	this.scrollTo(this.options.startX, this.options.startY);
	this.enable();
}

IScroll.prototype = {
	version: '5.1.1',

	_init: function () {
		this._initEvents();

		if ( this.options.scrollbars || this.options.indicators ) {
			this._initIndicators();
		}

		if ( this.options.mouseWheel ) {
			this._initWheel();
		}

		if ( this.options.snap ) {
			this._initSnap();
		}

		if ( this.options.keyBindings ) {
			this._initKeys();
		}

// INSERT POINT: _init

	},

	destroy: function () {
		this._initEvents(true);

		this._execEvent('destroy');
	},

	_transitionEnd: function (e) {
		if ( e.target != this.scroller || !this.isInTransition ) {
			return;
		}

		this._transitionTime();
		if ( !this.resetPosition(this.options.bounceTime) ) {
			this.isInTransition = false;
			this._execEvent('scrollEnd',e);
		}
	},

	_start: function (e) {
		// React to left mouse button only
		if ( utils.eventType[e.type] != 1 ) {
			if ( e.button !== 0 ) {
				return;
			}
		}


		if ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {
			return;
		}

		if ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		if(this.options.stopPropagation){
			e.stopPropagation();
		}

		var point = e.touches ? e.touches[0] : e,
			pos;

		this.initiated	= utils.eventType[e.type];
		this.moved		= false;
		this.distX		= 0;
		this.distY		= 0;
		this.directionX = 0;
		this.directionY = 0;
		this.directionLocked = 0;

		this._transitionTime();

		this.startTime = utils.getTime();

		if ( this.options.useTransition && this.isInTransition ) {
			this.isInTransition = false;
			pos = this.getComputedPosition();
			this._translate(Math.round(pos.x), Math.round(pos.y));
			this._execEvent('scrollEnd',e);
		} else if ( !this.options.useTransition && this.isAnimating ) {
			this.isAnimating = false;
			this._execEvent('scrollEnd',e);
		}

		this.startX    = this.x;
		this.startY    = this.y;
		this.absStartX = this.x;
		this.absStartY = this.y;
		this.pointX    = point.pageX;
		this.pointY    = point.pageY;

		this._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault ) {	// increases performance on Android? TODO: check!
			e.preventDefault();
		}

		var point		= e.touches ? e.touches[0] : e,
			deltaX		= point.pageX - this.pointX,
			deltaY		= point.pageY - this.pointY,
			timestamp	= utils.getTime(),
			newX, newY,
			absDistX, absDistY;

		this.pointX		= point.pageX;
		this.pointY		= point.pageY;

		this.distX		+= deltaX;
		this.distY		+= deltaY;
		absDistX		= Math.abs(this.distX);
		absDistY		= Math.abs(this.distY);

		// We need to move at least 10 pixels for the scrolling to initiate
		if ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {
			return;
		}

		// If you are scrolling in one direction lock the other
		if ( !this.directionLocked && !this.options.freeScroll ) {
			if ( absDistX > absDistY + this.options.directionLockThreshold ) {
				this.directionLocked = 'h';		// lock horizontally
			} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
				this.directionLocked = 'v';		// lock vertically
			} else {
				this.directionLocked = 'n';		// no lock
			}
		}

		if ( this.directionLocked == 'h' ) {
			if ( this.options.eventPassthrough == 'vertical' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'horizontal' ) {
				this.initiated = false;
				return;
			}

			deltaY = 0;
		} else if ( this.directionLocked == 'v' ) {
			if ( this.options.eventPassthrough == 'horizontal' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'vertical' ) {
				this.initiated = false;
				return;
			}

			deltaX = 0;
		}

		deltaX = this.hasHorizontalScroll ? deltaX : 0;
		deltaY = this.hasVerticalScroll ? deltaY : 0;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		// Slow down if outside of the boundaries
		if ( newX > 0 || newX < this.maxScrollX ) {
			newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
		}
		if ( newY > 0 || newY < this.maxScrollY ) {
			newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
		}

		this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if ( !this.moved ) {
			this._execEvent('scrollStart');
		}

		this.moved = true;

		this._translate(newX, newY);

/* REPLACE START: _move */
		if ( timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.startX = this.x;
			this.startY = this.y;

			if ( this.options.probeType == 1 ) {
				this._execEvent('scroll',e);
			}
		}

		if ( this.options.probeType > 1 ) {
			this._execEvent('scroll',e);
		}
/* REPLACE END: _move */

	},

	_end: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.changedTouches ? e.changedTouches[0] : e,
			momentumX,
			momentumY,
			duration = utils.getTime() - this.startTime,
			newX = Math.round(this.x),
			newY = Math.round(this.y),
			distanceX = Math.abs(newX - this.startX),
			distanceY = Math.abs(newY - this.startY),
			time = 0,
			easing = '';

		this.isInTransition = 0;
		this.initiated = 0;
		this.endTime = utils.getTime();

		// reset if we are outside of the boundaries
		if ( this.resetPosition(this.options.bounceTime) ) {
			return;
		}

		this.scrollTo(newX, newY);	// ensures that the last position is rounded

		// we scrolled less than 10 pixels
		if ( !this.moved ) {
			if ( this.options.tap ) {
				utils.tap(e, this.options.tap);
			}

			if ( this.options.click ) {
				utils.click(e);
			}

			this._execEvent('scrollCancel');
			return;
		}

		if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {
			this._execEvent('flick');
			return;
		}

		// start momentum animation if needed
		if ( this.options.momentum && duration < 300 ) {
			momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
			momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
			newX = momentumX.destination;
			newY = momentumY.destination;
			time = Math.max(momentumX.duration, momentumY.duration);
			this.isInTransition = 1;
		}


		if ( this.options.snap ) {
			var snap = this._nearestSnap(newX, newY);
			this.currentPage = snap;
			time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(newX - snap.x), 1000),
						Math.min(Math.abs(newY - snap.y), 1000)
					), 300);
			newX = snap.x;
			newY = snap.y;

			this.directionX = 0;
			this.directionY = 0;
			easing = this.options.bounceEasing;
		}

// INSERT POINT: _end

		if ( newX != this.x || newY != this.y ) {
			// change easing function when scroller goes out of the boundaries
			if ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {
				easing = utils.ease.quadratic;
			}

			this.scrollTo(newX, newY, time, easing);
			return;
		}

		this._execEvent('scrollEnd',e);
	},

	_resize: function () {
		var that = this;

		clearTimeout(this.resizeTimeout);

		this.resizeTimeout = setTimeout(function () {
			that.refresh();
		}, this.options.resizePolling);
	},

	resetPosition: function (time) {
		var x = this.x,
			y = this.y;

		time = time || 0;

		if ( !this.hasHorizontalScroll || this.x > 0 ) {
			x = 0;
		} else if ( this.x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( !this.hasVerticalScroll || this.y > 0 ) {
			y = 0;
		} else if ( this.y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		if ( x == this.x && y == this.y ) {
			return false;
		}

		this.scrollTo(x, y, time, this.options.bounceEasing);

		return true;
	},

	disable: function () {
		this.enabled = false;
	},

	enable: function () {
		this.enabled = true;
	},

	refresh: function () {
		var rf = this.wrapper.offsetHeight;		// Force reflow

		this.wrapperWidth	= this.wrapper.clientWidth;
		this.wrapperHeight	= this.wrapper.clientHeight;

/* REPLACE START: refresh */

		this.scrollerWidth	= this.scroller.offsetWidth;
		this.scrollerHeight	= this.scroller.offsetHeight;

		this.maxScrollX		= this.wrapperWidth - this.scrollerWidth;
		this.maxScrollY		= this.wrapperHeight - this.scrollerHeight;

/* REPLACE END: refresh */

		this.hasHorizontalScroll	= this.options.scrollX && this.maxScrollX < 0;
		this.hasVerticalScroll		= this.options.scrollY && this.maxScrollY < 0;

		if ( !this.hasHorizontalScroll ) {
			this.maxScrollX = 0;
			this.scrollerWidth = this.wrapperWidth;
		}

		if ( !this.hasVerticalScroll ) {
			this.maxScrollY = 0;
			this.scrollerHeight = this.wrapperHeight;
		}

		this.endTime = 0;
		this.directionX = 0;
		this.directionY = 0;

		this.wrapperOffset = utils.offset(this.wrapper);

		this._execEvent('refresh');

		this.resetPosition();

// INSERT POINT: _refresh

	},

	on: function (type, fn) {
		if ( !this._events[type] ) {
			this._events[type] = [];
		}

		this._events[type].push(fn);
	},

	off: function (type, fn) {
		if ( !this._events[type] ) {
			return;
		}

		var index = this._events[type].indexOf(fn);

		if ( index > -1 ) {
			this._events[type].splice(index, 1);
		}
	},

	_execEvent: function (type,e) {
		if ( !this._events[type] ) {
			return;
		}

		var i = 0,
			l = this._events[type].length;

		if ( !l ) {
			return;
		}

		for ( ; i < l; i++ ) {
			this._events[type][i].apply(this, [].slice.call(arguments, 1));
		}
	},

	scrollBy: function (x, y, time, easing) {
		x = this.x + x;
		y = this.y + y;
		time = time || 0;

		this.scrollTo(x, y, time, easing);
	},

	scrollTo: function (x, y, time, easing) {
		easing = easing || utils.ease.circular;

		this.isInTransition = this.options.useTransition && time > 0;

		if ( !time || (this.options.useTransition && easing.style) ) {
			this._transitionTimingFunction(easing.style);
			this._transitionTime(time);
			this._translate(x, y);
		} else {
			this._animate(x, y, time, easing.fn);
		}
	},

	scrollToElement: function (el, time, offsetX, offsetY, easing) {
		el = el.nodeType ? el : this.scroller.querySelector(el);

		if ( !el ) {
			return;
		}

		var pos = utils.offset(el);

		pos.left -= this.wrapperOffset.left;
		pos.top  -= this.wrapperOffset.top;

		// if offsetX/Y are true we center the element to the screen
		if ( offsetX === true ) {
			offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
		}
		if ( offsetY === true ) {
			offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
		}

		pos.left -= offsetX || 0;
		pos.top  -= offsetY || 0;

		pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
		pos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;

		time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;

		this.scrollTo(pos.left, pos.top, time, easing);
	},

	_transitionTime: function (time) {
		time = time || 0;

		this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
		}


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTime(time);
			}
		}


// INSERT POINT: _transitionTime

	},

	_transitionTimingFunction: function (easing) {
		this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTimingFunction(easing);
			}
		}


// INSERT POINT: _transitionTimingFunction

	},

	_translate: function (x, y) {
		if ( this.options.useTransform ) {

/* REPLACE START: _translate */

			this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

/* REPLACE END: _translate */

		} else {
			x = Math.round(x);
			y = Math.round(y);
			this.scrollerStyle.left = x + 'px';
			this.scrollerStyle.top = y + 'px';
		}

		this.x = x;
		this.y = y;


	if ( this.indicators ) {
		for ( var i = this.indicators.length; i--; ) {
			this.indicators[i].updatePosition();
		}
	}


// INSERT POINT: _translate

	},

	_initEvents: function (remove) {
		var eventType = remove ? utils.removeEvent : utils.addEvent,
			target = this.options.bindToWrapper ? this.wrapper : window;

		eventType(window, 'orientationchange', this);
		eventType(window, 'resize', this);

		if ( this.options.click ) {
			eventType(this.wrapper, 'click', this, true);
		}

		if ( !this.options.disableMouse ) {
			eventType(this.wrapper, 'mousedown', this);
			eventType(target, 'mousemove', this);
			eventType(target, 'mousecancel', this);
			eventType(target, 'mouseup', this);
		}

		if ( utils.hasPointer && !this.options.disablePointer ) {
			eventType(this.wrapper, 'MSPointerDown', this);
			eventType(target, 'MSPointerMove', this);
			eventType(target, 'MSPointerCancel', this);
			eventType(target, 'MSPointerUp', this);
		}

		if ( utils.hasTouch && !this.options.disableTouch ) {
			eventType(this.wrapper, 'touchstart', this);
			eventType(target, 'touchmove', this);
			eventType(target, 'touchcancel', this);
			eventType(target, 'touchend', this);
		}

		eventType(this.scroller, 'transitionend', this);
		eventType(this.scroller, 'webkitTransitionEnd', this);
		eventType(this.scroller, 'oTransitionEnd', this);
		eventType(this.scroller, 'MSTransitionEnd', this);
	},

	getComputedPosition: function () {
		var matrix = window.getComputedStyle(this.scroller, null),
			x, y;

		if ( this.options.useTransform ) {
			matrix = matrix[utils.style.transform].split(')')[0].split(', ');
			x = +(matrix[12] || matrix[4]);
			y = +(matrix[13] || matrix[5]);
		} else {
			x = +matrix.left.replace(/[^-\d.]/g, '');
			y = +matrix.top.replace(/[^-\d.]/g, '');
		}

		return { x: x, y: y };
	},

	_initIndicators: function () {
		var interactive = this.options.interactiveScrollbars,
			customStyle = typeof this.options.scrollbars != 'string',
			indicators = [],
			indicator;

		var that = this;

		this.indicators = [];

		if ( this.options.scrollbars ) {
			// Vertical scrollbar
			if ( this.options.scrollY ) {
				indicator = {
					el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenX: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}

			// Horizontal scrollbar
			if ( this.options.scrollX ) {
				indicator = {
					el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenY: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}
		}

		if ( this.options.indicators ) {
			// TODO: check concat compatibility
			indicators = indicators.concat(this.options.indicators);
		}

		for ( var i = indicators.length; i--; ) {
			this.indicators.push( new Indicator(this, indicators[i]) );
		}

		// TODO: check if we can use array.map (wide compatibility and performance issues)
		function _indicatorsMap (fn) {
			for ( var i = that.indicators.length; i--; ) {
				fn.call(that.indicators[i]);
			}
		}

		if ( this.options.fadeScrollbars ) {
			this.on('scrollEnd', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollCancel', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1);
				});
			});

			this.on('beforeScrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1, true);
				});
			});
		}


		this.on('refresh', function () {
			_indicatorsMap(function () {
				this.refresh();
			});
		});

		this.on('destroy', function () {
			_indicatorsMap(function () {
				this.destroy();
			});

			delete this.indicators;
		});
	},

	_initWheel: function () {
		utils.addEvent(this.wrapper, 'wheel', this);
		utils.addEvent(this.wrapper, 'mousewheel', this);
		utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

		this.on('destroy', function () {
			utils.removeEvent(this.wrapper, 'wheel', this);
			utils.removeEvent(this.wrapper, 'mousewheel', this);
			utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
		});
	},

	_wheel: function (e) {
		if ( !this.enabled ) {
			return;
		}

		e.preventDefault();
		e.stopPropagation();

		var wheelDeltaX, wheelDeltaY,
			newX, newY,
			that = this;

		if ( this.wheelTimeout === undefined ) {
			that._execEvent('scrollStart');
		}

		// Execute the scrollEnd event after 400ms the wheel stopped scrolling
		clearTimeout(this.wheelTimeout);
		this.wheelTimeout = setTimeout(function () {
			that._execEvent('scrollEnd',e);
			that.wheelTimeout = undefined;
		}, 400);

		if ( 'deltaX' in e ) {
			wheelDeltaX = -e.deltaX;
			wheelDeltaY = -e.deltaY;
		} else if ( 'wheelDeltaX' in e ) {
			wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
			wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
		} else if ( 'wheelDelta' in e ) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
		} else if ( 'detail' in e ) {
			wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
		} else {
			return;
		}

		wheelDeltaX *= this.options.invertWheelDirection;
		wheelDeltaY *= this.options.invertWheelDirection;

		if ( !this.hasVerticalScroll ) {
			wheelDeltaX = wheelDeltaY;
			wheelDeltaY = 0;
		}

		if ( this.options.snap ) {
			newX = this.currentPage.pageX;
			newY = this.currentPage.pageY;

			if ( wheelDeltaX > 0 ) {
				newX--;
			} else if ( wheelDeltaX < 0 ) {
				newX++;
			}

			if ( wheelDeltaY > 0 ) {
				newY--;
			} else if ( wheelDeltaY < 0 ) {
				newY++;
			}

			this.goToPage(newX, newY);

			return;
		}

		newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
		newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

		if ( newX > 0 ) {
			newX = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
		}

		if ( newY > 0 ) {
			newY = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
		}

		this.scrollTo(newX, newY, 0);

		if ( this.options.probeType > 1 ) {
			this._execEvent('scroll',e);
		}

// INSERT POINT: _wheel
	},

	_initSnap: function () {
		this.currentPage = {};

		if ( typeof this.options.snap == 'string' ) {
			this.options.snap = this.scroller.querySelectorAll(this.options.snap);
		}

		this.on('refresh', function () {
			var i = 0, l,
				m = 0, n,
				cx, cy,
				x = 0, y,
				stepX = this.options.snapStepX || this.wrapperWidth,
				stepY = this.options.snapStepY || this.wrapperHeight,
				el;

			this.pages = [];

			if ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {
				return;
			}

			if ( this.options.snap === true ) {
				cx = Math.round( stepX / 2 );
				cy = Math.round( stepY / 2 );

				while ( x > -this.scrollerWidth ) {
					this.pages[i] = [];
					l = 0;
					y = 0;

					while ( y > -this.scrollerHeight ) {
						this.pages[i][l] = {
							x: Math.max(x, this.maxScrollX),
							y: Math.max(y, this.maxScrollY),
							width: stepX,
							height: stepY,
							cx: x - cx,
							cy: y - cy
						};

						y -= stepY;
						l++;
					}

					x -= stepX;
					i++;
				}
			} else {
				el = this.options.snap;
				l = el.length;
				n = -1;

				for ( ; i < l; i++ ) {
					if ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {
						m = 0;
						n++;
					}

					if ( !this.pages[m] ) {
						this.pages[m] = [];
					}

					x = Math.max(-el[i].offsetLeft, this.maxScrollX);
					y = Math.max(-el[i].offsetTop, this.maxScrollY);
					cx = x - Math.round(el[i].offsetWidth / 2);
					cy = y - Math.round(el[i].offsetHeight / 2);

					this.pages[m][n] = {
						x: x,
						y: y,
						width: el[i].offsetWidth,
						height: el[i].offsetHeight,
						cx: cx,
						cy: cy
					};

					if ( x > this.maxScrollX ) {
						m++;
					}
				}
			}

			this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

			// Update snap threshold if needed
			if ( this.options.snapThreshold % 1 === 0 ) {
				this.snapThresholdX = this.options.snapThreshold;
				this.snapThresholdY = this.options.snapThreshold;
			} else {
				this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
				this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
			}
		});

		this.on('flick', function () {
			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.x - this.startX), 1000),
						Math.min(Math.abs(this.y - this.startY), 1000)
					), 300);

			this.goToPage(
				this.currentPage.pageX + this.directionX,
				this.currentPage.pageY + this.directionY,
				time
			);
		});
	},

	_nearestSnap: function (x, y) {
		if ( !this.pages.length ) {
			return { x: 0, y: 0, pageX: 0, pageY: 0 };
		}

		var i = 0,
			l = this.pages.length,
			m = 0;

		// Check if we exceeded the snap threshold
		if ( Math.abs(x - this.absStartX) < this.snapThresholdX &&
			Math.abs(y - this.absStartY) < this.snapThresholdY ) {
			return this.currentPage;
		}

		if ( x > 0 ) {
			x = 0;
		} else if ( x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( y > 0 ) {
			y = 0;
		} else if ( y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		for ( ; i < l; i++ ) {
			if ( x >= this.pages[i][0].cx ) {
				x = this.pages[i][0].x;
				break;
			}
		}

		l = this.pages[i].length;

		for ( ; m < l; m++ ) {
			if ( y >= this.pages[0][m].cy ) {
				y = this.pages[0][m].y;
				break;
			}
		}

		if ( i == this.currentPage.pageX ) {
			i += this.directionX;

			if ( i < 0 ) {
				i = 0;
			} else if ( i >= this.pages.length ) {
				i = this.pages.length - 1;
			}

			x = this.pages[i][0].x;
		}

		if ( m == this.currentPage.pageY ) {
			m += this.directionY;

			if ( m < 0 ) {
				m = 0;
			} else if ( m >= this.pages[0].length ) {
				m = this.pages[0].length - 1;
			}

			y = this.pages[0][m].y;
		}

		return {
			x: x,
			y: y,
			pageX: i,
			pageY: m
		};
	},

	goToPage: function (x, y, time, easing) {
		easing = easing || this.options.bounceEasing;

		if ( x >= this.pages.length ) {
			x = this.pages.length - 1;
		} else if ( x < 0 ) {
			x = 0;
		}

		if ( y >= this.pages[x].length ) {
			y = this.pages[x].length - 1;
		} else if ( y < 0 ) {
			y = 0;
		}

		var posX = this.pages[x][y].x,
			posY = this.pages[x][y].y;

		time = time === undefined ? this.options.snapSpeed || Math.max(
			Math.max(
				Math.min(Math.abs(posX - this.x), 1000),
				Math.min(Math.abs(posY - this.y), 1000)
			), 300) : time;

		this.currentPage = {
			x: posX,
			y: posY,
			pageX: x,
			pageY: y
		};
        this._execEvent('scrollEnd',{});
		this.scrollTo(posX, posY, time, easing);
	},

	next: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x++;

		if ( x >= this.pages.length && this.hasVerticalScroll ) {
			x = 0;
			y++;
		}

		this.goToPage(x, y, time, easing);
	},

	prev: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x--;

		if ( x < 0 && this.hasVerticalScroll ) {
			x = 0;
			y--;
		}

		this.goToPage(x, y, time, easing);
	},

	_initKeys: function (e) {
		// default key bindings
		var keys = {
			pageUp: 33,
			pageDown: 34,
			end: 35,
			home: 36,
			left: 37,
			up: 38,
			right: 39,
			down: 40
		};
		var i;

		// if you give me characters I give you keycode
		if ( typeof this.options.keyBindings == 'object' ) {
			for ( i in this.options.keyBindings ) {
				if ( typeof this.options.keyBindings[i] == 'string' ) {
					this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
				}
			}
		} else {
			this.options.keyBindings = {};
		}

		for ( i in keys ) {
			this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
		}

		utils.addEvent(window, 'keydown', this);

		this.on('destroy', function () {
			utils.removeEvent(window, 'keydown', this);
		});
	},

	_key: function (e) {
		if ( !this.enabled ) {
			return;
		}

		var snap = this.options.snap,	// we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			newY = snap ? this.currentPage.pageY : this.y,
			now = utils.getTime(),
			prevTime = this.keyTime || 0,
			acceleration = 0.250,
			pos;

		if ( this.options.useTransition && this.isInTransition ) {
			pos = this.getComputedPosition();

			this._translate(Math.round(pos.x), Math.round(pos.y));
			this.isInTransition = false;
		}

		this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

		switch ( e.keyCode ) {
			case this.options.keyBindings.pageUp:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX += snap ? 1 : this.wrapperWidth;
				} else {
					newY += snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.pageDown:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX -= snap ? 1 : this.wrapperWidth;
				} else {
					newY -= snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.end:
				newX = snap ? this.pages.length-1 : this.maxScrollX;
				newY = snap ? this.pages[0].length-1 : this.maxScrollY;
				break;
			case this.options.keyBindings.home:
				newX = 0;
				newY = 0;
				break;
			case this.options.keyBindings.left:
				newX += snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.up:
				newY += snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.right:
				newX -= snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.down:
				newY -= snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			default:
				return;
		}

		if ( snap ) {
			this.goToPage(newX, newY);
			return;
		}

		if ( newX > 0 ) {
			newX = 0;
			this.keyAcceleration = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
			this.keyAcceleration = 0;
		}

		if ( newY > 0 ) {
			newY = 0;
			this.keyAcceleration = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
			this.keyAcceleration = 0;
		}

		this.scrollTo(newX, newY, 0);

		this.keyTime = now;
	},

	_animate: function (destX, destY, duration, easingFn) {
		var that = this,
			startX = this.x,
			startY = this.y,
			startTime = utils.getTime(),
			destTime = startTime + duration;

		function step () {
			var now = utils.getTime(),
				newX, newY,
				easing;

			if ( now >= destTime ) {
				that.isAnimating = false;
				that._translate(destX, destY);

				if ( !that.resetPosition(that.options.bounceTime) ) {
					that._execEvent('scrollEnd',{});
				}

				return;
			}

			now = ( now - startTime ) / duration;
			easing = easingFn(now);
			newX = ( destX - startX ) * easing + startX;
			newY = ( destY - startY ) * easing + startY;
			that._translate(newX, newY);

			if ( that.isAnimating ) {
				rAF(step);
			}

			if ( that.options.probeType == 3 ) {
				that._execEvent('scroll',{});
			}
		}

		this.isAnimating = true;
		step();
	},

	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			case 'orientationchange':
			case 'resize':
				this._resize();
				break;
			case 'transitionend':
			case 'webkitTransitionEnd':
			case 'oTransitionEnd':
			case 'MSTransitionEnd':
				this._transitionEnd(e);
				break;
			case 'wheel':
			case 'DOMMouseScroll':
			case 'mousewheel':
				this._wheel(e);
				break;
			case 'keydown':
				this._key(e);
				break;
			case 'click':
				if ( !e._constructed ) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
		}
	}
};
function createDefaultScrollbar (direction, interactive, type) {
	var scrollbar = document.createElement('div'),
		indicator = document.createElement('div');

	if ( type === true ) {
		scrollbar.style.cssText = 'position:absolute;z-index:9999';
		indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
	}

	indicator.className = 'iScrollIndicator';

	if ( direction == 'h' ) {
		if ( type === true ) {
			scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
			indicator.style.height = '100%';
		}
		scrollbar.className = 'iScrollHorizontalScrollbar';
	} else {
		if ( type === true ) {
			scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
			indicator.style.width = '100%';
		}
		scrollbar.className = 'iScrollVerticalScrollbar';
	}

	scrollbar.style.cssText += ';overflow:hidden';

	if ( !interactive ) {
		scrollbar.style.pointerEvents = 'none';
	}

	scrollbar.appendChild(indicator);

	return scrollbar;
}

function Indicator (scroller, options) {
	this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
	this.wrapperStyle = this.wrapper.style;
	this.indicator = this.wrapper.children[0];
	this.indicatorStyle = this.indicator.style;
	this.scroller = scroller;

	this.options = {
		listenX: true,
		listenY: true,
		interactive: false,
		resize: true,
		defaultScrollbars: false,
		shrink: false,
		fade: false,
		speedRatioX: 0,
		speedRatioY: 0
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	this.sizeRatioX = 1;
	this.sizeRatioY = 1;
	this.maxPosX = 0;
	this.maxPosY = 0;

	if ( this.options.interactive ) {
		if ( !this.options.disableTouch ) {
			utils.addEvent(this.indicator, 'touchstart', this);
			utils.addEvent(window, 'touchend', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(this.indicator, 'MSPointerDown', this);
			utils.addEvent(window, 'MSPointerUp', this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(this.indicator, 'mousedown', this);
			utils.addEvent(window, 'mouseup', this);
		}
	}

	if ( this.options.fade ) {
		this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
		this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
		this.wrapperStyle.opacity = '0';
	}
}

Indicator.prototype = {
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
		}
	},

	destroy: function () {
		if ( this.options.interactive ) {
			utils.removeEvent(this.indicator, 'touchstart', this);
			utils.removeEvent(this.indicator, 'MSPointerDown', this);
			utils.removeEvent(this.indicator, 'mousedown', this);

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, 'MSPointerMove', this);
			utils.removeEvent(window, 'mousemove', this);

			utils.removeEvent(window, 'touchend', this);
			utils.removeEvent(window, 'MSPointerUp', this);
			utils.removeEvent(window, 'mouseup', this);
		}

		if ( this.options.defaultScrollbars ) {
			this.wrapper.parentNode.removeChild(this.wrapper);
		}
	},

	_start: function (e) {
		var point = e.touches ? e.touches[0] : e;

		e.preventDefault();
		e.stopPropagation();

		this.transitionTime();

		this.initiated = true;
		this.moved = false;
		this.lastPointX	= point.pageX;
		this.lastPointY	= point.pageY;

		this.startTime	= utils.getTime();

		if ( !this.options.disableTouch ) {
			utils.addEvent(window, 'touchmove', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(window, 'MSPointerMove', this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(window, 'mousemove', this);
		}

		this.scroller._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		var point = e.touches ? e.touches[0] : e,
			deltaX, deltaY,
			newX, newY,
			timestamp = utils.getTime();


		if ( !this.moved ) {
			this.scroller._execEvent('scrollStart');
		}

		this.moved = true;

		deltaX = point.pageX - this.lastPointX;
		this.lastPointX = point.pageX;

		deltaY = point.pageY - this.lastPointY;
		this.lastPointY = point.pageY;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		this._pos(newX, newY);


		if ( this.scroller.options.probeType == 1 && timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.scroller._execEvent('scroll',e);
		} else if ( this.scroller.options.probeType > 1 ) {
			this.scroller._execEvent('scroll',e);
		}


// INSERT POINT: indicator._move

		e.preventDefault();
		e.stopPropagation();
	},

	_end: function (e) {
		if ( !this.initiated ) {
			return;
		}

		this.initiated = false;

		e.preventDefault();
		e.stopPropagation();

		utils.removeEvent(window, 'touchmove', this);
		utils.removeEvent(window, 'MSPointerMove', this);
		utils.removeEvent(window, 'mousemove', this);

		if ( this.scroller.options.snap ) {
			var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.scroller.x - snap.x), 1000),
						Math.min(Math.abs(this.scroller.y - snap.y), 1000)
					), 300);

			if ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {
				this.scroller.directionX = 0;
				this.scroller.directionY = 0;
				this.scroller.currentPage = snap;
				this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
			}
		}

		if ( this.moved ) {
			this.scroller._execEvent('scrollEnd',e);
		}
	},

	transitionTime: function (time) {
		time = time || 0;
		this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
		}
	},

	transitionTimingFunction: function (easing) {
		this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
	},

	refresh: function () {
		this.transitionTime();

		if ( this.options.listenX && !this.options.listenY ) {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
		} else if ( this.options.listenY && !this.options.listenX ) {
			this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
		} else {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
		}

		if ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {
			utils.addClass(this.wrapper, 'iScrollBothScrollbars');
			utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '8px';
				} else {
					this.wrapper.style.bottom = '8px';
				}
			}
		} else {
			utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
			utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '2px';
				} else {
					this.wrapper.style.bottom = '2px';
				}
			}
		}

		var r = this.wrapper.offsetHeight;	// force refresh

		if ( this.options.listenX ) {
			this.wrapperWidth = this.wrapper.clientWidth;
			if ( this.options.resize ) {
				this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
				this.indicatorStyle.width = this.indicatorWidth + 'px';
			} else {
				this.indicatorWidth = this.indicator.clientWidth;
			}

			this.maxPosX = this.wrapperWidth - this.indicatorWidth;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryX = -this.indicatorWidth + 8;
				this.maxBoundaryX = this.wrapperWidth - 8;
			} else {
				this.minBoundaryX = 0;
				this.maxBoundaryX = this.maxPosX;
			}

			this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
		}

		if ( this.options.listenY ) {
			this.wrapperHeight = this.wrapper.clientHeight;
			if ( this.options.resize ) {
				this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
				this.indicatorStyle.height = this.indicatorHeight + 'px';
			} else {
				this.indicatorHeight = this.indicator.clientHeight;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryY = -this.indicatorHeight + 8;
				this.maxBoundaryY = this.wrapperHeight - 8;
			} else {
				this.minBoundaryY = 0;
				this.maxBoundaryY = this.maxPosY;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;
			this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
		}

		this.updatePosition();
	},

	updatePosition: function () {
		var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

		if ( !this.options.ignoreBoundaries ) {
			if ( x < this.minBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth + x, 8);
					this.indicatorStyle.width = this.width + 'px';
				}
				x = this.minBoundaryX;
			} else if ( x > this.maxBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
					this.indicatorStyle.width = this.width + 'px';
					x = this.maxPosX + this.indicatorWidth - this.width;
				} else {
					x = this.maxBoundaryX;
				}
			} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {
				this.width = this.indicatorWidth;
				this.indicatorStyle.width = this.width + 'px';
			}

			if ( y < this.minBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight + y * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
				}
				y = this.minBoundaryY;
			} else if ( y > this.maxBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
					y = this.maxPosY + this.indicatorHeight - this.height;
				} else {
					y = this.maxBoundaryY;
				}
			} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {
				this.height = this.indicatorHeight;
				this.indicatorStyle.height = this.height + 'px';
			}
		}

		this.x = x;
		this.y = y;

		if ( this.scroller.options.useTransform ) {
			this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
		} else {
			this.indicatorStyle.left = x + 'px';
			this.indicatorStyle.top = y + 'px';
		}
	},

	_pos: function (x, y) {
		if ( x < 0 ) {
			x = 0;
		} else if ( x > this.maxPosX ) {
			x = this.maxPosX;
		}

		if ( y < 0 ) {
			y = 0;
		} else if ( y > this.maxPosY ) {
			y = this.maxPosY;
		}

		x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
		y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

		this.scroller.scrollTo(x, y);
	},

	fade: function (val, hold) {
		if ( hold && !this.visible ) {
			return;
		}

		clearTimeout(this.fadeTimeout);
		this.fadeTimeout = null;

		var time = val ? 250 : 500,
			delay = val ? 0 : 300;

		val = val ? '1' : '0';

		this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

		this.fadeTimeout = setTimeout((function (val) {
			this.wrapperStyle.opacity = val;
			this.visible = +val;
		}).bind(this, val), delay);
	}
};

IScroll.utils = utils;

if ( typeof module != 'undefined' && module.exports ) {
	module.exports = IScroll;
} else {
	window.iScroll = IScroll;
}

})(window, document, Math);
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    var pixiContext  = manager.options.pixiContext;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    // 小包装的处理句柄，用来为manager启动状态和作用域
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            if(pixiContext){
                self.handler(ev.originalEvent);
            }else{
                self.handler(ev);
            }
        }
    };

    if (pixiContext) {
        pixiContext.mousedown = pixiContext.touchstart = function(ev){
            manager.options.returnStart(ev.originalEvent);
            self.domHandler(ev)
        }
        pixiContext.mousemove = pixiContext.touchmove = function(ev){
            manager.options.returnMove(ev.originalEvent);
            self.domHandler(ev)
        }
        pixiContext.mouseup   = pixiContext.touchend = this.domHandler
    } else {
        this.init();
    }
}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     * 开始绑定事件
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        //move up事件绑到window上面
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * 用个这Manager构造器创建一个输入类型的管理
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput; //移动手机端
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput; //桌面
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * 处理输入事件
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    //触发点数量
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    //输入的顺序
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    //取布尔值
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    // 计算缩放、旋转等
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    //运行识别器
    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * 扩展数据和一些有用的属性如缩放、旋转、速度等
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    // 多点判断
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';


/**
 * 鼠标输入，桌面PC
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    //用来禁止TouchMouse事件
    this.allow = true; // used by Input.TouchMouse to disable mouse events
    //鼠标按下的状态
    this.pressed = false; // mousedown state
    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        //定义的事件类型
        // mousedown: 1
        // mousemove: 2
        // mouseup: 4
        var eventType = MOUSE_INPUT_MAP[ev.type];


        // on start we want to have the left mouse button down
        // 开始我们按下鼠标左键
        if (eventType & INPUT_START && ev.button === 0) {
            //按下标记
            this.pressed = true;
        }

        //如果是移动事件，并且不是左键触发  
        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        // 如果鼠标不是通过按下触发的，算错误的处理，直接返回
        if (!this.pressed || !this.allow) {
            return;
        }

        //如果是up事件
        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * 识别器流程
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * 每一个识别器都要需要继承基类
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        // 拷贝一份新的输入对象
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});


/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    //配置手势识别器参数
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * 如果DOM事件被触发设置设置DOM事件
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    //存在on回调
    //swipe [callback1,callback2...]
    //tap [callback1,callback2...]
    this.handlers = {};

    this.session = {};

    //存放手势对象
    this.recognizers = [];

    this.element = element;

    //创建一个输入环境的实例对象
    //绑定事件与增加处理的句柄回调函数
    this.input = createInputInstance(this);

    //用于处理元素对touchAction的属性的支持
    if (!this.options.pixiContext) {
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
    }

    //默认初始化手势
    each(options.recognizers, function(item) {
        //构建手势对象，增加到手势容器里面
        var recognizer = this.add(new (item[0])(item[1]));
        //如果有合并的手势处理
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction && this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];
            // find out if we are allowed try to recognize the input for this one.
            // 果我们允许尝试识别的输入，找到它
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * 通过手势的事件名得到手势对象
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        // 如果存在指定手势，删除
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        //加入管理队列
        this.recognizers.push(recognizer);
        recognizer.manager = this;

        //更新touchAction属性
        this.touchAction && this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction && this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');
/**
 * 电子杂志
 * 2012,5,7
 *
 * @by Aaron
 *
 * @requires Zepto JavaScript Library
 *
 * 第一次重构
 * 2012.8.31 修改模块模式
 * 2012.9.2  增加 沙箱模式管理
 * 2012.9.8  增加 模块扩展接口
 * 2012.9.10 修改 符合common js 规范
 * 2012.9.13 数据分段加载
 * 2012.9.14 修复折叠bug
 * 2012.10.10 模块化热点类
 *
 *
 * 2013.2.28 开始第二次重构
 * 2013.3.1  增加常用方法
 *
 *
 * @class Xut
 * 杂志的核心工具类
 *
 *   1 常用工具
 *   2 事件管理
 *   3 模块加载
 *   4 类继承
 *
 * @singleton
 */
Xut = {
    Plugin: {}//插件
};

/**
 * 复制config对象的所有属性到obj
 *（第一个参数为obj，第二个参数为config）。
 * @param  {[type]} o        [属性接受方对象]
 * @param  {[type]} c        [属性源对象]
 * @param  {[type]} defaults [默认对象，如果该参数存在，obj将会得到那些defaults有而config没有的属性]
 * @return {[type]}          [description]
 */
Xut.apply = function(object, config, defaults) {
    if (defaults) {
        Xut.apply(object, defaults);
    }

    if (object && config && typeof config === 'object') {
        var i, j, k;

        for (i in config) {
            object[i] = config[i];
        }
    }
    return object;
};

//插件命名空间
Xut.plugins = {};

(function(global, DOC , Xut) {

    var ArrayProto = Array.prototype,
        ObjProto   = Object.prototype,
        FuncProto  = Function.prototype;

    var slice            = ArrayProto.slice,
        unshift          = ArrayProto.unshift,
        toString         = ObjProto.toString,
        hasOwnProperty   = ObjProto.hasOwnProperty;

    var
        nativeForEach      = ArrayProto.forEach,
        nativeMap          = ArrayProto.map,
        nativeReduce       = ArrayProto.reduce,
        nativeReduceRight  = ArrayProto.reduceRight,
        nativeFilter       = ArrayProto.filter,
        nativeEvery        = ArrayProto.every,
        nativeSome         = ArrayProto.some,
        nativeIndexOf      = ArrayProto.indexOf,
        nativeLastIndexOf  = ArrayProto.lastIndexOf,
        nativeIsArray      = Array.isArray,
        nativeKeys         = Object.keys,
        nativeBind         = FuncProto.bind;

    /**
     * 返回true,如果传递的值不是未定义。
     * @param {Mixed}
     * @return {Boolean}
     */
    function isDefined(v) {
        return typeof v !== 'undefined';
    }

    /**
     * 拷贝对象，跳过已存在的
     * @param  {[type]} o [接受方对象]
     * @param  {[type]} c [源对象]
     * @return {[type]}   [description]
     */
    function applyIf(o, c) {
        if (o) {
            for (var p in c) {
                //跳过已存在
                if (!isDefined(o[p])) {
                    o[p] = c[p];
                }
            }
        }
        return o;
    }

    //=================================继承方法=================================
    //
    Xut.apply(Xut, {

        /**
          * 继承，并由传递的值决定是否覆盖原对象的属性
          * 返回的对象中也增加了 override() 函数，用于覆盖实例的成员
          * @param { Object } subclass 子类，用于继承（该类继承了父类所有属性，并最终返回该对象）
          * @param { Object } superclass 父类，被继承
          * @param { Object } overrides （该参数可选） 一个对象，将它本身携带的属性对子类进行覆盖
          * @method extend
          */
        extend: (function() {
            //覆盖
            var io = function(o) {
                    for(var m in o) {
                        this[m] = o[m];
                    }
                };

            //顶层原型对象
            var oc = ObjProto.constructor;

            return function(subClass, superClass, overrides) {

                //参数移位
                if(typeof superClass == 'object') {
                    overrides = superClass;
                    superClass = subClass;
                    //如果overrides中含有constructor就是子类的构造器
                    subClass = overrides.constructor != oc ? overrides.constructor : function() {
                        superClass.apply(this, arguments);
                    };
                }

                var F = function() {},
                    subClassPrototype,
                    superClassPrototype = superClass.prototype;

                //简单继承
                F.prototype = superClassPrototype;
                subClassPrototype = subClass.prototype = new F();
                subClassPrototype.constructor = subClass;


                // 添加了 superclass 属性指向 superclass 的 prototype
                // 子类调用父类构造函数
                subClass.superclass = superClassPrototype;
                if(superClassPrototype.constructor == oc) {
                    superClassPrototype.constructor = superClass;
                }

                // 为 subClass 和 subClassPrototype 添加 override 函数
                subClass.override = function(o) {
                    Xut.override(subClass, o);
                };
                subClassPrototype.superclass = (function() {
                    return superClassPrototype;
                });
                subClassPrototype.override = io;

                //静态拷贝
                Xut.override(subClass, overrides);

                //子类具有继承功能
                subClass.extend = function(o) {
                    return Xut.extend(subClass, o);
                };

                return subClass;
            };

        })(),

        override:function (origclass, overrides) {
            if (overrides) {
                var p = origclass.prototype;
                for (var method in overrides) {
                    p[method] = overrides[method];
                }
            }
        },

        //生成32位UUID的方法
        createUUID : (function(uuidRegEx, uuidReplacer) {
            return function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
            };
        })(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0,
                v = c == "x" ? r : (r & 3 | 8);
            return v.toString(16);
        }),

        /**
         * 将任何可以迭代的对象转化成数组
         * @return {[type]} [description]
         */
        toArray: function(a, i, j) {
            return slice.call(a, i || 0, j || a.length);
        },

        /**
         * 创建一个唯一的uuid
         * @param  {[type]} pre [description]
         * @return {[type]}     [description]
         */
        guid: function(pre) {
            return(pre || 'Xut_') + (+new Date()) + (Math.random() + '').slice(-8);
        }

    });

    /**
     * @class String
     * 格式化字符串
     */
    applyIf(String, {
        format:function (format) {
            var args = Xut.toArray(arguments, 1);
            return format.replace(/\{(\d+)\}/g, function (m, i) {
                return args[i];
            });
        }
    });


})(this, this.document , Xut);


//模拟继承
Xut.CoreObject = function() {};

Xut.CoreObject.extend = function(props) {
    var init, subObj;

    props = props || {};
    // Set up the constructor using the supplied init method
    // or using the init of the parent object

    init = props.init || this.prototype.init || function() {};

    subObj = function() {
        init.apply(this, arguments);
    };

    // Inherit from this object's prototype
    subObj.prototype = Object.create(this.prototype);
    // Reset the constructor property for subObj otherwise
    // instances of subObj would have the constructor of the parent Object
    subObj.prototype.constructor = subObj;

    // Make the class extendable
    subObj.extend = Xut.CoreObject.extend;

    // Extend subObj's prototype with functions and other properties from props
    for (var name in props) {
        if (props.hasOwnProperty(name)) {
            subObj.prototype[name] = props[name];
        }
    }

    return subObj;
};

/**
 * 当监听的节点内容发生变化时,触发指定的回调
 * @param opts {
 *   container:父容器,dom对象或jQuery对象
 *   content  :要加入父容器的内容,字符串或jQuery对象
 *   position :内容插入父容器的位置,'first' 表示在前加入,默认在末尾
 *   delay    :延时,默认0
 *   }
 * @version  1.02
 * @author [author] bjtqti
 * @return {[type]} [description]
 */

Xut.nextTick = new function() {
    var DOC = document,
        MutationObserver = window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver;

    function nextTick(opts, callback, context) {
        // console.log('nextTick: '+ opts)
        var container  = opts.container,
            content    = opts.content,
            delay      = opts.delay||0,
            position   = opts.position,
            animatId   = 'T'+ (Math.random()*10000 << 1),
            tick       = DOC.createElement('input'),
            observer   = null;

        if (!container || !content) {
            return;
        }

        //检查容器---$(container) 转为dom对象
        if(typeof container === 'object' && container.selector !== undefined){
            container = container[0];
        }

        if(container.nodeType !== 1){
            console.log('container must be HTMLLIElement ');
            return;
        }

        //标记任务
        tick.setAttribute('value',animatId);

        //检查内容
        if(typeof content ==='string'){
            var temp = $(content);
            if(!temp[0]){
                //纯文本内容
                temp = DOC.createTextNode(content);
                temp = $(temp);
            }
            content = temp;
        }

       //组装内容到临时片段
        function _createFragment(){
            var frag = DOC.createDocumentFragment(),
                len = content.length;
            for(var i=0;i<len;i++){
                frag.appendChild(content[i]);
            }
            return frag;
        }

        //将内容加入父容器
        function _appendChild(){
            //拼接内容
            content = _createFragment();
            content.appendChild(tick);
            //判断插入的位置
            if(position === 'first'){
                container.insertBefore(content, container.firstChild);
            }else{
                container.appendChild(content);
            }
            //触发变动事件
            tick.setAttribute('value',animatId);
        }

        //完成任务后处理&Event
        function _finishTask(event) {
            if(event.target.value === animatId){
                //container.removeEventListener('DOMNodeRemoved',_finishTask,false);
                container.removeEventListener('DOMNodeInserted',_finishTask,false);
                callback.call(context);
            }
        }

        //完成任务后处理&Observer
        function _completeTask() {
            container.removeChild(tick);
            callback.call(context);
        }

        if(MutationObserver){
            observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(record) {
                    if(record.oldValue === animatId){
                        _completeTask();
                        observer = null;
                    }
                });
            });

            //设置要监听的属性
            observer.observe(tick, {
                attributes: true,
                //childList: true,
                attributeOldValue :true,
                attributeFilter:["value"]//只监听value属性,提高性能
            });

            _appendChild();

        }else{

            //检测是否支持DOM变动事件
            if(DOC.implementation.hasFeature("MutationEvents","2.0")){
                //container.addEventListener('DOMNodeRemoved',_finishTask,false);
                container.addEventListener('DOMNodeInserted',_finishTask,false);
                _appendChild();
                container.removeChild(tick);
            }else{
                //歉容Android2.xx处理
                _appendChild();
                setTimeout(function () {
                    _completeTask();
                }, delay);
            }
        }
    }

    return nextTick;
}


///////////
//设备平台判断 //
///////////
;(function() {

  //在读酷pc端 navigator的值被改写过了!!
  //navigator.appVersion: "xxt 1.0.5260.29725"
   var ua =  navigator.userAgent,
       uv = navigator.appVersion,
       _style         = document.documentElement.style,
       _cache         = {},
       TRANSITION_END = 'transitionend',
       ANIMATION_END  = 'animationend',
       KEYFRAMES      = '@keyframes ',
       isAndroid      = (/android/gi).test(uv),
       isIphone       = (/iphone|ipod/gi).test(ua),
       isIpad         = (/ipad/gi).test(ua),
       isIOS          = isIphone || isIpad,
       isIOS7         = isIOS && (/OS\s7/gi).test(ua),
       has3d          = 'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix();

       //针对win8的处理
       var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
       //支持触屏
       var SUPPORT_TOUCH = ('ontouchstart' in window);
       //支持鼠标
       var SUPPORT_MOUSE = ('onmousedown' in window);

       //移动端仅仅只支持touch
       var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

       //判断是否为浏览器
       var org_href = document.location.href;
       var boolBrowser = org_href.indexOf('http') > -1 || org_href.indexOf('https') > -1;

       function evtTarget(event, original) {
           var currTouches = null;
           if (SUPPORT_ONLY_TOUCH) {
             currTouches = event.touches;
             if (currTouches && currTouches.length > 0) {
               event = currTouches[0];
             }
           }
           return original ? event : event.target;
       }

       function prefixStyle(attr) {
          var vendors = ['webkit', 'Moz', 'ms', 'o'];
          var name;
          //缓存中存在
          if(_cache[attr]){
            return _cache[attr];
          }
          //不需要加前缀
          if(attr in _style){
            return _cache[attr] = attr;
          }
          //需要加前缀
          _.each(vendors,function(v){
            if(jQuery.camelCase(v+'-'+attr) in _style){
              name = '-' + v + '-' + attr;
              return _cache[attr] = name;
            }
          })

          return name;
      }

    (function() {
      var vendors, TRANSITION_END_NAMES, ANIMATION_END_NAMES;
      vendors = prefixStyle('animation'),
        TRANSITION_END_NAMES = {
          "moz"    : "transitionend",
          "webkit" : "webkitTransitionEnd",
          "ms"     : "MSTransitionEnd",
          "o"      : "oTransitionEnd"
        }
      ANIMATION_END_NAMES = {
        "moz"    : "animationend",
        "webkit" : "webkitAnimationEnd",
        "ms"     : "MSAnimationEnd",
        "o"      : "oAnimationEnd"
      };

      if (!vendors) return;
      vendors = vendors.split('-');
      if (!vendors[1]) return;
      
      TRANSITION_END = TRANSITION_END_NAMES[vendors[1]];
      ANIMATION_END = ANIMATION_END_NAMES[vendors[1]];
      KEYFRAMES = '@-' + vendors[1] + '-keyframes ';
    })();


    //平台判断参数
    var plat = Xut.plat = {
        has3d          : has3d,
        isAndroid      : isAndroid,
        isIphone       : isIphone,
        isIpad         : isIpad,
        isIOS          : isIOS,
        isIOS7         : isIOS7,
        isOverflow     : ("WebkitOverflowScrolling" in _style),
        hasTouch       : SUPPORT_ONLY_TOUCH,
        //游览器平台 解决ios Android浏览器判断问题
        isBrowser      : boolBrowser ? boolBrowser : !SUPPORT_ONLY_TOUCH,
        //2015.3.23 
        //可以点击与触摸
        isSurface      : SUPPORT_TOUCH && SUPPORT_MOUSE && !SUPPORT_ONLY_TOUCH,
        RESIZE_EV      : 'onorientationchange' in window ? 'orientationchange' : 'resize',
        START_EV       : SUPPORT_ONLY_TOUCH ? 'touchstart' : 'mousedown',
        MOVE_EV        : SUPPORT_ONLY_TOUCH ? 'touchmove' : 'mousemove',
        END_EV         : SUPPORT_ONLY_TOUCH ? 'touchend' : 'mouseup',
        CANCEL_EV      : SUPPORT_ONLY_TOUCH ? 'touchcancel' : 'mouseup',
        ANIMATION_EV   : ANIMATION_END,
        TRANSITION_EV  : TRANSITION_END,
        evtTarget      : evtTarget,
        prefixStyle    : prefixStyle,
        KEYFRAMES      : KEYFRAMES,
        noMaskBoxImage : prefixStyle('mask-box-image') == undefined
    };

    /**
     * 针对content中的html文本框
     * 增加rem的修改
     * @param  {[type]} doc [description]
     * @param  {[type]} win [description]
     * @return {[type]}     [description]
     */
    // (function(doc, win) {
    //   var docEl = doc.documentElement,
    //     resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
    //     recalc = function() {
    //       var clientWidth = docEl.clientWidth;
    //       if (!clientWidth) return;
    //       docEl.style.fontSize = (20 * (clientWidth / 320)/12) + 'px';
    //     };

    //   if (!doc.addEventListener) return;
    //   win.addEventListener(resizeEvt, recalc, false);
    //   doc.addEventListener('DOMContentLoaded', recalc, false);
    // })(document, window);

    /////////////////////////////////////////////////////////
    ///2015.3.24 新增
    //=====================事件单独处理========================= //
    //1 isBrowser
    //2 isMobile
    //3 isSurface
    /////////////////////////////////////////////////////////

    //2015.3.23 
    //可以点击与触摸
    var isSurface = plat.isSurface;
    //触发事件名
    var touchName = ['touchstart', 'touchmove', 'touchend', TRANSITION_END];
    var mouseName = ['mousedown', 'mousemove', 'mouseup', TRANSITION_END];
    var EVENT_NAME = function(){
        if (isSurface) {
          return {
            touch: touchName,
            mouse: mouseName
          }
        }
       return [plat.START_EV, plat.MOVE_EV, plat.END_EV, TRANSITION_END];
    }();

    /**
     * 合并事件绑定处理
     * 因为isSurface设备上
     * 要同时支持2种方式
     * @return {[type]} [description]
     */
    function bindEvent(events, callback) {
        callback.start && this.addEventListener(events[0], callback.start, false);
        callback.move && this.addEventListener(events[1], callback.move, false);
        callback.end && this.addEventListener(events[2], callback.end, false);
        callback.transitionend && this.addEventListener(events[3], callback.transitionend, false);
    }

    function removeEvent(events, callback) {
        callback.start && this.removeEventListener(events[0], callback.start, false);
        callback.move && this.removeEventListener(events[1], callback.move, false);
        callback.end && this.removeEventListener(events[2], callback.end, false);
        callback.transitionend && this.removeEventListener(events[3], callback.transitionend, false);
    }

    /**
     * processor
     * @param  {[type]}   processor    [处理器]
     * @param  {[type]}   eventContext [上下文]
     * @param  {Function} callback     [回调函数]
     * @return {[type]}                [description]
     */
    function execEvent(processor, eventContext, callback) {
        //如果两者都支持
        //鼠标与触摸
        if (isSurface) {
          // touch :['touchstart','touchmove','touchend'],
          // mouse :['mousedown','mousemove','mouseup']
          _.each(EVENT_NAME, function(events) {
            processor.call(eventContext, events, callback);
          })
        } else {
           processor.call(eventContext, EVENT_NAME, callback);
        }
    }


    /**
     * 合并事件绑定处理
     * 因为isSurface设备上
     * 要同时支持2种方式
     * @return {[type]} [description]
     */
    // Xut.plat.execEvent('on/off',{
    //     context : eventContext,
    //     callback:{
    //         start   : start,
    //         move    : move,
    //         end     : end
    //     }
    // })
    Xut.plat.execEvent = function(eventName, opts) {
        var eventContext = opts.context;
        var callback     = opts.callback;
        if (eventName === 'on') {
          execEvent(bindEvent, eventContext, callback)
        }
        if (eventName === 'off') {
          execEvent(removeEvent, eventContext, callback)
        }
    }   

    //如果execEvent的callback绑定的this
    // Xut.plat.handleEvent(e, {
    //     start: function(e) {
    //         self.onTouchStart(e);
    //     },
    //     move: function(e) {
    //         self.onTouchMove(e);
    //     },
    //     end: function(e) {
    //         self.onTouchEnd(e);
    //     },
    //     transitionend: function(e) {
    //         self.onAnimComplete(e);
    //     }
    // })
    Xut.plat.handleEvent = function(processor, context, event) {
        switch (event.type) {
          case 'touchstart':
          case 'mousedown':
            processor.start && processor.start.call(context,event)
            break;
          case 'touchmove':
          case 'mousemove':
            processor.move && processor.move.call(context,event)
            break;
          case 'touchend':
          case 'mouseup':
            processor.end && processor.end.call(context,event)
            break;
          case TRANSITION_END:
            processor.transitionend && processor.transitionend.call(context,event)
            break;
        }
    } 

 })();


/*
     **  frame窗口通信指导
     **  PMS 用于frame窗口之间通信
     **  PMS对象暴露三个接口
     * bind : 用于注册事件，当有窗口发送消息过来并且类匹配时，则会触发注册时相应的回调函数
     * send : 用于向指定的目标窗口发送信息
     * unbind : 取消之肖注册的事件
     *
     * 使用demo
     * 现在假设我们有两个frame窗口,一个是主窗口mainFrame ,一个是子窗口childFrame
     * 现在我们得在两个frame窗口中进行消息传递,则我们可以像下面这样操作
     *
     * 1 、 mainFrame传递消息到childFrame
     *    1.1 childFrame注册事件，在childFrame的js代码中
     *    PMS.bind('onload' , function(e){} , '*')
     *    此时childFrame已经注册了消息处理，当有窗口往childFrame消息事，此处注册的回调就会被执行
     *    参数{onload : 消息类型 , function : 回调函数 , '*' : 消息通信的域}
     *
     *    1.2 此时子窗口已准备，等待其它窗口发送消息的到来
     *    此时mainFrame给childFrame发送一个消息
     *    此处写在mainFrame的代码中
     *    PMS.send({
     *        target : frames[0],       //发送到目标窗口
     *        url :                     //URL
     *        type : 'onload' ,         //消息类型
     *        data : {                  //附带数据
     *            name : 'alice' ,
     *            age : 27
     *        },
     *        success : function(){     //成功回调
     *        },
     *        error : function(e){      //失败回调
     *        }
     *    });
     *
     *
     *   其它frame通信跟上面差不多,
     *   多个frame之间也能相互通信，只要通信目标正确即可
     *
     *   如果是子窗口发信息给父窗口，则像下面之样即可
     *   PMS.send({
     *       target : window.parent
     *       其它参数与上面相同
     *   });
     *
     *    target : 必填
     *    type : 必填
     *    其它参数可选
     *
     *    参考
     *    https://developer.mozilla.org/en-US/docs/DOM/window.postMessage
     *
     *  了解更多可分析下面源码
     *
 */

(function(glob) {
    var PMS = function(options) {
        pm.send(options);
    };
    PMS.send = PMS;

    PMS.bind = function(type, fn, origin, hash, async_reply) {
        pm.bind(type, fn, origin, hash, async_reply === true);
    };

    PMS.event = {

        onData: function(fn, origin, hash, async_reply) {
            PMS.bind('onData', fn, origin || '*', hash, async_reply);
        },

        onLoad : function(fn, origin, hash, async_reply){
            PMS.bind('onLoad' , fn , origin || '*' , hash , async_reply);
        },

        onDestory :function(fn, origin, hash, async_reply){
            PMS.bind('onDestory' , fn ,  origin || '*' , hash , async_reply);
        },

        onHide : function(fn, origin, hash, async_reply){
            PMS.bind('onHide' , fn ,  origin || '*' , hash , async_reply);
        },

        onShow : function(fn, origin, hash, async_reply){
            PMS.bind('onShow' , fn ,  origin || '*' , hash , async_reply);
        },
        onFullscreen : function(fn, origin, hash, async_reply){
            PMS.bind('onFullscreen' , fn ,  origin || '*' , hash , async_reply);
        }
    };

    PMS.unbind = function(type, fn) {
        pm.unbind(type, fn);
    };

    var extend = function(destination, source) {
        for (var property in source) {
            destination[property] = source[property];
        }
        return destination;
    };

    var pm = {

        send: function(options) {
            var o = extend(pm.defaults, options),
                target = o.target;
            if (!o.target) {
                console.warn("消息目标窗口必须填写!");
                return;
            }
            var msg = {
                data: o.data,
                type: o.type
            };
            if (o.success) {
                msg.callback = pm._callback(o.success);
            }
            if (o.error) {
                msg.errback = pm._callback(o.error);
            }
            if (("postMessage" in target) && !o.hash) {
                pm._bind();
                target.postMessage(JSON.stringify(msg), o.origin || '*');
            }
        },

        bind: function(type, fn, origin, hash, async_reply) {
            pm._replyBind(type, fn, origin, hash, async_reply);
        },

        _replyBind: function(type, fn, origin, hash, isCallback) {
            if (("postMessage" in window) && !hash) {
                pm._bind();
            }
            var l = pm.data("listeners.postmessage");
            if (!l) {
                l = {};
                pm.data("listeners.postmessage", l);
            }
            var fns = l[type];
            if (!fns) {
                fns = [];
                l[type] = fns;
            }
            fns.push({
                fn: fn,
                callback: isCallback,
                origin: origin || $.pm.origin
            });
        },

        unbind: function(type, fn) {
            var l = pm.data("listeners.postmessage"),
                c = pm.data("callbacks.postmessage");
            if (l) {
                if (type) {
                    if (fn) {
                        var fns = l[type];
                        if (fns) {
                            var m = [];
                            for (var i = 0, len = fns.length; i < len; i++) {
                                var o = fns[i];
                                if (o.fn !== fn) {
                                    m.push(o);
                                }
                            }
                            l[type] = m;
                        }
                    } else {
                        delete l[type];
                    }
                } else {
                    for (var i in l) {
                        delete l[i];
                    }
                }
            }

            if (c) {
                if (type) {
                    if (fn) {
                        var fns = c[type];
                        if (fns) {
                            var m = [];
                            for (var i = 0, len = fns.length; i < len; i++) {
                                var o = fns[i];
                                if (o.fn !== fn) {
                                    m.push(o);
                                }
                            }
                            c[type] = m;
                        }
                    } else {
                        delete c[type];
                    }
                } else {
                    for (var i in c) {
                        delete c[i];
                    }
                }
            }
        },

        data: function(k, v) {
            if (v === undefined) {
                return pm._data[k];
            }
            pm._data[k] = v;
            return v;
        },

        _data: {},

        _generate: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        },

        _callback: function(fn) {
            var cbs = pm.data("callbacks.postmessage");
            if (!cbs) {
                cbs = {};
                pm.data("callbacks.postmessage", cbs);
            }
            var r = pm._generate();
            cbs[r] = fn;
            return r;
        },

        _bind: function() {
            if (!pm.data("listening.postmessage")) {
                if (window.addEventListener) {
                    window.addEventListener("message", pm._dispatch, false);
                } else if (window.attachEvent) {
                    window.attachEvent("onmessage", pm._dispatch);
                }
                pm.data("listening.postmessage", 1);
            }
        },
        _dispatch: function(e) {
            try {
                var msg = JSON.parse(e.data);
            } catch (ex) {
                console.warn("消息的数据是无效的json", ex);
                return;
            }
            if (!msg.type) {
                console.warn("必须填写对应的消息类型");
                return;
            }
            var cbs = pm.data("callbacks.postmessage") || {},
            cb = cbs[msg.type];
            if (cb) {
                cb(msg.data);
            } else {
                var l = pm.data("listeners.postmessage") || {};
                var fns = l[msg.type] || [];
                for (var i = 0, len = fns.length; i < len; i++) {
                    var o = fns[i];
                    if (o.origin && o.origin !== '*' && e.origin !== o.origin) {
                        console.warn("消息来源不匹配!", e.origin, o.origin);
                        if (msg.errback) {
                            var error = {
                                message: "消息来源不匹配",
                                origin: [e.origin, o.origin]
                            };

                            pm.send({
                                target: e.source,
                                data: error,
                                type: msg.errback
                            });
                        }
                        continue;
                    }

                    function sendReply(data) {
                        if (msg.callback) {
                            pm.send({
                                target: e.source,
                                data: data,
                                type: msg.callback
                            });
                        }
                    }
                    try {
                        if (o.callback) {
                            o.fn(msg.data, sendReply, e);
                        } else {
                            sendReply(o.fn(msg.data, e));
                        }
                    } catch (ex) {
                        if (msg.errback) {
                            pm.send({
                                target: e.source,
                                data: ex,
                                type: msg.errback
                            });
                        } else {
                            throw ex;
                        }
                    }
                };
            }
        }
    };

    pm.defaults = {
        target: null,
        /* 目标窗口 (required) */
        url: null,
        /* 目标窗口URL (optional) */
        type: null,
        /* 消息类型 (required) */
        data: null,
        /* 消息数据 (optional) */
        success: null,
        /* 成功回调 (optional) */
        error: null,
        /* 失败回调 (optional) */
        origin: "*"
        /* 消息域 (optional) */
    }

    var module = module || 'undefined';
    (typeof module != "undefined" && module.exports) ? (module.exports = PMS) : (typeof define != "undefined" ? (define("PMS", [], function() {
        return PMS;
    })) : (glob.PMS = PMS));
})(this);
/**
 * 配置文件
 * @param  {[type]} require [description]
 * @param  {[type]} exports [description]
 * @param  {[type]} module  [description]
 * @return {[type]}         [description]
 */


//配置对象
var config = {},
    layoutMode,
    screenSize,
    proportion,
    isIOS = Xut.plat.isIOS,
    isIphone = Xut.plat.isIphone,
    isAndroid = Xut.plat.isAndroid,
    isBrowser = Xut.plat.isBrowser,
    sourceUrl = "content/gallery/";

var FLOOR = Math.floor;
var CEIL = Math.ceil;

/**
 * 屏幕尺寸
 * @return {[type]} [description]
 */
function judgeScreen() {

    //如果是IBooks模式处理   
    if (Xut.IBooks.Enabled) {
        var screenSize = Xut.IBooks.CONFIG.screenSize;
        if (screenSize) {
            return {
                "width": screenSize.width,
                "height": screenSize.height
            }
        }
    }

    return {
        "width": $(window).width(),
        // 1024 768
        "height": $(window).height()
    }
}

//排版判断
function judgeLayer() {
    return screenSize.width > screenSize.height ? "horizontal" : "vertical";
}


//缩放比例
function judgeScale(pptWidth, pptHeight) {
    var dbmode, scaleWidth, scaleHeight,
        width = screenSize.width,
        height = screenSize.height,
        // 根据设备判断设备的横竖屏 1 横板 0 竖版
        horizontalMode = width > height ? 1 : 0,

        //默认ppt尺寸
        defaultWidth = pptWidth ? pptWidth : horizontalMode ? 1024 : 768,
        defaultHeight = pptHeight ? pptHeight : horizontalMode ? 720 : 976,

        //当前屏幕的尺寸与数据库设计的尺寸，比例
        wProp = width / defaultWidth,
        hProp = height / defaultHeight,

        //布局的偏移量，可能是采用了画轴模式，一个可视区可以容纳3个页面
        offsetTop = 0,
        offsetLeft = 0;

    if (pptWidth && pptHeight && isBrowser) {
        dbmode = pptWidth > pptHeight ? 1 : 0; // 根据数据库判断横杂志的竖屏 1 横板 0 竖版
        if (dbmode != horizontalMode) {
            if (dbmode === 1) {
                hProp = wProp;
            } else {
                wProp = hProp;
            }
        }
    }

    //画轴模式
    if (config.scrollPaintingMode) {
        //    Dw       width - 2 * left 
        //   ----  =  -------------------
        //    Dh       height - 2 * top

        if (horizontalMode) {
            scaleWidth = defaultWidth * hProp;
            offsetLeft = (width - scaleWidth) / 2;
            wProp = hProp;
        } else {
            scaleHeight = defaultHeight * hProp;
            offsetTop = (height - scaleHeight) / 2;
            hProp = wProp;
        }
    }

    //word模式下的竖版
    if (config.virtualMode && !horizontalMode) {
        //假设高度不会溢出,按两倍屏宽计算
        var _prop = 2 * width / defaultWidth;
        offsetLeft = 0;
        scaleHeight = defaultHeight * _prop;
        offsetTop = (height - scaleHeight) / 2;

        //如果高度溢出,按屏高计算
        if (scaleHeight > height) {
            _prop = height / defaultHeight;
            scaleWidth = defaultWidth * _prop;

            offsetTop = 0;
            offsetLeft = (2 * width - scaleWidth) / 2;
        }

        wProp = hProp = _prop;
    }

    var opts = {
        width: wProp,
        height: hProp,
        left: wProp,
        top: hProp,
        offsetTop: offsetTop,
        offsetLeft: offsetLeft,
        pptWidth: pptWidth,
        pptHeight: pptHeight
    }

    return opts;
}

/**
 * 修正API接口
 * @return {[type]} [description]
 */
function fiexdAPI() {
    screenSize = config.screenSize = judgeScreen();
    layoutMode = config.layoutMode = judgeLayer();
    proportion = config.proportion = judgeScale();
}

/**
 * 修复缩放比
 * 如果PPT有编辑指定的宽度与高度
 */
function setProportion(pptWidth, pptHeight) {
    
    //计算新的缩放比
    proportion = config.proportion = judgeScale(pptWidth, pptHeight);

    //计算容器的宽高比
    proportion.calculateContainer = (function() {

        var pptWidth = proportion.pptWidth,
            pptHeight   = proportion.pptHeight,
            scaleWidth  = proportion.width,
            scaleHeight = proportion.height;

        return function(width, height, left, top) {

            width = arguments[0] ? arguments[0] : screenSize.width;
            height = arguments[1] ? arguments[1] : screenSize.height;
            left = arguments[2] ? arguments[2] : 0;
            top = arguments[3] ? arguments[3] : 0;

            if (pptWidth && pptHeight && isBrowser) {
                //维持竖版的缩放比
                var _width = scaleWidth * pptWidth;
                var _height = scaleHeight * pptHeight;

                //虚拟模式并且是竖版
                if (config.virtualMode && height > width) {
                    return {
                        width: FLOOR(_width),
                        height: FLOOR(_height),
                        left: FLOOR((width - _width / 2) / 2),
                        top: FLOOR((height - _height) / 2)
                    }
                }
                //横版模式
                return {
                    width: FLOOR(_width),
                    height: FLOOR(_height),
                    left: FLOOR((width - _width) / 2),
                    top: FLOOR((height - _height) / 2)
                };
            } else {
                return {
                    width: FLOOR(width),
                    height: FLOOR(height),
                    left: FLOOR(left),
                    top: FLOOR(top)
                }
            }
        }
    })();

    //计算元素的缩放比
    proportion.calculateElement = function(data) {
        var data = _.extend({}, data)
        data.width = CEIL(data.width * proportion.width);
        data.height = CEIL(data.height * proportion.height);
        data.top = FLOOR(data.top * proportion.top);
        data.left = FLOOR(data.left * proportion.left);
        return data;
    }
}


//层级关系
_.extend(Xut, {
    zIndexlevel: function() {
        return ++config.zIndexlevel;
    }
})

//通过新学堂加载
//用于处理iframe窗口去全屏
if (/xinxuetang/.test(window.location.href)) {
    config.iframeFullScreen = true;
}


/********************************************************************
 *
 *              通过iframe加载判断当前的加载方式
 *              1 本地iframe打开子文档
 *              2 读酷加载电子杂志
 *              3 读酷加载电子杂志打开子文档
 *
 * *******************************************************************/
var iframeMode = (function() {
    var mode;
    if (SUbCONFIGT && DUKUCONFIG) {
        //通过读酷客户端开打子文档方式
        mode = 'iframeDuKuSubDoc'
    } else {
        //子文档加载
        if (SUbCONFIGT) {
            mode = 'iframeSubDoc'
        }

        //读酷客户端加载
        if (DUKUCONFIG) {
            mode = 'iframeDuKu'
        }

        //客户端模式
        //通过零件加载
        if (CLIENTCONFIGT) {
            mode = 'iframeClient'
        }

        //秒秒学客户端加载
        if (MMXCONFIG) {
            mode = 'iframeMiaomiaoxue'
        }

    }
    return mode;
}());


//读酷模式下的路径
DUKUCONFIG && (DUKUCONFIG.path = DUKUCONFIG.path.replace('//', '/'));

//除右端的"/"
var rtrim = function(str) {
    if (typeof str != 'string') return str;
    var lastIndex = str.length - 1;
    if (str.charAt(lastIndex) === '/') {
        return str.substr(0, lastIndex)
    } else {
        return str;
    }
}

//iframe嵌套配置
//1 新阅读
//2 子文档
//3 秒秒学
var iframeConfig = {
    //资源图片
    resources: function() {
        if (isIOS) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    return sourceUrl;
                case 'iframeDuKuSubDoc':
                    return sourceUrl;
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
            }
        }

        if (isAndroid) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeDuKuSubDoc':
                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
            }
        }
    },

    //视频路径
    video: function() {
        if (isIOS) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    return sourceUrl
                case 'iframeDuKuSubDoc':
                    return sourceUrl;
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
            }
        }

        if (isAndroid) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    return 'android.resource://#packagename#/raw/';
                case 'iframeDuKuSubDoc':
                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
                case 'iframeMiaomiaoxue':
                    return rtrim(MMXCONFIG.path) + '/content/gallery/';
            }
        }
    },

    //音频路径
    audio: function() {
        if (isIOS) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    return sourceUrl;
                case 'iframeDuKuSubDoc':
                    return sourceUrl;
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
            }
        }
        if (isAndroid) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeDuKuSubDoc':
                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
                case 'iframeMiaomiaoxue':
                    return rtrim(MMXCONFIG.path) + '/content/gallery/';
            }
        }
    },

    //调用插件处理
    svg: function() {
        if (isIOS) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    //www/content/subdoc/00c83e668a6b6bad7eda8eedbd2110ad/content/gallery/
                    return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeDuKuSubDoc':
                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
            }
        }

        if (isAndroid) {
            switch (iframeMode) {
                case 'iframeDuKu':
                    return DUKUCONFIG.path;
                case 'iframeSubDoc':
                    return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeDuKuSubDoc':
                    return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
                case 'iframeClient':
                    return CLIENTCONFIGT.path;
            }
        }
    }

}


//杂志直接打开
var nativeConfig = {
    //资源图片
    resources: function() {
        if (isIOS) {
            return sourceUrl;
        }

        if (isAndroid) {
            if (parseInt(config.storageMode)) {
                //sd卡加载资源数据
                return "/sdcard/appcarrier/magazine/" + config.appId + "/" + sourceUrl;
            } else {
                //android_asset缓存加载资源
                return "/android_asset/www/" + sourceUrl;
            }
        }
    },

    //视频路径
    // ios平台在缓存
    // 安卓在编译raw中
    video: function() {
        if (isIOS) {
            return sourceUrl;
        }
        if (isAndroid) {
            return 'android.resource://#packagename#/raw/';
        }
    },

    //音频路径
    // ios平台在缓存
    // 安卓在缓存中
    audio: function() {
        if (isIOS) {
            return sourceUrl;
        }
        if (isAndroid) {
            return "/android_asset/www/" + sourceUrl;
        }
    },

    //读取svg路径前缀
    svg: function() {
        return 'www/' + sourceUrl;
    }
}



//缓存
var cacheResourcesPath, cacheVideoPath, cacheAudioPath, cacheSvgPath;


/**
 * pc端模式
 * 而且是客户端模式
 * @return {[type]} [description]
 */
function pcMode() {
    //如果是iframe加载
    //而且是客户端模式
    if (GLOBALIFRAME && CLIENTCONFIGT) {
        return CLIENTCONFIGT.path;
    }

    if (typeof initGalleryUrl != 'undefined') {
        return sourceUrl;
    } else {
        //资源存放位置
        // * storageMode 存放的位置
        // * 0 APK应用本身
        // 1 外置SD卡
        if (Number(config.storageMode)) {
            return "sdcard/" + config.appId + "/" + sourceUrl;
        } else {
            return sourceUrl;
        }
    }
};

/**
 * 平台加载用于
 * 视频.音频妙妙学处理
 * 1 桌面
 * 2 移动端
 * 3 安卓打包后通过网页访问=>妙妙学
 * @return {[type]} [description]
 */
function runLoad() {
    if (MMXCONFIG) {
        return false
    }
    return isBrowser;
}

/**
 * 图片资源配置路径
 * [resourcesPath description]
 * @return {[type]} [description]
 */
function resourcesPath() {
    if (cacheResourcesPath) {
        return cacheResourcesPath;
    }
    //移动端模式
    var mobileMode = function() {
        return GLOBALIFRAME ? iframeConfig.resources() : nativeConfig.resources();
    };
    return cacheResourcesPath = isBrowser ? pcMode() : mobileMode();
}


/**
 * mp3 mp4 音频文件路径
 * 1 音频加载就会自动拷贝到SD卡上
 * 2 或者asset上的资源
 * @return {[type]} [description]
 */
function videoPath() {
    if (cacheVideoPath) {
        return cacheVideoPath;
    }
    var mobilePath = function() {
        return GLOBALIFRAME ? iframeConfig.video() : nativeConfig.video();
    };
    return cacheVideoPath = runLoad() ? pcMode() : mobilePath();
}


/**
 * 音频路径
 * @return {[type]} [description]
 */
function audioPath() {
    if (cacheAudioPath) {
        return cacheAudioPath;
    }
    //移动端
    var mobileMode = function() {
        return GLOBALIFRAME ? iframeConfig.audio() : nativeConfig.audio();
    };
    return cacheAudioPath = runLoad() ? pcMode() : mobileMode();
};


/**
 * SVG文件路径
 * @return {[type]} [description]
 */
function svgPath() {
    if (cacheSvgPath) {
        return cacheSvgPath;
    }
    var mobileMode = function() {
        return GLOBALIFRAME ? iframeConfig.svg() : nativeConfig.svg();
    };
    return cacheSvgPath = isBrowser ? pcMode() : mobileMode();
}


//打印信息
Xut.log = function(info, name) {
    return
    //  if (!config.debugMode) return;
    switch (info) {
        case 'error':
            console.error && console.error(name);
            break;
        case 'debug':
            console.debug && console.debug(name);
            break;
        default:
            console.log(info)
            break;
    }
}


//=============================================
//
//             调试模式代码
//
//============================================
_.extend(config, {

    //调试模式
    //如果启动桌面调试模式,自动打开缓存加载,就是每次都打开都回到最后看到的一页
    debugMode: false,

    //直接通过数据库的历史记录定位到指定的页面
    // Xut.View.LoadScenario({
    //     'scenarioId' : scenarioInfo[0],
    //     'chapterId'  : scenarioInfo[1],
    //     'pageIndex'  : scenarioInfo[2]
    // })
    // {
    //     'scenarioId' : 7,
    //     'chapterId'  : 9
    // }
    // 
    // 
    deBugHistory: false
})



///////////
//全局模式配置 //
///////////
_.extend(config, {

    //支持电子在在线阅读,向服务端取数据
    //自定义配置地址即可
    onlineModeUrl: 'lib/data/database.php',

    //数据库名
    dbName: window.xxtmagzinedbname || 'magazine',

    //全局翻页模式
    //0 滑动翻页
    //1 直接换
    pageFlip: 0,

    //存储模式  
    //0 APK应用本身 
    //1 外置SD卡
    storageMode: 0,

    //虚拟模式
    //采用word排版，如果是横屏的布局放到竖版的手机上
    //就需要分割排版布局
    virtualMode: false,

    //画轴模式
    //在不同分辨率下，按照正比缩放拼接
    //在一个可视区中，可以看到3个li拼接后的效果
    scrollPaintingMode: false
})


/////////
//初始化代码//
/////////
_.extend(config, {

    //应用路径唯一标示
    appId: null,

    //配置图片路径地址
    //初始化资源路径
    initResourcesPath: function() {
        this.pathAddress = resourcesPath();
    },

    //视频文件路径
    videoPath: function() {
        return videoPath();
    },

    //音频文件路径
    audioPath: function() {
        return audioPath();
    },

    //配置SVG文件路径
    svgPath: function() {
        return svgPath();
    },

    //设备尺寸
    screenSize: screenSize,

    //排版模式
    layoutMode: layoutMode,

    //缩放比例
    proportion: proportion,

    isBrowser: isBrowser,

    //全局层级初始值
    zIndexlevel: 1000,

    //默认图标高度
    iconHeight: isIphone ? 32 : 44,

    //修正
    revised: fiexdAPI,

    //修正缩放比
    setProportion: setProportion,

    //数据库尺寸
    dbSize: 1

});

Xut.config = config;


 
//苗苗学
//嵌套iframe都不加载cordove
if (!Xut.plat.isBrowser && !MMXCONFIG) {
//IOS
if (Xut.plat.isIOS) {


    // Platform: ios
    // 91157c2e1bf3eb098c7e2ab31404e895ccb0df2a
    /*
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
     */
    ;
    (function() {
      var PLATFORM_VERSION_BUILD_LABEL = '3.7.0';
      // file: src/scripts/require.js

      /*jshint -W079 */
      /*jshint -W020 */

      var require,
        define;

      (function() {
        var modules = {},
          // Stack of moduleIds currently being built.
          requireStack = [],
          // Map of module ID -> index into requireStack of modules currently being built.
          inProgressModules = {},
          SEPARATOR = ".";



        function build(module) {
          var factory = module.factory,
            localRequire = function(id) {
              var resultantId = id;
              //Its a relative path, so lop off the last portion and add the id (minus "./")
              if (id.charAt(0) === ".") {
                resultantId = module.id.slice(0, module.id.lastIndexOf(SEPARATOR)) + SEPARATOR + id.slice(2);
              }
              return require(resultantId);
            };
          module.exports = {};
          delete module.factory;
          factory(localRequire, module.exports, module);
          return module.exports;
        }

        require = function(id) {
          if (!modules[id]) {
            throw "module " + id + " not found";
          } else if (id in inProgressModules) {
            var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;
            throw "Cycle in require graph: " + cycle;
          }
          if (modules[id].factory) {
            try {
              inProgressModules[id] = requireStack.length;
              requireStack.push(id);
              return build(modules[id]);
            } finally {
              delete inProgressModules[id];
              requireStack.pop();
            }
          }
          return modules[id].exports;
        };

        define = function(id, factory) {
          if (modules[id]) {
            throw "module " + id + " already defined";
          }

          modules[id] = {
            id: id,
            factory: factory
          };
        };

        define.remove = function(id) {
          delete modules[id];
        };

        define.moduleMap = modules;
      })();

      //Export for use in node
      if (typeof module === "object" && typeof require === "function") {
        module.exports.require = require;
        module.exports.define = define;
      }

      // file: src/cordova.js
      define("cordova", function(require, exports, module) {


        var channel = require('cordova/channel');
        var platform = require('cordova/platform');

        /**
         * Intercept calls to addEventListener + removeEventListener and handle deviceready,
         * resume, and pause events.
         */
        var m_document_addEventListener = document.addEventListener;
        var m_document_removeEventListener = document.removeEventListener;
        var m_window_addEventListener = window.addEventListener;
        var m_window_removeEventListener = window.removeEventListener;

        /**
         * Houses custom event handlers to intercept on document + window event listeners.
         */
        var documentEventHandlers = {},
          windowEventHandlers = {};

        document.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if (typeof documentEventHandlers[e] != 'undefined') {
            documentEventHandlers[e].subscribe(handler);
          } else {
            m_document_addEventListener.call(document, evt, handler, capture);
          }
        };

        window.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if (typeof windowEventHandlers[e] != 'undefined') {
            windowEventHandlers[e].subscribe(handler);
          } else {
            m_window_addEventListener.call(window, evt, handler, capture);
          }
        };

        document.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if (typeof documentEventHandlers[e] != "undefined") {
            documentEventHandlers[e].unsubscribe(handler);
          } else {
            m_document_removeEventListener.call(document, evt, handler, capture);
          }
        };

        window.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if (typeof windowEventHandlers[e] != "undefined") {
            windowEventHandlers[e].unsubscribe(handler);
          } else {
            m_window_removeEventListener.call(window, evt, handler, capture);
          }
        };

        function createEvent(type, data) {
          var event = document.createEvent('Events');
          event.initEvent(type, false, false);
          if (data) {
            for (var i in data) {
              if (data.hasOwnProperty(i)) {
                event[i] = data[i];
              }
            }
          }
          return event;
        }


        var cordova = {
          define: define,
          require: require,
          version: PLATFORM_VERSION_BUILD_LABEL,
          platformVersion: PLATFORM_VERSION_BUILD_LABEL,
          platformId: platform.id,
          /**
           * Methods to add/remove your own addEventListener hijacking on document + window.
           */
          addWindowEventHandler: function(event) {
            return (windowEventHandlers[event] = channel.create(event));
          },
          addStickyDocumentEventHandler: function(event) {
            return (documentEventHandlers[event] = channel.createSticky(event));
          },
          addDocumentEventHandler: function(event) {
            return (documentEventHandlers[event] = channel.create(event));
          },
          removeWindowEventHandler: function(event) {
            delete windowEventHandlers[event];
          },
          removeDocumentEventHandler: function(event) {
            delete documentEventHandlers[event];
          },
          /**
           * Retrieve original event handlers that were replaced by Cordova
           *
           * @return object
           */
          getOriginalHandlers: function() {
            return {
              'document': {
                'addEventListener': m_document_addEventListener,
                'removeEventListener': m_document_removeEventListener
              },
              'window': {
                'addEventListener': m_window_addEventListener,
                'removeEventListener': m_window_removeEventListener
              }
            };
          },
          /**
           * Method to fire event from native code
           * bNoDetach is required for events which cause an exception which needs to be caught in native code
           */
          fireDocumentEvent: function(type, data, bNoDetach) {
            var evt = createEvent(type, data);
            if (typeof documentEventHandlers[type] != 'undefined') {
              if (bNoDetach) {
                documentEventHandlers[type].fire(evt);
              } else {
                setTimeout(function() {
                  // Fire deviceready on listeners that were registered before cordova.js was loaded.
                  if (type == 'deviceready') {
                    document.dispatchEvent(evt);
                  }
                  documentEventHandlers[type].fire(evt);
                }, 0);
              }
            } else {
              document.dispatchEvent(evt);
            }
          },
          fireWindowEvent: function(type, data) {
            var evt = createEvent(type, data);
            if (typeof windowEventHandlers[type] != 'undefined') {
              setTimeout(function() {
                windowEventHandlers[type].fire(evt);
              }, 0);
            } else {
              window.dispatchEvent(evt);
            }
          },

          /**
           * Plugin callback mechanism.
           */
          // Randomize the starting callbackId to avoid collisions after refreshing or navigating.
          // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.
          callbackId: Math.floor(Math.random() * 2000000000),
          callbacks: {},
          callbackStatus: {
            NO_RESULT: 0,
            OK: 1,
            CLASS_NOT_FOUND_EXCEPTION: 2,
            ILLEGAL_ACCESS_EXCEPTION: 3,
            INSTANTIATION_EXCEPTION: 4,
            MALFORMED_URL_EXCEPTION: 5,
            IO_EXCEPTION: 6,
            INVALID_ACTION: 7,
            JSON_EXCEPTION: 8,
            ERROR: 9
          },

          /**
           * Called by native code when returning successful result from an action.
           */
          callbackSuccess: function(callbackId, args) {
            cordova.callbackFromNative(callbackId, true, args.status, [args.message], args.keepCallback);
          },

          /**
           * Called by native code when returning error result from an action.
           */
          callbackError: function(callbackId, args) {
            // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.
            // Derive success from status.
            cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);
          },

          /**
           * Called by native code when returning the result from an action.
           */
          callbackFromNative: function(callbackId, isSuccess, status, args, keepCallback) {
            try {
              var callback = cordova.callbacks[callbackId];
              if (callback) {
                if (isSuccess && status == cordova.callbackStatus.OK) {
                  callback.success && callback.success.apply(null, args);
                } else {
                  callback.fail && callback.fail.apply(null, args);
                }

                // Clear callback if not expecting any more results
                if (!keepCallback) {
                  delete cordova.callbacks[callbackId];
                }
              }
            } catch (err) {
              var msg = "Error in " + (isSuccess ? "Success" : "Error") + " callbackId: " + callbackId + " : " + err;
              console && console.log && console.log(msg);
              cordova.fireWindowEvent("cordovacallbackerror", {
                'message': msg
              });
              throw err;
            }
          },
          addConstructor: function(func) {
            channel.onCordovaReady.subscribe(function() {
              try {
                func();
              } catch (e) {
                console.log("Failed to run constructor: " + e);
              }
            });
          }
        };


        module.exports = cordova;

      });

      // file: src/common/argscheck.js
      define("cordova/argscheck", function(require, exports, module) {

        var exec = require('cordova/exec');
        var utils = require('cordova/utils');

        var moduleExports = module.exports;

        var typeMap = {
          'A': 'Array',
          'D': 'Date',
          'N': 'Number',
          'S': 'String',
          'F': 'Function',
          'O': 'Object'
        };

        function extractParamName(callee, argIndex) {
          return (/.*?\((.*?)\)/).exec(callee)[1].split(', ')[argIndex];
        }

        function checkArgs(spec, functionName, args, opt_callee) {
          if (!moduleExports.enableChecks) {
            return;
          }
          var errMsg = null;
          var typeName;
          for (var i = 0; i < spec.length; ++i) {
            var c = spec.charAt(i),
              cUpper = c.toUpperCase(),
              arg = args[i];
            // Asterix means allow anything.
            if (c == '*') {
              continue;
            }
            typeName = utils.typeName(arg);
            if ((arg === null || arg === undefined) && c == cUpper) {
              continue;
            }
            if (typeName != typeMap[cUpper]) {
              errMsg = 'Expected ' + typeMap[cUpper];
              break;
            }
          }
          if (errMsg) {
            errMsg += ', but got ' + typeName + '.';
            errMsg = 'Wrong type for parameter "' + extractParamName(opt_callee || args.callee, i) + '" of ' + functionName + ': ' + errMsg;
            // Don't log when running unit tests.
            if (typeof jasmine == 'undefined') {
              console.error(errMsg);
            }
            throw TypeError(errMsg);
          }
        }

        function getValue(value, defaultValue) {
          return value === undefined ? defaultValue : value;
        }

        moduleExports.checkArgs = checkArgs;
        moduleExports.getValue = getValue;
        moduleExports.enableChecks = true;


      });

      // file: src/common/base64.js
      define("cordova/base64", function(require, exports, module) {

        var base64 = exports;

        base64.fromArrayBuffer = function(arrayBuffer) {
          var array = new Uint8Array(arrayBuffer);
          return uint8ToBase64(array);
        };

        base64.toArrayBuffer = function(str) {
          var decodedStr = typeof atob != 'undefined' ? atob(str) : new Buffer(str, 'base64').toString('binary');
          var arrayBuffer = new ArrayBuffer(decodedStr.length);
          var array = new Uint8Array(arrayBuffer);
          for (var i = 0, len = decodedStr.length; i < len; i++) {
            array[i] = decodedStr.charCodeAt(i);
          }
          return arrayBuffer;
        };

        //------------------------------------------------------------------------------

        /* This code is based on the performance tests at http://jsperf.com/b64tests
         * This 12-bit-at-a-time algorithm was the best performing version on all
         * platforms tested.
         */

        var b64_6bit = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var b64_12bit;

        var b64_12bitTable = function() {
          b64_12bit = [];
          for (var i = 0; i < 64; i++) {
            for (var j = 0; j < 64; j++) {
              b64_12bit[i * 64 + j] = b64_6bit[i] + b64_6bit[j];
            }
          }
          b64_12bitTable = function() {
            return b64_12bit;
          };
          return b64_12bit;
        };

        function uint8ToBase64(rawData) {
          var numBytes = rawData.byteLength;
          var output = "";
          var segment;
          var table = b64_12bitTable();
          for (var i = 0; i < numBytes - 2; i += 3) {
            segment = (rawData[i] << 16) + (rawData[i + 1] << 8) + rawData[i + 2];
            output += table[segment >> 12];
            output += table[segment & 0xfff];
          }
          if (numBytes - i == 2) {
            segment = (rawData[i] << 16) + (rawData[i + 1] << 8);
            output += table[segment >> 12];
            output += b64_6bit[(segment & 0xfff) >> 6];
            output += '=';
          } else if (numBytes - i == 1) {
            segment = (rawData[i] << 16);
            output += table[segment >> 12];
            output += '==';
          }
          return output;
        }

      });

      // file: src/common/builder.js
      define("cordova/builder", function(require, exports, module) {

        var utils = require('cordova/utils');

        function each(objects, func, context) {
          for (var prop in objects) {
            if (objects.hasOwnProperty(prop)) {
              func.apply(context, [objects[prop], prop]);
            }
          }
        }

        function clobber(obj, key, value) {
          exports.replaceHookForTesting(obj, key);
          obj[key] = value;
          // Getters can only be overridden by getters.
          if (obj[key] !== value) {
            utils.defineGetter(obj, key, function() {
              return value;
            });
          }
        }

        function assignOrWrapInDeprecateGetter(obj, key, value, message) {
          if (message) {
            utils.defineGetter(obj, key, function() {
              console.log(message);
              delete obj[key];
              clobber(obj, key, value);
              return value;
            });
          } else {
            clobber(obj, key, value);
          }
        }

        function include(parent, objects, clobber, merge) {
          each(objects, function(obj, key) {
            try {
              var result = obj.path ? require(obj.path) : {};

              if (clobber) {
                // Clobber if it doesn't exist.
                if (typeof parent[key] === 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else if (typeof obj.path !== 'undefined') {
                  // If merging, merge properties onto parent, otherwise, clobber.
                  if (merge) {
                    recursiveMerge(parent[key], result);
                  } else {
                    assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                  }
                }
                result = parent[key];
              } else {
                // Overwrite if not currently defined.
                if (typeof parent[key] == 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else {
                  // Set result to what already exists, so we can build children into it if they exist.
                  result = parent[key];
                }
              }

              if (obj.children) {
                include(result, obj.children, clobber, merge);
              }
            } catch (e) {
              utils.alert('Exception building Cordova JS globals: ' + e + ' for key "' + key + '"');
            }
          });
        }

        /**
         * Merge properties from one object onto another recursively.  Properties from
         * the src object will overwrite existing target property.
         *
         * @param target Object to merge properties into.
         * @param src Object to merge properties from.
         */
        function recursiveMerge(target, src) {
          for (var prop in src) {
            if (src.hasOwnProperty(prop)) {
              if (target.prototype && target.prototype.constructor === target) {
                // If the target object is a constructor override off prototype.
                clobber(target.prototype, prop, src[prop]);
              } else {
                if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {
                  recursiveMerge(target[prop], src[prop]);
                } else {
                  clobber(target, prop, src[prop]);
                }
              }
            }
          }
        }

        exports.buildIntoButDoNotClobber = function(objects, target) {
          include(target, objects, false, false);
        };
        exports.buildIntoAndClobber = function(objects, target) {
          include(target, objects, true, false);
        };
        exports.buildIntoAndMerge = function(objects, target) {
          include(target, objects, true, true);
        };
        exports.recursiveMerge = recursiveMerge;
        exports.assignOrWrapInDeprecateGetter = assignOrWrapInDeprecateGetter;
        exports.replaceHookForTesting = function() {};

      });

      // file: src/common/channel.js
      define("cordova/channel", function(require, exports, module) {

        var utils = require('cordova/utils'),
          nextGuid = 1;

        /**
         * Custom pub-sub "channel" that can have functions subscribed to it
         * This object is used to define and control firing of events for
         * cordova initialization, as well as for custom events thereafter.
         *
         * The order of events during page load and Cordova startup is as follows:
         *
         * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.
         * onNativeReady*              Internal event that indicates the Cordova native side is ready.
         * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.
         * onDeviceReady*              User event fired to indicate that Cordova is ready
         * onResume                    User event fired to indicate a start/resume lifecycle event
         * onPause                     User event fired to indicate a pause lifecycle event
         * onDestroy*                  Internal event fired when app is being destroyed (User should use window.onunload event, not this one).
         *
         * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.
         * All listeners that subscribe after the event is fired will be executed right away.
         *
         * The only Cordova events that user code should register for are:
         *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript
         *      pause                 App has moved to background
         *      resume                App has returned to foreground
         *
         * Listeners can be registered as:
         *      document.addEventListener("deviceready", myDeviceReadyListener, false);
         *      document.addEventListener("resume", myResumeListener, false);
         *      document.addEventListener("pause", myPauseListener, false);
         *
         * The DOM lifecycle events should be used for saving and restoring state
         *      window.onload
         *      window.onunload
         *
         */

        /**
         * Channel
         * @constructor
         * @param type  String the channel name
         */
        var Channel = function(type, sticky) {
            this.type = type;
            // Map of guid -> function.
            this.handlers = {};
            // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
            this.state = sticky ? 1 : 0;
            // Used in sticky mode to remember args passed to fire().
            this.fireArgs = null;
            // Used by onHasSubscribersChange to know if there are any listeners.
            this.numHandlers = 0;
            // Function that is called when the first listener is subscribed, or when
            // the last listener is unsubscribed.
            this.onHasSubscribersChange = null;
          },
          channel = {
            /**
             * Calls the provided function only after all of the channels specified
             * have been fired. All channels must be sticky channels.
             */
            join: function(h, c) {
              var len = c.length,
                i = len,
                f = function() {
                  if (!(--i)) h();
                };
              for (var j = 0; j < len; j++) {
                if (c[j].state === 0) {
                  throw Error('Can only use join with sticky channels.');
                }
                c[j].subscribe(f);
              }
              if (!len) h();
            },
            create: function(type) {
              return channel[type] = new Channel(type, false);
            },
            createSticky: function(type) {
              return channel[type] = new Channel(type, true);
            },

            /**
             * cordova Channels that must fire before "deviceready" is fired.
             */
            deviceReadyChannelsArray: [],
            deviceReadyChannelsMap: {},

            /**
             * Indicate that a feature needs to be initialized before it is ready to be used.
             * This holds up Cordova's "deviceready" event until the feature has been initialized
             * and Cordova.initComplete(feature) is called.
             *
             * @param feature {String}     The unique feature name
             */
            waitForInitialization: function(feature) {
              if (feature) {
                var c = channel[feature] || this.createSticky(feature);
                this.deviceReadyChannelsMap[feature] = c;
                this.deviceReadyChannelsArray.push(c);
              }
            },

            /**
             * Indicate that initialization code has completed and the feature is ready to be used.
             *
             * @param feature {String}     The unique feature name
             */
            initializationComplete: function(feature) {
              var c = this.deviceReadyChannelsMap[feature];
              if (c) {
                c.fire();
              }
            }
          };

        function forceFunction(f) {
          if (typeof f != 'function') throw "Function required as first argument!";
        }

        /**
         * Subscribes the given function to the channel. Any time that
         * Channel.fire is called so too will the function.
         * Optionally specify an execution context for the function
         * and a guid that can be used to stop subscribing to the channel.
         * Returns the guid.
         */
        Channel.prototype.subscribe = function(f, c) {
          // need a function to call
          forceFunction(f);
          if (this.state == 2) {
            f.apply(c || this, this.fireArgs);
            return;
          }

          var func = f,
            guid = f.observer_guid;
          if (typeof c == "object") {
            func = utils.close(c, f);
          }

          if (!guid) {
            // first time any channel has seen this subscriber
            guid = '' + nextGuid++;
          }
          func.observer_guid = guid;
          f.observer_guid = guid;

          // Don't add the same handler more than once.
          if (!this.handlers[guid]) {
            this.handlers[guid] = func;
            this.numHandlers++;
            if (this.numHandlers == 1) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Unsubscribes the function with the given guid from the channel.
         */
        Channel.prototype.unsubscribe = function(f) {
          // need a function to unsubscribe
          forceFunction(f);

          var guid = f.observer_guid,
            handler = this.handlers[guid];
          if (handler) {
            delete this.handlers[guid];
            this.numHandlers--;
            if (this.numHandlers === 0) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Calls all functions subscribed to this channel.
         */
        Channel.prototype.fire = function(e) {
          var fail = false,
            fireArgs = Array.prototype.slice.call(arguments);
          // Apply stickiness.
          if (this.state == 1) {
            this.state = 2;
            this.fireArgs = fireArgs;
          }
          if (this.numHandlers) {
            // Copy the values first so that it is safe to modify it from within
            // callbacks.
            var toCall = [];
            for (var item in this.handlers) {
              toCall.push(this.handlers[item]);
            }
            for (var i = 0; i < toCall.length; ++i) {
              toCall[i].apply(this, fireArgs);
            }
            if (this.state == 2 && this.numHandlers) {
              this.numHandlers = 0;
              this.handlers = {};
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };


        // defining them here so they are ready super fast!
        // DOM event that is received when the web page is loaded and parsed.
        channel.createSticky('onDOMContentLoaded');

        // Event to indicate the Cordova native side is ready.
        channel.createSticky('onNativeReady');

        // Event to indicate that all Cordova JavaScript objects have been created
        // and it's time to run plugin constructors.
        channel.createSticky('onCordovaReady');

        // Event to indicate that all automatically loaded JS plugins are loaded and ready.
        // FIXME remove this
        channel.createSticky('onPluginsReady');

        // Event to indicate that Cordova is ready
        channel.createSticky('onDeviceReady');

        // Event to indicate a resume lifecycle event
        channel.create('onResume');

        // Event to indicate a pause lifecycle event
        channel.create('onPause');

        // Event to indicate a destroy lifecycle event
        channel.createSticky('onDestroy');

        // Channels that must fire before "deviceready" is fired.
        channel.waitForInitialization('onCordovaReady');
        channel.waitForInitialization('onDOMContentLoaded');

        module.exports = channel;

      });

      // file: src/ios/exec.js
      define("cordova/exec", function(require, exports, module) {

        /**
         * Creates a gap bridge iframe used to notify the native code about queued
         * commands.
         */
        var cordova = require('cordova'),
          channel = require('cordova/channel'),
          utils = require('cordova/utils'),
          base64 = require('cordova/base64'),
          // XHR mode does not work on iOS 4.2.
          // XHR mode's main advantage is working around a bug in -webkit-scroll, which
          // doesn't exist only on iOS 5.x devices.
          // IFRAME_NAV is the fastest.
          // IFRAME_HASH could be made to enable synchronous bridge calls if we wanted this feature.
          jsToNativeModes = {
            IFRAME_NAV: 0,
            XHR_NO_PAYLOAD: 1,
            XHR_WITH_PAYLOAD: 2,
            XHR_OPTIONAL_PAYLOAD: 3,
            IFRAME_HASH_NO_PAYLOAD: 4,
            // Bundling the payload turns out to be slower. Probably since it has to be URI encoded / decoded.
            IFRAME_HASH_WITH_PAYLOAD: 5,
            WK_WEBVIEW_BINDING: 6
          },
          bridgeMode,
          execIframe,
          execHashIframe,
          hashToggle = 1,
          execXhr,
          requestCount = 0,
          vcHeaderValue = null,
          commandQueue = [], // Contains pending JS->Native messages.
          isInContextOfEvalJs = 0;

        function createExecIframe(src, unloadListener) {
          var iframe = document.createElement("iframe");
          iframe.style.display = 'none';
          // Both the unload listener and the src must be set before adding the iframe
          // to the document in order to avoid race conditions. Callbacks from native
          // can happen within the appendChild() call!
          iframe.onunload = unloadListener;
          iframe.src = src;
          document.body.appendChild(iframe);
          return iframe;
        }

        function createHashIframe() {
          var ret = createExecIframe('about:blank');
          // Hash changes don't work on about:blank, so switch it to file:///.
          ret.contentWindow.history.replaceState(null, null, 'file:///#');
          return ret;
        }

        function shouldBundleCommandJson() {
          if (bridgeMode === jsToNativeModes.XHR_WITH_PAYLOAD) {
            return true;
          }
          if (bridgeMode === jsToNativeModes.XHR_OPTIONAL_PAYLOAD) {
            var payloadLength = 0;
            for (var i = 0; i < commandQueue.length; ++i) {
              payloadLength += commandQueue[i].length;
            }
            // The value here was determined using the benchmark within CordovaLibApp on an iPad 3.
            return payloadLength < 4500;
          }
          return false;
        }

        function massageArgsJsToNative(args) {
          if (!args || utils.typeName(args) != 'Array') {
            return args;
          }
          var ret = [];
          args.forEach(function(arg, i) {
            if (utils.typeName(arg) == 'ArrayBuffer') {
              ret.push({
                'CDVType': 'ArrayBuffer',
                'data': base64.fromArrayBuffer(arg)
              });
            } else {
              ret.push(arg);
            }
          });
          return ret;
        }

        function massageMessageNativeToJs(message) {
          if (message.CDVType == 'ArrayBuffer') {
            var stringToArrayBuffer = function(str) {
              var ret = new Uint8Array(str.length);
              for (var i = 0; i < str.length; i++) {
                ret[i] = str.charCodeAt(i);
              }
              return ret.buffer;
            };
            var base64ToArrayBuffer = function(b64) {
              return stringToArrayBuffer(atob(b64));
            };
            message = base64ToArrayBuffer(message.data);
          }
          return message;
        }

        function convertMessageToArgsNativeToJs(message) {
          var args = [];
          if (!message || !message.hasOwnProperty('CDVType')) {
            args.push(message);
          } else if (message.CDVType == 'MultiPart') {
            message.messages.forEach(function(e) {
              args.push(massageMessageNativeToJs(e));
            });
          } else {
            args.push(massageMessageNativeToJs(message));
          }
          return args;
        }

        function iOSExec() {
          if (bridgeMode === undefined) {
            bridgeMode = jsToNativeModes.IFRAME_NAV;
          }

          if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.cordova && window.webkit.messageHandlers.cordova.postMessage) {
            bridgeMode = jsToNativeModes.WK_WEBVIEW_BINDING;
          }

          var successCallback, failCallback, service, action, actionArgs, splitCommand;
          var callbackId = null;
          if (typeof arguments[0] !== "string") {
            // FORMAT ONE
            successCallback = arguments[0];
            failCallback = arguments[1];
            service = arguments[2];
            action = arguments[3];
            actionArgs = arguments[4];

            // Since we need to maintain backwards compatibility, we have to pass
            // an invalid callbackId even if no callback was provided since plugins
            // will be expecting it. The Cordova.exec() implementation allocates
            // an invalid callbackId and passes it even if no callbacks were given.
            callbackId = 'INVALID';
          } else {
            // FORMAT TWO, REMOVED
            try {
              splitCommand = arguments[0].split(".");
              action = splitCommand.pop();
              service = splitCommand.join(".");
              actionArgs = Array.prototype.splice.call(arguments, 1);

              console.log('The old format of this exec call has been removed (deprecated since 2.1). Change to: ' +
                "cordova.exec(null, null, \"" + service + "\", \"" + action + "\"," + JSON.stringify(actionArgs) + ");"
              );
              return;
            } catch (e) {}
          }

          // If actionArgs is not provided, default to an empty array
          actionArgs = actionArgs || [];

          // Register the callbacks and add the callbackId to the positional
          // arguments if given.
          if (successCallback || failCallback) {
            callbackId = service + cordova.callbackId++;
            cordova.callbacks[callbackId] = {
              success: successCallback,
              fail: failCallback
            };
          }

          actionArgs = massageArgsJsToNative(actionArgs);

          var command = [callbackId, service, action, actionArgs];

          // Stringify and queue the command. We stringify to command now to
          // effectively clone the command arguments in case they are mutated before
          // the command is executed.
          commandQueue.push(JSON.stringify(command));

          if (bridgeMode === jsToNativeModes.WK_WEBVIEW_BINDING) {
            window.webkit.messageHandlers.cordova.postMessage(command);
          } else {
            // If we're in the context of a stringByEvaluatingJavaScriptFromString call,
            // then the queue will be flushed when it returns; no need for a poke.
            // Also, if there is already a command in the queue, then we've already
            // poked the native side, so there is no reason to do so again.
            if (!isInContextOfEvalJs && commandQueue.length == 1) {
              switch (bridgeMode) {
                case jsToNativeModes.XHR_NO_PAYLOAD:
                case jsToNativeModes.XHR_WITH_PAYLOAD:
                case jsToNativeModes.XHR_OPTIONAL_PAYLOAD:
                  pokeNativeViaXhr();
                  break;
                default: // iframe-based.
                  pokeNativeViaIframe();
              }
            }
          }
        }

        function pokeNativeViaXhr() {
          // This prevents sending an XHR when there is already one being sent.
          // This should happen only in rare circumstances (refer to unit tests).
          if (execXhr && execXhr.readyState != 4) {
            execXhr = null;
          }
          // Re-using the XHR improves exec() performance by about 10%.
          execXhr = execXhr || new XMLHttpRequest();
          // Changing this to a GET will make the XHR reach the URIProtocol on 4.2.
          // For some reason it still doesn't work though...
          // Add a timestamp to the query param to prevent caching.
          execXhr.open('HEAD', "/!gap_exec?" + (+new Date()), true);
          if (!vcHeaderValue) {
            vcHeaderValue = /.*\((.*)\)$/.exec(navigator.userAgent)[1];
          }
          execXhr.setRequestHeader('vc', vcHeaderValue);
          execXhr.setRequestHeader('rc', ++requestCount);
          if (shouldBundleCommandJson()) {
            execXhr.setRequestHeader('cmds', iOSExec.nativeFetchMessages());
          }
          execXhr.send(null);
        }

        function onIframeUnload() {
          execIframe = null;
          setTimeout(pokeNativeViaIframe, 0);
        }

        function pokeNativeViaIframe() {
          // CB-5488 - Don't attempt to create iframe before document.body is available.
          if (!document.body) {
            setTimeout(pokeNativeViaIframe);
            return;
          }
          if (bridgeMode === jsToNativeModes.IFRAME_HASH_NO_PAYLOAD || bridgeMode === jsToNativeModes.IFRAME_HASH_WITH_PAYLOAD) {
            // TODO: This bridge mode doesn't properly support being removed from the DOM (CB-7735)
            execHashIframe = execHashIframe || createHashIframe();
            // Check if they've removed it from the DOM, and put it back if so.
            if (!execHashIframe.contentWindow) {
              execHashIframe = createHashIframe();
            }
            // The delegate method is called only when the hash changes, so toggle it back and forth.
            hashToggle = hashToggle ^ 3;
            var hashValue = '%0' + hashToggle;
            if (bridgeMode === jsToNativeModes.IFRAME_HASH_WITH_PAYLOAD) {
              hashValue += iOSExec.nativeFetchMessages();
            }
            execHashIframe.contentWindow.location.hash = hashValue;
          } else {
            // Check if they've removed it from the DOM, and put it back if so.
            if (execIframe && execIframe.contentWindow) {
              // Listen for unload, since it can happen (CB-7735) that the iframe gets
              // removed from the DOM before it gets a chance to poke the native side.
              execIframe.contentWindow.onunload = onIframeUnload;
              execIframe.src = 'gap://ready';
            } else {
              execIframe = createExecIframe('gap://ready', onIframeUnload);
            }
          }
        }

        iOSExec.jsToNativeModes = jsToNativeModes;

        iOSExec.setJsToNativeBridgeMode = function(mode) {
          // Remove the iFrame since it may be no longer required, and its existence
          // can trigger browser bugs.
          // https://issues.apache.org/jira/browse/CB-593
          if (execIframe) {
            execIframe.parentNode.removeChild(execIframe);
            execIframe = null;
          }
          bridgeMode = mode;
        };

        iOSExec.nativeFetchMessages = function() {
          // Stop listing for window detatch once native side confirms poke.
          if (execIframe && execIframe.contentWindow) {
            execIframe.contentWindow.onunload = null;
          }
          // Each entry in commandQueue is a JSON string already.
          if (!commandQueue.length) {
            return '';
          }
          var json = '[' + commandQueue.join(',') + ']';
          commandQueue.length = 0;
          return json;
        };

        iOSExec.nativeCallback = function(callbackId, status, message, keepCallback) {
          return iOSExec.nativeEvalAndFetch(function() {
            var success = status === 0 || status === 1;
            var args = convertMessageToArgsNativeToJs(message);
            cordova.callbackFromNative(callbackId, success, status, args, keepCallback);
          });
        };

        iOSExec.nativeEvalAndFetch = function(func) {
          // This shouldn't be nested, but better to be safe.
          isInContextOfEvalJs++;
          try {
            func();
            return iOSExec.nativeFetchMessages();
          } finally {
            isInContextOfEvalJs--;
          }
        };

        module.exports = iOSExec;

      });

      // file: src/common/exec/proxy.js
      define("cordova/exec/proxy", function(require, exports, module) {


        // internal map of proxy function
        var CommandProxyMap = {};

        module.exports = {

          // example: cordova.commandProxy.add("Accelerometer",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);
          add: function(id, proxyObj) {
            console.log("adding proxy for " + id);
            CommandProxyMap[id] = proxyObj;
            return proxyObj;
          },

          // cordova.commandProxy.remove("Accelerometer");
          remove: function(id) {
            var proxy = CommandProxyMap[id];
            delete CommandProxyMap[id];
            CommandProxyMap[id] = null;
            return proxy;
          },

          get: function(service, action) {
            return (CommandProxyMap[service] ? CommandProxyMap[service][action] : null);
          }
        };
      });

      // file: src/common/init.js
      define("cordova/init", function(require, exports, module) {

        var channel = require('cordova/channel');
        var cordova = require('cordova');
        var modulemapper = require('cordova/modulemapper');
        var platform = require('cordova/platform');
        var pluginloader = require('cordova/pluginloader');
        var utils = require('cordova/utils');

        var platformInitChannelsArray = [channel.onNativeReady, channel.onPluginsReady];

        function logUnfiredChannels(arr) {
          for (var i = 0; i < arr.length; ++i) {
            if (arr[i].state != 2) {
              console.log('Channel not fired: ' + arr[i].type);
            }
          }
        }

        window.setTimeout(function() {
          if (channel.onDeviceReady.state != 2) {
            console.log('deviceready has not fired after 5 seconds.');
            logUnfiredChannels(platformInitChannelsArray);
            logUnfiredChannels(channel.deviceReadyChannelsArray);
          }
        }, 5000);

        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        function replaceNavigator(origNavigator) {
          var CordovaNavigator = function() {};
          CordovaNavigator.prototype = origNavigator;
          var newNavigator = new CordovaNavigator();
          // This work-around really only applies to new APIs that are newer than Function.bind.
          // Without it, APIs such as getGamepads() break.
          if (CordovaNavigator.bind) {
            for (var key in origNavigator) {
              if (typeof origNavigator[key] == 'function') {
                newNavigator[key] = origNavigator[key].bind(origNavigator);
              } else {
                (function(k) {
                  utils.defineGetterSetter(newNavigator, key, function() {
                    return origNavigator[k];
                  });
                })(key);
              }
            }
          }
          return newNavigator;
        }

        if (window.navigator) {
          window.navigator = replaceNavigator(window.navigator);
        }

        if (!window.console) {
          window.console = {
            log: function() {}
          };
        }
        if (!window.console.warn) {
          window.console.warn = function(msg) {
            this.log("warn: " + msg);
          };
        }

        // Register pause, resume and deviceready channels as events on document.
        channel.onPause = cordova.addDocumentEventHandler('pause');
        channel.onResume = cordova.addDocumentEventHandler('resume');
        channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

        // Listen for DOMContentLoaded and notify our channel subscribers.
        if (document.readyState == 'complete' || document.readyState == 'interactive') {
          channel.onDOMContentLoaded.fire();
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            channel.onDOMContentLoaded.fire();
          }, false);
        }

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if (window._nativeReady) {
          channel.onNativeReady.fire();
        }

        modulemapper.clobbers('cordova', 'cordova');
        modulemapper.clobbers('cordova/exec', 'cordova.exec');
        modulemapper.clobbers('cordova/exec', 'Cordova.exec');

        // Call the platform-specific initialization.
        platform.bootstrap && platform.bootstrap();

        // Wrap in a setTimeout to support the use-case of having plugin JS appended to cordova.js.
        // The delay allows the attached modules to be defined before the plugin loader looks for them.
        setTimeout(function() {
          pluginloader.load(function() {
            channel.onPluginsReady.fire();
          });
        }, 0);

        /**
         * Create all cordova objects once native side is ready.
         */
        channel.join(function() {
          modulemapper.mapModules(window);

          platform.initialize && platform.initialize();

          // Fire event to notify that all objects are created
          channel.onCordovaReady.fire();

          // Fire onDeviceReady event once page has fully loaded, all
          // constructors have run and cordova info has been received from native
          // side.
          channel.join(function() {
            require('cordova').fireDocumentEvent('deviceready');
          }, channel.deviceReadyChannelsArray);

        }, platformInitChannelsArray);


      });

      // file: src/common/init_b.js
      define("cordova/init_b", function(require, exports, module) {

        var channel = require('cordova/channel');
        var cordova = require('cordova');
        var platform = require('cordova/platform');
        var utils = require('cordova/utils');

        var platformInitChannelsArray = [channel.onDOMContentLoaded, channel.onNativeReady];

        // setting exec
        cordova.exec = require('cordova/exec');

        function logUnfiredChannels(arr) {
          for (var i = 0; i < arr.length; ++i) {
            if (arr[i].state != 2) {
              console.log('Channel not fired: ' + arr[i].type);
            }
          }
        }

        window.setTimeout(function() {
          if (channel.onDeviceReady.state != 2) {
            console.log('deviceready has not fired after 5 seconds.');
            logUnfiredChannels(platformInitChannelsArray);
            logUnfiredChannels(channel.deviceReadyChannelsArray);
          }
        }, 5000);

        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        function replaceNavigator(origNavigator) {
          var CordovaNavigator = function() {};
          CordovaNavigator.prototype = origNavigator;
          var newNavigator = new CordovaNavigator();
          // This work-around really only applies to new APIs that are newer than Function.bind.
          // Without it, APIs such as getGamepads() break.
          if (CordovaNavigator.bind) {
            for (var key in origNavigator) {
              if (typeof origNavigator[key] == 'function') {
                newNavigator[key] = origNavigator[key].bind(origNavigator);
              } else {
                (function(k) {
                  utils.defineGetterSetter(newNavigator, key, function() {
                    return origNavigator[k];
                  });
                })(key);
              }
            }
          }
          return newNavigator;
        }
        if (window.navigator) {
          window.navigator = replaceNavigator(window.navigator);
        }

        if (!window.console) {
          window.console = {
            log: function() {}
          };
        }
        if (!window.console.warn) {
          window.console.warn = function(msg) {
            this.log("warn: " + msg);
          };
        }

        // Register pause, resume and deviceready channels as events on document.
        channel.onPause = cordova.addDocumentEventHandler('pause');
        channel.onResume = cordova.addDocumentEventHandler('resume');
        channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

        // Listen for DOMContentLoaded and notify our channel subscribers.
        if (document.readyState == 'complete' || document.readyState == 'interactive') {
          channel.onDOMContentLoaded.fire();
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            channel.onDOMContentLoaded.fire();
          }, false);
        }

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if (window._nativeReady) {
          channel.onNativeReady.fire();
        }

        // Call the platform-specific initialization.
        platform.bootstrap && platform.bootstrap();

        /**
         * Create all cordova objects once native side is ready.
         */
        channel.join(function() {

          platform.initialize && platform.initialize();

          // Fire event to notify that all objects are created
          channel.onCordovaReady.fire();

          // Fire onDeviceReady event once page has fully loaded, all
          // constructors have run and cordova info has been received from native
          // side.
          channel.join(function() {
            require('cordova').fireDocumentEvent('deviceready');
          }, channel.deviceReadyChannelsArray);

        }, platformInitChannelsArray);

      });

      // file: src/common/modulemapper.js
      define("cordova/modulemapper", function(require, exports, module) {

        var builder = require('cordova/builder'),
          moduleMap = define.moduleMap,
          symbolList,
          deprecationMap;

        exports.reset = function() {
          symbolList = [];
          deprecationMap = {};
        };

        function addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {
          if (!(moduleName in moduleMap)) {
            throw new Error('Module ' + moduleName + ' does not exist.');
          }
          symbolList.push(strategy, moduleName, symbolPath);
          if (opt_deprecationMessage) {
            deprecationMap[symbolPath] = opt_deprecationMessage;
          }
        }

        // Note: Android 2.3 does have Function.bind().
        exports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('c', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('m', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('d', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.runs = function(moduleName) {
          addEntry('r', moduleName, null);
        };

        function prepareNamespace(symbolPath, context) {
          if (!symbolPath) {
            return context;
          }
          var parts = symbolPath.split('.');
          var cur = context;
          for (var i = 0, part; part = parts[i]; ++i) {
            cur = cur[part] = cur[part] || {};
          }
          return cur;
        }

        exports.mapModules = function(context) {
          var origSymbols = {};
          context.CDV_origSymbols = origSymbols;
          for (var i = 0, len = symbolList.length; i < len; i += 3) {
            var strategy = symbolList[i];
            var moduleName = symbolList[i + 1];
            var module = require(moduleName);
            // <runs/>
            if (strategy == 'r') {
              continue;
            }
            var symbolPath = symbolList[i + 2];
            var lastDot = symbolPath.lastIndexOf('.');
            var namespace = symbolPath.substr(0, lastDot);
            var lastName = symbolPath.substr(lastDot + 1);

            var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;
            var parentObj = prepareNamespace(namespace, context);
            var target = parentObj[lastName];

            if (strategy == 'm' && target) {
              builder.recursiveMerge(target, module);
            } else if ((strategy == 'd' && !target) || (strategy != 'd')) {
              if (!(symbolPath in origSymbols)) {
                origSymbols[symbolPath] = target;
              }
              builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);
            }
          }
        };

        exports.getOriginalSymbol = function(context, symbolPath) {
          var origSymbols = context.CDV_origSymbols;
          if (origSymbols && (symbolPath in origSymbols)) {
            return origSymbols[symbolPath];
          }
          var parts = symbolPath.split('.');
          var obj = context;
          for (var i = 0; i < parts.length; ++i) {
            obj = obj && obj[parts[i]];
          }
          return obj;
        };

        exports.reset();


      });

      // file: src/ios/platform.js
      define("cordova/platform", function(require, exports, module) {

        module.exports = {
          id: 'ios',
          bootstrap: function() {
            require('cordova/channel').onNativeReady.fire();
          }
        };


      });

      // file: src/common/pluginloader.js
      define("cordova/pluginloader", function(require, exports, module) {

        var modulemapper = require('cordova/modulemapper');
        var urlutil = require('cordova/urlutil');

        // Helper function to inject a <script> tag.
        // Exported for testing.
        exports.injectScript = function(url, onload, onerror) {
          var script = document.createElement("script");
          // onload fires even when script fails loads with an error.
          script.onload = onload;
          // onerror fires for malformed URLs.
          script.onerror = onerror;
          script.src = url;
          document.head.appendChild(script);
        };

        function injectIfNecessary(id, url, onload, onerror) {
          onerror = onerror || onload;
          if (id in define.moduleMap) {
            onload();
          } else {
            exports.injectScript(url, function() {
              if (id in define.moduleMap) {
                onload();
              } else {
                onerror();
              }
            }, onerror);
          }
        }

        function onScriptLoadingComplete(moduleList, finishPluginLoading) {
          // Loop through all the plugins and then through their clobbers and merges.
          for (var i = 0, module; module = moduleList[i]; i++) {
            if (module.clobbers && module.clobbers.length) {
              for (var j = 0; j < module.clobbers.length; j++) {
                modulemapper.clobbers(module.id, module.clobbers[j]);
              }
            }

            if (module.merges && module.merges.length) {
              for (var k = 0; k < module.merges.length; k++) {
                modulemapper.merges(module.id, module.merges[k]);
              }
            }

            // Finally, if runs is truthy we want to simply require() the module.
            if (module.runs) {
              modulemapper.runs(module.id);
            }
          }

          finishPluginLoading();
        }

        // Handler for the cordova_plugins.js content.
        // See plugman's plugin_loader.js for the details of this object.
        // This function is only called if the really is a plugins array that isn't empty.
        // Otherwise the onerror response handler will just call finishPluginLoading().
        function handlePluginsObject(path, moduleList, finishPluginLoading) {
          // Now inject the scripts.
          var scriptCounter = moduleList.length;

          if (!scriptCounter) {
            finishPluginLoading();
            return;
          }

          function scriptLoadedCallback() {
            if (!--scriptCounter) {
              onScriptLoadingComplete(moduleList, finishPluginLoading);
            }
          }

          for (var i = 0; i < moduleList.length; i++) {
            injectIfNecessary(moduleList[i].id, path + moduleList[i].file, scriptLoadedCallback);
          }
        }

        function findCordovaPath() {
          var path = null;
          var scripts = document.getElementsByTagName('script');
          var term = '/cordova.js';
          for (var n = scripts.length - 1; n > -1; n--) {
            var src = scripts[n].src.replace(/\?.*$/, ''); // Strip any query param (CB-6007).
            if (src.indexOf(term) == (src.length - term.length)) {
              path = src.substring(0, src.length - term.length) + '/';
              break;
            }
          }
          return path;
        }

        // Tries to load all plugins' js-modules.
        // This is an async process, but onDeviceReady is blocked on onPluginsReady.
        // onPluginsReady is fired when there are no plugins to load, or they are all done.
        exports.load = function(callback) {
          var pathPrefix = findCordovaPath();
          if (pathPrefix === null) {
            console.log('Could not find cordova.js script tag. Plugin loading may fail.');
            pathPrefix = '';
          }
          injectIfNecessary('cordova/plugin_list', pathPrefix + 'cordova_plugins.js', function() {
            var moduleList = require("cordova/plugin_list");
            handlePluginsObject(pathPrefix, moduleList, callback);
          }, callback);
        };


      });

      // file: src/common/urlutil.js
      define("cordova/urlutil", function(require, exports, module) {


        /**
         * For already absolute URLs, returns what is passed in.
         * For relative URLs, converts them to absolute ones.
         */
        exports.makeAbsolute = function makeAbsolute(url) {
          var anchorEl = document.createElement('a');
          anchorEl.href = url;
          return anchorEl.href;
        };


      });

      // file: src/common/utils.js
      define("cordova/utils", function(require, exports, module) {

        var utils = exports;

        /**
         * Defines a property getter / setter for obj[key].
         */
        utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {
          if (Object.defineProperty) {
            var desc = {
              get: getFunc,
              configurable: true
            };
            if (opt_setFunc) {
              desc.set = opt_setFunc;
            }
            Object.defineProperty(obj, key, desc);
          } else {
            obj.__defineGetter__(key, getFunc);
            if (opt_setFunc) {
              obj.__defineSetter__(key, opt_setFunc);
            }
          }
        };

        /**
         * Defines a property getter for obj[key].
         */
        utils.defineGetter = utils.defineGetterSetter;

        utils.arrayIndexOf = function(a, item) {
          if (a.indexOf) {
            return a.indexOf(item);
          }
          var len = a.length;
          for (var i = 0; i < len; ++i) {
            if (a[i] == item) {
              return i;
            }
          }
          return -1;
        };

        /**
         * Returns whether the item was found in the array.
         */
        utils.arrayRemove = function(a, item) {
          var index = utils.arrayIndexOf(a, item);
          if (index != -1) {
            a.splice(index, 1);
          }
          return index != -1;
        };

        utils.typeName = function(val) {
          return Object.prototype.toString.call(val).slice(8, -1);
        };

        /**
         * Returns an indication of whether the argument is an array or not
         */
        utils.isArray = function(a) {
          return utils.typeName(a) == 'Array';
        };

        /**
         * Returns an indication of whether the argument is a Date or not
         */
        utils.isDate = function(d) {
          return utils.typeName(d) == 'Date';
        };

        /**
         * Does a deep clone of the object.
         */
        utils.clone = function(obj) {
          if (!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {
            return obj;
          }

          var retVal, i;

          if (utils.isArray(obj)) {
            retVal = [];
            for (i = 0; i < obj.length; ++i) {
              retVal.push(utils.clone(obj[i]));
            }
            return retVal;
          }

          retVal = {};
          for (i in obj) {
            if (!(i in retVal) || retVal[i] != obj[i]) {
              retVal[i] = utils.clone(obj[i]);
            }
          }
          return retVal;
        };

        /**
         * Returns a wrapped version of the function
         */
        utils.close = function(context, func, params) {
          if (typeof params == 'undefined') {
            return function() {
              return func.apply(context, arguments);
            };
          } else {
            return function() {
              return func.apply(context, params);
            };
          }
        };

        /**
         * Create a UUID
         */
        utils.createUUID = function() {
          return UUIDcreatePart(4) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(6);
        };

        /**
         * Extends a child object from a parent object using classical inheritance
         * pattern.
         */
        utils.extend = (function() {
          // proxy used to establish prototype chain
          var F = function() {};
          // extend Child from Parent
          return function(Child, Parent) {
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.__super__ = Parent.prototype;
            Child.prototype.constructor = Child;
          };
        }());

        /**
         * Alerts a message in any available way: alert or console.log.
         */
        utils.alert = function(msg) {
          if (window.alert) {
            window.alert(msg);
          } else if (console && console.log) {
            console.log(msg);
          }
        };


        //------------------------------------------------------------------------------
        function UUIDcreatePart(length) {
          var uuidpart = "";
          for (var i = 0; i < length; i++) {
            var uuidchar = parseInt((Math.random() * 256), 10).toString(16);
            if (uuidchar.length == 1) {
              uuidchar = "0" + uuidchar;
            }
            uuidpart += uuidchar;
          }
          return uuidpart;
        }


      });

/************************日志插件**********************/

    define("org.apache.cordova.console-via-logger", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      //------------------------------------------------------------------------------

      var logger = require("cordova/plugin/logger");
      var utils  = require("cordova/utils");

      //------------------------------------------------------------------------------
      // object that we're exporting
      //------------------------------------------------------------------------------
      var console = module.exports;

      //------------------------------------------------------------------------------
      // copy of the original console object
      //------------------------------------------------------------------------------
      var WinConsole = window.console;

      //------------------------------------------------------------------------------
      // whether to use the logger
      //------------------------------------------------------------------------------
      var UseLogger = false;

      //------------------------------------------------------------------------------
      // Timers
      //------------------------------------------------------------------------------
      var Timers = {};

      //------------------------------------------------------------------------------
      // used for unimplemented methods
      //------------------------------------------------------------------------------
      function noop() {}

      //------------------------------------------------------------------------------
      // used for unimplemented methods
      //------------------------------------------------------------------------------
      console.useLogger = function (value) {
          if (arguments.length) UseLogger = !!value;

          if (UseLogger) {
              if (logger.useConsole()) {
                  throw new Error("console and logger are too intertwingly");
              }
          }

          return UseLogger;
      };

      //------------------------------------------------------------------------------
      console.log = function() {
          if (logger.useConsole()) return;
          logger.log.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.error = function() {
          if (logger.useConsole()) return;
          logger.error.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.warn = function() {
          if (logger.useConsole()) return;
          logger.warn.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.info = function() {
          if (logger.useConsole()) return;
          logger.info.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.debug = function() {
          if (logger.useConsole()) return;
          logger.debug.apply(logger, [].slice.call(arguments));
      };

      //------------------------------------------------------------------------------
      console.assert = function(expression) {
          if (expression) return;

          var message = logger.format.apply(logger.format, [].slice.call(arguments, 1));
          console.log("ASSERT: " + message);
      };

      //------------------------------------------------------------------------------
      console.clear = function() {};

      //------------------------------------------------------------------------------
      console.dir = function(object) {
          console.log("%o", object);
      };

      //------------------------------------------------------------------------------
      console.dirxml = function(node) {
          console.log(node.innerHTML);
      };

      //------------------------------------------------------------------------------
      console.trace = noop;

      //------------------------------------------------------------------------------
      console.group = console.log;

      //------------------------------------------------------------------------------
      console.groupCollapsed = console.log;

      //------------------------------------------------------------------------------
      console.groupEnd = noop;

      //------------------------------------------------------------------------------
      console.time = function(name) {
          Timers[name] = new Date().valueOf();
      };

      //------------------------------------------------------------------------------
      console.timeEnd = function(name) {
          var timeStart = Timers[name];
          if (!timeStart) {
              console.warn("unknown timer: " + name);
              return;
          }

          var timeElapsed = new Date().valueOf() - timeStart;
          console.log(name + ": " + timeElapsed + "ms");
      };

      //------------------------------------------------------------------------------
      console.timeStamp = noop;

      //------------------------------------------------------------------------------
      console.profile = noop;

      //------------------------------------------------------------------------------
      console.profileEnd = noop;

      //------------------------------------------------------------------------------
      console.count = noop;

      //------------------------------------------------------------------------------
      console.exception = console.log;

      //------------------------------------------------------------------------------
      console.table = function(data, columns) {
          console.log("%o", data);
      };

      //------------------------------------------------------------------------------
      // return a new function that calls both functions passed as args
      //------------------------------------------------------------------------------
      function wrappedOrigCall(orgFunc, newFunc) {
          return function() {
              var args = [].slice.call(arguments);
              try { orgFunc.apply(WinConsole, args); } catch (e) {}
              try { newFunc.apply(console,    args); } catch (e) {}
          };
      }

      //------------------------------------------------------------------------------
      // For every function that exists in the original console object, that
      // also exists in the new console object, wrap the new console method
      // with one that calls both
      //------------------------------------------------------------------------------
      for (var key in console) {
          if (typeof WinConsole[key] == "function") {
              console[key] = wrappedOrigCall(WinConsole[key], console[key]);
          }
      }

    });

    define("cordova/plugin/logger", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      //------------------------------------------------------------------------------
      // The logger module exports the following properties/functions:
      //
      // LOG                          - constant for the level LOG
      // ERROR                        - constant for the level ERROR
      // WARN                         - constant for the level WARN
      // INFO                         - constant for the level INFO
      // DEBUG                        - constant for the level DEBUG
      // logLevel()                   - returns current log level
      // logLevel(value)              - sets and returns a new log level
      // useConsole()                 - returns whether logger is using console
      // useConsole(value)            - sets and returns whether logger is using console
      // log(message,...)             - logs a message at level LOG
      // error(message,...)           - logs a message at level ERROR
      // warn(message,...)            - logs a message at level WARN
      // info(message,...)            - logs a message at level INFO
      // debug(message,...)           - logs a message at level DEBUG
      // logLevel(level,message,...)  - logs a message specified level
      //
      //------------------------------------------------------------------------------

      var logger = exports;

      var exec    = require('cordova/exec');
      var utils   = require('cordova/utils');

      var UseConsole   = false;
      var UseLogger    = true;
      var Queued       = [];
      var DeviceReady  = false;
      var CurrentLevel;

      var originalConsole = console;

      /**
       * Logging levels
       */

      var Levels = [
          "LOG",
          "ERROR",
          "WARN",
          "INFO",
          "DEBUG"
      ];

      /*
       * add the logging levels to the logger object and
       * to a separate levelsMap object for testing
       */

      var LevelsMap = {};
      for (var i=0; i<Levels.length; i++) {
          var level = Levels[i];
          LevelsMap[level] = i;
          logger[level]    = level;
      }

      CurrentLevel = LevelsMap.WARN;

      /**
       * Getter/Setter for the logging level
       *
       * Returns the current logging level.
       *
       * When a value is passed, sets the logging level to that value.
       * The values should be one of the following constants:
       *    logger.LOG
       *    logger.ERROR
       *    logger.WARN
       *    logger.INFO
       *    logger.DEBUG
       *
       * The value used determines which messages get printed.  The logging
       * values above are in order, and only messages logged at the logging
       * level or above will actually be displayed to the user.  E.g., the
       * default level is WARN, so only messages logged with LOG, ERROR, or
       * WARN will be displayed; INFO and DEBUG messages will be ignored.
       */
      logger.level = function (value) {
          if (arguments.length) {
              if (LevelsMap[value] === null) {
                  throw new Error("invalid logging level: " + value);
              }
              CurrentLevel = LevelsMap[value];
          }

          return Levels[CurrentLevel];
      };

      /**
       * Getter/Setter for the useConsole functionality
       *
       * When useConsole is true, the logger will log via the
       * browser 'console' object.
       */
      logger.useConsole = function (value) {
          if (arguments.length) UseConsole = !!value;

          if (UseConsole) {
              if (typeof console == "undefined") {
                  throw new Error("global console object is not defined");
              }

              if (typeof console.log != "function") {
                  throw new Error("global console object does not have a log function");
              }

              if (typeof console.useLogger == "function") {
                  if (console.useLogger()) {
                      throw new Error("console and logger are too intertwingly");
                  }
              }
          }

          return UseConsole;
      };

      /**
       * Getter/Setter for the useLogger functionality
       *
       * When useLogger is true, the logger will log via the
       * native Logger plugin.
       */
      logger.useLogger = function (value) {
          // Enforce boolean
          if (arguments.length) UseLogger = !!value;
          return UseLogger;
      };

      /**
       * Logs a message at the LOG level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.log   = function(message) { logWithArgs("LOG",   arguments); };

      /**
       * Logs a message at the ERROR level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.error = function(message) { logWithArgs("ERROR", arguments); };

      /**
       * Logs a message at the WARN level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.warn  = function(message) { logWithArgs("WARN",  arguments); };

      /**
       * Logs a message at the INFO level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.info  = function(message) { logWithArgs("INFO",  arguments); };

      /**
       * Logs a message at the DEBUG level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.debug = function(message) { logWithArgs("DEBUG", arguments); };

      // log at the specified level with args
      function logWithArgs(level, args) {
          args = [level].concat([].slice.call(args));
          logger.logLevel.apply(logger, args);
      }

      // return the correct formatString for an object
      function formatStringForMessage(message) {
          return (typeof message === "string") ? "" : "%o";
      }

      /**
       * Logs a message at the specified level.
       *
       * Parameters passed after message are used applied to
       * the message with utils.format()
       */
      logger.logLevel = function(level /* , ... */) {
          // format the message with the parameters
          var formatArgs = [].slice.call(arguments, 1);
          var fmtString = formatStringForMessage(formatArgs[0]);
          if (fmtString.length > 0){
              formatArgs.unshift(fmtString); // add formatString
          }

          var message    = logger.format.apply(logger.format, formatArgs);

          if (LevelsMap[level] === null) {
              throw new Error("invalid logging level: " + level);
          }

          if (LevelsMap[level] > CurrentLevel) return;

          // queue the message if not yet at deviceready
          if (!DeviceReady && !UseConsole) {
              Queued.push([level, message]);
              return;
          }

          // Log using the native logger if that is enabled
          if (UseLogger) {
              exec(null, null, "Console", "logLevel", [level, message]);
          }

          // Log using the console if that is enabled
          if (UseConsole) {
              // make sure console is not using logger
              if (console.useLogger()) {
                  throw new Error("console and logger are too intertwingly");
              }

              // log to the console
              switch (level) {
                  case logger.LOG:   originalConsole.log(message); break;
                  case logger.ERROR: originalConsole.log("ERROR: " + message); break;
                  case logger.WARN:  originalConsole.log("WARN: "  + message); break;
                  case logger.INFO:  originalConsole.log("INFO: "  + message); break;
                  case logger.DEBUG: originalConsole.log("DEBUG: " + message); break;
              }
          }
      };


      /**
       * Formats a string and arguments following it ala console.log()
       *
       * Any remaining arguments will be appended to the formatted string.
       *
       * for rationale, see FireBug's Console API:
       *    http://getfirebug.com/wiki/index.php/Console_API
       */
      logger.format = function(formatString, args) {
          return __format(arguments[0], [].slice.call(arguments,1)).join(' ');
      };


      //------------------------------------------------------------------------------
      /**
       * Formats a string and arguments following it ala vsprintf()
       *
       * format chars:
       *   %j - format arg as JSON
       *   %o - format arg as JSON
       *   %c - format arg as ''
       *   %% - replace with '%'
       * any other char following % will format it's
       * arg via toString().
       *
       * Returns an array containing the formatted string and any remaining
       * arguments.
       */
      function __format(formatString, args) {
          if (formatString === null || formatString === undefined) return [""];
          if (arguments.length == 1) return [formatString.toString()];

          if (typeof formatString != "string")
              formatString = formatString.toString();

          var pattern = /(.*?)%(.)(.*)/;
          var rest    = formatString;
          var result  = [];

          while (args.length) {
              var match = pattern.exec(rest);
              if (!match) break;

              var arg   = args.shift();
              rest = match[3];
              result.push(match[1]);

              if (match[2] == '%') {
                  result.push('%');
                  args.unshift(arg);
                  continue;
              }

              result.push(__formatted(arg, match[2]));
          }

          result.push(rest);

          var remainingArgs = [].slice.call(args);
          remainingArgs.unshift(result.join(''));
          return remainingArgs;
      }

      function __formatted(object, formatChar) {

          try {
              switch(formatChar) {
                  case 'j':
                  case 'o': return JSON.stringify(object);
                  case 'c': return '';
              }
          }
          catch (e) {
              return "error JSON.stringify()ing argument: " + e;
          }

          if ((object === null) || (object === undefined)) {
              return Object.prototype.toString.call(object);
          }

          return object.toString();
      }


      //------------------------------------------------------------------------------
      // when deviceready fires, log queued messages
      logger.__onDeviceReady = function() {
          if (DeviceReady) return;

          DeviceReady = true;

          for (var i=0; i<Queued.length; i++) {
              var messageArgs = Queued[i];
              logger.logLevel(messageArgs[0], messageArgs[1]);
          }

          Queued = null;
      };

      // add a deviceready event to log queued messages
      document.addEventListener("deviceready", logger.__onDeviceReady, false);

    });

  /**************音频插件****************/
    define("org.apache.cordova.media.Media", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      var argscheck = require('cordova/argscheck'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec');

      var mediaObjects = {};

      /**
       * This class provides access to the device media, interfaces to both sound and video
       *
       * @constructor
       * @param src                   The file name or url to play
       * @param successCallback       The callback to be called when the file is done playing or recording.
       *                                  successCallback()
       * @param errorCallback         The callback to be called if there is an error.
       *                                  errorCallback(int errorCode) - OPTIONAL
       * @param statusCallback        The callback to be called when media status has changed.
       *                                  statusCallback(int statusCode) - OPTIONAL
       */
      var Media = function(src, successCallback, errorCallback, statusCallback) {
          argscheck.checkArgs('SFFF', 'Media', arguments);
          this.id = utils.createUUID();
          mediaObjects[this.id] = this;
          this.src = src;
          this.successCallback = successCallback;
          this.errorCallback = errorCallback;
          this.statusCallback = statusCallback;
          this._duration = -1;
          this._position = -1;
          exec(null, this.errorCallback, "Media", "create", [this.id, this.src]);
      };

      // Media messages
      Media.MEDIA_STATE = 1;
      Media.MEDIA_DURATION = 2;
      Media.MEDIA_POSITION = 3;
      Media.MEDIA_ERROR = 9;

      // Media states
      Media.MEDIA_NONE = 0;
      Media.MEDIA_STARTING = 1;
      Media.MEDIA_RUNNING = 2;
      Media.MEDIA_PAUSED = 3;
      Media.MEDIA_STOPPED = 4;
      Media.MEDIA_MSG = ["None", "Starting", "Running", "Paused", "Stopped"];

      // "static" function to return existing objs.
      Media.get = function(id) {
          return mediaObjects[id];
      };

      /**
       * Start or resume playing audio file.
       */
      Media.prototype.play = function(options) {
          exec(null, null, "Media", "startPlayingAudio", [this.id, this.src, options]);
      };

      /**
       * Stop playing audio file.
       */
      Media.prototype.stop = function() {
          var me = this;
          exec(function() {
              me._position = 0;
          }, this.errorCallback, "Media", "stopPlayingAudio", [this.id]);
      };

      /**
       * Seek or jump to a new time in the track..
       */
      Media.prototype.seekTo = function(milliseconds) {
          var me = this;
          exec(function(p) {
              me._position = p;
          }, this.errorCallback, "Media", "seekToAudio", [this.id, milliseconds]);
      };

      /**
       * Pause playing audio file.
       */
      Media.prototype.pause = function() {
          exec(null, this.errorCallback, "Media", "pausePlayingAudio", [this.id]);
      };

      /**
       * Get duration of an audio file.
       * The duration is only set for audio that is playing, paused or stopped.
       *
       * @return      duration or -1 if not known.
       */
      Media.prototype.getDuration = function() {
          return this._duration;
      };

      /**
       * Get position of audio.
       */
      Media.prototype.getCurrentPosition = function(success, fail) {
          var me = this;
          exec(function(p) {
              me._position = p;
              success(p);
          }, fail, "Media", "getCurrentPositionAudio", [this.id]);
      };

      /**
       * Start recording audio file.
       */
      Media.prototype.startRecord = function() {
          exec(null, this.errorCallback, "Media", "startRecordingAudio", [this.id, this.src]);
      };

      /**
       * Stop recording audio file.
       */
      Media.prototype.stopRecord = function() {
          exec(null, this.errorCallback, "Media", "stopRecordingAudio", [this.id]);
      };

      /**
       * Release the resources.
       */
      Media.prototype.release = function() {
          exec(null, this.errorCallback, "Media", "release", [this.id]);
      };

      /**
       * Adjust the volume.
       */
      Media.prototype.setVolume = function(volume) {
          exec(null, null, "Media", "setVolume", [this.id, volume]);
      };

      /**
       * Audio has status update.
       * PRIVATE
       *
       * @param id            The media object id (string)
       * @param msgType       The 'type' of update this is
       * @param value         Use of value is determined by the msgType
       */
      Media.onStatus = function(id, msgType, value) {

          var media = mediaObjects[id];

          if(media) {
              switch(msgType) {
                  case Media.MEDIA_STATE :
                      media.statusCallback && media.statusCallback(value);
                      if(value == Media.MEDIA_STOPPED) {
                          media.successCallback && media.successCallback();
                      }
                      break;
                  case Media.MEDIA_DURATION :
                      media._duration = value;
                      break;
                  case Media.MEDIA_ERROR :
                      media.errorCallback && media.errorCallback(value);
                      break;
                  case Media.MEDIA_POSITION :
                      media._position = Number(value);
                      break;
                  default :
                      console.error && console.error("Unhandled Media.onStatus :: " + msgType);
                      break;
              }
          }
          else {
              console.error && console.error("Received Media.onStatus callback for unknown media :: " + id);
          }

      };

      module.exports = Media;

    });

    define("org.apache.cordova.media.MediaError", function(require, exports, module) {
      /*
       *
       * Licensed to the Apache Software Foundation (ASF) under one
       * or more contributor license agreements.  See the NOTICE file
       * distributed with this work for additional information
       * regarding copyright ownership.  The ASF licenses this file
       * to you under the Apache License, Version 2.0 (the
       * "License"); you may not use this file except in compliance
       * with the License.  You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing,
       * software distributed under the License is distributed on an
       * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
       * KIND, either express or implied.  See the License for the
       * specific language governing permissions and limitations
       * under the License.
       *
      */

      /**
       * This class contains information about any Media errors.
      */
      /*
       According to :: http://dev.w3.org/html5/spec-author-view/video.html#mediaerror
       We should never be creating these objects, we should just implement the interface
       which has 1 property for an instance, 'code'

       instead of doing :
          errorCallbackFunction( new MediaError(3,'msg') );
      we should simply use a literal :
          errorCallbackFunction( {'code':3} );
       */

       var _MediaError = window.MediaError;


      if(!_MediaError) {
          window.MediaError = _MediaError = function(code, msg) {
              this.code = (typeof code != 'undefined') ? code : null;
              this.message = msg || ""; // message is NON-standard! do not use!
          };
      }

      _MediaError.MEDIA_ERR_NONE_ACTIVE    = _MediaError.MEDIA_ERR_NONE_ACTIVE    || 0;
      _MediaError.MEDIA_ERR_ABORTED        = _MediaError.MEDIA_ERR_ABORTED        || 1;
      _MediaError.MEDIA_ERR_NETWORK        = _MediaError.MEDIA_ERR_NETWORK        || 2;
      _MediaError.MEDIA_ERR_DECODE         = _MediaError.MEDIA_ERR_DECODE         || 3;
      _MediaError.MEDIA_ERR_NONE_SUPPORTED = _MediaError.MEDIA_ERR_NONE_SUPPORTED || 4;
      // TODO: MediaError.MEDIA_ERR_NONE_SUPPORTED is legacy, the W3 spec now defines it as below.
      // as defined by http://dev.w3.org/html5/spec-author-view/video.html#error-codes
      _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 4;

      module.exports = _MediaError;

      });

    //插件列表
    define("cordova/plugin_list", function(require, exports, module) {
        module.exports = [];
    });
    

//*****************************************************************
      window.cordova = require('cordova');
      // file: src/scripts/bootstrap.js

      require('cordova/init');

      window.console = require('org.apache.cordova.console-via-logger');
      window.Media = require('org.apache.cordova.media.Media');

    })();

} else if(Xut.plat.isAndroid){
      
    	// commit 71223711fb1591b1255d871140d959fd9095f0c3

    // File generated at :: Mon Jan 21 2013 13:45:08 GMT-0800 (PST)

    /*
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
     
         http://www.apache.org/licenses/LICENSE-2.0
     
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
    */

    ;(function() {

    // file: lib/scripts/require.js

    var require,
        define;

    (function () {
        var modules = {};
        // Stack of moduleIds currently being built.
        var requireStack = [];
        // Map of module ID -> index into requireStack of modules currently being built.
        var inProgressModules = {};

        function build(module) {
            var factory = module.factory;
            module.exports = {};
            delete module.factory;
            factory(require, module.exports, module);
            return module.exports;
        }

        require = function (id) {
            if (!modules[id]) {
                throw "module " + id + " not found";
            } else if (id in inProgressModules) {
                var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;
                throw "Cycle in require graph: " + cycle;
            }
            if (modules[id].factory) {
                try {
                    inProgressModules[id] = requireStack.length;
                    requireStack.push(id);
                    return build(modules[id]);
                } finally {
                    delete inProgressModules[id];
                    requireStack.pop();
                }
            }
            return modules[id].exports;
        };

        define = function (id, factory) {
            if (modules[id]) {
                throw "module " + id + " already defined";
            }

            modules[id] = {
                id: id,
                factory: factory
            };
        };

        define.remove = function (id) {
            delete modules[id];
        };

        define.moduleMap = modules;
    })();

    //Export for use in node
    if (typeof module === "object" && typeof require === "function") {
        module.exports.require = require;
        module.exports.define = define;
    }

    // file: lib/cordova.js
    define("cordova", function(require, exports, module) {


    var channel = require('cordova/channel');

    /**
     * Listen for DOMContentLoaded and notify our channel subscribers.
     */
    document.addEventListener('DOMContentLoaded', function() {
        channel.onDOMContentLoaded.fire();
    }, false);
    if (document.readyState == 'complete' || document.readyState == 'interactive') {
        channel.onDOMContentLoaded.fire();
    }

    /**
     * Intercept calls to addEventListener + removeEventListener and handle deviceready,
     * resume, and pause events.
     */
    var m_document_addEventListener = document.addEventListener;
    var m_document_removeEventListener = document.removeEventListener;
    var m_window_addEventListener = window.addEventListener;
    var m_window_removeEventListener = window.removeEventListener;

    /**
     * Houses custom event handlers to intercept on document + window event listeners.
     */
    var documentEventHandlers = {},
        windowEventHandlers = {};

    document.addEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        if (typeof documentEventHandlers[e] != 'undefined') {
            documentEventHandlers[e].subscribe(handler);
        } else {
            m_document_addEventListener.call(document, evt, handler, capture);
        }
    };

    window.addEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        if (typeof windowEventHandlers[e] != 'undefined') {
            windowEventHandlers[e].subscribe(handler);
        } else {
            m_window_addEventListener.call(window, evt, handler, capture);
        }
    };

    document.removeEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        // If unsubscribing from an event that is handled by a plugin
        if (typeof documentEventHandlers[e] != "undefined") {
            documentEventHandlers[e].unsubscribe(handler);
        } else {
            m_document_removeEventListener.call(document, evt, handler, capture);
        }
    };

    window.removeEventListener = function(evt, handler, capture) {
        var e = evt.toLowerCase();
        // If unsubscribing from an event that is handled by a plugin
        if (typeof windowEventHandlers[e] != "undefined") {
            windowEventHandlers[e].unsubscribe(handler);
        } else {
            m_window_removeEventListener.call(window, evt, handler, capture);
        }
    };

    function createEvent(type, data) {
        var event = document.createEvent('Events');
        event.initEvent(type, false, false);
        if (data) {
            for (var i in data) {
                if (data.hasOwnProperty(i)) {
                    event[i] = data[i];
                }
            }
        }
        return event;
    }

    if(typeof window.console === "undefined") {
        window.console = {
            log:function(){}
        };
    }

    var cordova = {
        define:define,
        require:require,
        /**
         * Methods to add/remove your own addEventListener hijacking on document + window.
         */
        addWindowEventHandler:function(event) {
            return (windowEventHandlers[event] = channel.create(event));
        },
        addStickyDocumentEventHandler:function(event) {
            return (documentEventHandlers[event] = channel.createSticky(event));
        },
        addDocumentEventHandler:function(event) {
            return (documentEventHandlers[event] = channel.create(event));
        },
        removeWindowEventHandler:function(event) {
            delete windowEventHandlers[event];
        },
        removeDocumentEventHandler:function(event) {
            delete documentEventHandlers[event];
        },
        /**
         * Retrieve original event handlers that were replaced by Cordova
         *
         * @return object
         */
        getOriginalHandlers: function() {
            return {'document': {'addEventListener': m_document_addEventListener, 'removeEventListener': m_document_removeEventListener},
            'window': {'addEventListener': m_window_addEventListener, 'removeEventListener': m_window_removeEventListener}};
        },
        /**
         * Method to fire event from native code
         * bNoDetach is required for events which cause an exception which needs to be caught in native code
         */
        fireDocumentEvent: function(type, data, bNoDetach) {
            var evt = createEvent(type, data);
            if (typeof documentEventHandlers[type] != 'undefined') {
                if( bNoDetach ) {
                  documentEventHandlers[type].fire(evt);
                }
                else {
                  setTimeout(function() {
                      documentEventHandlers[type].fire(evt);
                  }, 0);
                }
            } else {
                document.dispatchEvent(evt);
            }
        },
        fireWindowEvent: function(type, data) {
            var evt = createEvent(type,data);
            if (typeof windowEventHandlers[type] != 'undefined') {
                setTimeout(function() {
                    windowEventHandlers[type].fire(evt);
                }, 0);
            } else {
                window.dispatchEvent(evt);
            }
        },

        /**
         * Plugin callback mechanism.
         */
        // Randomize the starting callbackId to avoid collisions after refreshing or navigating.
        // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.
        callbackId: Math.floor(Math.random() * 2000000000),
        callbacks:  {},
        callbackStatus: {
            NO_RESULT: 0,
            OK: 1,
            CLASS_NOT_FOUND_EXCEPTION: 2,
            ILLEGAL_ACCESS_EXCEPTION: 3,
            INSTANTIATION_EXCEPTION: 4,
            MALFORMED_URL_EXCEPTION: 5,
            IO_EXCEPTION: 6,
            INVALID_ACTION: 7,
            JSON_EXCEPTION: 8,
            ERROR: 9
        },

        /**
         * Called by native code when returning successful result from an action.
         */
        callbackSuccess: function(callbackId, args) {
            try {
                cordova.callbackFromNative(callbackId, true, args.status, args.message, args.keepCallback);
            } catch (e) {
                console.log("Error in error callback: " + callbackId + " = "+e);
            }
        },

        /**
         * Called by native code when returning error result from an action.
         */
        callbackError: function(callbackId, args) {
            // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.
            // Derive success from status.
            try {
                cordova.callbackFromNative(callbackId, false, args.status, args.message, args.keepCallback);
            } catch (e) {
                console.log("Error in error callback: " + callbackId + " = "+e);
            }
        },

        /**
         * Called by native code when returning the result from an action.
         */
        callbackFromNative: function(callbackId, success, status, message, keepCallback) {
            var callback = cordova.callbacks[callbackId];
            if (callback) {
                if (success && status == cordova.callbackStatus.OK) {
                    callback.success && callback.success(message);
                } else if (!success) {
                    callback.fail && callback.fail(message);
                }

                // Clear callback if not expecting any more results
                if (!keepCallback) {
                    delete cordova.callbacks[callbackId];
                }
            }
        },
        addConstructor: function(func) {
            channel.onCordovaReady.subscribe(function() {
                try {
                    func();
                } catch(e) {
                    console.log("Failed to run constructor: " + e);
                }
            });
        }
    };

    // Register pause, resume and deviceready channels as events on document.
    channel.onPause = cordova.addDocumentEventHandler('pause');
    channel.onResume = cordova.addDocumentEventHandler('resume');
    channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

    module.exports = cordova;

    });

    // file: lib/common/argscheck.js
    define("cordova/argscheck", function(require, exports, module) {

    var exec = require('cordova/exec');
    var utils = require('cordova/utils');

    var moduleExports = module.exports;

    var typeMap = {
        'A': 'Array',
        'D': 'Date',
        'N': 'Number',
        'S': 'String',
        'F': 'Function',
        'O': 'Object'
    };

    function extractParamName(callee, argIndex) {
      return (/.*?\((.*?)\)/).exec(callee)[1].split(', ')[argIndex];
    }

    function checkArgs(spec, functionName, args, opt_callee) {
        if (!moduleExports.enableChecks) {
            return;
        }
        var errMsg = null;
        var typeName;
        for (var i = 0; i < spec.length; ++i) {
            var c = spec.charAt(i),
                cUpper = c.toUpperCase(),
                arg = args[i];
            // Asterix means allow anything.
            if (c == '*') {
                continue;
            }
            typeName = utils.typeName(arg);
            if ((arg === null || arg === undefined) && c == cUpper) {
                continue;
            }
            if (typeName != typeMap[cUpper]) {
                errMsg = 'Expected ' + typeMap[cUpper];
                break;
            }
        }
        if (errMsg) {
            errMsg += ', but got ' + typeName + '.';
            errMsg = 'Wrong type for parameter "' + extractParamName(opt_callee || args.callee, i) + '" of ' + functionName + ': ' + errMsg;
            // Don't log when running jake test.
            if (typeof jasmine == 'undefined') {
                console.error(errMsg);
            }
            throw TypeError(errMsg);
        }
    }

    function getValue(value, defaultValue) {
        return value === undefined ? defaultValue : value;
    }

    moduleExports.checkArgs = checkArgs;
    moduleExports.getValue = getValue;
    moduleExports.enableChecks = true;


    });

    // file: lib/common/builder.js
    define("cordova/builder", function(require, exports, module) {

    var utils = require('cordova/utils');

    function each(objects, func, context) {
        for (var prop in objects) {
            if (objects.hasOwnProperty(prop)) {
                func.apply(context, [objects[prop], prop]);
            }
        }
    }

    function clobber(obj, key, value) {
        obj[key] = value;
        // Getters can only be overridden by getters.
        if (obj[key] !== value) {
            utils.defineGetter(obj, key, function() {
                return value;
            });
        }
    }

    function assignOrWrapInDeprecateGetter(obj, key, value, message) {
        if (message) {
            utils.defineGetter(obj, key, function() {
                console.log(message);
                delete obj[key];
                clobber(obj, key, value);
                return value;
            });
        } else {
            clobber(obj, key, value);
        }
    }

    function include(parent, objects, clobber, merge) {
        each(objects, function (obj, key) {
            try {
              var result = obj.path ? require(obj.path) : {};

              if (clobber) {
                  // Clobber if it doesn't exist.
                  if (typeof parent[key] === 'undefined') {
                      assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                  } else if (typeof obj.path !== 'undefined') {
                      // If merging, merge properties onto parent, otherwise, clobber.
                      if (merge) {
                          recursiveMerge(parent[key], result);
                      } else {
                          assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                      }
                  }
                  result = parent[key];
              } else {
                // Overwrite if not currently defined.
                if (typeof parent[key] == 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else {
                  // Set result to what already exists, so we can build children into it if they exist.
                  result = parent[key];
                }
              }

              if (obj.children) {
                include(result, obj.children, clobber, merge);
              }
            } catch(e) {
              utils.alert('Exception building cordova JS globals: ' + e + ' for key "' + key + '"');
            }
        });
    }

    /**
     * Merge properties from one object onto another recursively.  Properties from
     * the src object will overwrite existing target property.
     *
     * @param target Object to merge properties into.
     * @param src Object to merge properties from.
     */
    function recursiveMerge(target, src) {
        for (var prop in src) {
            if (src.hasOwnProperty(prop)) {
                if (target.prototype && target.prototype.constructor === target) {
                    // If the target object is a constructor override off prototype.
                    clobber(target.prototype, prop, src[prop]);
                } else {
                    if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {
                        recursiveMerge(target[prop], src[prop]);
                    } else {
                        clobber(target, prop, src[prop]);
                    }
                }
            }
        }
    }

    module.exports = {
        buildIntoButDoNotClobber: function(objects, target) {
            include(target, objects, false, false);
        },
        buildIntoAndClobber: function(objects, target) {
            include(target, objects, true, false);
        },
        buildIntoAndMerge: function(objects, target) {
            include(target, objects, true, true);
        },
        recursiveMerge: recursiveMerge,
        assignOrWrapInDeprecateGetter: assignOrWrapInDeprecateGetter
    };

    });

    // file: lib/common/channel.js
    define("cordova/channel", function(require, exports, module) {

    var utils = require('cordova/utils'),
        nextGuid = 1;

    /**
     * Custom pub-sub "channel" that can have functions subscribed to it
     * This object is used to define and control firing of events for
     * cordova initialization, as well as for custom events thereafter.
     *
     * The order of events during page load and Cordova startup is as follows:
     *
     * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.
     * onNativeReady*              Internal event that indicates the Cordova native side is ready.
     * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.
     * onCordovaInfoReady*         Internal event fired when device properties are available.
     * onCordovaConnectionReady*   Internal event fired when the connection property has been set.
     * onDeviceReady*              User event fired to indicate that Cordova is ready
     * onResume                    User event fired to indicate a start/resume lifecycle event
     * onPause                     User event fired to indicate a pause lifecycle event
     * onDestroy*                  Internal event fired when app is being destroyed (User should use window.onunload event, not this one).
     *
     * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.
     * All listeners that subscribe after the event is fired will be executed right away.
     *
     * The only Cordova events that user code should register for are:
     *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript
     *      pause                 App has moved to background
     *      resume                App has returned to foreground
     *
     * Listeners can be registered as:
     *      document.addEventListener("deviceready", myDeviceReadyListener, false);
     *      document.addEventListener("resume", myResumeListener, false);
     *      document.addEventListener("pause", myPauseListener, false);
     *
     * The DOM lifecycle events should be used for saving and restoring state
     *      window.onload
     *      window.onunload
     *
     */

    /**
     * Channel
     * @constructor
     * @param type  String the channel name
     */
    var Channel = function(type, sticky) {
        this.type = type;
        // Map of guid -> function.
        this.handlers = {};
        // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
        this.state = sticky ? 1 : 0;
        // Used in sticky mode to remember args passed to fire().
        this.fireArgs = null;
        // Used by onHasSubscribersChange to know if there are any listeners.
        this.numHandlers = 0;
        // Function that is called when the first listener is subscribed, or when
        // the last listener is unsubscribed.
        this.onHasSubscribersChange = null;
    },
        channel = {
            /**
             * Calls the provided function only after all of the channels specified
             * have been fired. All channels must be sticky channels.
             */
            join: function(h, c) {
                var len = c.length,
                    i = len,
                    f = function() {
                        if (!(--i)) h();
                    };
                for (var j=0; j<len; j++) {
                    if (c[j].state === 0) {
                        throw Error('Can only use join with sticky channels.');
                    }
                    c[j].subscribe(f);
                }
                if (!len) h();
            },
            create: function(type) {
                return channel[type] = new Channel(type, false);
            },
            createSticky: function(type) {
                return channel[type] = new Channel(type, true);
            },

            /**
             * cordova Channels that must fire before "deviceready" is fired.
             */
            deviceReadyChannelsArray: [],
            deviceReadyChannelsMap: {},

            /**
             * Indicate that a feature needs to be initialized before it is ready to be used.
             * This holds up Cordova's "deviceready" event until the feature has been initialized
             * and Cordova.initComplete(feature) is called.
             *
             * @param feature {String}     The unique feature name
             */
            waitForInitialization: function(feature) {
                if (feature) {
                    var c = channel[feature] || this.createSticky(feature);
                    this.deviceReadyChannelsMap[feature] = c;
                    this.deviceReadyChannelsArray.push(c);
                }
            },

            /**
             * Indicate that initialization code has completed and the feature is ready to be used.
             *
             * @param feature {String}     The unique feature name
             */
            initializationComplete: function(feature) {
                var c = this.deviceReadyChannelsMap[feature];
                if (c) {
                    c.fire();
                }
            }
        };

    function forceFunction(f) {
        if (typeof f != 'function') throw "Function required as first argument!";
    }

    /**
     * Subscribes the given function to the channel. Any time that
     * Channel.fire is called so too will the function.
     * Optionally specify an execution context for the function
     * and a guid that can be used to stop subscribing to the channel.
     * Returns the guid.
     */
    Channel.prototype.subscribe = function(f, c) {
        // need a function to call
        forceFunction(f);
        if (this.state == 2) {
            f.apply(c || this, this.fireArgs);
            return;
        }

        var func = f,
            guid = f.observer_guid;
        if (typeof c == "object") { func = utils.close(c, f); }

        if (!guid) {
            // first time any channel has seen this subscriber
            guid = '' + nextGuid++;
        }
        func.observer_guid = guid;
        f.observer_guid = guid;

        // Don't add the same handler more than once.
        if (!this.handlers[guid]) {
            this.handlers[guid] = func;
            this.numHandlers++;
            if (this.numHandlers == 1) {
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };

    /**
     * Unsubscribes the function with the given guid from the channel.
     */
    Channel.prototype.unsubscribe = function(f) {
        // need a function to unsubscribe
        forceFunction(f);

        var guid = f.observer_guid,
            handler = this.handlers[guid];
        if (handler) {
            delete this.handlers[guid];
            this.numHandlers--;
            if (this.numHandlers === 0) {
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };

    /**
     * Calls all functions subscribed to this channel.
     */
    Channel.prototype.fire = function(e) {
        var fail = false,
            fireArgs = Array.prototype.slice.call(arguments);
        // Apply stickiness.
        if (this.state == 1) {
            this.state = 2;
            this.fireArgs = fireArgs;
        }
        if (this.numHandlers) {
            // Copy the values first so that it is safe to modify it from within
            // callbacks.
            var toCall = [];
            for (var item in this.handlers) {
                toCall.push(this.handlers[item]);
            }
            for (var i = 0; i < toCall.length; ++i) {
                toCall[i].apply(this, fireArgs);
            }
            if (this.state == 2 && this.numHandlers) {
                this.numHandlers = 0;
                this.handlers = {};
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };


    // defining them here so they are ready super fast!
    // DOM event that is received when the web page is loaded and parsed.
    channel.createSticky('onDOMContentLoaded');

    // Event to indicate the Cordova native side is ready.
    channel.createSticky('onNativeReady');

    // Event to indicate that all Cordova JavaScript objects have been created
    // and it's time to run plugin constructors.
    channel.createSticky('onCordovaReady');

    // Event to indicate that device properties are available
    channel.createSticky('onCordovaInfoReady');

    // Event to indicate that the connection property has been set.
    channel.createSticky('onCordovaConnectionReady');

    // Event to indicate that Cordova is ready
    channel.createSticky('onDeviceReady');

    // Event to indicate a resume lifecycle event
    channel.create('onResume');

    // Event to indicate a pause lifecycle event
    channel.create('onPause');

    // Event to indicate a destroy lifecycle event
    channel.createSticky('onDestroy');

    // Channels that must fire before "deviceready" is fired.
    channel.waitForInitialization('onCordovaReady');
    channel.waitForInitialization('onCordovaConnectionReady');

    module.exports = channel;

    });

    // file: lib/common/commandProxy.js
    define("cordova/commandProxy", function(require, exports, module) {


    // internal map of proxy function
    var CommandProxyMap = {};

    module.exports = {

        // example: cordova.commandProxy.add("Accelerometer",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);
        add:function(id,proxyObj) {
            console.log("adding proxy for " + id);
            CommandProxyMap[id] = proxyObj;
            return proxyObj;
        },

        // cordova.commandProxy.remove("Accelerometer");
        remove:function(id) {
            var proxy = CommandProxyMap[id];
            delete CommandProxyMap[id];
            CommandProxyMap[id] = null;
            return proxy;
        },

        get:function(service,action) {
            return ( CommandProxyMap[service] ? CommandProxyMap[service][action] : null );
        }
    };
    });

    // file: lib/common/common.js
    define("cordova/common", function(require, exports, module) {

    module.exports = {
        defaults: {
            cordova: {
                path: 'cordova',
                children: {
                    exec: {
                        path: 'cordova/exec'
                    },
                    logger: {
                        path: 'cordova/plugin/logger'
                    }
                }
            },
            Cordova: {
                children: {
                    exec: {
                        path: 'cordova/exec'
                    }
                }
            },
            open : {
                path: 'cordova/plugin/InAppBrowser'
            },
            navigator: {
                children: {
                    notification: {
                        path: 'cordova/plugin/notification'
                    },
                    accelerometer: {
                        path: 'cordova/plugin/accelerometer'
                    },
                    battery: {
                        path: 'cordova/plugin/battery'
                    },
                    camera:{
                        path: 'cordova/plugin/Camera'
                    },
                    compass:{
                        path: 'cordova/plugin/compass'
                    },
                    contacts: {
                        path: 'cordova/plugin/contacts'
                    },
                    device:{
                        children:{
                            capture: {
                                path: 'cordova/plugin/capture'
                            }
                        }
                    },
                    geolocation: {
                        path: 'cordova/plugin/geolocation'
                    },
                    globalization: {
                        path: 'cordova/plugin/globalization'
                    },
                    network: {
                        children: {
                            connection: {
                                path: 'cordova/plugin/network',
                                deprecated: 'navigator.network.connection is deprecated. Use navigator.connection instead.'
                            }
                        }
                    },
                    splashscreen: {
                        path: 'cordova/plugin/splashscreen'
                    }
                }
            },
            Acceleration: {
                path: 'cordova/plugin/Acceleration'
            },
            Camera:{
                path: 'cordova/plugin/CameraConstants'
            },
            CameraPopoverOptions: {
                path: 'cordova/plugin/CameraPopoverOptions'
            },
            CaptureError: {
                path: 'cordova/plugin/CaptureError'
            },
            CaptureAudioOptions:{
                path: 'cordova/plugin/CaptureAudioOptions'
            },
            CaptureImageOptions: {
                path: 'cordova/plugin/CaptureImageOptions'
            },
            CaptureVideoOptions: {
                path: 'cordova/plugin/CaptureVideoOptions'
            },
            CompassHeading:{
                path: 'cordova/plugin/CompassHeading'
            },
            CompassError:{
                path: 'cordova/plugin/CompassError'
            },
            ConfigurationData: {
                path: 'cordova/plugin/ConfigurationData'
            },
            Connection: {
                path: 'cordova/plugin/Connection'
            },
            Contact: {
                path: 'cordova/plugin/Contact'
            },
            ContactAddress: {
                path: 'cordova/plugin/ContactAddress'
            },
            ContactError: {
                path: 'cordova/plugin/ContactError'
            },
            ContactField: {
                path: 'cordova/plugin/ContactField'
            },
            ContactFindOptions: {
                path: 'cordova/plugin/ContactFindOptions'
            },
            ContactName: {
                path: 'cordova/plugin/ContactName'
            },
            ContactOrganization: {
                path: 'cordova/plugin/ContactOrganization'
            },
            Coordinates: {
                path: 'cordova/plugin/Coordinates'
            },
            device: {
                path: 'cordova/plugin/device'
            },
            GlobalizationError: {
                path: 'cordova/plugin/GlobalizationError'
            },
            Media: {
                path: 'cordova/plugin/Media'
            },
            MediaError: {
                path: 'cordova/plugin/MediaError'
            },
            MediaFile: {
                path: 'cordova/plugin/MediaFile'
            },
            MediaFileData:{
                path: 'cordova/plugin/MediaFileData'
            },
            Position: {
                path: 'cordova/plugin/Position'
            },
            PositionError: {
                path: 'cordova/plugin/PositionError'
            },
            ProgressEvent: {
                path: 'cordova/plugin/ProgressEvent'
            }
        },
        clobbers: {
            navigator: {
                children: {
                    connection: {
                        path: 'cordova/plugin/network'
                    }
                }
            }
        }
    };

    });

    // file: lib/android/exec.js
    define("cordova/exec", function(require, exports, module) {

    /**
     * Execute a cordova command.  It is up to the native side whether this action
     * is synchronous or asynchronous.  The native side can return:
     *      Synchronous: PluginResult object as a JSON string
     *      Asynchronous: Empty string ""
     * If async, the native side will cordova.callbackSuccess or cordova.callbackError,
     * depending upon the result of the action.
     *
     * @param {Function} success    The success callback
     * @param {Function} fail       The fail callback
     * @param {String} service      The name of the service to use
     * @param {String} action       Action to be run in cordova
     * @param {String[]} [args]     Zero or more arguments to pass to the method
     */
    var cordova = require('cordova'),
        nativeApiProvider = require('cordova/plugin/android/nativeapiprovider'),
        utils = require('cordova/utils'),
        jsToNativeModes = {
            PROMPT: 0,
            JS_OBJECT: 1,
            // This mode is currently for benchmarking purposes only. It must be enabled
            // on the native side through the ENABLE_LOCATION_CHANGE_EXEC_MODE
            // constant within CordovaWebViewClient.java before it will work.
            LOCATION_CHANGE: 2
        },
        nativeToJsModes = {
            // Polls for messages using the JS->Native bridge.
            POLLING: 0,
            // For LOAD_URL to be viable, it would need to have a work-around for
            // the bug where the soft-keyboard gets dismissed when a message is sent.
            LOAD_URL: 1,
            // For the ONLINE_EVENT to be viable, it would need to intercept all event
            // listeners (both through addEventListener and window.ononline) as well
            // as set the navigator property itself.
            ONLINE_EVENT: 2,
            // Uses reflection to access private APIs of the WebView that can send JS
            // to be executed.
            // Requires Android 3.2.4 or above.
            PRIVATE_API: 3
        },
        jsToNativeBridgeMode,  // Set lazily.
        nativeToJsBridgeMode = nativeToJsModes.ONLINE_EVENT,
        pollEnabled = false,
        messagesFromNative = [];

    function androidExec(success, fail, service, action, args) {
        // Set default bridge modes if they have not already been set.
        // By default, we use the failsafe, since addJavascriptInterface breaks too often
        if (jsToNativeBridgeMode === undefined) {
            androidExec.setJsToNativeBridgeMode(jsToNativeModes.JS_OBJECT);
        }

        // Process any ArrayBuffers in the args into a string.
        for (var i = 0; i < args.length; i++) {
            if (utils.typeName(args[i]) == 'ArrayBuffer') {
                args[i] = window.btoa(String.fromCharCode.apply(null, new Uint8Array(args[i])));
            }
        }

        var callbackId = service + cordova.callbackId++,
            argsJson = JSON.stringify(args),
            returnValue;

        // TODO: Returning the payload of a synchronous call was deprecated in 2.2.0.
        // Remove it after 6 months.
        function captureReturnValue(value) {
            returnValue = value;
            success && success(value);
        }

        cordova.callbacks[callbackId] = {success:captureReturnValue, fail:fail};

        if (jsToNativeBridgeMode == jsToNativeModes.LOCATION_CHANGE) {
            window.location = 'http://cdv_exec/' + service + '#' + action + '#' + callbackId + '#' + argsJson;
        } else {
            var messages = nativeApiProvider.get().exec(service, action, callbackId, argsJson);
            androidExec.processMessages(messages);
        }
        if (cordova.callbacks[callbackId]) {
            if (success || fail) {
                cordova.callbacks[callbackId].success = success;
            } else {
                delete cordova.callbacks[callbackId];
            }
        }
        return returnValue;
    }

    function pollOnce() {
        var msg = nativeApiProvider.get().retrieveJsMessages();
        androidExec.processMessages(msg);
    }

    function pollingTimerFunc() {
        if (pollEnabled) {
            pollOnce();
            setTimeout(pollingTimerFunc, 50);
        }
    }

    function hookOnlineApis() {
        function proxyEvent(e) {
            cordova.fireWindowEvent(e.type);
        }
        // The network module takes care of firing online and offline events.
        // It currently fires them only on document though, so we bridge them
        // to window here (while first listening for exec()-releated online/offline
        // events).
        window.addEventListener('online', pollOnce, false);
        window.addEventListener('offline', pollOnce, false);
        cordova.addWindowEventHandler('online');
        cordova.addWindowEventHandler('offline');
        document.addEventListener('online', proxyEvent, false);
        document.addEventListener('offline', proxyEvent, false);
    }

    hookOnlineApis();

    androidExec.jsToNativeModes = jsToNativeModes;
    androidExec.nativeToJsModes = nativeToJsModes;

    androidExec.setJsToNativeBridgeMode = function(mode) {
        if (mode == jsToNativeModes.JS_OBJECT && !window._cordovaNative) {
            console.log('Falling back on PROMPT mode since _cordovaNative is missing.');
            mode = jsToNativeModes.PROMPT;
        }
        nativeApiProvider.setPreferPrompt(mode == jsToNativeModes.PROMPT);
        jsToNativeBridgeMode = mode;
    };

    androidExec.setNativeToJsBridgeMode = function(mode) {
        if (mode == nativeToJsBridgeMode) {
            return;
        }
        if (nativeToJsBridgeMode == nativeToJsModes.POLLING) {
            pollEnabled = false;
        }

        nativeToJsBridgeMode = mode;
        // Tell the native side to switch modes.
        nativeApiProvider.get().setNativeToJsBridgeMode(mode);

        if (mode == nativeToJsModes.POLLING) {
            pollEnabled = true;
            setTimeout(pollingTimerFunc, 1);
        }
    };

    // Processes a single message, as encoded by NativeToJsMessageQueue.java.
    function processMessage(message) {
        try {
            var firstChar = message.charAt(0);
            if (firstChar == 'J') {
                eval(message.slice(1));
            } else if (firstChar == 'S' || firstChar == 'F') {
                var success = firstChar == 'S';
                var keepCallback = message.charAt(1) == '1';
                var spaceIdx = message.indexOf(' ', 2);
                var status = +message.slice(2, spaceIdx);
                var nextSpaceIdx = message.indexOf(' ', spaceIdx + 1);
                var callbackId = message.slice(spaceIdx + 1, nextSpaceIdx);
                var payloadKind = message.charAt(nextSpaceIdx + 1);
                var payload;
                if (payloadKind == 's') {
                    payload = message.slice(nextSpaceIdx + 2);
                } else if (payloadKind == 't') {
                    payload = true;
                } else if (payloadKind == 'f') {
                    payload = false;
                } else if (payloadKind == 'N') {
                    payload = null;
                } else if (payloadKind == 'n') {
                    payload = +message.slice(nextSpaceIdx + 2);
                } else if (payloadKind == 'A') {
                    var data = message.slice(nextSpaceIdx + 2);
                    var bytes = window.atob(data);
                    var arraybuffer = new Uint8Array(bytes.length);
                    for (var i = 0; i < bytes.length; i++) {
                        arraybuffer[i] = bytes.charCodeAt(i);
                    }
                    payload = arraybuffer.buffer;
                } else {
                    payload = JSON.parse(message.slice(nextSpaceIdx + 1));
                }
                cordova.callbackFromNative(callbackId, success, status, payload, keepCallback);
            } else {
                console.log("processMessage failed: invalid message:" + message);
            }
        } catch (e) {
            console.log("processMessage failed: Message: " + message);
            console.log("processMessage failed: Error: " + e);
            console.log("processMessage failed: Stack: " + e.stack);
        }
    }

    // This is called from the NativeToJsMessageQueue.java.
    androidExec.processMessages = function(messages) {
        if (messages) {
            messagesFromNative.push(messages);
            while (messagesFromNative.length) {
                messages = messagesFromNative.shift();
                // The Java side can send a * message to indicate that it
                // still has messages waiting to be retrieved.
                // TODO(agrieve): This is currently disabled on the Java side
                // since it breaks returning the result in exec of synchronous
                // plugins. Once we remove this ability, we can remove this comment.
                if (messages == '*') {
                    window.setTimeout(pollOnce, 0);
                    continue;
                }

                var spaceIdx = messages.indexOf(' ');
                var msgLen = +messages.slice(0, spaceIdx);
                var message = messages.substr(spaceIdx + 1, msgLen);
                messages = messages.slice(spaceIdx + msgLen + 1);
                // Put the remaining messages back into queue in case an exec()
                // is made by the callback.
                if (messages) {
                    messagesFromNative.unshift(messages);
                }

                if (message) {
                    processMessage(message);
                }
            }
        }
    };

    module.exports = androidExec;

    });

    // file: lib/common/modulemapper.js
    define("cordova/modulemapper", function(require, exports, module) {

    var builder = require('cordova/builder'),
        moduleMap = define.moduleMap,
        symbolList,
        deprecationMap;

    exports.reset = function() {
        symbolList = [];
        deprecationMap = {};
    };

    function addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {
        if (!(moduleName in moduleMap)) {
            throw new Error('Module ' + moduleName + ' does not exist.');
        }
        symbolList.push(strategy, moduleName, symbolPath);
        if (opt_deprecationMessage) {
            deprecationMap[symbolPath] = opt_deprecationMessage;
        }
    }

    // Note: Android 2.3 does have Function.bind().
    exports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('c', moduleName, symbolPath, opt_deprecationMessage);
    };

    exports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('m', moduleName, symbolPath, opt_deprecationMessage);
    };

    exports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('d', moduleName, symbolPath, opt_deprecationMessage);
    };

    function prepareNamespace(symbolPath, context) {
        if (!symbolPath) {
            return context;
        }
        var parts = symbolPath.split('.');
        var cur = context;
        for (var i = 0, part; part = parts[i]; ++i) {
            cur[part] = cur[part] || {};
        }
        return cur[parts[i-1]];
    }

    exports.mapModules = function(context) {
        var origSymbols = {};
        context.CDV_origSymbols = origSymbols;
        for (var i = 0, len = symbolList.length; i < len; i += 3) {
            var strategy = symbolList[i];
            var moduleName = symbolList[i + 1];
            var symbolPath = symbolList[i + 2];
            var lastDot = symbolPath.lastIndexOf('.');
            var namespace = symbolPath.substr(0, lastDot);
            var lastName = symbolPath.substr(lastDot + 1);

            var module = require(moduleName);
            var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;
            var parentObj = prepareNamespace(namespace, context);
            var target = parentObj[lastName];

            if (strategy == 'm' && target) {
                builder.recursiveMerge(target, module);
            } else if ((strategy == 'd' && !target) || (strategy != 'd')) {
                if (target) {
                    origSymbols[symbolPath] = target;
                }
                builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);
            }
        }
    };

    exports.getOriginalSymbol = function(context, symbolPath) {
        var origSymbols = context.CDV_origSymbols;
        if (origSymbols && (symbolPath in origSymbols)) {
            return origSymbols[symbolPath];
        }
        var parts = symbolPath.split('.');
        var obj = context;
        for (var i = 0; i < parts.length; ++i) {
            obj = obj && obj[parts[i]];
        }
        return obj;
    };

    exports.loadMatchingModules = function(matchingRegExp) {
        for (var k in moduleMap) {
            if (matchingRegExp.exec(k)) {
                require(k);
            }
        }
    };

    exports.reset();


    });

    // file: lib/android/platform.js
    define("cordova/platform", function(require, exports, module) {

    module.exports = {
        id: "android",
        initialize:function() {
            var channel = require("cordova/channel"),
                cordova = require('cordova'),
                exec = require('cordova/exec'),
                modulemapper = require('cordova/modulemapper');

            modulemapper.loadMatchingModules(/cordova.*\/symbols$/);
            modulemapper.mapModules(window);

            // Inject a listener for the backbutton on the document.
            var backButtonChannel = cordova.addDocumentEventHandler('backbutton');
            backButtonChannel.onHasSubscribersChange = function() {
                // If we just attached the first handler or detached the last handler,
                // let native know we need to override the back button.
                exec(null, null, "App", "overrideBackbutton", [this.numHandlers == 1]);
            };

            // Add hardware MENU and SEARCH button handlers
            cordova.addDocumentEventHandler('menubutton');
            cordova.addDocumentEventHandler('searchbutton');

            // Figure out if we need to shim-in localStorage and WebSQL
            // support from the native side.
            var storage = require('cordova/plugin/android/storage');

            // First patch WebSQL if necessary
            if (typeof window.openDatabase == 'undefined') {
                // Not defined, create an openDatabase function for all to use!
                window.openDatabase = storage.openDatabase;
            } else {
                // Defined, but some Android devices will throw a SECURITY_ERR -
                // so we wrap the whole thing in a try-catch and shim in our own
                // if the device has Android bug 16175.
                var originalOpenDatabase = window.openDatabase;
                window.openDatabase = function(name, version, desc, size) {
                    var db = null;
                    try {
                        db = originalOpenDatabase(name, version, desc, size);
                    }
                    catch (ex) {
                        if (ex.code === 18) {
                            db = null;
                        } else {
                            throw ex;
                        }
                    }

                    if (db === null) {
                        return storage.openDatabase(name, version, desc, size);
                    }
                    else {
                        return db;
                    }

                };
            }

            // Patch localStorage if necessary
            if (typeof window.localStorage == 'undefined' || window.localStorage === null) {
                window.localStorage = new storage.CupcakeLocalStorage();
            }

            // Let native code know we are all done on the JS side.
            // Native code will then un-hide the WebView.
            channel.join(function() {
                exec(null, null, "App", "show", []);
            }, [channel.onCordovaReady]);
        },
        clobbers: {
            navigator: {
                children: {
                    app:{
                        path: "cordova/plugin/android/app"
                    }
                }
            },
            File: { // exists natively on Android WebView, override
                path: "cordova/plugin/File"
            },
            FileReader: { // exists natively on Android WebView, override
                path: "cordova/plugin/FileReader"
            },
            FileError: { //exists natively on Android WebView on Android 4.x
                path: "cordova/plugin/FileError"
            },
            MediaError: { // exists natively on Android WebView on Android 4.x
                path: "cordova/plugin/MediaError"
            },
            open: {
                path: "cordova/plugin/InAppBrowser"
            }
        },
        merges: {
            device: {
                path: 'cordova/plugin/android/device'
            },
            navigator: {
                children: {
                    notification: {
                        path: 'cordova/plugin/android/notification'
                    }
                }
            }
        }
    };

    });

    // file: lib/common/plugin/Acceleration.js
    define("cordova/plugin/Acceleration", function(require, exports, module) {

    var Acceleration = function(x, y, z, timestamp) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.timestamp = timestamp || (new Date()).getTime();
    };

    module.exports = Acceleration;

    });

    // file: lib/common/plugin/Camera.js
    define("cordova/plugin/Camera", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        Camera = require('cordova/plugin/CameraConstants');

    var cameraExport = {};

    // Tack on the Camera Constants to the base camera plugin.
    for (var key in Camera) {
        cameraExport[key] = Camera[key];
    }

    /**
     * Gets a picture from source defined by "options.sourceType", and returns the
     * image as defined by the "options.destinationType" option.

     * The defaults are sourceType=CAMERA and destinationType=FILE_URI.
     *
     * @param {Function} successCallback
     * @param {Function} errorCallback
     * @param {Object} options
     */
    cameraExport.getPicture = function(successCallback, errorCallback, options) {
        argscheck.checkArgs('fFO', 'Camera.getPicture', arguments);
        options = options || {};
        var getValue = argscheck.getValue;

        var quality = getValue(options.quality, 50);
        var destinationType = getValue(options.destinationType, Camera.DestinationType.FILE_URI);
        var sourceType = getValue(options.sourceType, Camera.PictureSourceType.CAMERA);
        var targetWidth = getValue(options.targetWidth, -1);
        var targetHeight = getValue(options.targetHeight, -1);
        var encodingType = getValue(options.encodingType, Camera.EncodingType.JPEG);
        var mediaType = getValue(options.mediaType, Camera.MediaType.PICTURE);
        var allowEdit = !!options.allowEdit;
        var correctOrientation = !!options.correctOrientation;
        var saveToPhotoAlbum = !!options.saveToPhotoAlbum;
        var popoverOptions = getValue(options.popoverOptions, null);

        var args = [quality, destinationType, sourceType, targetWidth, targetHeight, encodingType,
                    mediaType, allowEdit, correctOrientation, saveToPhotoAlbum, popoverOptions];

        exec(successCallback, errorCallback, "Camera", "takePicture", args);
    };

    cameraExport.cleanup = function(successCallback, errorCallback) {
        exec(successCallback, errorCallback, "Camera", "cleanup", []);
    };

    module.exports = cameraExport;

    });

    // file: lib/common/plugin/CameraConstants.js
    define("cordova/plugin/CameraConstants", function(require, exports, module) {

    module.exports = {
      DestinationType:{
        DATA_URL: 0,         // Return base64 encoded string
        FILE_URI: 1,         // Return file uri (content://media/external/images/media/2 for Android)
        NATIVE_URI: 2        // Return native uri (eg. asset-library://... for iOS)
      },
      EncodingType:{
        JPEG: 0,             // Return JPEG encoded image
        PNG: 1               // Return PNG encoded image
      },
      MediaType:{
        PICTURE: 0,          // allow selection of still pictures only. DEFAULT. Will return format specified via DestinationType
        VIDEO: 1,            // allow selection of video only, ONLY RETURNS URL
        ALLMEDIA : 2         // allow selection from all media types
      },
      PictureSourceType:{
        PHOTOLIBRARY : 0,    // Choose image from picture library (same as SAVEDPHOTOALBUM for Android)
        CAMERA : 1,          // Take picture from camera
        SAVEDPHOTOALBUM : 2  // Choose image from picture library (same as PHOTOLIBRARY for Android)
      },
      PopoverArrowDirection:{
          ARROW_UP : 1,        // matches iOS UIPopoverArrowDirection constants to specify arrow location on popover
          ARROW_DOWN : 2,
          ARROW_LEFT : 4,
          ARROW_RIGHT : 8,
          ARROW_ANY : 15
      }
    };

    });

    // file: lib/common/plugin/CameraPopoverOptions.js
    define("cordova/plugin/CameraPopoverOptions", function(require, exports, module) {

    var Camera = require('cordova/plugin/CameraConstants');

    /**
     * Encapsulates options for iOS Popover image picker
     */
    var CameraPopoverOptions = function(x,y,width,height,arrowDir){
        // information of rectangle that popover should be anchored to
        this.x = x || 0;
        this.y = y || 32;
        this.width = width || 320;
        this.height = height || 480;
        // The direction of the popover arrow
        this.arrowDir = arrowDir || Camera.PopoverArrowDirection.ARROW_ANY;
    };

    module.exports = CameraPopoverOptions;

    });

    // file: lib/common/plugin/CaptureAudioOptions.js
    define("cordova/plugin/CaptureAudioOptions", function(require, exports, module) {

    /**
     * Encapsulates all audio capture operation configuration options.
     */
    var CaptureAudioOptions = function(){
        // Upper limit of sound clips user can record. Value must be equal or greater than 1.
        this.limit = 1;
        // Maximum duration of a single sound clip in seconds.
        this.duration = 0;
        // The selected audio mode. Must match with one of the elements in supportedAudioModes array.
        this.mode = null;
    };

    module.exports = CaptureAudioOptions;

    });

    // file: lib/common/plugin/CaptureError.js
    define("cordova/plugin/CaptureError", function(require, exports, module) {

    /**
     * The CaptureError interface encapsulates all errors in the Capture API.
     */
    var CaptureError = function(c) {
       this.code = c || null;
    };

    // Camera or microphone failed to capture image or sound.
    CaptureError.CAPTURE_INTERNAL_ERR = 0;
    // Camera application or audio capture application is currently serving other capture request.
    CaptureError.CAPTURE_APPLICATION_BUSY = 1;
    // Invalid use of the API (e.g. limit parameter has value less than one).
    CaptureError.CAPTURE_INVALID_ARGUMENT = 2;
    // User exited camera application or audio capture application before capturing anything.
    CaptureError.CAPTURE_NO_MEDIA_FILES = 3;
    // The requested capture operation is not supported.
    CaptureError.CAPTURE_NOT_SUPPORTED = 20;

    module.exports = CaptureError;

    });

    // file: lib/common/plugin/CaptureImageOptions.js
    define("cordova/plugin/CaptureImageOptions", function(require, exports, module) {

    /**
     * Encapsulates all image capture operation configuration options.
     */
    var CaptureImageOptions = function(){
        // Upper limit of images user can take. Value must be equal or greater than 1.
        this.limit = 1;
        // The selected image mode. Must match with one of the elements in supportedImageModes array.
        this.mode = null;
    };

    module.exports = CaptureImageOptions;

    });

    // file: lib/common/plugin/CaptureVideoOptions.js
    define("cordova/plugin/CaptureVideoOptions", function(require, exports, module) {

    /**
     * Encapsulates all video capture operation configuration options.
     */
    var CaptureVideoOptions = function(){
        // Upper limit of videos user can record. Value must be equal or greater than 1.
        this.limit = 1;
        // Maximum duration of a single video clip in seconds.
        this.duration = 0;
        // The selected video mode. Must match with one of the elements in supportedVideoModes array.
        this.mode = null;
    };

    module.exports = CaptureVideoOptions;

    });

    // file: lib/common/plugin/CompassError.js
    define("cordova/plugin/CompassError", function(require, exports, module) {

    /**
     *  CompassError.
     *  An error code assigned by an implementation when an error has occurred
     * @constructor
     */
    var CompassError = function(err) {
        this.code = (err !== undefined ? err : null);
    };

    CompassError.COMPASS_INTERNAL_ERR = 0;
    CompassError.COMPASS_NOT_SUPPORTED = 20;

    module.exports = CompassError;

    });

    // file: lib/common/plugin/CompassHeading.js
    define("cordova/plugin/CompassHeading", function(require, exports, module) {

    var CompassHeading = function(magneticHeading, trueHeading, headingAccuracy, timestamp) {
      this.magneticHeading = magneticHeading || null;
      this.trueHeading = trueHeading || null;
      this.headingAccuracy = headingAccuracy || null;
      this.timestamp = timestamp || new Date().getTime();
    };

    module.exports = CompassHeading;

    });

    // file: lib/common/plugin/ConfigurationData.js
    define("cordova/plugin/ConfigurationData", function(require, exports, module) {

    /**
     * Encapsulates a set of parameters that the capture device supports.
     */
    function ConfigurationData() {
        // The ASCII-encoded string in lower case representing the media type.
        this.type = null;
        // The height attribute represents height of the image or video in pixels.
        // In the case of a sound clip this attribute has value 0.
        this.height = 0;
        // The width attribute represents width of the image or video in pixels.
        // In the case of a sound clip this attribute has value 0
        this.width = 0;
    }

    module.exports = ConfigurationData;

    });

    // file: lib/common/plugin/Connection.js
    define("cordova/plugin/Connection", function(require, exports, module) {

    /**
     * Network status
     */
    module.exports = {
            UNKNOWN: "unknown",
            ETHERNET: "ethernet",
            WIFI: "wifi",
            CELL_2G: "2g",
            CELL_3G: "3g",
            CELL_4G: "4g",
            NONE: "none"
    };

    });

    // file: lib/common/plugin/Contact.js
    define("cordova/plugin/Contact", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        ContactError = require('cordova/plugin/ContactError'),
        utils = require('cordova/utils');

    /**
    * Converts primitives into Complex Object
    * Currently only used for Date fields
    */
    function convertIn(contact) {
        var value = contact.birthday;
        try {
          contact.birthday = new Date(parseFloat(value));
        } catch (exception){
          console.log("Cordova Contact convertIn error: exception creating date.");
        }
        return contact;
    }

    /**
    * Converts Complex objects into primitives
    * Only conversion at present is for Dates.
    **/

    function convertOut(contact) {
        var value = contact.birthday;
        if (value !== null) {
            // try to make it a Date object if it is not already
            if (!utils.isDate(value)){
                try {
                    value = new Date(value);
                } catch(exception){
                    value = null;
                }
            }
            if (utils.isDate(value)){
                value = value.valueOf(); // convert to milliseconds
            }
            contact.birthday = value;
        }
        return contact;
    }

    /**
    * Contains information about a single contact.
    * @constructor
    * @param {DOMString} id unique identifier
    * @param {DOMString} displayName
    * @param {ContactName} name
    * @param {DOMString} nickname
    * @param {Array.<ContactField>} phoneNumbers array of phone numbers
    * @param {Array.<ContactField>} emails array of email addresses
    * @param {Array.<ContactAddress>} addresses array of addresses
    * @param {Array.<ContactField>} ims instant messaging user ids
    * @param {Array.<ContactOrganization>} organizations
    * @param {DOMString} birthday contact's birthday
    * @param {DOMString} note user notes about contact
    * @param {Array.<ContactField>} photos
    * @param {Array.<ContactField>} categories
    * @param {Array.<ContactField>} urls contact's web sites
    */
    var Contact = function (id, displayName, name, nickname, phoneNumbers, emails, addresses,
        ims, organizations, birthday, note, photos, categories, urls) {
        this.id = id || null;
        this.rawId = null;
        this.displayName = displayName || null;
        this.name = name || null; // ContactName
        this.nickname = nickname || null;
        this.phoneNumbers = phoneNumbers || null; // ContactField[]
        this.emails = emails || null; // ContactField[]
        this.addresses = addresses || null; // ContactAddress[]
        this.ims = ims || null; // ContactField[]
        this.organizations = organizations || null; // ContactOrganization[]
        this.birthday = birthday || null;
        this.note = note || null;
        this.photos = photos || null; // ContactField[]
        this.categories = categories || null; // ContactField[]
        this.urls = urls || null; // ContactField[]
    };

    /**
    * Removes contact from device storage.
    * @param successCB success callback
    * @param errorCB error callback
    */
    Contact.prototype.remove = function(successCB, errorCB) {
        argscheck.checkArgs('FF', 'Contact.remove', arguments);
        var fail = errorCB && function(code) {
            errorCB(new ContactError(code));
        };
        if (this.id === null) {
            fail(ContactError.UNKNOWN_ERROR);
        }
        else {
            exec(successCB, fail, "Contacts", "remove", [this.id]);
        }
    };

    /**
    * Creates a deep copy of this Contact.
    * With the contact ID set to null.
    * @return copy of this Contact
    */
    Contact.prototype.clone = function() {
        var clonedContact = utils.clone(this);
        clonedContact.id = null;
        clonedContact.rawId = null;

        function nullIds(arr) {
            if (arr) {
                for (var i = 0; i < arr.length; ++i) {
                    arr[i].id = null;
                }
            }
        }

        // Loop through and clear out any id's in phones, emails, etc.
        nullIds(clonedContact.phoneNumbers);
        nullIds(clonedContact.emails);
        nullIds(clonedContact.addresses);
        nullIds(clonedContact.ims);
        nullIds(clonedContact.organizations);
        nullIds(clonedContact.categories);
        nullIds(clonedContact.photos);
        nullIds(clonedContact.urls);
        return clonedContact;
    };

    /**
    * Persists contact to device storage.
    * @param successCB success callback
    * @param errorCB error callback
    */
    Contact.prototype.save = function(successCB, errorCB) {
        argscheck.checkArgs('FFO', 'Contact.save', arguments);
        var fail = errorCB && function(code) {
            errorCB(new ContactError(code));
        };
        var success = function(result) {
            if (result) {
                if (successCB) {
                    var fullContact = require('cordova/plugin/contacts').create(result);
                    successCB(convertIn(fullContact));
                }
            }
            else {
                // no Entry object returned
                fail(ContactError.UNKNOWN_ERROR);
            }
        };
        var dupContact = convertOut(utils.clone(this));
        exec(success, fail, "Contacts", "save", [dupContact]);
    };


    module.exports = Contact;

    });

    // file: lib/common/plugin/ContactAddress.js
    define("cordova/plugin/ContactAddress", function(require, exports, module) {

    /**
    * Contact address.
    * @constructor
    * @param {DOMString} id unique identifier, should only be set by native code
    * @param formatted // NOTE: not a W3C standard
    * @param streetAddress
    * @param locality
    * @param region
    * @param postalCode
    * @param country
    */

    var ContactAddress = function(pref, type, formatted, streetAddress, locality, region, postalCode, country) {
        this.id = null;
        this.pref = (typeof pref != 'undefined' ? pref : false);
        this.type = type || null;
        this.formatted = formatted || null;
        this.streetAddress = streetAddress || null;
        this.locality = locality || null;
        this.region = region || null;
        this.postalCode = postalCode || null;
        this.country = country || null;
    };

    module.exports = ContactAddress;

    });

    // file: lib/common/plugin/ContactError.js
    define("cordova/plugin/ContactError", function(require, exports, module) {

    /**
     *  ContactError.
     *  An error code assigned by an implementation when an error has occurred
     * @constructor
     */
    var ContactError = function(err) {
        this.code = (typeof err != 'undefined' ? err : null);
    };

    /**
     * Error codes
     */
    ContactError.UNKNOWN_ERROR = 0;
    ContactError.INVALID_ARGUMENT_ERROR = 1;
    ContactError.TIMEOUT_ERROR = 2;
    ContactError.PENDING_OPERATION_ERROR = 3;
    ContactError.IO_ERROR = 4;
    ContactError.NOT_SUPPORTED_ERROR = 5;
    ContactError.PERMISSION_DENIED_ERROR = 20;

    module.exports = ContactError;

    });

    // file: lib/common/plugin/ContactField.js
    define("cordova/plugin/ContactField", function(require, exports, module) {

    /**
    * Generic contact field.
    * @constructor
    * @param {DOMString} id unique identifier, should only be set by native code // NOTE: not a W3C standard
    * @param type
    * @param value
    * @param pref
    */
    var ContactField = function(type, value, pref) {
        this.id = null;
        this.type = (type && type.toString()) || null;
        this.value = (value && value.toString()) || null;
        this.pref = (typeof pref != 'undefined' ? pref : false);
    };

    module.exports = ContactField;

    });

    // file: lib/common/plugin/ContactFindOptions.js
    define("cordova/plugin/ContactFindOptions", function(require, exports, module) {

    /**
     * ContactFindOptions.
     * @constructor
     * @param filter used to match contacts against
     * @param multiple boolean used to determine if more than one contact should be returned
     */

    var ContactFindOptions = function(filter, multiple) {
        this.filter = filter || '';
        this.multiple = (typeof multiple != 'undefined' ? multiple : false);
    };

    module.exports = ContactFindOptions;

    });

    // file: lib/common/plugin/ContactName.js
    define("cordova/plugin/ContactName", function(require, exports, module) {

    /**
    * Contact name.
    * @constructor
    * @param formatted // NOTE: not part of W3C standard
    * @param familyName
    * @param givenName
    * @param middle
    * @param prefix
    * @param suffix
    */
    var ContactName = function(formatted, familyName, givenName, middle, prefix, suffix) {
        this.formatted = formatted || null;
        this.familyName = familyName || null;
        this.givenName = givenName || null;
        this.middleName = middle || null;
        this.honorificPrefix = prefix || null;
        this.honorificSuffix = suffix || null;
    };

    module.exports = ContactName;

    });

    // file: lib/common/plugin/ContactOrganization.js
    define("cordova/plugin/ContactOrganization", function(require, exports, module) {

    /**
    * Contact organization.
    * @constructor
    * @param {DOMString} id unique identifier, should only be set by native code // NOTE: not a W3C standard
    * @param name
    * @param dept
    * @param title
    * @param startDate
    * @param endDate
    * @param location
    * @param desc
    */

    var ContactOrganization = function(pref, type, name, dept, title) {
        this.id = null;
        this.pref = (typeof pref != 'undefined' ? pref : false);
        this.type = type || null;
        this.name = name || null;
        this.department = dept || null;
        this.title = title || null;
    };

    module.exports = ContactOrganization;

    });

    // file: lib/common/plugin/Coordinates.js
    define("cordova/plugin/Coordinates", function(require, exports, module) {

    /**
     * This class contains position information.
     * @param {Object} lat
     * @param {Object} lng
     * @param {Object} alt
     * @param {Object} acc
     * @param {Object} head
     * @param {Object} vel
     * @param {Object} altacc
     * @constructor
     */
    var Coordinates = function(lat, lng, alt, acc, head, vel, altacc) {
        /**
         * The latitude of the position.
         */
        this.latitude = lat;
        /**
         * The longitude of the position,
         */
        this.longitude = lng;
        /**
         * The accuracy of the position.
         */
        this.accuracy = acc;
        /**
         * The altitude of the position.
         */
        this.altitude = (alt !== undefined ? alt : null);
        /**
         * The direction the device is moving at the position.
         */
        this.heading = (head !== undefined ? head : null);
        /**
         * The velocity with which the device is moving at the position.
         */
        this.speed = (vel !== undefined ? vel : null);

        if (this.speed === 0 || this.speed === null) {
            this.heading = NaN;
        }

        /**
         * The altitude accuracy of the position.
         */
        this.altitudeAccuracy = (altacc !== undefined) ? altacc : null;
    };

    module.exports = Coordinates;

    });

    // file: lib/common/plugin/DirectoryEntry.js
    define("cordova/plugin/DirectoryEntry", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        Entry = require('cordova/plugin/Entry'),
        FileError = require('cordova/plugin/FileError'),
        DirectoryReader = require('cordova/plugin/DirectoryReader');

    /**
     * An interface representing a directory on the file system.
     *
     * {boolean} isFile always false (readonly)
     * {boolean} isDirectory always true (readonly)
     * {DOMString} name of the directory, excluding the path leading to it (readonly)
     * {DOMString} fullPath the absolute full path to the directory (readonly)
     * TODO: implement this!!! {FileSystem} filesystem on which the directory resides (readonly)
     */
    var DirectoryEntry = function(name, fullPath) {
         DirectoryEntry.__super__.constructor.call(this, false, true, name, fullPath);
    };

    utils.extend(DirectoryEntry, Entry);

    /**
     * Creates a new DirectoryReader to read entries from this directory
     */
    DirectoryEntry.prototype.createReader = function() {
        return new DirectoryReader(this.fullPath);
    };

    /**
     * Creates or looks up a directory
     *
     * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a directory
     * @param {Flags} options to create or exclusively create the directory
     * @param {Function} successCallback is called with the new entry
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryEntry.prototype.getDirectory = function(path, options, successCallback, errorCallback) {
        argscheck.checkArgs('sOFF', 'DirectoryEntry.getDirectory', arguments);
        var win = successCallback && function(result) {
            var entry = new DirectoryEntry(result.name, result.fullPath);
            successCallback(entry);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getDirectory", [this.fullPath, path, options]);
    };

    /**
     * Deletes a directory and all of it's contents
     *
     * @param {Function} successCallback is called with no parameters
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryEntry.prototype.removeRecursively = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'DirectoryEntry.removeRecursively', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(successCallback, fail, "File", "removeRecursively", [this.fullPath]);
    };

    /**
     * Creates or looks up a file
     *
     * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a file
     * @param {Flags} options to create or exclusively create the file
     * @param {Function} successCallback is called with the new entry
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryEntry.prototype.getFile = function(path, options, successCallback, errorCallback) {
        argscheck.checkArgs('sOFF', 'DirectoryEntry.getFile', arguments);
        var win = successCallback && function(result) {
            var FileEntry = require('cordova/plugin/FileEntry');
            var entry = new FileEntry(result.name, result.fullPath);
            successCallback(entry);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getFile", [this.fullPath, path, options]);
    };

    module.exports = DirectoryEntry;

    });

    // file: lib/common/plugin/DirectoryReader.js
    define("cordova/plugin/DirectoryReader", function(require, exports, module) {

    var exec = require('cordova/exec'),
        FileError = require('cordova/plugin/FileError') ;

    /**
     * An interface that lists the files and directories in a directory.
     */
    function DirectoryReader(path) {
        this.path = path || null;
    }

    /**
     * Returns a list of entries from a directory.
     *
     * @param {Function} successCallback is called with a list of entries
     * @param {Function} errorCallback is called with a FileError
     */
    DirectoryReader.prototype.readEntries = function(successCallback, errorCallback) {
        var win = typeof successCallback !== 'function' ? null : function(result) {
            var retVal = [];
            for (var i=0; i<result.length; i++) {
                var entry = null;
                if (result[i].isDirectory) {
                    entry = new (require('cordova/plugin/DirectoryEntry'))();
                }
                else if (result[i].isFile) {
                    entry = new (require('cordova/plugin/FileEntry'))();
                }
                entry.isDirectory = result[i].isDirectory;
                entry.isFile = result[i].isFile;
                entry.name = result[i].name;
                entry.fullPath = result[i].fullPath;
                retVal.push(entry);
            }
            successCallback(retVal);
        };
        var fail = typeof errorCallback !== 'function' ? null : function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "readEntries", [this.path]);
    };

    module.exports = DirectoryReader;

    });

    // file: lib/common/plugin/Entry.js
    define("cordova/plugin/Entry", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        FileError = require('cordova/plugin/FileError'),
        Metadata = require('cordova/plugin/Metadata');

    /**
     * Represents a file or directory on the local file system.
     *
     * @param isFile
     *            {boolean} true if Entry is a file (readonly)
     * @param isDirectory
     *            {boolean} true if Entry is a directory (readonly)
     * @param name
     *            {DOMString} name of the file or directory, excluding the path
     *            leading to it (readonly)
     * @param fullPath
     *            {DOMString} the absolute full path to the file or directory
     *            (readonly)
     */
    function Entry(isFile, isDirectory, name, fullPath, fileSystem) {
        this.isFile = !!isFile;
        this.isDirectory = !!isDirectory;
        this.name = name || '';
        this.fullPath = fullPath || '';
        this.filesystem = fileSystem || null;
    }

    /**
     * Look up the metadata of the entry.
     *
     * @param successCallback
     *            {Function} is called with a Metadata object
     * @param errorCallback
     *            {Function} is called with a FileError
     */
    Entry.prototype.getMetadata = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'Entry.getMetadata', arguments);
        var success = successCallback && function(lastModified) {
            var metadata = new Metadata(lastModified);
            successCallback(metadata);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };

        exec(success, fail, "File", "getMetadata", [this.fullPath]);
    };

    /**
     * Set the metadata of the entry.
     *
     * @param successCallback
     *            {Function} is called with a Metadata object
     * @param errorCallback
     *            {Function} is called with a FileError
     * @param metadataObject
     *            {Object} keys and values to set
     */
    Entry.prototype.setMetadata = function(successCallback, errorCallback, metadataObject) {
        argscheck.checkArgs('FFO', 'Entry.setMetadata', arguments);
        exec(successCallback, errorCallback, "File", "setMetadata", [this.fullPath, metadataObject]);
    };

    /**
     * Move a file or directory to a new location.
     *
     * @param parent
     *            {DirectoryEntry} the directory to which to move this entry
     * @param newName
     *            {DOMString} new name of the entry, defaults to the current name
     * @param successCallback
     *            {Function} called with the new DirectoryEntry object
     * @param errorCallback
     *            {Function} called with a FileError
     */
    Entry.prototype.moveTo = function(parent, newName, successCallback, errorCallback) {
        argscheck.checkArgs('oSFF', 'Entry.moveTo', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        // source path
        var srcPath = this.fullPath,
            // entry name
            name = newName || this.name,
            success = function(entry) {
                if (entry) {
                    if (successCallback) {
                        // create appropriate Entry object
                        var result = (entry.isDirectory) ? new (require('cordova/plugin/DirectoryEntry'))(entry.name, entry.fullPath) : new (require('cordova/plugin/FileEntry'))(entry.name, entry.fullPath);
                        successCallback(result);
                    }
                }
                else {
                    // no Entry object returned
                    fail && fail(FileError.NOT_FOUND_ERR);
                }
            };

        // copy
        exec(success, fail, "File", "moveTo", [srcPath, parent.fullPath, name]);
    };

    /**
     * Copy a directory to a different location.
     *
     * @param parent
     *            {DirectoryEntry} the directory to which to copy the entry
     * @param newName
     *            {DOMString} new name of the entry, defaults to the current name
     * @param successCallback
     *            {Function} called with the new Entry object
     * @param errorCallback
     *            {Function} called with a FileError
     */
    Entry.prototype.copyTo = function(parent, newName, successCallback, errorCallback) {
        argscheck.checkArgs('oSFF', 'Entry.copyTo', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };

            // source path
        var srcPath = this.fullPath,
            // entry name
            name = newName || this.name,
            // success callback
            success = function(entry) {
                if (entry) {
                    if (successCallback) {
                        // create appropriate Entry object
                        var result = (entry.isDirectory) ? new (require('cordova/plugin/DirectoryEntry'))(entry.name, entry.fullPath) : new (require('cordova/plugin/FileEntry'))(entry.name, entry.fullPath);
                        successCallback(result);
                    }
                }
                else {
                    // no Entry object returned
                    fail && fail(FileError.NOT_FOUND_ERR);
                }
            };

        // copy
        exec(success, fail, "File", "copyTo", [srcPath, parent.fullPath, name]);
    };

    /**
     * Return a URL that can be used to identify this entry.
     */
    Entry.prototype.toURL = function() {
        // fullPath attribute contains the full URL
        return this.fullPath;
    };

    /**
     * Returns a URI that can be used to identify this entry.
     *
     * @param {DOMString} mimeType for a FileEntry, the mime type to be used to interpret the file, when loaded through this URI.
     * @return uri
     */
    Entry.prototype.toURI = function(mimeType) {
        console.log("DEPRECATED: Update your code to use 'toURL'");
        // fullPath attribute contains the full URI
        return this.toURL();
    };

    /**
     * Remove a file or directory. It is an error to attempt to delete a
     * directory that is not empty. It is an error to attempt to delete a
     * root directory of a file system.
     *
     * @param successCallback {Function} called with no parameters
     * @param errorCallback {Function} called with a FileError
     */
    Entry.prototype.remove = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'Entry.remove', arguments);
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(successCallback, fail, "File", "remove", [this.fullPath]);
    };

    /**
     * Look up the parent DirectoryEntry of this entry.
     *
     * @param successCallback {Function} called with the parent DirectoryEntry object
     * @param errorCallback {Function} called with a FileError
     */
    Entry.prototype.getParent = function(successCallback, errorCallback) {
        argscheck.checkArgs('FF', 'Entry.getParent', arguments);
        var win = successCallback && function(result) {
            var DirectoryEntry = require('cordova/plugin/DirectoryEntry');
            var entry = new DirectoryEntry(result.name, result.fullPath);
            successCallback(entry);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getParent", [this.fullPath]);
    };

    module.exports = Entry;

    });

    // file: lib/common/plugin/File.js
    define("cordova/plugin/File", function(require, exports, module) {

    /**
     * Constructor.
     * name {DOMString} name of the file, without path information
     * fullPath {DOMString} the full path of the file, including the name
     * type {DOMString} mime type
     * lastModifiedDate {Date} last modified date
     * size {Number} size of the file in bytes
     */

    var File = function(name, fullPath, type, lastModifiedDate, size){
        this.name = name || '';
        this.fullPath = fullPath || null;
        this.type = type || null;
        this.lastModifiedDate = lastModifiedDate || null;
        this.size = size || 0;

        // These store the absolute start and end for slicing the file.
        this.start = 0;
        this.end = this.size;
    };

    /**
     * Returns a "slice" of the file. Since Cordova Files don't contain the actual
     * content, this really returns a File with adjusted start and end.
     * Slices of slices are supported.
     * start {Number} The index at which to start the slice (inclusive).
     * end {Number} The index at which to end the slice (exclusive).
     */
    File.prototype.slice = function(start, end) {
        var size = this.end - this.start;
        var newStart = 0;
        var newEnd = size;
        if (arguments.length) {
            if (start < 0) {
                newStart = Math.max(size + start, 0);
            } else {
                newStart = Math.min(size, start);
            }
        }

        if (arguments.length >= 2) {
            if (end < 0) {
                newEnd = Math.max(size + end, 0);
            } else {
                newEnd = Math.min(end, size);
            }
        }

        var newFile = new File(this.name, this.fullPath, this.type, this.lastModifiedData, this.size);
        newFile.start = this.start + newStart;
        newFile.end = this.start + newEnd;
        return newFile;
    };


    module.exports = File;

    });

    // file: lib/common/plugin/FileEntry.js
    define("cordova/plugin/FileEntry", function(require, exports, module) {

    var utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        Entry = require('cordova/plugin/Entry'),
        FileWriter = require('cordova/plugin/FileWriter'),
        File = require('cordova/plugin/File'),
        FileError = require('cordova/plugin/FileError');

    /**
     * An interface representing a file on the file system.
     *
     * {boolean} isFile always true (readonly)
     * {boolean} isDirectory always false (readonly)
     * {DOMString} name of the file, excluding the path leading to it (readonly)
     * {DOMString} fullPath the absolute full path to the file (readonly)
     * {FileSystem} filesystem on which the file resides (readonly)
     */
    var FileEntry = function(name, fullPath) {
         FileEntry.__super__.constructor.apply(this, [true, false, name, fullPath]);
    };

    utils.extend(FileEntry, Entry);

    /**
     * Creates a new FileWriter associated with the file that this FileEntry represents.
     *
     * @param {Function} successCallback is called with the new FileWriter
     * @param {Function} errorCallback is called with a FileError
     */
    FileEntry.prototype.createWriter = function(successCallback, errorCallback) {
        this.file(function(filePointer) {
            var writer = new FileWriter(filePointer);

            if (writer.fileName === null || writer.fileName === "") {
                errorCallback && errorCallback(new FileError(FileError.INVALID_STATE_ERR));
            } else {
                successCallback && successCallback(writer);
            }
        }, errorCallback);
    };

    /**
     * Returns a File that represents the current state of the file that this FileEntry represents.
     *
     * @param {Function} successCallback is called with the new File object
     * @param {Function} errorCallback is called with a FileError
     */
    FileEntry.prototype.file = function(successCallback, errorCallback) {
        var win = successCallback && function(f) {
            var file = new File(f.name, f.fullPath, f.type, f.lastModifiedDate, f.size);
            successCallback(file);
        };
        var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
        };
        exec(win, fail, "File", "getFileMetadata", [this.fullPath]);
    };


    module.exports = FileEntry;

    });

    // file: lib/common/plugin/FileError.js
    define("cordova/plugin/FileError", function(require, exports, module) {

    /**
     * FileError
     */
    function FileError(error) {
      this.code = error || null;
    }

    // File error codes
    // Found in DOMException
    FileError.NOT_FOUND_ERR = 1;
    FileError.SECURITY_ERR = 2;
    FileError.ABORT_ERR = 3;

    // Added by File API specification
    FileError.NOT_READABLE_ERR = 4;
    FileError.ENCODING_ERR = 5;
    FileError.NO_MODIFICATION_ALLOWED_ERR = 6;
    FileError.INVALID_STATE_ERR = 7;
    FileError.SYNTAX_ERR = 8;
    FileError.INVALID_MODIFICATION_ERR = 9;
    FileError.QUOTA_EXCEEDED_ERR = 10;
    FileError.TYPE_MISMATCH_ERR = 11;
    FileError.PATH_EXISTS_ERR = 12;

    module.exports = FileError;

    });

    // file: lib/common/plugin/FileReader.js
    define("cordova/plugin/FileReader", function(require, exports, module) {

    var exec = require('cordova/exec'),
        modulemapper = require('cordova/modulemapper'),
        utils = require('cordova/utils'),
        File = require('cordova/plugin/File'),
        FileError = require('cordova/plugin/FileError'),
        ProgressEvent = require('cordova/plugin/ProgressEvent'),
        origFileReader = modulemapper.getOriginalSymbol(this, 'FileReader');

    /**
     * This class reads the mobile device file system.
     *
     * For Android:
     *      The root directory is the root of the file system.
     *      To read from the SD card, the file name is "sdcard/my_file.txt"
     * @constructor
     */
    var FileReader = function() {
        this._readyState = 0;
        this._error = null;
        this._result = null;
        this._fileName = '';
        this._realReader = origFileReader ? new origFileReader() : {};
    };

    // States
    FileReader.EMPTY = 0;
    FileReader.LOADING = 1;
    FileReader.DONE = 2;

    utils.defineGetter(FileReader.prototype, 'readyState', function() {
        return this._fileName ? this._readyState : this._realReader.readyState;
    });

    utils.defineGetter(FileReader.prototype, 'error', function() {
        return this._fileName ? this._error: this._realReader.error;
    });

    utils.defineGetter(FileReader.prototype, 'result', function() {
        return this._fileName ? this._result: this._realReader.result;
    });

    function defineEvent(eventName) {
        utils.defineGetterSetter(FileReader.prototype, eventName, function() {
            return this._realReader[eventName] || null;
        }, function(value) {
            this._realReader[eventName] = value;
        });
    }
    defineEvent('onloadstart');    // When the read starts.
    defineEvent('onprogress');     // While reading (and decoding) file or fileBlob data, and reporting partial file data (progress.loaded/progress.total)
    defineEvent('onload');         // When the read has successfully completed.
    defineEvent('onerror');        // When the read has failed (see errors).
    defineEvent('onloadend');      // When the request has completed (either in success or failure).
    defineEvent('onabort');        // When the read has been aborted. For instance, by invoking the abort() method.

    function initRead(reader, file) {
        // Already loading something
        if (reader.readyState == FileReader.LOADING) {
          throw new FileError(FileError.INVALID_STATE_ERR);
        }

        reader._result = null;
        reader._error = null;
        reader._readyState = FileReader.LOADING;

        if (typeof file == 'string') {
            // Deprecated in Cordova 2.4.
            console.warning('Using a string argument with FileReader.readAs functions is deprecated.');
            reader._fileName = file;
        } else if (typeof file.fullPath == 'string') {
            reader._fileName = file.fullPath;
        } else {
            reader._fileName = '';
            return true;
        }

        reader.onloadstart && reader.onloadstart(new ProgressEvent("loadstart", {target:reader}));
    }

    /**
     * Abort reading file.
     */
    FileReader.prototype.abort = function() {
        if (origFileReader && !this._fileName) {
            return this._realReader.abort();
        }
        this._result = null;

        if (this._readyState == FileReader.DONE || this._readyState == FileReader.EMPTY) {
          return;
        }

        this._readyState = FileReader.DONE;

        // If abort callback
        if (typeof this.onabort === 'function') {
            this.onabort(new ProgressEvent('abort', {target:this}));
        }
        // If load end callback
        if (typeof this.onloadend === 'function') {
            this.onloadend(new ProgressEvent('loadend', {target:this}));
        }
    };

    /**
     * Read text file.
     *
     * @param file          {File} File object containing file properties
     * @param encoding      [Optional] (see http://www.iana.org/assignments/character-sets)
     */
    FileReader.prototype.readAsText = function(file, encoding) {
        if (initRead(this, file)) {
            return this._realReader.readAsText(file, encoding);
        }

        // Default encoding is UTF-8
        var enc = encoding ? encoding : "UTF-8";
        var me = this;
        var execArgs = [this._fileName, enc];

        // Maybe add slice parameters.
        if (file.end < file.size) {
            execArgs.push(file.start, file.end);
        } else if (file.start > 0) {
            execArgs.push(file.start);
        }

        // Read file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // Save result
                me._result = r;

                // If onload callback
                if (typeof me.onload === "function") {
                    me.onload(new ProgressEvent("load", {target:me}));
                }

                // DONE state
                me._readyState = FileReader.DONE;

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // DONE state
                me._readyState = FileReader.DONE;

                // null result
                me._result = null;

                // Save error
                me._error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {target:me}));
                }

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            }, "File", "readAsText", execArgs);
    };


    /**
     * Read file and return data as a base64 encoded data url.
     * A data url is of the form:
     *      data:[<mediatype>][;base64],<data>
     *
     * @param file          {File} File object containing file properties
     */
    FileReader.prototype.readAsDataURL = function(file) {
        if (initRead(this, file)) {
            return this._realReader.readAsDataURL(file);
        }

        var me = this;
        var execArgs = [this._fileName];

        // Maybe add slice parameters.
        if (file.end < file.size) {
            execArgs.push(file.start, file.end);
        } else if (file.start > 0) {
            execArgs.push(file.start);
        }

        // Read file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // DONE state
                me._readyState = FileReader.DONE;

                // Save result
                me._result = r;

                // If onload callback
                if (typeof me.onload === "function") {
                    me.onload(new ProgressEvent("load", {target:me}));
                }

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me._readyState === FileReader.DONE) {
                    return;
                }

                // DONE state
                me._readyState = FileReader.DONE;

                me._result = null;

                // Save error
                me._error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {target:me}));
                }

                // If onloadend callback
                if (typeof me.onloadend === "function") {
                    me.onloadend(new ProgressEvent("loadend", {target:me}));
                }
            }, "File", "readAsDataURL", execArgs);
    };

    /**
     * Read file and return data as a binary data.
     *
     * @param file          {File} File object containing file properties
     */
    FileReader.prototype.readAsBinaryString = function(file) {
        if (initRead(this, file)) {
            return this._realReader.readAsBinaryString(file);
        }
        // TODO - Can't return binary data to browser.
        console.log('method "readAsBinaryString" is not supported at this time.');
        this.abort();
    };

    /**
     * Read file and return data as a binary data.
     *
     * @param file          {File} File object containing file properties
     */
    FileReader.prototype.readAsArrayBuffer = function(file) {
        if (initRead(this, file)) {
            return this._realReader.readAsArrayBuffer(file);
        }
        // TODO - Can't return binary data to browser.
        console.log('This method is not supported at this time.');
        this.abort();
    };

    module.exports = FileReader;

    });

    // file: lib/common/plugin/FileSystem.js
    define("cordova/plugin/FileSystem", function(require, exports, module) {

    var DirectoryEntry = require('cordova/plugin/DirectoryEntry');

    /**
     * An interface representing a file system
     *
     * @constructor
     * {DOMString} name the unique name of the file system (readonly)
     * {DirectoryEntry} root directory of the file system (readonly)
     */
    var FileSystem = function(name, root) {
        this.name = name || null;
        if (root) {
            this.root = new DirectoryEntry(root.name, root.fullPath);
        }
    };

    module.exports = FileSystem;

    });

    // file: lib/common/plugin/FileTransfer.js
    define("cordova/plugin/FileTransfer", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        FileTransferError = require('cordova/plugin/FileTransferError'),
        ProgressEvent = require('cordova/plugin/ProgressEvent');

    function newProgressEvent(result) {
        var pe = new ProgressEvent();
        pe.lengthComputable = result.lengthComputable;
        pe.loaded = result.loaded;
        pe.total = result.total;
        return pe;
    }

    var idCounter = 0;

    /**
     * FileTransfer uploads a file to a remote server.
     * @constructor
     */
    var FileTransfer = function() {
        this._id = ++idCounter;
        this.onprogress = null; // optional callback
    };

    /**
    * Given an absolute file path, uploads a file on the device to a remote server
    * using a multipart HTTP request.
    * @param filePath {String}           Full path of the file on the device
    * @param server {String}             URL of the server to receive the file
    * @param successCallback (Function}  Callback to be invoked when upload has completed
    * @param errorCallback {Function}    Callback to be invoked upon error
    * @param options {FileUploadOptions} Optional parameters such as file name and mimetype
    * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false
    */
    FileTransfer.prototype.upload = function(filePath, server, successCallback, errorCallback, options, trustAllHosts) {
        argscheck.checkArgs('ssFFO*', 'FileTransfer.upload', arguments);
        // check for options
        var fileKey = null;
        var fileName = null;
        var mimeType = null;
        var params = null;
        var chunkedMode = true;
        var headers = null;
        if (options) {
            fileKey = options.fileKey;
            fileName = options.fileName;
            mimeType = options.mimeType;
            headers = options.headers;
            if (options.chunkedMode !== null || typeof options.chunkedMode != "undefined") {
                chunkedMode = options.chunkedMode;
            }
            if (options.params) {
                params = options.params;
            }
            else {
                params = {};
            }
        }

        var fail = errorCallback && function(e) {
            var error = new FileTransferError(e.code, e.source, e.target, e.http_status);
            errorCallback(error);
        };

        var self = this;
        var win = function(result) {
            if (typeof result.lengthComputable != "undefined") {
                if (self.onprogress) {
                    self.onprogress(newProgressEvent(result));
                }
            } else {
                successCallback && successCallback(result);
            }
        };
        exec(win, fail, 'FileTransfer', 'upload', [filePath, server, fileKey, fileName, mimeType, params, trustAllHosts, chunkedMode, headers, this._id]);
    };

    /**
     * Downloads a file form a given URL and saves it to the specified directory.
     * @param source {String}          URL of the server to receive the file
     * @param target {String}         Full path of the file on the device
     * @param successCallback (Function}  Callback to be invoked when upload has completed
     * @param errorCallback {Function}    Callback to be invoked upon error
     * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false
     */
    FileTransfer.prototype.download = function(source, target, successCallback, errorCallback, trustAllHosts) {
        argscheck.checkArgs('ssFF*', 'FileTransfer.download', arguments);
        var self = this;
        var win = function(result) {
            if (typeof result.lengthComputable != "undefined") {
                if (self.onprogress) {
                    return self.onprogress(newProgressEvent(result));
                }
            } else if (successCallback) {
                var entry = null;
                if (result.isDirectory) {
                    entry = new (require('cordova/plugin/DirectoryEntry'))();
                }
                else if (result.isFile) {
                    entry = new (require('cordova/plugin/FileEntry'))();
                }
                entry.isDirectory = result.isDirectory;
                entry.isFile = result.isFile;
                entry.name = result.name;
                entry.fullPath = result.fullPath;
                successCallback(entry);
            }
        };

        var fail = errorCallback && function(e) {
            var error = new FileTransferError(e.code, e.source, e.target, e.http_status);
            errorCallback(error);
        };

        exec(win, fail, 'FileTransfer', 'download', [source, target, trustAllHosts, this._id]);
    };

    /**
     * Aborts the ongoing file transfer on this object
     * @param successCallback {Function}  Callback to be invoked upon success
     * @param errorCallback {Function}    Callback to be invoked upon error
     */
    FileTransfer.prototype.abort = function(successCallback, errorCallback) {
        exec(successCallback, errorCallback, 'FileTransfer', 'abort', [this._id]);
    };

    module.exports = FileTransfer;

    });

    // file: lib/common/plugin/FileTransferError.js
    define("cordova/plugin/FileTransferError", function(require, exports, module) {

    /**
     * FileTransferError
     * @constructor
     */
    var FileTransferError = function(code, source, target, status) {
        this.code = code || null;
        this.source = source || null;
        this.target = target || null;
        this.http_status = status || null;
    };

    FileTransferError.FILE_NOT_FOUND_ERR = 1;
    FileTransferError.INVALID_URL_ERR = 2;
    FileTransferError.CONNECTION_ERR = 3;
    FileTransferError.ABORT_ERR = 4;

    module.exports = FileTransferError;

    });

    // file: lib/common/plugin/FileUploadOptions.js
    define("cordova/plugin/FileUploadOptions", function(require, exports, module) {

    /**
     * Options to customize the HTTP request used to upload files.
     * @constructor
     * @param fileKey {String}   Name of file request parameter.
     * @param fileName {String}  Filename to be used by the server. Defaults to image.jpg.
     * @param mimeType {String}  Mimetype of the uploaded file. Defaults to image/jpeg.
     * @param params {Object}    Object with key: value params to send to the server.
     * @param headers {Object}   Keys are header names, values are header values. Multiple
     *                           headers of the same name are not supported.
     */
    var FileUploadOptions = function(fileKey, fileName, mimeType, params, headers) {
        this.fileKey = fileKey || null;
        this.fileName = fileName || null;
        this.mimeType = mimeType || null;
        this.params = params || null;
        this.headers = headers || null;
    };

    module.exports = FileUploadOptions;

    });

    // file: lib/common/plugin/FileUploadResult.js
    define("cordova/plugin/FileUploadResult", function(require, exports, module) {

    /**
     * FileUploadResult
     * @constructor
     */
    var FileUploadResult = function() {
        this.bytesSent = 0;
        this.responseCode = null;
        this.response = null;
    };

    module.exports = FileUploadResult;

    });

    // file: lib/common/plugin/FileWriter.js
    define("cordova/plugin/FileWriter", function(require, exports, module) {

    var exec = require('cordova/exec'),
        FileError = require('cordova/plugin/FileError'),
        ProgressEvent = require('cordova/plugin/ProgressEvent');

    /**
     * This class writes to the mobile device file system.
     *
     * For Android:
     *      The root directory is the root of the file system.
     *      To write to the SD card, the file name is "sdcard/my_file.txt"
     *
     * @constructor
     * @param file {File} File object containing file properties
     * @param append if true write to the end of the file, otherwise overwrite the file
     */
    var FileWriter = function(file) {
        this.fileName = "";
        this.length = 0;
        if (file) {
            this.fileName = file.fullPath || file;
            this.length = file.size || 0;
        }
        // default is to write at the beginning of the file
        this.position = 0;

        this.readyState = 0; // EMPTY

        this.result = null;

        // Error
        this.error = null;

        // Event handlers
        this.onwritestart = null;   // When writing starts
        this.onprogress = null;     // While writing the file, and reporting partial file data
        this.onwrite = null;        // When the write has successfully completed.
        this.onwriteend = null;     // When the request has completed (either in success or failure).
        this.onabort = null;        // When the write has been aborted. For instance, by invoking the abort() method.
        this.onerror = null;        // When the write has failed (see errors).
    };

    // States
    FileWriter.INIT = 0;
    FileWriter.WRITING = 1;
    FileWriter.DONE = 2;

    /**
     * Abort writing file.
     */
    FileWriter.prototype.abort = function() {
        // check for invalid state
        if (this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        // set error
        this.error = new FileError(FileError.ABORT_ERR);

        this.readyState = FileWriter.DONE;

        // If abort callback
        if (typeof this.onabort === "function") {
            this.onabort(new ProgressEvent("abort", {"target":this}));
        }

        // If write end callback
        if (typeof this.onwriteend === "function") {
            this.onwriteend(new ProgressEvent("writeend", {"target":this}));
        }
    };

    /**
     * Writes data to the file
     *
     * @param text to be written
     */
    FileWriter.prototype.write = function(text) {
        // Throw an exception if we are already writing a file
        if (this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        // WRITING state
        this.readyState = FileWriter.WRITING;

        var me = this;

        // If onwritestart callback
        if (typeof me.onwritestart === "function") {
            me.onwritestart(new ProgressEvent("writestart", {"target":me}));
        }

        // Write file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // position always increases by bytes written because file would be extended
                me.position += r;
                // The length of the file is now where we are done writing.

                me.length = me.position;

                // DONE state
                me.readyState = FileWriter.DONE;

                // If onwrite callback
                if (typeof me.onwrite === "function") {
                    me.onwrite(new ProgressEvent("write", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // DONE state
                me.readyState = FileWriter.DONE;

                // Save error
                me.error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            }, "File", "write", [this.fileName, text, this.position]);
    };

    /**
     * Moves the file pointer to the location specified.
     *
     * If the offset is a negative number the position of the file
     * pointer is rewound.  If the offset is greater than the file
     * size the position is set to the end of the file.
     *
     * @param offset is the location to move the file pointer to.
     */
    FileWriter.prototype.seek = function(offset) {
        // Throw an exception if we are already writing a file
        if (this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        if (!offset && offset !== 0) {
            return;
        }

        // See back from end of file.
        if (offset < 0) {
            this.position = Math.max(offset + this.length, 0);
        }
        // Offset is bigger than file size so set position
        // to the end of the file.
        else if (offset > this.length) {
            this.position = this.length;
        }
        // Offset is between 0 and file size so set the position
        // to start writing.
        else {
            this.position = offset;
        }
    };

    /**
     * Truncates the file to the size specified.
     *
     * @param size to chop the file at.
     */
    FileWriter.prototype.truncate = function(size) {
        // Throw an exception if we are already writing a file
        if (this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
        }

        // WRITING state
        this.readyState = FileWriter.WRITING;

        var me = this;

        // If onwritestart callback
        if (typeof me.onwritestart === "function") {
            me.onwritestart(new ProgressEvent("writestart", {"target":this}));
        }

        // Write file
        exec(
            // Success callback
            function(r) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // DONE state
                me.readyState = FileWriter.DONE;

                // Update the length of the file
                me.length = r;
                me.position = Math.min(me.position, r);

                // If onwrite callback
                if (typeof me.onwrite === "function") {
                    me.onwrite(new ProgressEvent("write", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            },
            // Error callback
            function(e) {
                // If DONE (cancelled), then don't do anything
                if (me.readyState === FileWriter.DONE) {
                    return;
                }

                // DONE state
                me.readyState = FileWriter.DONE;

                // Save error
                me.error = new FileError(e);

                // If onerror callback
                if (typeof me.onerror === "function") {
                    me.onerror(new ProgressEvent("error", {"target":me}));
                }

                // If onwriteend callback
                if (typeof me.onwriteend === "function") {
                    me.onwriteend(new ProgressEvent("writeend", {"target":me}));
                }
            }, "File", "truncate", [this.fileName, size]);
    };

    module.exports = FileWriter;

    });

    // file: lib/common/plugin/Flags.js
    define("cordova/plugin/Flags", function(require, exports, module) {

    /**
     * Supplies arguments to methods that lookup or create files and directories.
     *
     * @param create
     *            {boolean} file or directory if it doesn't exist
     * @param exclusive
     *            {boolean} used with create; if true the command will fail if
     *            target path exists
     */
    function Flags(create, exclusive) {
        this.create = create || false;
        this.exclusive = exclusive || false;
    }

    module.exports = Flags;

    });

    // file: lib/common/plugin/GlobalizationError.js
    define("cordova/plugin/GlobalizationError", function(require, exports, module) {


    /**
     * Globalization error object
     *
     * @constructor
     * @param code
     * @param message
     */
    var GlobalizationError = function(code, message) {
        this.code = code || null;
        this.message = message || '';
    };

    // Globalization error codes
    GlobalizationError.UNKNOWN_ERROR = 0;
    GlobalizationError.FORMATTING_ERROR = 1;
    GlobalizationError.PARSING_ERROR = 2;
    GlobalizationError.PATTERN_ERROR = 3;

    module.exports = GlobalizationError;

    });

    // file: lib/common/plugin/InAppBrowser.js
    define("cordova/plugin/InAppBrowser", function(require, exports, module) {

    var exec = require('cordova/exec');
    var channel = require('cordova/channel');

    function InAppBrowser() {
       this.channels = {
            'loadstart': channel.create('loadstart'),
            'loadstop' : channel.create('loadstop'),
            'exit' : channel.create('exit')
       };
    }

    InAppBrowser.prototype = {
        _eventHandler: function (event) {
            if (event.type in this.channels) {
                this.channels[event.type].fire(event);
            }
        },
        close: function (eventname) {
            exec(null, null, "InAppBrowser", "close", []);
        },
        addEventListener: function (eventname,f) {
            if (eventname in this.channels) {
                this.channels[eventname].subscribe(f);
            }
        },
        removeEventListener: function(eventname, f) {
            if (eventname in this.channels) {
                this.channels[eventname].unsubscribe(f);
            }
        }
    };

    module.exports = function(strUrl, strWindowName, strWindowFeatures) {
        var iab = new InAppBrowser();
        var cb = function(eventname) {
           iab._eventHandler(eventname);
        };
        exec(cb, null, "InAppBrowser", "open", [strUrl, strWindowName, strWindowFeatures]);
        return iab;
    };

    //Export the original open so it can be used if needed
    module.exports._orig = window.open;

    });

    // file: lib/common/plugin/LocalFileSystem.js
    define("cordova/plugin/LocalFileSystem", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Represents a local file system.
     */
    var LocalFileSystem = function() {

    };

    LocalFileSystem.TEMPORARY = 0; //temporary, with no guarantee of persistence
    LocalFileSystem.PERSISTENT = 1; //persistent

    module.exports = LocalFileSystem;

    });

    // file: lib/common/plugin/Media.js
    define("cordova/plugin/Media", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec');

    var mediaObjects = {};

    /**
     * This class provides access to the device media, interfaces to both sound and video
     *
     * @constructor
     * @param src                   The file name or url to play
     * @param successCallback       The callback to be called when the file is done playing or recording.
     *                                  successCallback()
     * @param errorCallback         The callback to be called if there is an error.
     *                                  errorCallback(int errorCode) - OPTIONAL
     * @param statusCallback        The callback to be called when media status has changed.
     *                                  statusCallback(int statusCode) - OPTIONAL
     */
    var Media = function(src, successCallback, errorCallback, statusCallback) {
        argscheck.checkArgs('SFFF', 'Media', arguments);
        this.id = utils.createUUID();
        mediaObjects[this.id] = this;
        this.src = src;
        this.successCallback = successCallback;
        this.errorCallback = errorCallback;
        this.statusCallback = statusCallback;
        this._duration = -1;
        this._position = -1;
        exec(null, this.errorCallback, "Media", "create", [this.id, this.src]);
    };

    // Media messages
    Media.MEDIA_STATE = 1;
    Media.MEDIA_DURATION = 2;
    Media.MEDIA_POSITION = 3;
    Media.MEDIA_ERROR = 9;

    // Media states
    Media.MEDIA_NONE = 0;
    Media.MEDIA_STARTING = 1;
    Media.MEDIA_RUNNING = 2;
    Media.MEDIA_PAUSED = 3;
    Media.MEDIA_STOPPED = 4;
    Media.MEDIA_MSG = ["None", "Starting", "Running", "Paused", "Stopped"];

    // "static" function to return existing objs.
    Media.get = function(id) {
        return mediaObjects[id];
    };

    /**
     * Start or resume playing audio file.
     */
    Media.prototype.play = function(options) {
        exec(null, null, "Media", "startPlayingAudio", [this.id, this.src, options]);
    };

    /**
     * Stop playing audio file.
     */
    Media.prototype.stop = function() {
        var me = this;
        exec(function() {
            me._position = 0;
        }, this.errorCallback, "Media", "stopPlayingAudio", [this.id]);
    };

    /**
     * Seek or jump to a new time in the track..
     */
    Media.prototype.seekTo = function(milliseconds) {
        var me = this;
        exec(function(p) {
            me._position = p;
        }, this.errorCallback, "Media", "seekToAudio", [this.id, milliseconds]);
    };

    /**
     * Pause playing audio file.
     */
    Media.prototype.pause = function() {
        exec(null, this.errorCallback, "Media", "pausePlayingAudio", [this.id]);
    };

    /**
     * Get duration of an audio file.
     * The duration is only set for audio that is playing, paused or stopped.
     *
     * @return      duration or -1 if not known.
     */
    Media.prototype.getDuration = function() {
        return this._duration;
    };

    /**
     * Get position of audio.
     */
    Media.prototype.getCurrentPosition = function(success, fail) {
        var me = this;
        exec(function(p) {
            me._position = p;
            success(p);
        }, fail, "Media", "getCurrentPositionAudio", [this.id]);
    };

    /**
     * Start recording audio file.
     */
    Media.prototype.startRecord = function() {
        exec(null, this.errorCallback, "Media", "startRecordingAudio", [this.id, this.src]);
    };

    /**
     * Stop recording audio file.
     */
    Media.prototype.stopRecord = function() {
        exec(null, this.errorCallback, "Media", "stopRecordingAudio", [this.id]);
    };

    /**
     * Release the resources.
     */
    Media.prototype.release = function() {
        exec(null, this.errorCallback, "Media", "release", [this.id]);
    };

    /**
     * Adjust the volume.
     */
    Media.prototype.setVolume = function(volume) {
        exec(null, null, "Media", "setVolume", [this.id, volume]);
    };

    /**
     * Audio has status update.
     * PRIVATE
     *
     * @param id            The media object id (string)
     * @param msgType       The 'type' of update this is
     * @param value         Use of value is determined by the msgType
     */
    Media.onStatus = function(id, msgType, value) {

        var media = mediaObjects[id];

        if(media) {
            switch(msgType) {
                case Media.MEDIA_STATE :
                    media.statusCallback && media.statusCallback(value);
                    if(value == Media.MEDIA_STOPPED) {
                        media.successCallback && media.successCallback();
                    }
                    break;
                case Media.MEDIA_DURATION :
                    media._duration = value;
                    break;
                case Media.MEDIA_ERROR :
                    media.errorCallback && media.errorCallback(value);
                    break;
                case Media.MEDIA_POSITION :
                    media._position = Number(value);
                    break;
                default :
                    console.error && console.error("Unhandled Media.onStatus :: " + msgType);
                    break;
            }
        }
        else {
             console.error && console.error("Received Media.onStatus callback for unknown media :: " + id);
        }

    };

    module.exports = Media;

    });

    // file: lib/common/plugin/MediaError.js
    define("cordova/plugin/MediaError", function(require, exports, module) {

    /**
     * This class contains information about any Media errors.
    */
    /*
     According to :: http://dev.w3.org/html5/spec-author-view/video.html#mediaerror
     We should never be creating these objects, we should just implement the interface
     which has 1 property for an instance, 'code'

     instead of doing :
        errorCallbackFunction( new MediaError(3,'msg') );
    we should simply use a literal :
        errorCallbackFunction( {'code':3} );
     */

     var _MediaError = window.MediaError;


    if(!_MediaError) {
        window.MediaError = _MediaError = function(code, msg) {
            this.code = (typeof code != 'undefined') ? code : null;
            this.message = msg || ""; // message is NON-standard! do not use!
        };
    }

    _MediaError.MEDIA_ERR_NONE_ACTIVE    = _MediaError.MEDIA_ERR_NONE_ACTIVE    || 0;
    _MediaError.MEDIA_ERR_ABORTED        = _MediaError.MEDIA_ERR_ABORTED        || 1;
    _MediaError.MEDIA_ERR_NETWORK        = _MediaError.MEDIA_ERR_NETWORK        || 2;
    _MediaError.MEDIA_ERR_DECODE         = _MediaError.MEDIA_ERR_DECODE         || 3;
    _MediaError.MEDIA_ERR_NONE_SUPPORTED = _MediaError.MEDIA_ERR_NONE_SUPPORTED || 4;
    // TODO: MediaError.MEDIA_ERR_NONE_SUPPORTED is legacy, the W3 spec now defines it as below.
    // as defined by http://dev.w3.org/html5/spec-author-view/video.html#error-codes
    _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 4;

    module.exports = _MediaError;

    });

    // file: lib/common/plugin/MediaFile.js
    define("cordova/plugin/MediaFile", function(require, exports, module) {

    var utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        File = require('cordova/plugin/File'),
        CaptureError = require('cordova/plugin/CaptureError');
    /**
     * Represents a single file.
     *
     * name {DOMString} name of the file, without path information
     * fullPath {DOMString} the full path of the file, including the name
     * type {DOMString} mime type
     * lastModifiedDate {Date} last modified date
     * size {Number} size of the file in bytes
     */
    var MediaFile = function(name, fullPath, type, lastModifiedDate, size){
        MediaFile.__super__.constructor.apply(this, arguments);
    };

    utils.extend(MediaFile, File);

    /**
     * Request capture format data for a specific file and type
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     */
    MediaFile.prototype.getFormatData = function(successCallback, errorCallback) {
        if (typeof this.fullPath === "undefined" || this.fullPath === null) {
            errorCallback(new CaptureError(CaptureError.CAPTURE_INVALID_ARGUMENT));
        } else {
            exec(successCallback, errorCallback, "Capture", "getFormatData", [this.fullPath, this.type]);
        }
    };

    module.exports = MediaFile;

    });

    // file: lib/common/plugin/MediaFileData.js
    define("cordova/plugin/MediaFileData", function(require, exports, module) {

    /**
     * MediaFileData encapsulates format information of a media file.
     *
     * @param {DOMString} codecs
     * @param {long} bitrate
     * @param {long} height
     * @param {long} width
     * @param {float} duration
     */
    var MediaFileData = function(codecs, bitrate, height, width, duration){
        this.codecs = codecs || null;
        this.bitrate = bitrate || 0;
        this.height = height || 0;
        this.width = width || 0;
        this.duration = duration || 0;
    };

    module.exports = MediaFileData;

    });

    // file: lib/common/plugin/Metadata.js
    define("cordova/plugin/Metadata", function(require, exports, module) {

    /**
     * Information about the state of the file or directory
     *
     * {Date} modificationTime (readonly)
     */
    var Metadata = function(time) {
        this.modificationTime = (typeof time != 'undefined'?new Date(time):null);
    };

    module.exports = Metadata;

    });

    // file: lib/common/plugin/Position.js
    define("cordova/plugin/Position", function(require, exports, module) {

    var Coordinates = require('cordova/plugin/Coordinates');

    var Position = function(coords, timestamp) {
        if (coords) {
            this.coords = new Coordinates(coords.latitude, coords.longitude, coords.altitude, coords.accuracy, coords.heading, coords.velocity, coords.altitudeAccuracy);
        } else {
            this.coords = new Coordinates();
        }
        this.timestamp = (timestamp !== undefined) ? timestamp : new Date();
    };

    module.exports = Position;

    });

    // file: lib/common/plugin/PositionError.js
    define("cordova/plugin/PositionError", function(require, exports, module) {

    /**
     * Position error object
     *
     * @constructor
     * @param code
     * @param message
     */
    var PositionError = function(code, message) {
        this.code = code || null;
        this.message = message || '';
    };

    PositionError.PERMISSION_DENIED = 1;
    PositionError.POSITION_UNAVAILABLE = 2;
    PositionError.TIMEOUT = 3;

    module.exports = PositionError;

    });

    // file: lib/common/plugin/ProgressEvent.js
    define("cordova/plugin/ProgressEvent", function(require, exports, module) {

    // If ProgressEvent exists in global context, use it already, otherwise use our own polyfill
    // Feature test: See if we can instantiate a native ProgressEvent;
    // if so, use that approach,
    // otherwise fill-in with our own implementation.
    //
    // NOTE: right now we always fill in with our own. Down the road would be nice if we can use whatever is native in the webview.
    var ProgressEvent = (function() {
        /*
        var createEvent = function(data) {
            var event = document.createEvent('Events');
            event.initEvent('ProgressEvent', false, false);
            if (data) {
                for (var i in data) {
                    if (data.hasOwnProperty(i)) {
                        event[i] = data[i];
                    }
                }
                if (data.target) {
                    // TODO: cannot call <some_custom_object>.dispatchEvent
                    // need to first figure out how to implement EventTarget
                }
            }
            return event;
        };
        try {
            var ev = createEvent({type:"abort",target:document});
            return function ProgressEvent(type, data) {
                data.type = type;
                return createEvent(data);
            };
        } catch(e){
        */
            return function ProgressEvent(type, dict) {
                this.type = type;
                this.bubbles = false;
                this.cancelBubble = false;
                this.cancelable = false;
                this.lengthComputable = false;
                this.loaded = dict && dict.loaded ? dict.loaded : 0;
                this.total = dict && dict.total ? dict.total : 0;
                this.target = dict && dict.target ? dict.target : null;
            };
        //}
    })();

    module.exports = ProgressEvent;

    });

    // file: lib/common/plugin/accelerometer.js
    define("cordova/plugin/accelerometer", function(require, exports, module) {

    /**
     * This class provides access to device accelerometer data.
     * @constructor
     */
    var argscheck = require('cordova/argscheck'),
        utils = require("cordova/utils"),
        exec = require("cordova/exec"),
        Acceleration = require('cordova/plugin/Acceleration');

    // Is the accel sensor running?
    var running = false;

    // Keeps reference to watchAcceleration calls.
    var timers = {};

    // Array of listeners; used to keep track of when we should call start and stop.
    var listeners = [];

    // Last returned acceleration object from native
    var accel = null;

    // Tells native to start.
    function start() {
        exec(function(a) {
            var tempListeners = listeners.slice(0);
            accel = new Acceleration(a.x, a.y, a.z, a.timestamp);
            for (var i = 0, l = tempListeners.length; i < l; i++) {
                tempListeners[i].win(accel);
            }
        }, function(e) {
            var tempListeners = listeners.slice(0);
            for (var i = 0, l = tempListeners.length; i < l; i++) {
                tempListeners[i].fail(e);
            }
        }, "Accelerometer", "start", []);
        running = true;
    }

    // Tells native to stop.
    function stop() {
        exec(null, null, "Accelerometer", "stop", []);
        running = false;
    }

    // Adds a callback pair to the listeners array
    function createCallbackPair(win, fail) {
        return {win:win, fail:fail};
    }

    // Removes a win/fail listener pair from the listeners array
    function removeListeners(l) {
        var idx = listeners.indexOf(l);
        if (idx > -1) {
            listeners.splice(idx, 1);
            if (listeners.length === 0) {
                stop();
            }
        }
    }

    var accelerometer = {
        /**
         * Asynchronously acquires the current acceleration.
         *
         * @param {Function} successCallback    The function to call when the acceleration data is available
         * @param {Function} errorCallback      The function to call when there is an error getting the acceleration data. (OPTIONAL)
         * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL)
         */
        getCurrentAcceleration: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'accelerometer.getCurrentAcceleration', arguments);

            var p;
            var win = function(a) {
                removeListeners(p);
                successCallback(a);
            };
            var fail = function(e) {
                removeListeners(p);
                errorCallback && errorCallback(e);
            };

            p = createCallbackPair(win, fail);
            listeners.push(p);

            if (!running) {
                start();
            }
        },

        /**
         * Asynchronously acquires the acceleration repeatedly at a given interval.
         *
         * @param {Function} successCallback    The function to call each time the acceleration data is available
         * @param {Function} errorCallback      The function to call when there is an error getting the acceleration data. (OPTIONAL)
         * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL)
         * @return String                       The watch id that must be passed to #clearWatch to stop watching.
         */
        watchAcceleration: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'accelerometer.watchAcceleration', arguments);
            // Default interval (10 sec)
            var frequency = (options && options.frequency && typeof options.frequency == 'number') ? options.frequency : 10000;

            // Keep reference to watch id, and report accel readings as often as defined in frequency
            var id = utils.createUUID();

            var p = createCallbackPair(function(){}, function(e) {
                removeListeners(p);
                errorCallback && errorCallback(e);
            });
            listeners.push(p);

            timers[id] = {
                timer:window.setInterval(function() {
                    if (accel) {
                        successCallback(accel);
                    }
                }, frequency),
                listeners:p
            };

            if (running) {
                // If we're already running then immediately invoke the success callback
                // but only if we have retrieved a value, sample code does not check for null ...
                if (accel) {
                    successCallback(accel);
                }
            } else {
                start();
            }

            return id;
        },

        /**
         * Clears the specified accelerometer watch.
         *
         * @param {String} id       The id of the watch returned from #watchAcceleration.
         */
        clearWatch: function(id) {
            // Stop javascript timer & remove from timer list
            if (id && timers[id]) {
                window.clearInterval(timers[id].timer);
                removeListeners(timers[id].listeners);
                delete timers[id];
            }
        }
    };

    module.exports = accelerometer;

    });

    // file: lib/android/plugin/android/app.js
    define("cordova/plugin/android/app", function(require, exports, module) {

    var exec = require('cordova/exec');

    module.exports = {
      /**
       * Clear the resource cache.
       */
      clearCache:function() {
        exec(null, null, "App", "clearCache", []);
      },

      /**
       * Load the url into the webview or into new browser instance.
       *
       * @param url           The URL to load
       * @param props         Properties that can be passed in to the activity:
       *      wait: int                           => wait msec before loading URL
       *      loadingDialog: "Title,Message"      => display a native loading dialog
       *      loadUrlTimeoutValue: int            => time in msec to wait before triggering a timeout error
       *      clearHistory: boolean              => clear webview history (default=false)
       *      openExternal: boolean              => open in a new browser (default=false)
       *
       * Example:
       *      navigator.app.loadUrl("http://server/myapp/index.html", {wait:2000, loadingDialog:"Wait,Loading App", loadUrlTimeoutValue: 60000});
       */
      loadUrl:function(url, props) {
        exec(null, null, "App", "loadUrl", [url, props]);
      },

      /**
       * Cancel loadUrl that is waiting to be loaded.
       */
      cancelLoadUrl:function() {
        exec(null, null, "App", "cancelLoadUrl", []);
      },

      /**
       * Clear web history in this web view.
       * Instead of BACK button loading the previous web page, it will exit the app.
       */
      clearHistory:function() {
        exec(null, null, "App", "clearHistory", []);
      },

      /**
       * Go to previous page displayed.
       * This is the same as pressing the backbutton on Android device.
       */
      backHistory:function() {
        exec(null, null, "App", "backHistory", []);
      },

      /**
       * Override the default behavior of the Android back button.
       * If overridden, when the back button is pressed, the "backKeyDown" JavaScript event will be fired.
       *
       * Note: The user should not have to call this method.  Instead, when the user
       *       registers for the "backbutton" event, this is automatically done.
       *
       * @param override        T=override, F=cancel override
       */
      overrideBackbutton:function(override) {
        exec(null, null, "App", "overrideBackbutton", [override]);
      },

      /**
       * Exit and terminate the application.
       */
      exitApp:function() {
        return exec(null, null, "App", "exitApp", []);
      }
    };

    });

    // file: lib/android/plugin/android/device.js
    define("cordova/plugin/android/device", function(require, exports, module) {

    var channel = require('cordova/channel'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        app = require('cordova/plugin/android/app');

    module.exports = {
        /*
         * DEPRECATED
         * This is only for Android.
         *
         * You must explicitly override the back button.
         */
        overrideBackButton:function() {
            console.log("Device.overrideBackButton() is deprecated.  Use App.overrideBackbutton(true).");
            app.overrideBackbutton(true);
        },

        /*
         * DEPRECATED
         * This is only for Android.
         *
         * This resets the back button to the default behavior
         */
        resetBackButton:function() {
            console.log("Device.resetBackButton() is deprecated.  Use App.overrideBackbutton(false).");
            app.overrideBackbutton(false);
        },

        /*
         * DEPRECATED
         * This is only for Android.
         *
         * This terminates the activity!
         */
        exitApp:function() {
            console.log("Device.exitApp() is deprecated.  Use App.exitApp().");
            app.exitApp();
        }
    };

    });

    // file: lib/android/plugin/android/nativeapiprovider.js
    define("cordova/plugin/android/nativeapiprovider", function(require, exports, module) {

    var nativeApi = this._cordovaNative || require('cordova/plugin/android/promptbasednativeapi');
    var currentApi = nativeApi;

    module.exports = {
        get: function() { return currentApi; },
        setPreferPrompt: function(value) {
            currentApi = value ? require('cordova/plugin/android/promptbasednativeapi') : nativeApi;
        },
        // Used only by tests.
        set: function(value) {
            currentApi = value;
        }
    };

    });

    // file: lib/android/plugin/android/notification.js
    define("cordova/plugin/android/notification", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Provides Android enhanced notification API.
     */
    module.exports = {
        activityStart : function(title, message) {
            // If title and message not specified then mimic Android behavior of
            // using default strings.
            if (typeof title === "undefined" && typeof message == "undefined") {
                title = "Busy";
                message = 'Please wait...';
            }

            exec(null, null, 'Notification', 'activityStart', [ title, message ]);
        },

        /**
         * Close an activity dialog
         */
        activityStop : function() {
            exec(null, null, 'Notification', 'activityStop', []);
        },

        /**
         * Display a progress dialog with progress bar that goes from 0 to 100.
         *
         * @param {String}
         *            title Title of the progress dialog.
         * @param {String}
         *            message Message to display in the dialog.
         */
        progressStart : function(title, message) {
            exec(null, null, 'Notification', 'progressStart', [ title, message ]);
        },

        /**
         * Close the progress dialog.
         */
        progressStop : function() {
            exec(null, null, 'Notification', 'progressStop', []);
        },

        /**
         * Set the progress dialog value.
         *
         * @param {Number}
         *            value 0-100
         */
        progressValue : function(value) {
            exec(null, null, 'Notification', 'progressValue', [ value ]);
        }
    };

    });

    // file: lib/android/plugin/android/promptbasednativeapi.js
    define("cordova/plugin/android/promptbasednativeapi", function(require, exports, module) {

    module.exports = {
        exec: function(service, action, callbackId, argsJson) {
            return prompt(argsJson, 'gap:'+JSON.stringify([service, action, callbackId]));
        },
        setNativeToJsBridgeMode: function(value) {
            prompt(value, 'gap_bridge_mode:');
        },
        retrieveJsMessages: function() {
            return prompt('', 'gap_poll:');
        }
    };

    });

    // file: lib/android/plugin/android/storage.js
    define("cordova/plugin/android/storage", function(require, exports, module) {

    var utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        channel = require('cordova/channel');

    var queryQueue = {};

    /**
     * SQL result set object
     * PRIVATE METHOD
     * @constructor
     */
    var DroidDB_Rows = function() {
        this.resultSet = [];    // results array
        this.length = 0;        // number of rows
    };

    /**
     * Get item from SQL result set
     *
     * @param row           The row number to return
     * @return              The row object
     */
    DroidDB_Rows.prototype.item = function(row) {
        return this.resultSet[row];
    };

    /**
     * SQL result set that is returned to user.
     * PRIVATE METHOD
     * @constructor
     */
    var DroidDB_Result = function() {
        this.rows = new DroidDB_Rows();
    };

    /**
     * Callback from native code when query is complete.
     * PRIVATE METHOD
     *
     * @param id   Query id
     */
    function completeQuery(id, data) {
        var query = queryQueue[id];
        if (query) {
            try {
                delete queryQueue[id];

                // Get transaction
                var tx = query.tx;

                // If transaction hasn't failed
                // Note: We ignore all query results if previous query
                //       in the same transaction failed.
                if (tx && tx.queryList[id]) {

                    // Save query results
                    var r = new DroidDB_Result();
                    r.rows.resultSet = data;
                    r.rows.length = data.length;
                    try {
                        if (typeof query.successCallback === 'function') {
                            query.successCallback(query.tx, r);
                        }
                    } catch (ex) {
                        console.log("executeSql error calling user success callback: "+ex);
                    }

                    tx.queryComplete(id);
                }
            } catch (e) {
                console.log("executeSql error: "+e);
            }
        }
    }

    /**
     * Callback from native code when query fails
     * PRIVATE METHOD
     *
     * @param reason            Error message
     * @param id                Query id
     */
    function failQuery(reason, id) {
        var query = queryQueue[id];
        if (query) {
            try {
                delete queryQueue[id];

                // Get transaction
                var tx = query.tx;

                // If transaction hasn't failed
                // Note: We ignore all query results if previous query
                //       in the same transaction failed.
                if (tx && tx.queryList[id]) {
                    tx.queryList = {};

                    try {
                        if (typeof query.errorCallback === 'function') {
                            query.errorCallback(query.tx, reason);
                        }
                    } catch (ex) {
                        console.log("executeSql error calling user error callback: "+ex);
                    }

                    tx.queryFailed(id, reason);
                }

            } catch (e) {
                console.log("executeSql error: "+e);
            }
        }
    }

    /**
     * SQL query object
     * PRIVATE METHOD
     *
     * @constructor
     * @param tx                The transaction object that this query belongs to
     */
    var DroidDB_Query = function(tx) {

        // Set the id of the query
        this.id = utils.createUUID();

        // Add this query to the queue
        queryQueue[this.id] = this;

        // Init result
        this.resultSet = [];

        // Set transaction that this query belongs to
        this.tx = tx;

        // Add this query to transaction list
        this.tx.queryList[this.id] = this;

        // Callbacks
        this.successCallback = null;
        this.errorCallback = null;

    };

    /**
     * Transaction object
     * PRIVATE METHOD
     * @constructor
     */
    var DroidDB_Tx = function() {

        // Set the id of the transaction
        this.id = utils.createUUID();

        // Callbacks
        this.successCallback = null;
        this.errorCallback = null;

        // Query list
        this.queryList = {};
    };

    /**
     * Mark query in transaction as complete.
     * If all queries are complete, call the user's transaction success callback.
     *
     * @param id                Query id
     */
    DroidDB_Tx.prototype.queryComplete = function(id) {
        delete this.queryList[id];

        // If no more outstanding queries, then fire transaction success
        if (this.successCallback) {
            var count = 0;
            var i;
            for (i in this.queryList) {
                if (this.queryList.hasOwnProperty(i)) {
                    count++;
                }
            }
            if (count === 0) {
                try {
                    this.successCallback();
                } catch(e) {
                    console.log("Transaction error calling user success callback: " + e);
                }
            }
        }
    };

    /**
     * Mark query in transaction as failed.
     *
     * @param id                Query id
     * @param reason            Error message
     */
    DroidDB_Tx.prototype.queryFailed = function(id, reason) {

        // The sql queries in this transaction have already been run, since
        // we really don't have a real transaction implemented in native code.
        // However, the user callbacks for the remaining sql queries in transaction
        // will not be called.
        this.queryList = {};

        if (this.errorCallback) {
            try {
                this.errorCallback(reason);
            } catch(e) {
                console.log("Transaction error calling user error callback: " + e);
            }
        }
    };

    /**
     * Execute SQL statement
     *
     * @param sql                   SQL statement to execute
     * @param params                Statement parameters
     * @param successCallback       Success callback
     * @param errorCallback         Error callback
     */
    DroidDB_Tx.prototype.executeSql = function(sql, params, successCallback, errorCallback) {

        // Init params array
        if (typeof params === 'undefined') {
            params = [];
        }

        // Create query and add to queue
        var query = new DroidDB_Query(this);
        queryQueue[query.id] = query;

        // Save callbacks
        query.successCallback = successCallback;
        query.errorCallback = errorCallback;

        // Call native code
        exec(null, null, "Storage", "executeSql", [sql, params, query.id]);
    };

    var DatabaseShell = function() {
    };

    /**
     * Start a transaction.
     * Does not support rollback in event of failure.
     *
     * @param process {Function}            The transaction function
     * @param successCallback {Function}
     * @param errorCallback {Function}
     */
    DatabaseShell.prototype.transaction = function(process, errorCallback, successCallback) {
        var tx = new DroidDB_Tx();
        tx.successCallback = successCallback;
        tx.errorCallback = errorCallback;
        try {
            process(tx);
        } catch (e) {
            console.log("Transaction error: "+e);
            if (tx.errorCallback) {
                try {
                    tx.errorCallback(e);
                } catch (ex) {
                    console.log("Transaction error calling user error callback: "+e);
                }
            }
        }
    };

    /**
     * Open database
     *
     * @param name              Database name
     * @param version           Database version
     * @param display_name      Database display name
     * @param size              Database size in bytes
     * @return                  Database object
     */
    var DroidDB_openDatabase = function(name, version, display_name, size) {
        exec(null, null, "Storage", "openDatabase", [name, version, display_name, size]);
        var db = new DatabaseShell();
        return db;
    };

    /**
     * For browsers with no localStorage we emulate it with SQLite. Follows the w3c api.
     * TODO: Do similar for sessionStorage.
     * @constructor
     */
    var CupcakeLocalStorage = function() {
        channel.waitForInitialization("cupcakeStorage");

        try {

          this.db = openDatabase('localStorage', '1.0', 'localStorage', 2621440);
          var storage = {};
          this.length = 0;
          function setLength (length) {
            this.length = length;
            localStorage.length = length;
          }
          this.db.transaction(
            function (transaction) {
                var i;
              transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
              transaction.executeSql('SELECT * FROM storage', [], function(tx, result) {
                for(var i = 0; i < result.rows.length; i++) {
                  storage[result.rows.item(i).id] =  result.rows.item(i).body;
                }
                setLength(result.rows.length);
                channel.initializationComplete("cupcakeStorage");
              });

            },
            function (err) {
              utils.alert(err.message);
            }
          );
          this.setItem = function(key, val) {
            if (typeof(storage[key])=='undefined') {
              this.length++;
            }
            storage[key] = val;
            this.db.transaction(
              function (transaction) {
                transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                transaction.executeSql('REPLACE INTO storage (id, body) values(?,?)', [key,val]);
              }
            );
          };
          this.getItem = function(key) {
            return storage[key];
          };
          this.removeItem = function(key) {
            delete storage[key];
            this.length--;
            this.db.transaction(
              function (transaction) {
                transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                transaction.executeSql('DELETE FROM storage where id=?', [key]);
              }
            );
          };
          this.clear = function() {
            storage = {};
            this.length = 0;
            this.db.transaction(
              function (transaction) {
                transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                transaction.executeSql('DELETE FROM storage', []);
              }
            );
          };
          this.key = function(index) {
            var i = 0;
            for (var j in storage) {
              if (i==index) {
                return j;
              } else {
                i++;
              }
            }
            return null;
          };

        } catch(e) {
              utils.alert("Database error "+e+".");
            return;
        }
    };

    module.exports = {
      openDatabase:DroidDB_openDatabase,
      CupcakeLocalStorage:CupcakeLocalStorage,
      failQuery:failQuery,
      completeQuery:completeQuery
    };

    });

    // file: lib/common/plugin/battery.js
    define("cordova/plugin/battery", function(require, exports, module) {

    /**
     * This class contains information about the current battery status.
     * @constructor
     */
    var cordova = require('cordova'),
        exec = require('cordova/exec');

    function handlers() {
      return battery.channels.batterystatus.numHandlers +
             battery.channels.batterylow.numHandlers +
             battery.channels.batterycritical.numHandlers;
    }

    var Battery = function() {
        this._level = null;
        this._isPlugged = null;
        // Create new event handlers on the window (returns a channel instance)
        this.channels = {
          batterystatus:cordova.addWindowEventHandler("batterystatus"),
          batterylow:cordova.addWindowEventHandler("batterylow"),
          batterycritical:cordova.addWindowEventHandler("batterycritical")
        };
        for (var key in this.channels) {
            this.channels[key].onHasSubscribersChange = Battery.onHasSubscribersChange;
        }
    };
    /**
     * Event handlers for when callbacks get registered for the battery.
     * Keep track of how many handlers we have so we can start and stop the native battery listener
     * appropriately (and hopefully save on battery life!).
     */
    Battery.onHasSubscribersChange = function() {
      // If we just registered the first handler, make sure native listener is started.
      if (this.numHandlers === 1 && handlers() === 1) {
          exec(battery._status, battery._error, "Battery", "start", []);
      } else if (handlers() === 0) {
          exec(null, null, "Battery", "stop", []);
      }
    };

    /**
     * Callback for battery status
     *
     * @param {Object} info            keys: level, isPlugged
     */
    Battery.prototype._status = function(info) {
        if (info) {
            var me = battery;
        var level = info.level;
            if (me._level !== level || me._isPlugged !== info.isPlugged) {
                // Fire batterystatus event
                cordova.fireWindowEvent("batterystatus", info);

                // Fire low battery event
                if (level === 20 || level === 5) {
                    if (level === 20) {
                        cordova.fireWindowEvent("batterylow", info);
                    }
                    else {
                        cordova.fireWindowEvent("batterycritical", info);
                    }
                }
            }
            me._level = level;
            me._isPlugged = info.isPlugged;
        }
    };

    /**
     * Error callback for battery start
     */
    Battery.prototype._error = function(e) {
        console.log("Error initializing Battery: " + e);
    };

    var battery = new Battery();

    module.exports = battery;

    });

    // file: lib/common/plugin/capture.js
    define("cordova/plugin/capture", function(require, exports, module) {

    var exec = require('cordova/exec'),
        MediaFile = require('cordova/plugin/MediaFile');

    /**
     * Launches a capture of different types.
     *
     * @param (DOMString} type
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureVideoOptions} options
     */
    function _capture(type, successCallback, errorCallback, options) {
        var win = function(pluginResult) {
            var mediaFiles = [];
            var i;
            for (i = 0; i < pluginResult.length; i++) {
                var mediaFile = new MediaFile();
                mediaFile.name = pluginResult[i].name;
                mediaFile.fullPath = pluginResult[i].fullPath;
                mediaFile.type = pluginResult[i].type;
                mediaFile.lastModifiedDate = pluginResult[i].lastModifiedDate;
                mediaFile.size = pluginResult[i].size;
                mediaFiles.push(mediaFile);
            }
            successCallback(mediaFiles);
        };
        exec(win, errorCallback, "Capture", type, [options]);
    }
    /**
     * The Capture interface exposes an interface to the camera and microphone of the hosting device.
     */
    function Capture() {
        this.supportedAudioModes = [];
        this.supportedImageModes = [];
        this.supportedVideoModes = [];
    }

    /**
     * Launch audio recorder application for recording audio clip(s).
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureAudioOptions} options
     */
    Capture.prototype.captureAudio = function(successCallback, errorCallback, options){
        _capture("captureAudio", successCallback, errorCallback, options);
    };

    /**
     * Launch camera application for taking image(s).
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureImageOptions} options
     */
    Capture.prototype.captureImage = function(successCallback, errorCallback, options){
        _capture("captureImage", successCallback, errorCallback, options);
    };

    /**
     * Launch device camera application for recording video(s).
     *
     * @param {Function} successCB
     * @param {Function} errorCB
     * @param {CaptureVideoOptions} options
     */
    Capture.prototype.captureVideo = function(successCallback, errorCallback, options){
        _capture("captureVideo", successCallback, errorCallback, options);
    };


    module.exports = new Capture();

    });

    // file: lib/common/plugin/compass.js
    define("cordova/plugin/compass", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        utils = require('cordova/utils'),
        CompassHeading = require('cordova/plugin/CompassHeading'),
        CompassError = require('cordova/plugin/CompassError'),
        timers = {},
        compass = {
            /**
             * Asynchronously acquires the current heading.
             * @param {Function} successCallback The function to call when the heading
             * data is available
             * @param {Function} errorCallback The function to call when there is an error
             * getting the heading data.
             * @param {CompassOptions} options The options for getting the heading data (not used).
             */
            getCurrentHeading:function(successCallback, errorCallback, options) {
                argscheck.checkArgs('fFO', 'compass.getCurrentHeading', arguments);

                var win = function(result) {
                    var ch = new CompassHeading(result.magneticHeading, result.trueHeading, result.headingAccuracy, result.timestamp);
                    successCallback(ch);
                };
                var fail = errorCallback && function(code) {
                    var ce = new CompassError(code);
                    errorCallback(ce);
                };

                // Get heading
                exec(win, fail, "Compass", "getHeading", [options]);
            },

            /**
             * Asynchronously acquires the heading repeatedly at a given interval.
             * @param {Function} successCallback The function to call each time the heading
             * data is available
             * @param {Function} errorCallback The function to call when there is an error
             * getting the heading data.
             * @param {HeadingOptions} options The options for getting the heading data
             * such as timeout and the frequency of the watch. For iOS, filter parameter
             * specifies to watch via a distance filter rather than time.
             */
            watchHeading:function(successCallback, errorCallback, options) {
                argscheck.checkArgs('fFO', 'compass.watchHeading', arguments);
                // Default interval (100 msec)
                var frequency = (options !== undefined && options.frequency !== undefined) ? options.frequency : 100;
                var filter = (options !== undefined && options.filter !== undefined) ? options.filter : 0;

                var id = utils.createUUID();
                if (filter > 0) {
                    // is an iOS request for watch by filter, no timer needed
                    timers[id] = "iOS";
                    compass.getCurrentHeading(successCallback, errorCallback, options);
                } else {
                    // Start watch timer to get headings
                    timers[id] = window.setInterval(function() {
                        compass.getCurrentHeading(successCallback, errorCallback);
                    }, frequency);
                }

                return id;
            },

            /**
             * Clears the specified heading watch.
             * @param {String} watchId The ID of the watch returned from #watchHeading.
             */
            clearWatch:function(id) {
                // Stop javascript timer & remove from timer list
                if (id && timers[id]) {
                    if (timers[id] != "iOS") {
                        clearInterval(timers[id]);
                    } else {
                        // is iOS watch by filter so call into device to stop
                        exec(null, null, "Compass", "stopHeading", []);
                    }
                    delete timers[id];
                }
            }
        };

    module.exports = compass;

    });

    // file: lib/common/plugin/console-via-logger.js
    define("cordova/plugin/console-via-logger", function(require, exports, module) {

    //------------------------------------------------------------------------------

    var logger = require("cordova/plugin/logger");
    var utils  = require("cordova/utils");

    //------------------------------------------------------------------------------
    // object that we're exporting
    //------------------------------------------------------------------------------
    var console = module.exports;

    //------------------------------------------------------------------------------
    // copy of the original console object
    //------------------------------------------------------------------------------
    var WinConsole = window.console;

    //------------------------------------------------------------------------------
    // whether to use the logger
    //------------------------------------------------------------------------------
    var UseLogger = false;

    //------------------------------------------------------------------------------
    // Timers
    //------------------------------------------------------------------------------
    var Timers = {};

    //------------------------------------------------------------------------------
    // used for unimplemented methods
    //------------------------------------------------------------------------------
    function noop() {}

    //------------------------------------------------------------------------------
    // used for unimplemented methods
    //------------------------------------------------------------------------------
    console.useLogger = function (value) {
        if (arguments.length) UseLogger = !!value;

        if (UseLogger) {
            if (logger.useConsole()) {
                throw new Error("console and logger are too intertwingly");
            }
        }

        return UseLogger;
    };

    //------------------------------------------------------------------------------
    console.log = function() {
        if (logger.useConsole()) return;
        logger.log.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.error = function() {
        if (logger.useConsole()) return;
        logger.error.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.warn = function() {
        if (logger.useConsole()) return;
        logger.warn.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.info = function() {
        if (logger.useConsole()) return;
        logger.info.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.debug = function() {
        if (logger.useConsole()) return;
        logger.debug.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.assert = function(expression) {
        if (expression) return;

        var message = utils.vformat(arguments[1], [].slice.call(arguments, 2));
        console.log("ASSERT: " + message);
    };

    //------------------------------------------------------------------------------
    console.clear = function() {};

    //------------------------------------------------------------------------------
    console.dir = function(object) {
        console.log("%o", object);
    };

    //------------------------------------------------------------------------------
    console.dirxml = function(node) {
        console.log(node.innerHTML);
    };

    //------------------------------------------------------------------------------
    console.trace = noop;

    //------------------------------------------------------------------------------
    console.group = console.log;

    //------------------------------------------------------------------------------
    console.groupCollapsed = console.log;

    //------------------------------------------------------------------------------
    console.groupEnd = noop;

    //------------------------------------------------------------------------------
    console.time = function(name) {
        Timers[name] = new Date().valueOf();
    };

    //------------------------------------------------------------------------------
    console.timeEnd = function(name) {
        var timeStart = Timers[name];
        if (!timeStart) {
            console.warn("unknown timer: " + name);
            return;
        }

        var timeElapsed = new Date().valueOf() - timeStart;
        console.log(name + ": " + timeElapsed + "ms");
    };

    //------------------------------------------------------------------------------
    console.timeStamp = noop;

    //------------------------------------------------------------------------------
    console.profile = noop;

    //------------------------------------------------------------------------------
    console.profileEnd = noop;

    //------------------------------------------------------------------------------
    console.count = noop;

    //------------------------------------------------------------------------------
    console.exception = console.log;

    //------------------------------------------------------------------------------
    console.table = function(data, columns) {
        console.log("%o", data);
    };

    //------------------------------------------------------------------------------
    // return a new function that calls both functions passed as args
    //------------------------------------------------------------------------------
    function wrappedOrigCall(orgFunc, newFunc) {
        return function() {
            var args = [].slice.call(arguments);
            try { orgFunc.apply(WinConsole, args); } catch (e) {}
            try { newFunc.apply(console,    args); } catch (e) {}
        };
    }

    //------------------------------------------------------------------------------
    // For every function that exists in the original console object, that
    // also exists in the new console object, wrap the new console method
    // with one that calls both
    //------------------------------------------------------------------------------
    for (var key in console) {
        if (typeof WinConsole[key] == "function") {
            console[key] = wrappedOrigCall(WinConsole[key], console[key]);
        }
    }

    });

    // file: lib/common/plugin/contacts.js
    define("cordova/plugin/contacts", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        ContactError = require('cordova/plugin/ContactError'),
        utils = require('cordova/utils'),
        Contact = require('cordova/plugin/Contact');

    /**
    * Represents a group of Contacts.
    * @constructor
    */
    var contacts = {
        /**
         * Returns an array of Contacts matching the search criteria.
         * @param fields that should be searched
         * @param successCB success callback
         * @param errorCB error callback
         * @param {ContactFindOptions} options that can be applied to contact searching
         * @return array of Contacts matching search criteria
         */
        find:function(fields, successCB, errorCB, options) {
            argscheck.checkArgs('afFO', 'contacts.find', arguments);
            if (!fields.length) {
                errorCB && errorCB(new ContactError(ContactError.INVALID_ARGUMENT_ERROR));
            } else {
                var win = function(result) {
                    var cs = [];
                    for (var i = 0, l = result.length; i < l; i++) {
                        cs.push(contacts.create(result[i]));
                    }
                    successCB(cs);
                };
                exec(win, errorCB, "Contacts", "search", [fields, options]);
            }
        },

        /**
         * This function creates a new contact, but it does not persist the contact
         * to device storage. To persist the contact to device storage, invoke
         * contact.save().
         * @param properties an object whose properties will be examined to create a new Contact
         * @returns new Contact object
         */
        create:function(properties) {
            argscheck.checkArgs('O', 'contacts.create', arguments);
            var contact = new Contact();
            for (var i in properties) {
                if (typeof contact[i] !== 'undefined' && properties.hasOwnProperty(i)) {
                    contact[i] = properties[i];
                }
            }
            return contact;
        }
    };

    module.exports = contacts;

    });

    // file: lib/common/plugin/device.js
    define("cordova/plugin/device", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        channel = require('cordova/channel'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec');

    // Tell cordova channel to wait on the CordovaInfoReady event
    channel.waitForInitialization('onCordovaInfoReady');

    /**
     * This represents the mobile device, and provides properties for inspecting the model, version, UUID of the
     * phone, etc.
     * @constructor
     */
    function Device() {
        this.available = false;
        this.platform = null;
        this.version = null;
        this.name = null;
        this.uuid = null;
        this.cordova = null;
        this.model = null;

        var me = this;

        channel.onCordovaReady.subscribe(function() {
            me.getInfo(function(info) {
                me.available = true;
                me.platform = info.platform;
                me.version = info.version;
                me.name = info.name;
                me.uuid = info.uuid;
                me.cordova = info.cordova;
                me.model = info.model;
                channel.onCordovaInfoReady.fire();
            },function(e) {
                me.available = false;
                utils.alert("[ERROR] Error initializing Cordova: " + e);
            });
        });
    }

    /**
     * Get device info
     *
     * @param {Function} successCallback The function to call when the heading data is available
     * @param {Function} errorCallback The function to call when there is an error getting the heading data. (OPTIONAL)
     */
    Device.prototype.getInfo = function(successCallback, errorCallback) {
        argscheck.checkArgs('fF', 'Device.getInfo', arguments);
        exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);
    };

    module.exports = new Device();

    });

    // file: lib/common/plugin/echo.js
    define("cordova/plugin/echo", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Sends the given message through exec() to the Echo plugin, which sends it back to the successCallback.
     * @param successCallback  invoked with a FileSystem object
     * @param errorCallback  invoked if error occurs retrieving file system
     * @param message  The string to be echoed.
     * @param forceAsync  Whether to force an async return value (for testing native->js bridge).
     */
    module.exports = function(successCallback, errorCallback, message, forceAsync) {
        var action = forceAsync ? 'echoAsync' : 'echo';
        if (!forceAsync && message.constructor == ArrayBuffer) {
            action = 'echoArrayBuffer';
        }
        exec(successCallback, errorCallback, "Echo", action, [message]);
    };


    });

    // file: lib/android/plugin/file/symbols.js
    define("cordova/plugin/file/symbols", function(require, exports, module) {


    var modulemapper = require('cordova/modulemapper'),
        symbolshelper = require('cordova/plugin/file/symbolshelper');

    symbolshelper(modulemapper.clobbers);

    });

    // file: lib/common/plugin/file/symbolshelper.js
    define("cordova/plugin/file/symbolshelper", function(require, exports, module) {

    module.exports = function(exportFunc) {
        exportFunc('cordova/plugin/DirectoryEntry', 'DirectoryEntry');
        exportFunc('cordova/plugin/DirectoryReader', 'DirectoryReader');
        exportFunc('cordova/plugin/Entry', 'Entry');
        exportFunc('cordova/plugin/File', 'File');
        exportFunc('cordova/plugin/FileEntry', 'FileEntry');
        exportFunc('cordova/plugin/FileError', 'FileError');
        exportFunc('cordova/plugin/FileReader', 'FileReader');
        exportFunc('cordova/plugin/FileSystem', 'FileSystem');
        exportFunc('cordova/plugin/FileTransfer', 'FileTransfer');
        exportFunc('cordova/plugin/FileTransferError', 'FileTransferError');
        exportFunc('cordova/plugin/FileUploadOptions', 'FileUploadOptions');
        exportFunc('cordova/plugin/FileUploadResult', 'FileUploadResult');
        exportFunc('cordova/plugin/FileWriter', 'FileWriter');
        exportFunc('cordova/plugin/Flags', 'Flags');
        exportFunc('cordova/plugin/LocalFileSystem', 'LocalFileSystem');
        exportFunc('cordova/plugin/Metadata', 'Metadata');
        exportFunc('cordova/plugin/requestFileSystem', 'requestFileSystem');
        exportFunc('cordova/plugin/resolveLocalFileSystemURI', 'resolveLocalFileSystemURI');
    };

    });

    // file: lib/common/plugin/geolocation.js
    define("cordova/plugin/geolocation", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        utils = require('cordova/utils'),
        exec = require('cordova/exec'),
        PositionError = require('cordova/plugin/PositionError'),
        Position = require('cordova/plugin/Position');

    var timers = {};   // list of timers in use

    // Returns default params, overrides if provided with values
    function parseParameters(options) {
        var opt = {
            maximumAge: 0,
            enableHighAccuracy: false,
            timeout: Infinity
        };

        if (options) {
            if (options.maximumAge !== undefined && !isNaN(options.maximumAge) && options.maximumAge > 0) {
                opt.maximumAge = options.maximumAge;
            }
            if (options.enableHighAccuracy !== undefined) {
                opt.enableHighAccuracy = options.enableHighAccuracy;
            }
            if (options.timeout !== undefined && !isNaN(options.timeout)) {
                if (options.timeout < 0) {
                    opt.timeout = 0;
                } else {
                    opt.timeout = options.timeout;
                }
            }
        }

        return opt;
    }

    // Returns a timeout failure, closed over a specified timeout value and error callback.
    function createTimeout(errorCallback, timeout) {
        var t = setTimeout(function() {
            clearTimeout(t);
            t = null;
            errorCallback({
                code:PositionError.TIMEOUT,
                message:"Position retrieval timed out."
            });
        }, timeout);
        return t;
    }

    var geolocation = {
        lastPosition:null, // reference to last known (cached) position returned
        /**
       * Asynchronously acquires the current position.
       *
       * @param {Function} successCallback    The function to call when the position data is available
       * @param {Function} errorCallback      The function to call when there is an error getting the heading position. (OPTIONAL)
       * @param {PositionOptions} options     The options for getting the position data. (OPTIONAL)
       */
        getCurrentPosition:function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);
            options = parseParameters(options);

            // Timer var that will fire an error callback if no position is retrieved from native
            // before the "timeout" param provided expires
            var timeoutTimer = {timer:null};

            var win = function(p) {
                clearTimeout(timeoutTimer.timer);
                if (!(timeoutTimer.timer)) {
                    // Timeout already happened, or native fired error callback for
                    // this geo request.
                    // Don't continue with success callback.
                    return;
                }
                var pos = new Position(
                    {
                        latitude:p.latitude,
                        longitude:p.longitude,
                        altitude:p.altitude,
                        accuracy:p.accuracy,
                        heading:p.heading,
                        velocity:p.velocity,
                        altitudeAccuracy:p.altitudeAccuracy
                    },
                    (p.timestamp === undefined ? new Date() : ((p.timestamp instanceof Date) ? p.timestamp : new Date(p.timestamp)))
                );
                geolocation.lastPosition = pos;
                successCallback(pos);
            };
            var fail = function(e) {
                clearTimeout(timeoutTimer.timer);
                timeoutTimer.timer = null;
                var err = new PositionError(e.code, e.message);
                if (errorCallback) {
                    errorCallback(err);
                }
            };

            // Check our cached position, if its timestamp difference with current time is less than the maximumAge, then just
            // fire the success callback with the cached position.
            if (geolocation.lastPosition && options.maximumAge && (((new Date()).getTime() - geolocation.lastPosition.timestamp.getTime()) <= options.maximumAge)) {
                successCallback(geolocation.lastPosition);
            // If the cached position check failed and the timeout was set to 0, error out with a TIMEOUT error object.
            } else if (options.timeout === 0) {
                fail({
                    code:PositionError.TIMEOUT,
                    message:"timeout value in PositionOptions set to 0 and no cached Position object available, or cached Position object's age exceeds provided PositionOptions' maximumAge parameter."
                });
            // Otherwise we have to call into native to retrieve a position.
            } else {
                if (options.timeout !== Infinity) {
                    // If the timeout value was not set to Infinity (default), then
                    // set up a timeout function that will fire the error callback
                    // if no successful position was retrieved before timeout expired.
                    timeoutTimer.timer = createTimeout(fail, options.timeout);
                } else {
                    // This is here so the check in the win function doesn't mess stuff up
                    // may seem weird but this guarantees timeoutTimer is
                    // always truthy before we call into native
                    timeoutTimer.timer = true;
                }
                exec(win, fail, "Geolocation", "getLocation", [options.enableHighAccuracy, options.maximumAge]);
            }
            return timeoutTimer;
        },
        /**
         * Asynchronously watches the geolocation for changes to geolocation.  When a change occurs,
         * the successCallback is called with the new location.
         *
         * @param {Function} successCallback    The function to call each time the location data is available
         * @param {Function} errorCallback      The function to call when there is an error getting the location data. (OPTIONAL)
         * @param {PositionOptions} options     The options for getting the location data such as frequency. (OPTIONAL)
         * @return String                       The watch id that must be passed to #clearWatch to stop watching.
         */
        watchPosition:function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);
            options = parseParameters(options);

            var id = utils.createUUID();

            // Tell device to get a position ASAP, and also retrieve a reference to the timeout timer generated in getCurrentPosition
            timers[id] = geolocation.getCurrentPosition(successCallback, errorCallback, options);

            var fail = function(e) {
                clearTimeout(timers[id].timer);
                var err = new PositionError(e.code, e.message);
                if (errorCallback) {
                    errorCallback(err);
                }
            };

            var win = function(p) {
                clearTimeout(timers[id].timer);
                if (options.timeout !== Infinity) {
                    timers[id].timer = createTimeout(fail, options.timeout);
                }
                var pos = new Position(
                    {
                        latitude:p.latitude,
                        longitude:p.longitude,
                        altitude:p.altitude,
                        accuracy:p.accuracy,
                        heading:p.heading,
                        velocity:p.velocity,
                        altitudeAccuracy:p.altitudeAccuracy
                    },
                    (p.timestamp === undefined ? new Date() : ((p.timestamp instanceof Date) ? p.timestamp : new Date(p.timestamp)))
                );
                geolocation.lastPosition = pos;
                successCallback(pos);
            };

            exec(win, fail, "Geolocation", "addWatch", [id, options.enableHighAccuracy]);

            return id;
        },
        /**
         * Clears the specified heading watch.
         *
         * @param {String} id       The ID of the watch returned from #watchPosition
         */
        clearWatch:function(id) {
            if (id && timers[id] !== undefined) {
                clearTimeout(timers[id].timer);
                timers[id].timer = false;
                exec(null, null, "Geolocation", "clearWatch", [id]);
            }
        }
    };

    module.exports = geolocation;

    });

    // file: lib/common/plugin/globalization.js
    define("cordova/plugin/globalization", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        exec = require('cordova/exec'),
        GlobalizationError = require('cordova/plugin/GlobalizationError');

    var globalization = {

    /**
    * Returns the string identifier for the client's current language.
    * It returns the language identifier string to the successCB callback with a
    * properties object as a parameter. If there is an error getting the language,
    * then the errorCB callback is invoked.
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.value {String}: The language identifier
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getPreferredLanguage(function (language) {alert('language:' + language.value + '\n');},
    *                                function () {});
    */
    getPreferredLanguage:function(successCB, failureCB) {
        argscheck.checkArgs('fF', 'Globalization.getPreferredLanguage', arguments);
        exec(successCB, failureCB, "Globalization","getPreferredLanguage", []);
    },

    /**
    * Returns the string identifier for the client's current locale setting.
    * It returns the locale identifier string to the successCB callback with a
    * properties object as a parameter. If there is an error getting the locale,
    * then the errorCB callback is invoked.
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.value {String}: The locale identifier
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getLocaleName(function (locale) {alert('locale:' + locale.value + '\n');},
    *                                function () {});
    */
    getLocaleName:function(successCB, failureCB) {
        argscheck.checkArgs('fF', 'Globalization.getLocaleName', arguments);
        exec(successCB, failureCB, "Globalization","getLocaleName", []);
    },


    /**
    * Returns a date formatted as a string according to the client's user preferences and
    * calendar using the time zone of the client. It returns the formatted date string to the
    * successCB callback with a properties object as a parameter. If there is an error
    * formatting the date, then the errorCB callback is invoked.
    *
    * The defaults are: formatLenght="short" and selector="date and time"
    *
    * @param {Date} date
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            formatLength {String}: 'short', 'medium', 'long', or 'full'
    *            selector {String}: 'date', 'time', or 'date and time'
    *
    * @return Object.value {String}: The localized date string
    *
    * @error GlobalizationError.FORMATTING_ERROR
    *
    * Example
    *    globalization.dateToString(new Date(),
    *                function (date) {alert('date:' + date.value + '\n');},
    *                function (errorCode) {alert(errorCode);},
    *                {formatLength:'short'});
    */
    dateToString:function(date, successCB, failureCB, options) {
        argscheck.checkArgs('dfFO', 'Globalization.dateToString', arguments);
        var dateValue = date.valueOf();
        exec(successCB, failureCB, "Globalization", "dateToString", [{"date": dateValue, "options": options}]);
    },


    /**
    * Parses a date formatted as a string according to the client's user
    * preferences and calendar using the time zone of the client and returns
    * the corresponding date object. It returns the date to the successCB
    * callback with a properties object as a parameter. If there is an error
    * parsing the date string, then the errorCB callback is invoked.
    *
    * The defaults are: formatLength="short" and selector="date and time"
    *
    * @param {String} dateString
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            formatLength {String}: 'short', 'medium', 'long', or 'full'
    *            selector {String}: 'date', 'time', or 'date and time'
    *
    * @return    Object.year {Number}: The four digit year
    *            Object.month {Number}: The month from (0 - 11)
    *            Object.day {Number}: The day from (1 - 31)
    *            Object.hour {Number}: The hour from (0 - 23)
    *            Object.minute {Number}: The minute from (0 - 59)
    *            Object.second {Number}: The second from (0 - 59)
    *            Object.millisecond {Number}: The milliseconds (from 0 - 999),
    *                                        not available on all platforms
    *
    * @error GlobalizationError.PARSING_ERROR
    *
    * Example
    *    globalization.stringToDate('4/11/2011',
    *                function (date) { alert('Month:' + date.month + '\n' +
    *                    'Day:' + date.day + '\n' +
    *                    'Year:' + date.year + '\n');},
    *                function (errorCode) {alert(errorCode);},
    *                {selector:'date'});
    */
    stringToDate:function(dateString, successCB, failureCB, options) {
        argscheck.checkArgs('sfFO', 'Globalization.stringToDate', arguments);
        exec(successCB, failureCB, "Globalization", "stringToDate", [{"dateString": dateString, "options": options}]);
    },


    /**
    * Returns a pattern string for formatting and parsing dates according to the client's
    * user preferences. It returns the pattern to the successCB callback with a
    * properties object as a parameter. If there is an error obtaining the pattern,
    * then the errorCB callback is invoked.
    *
    * The defaults are: formatLength="short" and selector="date and time"
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            formatLength {String}: 'short', 'medium', 'long', or 'full'
    *            selector {String}: 'date', 'time', or 'date and time'
    *
    * @return    Object.pattern {String}: The date and time pattern for formatting and parsing dates.
    *                                    The patterns follow Unicode Technical Standard #35
    *                                    http://unicode.org/reports/tr35/tr35-4.html
    *            Object.timezone {String}: The abbreviated name of the time zone on the client
    *            Object.utc_offset {Number}: The current difference in seconds between the client's
    *                                        time zone and coordinated universal time.
    *            Object.dst_offset {Number}: The current daylight saving time offset in seconds
    *                                        between the client's non-daylight saving's time zone
    *                                        and the client's daylight saving's time zone.
    *
    * @error GlobalizationError.PATTERN_ERROR
    *
    * Example
    *    globalization.getDatePattern(
    *                function (date) {alert('pattern:' + date.pattern + '\n');},
    *                function () {},
    *                {formatLength:'short'});
    */
    getDatePattern:function(successCB, failureCB, options) {
        argscheck.checkArgs('fFO', 'Globalization.getDatePattern', arguments);
        exec(successCB, failureCB, "Globalization", "getDatePattern", [{"options": options}]);
    },


    /**
    * Returns an array of either the names of the months or days of the week
    * according to the client's user preferences and calendar. It returns the array of names to the
    * successCB callback with a properties object as a parameter. If there is an error obtaining the
    * names, then the errorCB callback is invoked.
    *
    * The defaults are: type="wide" and item="months"
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'narrow' or 'wide'
    *            item {String}: 'months', or 'days'
    *
    * @return Object.value {Array{String}}: The array of names starting from either
    *                                        the first month in the year or the
    *                                        first day of the week.
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getDateNames(function (names) {
    *        for(var i = 0; i < names.value.length; i++) {
    *            alert('Month:' + names.value[i] + '\n');}},
    *        function () {});
    */
    getDateNames:function(successCB, failureCB, options) {
        argscheck.checkArgs('fFO', 'Globalization.getDateNames', arguments);
        exec(successCB, failureCB, "Globalization", "getDateNames", [{"options": options}]);
    },

    /**
    * Returns whether daylight savings time is in effect for a given date using the client's
    * time zone and calendar. It returns whether or not daylight savings time is in effect
    * to the successCB callback with a properties object as a parameter. If there is an error
    * reading the date, then the errorCB callback is invoked.
    *
    * @param {Date} date
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.dst {Boolean}: The value "true" indicates that daylight savings time is
    *                                in effect for the given date and "false" indicate that it is not.
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.isDayLightSavingsTime(new Date(),
    *                function (date) {alert('dst:' + date.dst + '\n');}
    *                function () {});
    */
    isDayLightSavingsTime:function(date, successCB, failureCB) {
        argscheck.checkArgs('dfF', 'Globalization.isDayLightSavingsTime', arguments);
        var dateValue = date.valueOf();
        exec(successCB, failureCB, "Globalization", "isDayLightSavingsTime", [{"date": dateValue}]);
    },

    /**
    * Returns the first day of the week according to the client's user preferences and calendar.
    * The days of the week are numbered starting from 1 where 1 is considered to be Sunday.
    * It returns the day to the successCB callback with a properties object as a parameter.
    * If there is an error obtaining the pattern, then the errorCB callback is invoked.
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return Object.value {Number}: The number of the first day of the week.
    *
    * @error GlobalizationError.UNKNOWN_ERROR
    *
    * Example
    *    globalization.getFirstDayOfWeek(function (day)
    *                { alert('Day:' + day.value + '\n');},
    *                function () {});
    */
    getFirstDayOfWeek:function(successCB, failureCB) {
        argscheck.checkArgs('fF', 'Globalization.getFirstDayOfWeek', arguments);
        exec(successCB, failureCB, "Globalization", "getFirstDayOfWeek", []);
    },


    /**
    * Returns a number formatted as a string according to the client's user preferences.
    * It returns the formatted number string to the successCB callback with a properties object as a
    * parameter. If there is an error formatting the number, then the errorCB callback is invoked.
    *
    * The defaults are: type="decimal"
    *
    * @param {Number} number
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'decimal', "percent", or 'currency'
    *
    * @return Object.value {String}: The formatted number string.
    *
    * @error GlobalizationError.FORMATTING_ERROR
    *
    * Example
    *    globalization.numberToString(3.25,
    *                function (number) {alert('number:' + number.value + '\n');},
    *                function () {},
    *                {type:'decimal'});
    */
    numberToString:function(number, successCB, failureCB, options) {
        argscheck.checkArgs('nfFO', 'Globalization.numberToString', arguments);
        exec(successCB, failureCB, "Globalization", "numberToString", [{"number": number, "options": options}]);
    },

    /**
    * Parses a number formatted as a string according to the client's user preferences and
    * returns the corresponding number. It returns the number to the successCB callback with a
    * properties object as a parameter. If there is an error parsing the number string, then
    * the errorCB callback is invoked.
    *
    * The defaults are: type="decimal"
    *
    * @param {String} numberString
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'decimal', "percent", or 'currency'
    *
    * @return Object.value {Number}: The parsed number.
    *
    * @error GlobalizationError.PARSING_ERROR
    *
    * Example
    *    globalization.stringToNumber('1234.56',
    *                function (number) {alert('Number:' + number.value + '\n');},
    *                function () { alert('Error parsing number');});
    */
    stringToNumber:function(numberString, successCB, failureCB, options) {
        argscheck.checkArgs('sfFO', 'Globalization.stringToNumber', arguments);
        exec(successCB, failureCB, "Globalization", "stringToNumber", [{"numberString": numberString, "options": options}]);
    },

    /**
    * Returns a pattern string for formatting and parsing numbers according to the client's user
    * preferences. It returns the pattern to the successCB callback with a properties object as a
    * parameter. If there is an error obtaining the pattern, then the errorCB callback is invoked.
    *
    * The defaults are: type="decimal"
    *
    * @param {Function} successCB
    * @param {Function} errorCB
    * @param {Object} options {optional}
    *            type {String}: 'decimal', "percent", or 'currency'
    *
    * @return    Object.pattern {String}: The number pattern for formatting and parsing numbers.
    *                                    The patterns follow Unicode Technical Standard #35.
    *                                    http://unicode.org/reports/tr35/tr35-4.html
    *            Object.symbol {String}: The symbol to be used when formatting and parsing
    *                                    e.g., percent or currency symbol.
    *            Object.fraction {Number}: The number of fractional digits to use when parsing and
    *                                    formatting numbers.
    *            Object.rounding {Number}: The rounding increment to use when parsing and formatting.
    *            Object.positive {String}: The symbol to use for positive numbers when parsing and formatting.
    *            Object.negative: {String}: The symbol to use for negative numbers when parsing and formatting.
    *            Object.decimal: {String}: The decimal symbol to use for parsing and formatting.
    *            Object.grouping: {String}: The grouping symbol to use for parsing and formatting.
    *
    * @error GlobalizationError.PATTERN_ERROR
    *
    * Example
    *    globalization.getNumberPattern(
    *                function (pattern) {alert('Pattern:' + pattern.pattern + '\n');},
    *                function () {});
    */
    getNumberPattern:function(successCB, failureCB, options) {
        argscheck.checkArgs('fFO', 'Globalization.getNumberPattern', arguments);
        exec(successCB, failureCB, "Globalization", "getNumberPattern", [{"options": options}]);
    },

    /**
    * Returns a pattern string for formatting and parsing currency values according to the client's
    * user preferences and ISO 4217 currency code. It returns the pattern to the successCB callback with a
    * properties object as a parameter. If there is an error obtaining the pattern, then the errorCB
    * callback is invoked.
    *
    * @param {String} currencyCode
    * @param {Function} successCB
    * @param {Function} errorCB
    *
    * @return    Object.pattern {String}: The currency pattern for formatting and parsing currency values.
    *                                    The patterns follow Unicode Technical Standard #35
    *                                    http://unicode.org/reports/tr35/tr35-4.html
    *            Object.code {String}: The ISO 4217 currency code for the pattern.
    *            Object.fraction {Number}: The number of fractional digits to use when parsing and
    *                                    formatting currency.
    *            Object.rounding {Number}: The rounding increment to use when parsing and formatting.
    *            Object.decimal: {String}: The decimal symbol to use for parsing and formatting.
    *            Object.grouping: {String}: The grouping symbol to use for parsing and formatting.
    *
    * @error GlobalizationError.FORMATTING_ERROR
    *
    * Example
    *    globalization.getCurrencyPattern('EUR',
    *                function (currency) {alert('Pattern:' + currency.pattern + '\n');}
    *                function () {});
    */
    getCurrencyPattern:function(currencyCode, successCB, failureCB) {
        argscheck.checkArgs('sfF', 'Globalization.getCurrencyPattern', arguments);
        exec(successCB, failureCB, "Globalization", "getCurrencyPattern", [{"currencyCode": currencyCode}]);
    }

    };

    module.exports = globalization;

    });

    // file: lib/common/plugin/logger.js
    define("cordova/plugin/logger", function(require, exports, module) {

    //------------------------------------------------------------------------------
    // The logger module exports the following properties/functions:
    //
    // LOG                          - constant for the level LOG
    // ERROR                        - constant for the level ERROR
    // WARN                         - constant for the level WARN
    // INFO                         - constant for the level INFO
    // DEBUG                        - constant for the level DEBUG
    // logLevel()                   - returns current log level
    // logLevel(value)              - sets and returns a new log level
    // useConsole()                 - returns whether logger is using console
    // useConsole(value)            - sets and returns whether logger is using console
    // log(message,...)             - logs a message at level LOG
    // error(message,...)           - logs a message at level ERROR
    // warn(message,...)            - logs a message at level WARN
    // info(message,...)            - logs a message at level INFO
    // debug(message,...)           - logs a message at level DEBUG
    // logLevel(level,message,...)  - logs a message specified level
    //
    //------------------------------------------------------------------------------

    var logger = exports;

    var exec    = require('cordova/exec');
    var utils   = require('cordova/utils');

    var UseConsole   = true;
    var Queued       = [];
    var DeviceReady  = false;
    var CurrentLevel;

    /**
     * Logging levels
     */

    var Levels = [
        "LOG",
        "ERROR",
        "WARN",
        "INFO",
        "DEBUG"
    ];

    /*
     * add the logging levels to the logger object and
     * to a separate levelsMap object for testing
     */

    var LevelsMap = {};
    for (var i=0; i<Levels.length; i++) {
        var level = Levels[i];
        LevelsMap[level] = i;
        logger[level]    = level;
    }

    CurrentLevel = LevelsMap.WARN;

    /**
     * Getter/Setter for the logging level
     *
     * Returns the current logging level.
     *
     * When a value is passed, sets the logging level to that value.
     * The values should be one of the following constants:
     *    logger.LOG
     *    logger.ERROR
     *    logger.WARN
     *    logger.INFO
     *    logger.DEBUG
     *
     * The value used determines which messages get printed.  The logging
     * values above are in order, and only messages logged at the logging
     * level or above will actually be displayed to the user.  E.g., the
     * default level is WARN, so only messages logged with LOG, ERROR, or
     * WARN will be displayed; INFO and DEBUG messages will be ignored.
     */
    logger.level = function (value) {
        if (arguments.length) {
            if (LevelsMap[value] === null) {
                throw new Error("invalid logging level: " + value);
            }
            CurrentLevel = LevelsMap[value];
        }

        return Levels[CurrentLevel];
    };

    /**
     * Getter/Setter for the useConsole functionality
     *
     * When useConsole is true, the logger will log via the
     * browser 'console' object.  Otherwise, it will use the
     * native Logger plugin.
     */
    logger.useConsole = function (value) {
        if (arguments.length) UseConsole = !!value;

        if (UseConsole) {
            if (typeof console == "undefined") {
                throw new Error("global console object is not defined");
            }

            if (typeof console.log != "function") {
                throw new Error("global console object does not have a log function");
            }

            if (typeof console.useLogger == "function") {
                if (console.useLogger()) {
                    throw new Error("console and logger are too intertwingly");
                }
            }
        }

        return UseConsole;
    };

    /**
     * Logs a message at the LOG level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.log   = function(message) { logWithArgs("LOG",   arguments); };

    /**
     * Logs a message at the ERROR level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.error = function(message) { logWithArgs("ERROR", arguments); };

    /**
     * Logs a message at the WARN level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.warn  = function(message) { logWithArgs("WARN",  arguments); };

    /**
     * Logs a message at the INFO level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.info  = function(message) { logWithArgs("INFO",  arguments); };

    /**
     * Logs a message at the DEBUG level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.debug = function(message) { logWithArgs("DEBUG", arguments); };

    // log at the specified level with args
    function logWithArgs(level, args) {
        args = [level].concat([].slice.call(args));
        logger.logLevel.apply(logger, args);
    }

    /**
     * Logs a message at the specified level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.logLevel = function(level, message /* , ... */) {
        // format the message with the parameters
        var formatArgs = [].slice.call(arguments, 2);
        message    = utils.vformat(message, formatArgs);

        if (LevelsMap[level] === null) {
            throw new Error("invalid logging level: " + level);
        }

        if (LevelsMap[level] > CurrentLevel) return;

        // queue the message if not yet at deviceready
        if (!DeviceReady && !UseConsole) {
            Queued.push([level, message]);
            return;
        }

        // if not using the console, use the native logger
        if (!UseConsole) {
            exec(null, null, "Logger", "logLevel", [level, message]);
            return;
        }

        // make sure console is not using logger
        if (console.__usingCordovaLogger) {
            throw new Error("console and logger are too intertwingly");
        }

        // log to the console
        switch (level) {
            case logger.LOG:   console.log(message); break;
            case logger.ERROR: console.log("ERROR: " + message); break;
            case logger.WARN:  console.log("WARN: "  + message); break;
            case logger.INFO:  console.log("INFO: "  + message); break;
            case logger.DEBUG: console.log("DEBUG: " + message); break;
        }
    };

    // when deviceready fires, log queued messages
    logger.__onDeviceReady = function() {
        if (DeviceReady) return;

        DeviceReady = true;

        for (var i=0; i<Queued.length; i++) {
            var messageArgs = Queued[i];
            logger.logLevel(messageArgs[0], messageArgs[1]);
        }

        Queued = null;
    };

    // add a deviceready event to log queued messages
    document.addEventListener("deviceready", logger.__onDeviceReady, false);

    });

    // file: lib/common/plugin/network.js
    define("cordova/plugin/network", function(require, exports, module) {

    var exec = require('cordova/exec'),
        cordova = require('cordova'),
        channel = require('cordova/channel'),
        utils = require('cordova/utils');

    // Link the onLine property with the Cordova-supplied network info.
    // This works because we clobber the naviagtor object with our own
    // object in bootstrap.js.
    if (typeof navigator != 'undefined') {
        utils.defineGetter(navigator, 'onLine', function() {
            return this.connection.type != 'none';
        });
    }

    function NetworkConnection() {
        this.type = 'unknown';
    }

    /**
     * Get connection info
     *
     * @param {Function} successCallback The function to call when the Connection data is available
     * @param {Function} errorCallback The function to call when there is an error getting the Connection data. (OPTIONAL)
     */
    NetworkConnection.prototype.getInfo = function(successCallback, errorCallback) {
        exec(successCallback, errorCallback, "NetworkStatus", "getConnectionInfo", []);
    };

    var me = new NetworkConnection();
    var timerId = null;
    var timeout = 500;

    channel.onCordovaReady.subscribe(function() {
        me.getInfo(function(info) {
            me.type = info;
            if (info === "none") {
                // set a timer if still offline at the end of timer send the offline event
                timerId = setTimeout(function(){
                    cordova.fireDocumentEvent("offline");
                    timerId = null;
                }, timeout);
            } else {
                // If there is a current offline event pending clear it
                if (timerId !== null) {
                    clearTimeout(timerId);
                    timerId = null;
                }
                cordova.fireDocumentEvent("online");
            }

            // should only fire this once
            if (channel.onCordovaConnectionReady.state !== 2) {
                channel.onCordovaConnectionReady.fire();
            }
        },
        function (e) {
            // If we can't get the network info we should still tell Cordova
            // to fire the deviceready event.
            if (channel.onCordovaConnectionReady.state !== 2) {
                channel.onCordovaConnectionReady.fire();
            }
            console.log("Error initializing Network Connection: " + e);
        });
    });

    module.exports = me;

    });

    // file: lib/common/plugin/notification.js
    define("cordova/plugin/notification", function(require, exports, module) {

    var exec = require('cordova/exec');

    /**
     * Provides access to notifications on the device.
     */

    module.exports = {

        /**
         * Open a native alert dialog, with a customizable title and button text.
         *
         * @param {String} message              Message to print in the body of the alert
         * @param {Function} completeCallback   The callback that is called when user clicks on a button.
         * @param {String} title                Title of the alert dialog (default: Alert)
         * @param {String} buttonLabel          Label of the close button (default: OK)
         */
        alert: function(message, completeCallback, title, buttonLabel) {
            var _title = (title || "Alert");
            var _buttonLabel = (buttonLabel || "OK");
            exec(completeCallback, null, "Notification", "alert", [message, _title, _buttonLabel]);
        },

        /**
         * Open a native confirm dialog, with a customizable title and button text.
         * The result that the user selects is returned to the result callback.
         *
         * @param {String} message              Message to print in the body of the alert
         * @param {Function} resultCallback     The callback that is called when user clicks on a button.
         * @param {String} title                Title of the alert dialog (default: Confirm)
         * @param {String} buttonLabels         Comma separated list of the labels of the buttons (default: 'OK,Cancel')
         */
        confirm: function(message, resultCallback, title, buttonLabels) {
            var _title = (title || "Confirm");
            var _buttonLabels = (buttonLabels || "OK,Cancel");
            exec(resultCallback, null, "Notification", "confirm", [message, _title, _buttonLabels]);
        },

        /**
         * Causes the device to vibrate.
         *
         * @param {Integer} mills       The number of milliseconds to vibrate for.
         */
        vibrate: function(mills) {
            exec(null, null, "Notification", "vibrate", [mills]);
        },

        /**
         * Causes the device to beep.
         * On Android, the default notification ringtone is played "count" times.
         *
         * @param {Integer} count       The number of beeps.
         */
        beep: function(count) {
            exec(null, null, "Notification", "beep", [count]);
        }
    };

    });

    // file: lib/common/plugin/requestFileSystem.js
    define("cordova/plugin/requestFileSystem", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        FileError = require('cordova/plugin/FileError'),
        FileSystem = require('cordova/plugin/FileSystem'),
        exec = require('cordova/exec');

    /**
     * Request a file system in which to store application data.
     * @param type  local file system type
     * @param size  indicates how much storage space, in bytes, the application expects to need
     * @param successCallback  invoked with a FileSystem object
     * @param errorCallback  invoked if error occurs retrieving file system
     */
    var requestFileSystem = function(type, size, successCallback, errorCallback) {
        argscheck.checkArgs('nnFF', 'requestFileSystem', arguments);
        var fail = function(code) {
            errorCallback && errorCallback(new FileError(code));
        };

        if (type < 0 || type > 3) {
            fail(FileError.SYNTAX_ERR);
        } else {
            // if successful, return a FileSystem object
            var success = function(file_system) {
                if (file_system) {
                    if (successCallback) {
                        // grab the name and root from the file system object
                        var result = new FileSystem(file_system.name, file_system.root);
                        successCallback(result);
                    }
                }
                else {
                    // no FileSystem object returned
                    fail(FileError.NOT_FOUND_ERR);
                }
            };
            exec(success, fail, "File", "requestFileSystem", [type, size]);
        }
    };

    module.exports = requestFileSystem;

    });

    // file: lib/common/plugin/resolveLocalFileSystemURI.js
    define("cordova/plugin/resolveLocalFileSystemURI", function(require, exports, module) {

    var argscheck = require('cordova/argscheck'),
        DirectoryEntry = require('cordova/plugin/DirectoryEntry'),
        FileEntry = require('cordova/plugin/FileEntry'),
        FileError = require('cordova/plugin/FileError'),
        exec = require('cordova/exec');

    /**
     * Look up file system Entry referred to by local URI.
     * @param {DOMString} uri  URI referring to a local file or directory
     * @param successCallback  invoked with Entry object corresponding to URI
     * @param errorCallback    invoked if error occurs retrieving file system entry
     */
    module.exports = function(uri, successCallback, errorCallback) {
        argscheck.checkArgs('sFF', 'resolveLocalFileSystemURI', arguments);
        // error callback
        var fail = function(error) {
            errorCallback && errorCallback(new FileError(error));
        };
        // sanity check for 'not:valid:filename'
        if(!uri || uri.split(":").length > 2) {
            setTimeout( function() {
                fail(FileError.ENCODING_ERR);
            },0);
            return;
        }
        // if successful, return either a file or directory entry
        var success = function(entry) {
            var result;
            if (entry) {
                if (successCallback) {
                    // create appropriate Entry object
                    result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath) : new FileEntry(entry.name, entry.fullPath);
                    successCallback(result);
                }
            }
            else {
                // no Entry object returned
                fail(FileError.NOT_FOUND_ERR);
            }
        };

        exec(success, fail, "File", "resolveLocalFileSystemURI", [uri]);
    };

    });

    // file: lib/common/plugin/splashscreen.js
    define("cordova/plugin/splashscreen", function(require, exports, module) {

    var exec = require('cordova/exec');

    var splashscreen = {
        show:function() {
            exec(null, null, "SplashScreen", "show", []);
        },
        hide:function() {
            exec(null, null, "SplashScreen", "hide", []);
        }
    };

    module.exports = splashscreen;

    });

    // file: lib/common/utils.js
    define("cordova/utils", function(require, exports, module) {

    var utils = exports;

    /**
     * Defines a property getter / setter for obj[key].
     */
    utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {
        if (Object.defineProperty) {
            var desc = {
                get: getFunc,
                configurable: true
            };
            if (opt_setFunc) {
                desc.set = opt_setFunc;
            }
            Object.defineProperty(obj, key, desc);
        } else {
            obj.__defineGetter__(key, getFunc);
            if (opt_setFunc) {
                obj.__defineSetter__(key, opt_setFunc);
            }
        }
    };

    /**
     * Defines a property getter for obj[key].
     */
    utils.defineGetter = utils.defineGetterSetter;

    utils.arrayIndexOf = function(a, item) {
        if (a.indexOf) {
            return a.indexOf(item);
        }
        var len = a.length;
        for (var i = 0; i < len; ++i) {
            if (a[i] == item) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Returns whether the item was found in the array.
     */
    utils.arrayRemove = function(a, item) {
        var index = utils.arrayIndexOf(a, item);
        if (index != -1) {
            a.splice(index, 1);
        }
        return index != -1;
    };

    utils.typeName = function(val) {
        return Object.prototype.toString.call(val).slice(8, -1);
    };

    /**
     * Returns an indication of whether the argument is an array or not
     */
    utils.isArray = function(a) {
        return utils.typeName(a) == 'Array';
    };

    /**
     * Returns an indication of whether the argument is a Date or not
     */
    utils.isDate = function(d) {
        return utils.typeName(d) == 'Date';
    };

    /**
     * Does a deep clone of the object.
     */
    utils.clone = function(obj) {
        if(!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {
            return obj;
        }

        var retVal, i;

        if(utils.isArray(obj)){
            retVal = [];
            for(i = 0; i < obj.length; ++i){
                retVal.push(utils.clone(obj[i]));
            }
            return retVal;
        }

        retVal = {};
        for(i in obj){
            if(!(i in retVal) || retVal[i] != obj[i]) {
                retVal[i] = utils.clone(obj[i]);
            }
        }
        return retVal;
    };

    /**
     * Returns a wrapped version of the function
     */
    utils.close = function(context, func, params) {
        if (typeof params == 'undefined') {
            return function() {
                return func.apply(context, arguments);
            };
        } else {
            return function() {
                return func.apply(context, params);
            };
        }
    };

    /**
     * Create a UUID
     */
    utils.createUUID = function() {
        return UUIDcreatePart(4) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(6);
    };

    /**
     * Extends a child object from a parent object using classical inheritance
     * pattern.
     */
    utils.extend = (function() {
        // proxy used to establish prototype chain
        var F = function() {};
        // extend Child from Parent
        return function(Child, Parent) {
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.__super__ = Parent.prototype;
            Child.prototype.constructor = Child;
        };
    }());

    /**
     * Alerts a message in any available way: alert or console.log.
     */
    utils.alert = function(msg) {
        if (window.alert) {
            window.alert(msg);
        } else if (console && console.log) {
            console.log(msg);
        }
    };

    /**
     * Formats a string and arguments following it ala sprintf()
     *
     * see utils.vformat() for more information
     */
    utils.format = function(formatString /* ,... */) {
        var args = [].slice.call(arguments, 1);
        return utils.vformat(formatString, args);
    };

    /**
     * Formats a string and arguments following it ala vsprintf()
     *
     * format chars:
     *   %j - format arg as JSON
     *   %o - format arg as JSON
     *   %c - format arg as ''
     *   %% - replace with '%'
     * any other char following % will format it's
     * arg via toString().
     *
     * for rationale, see FireBug's Console API:
     *    http://getfirebug.com/wiki/index.php/Console_API
     */
    utils.vformat = function(formatString, args) {
        if (formatString === null || formatString === undefined) return "";
        if (arguments.length == 1) return formatString.toString();
        if (typeof formatString != "string") return formatString.toString();

        var pattern = /(.*?)%(.)(.*)/;
        var rest    = formatString;
        var result  = [];

        while (args.length) {
            var arg   = args.shift();
            var match = pattern.exec(rest);

            if (!match) break;

            rest = match[3];

            result.push(match[1]);

            if (match[2] == '%') {
                result.push('%');
                args.unshift(arg);
                continue;
            }

            result.push(formatted(arg, match[2]));
        }

        result.push(rest);

        return result.join('');
    };

    //------------------------------------------------------------------------------
    function UUIDcreatePart(length) {
        var uuidpart = "";
        for (var i=0; i<length; i++) {
            var uuidchar = parseInt((Math.random() * 256), 10).toString(16);
            if (uuidchar.length == 1) {
                uuidchar = "0" + uuidchar;
            }
            uuidpart += uuidchar;
        }
        return uuidpart;
    }

    //------------------------------------------------------------------------------
    function formatted(object, formatChar) {

        try {
            switch(formatChar) {
                case 'j':
                case 'o': return JSON.stringify(object);
                case 'c': return '';
            }
        }
        catch (e) {
            return "error JSON.stringify()ing argument: " + e;
        }

        if ((object === null) || (object === undefined)) {
            return Object.prototype.toString.call(object);
        }

        return object.toString();
    }

    });


    window.cordova = require('cordova');

    // file: lib/scripts/bootstrap.js

    (function (context) {
        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        if (context.navigator) {
            var CordovaNavigator = function() {};
            CordovaNavigator.prototype = context.navigator;
            context.navigator = new CordovaNavigator();
        }

        var channel = require("cordova/channel"),
            _self = {
                boot: function () {
                    /**
                     * Create all cordova objects once page has fully loaded and native side is ready.
                     */
                    channel.join(function() {
                        var builder = require('cordova/builder'),
                            base = require('cordova/common'),
                            platform = require('cordova/platform');

                        // Drop the common globals into the window object, but be nice and don't overwrite anything.
                        builder.buildIntoButDoNotClobber(base.defaults, context);
                        builder.buildIntoAndClobber(base.clobbers, context);
                        builder.buildIntoAndMerge(base.merges, context);

                        builder.buildIntoButDoNotClobber(platform.defaults, context);
                        builder.buildIntoAndClobber(platform.clobbers, context);
                        builder.buildIntoAndMerge(platform.merges, context);

                        // Call the platform-specific initialization
                        platform.initialize();

                        // Fire event to notify that all objects are created
                        channel.onCordovaReady.fire();

                        // Fire onDeviceReady event once all constructors have run and
                        // cordova info has been received from native side.
                        channel.join(function() {
                            require('cordova').fireDocumentEvent('deviceready');
                        }, channel.deviceReadyChannelsArray);

                    }, [ channel.onDOMContentLoaded, channel.onNativeReady ]);
                }
            };

        // boot up once native side is ready
        channel.onNativeReady.subscribe(_self.boot);

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if (window._nativeReady) {
            channel.onNativeReady.fire();
        }

    }(window));


    })();
    var PhoneGap = cordova;

  }
}

/**
 *     readAssetsFilePlugin.js
 *     readAssetsFilePlugin PhoneGap plugin (Android)
 *
 *     Created by Tanxiangjiang on 05/21/2013.
 */
Xut.Plugin.ReadAssetsFile = {

	readAssetsFileAction: function(path, successCallback, failureCallback) {
		if (GLOBALIFRAME) {
			//客户端插件调用
			if(CLIENTCONFIGT){
				return GLOBALCONTEXT.Xut.Plugin.ReadAssetsFile.readAssetsFileAction(path, successCallback, failureCallback)
			}
			//读库
			return GLOBALCONTEXT.ReadAssetsFile.readAssetsFileAction(path, successCallback, failureCallback);
		} else {
			//正常模式
			return cordova.exec(
				successCallback,
				failureCallback,
				'ReadAssetsFile',
				'readAssetsFileAction', [path]);
		}
	}

};
/**
 * Constructor
 */
Xut.Plugin.XXTEbookInit = {

	/**
	 * Play the passed in text as synthasized speech
	 *
	 * @param {DOMString} text
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	update: function(text, successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "update", [text]);
	},

	/**
	 * Starts up the XXTEbookInit Service
	 * @param {string} databaseName
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	startup: function(databaseName,successCallback, errorCallback) {
		if (GLOBALIFRAME) {
			return successCallback();
		} else {
			return cordova.exec(successCallback, errorCallback, "XxtebookInit", "startup", [databaseName]);
		}
	},

	/**
	 * Finds out if the language is currently supported by the XXTEbookInit service.
	 *
	 * @param {DOMSting} lang
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	getInfo: function(text, successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getInfo", [text]);
	},

	/**
	 * Finds out the current language of the XXTEbookInit service.
	 *
	 * @param {Object} successCallback
	 * @param {Object} errorCallback
	 */
	getChapter: function(chapterId, successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getChapter", [chapterId]);
	},



	getPercent: function(successCallback, errorCallback) {
		return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getPercent", []);
	}

};
/*
 * PhoneGap is available under *either* the terms of the modified BSD license *or* the
 * MIT License (2008). See http://opensource.org/licenses/alphabetical for full text.
 *
 * Copyright (c) 2005-2010, Nitobi Software Inc.
 * Copyright (c) 2011, IBM Corporation
 */

Xut.Plugin.WebView = {
	open: function(url, left, top, height, width, mode) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.WebView.open(url, left, top, height, width, mode);
		} else {
			return cordova.exec(null, null, "WebView", "open", [url, left, top, height, width, mode]);
		}
	},
	close: function() {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.WebView.close();
		} else {
			return cordova.exec(null, null, "WebView", "close", []);
		}
	},
	flag: function(successCallback) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.WebView.flag(successCallback);
		} else {
			return cordova.exec(successCallback, null, "WebView", "flag", []);
		}
	}
};
Xut.Plugin.VideoPlayer = {
    play: function(successCallback, errorCallback, videoname, type, left, top, height, width) {
        if (GLOBALIFRAME) {
             return GLOBALCONTEXT.VideoPlayer.play(successCallback, errorCallback, videoname, 0, left, top, height, width);
        } else {
            if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
                var config = {
                    paramA: videoname, //传入地址
                    paramB: type, //传入类型 0-本地 1-网络
                    paramC: left, //上下左右表示视频的位置
                    paramD: top,
                    paramE: height,
                    paramF: width
                };
                return cordova.exec(successCallback, errorCallback, 'VideoPlayer', 'play', [config]);
            } else {
                var param = new Array();
                param[0] = videoname;
                param[1] = type;
                param[2] = left;
                param[3] = top;
                param[4] = height;
                param[5] = width;
                return cordova.exec(successCallback, errorCallback, "VideoPlayer", "play", param);


            }
        }
    },

    close: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.close(successCallback);
        } else {
            return cordova.exec(successCallback, null, "VideoPlayer", "close", []);
        }
    },

    flag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALIFRAME.VideoPlayer.flag(successCallback);
        } else {
            return cordova.exec(successCallback, null, "VideoPlayer", "flag", []);
        }
    },

    errorFlag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.errorFlag(successCallback);
        } else {
            return cordova.exec(successCallback, null, 'VideoPlayer', 'errorFlag', []);
        }
    },

    pauseFlag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.pauseFlag(successCallback);
        } else {
            return cordova.exec(successCallback, null, 'VideoPlayer', 'pauseFlag', []);
        }
    },

    windowFlag: function(successCallback) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.windowFlag(successCallback);
        } else {
            return cordova.exec(successCallback, null, "VideoPlayer", "windowFlag", []);
        }
    },

    init: function(successCallback, infilename, outfilename) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.VideoPlayer.init(successCallback, infilename, outfilename);
        } else {
            return cordova.exec(successCallback, null, 'VideoPlayer', 'init', [infilename, outfilename]);
        }
    }
};
/**
 *     AppToAppPlugin.js
 *     AppToApp PhoneGap plugin (Android)
 *
 *     Created by Tanxiangjiang on 06/11/2012.
 */
Xut.Plugin.OpenApp = {

	openAppAction: function(appName, successCallback, failureCallback) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.OpenApp.openAppAction(appName, successCallback, failureCallback);
		} else {
			return cordova.exec(
				successCallback,
				failureCallback,
				'OpenApp',
				'openAppAction', [appName]);
		}
	}

};
/**
 *  tabletPlugin.js
 *  tablet PhoneGap plugin (Android)
 *
 *  Created by Tanxiangjiang on 06/16/2012
 */
Xut.Plugin.Tablet = {

  paintPath: function(successCallback, failureCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.paintPath(successCallback, failureCallback);
    } else {
      return cordova.exec(
        successCallback,
        failureCallback,
        'Tablet',
        'paintPath', []);
    }
  },

  openAction: function(path, filename, BitmapWidth, BitmapHeight, left, top, height, weight, successCallback, failureCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.openAction(path, filename, BitmapWidth, BitmapHeight, left, top, height, weight, successCallback, failureCallback);
    } else {
      return cordova.exec(successCallback,
        failureCallback,
        'Tablet',
        'openAction', [path, filename, BitmapWidth, BitmapHeight, left, top, height, weight]);
    }
  },

  closeAction: function(successCallback, failureCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.closeAction(successCallback, failureCallback);
    } else {
      return cordova.exec(successCallback,
        failureCallback,
        'Tablet',
        'closeAction', []);
    }
  }

};
/**
 * 	aptestPlugin.js
 * 	aptestPlugin PhoneGap plugin (IOS)
 *
 * 	Created by YangQingming on 2013-07-01.
 * 	appInfo  1:hide ; 0:show
 */
Xut.Plugin.statusbarPlugin = {
	setStatus: function(successfullCallback, failedCallback, appInfo) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.XXT.plugins.statusbarPlugin.setStatus(successfullCallback, failedCallback, appInfo);
		} else {
			return cordova.exec(successfullCallback, failedCallback, 'statusbarSet', 'set', [appInfo]);
		}
	}
};

/**
 *  iap.js
 *  iap PhoneGap plugin (IOS)
 *
 *  Created by YangQingming on 2013-07-01.
 **/

Xut.Plugin.iapPlugin = {
    restore: function(successfullCallback, failedCallback, appInfo) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.iapPlugin.restore(successfullCallback, failedCallback, appInfo);
        } else {
            return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'restoreGood', [appInfo]);
        }
    },

    buyGood: function(successfullCallback, failedCallback, appInfo) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.iapPlugin.buyGood(successfullCallback, failedCallback, appInfo);
        } else {
            return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'buyIAP', [appInfo]);
        }
    },

    selectInfo: function(successfullCallback, failedCallback, appInfo) {
        if (GLOBALIFRAME) {
            return GLOBALCONTEXT.iapPlugin.selectInfo(successfullCallback, failedCallback, appInfo);
        } else {
            return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'selectInfo', [appInfo]);
        }
    }
};



/**
 *  AppStoreLink.js
 *  AppStoreLink PhoneGap plugin (IOS)
 *
 *  Created by HuXi on 2014-05-29.
 **/

Xut.Plugin.appStoreLinkPlugin = {
	callProductView: function(successfullCallback, failedCallback, appId) {
	    if (GLOBALIFRAME) {
	        return GLOBALCONTEXT.appStoreLinkPlugin.callProductView(successfullCallback, failedCallback, appId);
	    } else {
	        return  cordova.exec(successfullCallback, failedCallback, "AppStoreLink", "callProductView", [appId]);
	    }
	}
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

Xut.Plugin.DownloadPlugin = {

     download: function(successfullCallback, failedCallback, json) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'download', [json]);
     },

     pause: function(successfullCallback, failedCallback, url) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'pause', [url]);
     },

     downloadContinue: function(successfullCallback, failedCallback, json) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'downloadContinue', [json]);
     },

     back: function(successfullCallback, failedCallback) {
          return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'back', []);
     }
}
//txt文本插件
Xut.Plugin.bookManagerPlugins = {
	getAppOpenWay: function(successfullCallback, failedCallback) {
		return cordova.exec(successfullCallback, failedCallback, 'XxtebookManager', 'getAppOpenWay', []);
	},
	pause: function(successfullCallback, failedCallback) {

		return cordova.exec(successfullCallback, failedCallback, 'XxtebookManager', 'pause', []);
	}
}
/**
 * 	unzipPlugin.js
 * 	Unzip PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 18/6/2013.
 */

Xut.Plugin.UnzipPlugin = {
	storageAction: function(json, successCallback, failureCallback) {
		return cordova.exec(successCallback, failureCallback, 'UnzipPlugin', 'storageAction', [json]);
	}
}
/**
 * 	readPlugin.js
 * 	Read PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 18/6/2013.
 */

     Xut.Plugin.ReadPlugin = {
         loadAction: function(id, type, successCallback, failureCallback) {
             return cordova.exec(successCallback, failureCallback, 'ReadPlugin', 'loadAction', [id, type]);
         }
     };



/**
 * 	deletePlugin.js
 * 	delete PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 4/8/2013.
 *  Last-Modified  11:03 4/8/2013
 */
Xut.Plugin.DeletePlugin = {
	deleteAction: function(successCallback, failureCallback, id) {
		if (GLOBALIFRAME) {
			return GLOBALCONTEXT.DeletePlugin.deleteAction(directory, successCallback, failureCallback);
		} else {
			return cordova.exec(successCallback, failureCallback, 'DeletePlugin', 'deleteAction', [id]);
		}
	}
}

;(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PIXI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
(function () {

    var async = {};
    function noop() {}
    function identity(v) {
        return v;
    }
    function toBool(v) {
        return !!v;
    }
    function notId(v) {
        return !v;
    }

    // global on the server, window in the browser
    var previous_async;

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self === 'object' && self.self === self && self ||
            typeof global === 'object' && global.global === global && global ||
            this;

    if (root != null) {
        previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        return function() {
            if (fn === null) throw new Error("Callback was already called.");
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function _once(fn) {
        return function() {
            if (fn === null) return;
            fn.apply(this, arguments);
            fn = null;
        };
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    // Ported from underscore.js isObject
    var _isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };

    function _isArrayLike(arr) {
        return _isArray(arr) || (
            // has a positive integer length property
            typeof arr.length === "number" &&
            arr.length >= 0 &&
            arr.length % 1 === 0
        );
    }

    function _arrayEach(arr, iterator) {
        var index = -1,
            length = arr.length;

        while (++index < length) {
            iterator(arr[index], index, arr);
        }
    }

    function _map(arr, iterator) {
        var index = -1,
            length = arr.length,
            result = Array(length);

        while (++index < length) {
            result[index] = iterator(arr[index], index, arr);
        }
        return result;
    }

    function _range(count) {
        return _map(Array(count), function (v, i) { return i; });
    }

    function _reduce(arr, iterator, memo) {
        _arrayEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    }

    function _forEachOf(object, iterator) {
        _arrayEach(_keys(object), function (key) {
            iterator(object[key], key);
        });
    }

    function _indexOf(arr, item) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) return i;
        }
        return -1;
    }

    var _keys = Object.keys || function (obj) {
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    function _keyIterator(coll) {
        var i = -1;
        var len;
        var keys;
        if (_isArrayLike(coll)) {
            len = coll.length;
            return function next() {
                i++;
                return i < len ? i : null;
            };
        } else {
            keys = _keys(coll);
            len = keys.length;
            return function next() {
                i++;
                return i < len ? keys[i] : null;
            };
        }
    }

    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
    // This accumulates the arguments passed into an array, after a given index.
    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
    function _restParam(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
            var length = Math.max(arguments.length - startIndex, 0);
            var rest = Array(length);
            for (var index = 0; index < length; index++) {
                rest[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, arguments[0], rest);
            }
            // Currently unused but handle cases outside of the switch statement:
            // var args = Array(startIndex + 1);
            // for (index = 0; index < startIndex; index++) {
            //     args[index] = arguments[index];
            // }
            // args[startIndex] = rest;
            // return func.apply(this, args);
        };
    }

    function _withoutIndex(iterator) {
        return function (value, index, callback) {
            return iterator(value, callback);
        };
    }

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////

    // capture the global reference to guard against fakeTimer mocks
    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

    var _delay = _setImmediate ? function(fn) {
        // not a direct alias for IE10 compatibility
        _setImmediate(fn);
    } : function(fn) {
        setTimeout(fn, 0);
    };

    if (typeof process === 'object' && typeof process.nextTick === 'function') {
        async.nextTick = process.nextTick;
    } else {
        async.nextTick = _delay;
    }
    async.setImmediate = _setImmediate ? _delay : async.nextTick;


    async.forEach =
    async.each = function (arr, iterator, callback) {
        return async.eachOf(arr, _withoutIndex(iterator), callback);
    };

    async.forEachSeries =
    async.eachSeries = function (arr, iterator, callback) {
        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
    };


    async.forEachLimit =
    async.eachLimit = function (arr, limit, iterator, callback) {
        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
    };

    async.forEachOf =
    async.eachOf = function (object, iterator, callback) {
        callback = _once(callback || noop);
        object = object || [];

        var iter = _keyIterator(object);
        var key, completed = 0;

        while ((key = iter()) != null) {
            completed += 1;
            iterator(object[key], key, only_once(done));
        }

        if (completed === 0) callback(null);

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            }
            // Check key is null in case iterator isn't exhausted
            // and done resolved synchronously.
            else if (key === null && completed <= 0) {
                callback(null);
            }
        }
    };

    async.forEachOfSeries =
    async.eachOfSeries = function (obj, iterator, callback) {
        callback = _once(callback || noop);
        obj = obj || [];
        var nextKey = _keyIterator(obj);
        var key = nextKey();
        function iterate() {
            var sync = true;
            if (key === null) {
                return callback(null);
            }
            iterator(obj[key], key, only_once(function (err) {
                if (err) {
                    callback(err);
                }
                else {
                    key = nextKey();
                    if (key === null) {
                        return callback(null);
                    } else {
                        if (sync) {
                            async.setImmediate(iterate);
                        } else {
                            iterate();
                        }
                    }
                }
            }));
            sync = false;
        }
        iterate();
    };



    async.forEachOfLimit =
    async.eachOfLimit = function (obj, limit, iterator, callback) {
        _eachOfLimit(limit)(obj, iterator, callback);
    };

    function _eachOfLimit(limit) {

        return function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            if (limit <= 0) {
                return callback(null);
            }
            var done = false;
            var running = 0;
            var errored = false;

            (function replenish () {
                if (done && running <= 0) {
                    return callback(null);
                }

                while (running < limit && !errored) {
                    var key = nextKey();
                    if (key === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iterator(obj[key], key, only_once(function (err) {
                        running -= 1;
                        if (err) {
                            callback(err);
                            errored = true;
                        }
                        else {
                            replenish();
                        }
                    }));
                }
            })();
        };
    }


    function doParallel(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOf, obj, iterator, callback);
        };
    }
    function doParallelLimit(fn) {
        return function (obj, limit, iterator, callback) {
            return fn(_eachOfLimit(limit), obj, iterator, callback);
        };
    }
    function doSeries(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOfSeries, obj, iterator, callback);
        };
    }

    function _asyncMap(eachfn, arr, iterator, callback) {
        callback = _once(callback || noop);
        arr = arr || [];
        var results = _isArrayLike(arr) ? [] : {};
        eachfn(arr, function (value, index, callback) {
            iterator(value, function (err, v) {
                results[index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    }

    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = doParallelLimit(_asyncMap);

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.inject =
    async.foldl =
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachOfSeries(arr, function (x, i, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };

    async.foldr =
    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, identity).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };

    async.transform = function (arr, memo, iterator, callback) {
        if (arguments.length === 3) {
            callback = iterator;
            iterator = memo;
            memo = _isArray(arr) ? [] : {};
        }

        async.eachOf(arr, function(v, k, cb) {
            iterator(memo, v, k, cb);
        }, function(err) {
            callback(err, memo);
        });
    };

    function _filter(eachfn, arr, iterator, callback) {
        var results = [];
        eachfn(arr, function (x, index, callback) {
            iterator(x, function (v) {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            });
        }, function () {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    }

    async.select =
    async.filter = doParallel(_filter);

    async.selectLimit =
    async.filterLimit = doParallelLimit(_filter);

    async.selectSeries =
    async.filterSeries = doSeries(_filter);

    function _reject(eachfn, arr, iterator, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iterator(value, function(v) {
                cb(!v);
            });
        }, callback);
    }
    async.reject = doParallel(_reject);
    async.rejectLimit = doParallelLimit(_reject);
    async.rejectSeries = doSeries(_reject);

    function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iterator, cb) {
            function done() {
                if (cb) cb(getResult(false, void 0));
            }
            function iteratee(x, _, callback) {
                if (!cb) return callback();
                iterator(x, function (v) {
                    if (cb && check(v)) {
                        cb(getResult(true, x));
                        cb = iterator = false;
                    }
                    callback();
                });
            }
            if (arguments.length > 3) {
                eachfn(arr, limit, iteratee, done);
            } else {
                cb = iterator;
                iterator = limit;
                eachfn(arr, iteratee, done);
            }
        };
    }

    async.any =
    async.some = _createTester(async.eachOf, toBool, identity);

    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

    async.all =
    async.every = _createTester(async.eachOf, notId, notId);

    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

    function _findGetResult(v, x) {
        return x;
    }
    async.detect = _createTester(async.eachOf, identity, _findGetResult);
    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                callback(null, _map(results.sort(comparator), function (x) {
                    return x.value;
                }));
            }

        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    };

    async.auto = function (tasks, concurrency, callback) {
        if (!callback) {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = _once(callback || noop);
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = remainingTasks;
        }

        var results = {};
        var runningTasks = 0;

        var listeners = [];
        function addListener(fn) {
            listeners.unshift(fn);
        }
        function removeListener(fn) {
            var idx = _indexOf(listeners, fn);
            if (idx >= 0) listeners.splice(idx, 1);
        }
        function taskComplete() {
            remainingTasks--;
            _arrayEach(listeners.slice(0), function (fn) {
                fn();
            });
        }

        addListener(function () {
            if (!remainingTasks) {
                callback(null, results);
            }
        });

        _arrayEach(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = _restParam(function(err, args) {
                runningTasks--;
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _forEachOf(results, function(val, rkey) {
                        safeResults[rkey] = val;
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            });
            var requires = task.slice(0, task.length - 1);
            // prevent dead-locks
            var len = requires.length;
            var dep;
            while (len--) {
                if (!(dep = tasks[requires[len]])) {
                    throw new Error('Has inexistant dependency');
                }
                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                    throw new Error('Has cyclic dependencies');
                }
            }
            function ready() {
                return runningTasks < concurrency && _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            }
            if (ready()) {
                runningTasks++;
                task[task.length - 1](taskCallback, results);
            }
            else {
                addListener(listener);
            }
            function listener() {
                if (ready()) {
                    runningTasks++;
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                }
            }
        });
    };



    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;

        var attempts = [];

        var opts = {
            times: DEFAULT_TIMES,
            interval: DEFAULT_INTERVAL
        };

        function parseTimes(acc, t){
            if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
            } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
            } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
            }
        }

        var length = arguments.length;
        if (length < 1 || length > 3) {
            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
        } else if (length <= 2 && typeof times === 'function') {
            callback = task;
            task = times;
        }
        if (typeof times !== 'function') {
            parseTimes(opts, times);
        }
        opts.callback = callback;
        opts.task = task;

        function wrappedTask(wrappedCallback, wrappedResults) {
            function retryAttempt(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            }

            function retryInterval(interval){
                return function(seriesCallback){
                    setTimeout(function(){
                        seriesCallback(null);
                    }, interval);
                };
            }

            while (opts.times) {

                var finalAttempt = !(opts.times-=1);
                attempts.push(retryAttempt(opts.task, finalAttempt));
                if(!finalAttempt && opts.interval > 0){
                    attempts.push(retryInterval(opts.interval));
                }
            }

            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || opts.callback)(data.err, data.result);
            });
        }

        // If a callback is passed, run this as a controll flow
        return opts.callback ? wrappedTask() : wrappedTask;
    };

    async.waterfall = function (tasks, callback) {
        callback = _once(callback || noop);
        if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        function wrapIterator(iterator) {
            return _restParam(function (err, args) {
                if (err) {
                    callback.apply(null, [err].concat(args));
                }
                else {
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    ensureAsync(iterator).apply(null, args);
                }
            });
        }
        wrapIterator(async.iterator(tasks))();
    };

    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = _isArrayLike(tasks) ? [] : {};

        eachfn(tasks, function (task, key, callback) {
            task(_restParam(function (err, args) {
                if (args.length <= 1) {
                    args = args[0];
                }
                results[key] = args;
                callback(err);
            }));
        }, function (err) {
            callback(err, results);
        });
    }

    async.parallel = function (tasks, callback) {
        _parallel(async.eachOf, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    };

    async.series = function(tasks, callback) {
        _parallel(async.eachOfSeries, tasks, callback);
    };

    async.iterator = function (tasks) {
        function makeCallback(index) {
            function fn() {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            }
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        }
        return makeCallback(0);
    };

    async.apply = _restParam(function (fn, args) {
        return _restParam(function (callArgs) {
            return fn.apply(
                null, args.concat(callArgs)
            );
        });
    });

    function _concat(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function (x, index, cb) {
            fn(x, function (err, y) {
                result = result.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, result);
        });
    }
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        callback = callback || noop;
        if (test()) {
            var next = _restParam(function(err, args) {
                if (err) {
                    callback(err);
                } else if (test.apply(this, args)) {
                    iterator(next);
                } else {
                    callback(null);
                }
            });
            iterator(next);
        } else {
            callback(null);
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        var calls = 0;
        return async.whilst(function() {
            return ++calls <= 1 || test.apply(this, arguments);
        }, iterator, callback);
    };

    async.until = function (test, iterator, callback) {
        return async.whilst(function() {
            return !test.apply(this, arguments);
        }, iterator, callback);
    };

    async.doUntil = function (iterator, test, callback) {
        return async.doWhilst(iterator, function() {
            return !test.apply(this, arguments);
        }, callback);
    };

    async.during = function (test, iterator, callback) {
        callback = callback || noop;

        var next = _restParam(function(err, args) {
            if (err) {
                callback(err);
            } else {
                args.push(check);
                test.apply(this, args);
            }
        });

        var check = function(err, truth) {
            if (err) {
                callback(err);
            } else if (truth) {
                iterator(next);
            } else {
                callback(null);
            }
        };

        test(check);
    };

    async.doDuring = function (iterator, test, callback) {
        var calls = 0;
        async.during(function(next) {
            if (calls++ < 1) {
                next(null, true);
            } else {
                test.apply(this, arguments);
            }
        }, iterator, callback);
    };

    function _queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new Error('Concurrency must not be zero');
        }
        function _insert(q, data, pos, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    callback: callback || noop
                };

                if (pos) {
                    q.tasks.unshift(item);
                } else {
                    q.tasks.push(item);
                }

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
            });
            async.setImmediate(q.process);
        }
        function _next(q, tasks) {
            return function(){
                workers -= 1;

                var removed = false;
                var args = arguments;
                _arrayEach(tasks, function (task) {
                    _arrayEach(workersList, function (worker, index) {
                        if (worker === task && !removed) {
                            workersList.splice(index, 1);
                            removed = true;
                        }
                    });

                    task.callback.apply(task, args);
                });
                if (q.tasks.length + workers === 0) {
                    q.drain();
                }
                q.process();
            };
        }

        var workers = 0;
        var workersList = [];
        var q = {
            tasks: [],
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            empty: noop,
            drain: noop,
            started: false,
            paused: false,
            push: function (data, callback) {
                _insert(q, data, false, callback);
            },
            kill: function () {
                q.drain = noop;
                q.tasks = [];
            },
            unshift: function (data, callback) {
                _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    while(workers < q.concurrency && q.tasks.length){
                        var tasks = q.payload ?
                            q.tasks.splice(0, q.payload) :
                            q.tasks.splice(0, q.tasks.length);

                        var data = _map(tasks, function (task) {
                            return task.data;
                        });

                        if (q.tasks.length === 0) {
                            q.empty();
                        }
                        workers += 1;
                        workersList.push(tasks[0]);
                        var cb = only_once(_next(q, tasks));
                        worker(data, cb);
                    }
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            workersList: function () {
                return workersList;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= resumeCount; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    }

    async.queue = function (worker, concurrency) {
        var q = _queue(function (items, cb) {
            worker(items[0], cb);
        }, concurrency, 1);

        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
            return a.priority - b.priority;
        }

        function _binarySearch(sequence, item, compare) {
            var beg = -1,
                end = sequence.length - 1;
            while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                    beg = mid;
                } else {
                    end = mid - 1;
                }
            }
            return beg;
        }

        function _insert(q, data, priority, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    priority: priority,
                    callback: typeof callback === 'function' ? callback : noop
                };

                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
                async.setImmediate(q.process);
            });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
            _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        return _queue(worker, 1, payload);
    };

    function _console_fn(name) {
        return _restParam(function (fn, args) {
            fn.apply(null, args.concat([_restParam(function (err, args) {
                if (typeof console === 'object') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _arrayEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            })]));
        });
    }
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || identity;
        var memoized = _restParam(function memoized(args) {
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.setImmediate(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([_restParam(function (args) {
                    memo[key] = args;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i].apply(null, args);
                    }
                })]));
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
        return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    };

    function _times(mapper) {
        return function (count, iterator, callback) {
            mapper(_range(count), iterator, callback);
        };
    }

    async.times = _times(async.map);
    async.timesSeries = _times(async.mapSeries);
    async.timesLimit = function (count, limit, iterator, callback) {
        return async.mapLimit(_range(count), limit, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return _restParam(function (args) {
            var that = this;

            var callback = args[args.length - 1];
            if (typeof callback == 'function') {
                args.pop();
            } else {
                callback = noop;
            }

            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
                    cb(err, nextargs);
                })]));
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        });
    };

    async.compose = function (/* functions... */) {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };


    function _applyEach(eachfn) {
        return _restParam(function(fns, args) {
            var go = _restParam(function(args) {
                var that = this;
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            });
            if (args.length) {
                return go.apply(this, args);
            }
            else {
                return go;
            }
        });
    }

    async.applyEach = _applyEach(async.eachOf);
    async.applyEachSeries = _applyEach(async.eachOfSeries);


    async.forever = function (fn, callback) {
        var done = only_once(callback || noop);
        var task = ensureAsync(fn);
        function next(err) {
            if (err) {
                return done(err);
            }
            task(next);
        }
        next();
    };

    function ensureAsync(fn) {
        return _restParam(function (args) {
            var callback = args.pop();
            args.push(function () {
                var innerArgs = arguments;
                if (sync) {
                    async.setImmediate(function () {
                        callback.apply(null, innerArgs);
                    });
                } else {
                    callback.apply(null, innerArgs);
                }
            });
            var sync = true;
            fn.apply(this, args);
            sync = false;
        });
    }

    async.ensureAsync = ensureAsync;

    async.constant = _restParam(function(values) {
        var args = [null].concat(values);
        return function (callback) {
            return callback.apply(this, args);
        };
    });

    async.wrapSync =
    async.asyncify = function asyncify(func) {
        return _restParam(function (args) {
            var callback = args.pop();
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (_isObject(result) && typeof result.then === "function") {
                result.then(function(value) {
                    callback(null, value);
                })["catch"](function(err) {
                    callback(err.message ? err : new Error(err));
                });
            } else {
                callback(null, result);
            }
        });
    };

    // Node.js
    if (typeof module === 'object' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3}],2:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],7:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":5,"./encode":6}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":4,"querystring":7}],9:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var sum = 0,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        // a self-intersection where edge (v[i-1],v[i]) intersects (v[i+1],v[i+2])
        if (intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= m.x &&
                pointInTriangle(hy < m.y ? hx : qx, hy, m.x, m.y, hy < m.y ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

},{}],10:[function(require,module,exports){
'use strict';

//
// We store our EE objects in a plain object whose properties are event names.
// If `Object.create(null)` is not supported we prefix the event names with a
// `~` to make sure that the built-in object properties are not overridden or
// used as an attack vector.
// We also assume that `Object.create(null)` is available when the event name
// is an ES6 Symbol.
//
var prefix = typeof Object.create !== 'function' ? '~' : false;

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @param {Boolean} exists We only need to know if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events && this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Mixed} context Only remove listeners matching this context.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once && !listeners.once)
        || (context && listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i < length; i++) {
        if (
             listeners[i].fn !== fn
          || (once && !listeners[i].once)
          || (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],11:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],12:[function(require,module,exports){
module.exports={
  "name": "pixi.js",
  "version": "3.0.9",
  "description": "Pixi.js is a fast lightweight 2D library that works across all devices.",
  "author": "Mat Groves",
  "contributors": [
    "Chad Engler <chad@pantherdev.com>",
    "Richard Davey <rdavey@gmail.com>"
  ],
  "main": "./src/index.js",
  "homepage": "http://goodboydigital.com/",
  "bugs": "https://github.com/pixijs/pixi.js/issues",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/pixijs/pixi.js.git"
  },
  "scripts": {
    "start": "gulp && gulp watch",
    "test": "gulp && testem ci",
    "build": "gulp",
    "docs": "jsdoc -c ./gulp/util/jsdoc.conf.json -R README.md"
  },
  "files": [
    "bin/",
    "src/",
    "CONTRIBUTING.md",
    "LICENSE",
    "package.json",
    "README.md"
  ],
  "dependencies": {
    "async": "^1.5.0",
    "brfs": "^1.4.1",
    "earcut": "^2.0.7",
    "eventemitter3": "^1.1.1",
    "object-assign": "^4.0.1",
    "resource-loader": "^1.6.4"
  },
  "devDependencies": {
    "browserify": "^11.1.0",
    "chai": "^3.2.0",
    "del": "^2.0.2",
    "gulp": "^3.9.0",
    "gulp-cached": "^1.1.0",
    "gulp-concat": "^2.6.0",
    "gulp-debug": "^2.1.0",
    "gulp-header": "^1.7.1",
    "gulp-jshint": "^1.11.2",
    "gulp-mirror": "^0.4.0",
    "gulp-plumber": "^1.0.1",
    "gulp-rename": "^1.2.2",
    "gulp-sourcemaps": "^1.5.2",
    "gulp-uglify": "^1.4.1",
    "gulp-util": "^3.0.6",
    "jaguarjs-jsdoc": "git+https://github.com/davidshimjs/jaguarjs-jsdoc.git",
    "jsdoc": "^3.3.2",
    "jshint-summary": "^0.4.0",
    "minimist": "^1.2.0",
    "mocha": "^2.3.2",
    "require-dir": "^0.3.0",
    "run-sequence": "^1.1.2",
    "testem": "^0.9.4",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.1.0",
    "watchify": "^3.4.0"
  },
  "browserify": {
    "transform": [
      "brfs"
    ]
  }
}

},{}],13:[function(require,module,exports){
var core = require('../core');

// add some extra variables to the container..
Object.assign(
    core.DisplayObject.prototype,
    require('./accessibleTarget')
);


/**
 * The Accessibility manager reacreates the ability to tab and and have content read by screen readers. This is very important as it can possibly help people with disabilities access pixi content.
 * Much like interaction any DisplayObject can be made accessible. This manager will map the events as if the mouse was being used, minimizing the efferot required to implement.
 *
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer
 */
function AccessibilityManager(renderer)
{
	// first we create a div that will sit over the pixi element. This is where the div overlays will go.
    var div = document.createElement('div');
    
    div.style.width = 100 + 'px';
    div.style.height = 100 + 'px';
    div.style.position = 'absolute';
    div.style.top = 0;
    div.style.left = 0;
   //
    div.style.zIndex = 2;
   	
   	/**
   	 * This is the dom element that will sit over the pixi element. This is where the div overlays will go.
   	 * 
   	 * @type {HTMLElement}
   	 * @private
   	 */
   	this.div = div;

   	/**
   	 * A simple pool for storing divs.
   	 * 
   	 * @type {Array}
   	 * @private
   	 */
 	this.pool = [];

 	/**
 	 * This is a tick used to check if an object is no longer being rendered.
 	 * 
 	 * @type {Number}
 	 * @private
 	 */
   	this.renderId = 0;

   	/**
   	 * Setting this to true will visually show the divs
   	 * 
   	 * @type {Boolean}
   	 */
   	this.debug = false;

  	/**
     * The renderer this accessibility manager works for.
     *
     * @member {PIXI.SystemRenderer}
     */
   	this.renderer = renderer;

   	/**
     * The array of currently active accessible items.
     *
     * @member {Array}
     * @private
     */
   	this.children = [];
   	
   	/**
     * pre bind the functions..
     */
   	this._onKeyDown = this._onKeyDown.bind(this);
   	this._onMouseMove = this._onMouseMove.bind(this);
   	
   	/**
     * stores the state of the manager. If there are no accessible objects or the mouse is moving the will be false.
     *
     * @member {Array}
     * @private
     */
   	this.isActive = false;


   	// let listen for tab.. once pressed we can fire up and show the accessibility layer
   	window.addEventListener('keydown', this._onKeyDown, false);
}


AccessibilityManager.prototype.constructor = AccessibilityManager;
module.exports = AccessibilityManager;

/**
 * Activating will cause the Accessibility layer to be shown. This is called when a user preses the tab key
 * @private
 */
AccessibilityManager.prototype.activate = function()
{
	if(this.isActive)
	{
		return;
	}

	this.isActive = true;

	window.document.addEventListener('mousemove', this._onMouseMove, true);
	window.removeEventListener('keydown', this._onKeyDown, false);

	this.renderer.on('postrender', this.update, this);

	this.renderer.view.parentNode.appendChild(this.div);	
};

/**
 * Deactivating will cause the Accessibility layer to be hidden. This is called when a user moves the mouse
 * @private
 */
AccessibilityManager.prototype.deactivate = function()
{
	if(!this.isActive)
	{
		return;
	}

	this.isActive = false;

	window.document.removeEventListener('mousemove', this._onMouseMove);
	window.addEventListener('keydown', this._onKeyDown, false);

	this.renderer.off('postrender', this.update);

	this.div.parentNode.removeChild(this.div);

};

/**
 * This recursive function will run throught he scene graph and add any new accessible objects to the DOM layer.
 * @param element {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the DisplayObject to check.
 * @private
 */
AccessibilityManager.prototype.updateAccessibleObjects = function(displayObject)
{
	if(!displayObject.visible)
	{
		return;
	}

	if(displayObject.accessible && displayObject.interactive)
	{
		if(!displayObject._accessibleActive)
		{
			this.addChild(displayObject);
		}
	   	
	   	displayObject.renderId = this.renderId;
	}

	var children = displayObject.children;

	for (var i = children.length - 1; i >= 0; i--) {
		
		this.updateAccessibleObjects(children[i]);
	}
};


/**
 * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects
 * @private
 */
AccessibilityManager.prototype.update = function()
{

	// update children...
	this.updateAccessibleObjects(this.renderer._lastObjectRendered);

	var rect = this.renderer.view.getBoundingClientRect();
	var sx = rect.width  / this.renderer.width;
	var sy = rect.height / this.renderer.height;

	var div = this.div;

	div.style.left = rect.left + 'px';
	div.style.top = rect.top + 'px';
	div.style.width = this.renderer.width + 'px';
	div.style.height = this.renderer.height + 'px';

	for (var i = 0; i < this.children.length; i++)
	{

		var child = this.children[i];

		if(child.renderId !== this.renderId)
		{
			child._accessibleActive = false;

            core.utils.removeItems(this.children, i, 1);
			this.div.removeChild( child._accessibleDiv );
			this.pool.push(child._accessibleDiv);
			child._accessibleDiv = null;

			i--;

			if(this.children.length === 0)
			{
				this.deactivate();
			}
		}
		else
		{
			// map div to display..
			div = child._accessibleDiv;
			var hitArea = child.hitArea;
			var wt = child.worldTransform;

			if(child.hitArea)
			{
				div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + 'px';
				div.style.top =  ((wt.ty + (hitArea.y * wt.d)) * sy) +  'px';

				div.style.width = (hitArea.width * wt.a * sx) + 'px';
				div.style.height = (hitArea.height * wt.d * sy) + 'px';
			
			}
			else
			{
				hitArea = child.getBounds();

				this.capHitArea(hitArea);

				div.style.left = (hitArea.x * sx) + 'px';
				div.style.top =  (hitArea.y * sy) +  'px';

				div.style.width = (hitArea.width * sx) + 'px';
				div.style.height = (hitArea.height * sy) + 'px';
			}		
		}
	}

	// increment the render id..
	this.renderId++;
};

AccessibilityManager.prototype.capHitArea = function (hitArea)
{
    if (hitArea.x < 0)
    {
        hitArea.width += hitArea.x;
        hitArea.x = 0;
    }

    if (hitArea.y < 0)
    {
        hitArea.height += hitArea.y;
        hitArea.y = 0;
    }

    if ( hitArea.x + hitArea.width > this.renderer.width )
    {
        hitArea.width = this.renderer.width - hitArea.x;
    }

    if ( hitArea.y + hitArea.height > this.renderer.height )
    {
        hitArea.height = this.renderer.height - hitArea.y;
    }
};


/**
 * Adds a DisplayObject to the accessibility manager
 * @private
 */
AccessibilityManager.prototype.addChild = function(displayObject)
{
//	this.activate();
	
	var div = this.pool.pop();

	if(!div)
	{
		div = document.createElement('button'); 

	    div.style.width = 100 + 'px';
	    div.style.height = 100 + 'px';
	    div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
	    div.style.position = 'absolute';
	    div.style.zIndex = 2;
	    div.style.borderStyle = 'none';

	    
	    div.addEventListener('click', this._onClick.bind(this));
	    div.addEventListener('focus', this._onFocus.bind(this));
	    div.addEventListener('focusout', this._onFocusOut.bind(this));
	}
	   	



	div.title = displayObject.accessibleTitle || 'displayObject ' + this.tabIndex;

	//
	
	displayObject._accessibleActive = true;
	displayObject._accessibleDiv = div;
	div.displayObject = displayObject;


	this.children.push(displayObject);
	this.div.appendChild( displayObject._accessibleDiv );
	displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
};


/**
 * Maps the div button press to pixi's InteractionManager (click)
 * @private
 */
AccessibilityManager.prototype._onClick = function(e)
{
	var interactionManager = this.renderer.plugins.interaction;
	interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
};

/**
 * Maps the div focus events to pixis InteractionManager (mouseover)
 * @private
 */
AccessibilityManager.prototype._onFocus = function(e)
{
	var interactionManager = this.renderer.plugins.interaction;
	interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
};

/**
 * Maps the div focus events to pixis InteractionManager (mouseout)
 * @private
 */
AccessibilityManager.prototype._onFocusOut = function(e)
{
	var interactionManager = this.renderer.plugins.interaction;
	interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
};

/**
 * Is called when a key is pressed
 *
 * @private
 */
AccessibilityManager.prototype._onKeyDown = function(e)
{
	if(e.keyCode !== 9)
	{
		return;
	}

	this.activate();
};

/**
 * Is called when the mouse moves across the renderer element
 *
 * @private
 */
AccessibilityManager.prototype._onMouseMove = function()
{
	this.deactivate();
};


/**
 * Destroys the accessibility manager
 *
 */
AccessibilityManager.prototype.destroy = function () 
{
	this.div = null;

	for (var i = 0; i < this.children.length; i++)
	{
		this.children[i].div = null;
	}

	
	window.document.removeEventListener('mousemove', this._onMouseMove);
	window.removeEventListener('keydown', this._onKeyDown);
		
	this.pool = null;
	this.children = null;
	this.renderer = null;

};

core.WebGLRenderer.registerPlugin('accessibility', AccessibilityManager);
core.CanvasRenderer.registerPlugin('accessibility', AccessibilityManager);


},{"../core":23,"./accessibleTarget":14}],14:[function(require,module,exports){
/**
 * Default property values of accessible objects
 * used by {@link PIXI.accessibility.AccessibilityManager}.
 *
 * @mixin
 * @memberof PIXI
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.accessibility.accessibleTarget
 *      );
 */
var accessibleTarget = {
    
    /**
     * @todo Needs docs.
     */
    accessible:false,

    /**
     * @todo Needs docs.
     */
    accessibleTitle:null,

    /**
     * @todo Needs docs.
     */
    tabIndex:0,

    /**
     * @todo Needs docs.
     */
    _accessibleActive:false,

    /**
     * @todo Needs docs.
     */
    _accessibleDiv:false

};

module.exports = accessibleTarget;

},{}],15:[function(require,module,exports){
/**
 * @file        Main export of the PIXI accessibility library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.interaction
 */
module.exports = {
    accessibleTarget:     require('./accessibleTarget'),
    AccessibilityManager: require('./AccessibilityManager')
};

},{"./AccessibilityManager":13,"./accessibleTarget":14}],16:[function(require,module,exports){
/**
 * Constant values used in pixi
 *
 * @lends PIXI
 */
var CONST = {
    /**
     * String of the current PIXI version
     *
     * @static
     * @constant
     * @property {string} VERSION
     */
    VERSION: require('../../package.json').version,

    /**
     * @property {number} PI_2 - Two Pi
     * @constant
     * @static
     */
    PI_2: Math.PI * 2,

    /**
     * @property {number} RAD_TO_DEG - Constant conversion factor for converting radians to degrees
     * @constant
     * @static
     */
    RAD_TO_DEG: 180 / Math.PI,

    /**
     * @property {Number} DEG_TO_RAD - Constant conversion factor for converting degrees to radians
     * @constant
     * @static
     */
    DEG_TO_RAD: Math.PI / 180,

    /**
     * Target frames per millisecond.
     *
     * @static
     * @constant
     * @property {number} TARGET_FPMS=0.06
     */
    TARGET_FPMS: 0.06,

    /**
     * Constant to identify the Renderer Type.
     *
     * @static
     * @constant
     * @property {object} RENDERER_TYPE
     * @property {number} RENDERER_TYPE.UNKNOWN
     * @property {number} RENDERER_TYPE.WEBGL
     * @property {number} RENDERER_TYPE.CANVAS
     */
    RENDERER_TYPE: {
        UNKNOWN:    0,
        WEBGL:      1,
        CANVAS:     2
    },

    /**
     * Various blend modes supported by PIXI. IMPORTANT - The WebGL renderer only supports
     * the NORMAL, ADD, MULTIPLY and SCREEN blend modes. Anything else will silently act like
     * NORMAL.
     *
     * @static
     * @constant
     * @property {object} BLEND_MODES
     * @property {number} BLEND_MODES.NORMAL
     * @property {number} BLEND_MODES.ADD
     * @property {number} BLEND_MODES.MULTIPLY
     * @property {number} BLEND_MODES.SCREEN
     * @property {number} BLEND_MODES.OVERLAY
     * @property {number} BLEND_MODES.DARKEN
     * @property {number} BLEND_MODES.LIGHTEN
     * @property {number} BLEND_MODES.COLOR_DODGE
     * @property {number} BLEND_MODES.COLOR_BURN
     * @property {number} BLEND_MODES.HARD_LIGHT
     * @property {number} BLEND_MODES.SOFT_LIGHT
     * @property {number} BLEND_MODES.DIFFERENCE
     * @property {number} BLEND_MODES.EXCLUSION
     * @property {number} BLEND_MODES.HUE
     * @property {number} BLEND_MODES.SATURATION
     * @property {number} BLEND_MODES.COLOR
     * @property {number} BLEND_MODES.LUMINOSITY
     */
    BLEND_MODES: {
        NORMAL:         0,
        ADD:            1,
        MULTIPLY:       2,
        SCREEN:         3,
        OVERLAY:        4,
        DARKEN:         5,
        LIGHTEN:        6,
        COLOR_DODGE:    7,
        COLOR_BURN:     8,
        HARD_LIGHT:     9,
        SOFT_LIGHT:     10,
        DIFFERENCE:     11,
        EXCLUSION:      12,
        HUE:            13,
        SATURATION:     14,
        COLOR:          15,
        LUMINOSITY:     16
    },

    /**
     * Various webgl draw modes. These can be used to specify which GL drawMode to use
     * under certain situations and renderers.
     *
     * @static
     * @constant
     * @property {object} DRAW_MODES
     * @property {number} DRAW_MODES.POINTS
     * @property {number} DRAW_MODES.LINES
     * @property {number} DRAW_MODES.LINE_LOOP
     * @property {number} DRAW_MODES.LINE_STRIP
     * @property {number} DRAW_MODES.TRIANGLES
     * @property {number} DRAW_MODES.TRIANGLE_STRIP
     * @property {number} DRAW_MODES.TRIANGLE_FAN
     */
    DRAW_MODES: {
        POINTS:         0,
        LINES:          1,
        LINE_LOOP:      2,
        LINE_STRIP:     3,
        TRIANGLES:      4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN:   6
    },

    /**
     * The scale modes that are supported by pixi.
     *
     * The DEFAULT scale mode affects the default scaling mode of future operations.
     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
     *
     * @static
     * @constant
     * @property {object} SCALE_MODES
     * @property {number} SCALE_MODES.DEFAULT=LINEAR
     * @property {number} SCALE_MODES.LINEAR Smooth scaling
     * @property {number} SCALE_MODES.NEAREST Pixelating scaling
     */
    SCALE_MODES: {
        DEFAULT:    0,
        LINEAR:     0,
        NEAREST:    1
    },

    /**
     * The prefix that denotes a URL is for a retina asset
     *
     * @static
     * @constant
     * @property {string} RETINA_PREFIX
     */
    //example: '@2x',
    RETINA_PREFIX: /@(.+)x/,

    RESOLUTION:1,

    FILTER_RESOLUTION:1,

    /**
     * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
     * or {@link PIXI.CanvasRenderer}.
     *
     * @static
     * @constant
     * @property {object} DEFAULT_RENDER_OPTIONS
     * @property {HTMLCanvasElement} DEFAULT_RENDER_OPTIONS.view=null
     * @property {boolean} DEFAULT_RENDER_OPTIONS.transparent=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.antialias=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.forceFXAA=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.preserveDrawingBuffer=false
     * @property {number} DEFAULT_RENDER_OPTIONS.resolution=1
     * @property {number} DEFAULT_RENDER_OPTIONS.backgroundColor=0x000000
     * @property {boolean} DEFAULT_RENDER_OPTIONS.clearBeforeRender=true
     * @property {boolean} DEFAULT_RENDER_OPTIONS.autoResize=false
     */
    DEFAULT_RENDER_OPTIONS: {
        view: null,
        resolution: 1,
        antialias: false,
        forceFXAA: false,
        autoResize: false,
        transparent: false,
        backgroundColor: 0x000000,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        roundPixels: false
    },

    /**
     * Constants that identify shapes, mainly to prevent `instanceof` calls.
     *
     * @static
     * @constant
     * @property {object} SHAPES
     * @property {object} SHAPES.POLY=0
     * @property {object} SHAPES.RECT=1
     * @property {object} SHAPES.CIRC=2
     * @property {object} SHAPES.ELIP=3
     * @property {object} SHAPES.RREC=4
     */
    SHAPES: {
        POLY: 0,
        RECT: 1,
        CIRC: 2,
        ELIP: 3,
        RREC: 4
    },

    // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
    // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
    SPRITE_BATCH_SIZE: 2000 //nice balance between mobile and desktop machines
};

module.exports = CONST;

},{"../../package.json":12}],17:[function(require,module,exports){
var math = require('../math'),
    utils = require('../utils'),
    DisplayObject = require('./DisplayObject'),
    RenderTexture = require('../textures/RenderTexture'),
    _tempMatrix = new math.Matrix();

/**
 * A Container represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 *```js
 * var container = new PIXI.Container();
 * container.addChild(sprite);
 * ```
 * @class
 * @extends PIXI.DisplayObject
 * @memberof PIXI
 */
function Container()
{
    DisplayObject.call(this);

    /**
     * The array of children of this container.
     *
     * @member {PIXI.DisplayObject[]}
     * @readonly
     */
    this.children = [];
}

// constructor
Container.prototype = Object.create(DisplayObject.prototype);
Container.prototype.constructor = Container;
module.exports = Container;

Object.defineProperties(Container.prototype, {
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Container#
     */
    width: {
        get: function ()
        {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function (value)
        {

            var width = this.getLocalBounds().width;

            if (width !== 0)
            {
                this.scale.x = value / width;
            }
            else
            {
                this.scale.x = 1;
            }


            this._width = value;
        }
    },

    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Container#
     */
    height: {
        get: function ()
        {
            return  this.scale.y * this.getLocalBounds().height;
        },
        set: function (value)
        {

            var height = this.getLocalBounds().height;

            if (height !== 0)
            {
                this.scale.y = value / height ;
            }
            else
            {
                this.scale.y = 1;
            }

            this._height = value;
        }
    }
});

/**
 * Overridable method that can be used by Container subclasses whenever the children array is modified
 *
 * @private
 */
Container.prototype.onChildrenChange = function () {};

/**
 * Adds a child to the container.
 * 
 * You can also add multple items like so: myContainer.addChild(thinkOne, thingTwo, thingThree)
 * @param child {PIXI.DisplayObject} The DisplayObject to add to the container
 * @return {PIXI.DisplayObject} The child that was added.
 */
Container.prototype.addChild = function (child)
{ 
    var argumentsLength = arguments.length;

    // if there is only one argument we can bypass looping through the them
    if(argumentsLength > 1)
    {
        // loop through the arguments property and add all children
        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
        for (var i = 0; i < argumentsLength; i++)
        {
            this.addChild( arguments[i] );
        }
    }     
    else
    {
        // if the child has a parent then lets remove it as Pixi objects can only exist in one place
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;
        
        this.children.push(child);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(this.children.length-1);
        child.emit('added', this);
    }

    return child;
};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @param child {PIXI.DisplayObject} The child to add
 * @param index {number} The index to place the child in
 * @return {PIXI.DisplayObject} The child that was added.
 */
Container.prototype.addChildAt = function (child, index)
{
    if (index >= 0 && index <= this.children.length)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('added', this);

        return child;
    }
    else
    {
        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * Swaps the position of 2 Display Objects within this container.
 *
 * @param child {PIXI.DisplayObject}
 * @param child2 {PIXI.DisplayObject}
 */
Container.prototype.swapChildren = function (child, child2)
{
    if (child === child2)
    {
        return;
    }

    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);

    if (index1 < 0 || index2 < 0)
    {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be children of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
};

/**
 * Returns the index position of a child DisplayObject instance
 *
 * @param child {PIXI.DisplayObject} The DisplayObject instance to identify
 * @return {number} The index position of the child display object to identify
 */
Container.prototype.getChildIndex = function (child)
{
    var index = this.children.indexOf(child);

    if (index === -1)
    {
        throw new Error('The supplied DisplayObject must be a child of the caller');
    }

    return index;
};

/**
 * Changes the position of an existing child in the display object container
 *
 * @param child {PIXI.DisplayObject} The child DisplayObject instance for which you want to change the index number
 * @param index {number} The resulting index number for the child display object
 */
Container.prototype.setChildIndex = function (child, index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('The supplied index is out of bounds');
    }

    var currentIndex = this.getChildIndex(child);

    utils.removeItems(this.children, currentIndex, 1); // remove from old position
    this.children.splice(index, 0, child); //add at new position
    this.onChildrenChange(index);
};

/**
 * Returns the child at the specified index
 *
 * @param index {number} The index to get the child at
 * @return {PIXI.DisplayObject} The child at the given index, if any.
 */
Container.prototype.getChildAt = function (index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject is not a child of the caller');
    }

    return this.children[index];
};

/**
 * Removes a child from the container.
 *
 * @param child {PIXI.DisplayObject} The DisplayObject to remove
 * @return {PIXI.DisplayObject} The child that was removed.
 */
Container.prototype.removeChild = function (child)
{
    var argumentsLength = arguments.length;

    // if there is only one argument we can bypass looping through the them
    if(argumentsLength > 1)
    {
        // loop through the arguments property and add all children
        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
        for (var i = 0; i < argumentsLength; i++)
        {
            this.removeChild( arguments[i] );
        }
    }     
    else
    {   
        var index = this.children.indexOf(child);

        if (index === -1)
        {
            return;
        }

        child.parent = null;
        utils.removeItems(this.children, index, 1);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('removed', this);
    }

    return child;
};

/**
 * Removes a child from the specified index position.
 *
 * @param index {number} The index to get the child from
 * @return {PIXI.DisplayObject} The child that was removed.
 */
Container.prototype.removeChildAt = function (index)
{
    var child = this.getChildAt(index);

    child.parent = null;
    utils.removeItems(this.children, index, 1);

    // TODO - lets either do all callbacks or all events.. not both!
    this.onChildrenChange(index);
    child.emit('removed', this);

    return child;
};

/**
 * Removes all children from this container that are within the begin and end indexes.
 *
 * @param beginIndex {number} The beginning position. Default value is 0.
 * @param endIndex {number} The ending position. Default value is size of the container.
 */
Container.prototype.removeChildren = function (beginIndex, endIndex)
{
    var begin = beginIndex || 0;
    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
    var range = end - begin;
    var removed, i;

    if (range > 0 && range <= end)
    {
        removed = this.children.splice(begin, range);

        for (i = 0; i < removed.length; ++i)
        {
            removed[i].parent = null;
        }

        this.onChildrenChange(beginIndex);

        for (i = 0; i < removed.length; ++i)
        {
            removed[i].emit('removed', this);
        }

        return removed;
    }
    else if (range === 0 && this.children.length === 0)
    {
        return [];
    }
    else
    {
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
};

/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
 * @param resolution {number} The resolution of the texture being generated
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} a texture of the display object
 */
Container.prototype.generateTexture = function (renderer, resolution, scaleMode)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/*
 * Updates the transform on all children of this container for rendering
 *
 * @private
 */
Container.prototype.updateTransform = function ()
{
    if (!this.visible)
    {
        return;
    }

    this.displayObjectUpdateTransform();

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }
};

// performance increase to avoid using call.. (10x faster)
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

/**
 * Retrieves the bounds of the Container as a rectangle. The bounds calculation takes all visible children into consideration.
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */
Container.prototype.getBounds = function ()
{
    if(!this._currentBounds)
    {

        if (this.children.length === 0)
        {
            return math.Rectangle.EMPTY;
        }

        // TODO the bounds have already been calculated this render session so return what we have

        var minX = Infinity;
        var minY = Infinity;

        var maxX = -Infinity;
        var maxY = -Infinity;

        var childBounds;
        var childMaxX;
        var childMaxY;

        var childVisible = false;

        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            var child = this.children[i];

            if (!child.visible)
            {
                continue;
            }

            childVisible = true;

            childBounds = this.children[i].getBounds();

            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;

            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;

            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
        }

        if (!childVisible)
        {
            return math.Rectangle.EMPTY;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.y = minY;
        bounds.width = maxX - minX;
        bounds.height = maxY - minY;

        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

Container.prototype.containerGetBounds = Container.prototype.getBounds;

/**
 * Retrieves the non-global local bounds of the Container as a rectangle.
 * The calculation takes all visible children into consideration.
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */
Container.prototype.getLocalBounds = function ()
{
    var matrixCache = this.worldTransform;

    this.worldTransform = math.Matrix.IDENTITY;

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }

    this.worldTransform = matrixCache;

    this._currentBounds = null;

    return this.getBounds( math.Matrix.IDENTITY );
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 */
Container.prototype.renderWebGL = function (renderer)
{

    // if the object is not visible or the alpha is 0 then no need to render this element
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    var i, j;

    // do a quick check to see if this element has a mask or a filter.
    if (this._mask || this._filters)
    {
        renderer.currentRenderer.flush();

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (this._filters && this._filters.length)
        {
            renderer.filterManager.pushFilter(this, this._filters);
        }

        if (this._mask)
        {
            renderer.maskManager.pushMask(this, this._mask);
        }

        renderer.currentRenderer.start();

        // add this object to the batch, only rendered if it has a texture.
        this._renderWebGL(renderer);

        // now loop through the children and make sure they get rendered
        for (i = 0, j = this.children.length; i < j; i++)
        {
            this.children[i].renderWebGL(renderer);
        }

        renderer.currentRenderer.flush();

        if (this._mask)
        {
            renderer.maskManager.popMask(this, this._mask);
        }

        if (this._filters)
        {
            renderer.filterManager.popFilter();

        }
        renderer.currentRenderer.start();
    }
    else
    {
        this._renderWebGL(renderer);

        // simple render children!
        for (i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].renderWebGL(renderer);
        }
    }
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 * @private
 */
Container.prototype._renderWebGL = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 * @private
 */
Container.prototype._renderCanvas = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};


/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 */
Container.prototype.renderCanvas = function (renderer)
{
    // if not visible or the alpha is 0 then no need to render this
    if (!this.visible || this.alpha <= 0 || !this.renderable)
    {
        return;
    }

    if (this._mask)
    {
        renderer.maskManager.pushMask(this._mask, renderer);
    }

    this._renderCanvas(renderer);
    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].renderCanvas(renderer);
    }

    if (this._mask)
    {
        renderer.maskManager.popMask(renderer);
    }
};

/**
 * Destroys the container
 * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well
 */
Container.prototype.destroy = function (destroyChildren)
{
    DisplayObject.prototype.destroy.call(this);

    if (destroyChildren)
    {
        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].destroy(destroyChildren);
        }
    }

    this.removeChildren();

    this.children = null;
};

},{"../math":26,"../textures/RenderTexture":64,"../utils":70,"./DisplayObject":18}],18:[function(require,module,exports){
var math = require('../math'),
    RenderTexture = require('../textures/RenderTexture'),
    EventEmitter = require('eventemitter3'),
    CONST = require('../const'),
    _tempMatrix = new math.Matrix(),
    _tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};


/**
 * The base class for all objects that are rendered on the screen.
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class
 * @extends EventEmitter
 * @memberof PIXI
 */
function DisplayObject()
{
    EventEmitter.call(this);

    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @member {PIXI.Point}
     */
    this.position = new math.Point();

    /**
     * The scale factor of the object.
     *
     * @member {PIXI.Point}
     */
    this.scale = new math.Point(1, 1);

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @member {PIXI.Point}
     */
    this.pivot = new math.Point(0, 0);


    /**
     * The skew factor for the object in radians.
     *
     * @member {PIXI.Point}
     */
    this.skew = new math.Point(0, 0);

    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    this.rotation = 0;

    /**
     * The opacity of the object.
     *
     * @member {number}
     */
    this.alpha = 1;

    /**
     * The visibility of the object. If false the object will not be drawn, and
     * the updateTransform function will not be called.
     *
     * @member {boolean}
     */
    this.visible = true;

    /**
     * Can this object be rendered, if false the object will not be drawn but the updateTransform
     * methods will still be called.
     *
     * @member {boolean}
     */
    this.renderable = true;

    /**
     * The display object container that contains this display object.
     *
     * @member {PIXI.Container}
     * @readOnly
     */
    this.parent = null;

    /**
     * The multiplied alpha of the displayObject
     *
     * @member {number}
     * @readOnly
     */
    this.worldAlpha = 1;

    /**
     * Current transform of the object based on world (parent) factors
     *
     * @member {PIXI.Matrix}
     * @readOnly
     */
    this.worldTransform = new math.Matrix();

    /**
     * The area the filter is applied to. This is used as more of an optimisation
     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
     *
     * @member {PIXI.Rectangle}
     */
    this.filterArea = null;

    /**
     * cached sin rotation
     *
     * @member {number}
     * @private
     */
    this._sr = 0;

    /**
     * cached cos rotation
     *
     * @member {number}
     * @private
     */
    this._cr = 1;

    /**
     * The original, cached bounds of the object
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._bounds = new math.Rectangle(0, 0, 1, 1);

    /**
     * The most up-to-date bounds of the object
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._currentBounds = null;

    /**
     * The original, cached mask of the object
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._mask = null;
}

// constructor
DisplayObject.prototype = Object.create(EventEmitter.prototype);
DisplayObject.prototype.constructor = DisplayObject;
module.exports = DisplayObject;

Object.defineProperties(DisplayObject.prototype, {
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof PIXI.DisplayObject#
     */
    x: {
        get: function ()
        {
            return this.position.x;
        },
        set: function (value)
        {
            this.position.x = value;
        }
    },

    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof PIXI.DisplayObject#
     */
    y: {
        get: function ()
        {
            return this.position.y;
        },
        set: function (value)
        {
            this.position.y = value;
        }
    },

    /**
     * Indicates if the sprite is globally visible.
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     * @readonly
     */
    worldVisible: {
        get: function ()
        {
            var item = this;

            do {
                if (!item.visible)
                {
                    return false;
                }

                item = item.parent;
            } while (item);

            return true;
        }
    },

    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
     * In PIXI a regular mask must be a PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it utilises shape clipping.
     * To remove a mask, set this property to null.
     *
     * @member {PIXI.Graphics|PIXI.Sprite}
     * @memberof PIXI.DisplayObject#
     */
    mask: {
        get: function ()
        {
            return this._mask;
        },
        set: function (value)
        {
            if (this._mask)
            {
                this._mask.renderable = true;
            }

            this._mask = value;

            if (this._mask)
            {
                this._mask.renderable = false;
            }
        }
    },

    /**
     * Sets the filters for the displayObject.
     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
     * To remove filters simply set this property to 'null'
     *
     * @member {PIXI.AbstractFilter[]}
     * @memberof PIXI.DisplayObject#
     */
    filters: {
        get: function ()
        {
            return this._filters && this._filters.slice();
        },
        set: function (value)
        {
            this._filters = value && value.slice();
        }
    }

});

/*
 * Updates the object transform for rendering
 *
 * TODO - Optimization pass!
 */
DisplayObject.prototype.updateTransform = function ()
{
    // create some matrix refs for easy access
    var pt = this.parent.worldTransform;
    var wt = this.worldTransform;

    // temporary matrix variables
    var a, b, c, d, tx, ty;

    // looks like we are skewing
    if(this.skew.x || this.skew.y)
    {
        // I'm assuming that skewing is not going to be very common
        // With that in mind, we can do a full setTransform using the temp matrix
        _tempMatrix.setTransform(
            this.position.x,
            this.position.y,
            this.pivot.x,
            this.pivot.y,
            this.scale.x,
            this.scale.y,
            this.rotation,
            this.skew.x,
            this.skew.y
        );

        // now concat the matrix (inlined so that we can avoid using copy)
        wt.a  = _tempMatrix.a  * pt.a + _tempMatrix.b  * pt.c;
        wt.b  = _tempMatrix.a  * pt.b + _tempMatrix.b  * pt.d;
        wt.c  = _tempMatrix.c  * pt.a + _tempMatrix.d  * pt.c;
        wt.d  = _tempMatrix.c  * pt.b + _tempMatrix.d  * pt.d;
        wt.tx = _tempMatrix.tx * pt.a + _tempMatrix.ty * pt.c + pt.tx;
        wt.ty = _tempMatrix.tx * pt.b + _tempMatrix.ty * pt.d + pt.ty;
    }
    else
    {
        // so if rotation is between 0 then we can simplify the multiplication process...
        if (this.rotation % CONST.PI_2)
        {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            if (this.rotation !== this.rotationCache)
            {
                this.rotationCache = this.rotation;
                this._sr = Math.sin(this.rotation);
                this._cr = Math.cos(this.rotation);
            }

            // get the matrix values of the displayobject based on its transform properties..
            a  =  this._cr * this.scale.x;
            b  =  this._sr * this.scale.x;
            c  = -this._sr * this.scale.y;
            d  =  this._cr * this.scale.y;
            tx =  this.position.x;
            ty =  this.position.y;

            // check for pivot.. not often used so geared towards that fact!
            if (this.pivot.x || this.pivot.y)
            {
                tx -= this.pivot.x * a + this.pivot.y * c;
                ty -= this.pivot.x * b + this.pivot.y * d;
            }

            // concat the parent matrix with the objects transform.
            wt.a  = a  * pt.a + b  * pt.c;
            wt.b  = a  * pt.b + b  * pt.d;
            wt.c  = c  * pt.a + d  * pt.c;
            wt.d  = c  * pt.b + d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
        else
        {
            // lets do the fast version as we know there is no rotation..
            a  = this.scale.x;
            d  = this.scale.y;

            tx = this.position.x - this.pivot.x * a;
            ty = this.position.y - this.pivot.y * d;

            wt.a  = a  * pt.a;
            wt.b  = a  * pt.b;
            wt.c  = d  * pt.c;
            wt.d  = d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
    }

    // multiply the alphas..
    this.worldAlpha = this.alpha * this.parent.worldAlpha;

    // reset the bounds each time this is called!
    this._currentBounds = null;
};

// performance increase to avoid using call.. (10x faster)
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

/**
 *
 *
 * Retrieves the bounds of the displayObject as a rectangle object
 *
 * @param matrix {PIXI.Matrix}
 * @return {PIXI.Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getBounds = function (matrix) // jshint unused:false
{
    return math.Rectangle.EMPTY;
};

/**
 * Retrieves the local bounds of the displayObject as a rectangle object
 *
 * @return {PIXI.Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getLocalBounds = function ()
{
    return this.getBounds(math.Matrix.IDENTITY);
};

/**
 * Calculates the global position of the display object
 *
 * @param position {PIXI.Point} The world origin to calculate from
 * @return {PIXI.Point} A point object representing the position of this object
 */
DisplayObject.prototype.toGlobal = function (position)
{
    // this parent check is for just in case the item is a root object.
    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
    if(!this.parent)
    {
        this.parent = _tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
    }
    else
    {
        this.displayObjectUpdateTransform();
    }

    // don't need to update the lot
    return this.worldTransform.apply(position);
};

/**
 * Calculates the local position of the display object relative to another point
 *
 * @param position {PIXI.Point} The world origin to calculate from
 * @param [from] {PIXI.DisplayObject} The DisplayObject to calculate the global position from
 * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new Point)
 * @return {PIXI.Point} A point object representing the position of this object
 */
DisplayObject.prototype.toLocal = function (position, from, point)
{
    if (from)
    {
        position = from.toGlobal(position);
    }

    // this parent check is for just in case the item is a root object.
    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
    if(!this.parent)
    {
        this.parent = _tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
    }
    else
    {
        this.displayObjectUpdateTransform();
    }

    // simply apply the matrix..
    return this.worldTransform.applyInverse(position, point);
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};
/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} The resolution of the texture being generated
 * @return {PIXI.Texture} a texture of the display object
 */
DisplayObject.prototype.generateTexture = function (renderer, scaleMode, resolution)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/**
 * Set the parent Container of this DisplayObject
 *
 * @param container {Container} The Container to add this DisplayObject to
 * @return {Container} The Container that this DisplayObject was added to
 */
DisplayObject.prototype.setParent = function (container)
{
    if (!container || !container.addChild)
    {
        throw new Error('setParent: Argument must be a Container');
    }

    container.addChild(this);
    return container;
};

/**
 * Convenience function to set the postion, scale, skew and pivot at once.
 *
 * @param [x=0] {number} The X position
 * @param [y=0] {number} The Y position
 * @param [scaleX=1] {number} The X scale value
 * @param [scaleY=1] {number} The Y scale value
 * @param [rotation=0] {number} The rotation
 * @param [skewX=0] {number} The X skew value
 * @param [skewY=0] {number} The Y skew value
 * @param [pivotX=0] {number} The X pivot value
 * @param [pivotY=0] {number} The Y pivot value
 * @return {PIXI.DisplayObject}
 */
DisplayObject.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) //jshint ignore:line
{
    this.position.x = x || 0;
    this.position.y = y || 0;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation || 0;
    this.skew.x = skewX || 0;
    this.skew.y = skewY || 0;
    this.pivot.x = pivotX || 0;
    this.pivot.y = pivotY || 0;
    return this;
};

/**
 * Base destroy method for generic display objects
 *
 */
DisplayObject.prototype.destroy = function ()
{

    this.position = null;
    this.scale = null;
    this.pivot = null;
    this.skew = null;

    this.parent = null;

    this._bounds = null;
    this._currentBounds = null;
    this._mask = null;

    this.worldTransform = null;
    this.filterArea = null;
};

},{"../const":16,"../math":26,"../textures/RenderTexture":64,"eventemitter3":10}],19:[function(require,module,exports){
var Container = require('../display/Container'),
    Texture = require('../textures/Texture'),
    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),
    GraphicsData = require('./GraphicsData'),
    math = require('../math'),
    CONST = require('../const'),
    tempPoint = new math.Point();

/**
 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
 * rectangles to the display, and to color and fill them.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */
function Graphics()
{
    Container.call(this);

    /**
     * The alpha value used when filling the Graphics object.
     *
     * @member {number}
     * @default 1
     */
    this.fillAlpha = 1;

    /**
     * The width (thickness) of any lines drawn.
     *
     * @member {number}
     * @default 0
     */
    this.lineWidth = 0;

    /**
     * The color of any lines drawn.
     *
     * @member {string}
     * @default 0
     */
    this.lineColor = 0;

    /**
     * Graphics data
     *
     * @member {PIXI.GraphicsData[]}
     * @private
     */
    this.graphicsData = [];

    /**
     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;

    /**
     * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.
     *
     * @member {number}
     * @private
     * @default 0xFFFFFF
     */
    this._prevTint = 0xFFFFFF;

    /**
     * The blend mode to be applied to the graphic shape. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * Current path
     *
     * @member {PIXI.GraphicsData}
     * @private
     */
    this.currentPath = null;

    /**
     * Array containing some WebGL-related properties used by the WebGL renderer.
     *
     * @member {object<number, object>}
     * @private
     */
    // TODO - _webgl should use a prototype object, not a random undocumented object...
    this._webGL = {};

    /**
     * Whether this shape is being used as a mask.
     *
     * @member {boolean}
     */
    this.isMask = false;

    /**
     * The bounds' padding used for bounds calculation.
     *
     * @member {number}
     */
    this.boundsPadding = 0;

    /**
     * A cache of the local bounds to prevent recalculation.
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._localBounds = new math.Rectangle(0,0,1,1);

    /**
     * Used to detect if the graphics object has changed. If this is set to true then the graphics
     * object will be recalculated.
     *
     * @member {boolean}
     * @private
     */
    this.dirty = true;

    /**
     * Used to detect if the WebGL graphics object has changed. If this is set to true then the
     * graphics object will be recalculated.
     *
     * @member {boolean}
     * @private
     */
    this.glDirty = false;

    this.boundsDirty = true;

    /**
     * Used to detect if the cached sprite object needs to be updated.
     *
     * @member {boolean}
     * @private
     */
    this.cachedSpriteDirty = false;

    /**
     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
     * This is useful if your graphics element does not change often, as it will speed up the rendering
     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
     * you are constantly redrawing the graphics element.
     *
     * @name cacheAsBitmap
     * @member {boolean}
     * @memberof PIXI.Graphics#
     * @default false
     */
}

// constructor
Graphics.prototype = Object.create(Container.prototype);
Graphics.prototype.constructor = Graphics;
module.exports = Graphics;

/**
 * Creates a new Graphics object with the same values as this one.
 * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
 *
 * @return {PIXI.Graphics}
 */
Graphics.prototype.clone = function ()
{
    var clone = new Graphics();

    clone.renderable    = this.renderable;
    clone.fillAlpha     = this.fillAlpha;
    clone.lineWidth     = this.lineWidth;
    clone.lineColor     = this.lineColor;
    clone.tint          = this.tint;
    clone.blendMode     = this.blendMode;
    clone.isMask        = this.isMask;
    clone.boundsPadding = this.boundsPadding;
    clone.dirty         = true;
    clone.glDirty       = true;
    clone.cachedSpriteDirty = this.cachedSpriteDirty;

    // copy graphics data
    for (var i = 0; i < this.graphicsData.length; ++i)
    {
        clone.graphicsData.push(this.graphicsData[i].clone());
    }

    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];

    clone.updateLocalBounds();

    return clone;
};

/**
 * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
 *
 * @param lineWidth {number} width of the line to draw, will update the objects stored style
 * @param color {number} color of the line to draw, will update the objects stored style
 * @param alpha {number} alpha of the line to draw, will update the objects stored style
 * @return {PIXI.Graphics}
 */
Graphics.prototype.lineStyle = function (lineWidth, color, alpha)
{
    this.lineWidth = lineWidth || 0;
    this.lineColor = color || 0;
    this.lineAlpha = (alpha === undefined) ? 1 : alpha;

    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length)
        {
            // halfway through a line? start a new one!
            var shape = new math.Polygon(this.currentPath.shape.points.slice(-2));
            shape.closed = false;
            this.drawShape(shape);
        }
        else
        {
            // otherwise its empty so lets just set the line properties
            this.currentPath.lineWidth = this.lineWidth;
            this.currentPath.lineColor = this.lineColor;
            this.currentPath.lineAlpha = this.lineAlpha;
        }
    }

    return this;
};

/**
 * Moves the current drawing position to x, y.
 *
 * @param x {number} the X coordinate to move to
 * @param y {number} the Y coordinate to move to
 * @return {PIXI.Graphics}
  */
Graphics.prototype.moveTo = function (x, y)
{
    var shape = new math.Polygon([x,y]);
    shape.closed = false;
    this.drawShape(shape);

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * The current drawing position is then set to (x, y).
 *
 * @param x {number} the X coordinate to draw to
 * @param y {number} the Y coordinate to draw to
 * @return {PIXI.Graphics}
 */
Graphics.prototype.lineTo = function (x, y)
{
    this.currentPath.shape.points.push(x, y);
    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a quadratic bezier curve and then draws it.
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @return {PIXI.Graphics}
 */
Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points = [0, 0];
        }
    }
    else
    {
        this.moveTo(0,0);
    }

    var xa,
        ya,
        n = 20,
        points = this.currentPath.shape.points;

    if (points.length === 0)
    {
        this.moveTo(0, 0);
    }

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;
    for (var i = 1; i <= n; ++i)
    {
        j = i / n;

        xa = fromX + ( (cpX - fromX) * j );
        ya = fromY + ( (cpY - fromY) * j );

        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),
                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * Calculate the points for a bezier curve and then draws it.
 *
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param cpX2 {number} Second Control point x
 * @param cpY2 {number} Second Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @return {PIXI.Graphics}
 */
Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points = [0, 0];
        }
    }
    else
    {
        this.moveTo(0,0);
    }

    var n = 20,
        dt,
        dt2,
        dt3,
        t2,
        t3,
        points = this.currentPath.shape.points;

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;

    for (var i = 1; i <= n; ++i)
    {
        j = i / n;

        dt = (1 - j);
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * The arcTo() method creates an arc/curve between two tangents on the canvas.
 *
 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
 *
 * @param x1 {number} The x-coordinate of the beginning of the arc
 * @param y1 {number} The y-coordinate of the beginning of the arc
 * @param x2 {number} The x-coordinate of the end of the arc
 * @param y2 {number} The y-coordinate of the end of the arc
 * @param radius {number} The radius of the arc
 * @return {PIXI.Graphics}
 */
Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points.push(x1, y1);
        }
    }
    else
    {
        this.moveTo(x1, y1);
    }

    var points = this.currentPath.shape.points,
        fromX = points[points.length-2],
        fromY = points[points.length-1],
        a1 = fromY - y1,
        b1 = fromX - x1,
        a2 = y2   - y1,
        b2 = x2   - x1,
        mm = Math.abs(a1 * b2 - b1 * a2);

    if (mm < 1.0e-8 || radius === 0)
    {
        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)
        {
            points.push(x1, y1);
        }
    }
    else
    {
        var dd = a1 * a1 + b1 * b1,
            cc = a2 * a2 + b2 * b2,
            tt = a1 * a2 + b1 * b2,
            k1 = radius * Math.sqrt(dd) / mm,
            k2 = radius * Math.sqrt(cc) / mm,
            j1 = k1 * tt / dd,
            j2 = k2 * tt / cc,
            cx = k1 * b2 + k2 * b1,
            cy = k1 * a2 + k2 * a1,
            px = b1 * (k2 + j1),
            py = a1 * (k2 + j1),
            qx = b2 * (k1 + j2),
            qy = a2 * (k1 + j2),
            startAngle = Math.atan2(py - cy, px - cx),
            endAngle   = Math.atan2(qy - cy, qx - cx);

        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * The arc method creates an arc/curve (used to create circles, or parts of circles).
 *
 * @param cx {number} The x-coordinate of the center of the circle
 * @param cy {number} The y-coordinate of the center of the circle
 * @param radius {number} The radius of the circle
 * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
 * @param endAngle {number} The ending angle, in radians
 * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
 * @return {PIXI.Graphics}
 */
Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)
{
    anticlockwise = anticlockwise || false;

    if (startAngle === endAngle)
    {
        return this;
    }

    if( !anticlockwise && endAngle <= startAngle )
    {
        endAngle += Math.PI * 2;
    }
    else if( anticlockwise && startAngle <= endAngle )
    {
        startAngle += Math.PI * 2;
    }

    var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);
    var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;

    if(sweep === 0)
    {
        return this;
    }

    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;

    if (this.currentPath)
    {
        this.currentPath.shape.points.push(startX, startY);
    }
    else
    {
        this.moveTo(startX, startY);
    }

    var points = this.currentPath.shape.points;

    var theta = sweep/(segs*2);
    var theta2 = theta*2;

    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);

    var segMinus = segs - 1;

    var remainder = ( segMinus % 1 ) / segMinus;

    for(var i=0; i<=segMinus; i++)
    {
        var real =  i + remainder * i;


        var angle = ((theta) + startAngle + (theta2 * real));

        var c = Math.cos(angle);
        var s = -Math.sin(angle);

        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,
                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);
    }

    this.dirty = this.boundsDirty = true;

    return this;
};

/**
 * Specifies a simple one-color fill that subsequent calls to other Graphics methods
 * (such as lineTo() or drawCircle()) use when drawing.
 *
 * @param color {number} the color of the fill
 * @param alpha {number} the alpha of the fill
 * @return {PIXI.Graphics}
 */
Graphics.prototype.beginFill = function (color, alpha)
{
    this.filling = true;
    this.fillColor = color || 0;
    this.fillAlpha = (alpha === undefined) ? 1 : alpha;

    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length <= 2)
        {
            this.currentPath.fill = this.filling;
            this.currentPath.fillColor = this.fillColor;
            this.currentPath.fillAlpha = this.fillAlpha;
        }
    }
    return this;
};

/**
 * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
 *
 * @return {Graphics}
 */
Graphics.prototype.endFill = function ()
{
    this.filling = false;
    this.fillColor = null;
    this.fillAlpha = 1;

    return this;
};

/**
 *
 * @param x {number} The X coord of the top-left of the rectangle
 * @param y {number} The Y coord of the top-left of the rectangle
 * @param width {number} The width of the rectangle
 * @param height {number} The height of the rectangle
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawRect = function ( x, y, width, height )
{
    this.drawShape(new math.Rectangle(x,y, width, height));

    return this;
};

/**
 *
 * @param x {number} The X coord of the top-left of the rectangle
 * @param y {number} The Y coord of the top-left of the rectangle
 * @param width {number} The width of the rectangle
 * @param height {number} The height of the rectangle
 * @param radius {number} Radius of the rectangle corners
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawRoundedRect = function ( x, y, width, height, radius )
{
    this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));

    return this;
};

/**
 * Draws a circle.
 *
 * @param x {number} The X coordinate of the center of the circle
 * @param y {number} The Y coordinate of the center of the circle
 * @param radius {number} The radius of the circle
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawCircle = function (x, y, radius)
{
    this.drawShape(new math.Circle(x,y, radius));

    return this;
};

/**
 * Draws an ellipse.
 *
 * @param x {number} The X coordinate of the center of the ellipse
 * @param y {number} The Y coordinate of the center of the ellipse
 * @param width {number} The half width of the ellipse
 * @param height {number} The half height of the ellipse
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawEllipse = function (x, y, width, height)
{
    this.drawShape(new math.Ellipse(x, y, width, height));

    return this;
};

/**
 * Draws a polygon using the given path.
 *
 * @param path {number[]|PIXI.Point[]} The path data used to construct the polygon.
 * @return {PIXI.Graphics}
 */
Graphics.prototype.drawPolygon = function (path)
{
    // prevents an argument assignment deopt
    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var points = path;

    var closed = true;

    if (points instanceof math.Polygon)
    {
        closed = points.closed;
        points = points.points;
    }

    if (!Array.isArray(points))
    {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var i = 0; i < points.length; ++i)
        {
            points[i] = arguments[i];
        }
    }

    var shape = new math.Polygon(points);
    shape.closed = closed;

    this.drawShape(shape);

    return this;
};

/**
 * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
 *
 * @return {PIXI.Graphics}
 */
Graphics.prototype.clear = function ()
{
    this.lineWidth = 0;
    this.filling = false;

    this.dirty = true;
    this.clearDirty = true;
    this.graphicsData = [];

    return this;
};

/**
 * Useful function that returns a texture of the graphics object that can then be used to create sprites
 * This can be quite useful if your geometry is complicated and needs to be reused multiple times.
 *
 * @param resolution {number} The resolution of the texture being generated
 * @param scaleMode {number} Should be one of the scaleMode consts
 * @return {PIXI.Texture} a texture of the graphics object
 */
Graphics.prototype.generateTexture = function (renderer, resolution, scaleMode)
{

    resolution = resolution || 1;

    var bounds = this.getLocalBounds();

    var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);

    var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);
    texture.baseTexture.resolution = resolution;

    canvasBuffer.context.scale(resolution, resolution);

    canvasBuffer.context.translate(-bounds.x,-bounds.y);

    CanvasGraphics.renderGraphics(this, canvasBuffer.context);

    return texture;
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer}
 * @private
 */
Graphics.prototype._renderWebGL = function (renderer)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element

    // this code may still be needed so leaving for now..
    //
    /*
    if (this._cacheAsBitmap)
    {
        if (this.dirty || this.cachedSpriteDirty)
        {
            this._generateCachedSprite();

            // we will also need to update the texture on the gpu too!
            this.updateCachedSpriteTexture();

            this.cachedSpriteDirty = false;
            this.dirty = false;
        }

        this._cachedSprite.worldAlpha = this.worldAlpha;

        Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);

        return;
    }

    */

    if (this.glDirty)
    {
        this.dirty = true;
        this.glDirty = false;
    }

    renderer.setObjectRenderer(renderer.plugins.graphics);
    renderer.plugins.graphics.render(this);

};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer}
 * @private
 */
Graphics.prototype._renderCanvas = function (renderer)
{
    if (this.isMask === true)
    {
        return;
    }

    // if the tint has changed, set the graphics object to dirty.
    if (this._prevTint !== this.tint) {
        this.dirty = true;
    }

    // this code may still be needed so leaving for now..
    //
    /*
    if (this._cacheAsBitmap)
    {
        if (this.dirty || this.cachedSpriteDirty)
        {
            this._generateCachedSprite();

            // we will also need to update the texture
            this.updateCachedSpriteTexture();

            this.cachedSpriteDirty = false;
            this.dirty = false;
        }

        this._cachedSprite.alpha = this.alpha;

        Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);

        return;
    }
    */
    var context = renderer.context;
    var transform = this.worldTransform;

    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== context.globalCompositeOperation)
    {
        context.globalCompositeOperation = compositeOperation;
    }

    var resolution = renderer.resolution;
    context.setTransform(
        transform.a * resolution,
        transform.b * resolution,
        transform.c * resolution,
        transform.d * resolution,
        transform.tx * resolution,
        transform.ty * resolution
    );

    CanvasGraphics.renderGraphics(this, context);
};

/**
 * Retrieves the bounds of the graphic shape as a rectangle object
 *
 * @param [matrix] {PIXI.Matrix} The world transform matrix to use, defaults to this
 *  object's worldTransform.
 * @return {PIXI.Rectangle} the rectangular bounding area
 */
Graphics.prototype.getBounds = function (matrix)
{
    if(!this._currentBounds)
    {

        // return an empty object if the item is a mask!
        if (!this.renderable)
        {
            return math.Rectangle.EMPTY;
        }

        if (this.boundsDirty)
        {
            this.updateLocalBounds();

            this.glDirty = true;
            this.cachedSpriteDirty = true;
            this.boundsDirty = false;
        }

        var bounds = this._localBounds;

        var w0 = bounds.x;
        var w1 = bounds.width + bounds.x;

        var h0 = bounds.y;
        var h1 = bounds.height + bounds.y;

        var worldTransform = matrix || this.worldTransform;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 =  a * w1 + c * h0 + tx;
        var y4 =  d * h0 + b * w1 + ty;

        var maxX = x1;
        var maxY = y1;

        var minX = x1;
        var minY = y1;

        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;

        this._bounds.x = minX;
        this._bounds.width = maxX - minX;

        this._bounds.y = minY;
        this._bounds.height = maxY - minY;

        this._currentBounds = this._bounds;
    }

    return this._currentBounds;
};

/**
* Tests if a point is inside this graphics object
*
* @param point {PIXI.Point} the point to test
* @return {boolean} the result of the test
*/
Graphics.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var graphicsData = this.graphicsData;

    for (var i = 0; i < graphicsData.length; i++)
    {
        var data = graphicsData[i];

        if (!data.fill)
        {
            continue;
        }

        // only deal with fills..
        if (data.shape)
        {
            if ( data.shape.contains( tempPoint.x, tempPoint.y ) )
            {
                return true;
            }
        }
    }

    return false;
};

/**
 * Update the bounds of the object
 *
 */
Graphics.prototype.updateLocalBounds = function ()
{
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    if (this.graphicsData.length)
    {
        var shape, points, x, y, w, h;

        for (var i = 0; i < this.graphicsData.length; i++)
        {
            var data = this.graphicsData[i];
            var type = data.type;
            var lineWidth = data.lineWidth;
            shape = data.shape;

            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC)
            {
                x = shape.x - lineWidth/2;
                y = shape.y - lineWidth/2;
                w = shape.width + lineWidth;
                h = shape.height + lineWidth;

                minX = x < minX ? x : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y < minY ? y : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else if (type === CONST.SHAPES.CIRC)
            {
                x = shape.x;
                y = shape.y;
                w = shape.radius + lineWidth/2;
                h = shape.radius + lineWidth/2;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else if (type === CONST.SHAPES.ELIP)
            {
                x = shape.x;
                y = shape.y;
                w = shape.width + lineWidth/2;
                h = shape.height + lineWidth/2;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else
            {
                // POLY
                points = shape.points;

                for (var j = 0; j < points.length; j += 2)
                {
                    x = points[j];
                    y = points[j+1];

                    minX = x-lineWidth < minX ? x-lineWidth : minX;
                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;

                    minY = y-lineWidth < minY ? y-lineWidth : minY;
                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;
                }
            }
        }
    }
    else
    {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
    }

    var padding = this.boundsPadding;

    this._localBounds.x = minX - padding;
    this._localBounds.width = (maxX - minX) + padding * 2;

    this._localBounds.y = minY - padding;
    this._localBounds.height = (maxY - minY) + padding * 2;
};

/**
 * Generates the cached sprite when the sprite has cacheAsBitmap = true
 *
 * @private
 */
/*
Graphics.prototype._generateCachedSprite = function ()
{
    var bounds = this.getLocalBounds();

    if (!this._cachedSprite)
    {
        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);
        var texture = Texture.fromCanvas(canvasBuffer.canvas);

        this._cachedSprite = new Sprite(texture);
        this._cachedSprite.buffer = canvasBuffer;

        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.buffer.resize(bounds.width, bounds.height);
    }

    // leverage the anchor to account for the offset of the element
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    // this._cachedSprite.buffer.context.save();
    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);

    // make sure we set the alpha of the graphics to 1 for the render..
    this.worldAlpha = 1;

    // now render the graphic..
    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);

    this._cachedSprite.alpha = this.alpha;
};
*/
/**
 * Updates texture size based on canvas size
 *
 * @private
 */
/*
Graphics.prototype.updateCachedSpriteTexture = function ()
{
    var cachedSprite = this._cachedSprite;
    var texture = cachedSprite.texture;
    var canvas = cachedSprite.buffer.canvas;

    texture.baseTexture.width = canvas.width;
    texture.baseTexture.height = canvas.height;
    texture.crop.width = texture.frame.width = canvas.width;
    texture.crop.height = texture.frame.height = canvas.height;

    cachedSprite._width = canvas.width;
    cachedSprite._height = canvas.height;

    // update the dirty base textures
    texture.baseTexture.dirty();
};*/

/**
 * Destroys a previous cached sprite.
 *
 */
/*
Graphics.prototype.destroyCachedSprite = function ()
{
    this._cachedSprite.texture.destroy(true);

    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};*/

/**
 * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
 *
 * @param shape {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.
 * @return {PIXI.GraphicsData} The generated GraphicsData object.
 */
Graphics.prototype.drawShape = function (shape)
{
    if (this.currentPath)
    {
        // check current path!
        if (this.currentPath.shape.points.length <= 2)
        {
            this.graphicsData.pop();
        }
    }

    this.currentPath = null;

    var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);

    this.graphicsData.push(data);

    if (data.type === CONST.SHAPES.POLY)
    {
        data.shape.closed = data.shape.closed || this.filling;
        this.currentPath = data;
    }

    this.dirty = this.boundsDirty = true;

    return data;
};

/**
 * Destroys the Graphics object.
 */
Graphics.prototype.destroy = function () {
    Container.prototype.destroy.apply(this, arguments);

    // destroy each of the GraphicsData objects
    for (var i = 0; i < this.graphicsData.length; ++i) {
        this.graphicsData[i].destroy();
    }

    // for each webgl data entry, destroy the WebGLGraphicsData
    for (var id in this._webgl) {
        for (var j = 0; j < this._webgl[id].data.length; ++j) {
            this._webgl[id].data[j].destroy();
        }
    }

    this.graphicsData = null;

    this.currentPath = null;
    this._webgl = null;
    this._localBounds = null;
};

},{"../const":16,"../display/Container":17,"../math":26,"../renderers/canvas/utils/CanvasBuffer":38,"../renderers/canvas/utils/CanvasGraphics":39,"../textures/Texture":65,"./GraphicsData":20}],20:[function(require,module,exports){
/**
 * A GraphicsData object.
 *
 * @class
 * @memberof PIXI
 * @param lineWidth {number} the width of the line to draw
 * @param lineColor {number} the color of the line to draw
 * @param lineAlpha {number} the alpha of the line to draw
 * @param fillColor {number} the color of the fill
 * @param fillAlpha {number} the alpha of the fill
 * @param fill      {boolean} whether or not the shape is filled with a colour
 * @param shape     {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.
 */
function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape)
{
    /*
     * @member {number} the width of the line to draw
     */
    this.lineWidth = lineWidth;

    /*
     * @member {number} the color of the line to draw
     */
    this.lineColor = lineColor;
    /*
     * @member {number} the alpha of the line to draw
     */
    this.lineAlpha = lineAlpha;
    /*
     * @member {number} cached tint of the line to draw
     */
    this._lineTint = lineColor;

    /*
     * @member {number} the color of the fill
     */
    this.fillColor = fillColor;

    /*
     * @member {number} the alpha of the fill
     */
    this.fillAlpha = fillAlpha;

    /*
     * @member {number} cached tint of the fill
     */
    this._fillTint = fillColor;

    /*
     * @member {boolean} whether or not the shape is filled with a colour
     */
    this.fill = fill;

    /*
     * @member {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.
     */
    this.shape = shape;

    /*
     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,
     */
    this.type = shape.type;
}

GraphicsData.prototype.constructor = GraphicsData;
module.exports = GraphicsData;

/**
 * Creates a new GraphicsData object with the same values as this one.
 *
 * @return {PIXI.GraphicsData}
 */
GraphicsData.prototype.clone = function ()
{
    return new GraphicsData(
        this.lineWidth,
        this.lineColor,
        this.lineAlpha,
        this.fillColor,
        this.fillAlpha,
        this.fill,
        this.shape
    );
};

/**
 * Destroys the Graphics data.
 */
GraphicsData.prototype.destroy = function () {
    this.shape = null;
};

},{}],21:[function(require,module,exports){
var utils = require('../../utils'),
    math = require('../../math'),
    CONST = require('../../const'),
    ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    WebGLGraphicsData = require('./WebGLGraphicsData'),
    earcut = require('earcut');

/**
 * Renders the graphics object.
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.
 */
function GraphicsRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    this.graphicsDataPool = [];

    this.primitiveShader = null;
    this.complexPrimitiveShader = null;

    /**
     * This is the maximum number of points a poly can contain before it is rendered as a complex polygon (using the stencil buffer)
     * @type {Number}
     */
    this.maximumSimplePolySize = 200;
}

GraphicsRenderer.prototype = Object.create(ObjectRenderer.prototype);
GraphicsRenderer.prototype.constructor = GraphicsRenderer;
module.exports = GraphicsRenderer;

WebGLRenderer.registerPlugin('graphics', GraphicsRenderer);

/**
 * Called when there is a WebGL context change
 *
 * @private
 *
 */
GraphicsRenderer.prototype.onContextChange = function()
{

};

/**
 * Destroys this renderer.
 *
 */
GraphicsRenderer.prototype.destroy = function () {
    ObjectRenderer.prototype.destroy.call(this);

    for (var i = 0; i < this.graphicsDataPool.length; ++i) {
        this.graphicsDataPool[i].destroy();
    }

    this.graphicsDataPool = null;
};

/**
 * Renders a graphics object.
 *
 * @param graphics {PIXI.Graphics} The graphics object to render.
 */
GraphicsRenderer.prototype.render = function(graphics)
{
    var renderer = this.renderer;
    var gl = renderer.gl;

    var shader = renderer.shaderManager.plugins.primitiveShader,
        webGLData;

    if (graphics.dirty || !graphics._webGL[gl.id])
    {
        this.updateGraphics(graphics);
    }

    var webGL = graphics._webGL[gl.id];

    // This  could be speeded up for sure!

    renderer.blendModeManager.setBlendMode( graphics.blendMode );

//    var matrix =  graphics.worldTransform.clone();
//    var matrix =  renderer.currentRenderTarget.projectionMatrix.clone();
//    matrix.append(graphics.worldTransform);

    for (var i = 0, n = webGL.data.length; i < n; i++)
    {
        webGLData = webGL.data[i];

        if (webGL.data[i].mode === 1)
        {

            renderer.stencilManager.pushStencil(graphics, webGLData);

            gl.uniform1f(renderer.shaderManager.complexPrimitiveShader.uniforms.alpha._location, graphics.worldAlpha * webGLData.alpha);

            // render quad..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

            renderer.stencilManager.popStencil(graphics, webGLData);
        }
        else
        {

            shader = renderer.shaderManager.primitiveShader;

            renderer.shaderManager.setShader( shader );//activatePrimitiveShader();

            gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

            gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));

            gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

            gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);


            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);

            // set the index buffer!
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
        }

        renderer.drawCount++;
    }
};

/**
 * Updates the graphics object
 *
 * @private
 * @param graphics {PIXI.Graphics} The graphics object to update
 */
GraphicsRenderer.prototype.updateGraphics = function(graphics)
{
    var gl = this.renderer.gl;

     // get the contexts graphics object
    var webGL = graphics._webGL[gl.id];

    // if the graphics object does not exist in the webGL context time to create it!
    if (!webGL)
    {
        webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};
    }

    // flag the graphics as not dirty as we are about to update it...
    graphics.dirty = false;

    var i;

    // if the user cleared the graphics object we will need to clear every object
    if (graphics.clearDirty)
    {
        graphics.clearDirty = false;

        // loop through and return all the webGLDatas to the object pool so than can be reused later on
        for (i = 0; i < webGL.data.length; i++)
        {
            var graphicsData = webGL.data[i];
            graphicsData.reset();
            this.graphicsDataPool.push( graphicsData );
        }

        // clear the array and reset the index..
        webGL.data = [];
        webGL.lastIndex = 0;
    }

    var webGLData;

    // loop through the graphics datas and construct each one..
    // if the object is a complex fill then the new stencil buffer technique will be used
    // other wise graphics objects will be pushed into a batch..
    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        if (data.type === CONST.SHAPES.POLY)
        {
            // need to add the points the the graphics object..
            data.points = data.shape.points.slice();
            if (data.shape.closed)
            {
                // close the poly if the value is true!
                if (data.points[0] !== data.points[data.points.length-2] || data.points[1] !== data.points[data.points.length-1])
                {
                    data.points.push(data.points[0], data.points[1]);
                }
            }

            // MAKE SURE WE HAVE THE CORRECT TYPE..
            if (data.fill)
            {
                if (data.points.length >= 6)
                {
                    if (data.points.length < this.maximumSimplePolySize * 2)
                    {
                        webGLData = this.switchMode(webGL, 0);

                        var canDrawUsingSimple = this.buildPoly(data, webGLData);

                        if (!canDrawUsingSimple)
                        {
                            webGLData = this.switchMode(webGL, 1);
                            this.buildComplexPoly(data, webGLData);
                        }

                    }
                    else
                    {
                        webGLData = this.switchMode(webGL, 1);
                        this.buildComplexPoly(data, webGLData);
                    }
                }
            }

            if (data.lineWidth > 0)
            {
                webGLData = this.switchMode(webGL, 0);
                this.buildLine(data, webGLData);
            }
        }
        else
        {
            webGLData = this.switchMode(webGL, 0);

            if (data.type === CONST.SHAPES.RECT)
            {
                this.buildRectangle(data, webGLData);
            }
            else if (data.type === CONST.SHAPES.CIRC || data.type === CONST.SHAPES.ELIP)
            {
                this.buildCircle(data, webGLData);
            }
            else if (data.type === CONST.SHAPES.RREC)
            {
                this.buildRoundedRectangle(data, webGLData);
            }
        }

        webGL.lastIndex++;
    }

    // upload all the dirty data...
    for (i = 0; i < webGL.data.length; i++)
    {
        webGLData = webGL.data[i];

        if (webGLData.dirty)
        {
            webGLData.upload();
        }
    }
};

/**
 *
 *
 * @private
 * @param webGL {WebGLRenderingContext} the current WebGL drawing context
 * @param type {number} TODO @Alvin
 */
GraphicsRenderer.prototype.switchMode = function (webGL, type)
{
    var webGLData;

    if (!webGL.data.length)
    {
        webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
        webGLData.mode = type;
        webGL.data.push(webGLData);
    }
    else
    {
        webGLData = webGL.data[webGL.data.length-1];

        if ((webGLData.points.length > 320000) || webGLData.mode !== type || type === 1)
        {
            webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        }
    }

    webGLData.dirty = true;

    return webGLData;
};

/**
 * Builds a rectangle to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildRectangle = function (graphicsData, webGLData)
{
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length/6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x , y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y,
                  x + width, y,
                  x + width, y + height,
                  x, y + height,
                  x, y];


        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a rounded rectangle to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildRoundedRectangle = function (graphicsData, webGLData)
{
    var rrectData = graphicsData.shape;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;

    var radius = rrectData.radius;

    var recPoints = [];
    recPoints.push(x, y + radius);
    this.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
    this.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
    this.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
    this.quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);

    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
    // TODO - fix this properly, this is not very elegant.. but it works for now.

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        var triangles = earcut(recPoints, null, 2);

        var i = 0;
        for (i = 0; i < triangles.length; i+=3)
        {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i+1] + vecPos);
            indices.push(triangles[i+2] + vecPos);
            indices.push(triangles[i+2] + vecPos);
        }

        for (i = 0; i < recPoints.length; i++)
        {
            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @private
 * @param fromX {number} Origin point x
 * @param fromY {number} Origin point x
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @param [out] {number[]} The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
GraphicsRenderer.prototype.quadraticBezierCurve = function (fromX, fromY, cpX, cpY, toX, toY, out)
{
    var xa,
        ya,
        xb,
        yb,
        x,
        y,
        n = 20,
        points = out || [];

    function getPt(n1 , n2, perc) {
        var diff = n2 - n1;

        return n1 + ( diff * perc );
    }

    var j = 0;
    for (var i = 0; i <= n; i++ ) {
        j = i / n;

        // The Green Line
        xa = getPt( fromX , cpX , j );
        ya = getPt( fromY , cpY , j );
        xb = getPt( cpX , toX , j );
        yb = getPt( cpY , toY , j );

        // The Black Dot
        x = getPt( xa , xb , j );
        y = getPt( ya , yb , j );

        points.push(x, y);
    }

    return points;
};

/**
 * Builds a circle to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object to draw
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildCircle = function (graphicsData, webGLData)
{
    // need to convert points to a nice regular data
    var circleData = graphicsData.shape;
    var x = circleData.x;
    var y = circleData.y;
    var width;
    var height;

    // TODO - bit hacky??
    if (graphicsData.type === CONST.SHAPES.CIRC)
    {
        width = circleData.radius;
        height = circleData.radius;
    }
    else
    {
        width = circleData.width;
        height = circleData.height;
    }

    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
    var seg = (Math.PI * 2) / totalSegs ;

    var i = 0;

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        indices.push(vecPos);

        for (i = 0; i < totalSegs + 1 ; i++)
        {
            verts.push(x,y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width,
                       y + Math.cos(seg * i) * height,
                       r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos-1);
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (i = 0; i < totalSegs + 1; i++)
        {
            graphicsData.points.push(x + Math.sin(seg * i) * width,
                                     y + Math.cos(seg * i) * height);
        }

        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a line to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildLine = function (graphicsData, webGLData)
{
    // TODO OPTIMISE!
    var i = 0;
    var points = graphicsData.points;

    if (points.length === 0)
    {
        return;
    }
    // if the line width is an odd number add 0.5 to align to a whole pixel
    // commenting this out fixes #711 and #1620
    // if (graphicsData.lineWidth%2)
    // {
    //     for (i = 0; i < points.length; i++)
    //     {
    //         points[i] += 0.5;
    //     }
    // }

    // get first and last point.. figure out the middle!
    var firstPoint = new math.Point(points[0], points[1]);
    var lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);

    // if the first point is the last point - gonna have issues :)
    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)
    {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length/6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = utils.hex2rgb(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
    var a1, b1, c1, a2, b2, c2;
    var denom, pdist, dist;

    p1x = points[0];
    p1y = points[1];

    p2x = points[2];
    p2y = points[3];

    perpx = -(p1y - p2y);
    perpy =  p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx , p1y - perpy,
                r, g, b, alpha);

    verts.push(p1x + perpx , p1y + perpy,
                r, g, b, alpha);

    for (i = 1; i < length-1; i++)
    {
        p1x = points[(i-1)*2];
        p1y = points[(i-1)*2 + 1];

        p2x = points[(i)*2];
        p2y = points[(i)*2 + 1];

        p3x = points[(i+1)*2];
        p3y = points[(i+1)*2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx*perpx + perpy*perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        a1 = (-perpy + p1y) - (-perpy + p2y);
        b1 = (-perpx + p2x) - (-perpx + p1x);
        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        a2 = (-perp2y + p3y) - (-perp2y + p2y);
        b2 = (-perp2x + p2x) - (-perp2x + p3x);
        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        denom = a1*b2 - a2*b1;

        if (Math.abs(denom) < 0.1 )
        {

            denom+=10.1;
            verts.push(p2x - perpx , p2y - perpy,
                r, g, b, alpha);

            verts.push(p2x + perpx , p2y + perpy,
                r, g, b, alpha);

            continue;
        }

        px = (b1*c2 - b2*c1)/denom;
        py = (a2*c1 - a1*c2)/denom;


        pdist = (px -p2x) * (px -p2x) + (py -p2y) * (py -p2y);


        if (pdist > 140 * 140)
        {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y +perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        }
        else
        {

            verts.push(px , py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px-p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length-2)*2];
    p1y = points[(length-2)*2 + 1];

    p2x = points[(length-1)*2];
    p2y = points[(length-1)*2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx , p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx , p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (i = 0; i < indexCount; i++)
    {
        indices.push(indexStart++);
    }

    indices.push(indexStart-1);
};

/**
 * Builds a complex polygon to draw
 *
 * @private
 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildComplexPoly = function (graphicsData, webGLData)
{
    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..
    var points = graphicsData.points.slice();

    if (points.length < 6)
    {
        return;
    }

    // get first and last point.. figure out the middle!
    var indices = webGLData.indices;
    webGLData.points = points;
    webGLData.alpha = graphicsData.fillAlpha;
    webGLData.color = utils.hex2rgb(graphicsData.fillColor);

    // calclate the bounds..
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var x,y;

    // get size..
    for (var i = 0; i < points.length; i+=2)
    {
        x = points[i];
        y = points[i+1];

        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;

        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
    }

    // add a quad to the end cos there is no point making another buffer!
    points.push(minX, minY,
                maxX, minY,
                maxX, maxY,
                minX, maxY);

    // push a quad onto the end..

    //TODO - this aint needed!
    var length = points.length / 2;
    for (i = 0; i < length; i++)
    {
        indices.push( i );
    }

};

/**
 * Builds a polygon to draw
 *
 * @private
 * @param graphicsData {PIXI.WebGLGraphicsData} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildPoly = function (graphicsData, webGLData)
{
    var points = graphicsData.points;

    if (points.length < 6)
    {
        return;
    }

    // get first and last point.. figure out the middle!
    var verts = webGLData.points;
    var indices = webGLData.indices;

    var length = points.length / 2;

    // sort color
    var color = utils.hex2rgb(graphicsData.fillColor);
    var alpha = graphicsData.fillAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var triangles = earcut(points, null, 2);

    if (!triangles) {
        return false;
    }

    var vertPos = verts.length / 6;

    var i = 0;

    for (i = 0; i < triangles.length; i+=3)
    {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i+1] + vertPos);
        indices.push(triangles[i+2] +vertPos);
        indices.push(triangles[i+2] + vertPos);
    }

    for (i = 0; i < length; i++)
    {
        verts.push(points[i * 2], points[i * 2 + 1],
                   r, g, b, alpha);
    }

    return true;
};

},{"../../const":16,"../../math":26,"../../renderers/webgl/WebGLRenderer":42,"../../renderers/webgl/utils/ObjectRenderer":56,"../../utils":70,"./WebGLGraphicsData":22,"earcut":9}],22:[function(require,module,exports){
/**
 * An object containing WebGL specific properties to be used by the WebGL renderer
 *
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 * @private
 */
function WebGLGraphicsData(gl) {

    /**
     * The current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    //TODO does this need to be split before uploding??
    /**
     * An array of color components (r,g,b)
     * @member {number[]}
     */
    this.color = [0,0,0]; // color split!

    /**
     * An array of points to draw
     * @member {PIXI.Point[]}
     */
    this.points = [];

    /**
     * The indices of the vertices
     * @member {number[]}
     */
    this.indices = [];
    /**
     * The main buffer
     * @member {WebGLBuffer}
     */
    this.buffer = gl.createBuffer();

    /**
     * The index buffer
     * @member {WebGLBuffer}
     */
    this.indexBuffer = gl.createBuffer();

    /**
     * todo @alvin
     * @member {number}
     */
    this.mode = 1;

    /**
     * The alpha of the graphics
     * @member {number}
     */
    this.alpha = 1;

    /**
     * Whether this graphics is dirty or not
     * @member {boolean}
     */
    this.dirty = true;

    this.glPoints = null;
    this.glIndices = null;
}

WebGLGraphicsData.prototype.constructor = WebGLGraphicsData;
module.exports = WebGLGraphicsData;

/**
 * Resets the vertices and the indices
 */
WebGLGraphicsData.prototype.reset = function () {
    this.points.length = 0;
    this.indices.length = 0;
};

/**
 * Binds the buffers and uploads the data
 */
WebGLGraphicsData.prototype.upload = function () {
    var gl = this.gl;

//    this.lastIndex = graphics.graphicsData.length;
    this.glPoints = new Float32Array(this.points);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);

    this.glIndices = new Uint16Array(this.indices);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndices, gl.STATIC_DRAW);

    this.dirty = false;
};

WebGLGraphicsData.prototype.destroy = function () {
    this.color = null;
    this.points = null;
    this.indices = null;

    this.gl.deleteBuffer(this.buffer);
    this.gl.deleteBuffer(this.indexBuffer);
    
    this.gl = null;

    this.buffer = null;
    this.indexBuffer = null;

    this.glPoints = null;
    this.glIndices = null;
};

},{}],23:[function(require,module,exports){
/**
 * @file        Main export of the PIXI core library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI
 */
// export core and const. We assign core to const so that the non-reference types in const remain in-tact
var core = module.exports = Object.assign(require('./const'), require('./math'), {
    // utils
    utils: require('./utils'),
    ticker: require('./ticker'),

    // display
    DisplayObject:          require('./display/DisplayObject'),
    Container:              require('./display/Container'),

    // sprites
    Sprite:                 require('./sprites/Sprite'),
    ParticleContainer:      require('./particles/ParticleContainer'),
    SpriteRenderer:         require('./sprites/webgl/SpriteRenderer'),
    ParticleRenderer:       require('./particles/webgl/ParticleRenderer'),

    // text
    Text:                   require('./text/Text'),

    // primitives
    Graphics:               require('./graphics/Graphics'),
    GraphicsData:           require('./graphics/GraphicsData'),
    GraphicsRenderer:       require('./graphics/webgl/GraphicsRenderer'),

    // textures
    Texture:                require('./textures/Texture'),
    BaseTexture:            require('./textures/BaseTexture'),
    RenderTexture:          require('./textures/RenderTexture'),
    VideoBaseTexture:       require('./textures/VideoBaseTexture'),
    TextureUvs:             require('./textures/TextureUvs'),

    // renderers - canvas
    CanvasRenderer:         require('./renderers/canvas/CanvasRenderer'),
    CanvasGraphics:         require('./renderers/canvas/utils/CanvasGraphics'),
    CanvasBuffer:           require('./renderers/canvas/utils/CanvasBuffer'),

    // renderers - webgl
    WebGLRenderer:          require('./renderers/webgl/WebGLRenderer'),
    WebGLManager:          require('./renderers/webgl/managers/WebGLManager'),
    ShaderManager:          require('./renderers/webgl/managers/ShaderManager'),
    Shader:                 require('./renderers/webgl/shaders/Shader'),
    ObjectRenderer:         require('./renderers/webgl/utils/ObjectRenderer'),
    RenderTarget:           require('./renderers/webgl/utils/RenderTarget'),

    // filters - webgl
    AbstractFilter:         require('./renderers/webgl/filters/AbstractFilter'),
    FXAAFilter:             require('./renderers/webgl/filters/FXAAFilter'),
    SpriteMaskFilter:       require('./renderers/webgl/filters/SpriteMaskFilter'),

    /**
     * This helper function will automatically detect which renderer you should be using.
     * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
     * the browser then this function will return a canvas renderer
     *
     * @memberof PIXI
     * @param width=800 {number} the width of the renderers view
     * @param height=600 {number} the height of the renderers view
     * @param [options] {object} The optional renderer parameters
     * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
     * @param [options.transparent=false] {boolean} If the render view is transparent, default false
     * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
     * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if you
     *      need to call toDataUrl on the webgl context
     * @param [options.resolution=1] {number} the resolution of the renderer, retina would be 2
     * @param [noWebGL=false] {boolean} prevents selection of WebGL renderer, even if such is present
     *
     * @return {WebGLRenderer|CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
     */
    autoDetectRenderer: function (width, height, options, noWebGL)
    {
        width = width || 800;
        height = height || 600;

        if (!noWebGL && core.utils.isWebGLSupported())
        {
            return new core.WebGLRenderer(width, height, options);
        }

        return new core.CanvasRenderer(width, height, options);
    }
});

},{"./const":16,"./display/Container":17,"./display/DisplayObject":18,"./graphics/Graphics":19,"./graphics/GraphicsData":20,"./graphics/webgl/GraphicsRenderer":21,"./math":26,"./particles/ParticleContainer":32,"./particles/webgl/ParticleRenderer":34,"./renderers/canvas/CanvasRenderer":37,"./renderers/canvas/utils/CanvasBuffer":38,"./renderers/canvas/utils/CanvasGraphics":39,"./renderers/webgl/WebGLRenderer":42,"./renderers/webgl/filters/AbstractFilter":43,"./renderers/webgl/filters/FXAAFilter":44,"./renderers/webgl/filters/SpriteMaskFilter":45,"./renderers/webgl/managers/ShaderManager":49,"./renderers/webgl/managers/WebGLManager":51,"./renderers/webgl/shaders/Shader":54,"./renderers/webgl/utils/ObjectRenderer":56,"./renderers/webgl/utils/RenderTarget":58,"./sprites/Sprite":60,"./sprites/webgl/SpriteRenderer":61,"./text/Text":62,"./textures/BaseTexture":63,"./textures/RenderTexture":64,"./textures/Texture":65,"./textures/TextureUvs":66,"./textures/VideoBaseTexture":67,"./ticker":69,"./utils":70}],24:[function(require,module,exports){
// @todo - ignore the too many parameters warning for now
// should either fix it or change the jshint config
// jshint -W072

var Point = require('./Point');

/**
 * The pixi Matrix class as an object, which makes it a lot faster,
 * here is a representation of it :
 * | a | b | tx|
 * | c | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 */
function Matrix()
{
    /**
     * @member {number}
     * @default 1
     */
    this.a = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.b = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.c = 0;

    /**
     * @member {number}
     * @default 1
     */
    this.d = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.tx = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.ty = 0;
}

Matrix.prototype.constructor = Matrix;
module.exports = Matrix;

/**
 * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
 *
 * a = array[0]
 * b = array[1]
 * c = array[3]
 * d = array[4]
 * tx = array[2]
 * ty = array[5]
 *
 * @param array {number[]} The array that the matrix will be populated from.
 */
Matrix.prototype.fromArray = function (array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};


/**
 * sets the matrix properties
 *
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @param {number} tx
 * @param {number} ty
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.set = function (a, b, c, d, tx, ty)
{
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;

    return this;
};


/**
 * Creates an array from the current Matrix object.
 *
 * @param transpose {boolean} Whether we need to transpose the matrix or not
 * @param [out] {Array} If provided the array will be assigned to out
 * @return {number[]} the newly created array which contains the matrix
 */
Matrix.prototype.toArray = function (transpose, out)
{
    if (!this.array)
    {
        this.array = new Float32Array(9);
    }

    var array = out || this.array;

    if (transpose)
    {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
    }
    else
    {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
    }

    return array;
};

/**
 * Get a new position with the current transformation applied.
 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
 *
 * @param pos {PIXI.Point} The origin
 * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {PIXI.Point} The new point, transformed through this matrix
 */
Matrix.prototype.apply = function (pos, newPos)
{
    newPos = newPos || new Point();

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;

    return newPos;
};

/**
 * Get a new position with the inverse of the current transformation applied.
 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
 *
 * @param pos {PIXI.Point} The origin
 * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {PIXI.Point} The new point, inverse-transformed through this matrix
 */
Matrix.prototype.applyInverse = function (pos, newPos)
{
    newPos = newPos || new Point();

    var id = 1 / (this.a * this.d + this.c * -this.b);

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

    return newPos;
};

/**
 * Translates the matrix on the x and y.
 *
 * @param {number} x
 * @param {number} y
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.translate = function (x, y)
{
    this.tx += x;
    this.ty += y;

    return this;
};

/**
 * Applies a scale transformation to the matrix.
 *
 * @param {number} x The amount to scale horizontally
 * @param {number} y The amount to scale vertically
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.scale = function (x, y)
{
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;

    return this;
};


/**
 * Applies a rotation transformation to the matrix.
 *
 * @param {number} angle - The angle in radians.
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.rotate = function (angle)
{
    var cos = Math.cos( angle );
    var sin = Math.sin( angle );

    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;

    this.a = a1 * cos-this.b * sin;
    this.b = a1 * sin+this.b * cos;
    this.c = c1 * cos-this.d * sin;
    this.d = c1 * sin+this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;

    return this;
};

/**
 * Appends the given Matrix to this Matrix.
 *
 * @param {PIXI.Matrix} matrix
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.append = function (matrix)
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;

    this.a  = matrix.a * a1 + matrix.b * c1;
    this.b  = matrix.a * b1 + matrix.b * d1;
    this.c  = matrix.c * a1 + matrix.d * c1;
    this.d  = matrix.c * b1 + matrix.d * d1;

    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

    return this;
};

/**
 * Sets the matrix based on all the available properties
 *
 * @param {number} x
 * @param {number} y
 * @param {number} pivotX
 * @param {number} pivotY
 * @param {number} scaleX
 * @param {number} scaleY
 * @param {number} rotation
 * @param {number} skewX
 * @param {number} skewY
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.setTransform = function (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY)
{
    var a, b, c, d, sr, cr, cy, sy, nsx, cx;

    sr  = Math.sin(rotation);
    cr  = Math.cos(rotation);
    cy  = Math.cos(skewY);
    sy  = Math.sin(skewY);
    nsx = -Math.sin(skewX);
    cx  =  Math.cos(skewX);

    a  =  cr * scaleX;
    b  =  sr * scaleX;
    c  = -sr * scaleY;
    d  =  cr * scaleY;

    this.a  = cy * a + sy * c;
    this.b  = cy * b + sy * d;
    this.c  = nsx * a + cx * c;
    this.d  = nsx * b + cx * d;

    this.tx = x + ( pivotX * a + pivotY * c );
    this.ty = y + ( pivotX * b + pivotY * d );

    return this;
};

/**
 * Prepends the given Matrix to this Matrix.
 *
 * @param {PIXI.Matrix} matrix
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.prepend = function(matrix)
{
    var tx1 = this.tx;

    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)
    {
        var a1 = this.a;
        var c1 = this.c;
        this.a  = a1*matrix.a+this.b*matrix.c;
        this.b  = a1*matrix.b+this.b*matrix.d;
        this.c  = c1*matrix.a+this.d*matrix.c;
        this.d  = c1*matrix.b+this.d*matrix.d;
    }

    this.tx = tx1*matrix.a+this.ty*matrix.c+matrix.tx;
    this.ty = tx1*matrix.b+this.ty*matrix.d+matrix.ty;

    return this;
};

/**
 * Inverts this matrix
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.invert = function()
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n = a1*d1-b1*c1;

    this.a = d1/n;
    this.b = -b1/n;
    this.c = -c1/n;
    this.d = a1/n;
    this.tx = (c1*this.ty-d1*tx1)/n;
    this.ty = -(a1*this.ty-b1*tx1)/n;

    return this;
};


/**
 * Resets this Matix to an identity (default) matrix.
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.identity = function ()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;

    return this;
};

/**
 * Creates a new Matrix object with the same values as this one.
 *
 * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
 */
Matrix.prototype.clone = function ()
{
    var matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * Changes the values of the given matrix to be the same as the ones in this matrix
 *
 * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
 */
Matrix.prototype.copy = function (matrix)
{
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * A default (identity) matrix
 *
 * @static
 * @const
 */
Matrix.IDENTITY = new Matrix();

/**
 * A temp matrix
 *
 * @static
 * @const
 */
Matrix.TEMP_MATRIX = new Matrix();

},{"./Point":25}],25:[function(require,module,exports){
/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
function Point(x, y)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;
}

Point.prototype.constructor = Point;
module.exports = Point;

/**
 * Creates a clone of this point
 *
 * @return {PIXI.Point} a copy of the point
 */
Point.prototype.clone = function ()
{
    return new Point(this.x, this.y);
};

/**
 * Copies x and y from the given point
 *
 * @param p {PIXI.Point}
 */
Point.prototype.copy = function (p) {
    this.set(p.x, p.y);
};

/**
 * Returns true if the given point is equal to this point
 *
 * @param p {PIXI.Point}
 * @returns {boolean}
 */
Point.prototype.equals = function (p) {
    return (p.x === this.x) && (p.y === this.y);
};

/**
 * Sets the point to a new x and y position.
 * If y is omitted, both x and y will be set to x.
 *
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
Point.prototype.set = function (x, y)
{
    this.x = x || 0;
    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
};

},{}],26:[function(require,module,exports){
/**
 * Math classes and utilities mixed into PIXI namespace.
 *
 * @lends PIXI
 */
module.exports = {
    // These will be mixed to be made publicly available,
    // while this module is used internally in core
    // to avoid circular dependencies and cut down on
    // internal module requires.

    Point:      require('./Point'),
    Matrix:     require('./Matrix'),

    Circle:     require('./shapes/Circle'),
    Ellipse:    require('./shapes/Ellipse'),
    Polygon:    require('./shapes/Polygon'),
    Rectangle:  require('./shapes/Rectangle'),
    RoundedRectangle: require('./shapes/RoundedRectangle')
};

},{"./Matrix":24,"./Point":25,"./shapes/Circle":27,"./shapes/Ellipse":28,"./shapes/Polygon":29,"./shapes/Rectangle":30,"./shapes/RoundedRectangle":31}],27:[function(require,module,exports){
var Rectangle = require('./Rectangle'),
    CONST = require('../../const');

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the center of this circle
 * @param y {number} The Y coordinate of the center of this circle
 * @param radius {number} The radius of the circle
 */
function Circle(x, y, radius)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.CIRC;
}

Circle.prototype.constructor = Circle;
module.exports = Circle;

/**
 * Creates a clone of this Circle instance
 *
 * @return {PIXI.Circle} a copy of the Circle
 */
Circle.prototype.clone = function ()
{
    return new Circle(this.x, this.y, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this circle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Circle
 */
Circle.prototype.contains = function (x, y)
{
    if (this.radius <= 0)
    {
        return false;
    }

    var dx = (this.x - x),
        dy = (this.y - y),
        r2 = this.radius * this.radius;

    dx *= dx;
    dy *= dy;

    return (dx + dy <= r2);
};

/**
* Returns the framing rectangle of the circle as a Rectangle object
*
* @return {PIXI.Rectangle} the framing rectangle
*/
Circle.prototype.getBounds = function ()
{
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
};

},{"../../const":16,"./Rectangle":30}],28:[function(require,module,exports){
var Rectangle = require('./Rectangle'),
    CONST = require('../../const');

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the center of the ellipse
 * @param y {number} The Y coordinate of the center of the ellipse
 * @param width {number} The half width of this ellipse
 * @param height {number} The half height of this ellipse
 */
function Ellipse(x, y, width, height)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.ELIP;
}

Ellipse.prototype.constructor = Ellipse;
module.exports = Ellipse;

/**
 * Creates a clone of this Ellipse instance
 *
 * @return {PIXI.Ellipse} a copy of the ellipse
 */
Ellipse.prototype.clone = function ()
{
    return new Ellipse(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this ellipse
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coords are within this ellipse
 */
Ellipse.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    //normalize the coords to an ellipse with center 0,0
    var normx = ((x - this.x) / this.width),
        normy = ((y - this.y) / this.height);

    normx *= normx;
    normy *= normy;

    return (normx + normy <= 1);
};

/**
 * Returns the framing rectangle of the ellipse as a Rectangle object
 *
 * @return {PIXI.Rectangle} the framing rectangle
 */
Ellipse.prototype.getBounds = function ()
{
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
};

},{"../../const":16,"./Rectangle":30}],29:[function(require,module,exports){
var Point = require('../Point'),
    CONST = require('../../const');

/**
 * @class
 * @memberof PIXI
 * @param points {PIXI.Point[]|number[]|...PIXI.Point|...number} This can be an array of Points that form the polygon,
 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
 *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
 *      Numbers.
 */
function Polygon(points_)
{
    // prevents an argument assignment deopt
    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var points = points_;

    //if points isn't an array, use arguments as the array
    if (!Array.isArray(points))
    {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var a = 0; a < points.length; ++a) {
            points[a] = arguments[a];
        }
    }

    // if this is an array of points, convert it to a flat array of numbers
    if (points[0] instanceof Point)
    {
        var p = [];
        for (var i = 0, il = points.length; i < il; i++)
        {
            p.push(points[i].x, points[i].y);
        }

        points = p;
    }

    this.closed = true;

    /**
     * An array of the points of this polygon
     *
     * @member {number[]}
     */
    this.points = points;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.POLY;
}

Polygon.prototype.constructor = Polygon;
module.exports = Polygon;

/**
 * Creates a clone of this polygon
 *
 * @return {PIXI.Polygon} a copy of the polygon
 */
Polygon.prototype.clone = function ()
{
    return new Polygon(this.points.slice());
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this polygon
 */
Polygon.prototype.contains = function (x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    var length = this.points.length / 2;

    for (var i = 0, j = length - 1; i < length; j = i++)
    {
        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],
            xj = this.points[j * 2], yj = this.points[j * 2 + 1],
            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect)
        {
            inside = !inside;
        }
    }

    return inside;
};

},{"../../const":16,"../Point":25}],30:[function(require,module,exports){
var CONST = require('../../const');

/**
 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the upper-left corner of the rectangle
 * @param y {number} The Y coordinate of the upper-left corner of the rectangle
 * @param width {number} The overall width of this rectangle
 * @param height {number} The overall height of this rectangle
 */
function Rectangle(x, y, width, height)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.RECT;
}

Rectangle.prototype.constructor = Rectangle;
module.exports = Rectangle;

/**
 * A constant empty rectangle.
 *
 * @static
 * @constant
 */
Rectangle.EMPTY = new Rectangle(0, 0, 0, 0);


/**
 * Creates a clone of this Rectangle
 *
 * @return {PIXI.Rectangle} a copy of the rectangle
 */
Rectangle.prototype.clone = function ()
{
    return new Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rectangle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rectangle
 */
Rectangle.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x < this.x + this.width)
    {
        if (y >= this.y && y < this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

},{"../../const":16}],31:[function(require,module,exports){
var CONST = require('../../const');

/**
 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its top-left corner point (x, y) and by its width and its height and its radius.
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the upper-left corner of the rounded rectangle
 * @param y {number} The Y coordinate of the upper-left corner of the rounded rectangle
 * @param width {number} The overall width of this rounded rectangle
 * @param height {number} The overall height of this rounded rectangle
 * @param radius {number} Controls the radius of the rounded corners
 */
function RoundedRectangle(x, y, width, height, radius)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * @member {number}
     * @default 20
     */
    this.radius = radius || 20;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.RREC;
}

RoundedRectangle.prototype.constructor = RoundedRectangle;
module.exports = RoundedRectangle;

/**
 * Creates a clone of this Rounded Rectangle
 *
 * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
 */
RoundedRectangle.prototype.clone = function ()
{
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
 */
RoundedRectangle.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x <= this.x + this.width)
    {
        if (y >= this.y && y <= this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

},{"../../const":16}],32:[function(require,module,exports){
var Container = require('../display/Container'),
    CONST = require('../const');

/**
 * The ParticleContainer class is a really fast version of the Container built solely for speed,
 * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced
 * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).
 * Any other functionality like tinting, masking, etc will not work on sprites in this batch.
 *
 * It's extremely easy to use :
 *
 * ```js
 * var container = new ParticleContainer();
 *
 * for (var i = 0; i < 100; ++i)
 * {
 *     var sprite = new PIXI.Sprite.fromImage("myImage.png");
 *     container.addChild(sprite);
 * }
 * ```
 *
 * And here you have a hundred sprites that will be renderer at the speed of light.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 * @param [maxSize=15000] {number} The maximum number of particles that can be renderer by the container.
 * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.
 * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.
 * @param [properties.position=true] {boolean} When true, position be uploaded and applied.
 * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.
 * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.
 * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.
 * @param [batchSize=15000] {number} Number of particles per batch.
 */
function ParticleContainer(maxSize, properties, batchSize)
{
    Container.call(this);

    batchSize = batchSize || 15000; //CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
    maxSize = maxSize || 15000;

    // Making sure the batch size is valid
    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
    // so max number of particles is 65536 / 4 = 16384
    var maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
        batchSize = maxBatchSize;
    }

    if (batchSize > maxSize) {
        batchSize = maxSize;
    }

    /**
     * Set properties to be dynamic (true) / static (false)
     *
     * @member {boolean[]}
     * @private
     */
    this._properties = [false, true, false, false, false];

    /**
     * @member {number}
     * @private
     */
    this._maxSize = maxSize;

    /**
     * @member {number}
     * @private
     */
    this._batchSize = batchSize;

    /**
     * @member {WebGLBuffer}
     * @private
     */
    this._buffers = null;

    /**
     * @member {number}
     * @private
     */
    this._bufferToUpdate = 0;

    /**
     * @member {boolean}
     *
     */
    this.interactiveChildren = false;

    /**
     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * Used for canvas renderering. If true then the elements will be positioned at the nearest pixel. This provides a nice speed boost.
     *
     * @member {boolean}
     * @default true;
     */
    this.roundPixels = true;

    this.setProperties(properties);
}

ParticleContainer.prototype = Object.create(Container.prototype);
ParticleContainer.prototype.constructor = ParticleContainer;
module.exports = ParticleContainer;

/**
 * Sets the private properties array to dynamic / static based on the passed properties object
 *
 * @param properties {object} The properties to be uploaded
 */
ParticleContainer.prototype.setProperties = function(properties)
{
    if ( properties ) {
        this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];
        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];
    }
};

/**
 * Updates the object transform for rendering
 *
 * @private
 */
ParticleContainer.prototype.updateTransform = function ()
{

    // TODO don't need to!
    this.displayObjectUpdateTransform();
    //  PIXI.Container.prototype.updateTransform.call( this );
};

/**
 * Renders the container using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The webgl renderer
 * @private
 */
ParticleContainer.prototype.renderWebGL = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
    {
        return;
    }

    renderer.setObjectRenderer( renderer.plugins.particle );
    renderer.plugins.particle.render( this );
};

/**
 * Set the flag that static data should be updated to true
 *
 * @private
 */
ParticleContainer.prototype.onChildrenChange = function (smallestChildIndex)
{
    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    if (bufferIndex < this._bufferToUpdate) {
        this._bufferToUpdate = bufferIndex;
    }
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} The canvas renderer
 * @private
 */
ParticleContainer.prototype.renderCanvas = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
    {
        return;
    }

    var context = renderer.context;
    var transform = this.worldTransform;
    var isRotated = true;

    var positionX = 0;
    var positionY = 0;

    var finalWidth = 0;
    var finalHeight = 0;

    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== context.globalCompositeOperation)
    {
        context.globalCompositeOperation = compositeOperation;
    }

    context.globalAlpha = this.worldAlpha;

    this.displayObjectUpdateTransform();

    for (var i = 0; i < this.children.length; ++i)
    {
        var child = this.children[i];

        if (!child.visible)
        {
            continue;
        }

        var frame = child.texture.frame;

        context.globalAlpha = this.worldAlpha * child.alpha;

        if (child.rotation % (Math.PI * 2) === 0)
        {
            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
            if (isRotated)
            {
                context.setTransform(
                    transform.a,
                    transform.b,
                    transform.c,
                    transform.d,
                    transform.tx,
                    transform.ty
                );

                isRotated = false;
            }

            positionX = ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5);
            positionY = ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5);

            finalWidth = frame.width * child.scale.x;
            finalHeight = frame.height * child.scale.y;

        }
        else
        {
            if (!isRotated)
            {
                isRotated = true;
            }

            child.displayObjectUpdateTransform();

            var childTransform = child.worldTransform;

            if (renderer.roundPixels)
            {
                context.setTransform(
                    childTransform.a,
                    childTransform.b,
                    childTransform.c,
                    childTransform.d,
                    childTransform.tx | 0,
                    childTransform.ty | 0
                );
            }
            else
            {
                context.setTransform(
                    childTransform.a,
                    childTransform.b,
                    childTransform.c,
                    childTransform.d,
                    childTransform.tx,
                    childTransform.ty
                );
            }

            positionX = ((child.anchor.x) * (-frame.width) + 0.5);
            positionY = ((child.anchor.y) * (-frame.height) + 0.5);

            finalWidth = frame.width;
            finalHeight = frame.height;
        }

        context.drawImage(
            child.texture.baseTexture.source,
            frame.x,
            frame.y,
            frame.width,
            frame.height,
            positionX,
            positionY,
            finalWidth,
            finalHeight
        );
    }
};

/**
 * Destroys the container
 *
 * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well
 */
ParticleContainer.prototype.destroy = function () {
    Container.prototype.destroy.apply(this, arguments);

    if (this._buffers) {
        for (var i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();
        }
    }

    this._properties = null;
    this._buffers = null;
};

},{"../const":16,"../display/Container":17}],33:[function(require,module,exports){

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleBuffer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java
 */

/**
 * The particle buffer manages the static and dynamic buffers for a particle container.
 *
 * @class
 * @private
 * @memberof PIXI
 */
function ParticleBuffer(gl, properties, dynamicPropertyFlags, size)
{
    /**
     * The current WebGL drawing context.
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * Size of a single vertex.
     *
     * @member {number}
     */
    this.vertSize = 2;

    /**
     * Size of a single vertex in bytes.
     *
     * @member {number}
     */
    this.vertByteSize = this.vertSize * 4;

    /**
     * The number of particles the buffer can hold
     *
     * @member {number}
     */
    this.size = size;

    /**
     * A list of the properties that are dynamic.
     *
     * @member {object[]}
     */
    this.dynamicProperties = [];

    /**
     * A list of the properties that are static.
     *
     * @member {object[]}
     */
    this.staticProperties = [];

    for (var i = 0; i < properties.length; i++)
    {
        var property = properties[i];

        if(dynamicPropertyFlags[i])
        {
            this.dynamicProperties.push(property);
        }
        else
        {
            this.staticProperties.push(property);
        }
    }

    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;

    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;

    this.initBuffers();

}

ParticleBuffer.prototype.constructor = ParticleBuffer;
module.exports = ParticleBuffer;

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 */
ParticleBuffer.prototype.initBuffers = function ()
{
    var gl = this.gl;
    var i;
    var property;

    var dynamicOffset = 0;
    this.dynamicStride = 0;

    for (i = 0; i < this.dynamicProperties.length; i++)
    {
        property = this.dynamicProperties[i];

        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
    }

    this.dynamicData = new Float32Array( this.size * this.dynamicStride * 4);
    this.dynamicBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.dynamicData, gl.DYNAMIC_DRAW);


    // static //
    var staticOffset = 0;
    this.staticStride = 0;

    for (i = 0; i < this.staticProperties.length; i++)
    {
        property = this.staticProperties[i];

        property.offset = staticOffset;
        staticOffset += property.size;
        this.staticStride += property.size;
    }

    this.staticData = new Float32Array( this.size * this.staticStride * 4);
    this.staticBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.staticData, gl.DYNAMIC_DRAW);
};

/**
 * Uploads the dynamic properties.
 *
 */
ParticleBuffer.prototype.uploadDynamic = function(children, startIndex, amount)
{
    var gl = this.gl;

    for (var i = 0; i < this.dynamicProperties.length; i++)
    {
        var property = this.dynamicProperties[i];
        property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dynamicData);
};

/**
 * Uploads the static properties.
 *
 */
ParticleBuffer.prototype.uploadStatic = function(children, startIndex, amount)
{
    var gl = this.gl;

    for (var i = 0; i < this.staticProperties.length; i++)
    {
        var property = this.staticProperties[i];
        property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.staticData);
};

/**
 * Binds the buffers to the GPU
 *
 */
ParticleBuffer.prototype.bind = function ()
{
    var gl = this.gl;
    var i, property;

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);

    for (i = 0; i < this.dynamicProperties.length; i++)
    {
        property = this.dynamicProperties[i];
        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.dynamicStride * 4, property.offset * 4);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);

    for (i = 0; i < this.staticProperties.length; i++)
    {
        property = this.staticProperties[i];
        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.staticStride * 4, property.offset * 4);
    }
};

/**
 * Destroys the ParticleBuffer.
 *
 */
ParticleBuffer.prototype.destroy = function ()
{
    this.dynamicProperties = null;
    this.dynamicData = null;
    this.gl.deleteBuffer(this.dynamicBuffer);

    this.staticProperties = null;
    this.staticData = null;
    this.gl.deleteBuffer(this.staticBuffer);
};

},{}],34:[function(require,module,exports){
var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    ParticleShader = require('./ParticleShader'),
    ParticleBuffer = require('./ParticleBuffer'),
    math            = require('../../math');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
 */
function ParticleRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
    // so max number of particles is 65536 / 4 = 16384
    // and max number of element in the index buffer is 16384 * 6 = 98304
    // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
    var numIndices = 98304;

    /**
     * Holds the indices
     *
     * @member {Uint16Array}
     */
    this.indices = new Uint16Array(numIndices);

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     * The default shader that is used if a sprite doesn't have a more specific one.
     *
     * @member {PIXI.Shader}
     */
    this.shader = null;

    this.indexBuffer = null;

    this.properties = null;

    this.tempMatrix = new math.Matrix();
}

ParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);
ParticleRenderer.prototype.constructor = ParticleRenderer;
module.exports = ParticleRenderer;

WebGLRenderer.registerPlugin('particle', ParticleRenderer);

/**
 * When there is a WebGL context change
 *
 * @private
 */
ParticleRenderer.prototype.onContextChange = function ()
{
    var gl = this.renderer.gl;

    // setup default shader
    this.shader = new ParticleShader(this.renderer.shaderManager);

    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    this.properties = [
        // verticesData
        {
            attribute:this.shader.attributes.aVertexPosition,
            size:2,
            uploadFunction:this.uploadVertices,
            offset:0
        },
        // positionData
        {
            attribute:this.shader.attributes.aPositionCoord,
            size:2,
            uploadFunction:this.uploadPosition,
            offset:0
        },
        // rotationData
        {
            attribute:this.shader.attributes.aRotation,
            size:1,
            uploadFunction:this.uploadRotation,
            offset:0
        },
        // uvsData
        {
            attribute:this.shader.attributes.aTextureCoord,
            size:2,
            uploadFunction:this.uploadUvs,
            offset:0
        },
        // alphaData
        {
            attribute:this.shader.attributes.aColor,
            size:1,
            uploadFunction:this.uploadAlpha,
            offset:0
        }
    ];
};

/**
 * Starts a new particle batch.
 *
 */
ParticleRenderer.prototype.start = function ()
{
    var gl = this.renderer.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    var shader = this.shader;

    this.renderer.shaderManager.setShader(shader);
};


/**
 * Renders the particle container object.
 *
 * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer
 */
ParticleRenderer.prototype.render = function (container)
{
    var children = container.children,
        totalChildren = children.length,
        maxSize = container._maxSize,
        batchSize = container._batchSize;

    if(totalChildren === 0)
    {
        return;
    }
    else if(totalChildren > maxSize)
    {
        totalChildren = maxSize;
    }

    if(!container._buffers)
    {
        container._buffers = this.generateBuffers( container );
    }

    // if the uvs have not updated then no point rendering just yet!
    this.renderer.blendModeManager.setBlendMode(container.blendMode);

    var gl = this.renderer.gl;

    var m =  container.worldTransform.copy( this.tempMatrix );
    m.prepend( this.renderer.currentRenderTarget.projectionMatrix );
    gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));
    gl.uniform1f(this.shader.uniforms.uAlpha._location, container.worldAlpha);


    // make sure the texture is bound..
    var baseTexture = children[0]._texture.baseTexture;

    if (!baseTexture._glTextures[gl.id])
    {
        // if the texture has not updated then lets not upload any static properties
        if(!this.renderer.updateTexture(baseTexture))
        {
            return;
        }

        if(!container._properties[0] || !container._properties[3])
        {
            container._bufferToUpdate = 0;
        }
    }
    else
    {
        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
    }

    // now lets upload and render the buffers..
    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)
    {
        var amount = ( totalChildren - i);
        if(amount > batchSize)
        {
            amount = batchSize;
        }

        var buffer = container._buffers[j];

        // we always upload the dynamic
        buffer.uploadDynamic(children, i, amount);

        // we only upload the static content when we have to!
        if(container._bufferToUpdate === j)
        {
            buffer.uploadStatic(children, i, amount);
            container._bufferToUpdate = j + 1;
        }

        // bind the buffer
        buffer.bind( this.shader );

         // now draw those suckas!
        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        this.renderer.drawCount++;
    }
};

/**
 * Creates one particle buffer for each child in the container we want to render and updates internal properties
 *
 * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer
 */
ParticleRenderer.prototype.generateBuffers = function (container)
{
    var gl = this.renderer.gl,
        buffers = [],
        size = container._maxSize,
        batchSize = container._batchSize,
        dynamicPropertyFlags = container._properties,
        i;

    for (i = 0; i < size; i += batchSize)
    {
        buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));
    }

    return buffers;
};

/**
 * Uploads the verticies.
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their vertices uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset)
{
    var sprite,
        texture,
        trim,
        sx,
        sy,
        w0, w1, h0, h1;

    for (var i = 0; i < amount; i++) {

        sprite = children[startIndex + i];
        texture = sprite._texture;
        sx = sprite.scale.x;
        sy = sprite.scale.y;

        if (texture.trim)
        {
            // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
            trim = texture.trim;

            w1 = trim.x - sprite.anchor.x * trim.width;
            w0 = w1 + texture.crop.width;

            h1 = trim.y - sprite.anchor.y * trim.height;
            h0 = h1 + texture.crop.height;
        }
        else
        {
            w0 = (texture._frame.width ) * (1-sprite.anchor.x);
            w1 = (texture._frame.width ) * -sprite.anchor.x;

            h0 = texture._frame.height * (1-sprite.anchor.y);
            h1 = texture._frame.height * -sprite.anchor.y;
        }

        array[offset] = w1 * sx;
        array[offset + 1] = h1 * sy;

        array[offset + stride] = w0 * sx;
        array[offset + stride + 1] = h1 * sy;

        array[offset + stride * 2] = w0 * sx;
        array[offset + stride * 2 + 1] = h0 * sy;

        array[offset + stride * 3] = w1 * sx;
        array[offset + stride * 3 + 1] = h0 * sy;

        offset += stride * 4;
    }

};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their positions uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadPosition = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var spritePosition = children[startIndex + i].position;

        array[offset] = spritePosition.x;
        array[offset + 1] = spritePosition.y;

        array[offset + stride] = spritePosition.x;
        array[offset + stride + 1] = spritePosition.y;

        array[offset + stride * 2] = spritePosition.x;
        array[offset + stride * 2 + 1] = spritePosition.y;

        array[offset + stride * 3] = spritePosition.x;
        array[offset + stride * 3 + 1] = spritePosition.y;

        offset += stride * 4;
    }

};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their rotation uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadRotation = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var spriteRotation = children[startIndex + i].rotation;


        array[offset] = spriteRotation;
        array[offset + stride] = spriteRotation;
        array[offset + stride * 2] = spriteRotation;
        array[offset + stride * 3] = spriteRotation;

        offset += stride * 4;
    }
};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their Uvs uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadUvs = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var textureUvs = children[startIndex + i]._texture._uvs;

        if (textureUvs)
        {
            array[offset] = textureUvs.x0;
            array[offset + 1] = textureUvs.y0;

            array[offset + stride] = textureUvs.x1;
            array[offset + stride + 1] = textureUvs.y1;

            array[offset + stride * 2] = textureUvs.x2;
            array[offset + stride * 2 + 1] = textureUvs.y2;

            array[offset + stride * 3] = textureUvs.x3;
            array[offset + stride * 3 + 1] = textureUvs.y3;

            offset += stride * 4;
        }
        else
        {
            //TODO you know this can be easier!
            array[offset] = 0;
            array[offset + 1] = 0;

            array[offset + stride] = 0;
            array[offset + stride + 1] = 0;

            array[offset + stride * 2] = 0;
            array[offset + stride * 2 + 1] = 0;

            array[offset + stride * 3] = 0;
            array[offset + stride * 3 + 1] = 0;

            offset += stride * 4;
        }
    }
};

/**
 *
 * @param children {PIXI.DisplayObject[]} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their alpha uploaded
 * @param array {number[]}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadAlpha = function (children,startIndex, amount, array, stride, offset)
{
     for (var i = 0; i < amount; i++)
     {
        var spriteAlpha = children[startIndex + i].alpha;

        array[offset] = spriteAlpha;
        array[offset + stride] = spriteAlpha;
        array[offset + stride * 2] = spriteAlpha;
        array[offset + stride * 3] = spriteAlpha;

        offset += stride * 4;
    }
};


/**
 * Destroys the ParticleRenderer.
 *
 */
ParticleRenderer.prototype.destroy = function ()
{
    if (this.renderer.gl) {
        this.renderer.gl.deleteBuffer(this.indexBuffer);
    }

    ObjectRenderer.prototype.destroy.apply(this, arguments);

    this.shader.destroy();

    this.indices = null;
    this.tempMatrix = null;
};

},{"../../math":26,"../../renderers/webgl/WebGLRenderer":42,"../../renderers/webgl/utils/ObjectRenderer":56,"./ParticleBuffer":33,"./ParticleShader":35}],35:[function(require,module,exports){
var TextureShader = require('../../renderers/webgl/shaders/TextureShader');

/**
 * @class
 * @extends PIXI.TextureShader
 * @memberof PIXI
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 */
function ParticleShader(shaderManager)
{
    TextureShader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',
            'attribute vec2 aTextureCoord;',
            'attribute float aColor;',

            'attribute vec2 aPositionCoord;',
            'attribute vec2 aScale;',
            'attribute float aRotation;',

            'uniform mat3 projectionMatrix;',

            'varying vec2 vTextureCoord;',
            'varying float vColor;',

            'void main(void){',
            '   vec2 v = aVertexPosition;',

            '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);',
            '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);',
            '   v = v + aPositionCoord;',

            '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);',

            '   vTextureCoord = aTextureCoord;',
            '   vColor = aColor;',
            '}'
        ].join('\n'),
        // hello
         [
            'precision lowp float;',

            'varying vec2 vTextureCoord;',
            'varying float vColor;',

            'uniform sampler2D uSampler;',
            'uniform float uAlpha;',

            'void main(void){',
            '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uAlpha;',
            '  if (color.a == 0.0) discard;',
            '  gl_FragColor = color;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            uAlpha:  { type: '1f', value: 1 }
        },
        // custom attributes
        {
            aPositionCoord: 0,
           // aScale:         0,
            aRotation:      0
        }
    );

    // TEMP HACK

}

ParticleShader.prototype = Object.create(TextureShader.prototype);
ParticleShader.prototype.constructor = ParticleShader;

module.exports = ParticleShader;

},{"../../renderers/webgl/shaders/TextureShader":55}],36:[function(require,module,exports){
var utils = require('../utils'),
    math = require('../math'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3');

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @param system {string} The name of the system this renderer is for.
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 * @param [options.backgroundColor=0x000000] {number} The background color of the rendered area (shown if not transparent).
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function SystemRenderer(system, width, height, options)
{
    EventEmitter.call(this);

    utils.sayHello(system);

    // prepare options
    if (options)
    {
        for (var i in CONST.DEFAULT_RENDER_OPTIONS)
        {
            if (typeof options[i] === 'undefined')
            {
                options[i] = CONST.DEFAULT_RENDER_OPTIONS[i];
            }
        }
    }
    else
    {
        options = CONST.DEFAULT_RENDER_OPTIONS;
    }

    /**
     * The type of the renderer.
     *
     * @member {number}
     * @default PIXI.RENDERER_TYPE.UNKNOWN
     * @see PIXI.RENDERER_TYPE
     */
    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    /**
     * The width of the canvas view
     *
     * @member {number}
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @member {number}
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    this.view = options.view || document.createElement('canvas');

    /**
     * The resolution of the renderer
     *
     * @member {number}
     * @default 1
     */
    this.resolution = options.resolution;

    /**
     * Whether the render view is transparent
     *
     * @member {boolean}
     */
    this.transparent = options.transparent;

    /**
     * Whether the render view should be resized automatically
     *
     * @member {boolean}
     */
    this.autoResize = options.autoResize || false;

    /**
     * Tracks the blend modes useful for this renderer.
     *
     * @member {object<string, mixed>}
     */
    this.blendModes = null;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
     *
     * @member {boolean}
     */
    this.preserveDrawingBuffer = options.preserveDrawingBuffer;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @member {boolean}
     * @default
     */
    this.clearBeforeRender = options.clearBeforeRender;

    /**
     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Handy for crisp pixel art and speed on legacy devices.
     *
     * @member {boolean}
     */
    this.roundPixels = options.roundPixels;

    /**
     * The background color as a number.
     *
     * @member {number}
     * @private
     */
    this._backgroundColor = 0x000000;

    /**
     * The background color as an [R, G, B] array.
     *
     * @member {number[]}
     * @private
     */
    this._backgroundColorRgb = [0, 0, 0];

    /**
     * The background color as a string.
     *
     * @member {string}
     * @private
     */
    this._backgroundColorString = '#000000';

    this.backgroundColor = options.backgroundColor || this._backgroundColor; // run bg color setter

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};

    /**
     * The last root object that the renderer tried to render.
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._lastObjectRendered = this._tempDisplayObjectParent;
}

// constructor
SystemRenderer.prototype = Object.create(EventEmitter.prototype);
SystemRenderer.prototype.constructor = SystemRenderer;
module.exports = SystemRenderer;

Object.defineProperties(SystemRenderer.prototype, {
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     * @memberof PIXI.SystemRenderer#
     */
    backgroundColor:
    {
        get: function ()
        {
            return this._backgroundColor;
        },
        set: function (val)
        {
            this._backgroundColor = val;
            this._backgroundColorString = utils.hex2string(val);
            utils.hex2rgb(val, this._backgroundColorRgb);
        }
    }
});

/**
 * Resizes the canvas view to the specified width and height
 *
 * @param width {number} the new width of the canvas view
 * @param height {number} the new height of the canvas view
 */
SystemRenderer.prototype.resize = function (width, height) {
    this.width = width * this.resolution;
    this.height = height * this.resolution;

    this.view.width = this.width;
    this.view.height = this.height;

    if (this.autoResize)
    {
        this.view.style.width = this.width / this.resolution + 'px';
        this.view.style.height = this.height / this.resolution + 'px';
    }
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
SystemRenderer.prototype.destroy = function (removeView) {
    if (removeView && this.view.parentNode)
    {
        this.view.parentNode.removeChild(this.view);
    }

    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    this.width = 0;
    this.height = 0;

    this.view = null;

    this.resolution = 0;

    this.transparent = false;

    this.autoResize = false;

    this.blendModes = null;

    this.preserveDrawingBuffer = false;
    this.clearBeforeRender = false;

    this.roundPixels = false;

    this._backgroundColor = 0;
    this._backgroundColorRgb = null;
    this._backgroundColorString = null;
};

},{"../const":16,"../math":26,"../utils":70,"eventemitter3":10}],37:[function(require,module,exports){
var SystemRenderer = require('../SystemRenderer'),
    CanvasMaskManager = require('./utils/CanvasMaskManager'),
    utils = require('../../utils'),
    math = require('../../math'),
    CONST = require('../../const');

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function CanvasRenderer(width, height, options)
{
    options = options || {};

    SystemRenderer.call(this, 'Canvas', width, height, options);

    this.type = CONST.RENDERER_TYPE.CANVAS;

    /**
     * The canvas 2d context that everything is drawn with.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.view.getContext('2d', { alpha: this.transparent });

    /**
     * Boolean flag controlling canvas refresh.
     *
     * @member {boolean}
     */
    this.refresh = true;

    /**
     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
     *
     * @member {PIXI.CanvasMaskManager}
     */
    this.maskManager = new CanvasMaskManager();

    /**
     * The canvas property used to set the canvas smoothing property.
     *
     * @member {string}
     */
    this.smoothProperty = 'imageSmoothingEnabled';

    if (!this.context.imageSmoothingEnabled)
    {
        if (this.context.webkitImageSmoothingEnabled)
        {
            this.smoothProperty = 'webkitImageSmoothingEnabled';
        }
        else if (this.context.mozImageSmoothingEnabled)
        {
            this.smoothProperty = 'mozImageSmoothingEnabled';
        }
        else if (this.context.oImageSmoothingEnabled)
        {
            this.smoothProperty = 'oImageSmoothingEnabled';
        }
        else if (this.context.msImageSmoothingEnabled)
        {
            this.smoothProperty = 'msImageSmoothingEnabled';
        }
    }

    this.initPlugins();

    this._mapBlendModes();

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {
        worldTransform: new math.Matrix(),
        worldAlpha: 1
    };


    this.resize(width, height);
}

// constructor
CanvasRenderer.prototype = Object.create(SystemRenderer.prototype);
CanvasRenderer.prototype.constructor = CanvasRenderer;
module.exports = CanvasRenderer;
utils.pluginTarget.mixin(CanvasRenderer);

/**
 * Renders the object to this canvas view
 *
 * @param object {PIXI.DisplayObject} the object to be rendered
 */
CanvasRenderer.prototype.render = function (object)
{
    this.emit('prerender');

    var cacheParent = object.parent;

    this._lastObjectRendered = object;

    object.parent = this._tempDisplayObjectParent;

    // update the scene graph
    object.updateTransform();

    object.parent = cacheParent;

    this.context.setTransform(1, 0, 0, 1, 0, 0);

    this.context.globalAlpha = 1;

    this.context.globalCompositeOperation = this.blendModes[CONST.BLEND_MODES.NORMAL];

    if (navigator.isCocoonJS && this.view.screencanvas)
    {
        this.context.fillStyle = 'black';
        this.context.clear();
    }

    if (this.clearBeforeRender)
    {
        if (this.transparent)
        {
            this.context.clearRect(0, 0, this.width, this.height);
        }
        else
        {
            this.context.fillStyle = this._backgroundColorString;
            this.context.fillRect(0, 0, this.width , this.height);
        }
    }

    this.renderDisplayObject(object, this.context);

    this.emit('postrender');
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
CanvasRenderer.prototype.destroy = function (removeView)
{
    this.destroyPlugins();

    // call the base destroy
    SystemRenderer.prototype.destroy.call(this, removeView);

    this.context = null;

    this.refresh = true;

    this.maskManager.destroy();
    this.maskManager = null;

    this.smoothProperty = null;
};

/**
 * Renders a display object
 *
 * @param displayObject {PIXI.DisplayObject} The displayObject to render
 * @private
 */
CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context)
{
    var tempContext = this.context;

    this.context = context;
    displayObject.renderCanvas(this);
    this.context = tempContext;
};

/**
 * @extends PIXI.SystemRenderer#resize
 *
 * @param {number} w
 * @param {number} h
 */
CanvasRenderer.prototype.resize = function (w, h)
{
    SystemRenderer.prototype.resize.call(this, w, h);

    //reset the scale mode.. oddly this seems to be reset when the canvas is resized.
    //surely a browser bug?? Let pixi fix that for you..
    if(this.smoothProperty)
    {
        this.context[this.smoothProperty] = (CONST.SCALE_MODES.DEFAULT === CONST.SCALE_MODES.LINEAR);
    }

};

/**
 * Maps Pixi blend modes to canvas blend modes.
 *
 * @private
 */
CanvasRenderer.prototype._mapBlendModes = function ()
{
    if (!this.blendModes)
    {
        this.blendModes = {};

        if (utils.canUseNewCanvasBlendModes())
        {
            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'multiply';
            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'screen';
            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'overlay';
            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'darken';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'lighten';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'color-dodge';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'color-burn';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'hard-light';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'soft-light';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'difference';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'exclusion';
            this.blendModes[CONST.BLEND_MODES.HUE]           = 'hue';
            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'saturate';
            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'color';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'luminosity';
        }
        else
        {
            // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HUE]           = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'source-over';
        }
    }
};

},{"../../const":16,"../../math":26,"../../utils":70,"../SystemRenderer":36,"./utils/CanvasMaskManager":40}],38:[function(require,module,exports){
/**
 * Creates a Canvas element of the given size.
 *
 * @class
 * @memberof PIXI
 * @param width {number} the width for the newly created canvas
 * @param height {number} the height for the newly created canvas
 */
function CanvasBuffer(width, height)
{
    /**
     * The Canvas object that belongs to this CanvasBuffer.
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.canvas.getContext('2d');

    this.canvas.width = width;
    this.canvas.height = height;
}

CanvasBuffer.prototype.constructor = CanvasBuffer;
module.exports = CanvasBuffer;

Object.defineProperties(CanvasBuffer.prototype, {
    /**
     * The width of the canvas buffer in pixels.
     *
     * @member {number}
     * @memberof PIXI.CanvasBuffer#
     */
    width: {
        get: function ()
        {
            return this.canvas.width;
        },
        set: function (val)
        {
            this.canvas.width = val;
        }
    },
    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     * @memberof PIXI.CanvasBuffer#
     */
    height: {
        get: function ()
        {
            return this.canvas.height;
        },
        set: function (val)
        {
            this.canvas.height = val;
        }
    }
});

/**
 * Clears the canvas that was created by the CanvasBuffer class.
 *
 * @private
 */
CanvasBuffer.prototype.clear = function ()
{
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0,0, this.canvas.width, this.canvas.height);
};

/**
 * Resizes the canvas to the specified width and height.
 *
 * @param width {number} the new width of the canvas
 * @param height {number} the new height of the canvas
 */
CanvasBuffer.prototype.resize = function (width, height)
{
    this.canvas.width = width;
    this.canvas.height = height;
};

/**
 * Destroys this canvas.
 *
 */
CanvasBuffer.prototype.destroy = function ()
{
    this.context = null;
    this.canvas = null;
};

},{}],39:[function(require,module,exports){
var CONST = require('../../../const');

/**
 * A set of functions used by the canvas renderer to draw the primitive graphics data.
 * @static
 * @class
 * @memberof PIXI
 */
var CanvasGraphics = {};
module.exports = CanvasGraphics;

/*
 * Renders a Graphics object to a canvas.
 *
 * @param graphics {PIXI.Graphics} the actual graphics object to render
 * @param context {CanvasRenderingContext2D} the 2d drawing method of the canvas
 */
CanvasGraphics.renderGraphics = function (graphics, context)
{
    var worldAlpha = graphics.worldAlpha;

    if (graphics.dirty)
    {
        this.updateGraphicsTint(graphics);
        graphics.dirty = false;
    }

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];
        var shape = data.shape;

        var fillColor = data._fillTint;
        var lineColor = data._lineTint;

        context.lineWidth = data.lineWidth;

        if (data.type === CONST.SHAPES.POLY)
        {
            context.beginPath();

            var points = shape.points;

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            if (shape.closed)
            {
                context.lineTo(points[0], points[1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.RECT)
        {

            if (data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fillRect(shape.x, shape.y, shape.width, shape.height);

            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.strokeRect(shape.x, shape.y, shape.width, shape.height);
            }
        }
        else if (data.type === CONST.SHAPES.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);
            context.closePath();

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.ELIP)
        {
            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var w = shape.width * 2;
            var h = shape.height * 2;

            var x = shape.x - w/2;
            var y = shape.y - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

            context.closePath();

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.RREC)
        {
            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();

            if (data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();

            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
    }
};

/*
 * Renders a graphics mask
 *
 * @private
 * @param graphics {PIXI.Graphics} the graphics which will be used as a mask
 * @param context {CanvasRenderingContext2D} the context 2d method of the canvas
 */
CanvasGraphics.renderGraphicsMask = function (graphics, context)
{
    var len = graphics.graphicsData.length;

    if (len === 0)
    {
        return;
    }

    context.beginPath();

    for (var i = 0; i < len; i++)
    {
        var data = graphics.graphicsData[i];
        var shape = data.shape;

        if (data.type === CONST.SHAPES.POLY)
        {

            var points = shape.points;

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

        }
        else if (data.type === CONST.SHAPES.RECT)
        {
            context.rect(shape.x, shape.y, shape.width, shape.height);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.CIRC)
        {
            // TODO - need to be Undefined!
            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var w = shape.width * 2;
            var h = shape.height * 2;

            var x = shape.x - w/2;
            var y = shape.y - h/2;

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.RREC)
        {

            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
        }
    }
};

/*
 * Updates the tint of a graphics object
 *
 * @private
 * @param graphics {PIXI.Graphics} the graphics that will have its tint updated
 *
 */
CanvasGraphics.updateGraphicsTint = function (graphics)
{
    if (graphics.tint === 0xFFFFFF && graphics._prevTint === graphics.tint)
    {
        return;
    }
    graphics._prevTint = graphics.tint;

    var tintR = (graphics.tint >> 16 & 0xFF) / 255;
    var tintG = (graphics.tint >> 8 & 0xFF) / 255;
    var tintB = (graphics.tint & 0xFF)/ 255;

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        var fillColor = data.fillColor | 0;
        var lineColor = data.lineColor | 0;

        /*
        var colorR = (fillColor >> 16 & 0xFF) / 255;
        var colorG = (fillColor >> 8 & 0xFF) / 255;
        var colorB = (fillColor & 0xFF) / 255;

        colorR *= tintR;
        colorG *= tintG;
        colorB *= tintB;

        fillColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);

        colorR = (lineColor >> 16 & 0xFF) / 255;
        colorG = (lineColor >> 8 & 0xFF) / 255;
        colorB = (lineColor & 0xFF) / 255;

        colorR *= tintR;
        colorG *= tintG;
        colorB *= tintB;

        lineColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);
        */

        // super inline cos im an optimization NAZI :)
        data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (fillColor & 0xFF) / 255 * tintB*255);
        data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (lineColor & 0xFF) / 255 * tintB*255);

    }
};


},{"../../../const":16}],40:[function(require,module,exports){
var CanvasGraphics = require('./CanvasGraphics');

/**
 * A set of functions used to handle masking.
 *
 * @class
 * @memberof PIXI
 */
function CanvasMaskManager()
{}

CanvasMaskManager.prototype.constructor = CanvasMaskManager;
module.exports = CanvasMaskManager;

/**
 * This method adds it to the current stack of masks.
 *
 * @param maskData {object} the maskData that will be pushed
 * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.
 */
CanvasMaskManager.prototype.pushMask = function (maskData, renderer)
{

    renderer.context.save();

    var cacheAlpha = maskData.alpha;
    var transform = maskData.worldTransform;
    var resolution = renderer.resolution;

    renderer.context.setTransform(
        transform.a * resolution,
        transform.b * resolution,
        transform.c * resolution,
        transform.d * resolution,
        transform.tx * resolution,
        transform.ty * resolution
    );

    //TODO suport sprite alpha masks??
    //lots of effort required. If demand is great enough..
    if(!maskData.texture)
    {
        CanvasGraphics.renderGraphicsMask(maskData, renderer.context);
        renderer.context.clip();
    }

    maskData.worldAlpha = cacheAlpha;
};

/**
 * Restores the current drawing context to the state it was before the mask was applied.
 *
 * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.
 */
CanvasMaskManager.prototype.popMask = function (renderer)
{
    renderer.context.restore();
};

CanvasMaskManager.prototype.destroy = function () {};

},{"./CanvasGraphics":39}],41:[function(require,module,exports){
var utils = require('../../../utils');

/**
 * Utility methods for Sprite/Texture tinting.
 * @static
 * @class
 * @memberof PIXI
 */
var CanvasTinter = {};
module.exports = CanvasTinter;

/**
 * Basically this method just needs a sprite and a color and tints the sprite with the given color.
 *
 * @param sprite {PIXI.Sprite} the sprite to tint
 * @param color {number} the color to use to tint the sprite with
 * @return {HTMLCanvasElement} The tinted canvas
 */
CanvasTinter.getTintedTexture = function (sprite, color)
{
    var texture = sprite.texture;

    color = CanvasTinter.roundColor(color);

    var stringColor = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    texture.tintCache = texture.tintCache || {};

    if (texture.tintCache[stringColor])
    {
        return texture.tintCache[stringColor];
    }

     // clone texture..
    var canvas = CanvasTinter.canvas || document.createElement('canvas');

    //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
    CanvasTinter.tintMethod(texture, color, canvas);

    if (CanvasTinter.convertTintToImage)
    {
        // is this better?
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();

        texture.tintCache[stringColor] = tintImage;
    }
    else
    {
        texture.tintCache[stringColor] = canvas;
        // if we are not converting the texture to an image then we need to lose the reference to the canvas
        CanvasTinter.canvas = null;
    }

    return canvas;
};

/**
 * Tint a texture using the 'multiply' operation.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithMultiply = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'multiply';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    context.globalCompositeOperation = 'destination-atop';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );
};

/**
 * Tint a texture using the 'overlay' operation.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithOverlay = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'destination-atop';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    // context.globalCompositeOperation = 'copy';
};

/**
 * Tint a texture pixel per pixel.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithPerPixel = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    var rgbValues = utils.hex2rgb(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, crop.width, crop.height);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i+0] *= r;
        pixels[i+1] *= g;
        pixels[i+2] *= b;
    }

    context.putImageData(pixelData, 0, 0);
};

/**
 * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
 *
 * @param color {number} the color to round, should be a hex color
 */
CanvasTinter.roundColor = function (color)
{
    var step = CanvasTinter.cacheStepsPerColorChannel;

    var rgbValues = utils.hex2rgb(color);

    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

    return utils.rgb2hex(rgbValues);
};

/**
 * Number of steps which will be used as a cap when rounding colors.
 *
 * @member
 */
CanvasTinter.cacheStepsPerColorChannel = 8;

/**
 * Tint cache boolean flag.
 *
 * @member
 */
CanvasTinter.convertTintToImage = false;

/**
 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
 *
 * @member
 */
CanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();

/**
 * The tinting method that will be used.
 *
 */
CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply :  CanvasTinter.tintWithPerPixel;

},{"../../../utils":70}],42:[function(require,module,exports){
var SystemRenderer = require('../SystemRenderer'),
    ShaderManager = require('./managers/ShaderManager'),
    MaskManager = require('./managers/MaskManager'),
    StencilManager = require('./managers/StencilManager'),
    FilterManager = require('./managers/FilterManager'),
    BlendModeManager = require('./managers/BlendModeManager'),
    RenderTarget = require('./utils/RenderTarget'),
    ObjectRenderer = require('./utils/ObjectRenderer'),
    FXAAFilter = require('./filters/FXAAFilter'),
    utils = require('../../utils'),
    CONST = require('../../const');

/**
 * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
 * So no need for Sprite Batches or Sprite Clouds.
 * Don't forget to add the view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 * @param [width=0] {number} the width of the canvas view
 * @param [height=0] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used
 * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always look as great
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass. If you wish to set this to false, you *must* set preserveDrawingBuffer to `true`.
 * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if
 *      you need to call toDataUrl on the webgl context.
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function WebGLRenderer(width, height, options)
{
    options = options || {};

    SystemRenderer.call(this, 'WebGL', width, height, options);

    /**
     * The type of this renderer as a standardised const
     *
     * @member {number}
     *
     */
    this.type = CONST.RENDERER_TYPE.WEBGL;

    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);

    this.view.addEventListener('webglcontextlost', this.handleContextLost, false);
    this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);

    //TODO possibility to force FXAA as it may offer better performance?
    /**
     * Does it use FXAA ?
     *
     * @member {boolean}
     * @private
     */
    this._useFXAA = !!options.forceFXAA && options.antialias;

    /**
     * The fxaa filter
     *
     * @member {PIXI.FXAAFilter}
     * @private
     */
    this._FXAAFilter = null;

    /**
     * The options passed in to create a new webgl context.
     *
     * @member {object}
     * @private
     */
    this._contextOptions = {
        alpha: this.transparent,
        antialias: options.antialias,
        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer
    };

    /**
     * Counter for the number of draws made each frame
     *
     * @member {number}
     */
    this.drawCount = 0;

    /**
     * Deals with managing the shader programs and their attribs.
     *
     * @member {PIXI.ShaderManager}
     */
    this.shaderManager = new ShaderManager(this);

    /**
     * Manages the masks using the stencil buffer.
     *
     * @member {PIXI.MaskManager}
     */
    this.maskManager = new MaskManager(this);

    /**
     * Manages the stencil buffer.
     *
     * @member {PIXI.StencilManager}
     */
    this.stencilManager = new StencilManager(this);

    /**
     * Manages the filters.
     *
     * @member {PIXI.FilterManager}
     */
    this.filterManager = new FilterManager(this);


    /**
     * Manages the blendModes
     *
     * @member {PIXI.BlendModeManager}
     */
    this.blendModeManager = new BlendModeManager(this);

    /**
     * Holds the current render target
     *
     * @member {PIXI.RenderTarget}
     */
    this.currentRenderTarget = null;

    /**
     * The currently active ObjectRenderer.
     *
     * @member {PIXI.ObjectRenderer}
     */
    this.currentRenderer = new ObjectRenderer(this);

    this.initPlugins();

    // initialize the context so it is ready for the managers.
    this._createContext();
    this._initContext();

    // map some webGL blend modes..
    this._mapGlModes();

    // track textures in the renderer so we can no longer listen to them on destruction.
    this._managedTextures = [];

    /**
     * An array of render targets
     * @member {PIXI.RenderTarget[]}
     * @private
     */
    this._renderTargetStack = [];
}

// constructor
WebGLRenderer.prototype = Object.create(SystemRenderer.prototype);
WebGLRenderer.prototype.constructor = WebGLRenderer;
module.exports = WebGLRenderer;
utils.pluginTarget.mixin(WebGLRenderer);

WebGLRenderer.glContextId = 0;

/**
 * Creates the gl context.
 *
 * @private
 */
WebGLRenderer.prototype._createContext = function () {
    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);
    this.gl = gl;

    if (!gl)
    {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    this.glContextId = WebGLRenderer.glContextId++;
    gl.id = this.glContextId;
    gl.renderer = this;
};

/**
 * Creates the WebGL context
 *
 * @private
 */
WebGLRenderer.prototype._initContext = function ()
{
    var gl = this.gl;

    // set up the default pixi settings..
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.BLEND);

    this.renderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);

    this.setRenderTarget(this.renderTarget);

    this.emit('context', gl);

    // setup the width/height properties and gl viewport
    this.resize(this.width, this.height);

    if(!this._useFXAA)
    {
        this._useFXAA = (this._contextOptions.antialias && ! gl.getContextAttributes().antialias);
    }


    if(this._useFXAA)
    {
        window.console.warn('FXAA antialiasing being used instead of native antialiasing');
        this._FXAAFilter = [new FXAAFilter()];
    }
};

/**
 * Renders the object to its webGL view
 *
 * @param object {PIXI.DisplayObject} the object to be rendered
 */
WebGLRenderer.prototype.render = function (object)
{

    this.emit('prerender');

    // no point rendering if our context has been blown up!
    if (this.gl.isContextLost())
    {
        return;
    }

    this.drawCount = 0;

    this._lastObjectRendered = object;

    if(this._useFXAA)
    {
        this._FXAAFilter[0].uniforms.resolution.value.x = this.width;
        this._FXAAFilter[0].uniforms.resolution.value.y = this.height;
        object.filterArea = this.renderTarget.size;
        object.filters = this._FXAAFilter;
    }

    var cacheParent = object.parent;
    object.parent = this._tempDisplayObjectParent;

    // update the scene graph
    object.updateTransform();

    object.parent = cacheParent;

    var gl = this.gl;

    // make sure we are bound to the main frame buffer
    this.setRenderTarget(this.renderTarget);

    if (this.clearBeforeRender)
    {
        if (this.transparent)
        {
            gl.clearColor(0, 0, 0, 0);
        }
        else
        {
            gl.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1);
        }

        gl.clear(gl.COLOR_BUFFER_BIT);
    }

    this.renderDisplayObject(object, this.renderTarget);//this.projection);

    this.emit('postrender');
};

/**
 * Renders a Display Object.
 *
 * @param displayObject {PIXI.DisplayObject} The DisplayObject to render
 * @param renderTarget {PIXI.RenderTarget} The render target to use to render this display object
 *
 */
WebGLRenderer.prototype.renderDisplayObject = function (displayObject, renderTarget, clear)//projection, buffer)
{
    // TODO is this needed...
    //this.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);
    this.setRenderTarget(renderTarget);

    if(clear)
    {
        renderTarget.clear();
    }

    // start the filter manager
    this.filterManager.setFilterStack( renderTarget.filterStack );

    // render the scene!
    displayObject.renderWebGL(this);

    // finish the current renderer..
    this.currentRenderer.flush();
};

/**
 * Changes the current renderer to the one given in parameter
 *
 * @param objectRenderer {PIXI.ObjectRenderer} The object renderer to use.
 */
WebGLRenderer.prototype.setObjectRenderer = function (objectRenderer)
{
    if (this.currentRenderer === objectRenderer)
    {
        return;
    }

    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
};

/**
 * Changes the current render target to the one given in parameter
 *
 * @param renderTarget {PIXI.RenderTarget} the new render target
 */
WebGLRenderer.prototype.setRenderTarget = function (renderTarget)
{
    if( this.currentRenderTarget === renderTarget)
    {
        return;
    }
    // TODO - maybe down the line this should be a push pos thing? Leaving for now though.
    this.currentRenderTarget = renderTarget;
    this.currentRenderTarget.activate();
    this.stencilManager.setMaskStack( renderTarget.stencilMaskStack );
};


/**
 * Resizes the webGL view to the specified width and height.
 *
 * @param width {number} the new width of the webGL view
 * @param height {number} the new height of the webGL view
 */
WebGLRenderer.prototype.resize = function (width, height)
{
    SystemRenderer.prototype.resize.call(this, width, height);

    this.filterManager.resize(width, height);
    this.renderTarget.resize(width, height);

    if(this.currentRenderTarget === this.renderTarget)
    {
        this.renderTarget.activate();
        this.gl.viewport(0, 0, this.width, this.height);
    }
};

/**
 * Updates and/or Creates a WebGL texture for the renderer's context.
 *
 * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to update
 */
WebGLRenderer.prototype.updateTexture = function (texture)
{
    texture = texture.baseTexture || texture;

    if (!texture.hasLoaded)
    {
        return;
    }

    var gl = this.gl;

    if (!texture._glTextures[gl.id])
    {
        texture._glTextures[gl.id] = gl.createTexture();
        texture.on('update', this.updateTexture, this);
        texture.on('dispose', this.destroyTexture, this);
        this._managedTextures.push(texture);
    }


    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);


    if (texture.mipmap && texture.isPowerOfTwo)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }

    if (!texture.isPowerOfTwo)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    }

    return  texture._glTextures[gl.id];
};

/**
 * Deletes the texture from WebGL
 *
 * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to destroy
 */
WebGLRenderer.prototype.destroyTexture = function (texture, _skipRemove)
{
    texture = texture.baseTexture || texture;

    if (!texture.hasLoaded)
    {
        return;
    }

    if (texture._glTextures[this.gl.id])
    {
        this.gl.deleteTexture(texture._glTextures[this.gl.id]);
        delete texture._glTextures[this.gl.id];

        if (!_skipRemove)
        {
            var i = this._managedTextures.indexOf(texture);
            if (i !== -1) {
                utils.removeItems(this._managedTextures, i, 1);
            }
        }
    }
};

/**
 * Handles a lost webgl context
 *
 * @private
 */
WebGLRenderer.prototype.handleContextLost = function (event)
{
    event.preventDefault();
};

/**
 * Handles a restored webgl context
 *
 * @private
 */
WebGLRenderer.prototype.handleContextRestored = function ()
{
    this._initContext();

    // empty all the old gl textures as they are useless now
    for (var i = 0; i < this._managedTextures.length; ++i)
    {
        var texture = this._managedTextures[i];
        if (texture._glTextures[this.gl.id])
        {
            delete texture._glTextures[this.gl.id];
        }
    }
};

/**
 * Removes everything from the renderer (event listeners, spritebatch, etc...)
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
WebGLRenderer.prototype.destroy = function (removeView)
{
    this.destroyPlugins();

    // remove listeners
    this.view.removeEventListener('webglcontextlost', this.handleContextLost);
    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);

    // destroy managed textures
    for (var i = 0; i < this._managedTextures.length; ++i)
    {
        var texture = this._managedTextures[i];
        this.destroyTexture(texture, true);
        texture.off('update', this.updateTexture, this);
        texture.off('dispose', this.destroyTexture, this);
    }

    // call base destroy
    SystemRenderer.prototype.destroy.call(this, removeView);

    this.uid = 0;

    // destroy the managers
    this.shaderManager.destroy();
    this.maskManager.destroy();
    this.stencilManager.destroy();
    this.filterManager.destroy();
    this.blendModeManager.destroy();

    this.shaderManager = null;
    this.maskManager = null;
    this.filterManager = null;
    this.blendModeManager = null;
    this.currentRenderer = null;

    this.handleContextLost = null;
    this.handleContextRestored = null;

    this._contextOptions = null;

    this._managedTextures = null;

    this.drawCount = 0;

    this.gl.useProgram(null);

    this.gl = null;
};

/**
 * Maps Pixi blend modes to WebGL blend modes.
 *
 * @private
 */
WebGLRenderer.prototype._mapGlModes = function ()
{
    var gl = this.gl;

    if (!this.blendModes)
    {
        this.blendModes = {};

        this.blendModes[CONST.BLEND_MODES.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];
        this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];
        this.blendModes[CONST.BLEND_MODES.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
    }

    if (!this.drawModes)
    {
        this.drawModes = {};

        this.drawModes[CONST.DRAW_MODES.POINTS]         = gl.POINTS;
        this.drawModes[CONST.DRAW_MODES.LINES]          = gl.LINES;
        this.drawModes[CONST.DRAW_MODES.LINE_LOOP]      = gl.LINE_LOOP;
        this.drawModes[CONST.DRAW_MODES.LINE_STRIP]     = gl.LINE_STRIP;
        this.drawModes[CONST.DRAW_MODES.TRIANGLES]      = gl.TRIANGLES;
        this.drawModes[CONST.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
        this.drawModes[CONST.DRAW_MODES.TRIANGLE_FAN]   = gl.TRIANGLE_FAN;
    }
};

},{"../../const":16,"../../utils":70,"../SystemRenderer":36,"./filters/FXAAFilter":44,"./managers/BlendModeManager":46,"./managers/FilterManager":47,"./managers/MaskManager":48,"./managers/ShaderManager":49,"./managers/StencilManager":50,"./utils/ObjectRenderer":56,"./utils/RenderTarget":58}],43:[function(require,module,exports){
var DefaultShader = require('../shaders/TextureShader');

/**
 * This is the base class for creating a PIXI filter. Currently only WebGL supports filters.
 * If you want to make a custom filter this should be your base class.
 *
 * @class
 * @memberof PIXI
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param uniforms {object} An object containing the uniforms for this filter.
 */
function AbstractFilter(vertexSrc, fragmentSrc, uniforms)
{

    /**
     * An array of shaders
     * @member {PIXI.Shader[]}
     * @private
     */
    this.shaders = [];

    /**
     * The extra padding that the filter might need
     * @member {number}
     */
    this.padding = 0;

    /**
     * The uniforms as an object
     * @member {object}
     */
    this.uniforms = uniforms || {};


    /**
     * The code of the vertex shader
     * @member {string[]}
     * @private
     */
    this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;

    /**
     * The code of the frament shader
     * @member {string[]}
     * @private
     */
    this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc;

    //TODO a reminder - would be cool to have lower res filters as this would give better performance.

    //typeof fragmentSrc === 'string' ? fragmentSrc.split('') : (fragmentSrc || []);

}

AbstractFilter.prototype.constructor = AbstractFilter;
module.exports = AbstractFilter;

/**
 * Grabs a shader from the current renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the shader from
 */
AbstractFilter.prototype.getShader = function (renderer)
{
    var gl = renderer.gl;

    var shader = this.shaders[gl.id];

    if (!shader)
    {
        shader = new DefaultShader(renderer.shaderManager,
            this.vertexSrc,
            this.fragmentSrc,
            this.uniforms,
            this.attributes
        );

        this.shaders[gl.id] = shader;
    }

    return shader;
};

/**
 * Applies the filter
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
 * @param input {PIXI.RenderTarget}
 * @param output {PIXI.RenderTarget}
 * @param clear {boolean} Whether or not we want to clear the outputTarget
 */
AbstractFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    renderer.filterManager.applyFilter(shader, input, output, clear);
};

/**
 * Syncs a uniform between the class object and the shaders.
 *
 */
AbstractFilter.prototype.syncUniform = function (uniform)
{
    for (var i = 0, j = this.shaders.length; i < j; ++i)
    {
        this.shaders[i].syncUniform(uniform);
    }
};

},{"../shaders/TextureShader":55}],44:[function(require,module,exports){
var AbstractFilter = require('./AbstractFilter');
// @see https://github.com/substack/brfs/issues/25


/**
 *
 * Basic FXAA implementation based on the code on geeks3d.com with the
 * modification that the texture2DLod stuff was removed since it's
 * unsupported by WebGL.
 *
 * --
 * From:
 * https://github.com/mitsuhiko/webgl-meincraft
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI
 *
 */
function FXAAFilter()
{
    AbstractFilter.call(this,
        // vertex shader
        "\nprecision mediump float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform vec2 resolution;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\n            out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n   vResolution = resolution;\n\n   //compute the texture coords and send them to varyings\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",
        // fragment shader
        "precision lowp float;\n\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE,\n            vec2 v_rgbSW, vec2 v_rgbSE,\n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform sampler2D uSampler;\n\n\nvoid main(void){\n\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n}\n",
        // uniforms
        {
            resolution: { type: 'v2', value: { x: 1, y: 1 } }
        }
    );

}

FXAAFilter.prototype = Object.create(AbstractFilter.prototype);
FXAAFilter.prototype.constructor = FXAAFilter;
module.exports = FXAAFilter;

/**
 * Applies the filter
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
 * @param input {PIXI.RenderTarget}
 * @param output {PIXI.RenderTarget}
 */
FXAAFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    var shader = this.getShader( renderer );
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};

},{"./AbstractFilter":43}],45:[function(require,module,exports){
var AbstractFilter = require('./AbstractFilter'),
    math =  require('../../../math');

// @see https://github.com/substack/brfs/issues/25


/**
 * The SpriteMaskFilter class
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI
 * @param sprite {PIXI.Sprite} the target sprite
 */
function SpriteMaskFilter(sprite)
{
    var maskMatrix = new math.Matrix();

    AbstractFilter.call(this,
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        "precision lowp float;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    original *= (masky.r * masky.a * alpha * clip);\n    gl_FragColor = original;\n}\n",
        {
            mask:           { type: 'sampler2D', value: sprite._texture },
            alpha:          { type: 'f', value: 1},
            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) }
        }
    );

    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
}

SpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);
SpriteMaskFilter.prototype.constructor = SpriteMaskFilter;
module.exports = SpriteMaskFilter;

/**
 * Applies the filter
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
 * @param input {PIXI.RenderTarget}
 * @param output {PIXI.RenderTarget}
 */
SpriteMaskFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    this.uniforms.mask.value = this.maskSprite._texture;

    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);

    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
    this.uniforms.alpha.value = this.maskSprite.worldAlpha;

    var shader = this.getShader(renderer);
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};


Object.defineProperties(SpriteMaskFilter.prototype, {
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.SpriteMaskFilter#
     */
    map: {
        get: function ()
        {
            return this.uniforms.mask.value;
        },
        set: function (value)
        {
            this.uniforms.mask.value = value;
        }
    },

    /**
     * The offset used to move the displacement map.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.SpriteMaskFilter#
     */
    offset: {
        get: function()
        {
            return this.uniforms.offset.value;
        },
        set: function(value)
        {
            this.uniforms.offset.value = value;
        }
    }
});

},{"../../../math":26,"./AbstractFilter":43}],46:[function(require,module,exports){
var WebGLManager = require('./WebGLManager');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGlManager
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function BlendModeManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {number}
     */
    this.currentBlendMode = 99999;
}

BlendModeManager.prototype = Object.create(WebGLManager.prototype);
BlendModeManager.prototype.constructor = BlendModeManager;
module.exports = BlendModeManager;

/**
 * Sets-up the given blendMode from WebGL's point of view.
 *
 * @param blendMode {number} the blendMode, should be a Pixi const, such as `PIXI.BLEND_MODES.ADD`. See
 *  {@link PIXI.BLEND_MODES} for possible values.
 */
BlendModeManager.prototype.setBlendMode = function (blendMode)
{
    if (this.currentBlendMode === blendMode)
    {
        return false;
    }

    this.currentBlendMode = blendMode;

    var mode = this.renderer.blendModes[this.currentBlendMode];
    this.renderer.gl.blendFunc(mode[0], mode[1]);

    return true;
};

},{"./WebGLManager":51}],47:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    RenderTarget = require('../utils/RenderTarget'),
    CONST = require('../../../const'),
    Quad = require('../utils/Quad'),
    math =  require('../../../math');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGLManager
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function FilterManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {object[]}
     */
    this.filterStack = [];

    this.filterStack.push({
        renderTarget:renderer.currentRenderTarget,
        filter:[],
        bounds:null
    });

    /**
     * @member {PIXI.RenderTarget[]}
     */
    this.texturePool = [];

    /**
     * The size of the texture
     *
     * @member {PIXI.Rectangle}
     */
    // listen for context and update necessary buffers
    //TODO make this dynamic!
    //TODO test this out by forces power of two?
    this.textureSize = new math.Rectangle(0, 0, renderer.width, renderer.height);

    /**
     * The current frame
     *
     * @member {PIXI.Rectangle}
     */
    this.currentFrame = null;
}

FilterManager.prototype = Object.create(WebGLManager.prototype);
FilterManager.prototype.constructor = FilterManager;
module.exports = FilterManager;


/**
 * Called when there is a WebGL context change.
 *
 */
FilterManager.prototype.onContextChange = function ()
{
    this.texturePool.length = 0;

    var gl = this.renderer.gl;
    this.quad = new Quad(gl);
};

/**
 * @param renderer {PIXI.WebGLRenderer}
 * @param buffer {ArrayBuffer}
 */
FilterManager.prototype.setFilterStack = function ( filterStack )
{
    this.filterStack = filterStack;
};

/**
 * Applies the filter and adds it to the current filter stack.
 *
 * @param target {PIXI.DisplayObject}
 * @param filters {PIXI.AbstractFiler[]} the filters that will be pushed to the current filter stack
 */
FilterManager.prototype.pushFilter = function (target, filters)
{
    // get the bounds of the object..
    // TODO replace clone with a copy to save object creation
    var bounds = target.filterArea ? target.filterArea.clone() : target.getBounds();

    //bounds = bounds.clone();

    // round off the rectangle to get a nice smoooooooth filter :)
    bounds.x = bounds.x | 0;
    bounds.y = bounds.y | 0;
    bounds.width = bounds.width | 0;
    bounds.height = bounds.height | 0;


    // padding!
    var padding = filters[0].padding | 0;
    bounds.x -= padding;
    bounds.y -= padding;
    bounds.width += padding * 2;
    bounds.height += padding * 2;


    if(this.renderer.currentRenderTarget.transform)
    {
        //TODO this will break if the renderTexture transform is anything other than a translation.
        //Will need to take the full matrix transform into acount..
        var transform = this.renderer.currentRenderTarget.transform;

        bounds.x += transform.tx;
        bounds.y += transform.ty;

        this.capFilterArea( bounds );

        bounds.x -= transform.tx;
        bounds.y -= transform.ty;
    }
    else
    {
         this.capFilterArea( bounds );
    }

    if(bounds.width > 0 && bounds.height > 0)
    {
        this.currentFrame = bounds;

        var texture = this.getRenderTarget();

        this.renderer.setRenderTarget(texture);

        // clear the texture..
        texture.clear();

        // TODO get rid of object creation!
        this.filterStack.push({
            renderTarget: texture,
            filter: filters
        });

    }
    else
    {
        // push somthing on to the stack that is empty
        this.filterStack.push({
            renderTarget: null,
            filter: filters
        });
    }
};


/**
 * Removes the last filter from the filter stack and returns it.
 *
 */
FilterManager.prototype.popFilter = function ()
{
    var filterData = this.filterStack.pop();
    var previousFilterData = this.filterStack[this.filterStack.length-1];

    var input = filterData.renderTarget;

    // if the renderTarget is null then we don't apply the filter as its offscreen
    if(!filterData.renderTarget)
    {
        return;
    }

    var output = previousFilterData.renderTarget;

    // use program
    var gl = this.renderer.gl;


    this.currentFrame = input.frame;

    this.quad.map(this.textureSize, input.frame);


    // TODO.. this probably only needs to be done once!
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);

    var filters = filterData.filter;

    // assuming all filters follow the correct format??
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);

    // restore the normal blendmode!
    this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);

    if (filters.length === 1)
    {
        // TODO (cengler) - There has to be a better way then setting this each time?
        if (filters[0].uniforms.dimensions)
        {
            filters[0].uniforms.dimensions.value[0] = this.renderer.width;
            filters[0].uniforms.dimensions.value[1] = this.renderer.height;
            filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];
            filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];
        }

        filters[0].applyFilter( this.renderer, input, output );
        this.returnRenderTarget( input );

    }
    else
    {
        var flipTexture = input;
        var flopTexture = this.getRenderTarget(true);

        for (var i = 0; i < filters.length-1; i++)
        {
            var filter = filters[i];

            // TODO (cengler) - There has to be a better way then setting this each time?
            if (filter.uniforms.dimensions)
            {
                filter.uniforms.dimensions.value[0] = this.renderer.width;
                filter.uniforms.dimensions.value[1] = this.renderer.height;
                filter.uniforms.dimensions.value[2] = this.quad.vertices[0];
                filter.uniforms.dimensions.value[3] = this.quad.vertices[5];
            }

            filter.applyFilter( this.renderer, flipTexture, flopTexture );

            var temp = flipTexture;
            flipTexture = flopTexture;
            flopTexture = temp;
        }

        filters[filters.length-1].applyFilter( this.renderer, flipTexture, output );

        this.returnRenderTarget( flipTexture );
        this.returnRenderTarget( flopTexture );
    }

    return filterData.filter;
};

/**
 * Grabs an render target from the internal pool
 *
 * @param clear {boolean} Whether or not we need to clear the RenderTarget
 * @return {RenderTarget}
 */
FilterManager.prototype.getRenderTarget = function ( clear )
{
    var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);
    renderTarget.frame = this.currentFrame;

    if (clear)
    {
        renderTarget.clear(true);
    }

    return renderTarget;
};

/*
 * Returns a RenderTarget to the internal pool
 * @param renderTarget {RenderTarget} The RenderTarget we want to return to the pool
 */
FilterManager.prototype.returnRenderTarget = function (renderTarget)
{
    this.texturePool.push( renderTarget );
};

/*
 * Applies the filter
 * @param shader {Shader} The shader to upload
 * @param inputTarget {RenderTarget}
 * @param outputTarget {RenderTarget}
 * @param clear {boolean} Whether or not we want to clear the outputTarget
 */
FilterManager.prototype.applyFilter = function (shader, inputTarget, outputTarget, clear)
{
    var gl = this.renderer.gl;

    this.renderer.setRenderTarget(outputTarget);

    if (clear)
    {
        outputTarget.clear();
    }

    // set the shader
    this.renderer.shaderManager.setShader(shader);

    // TODO (cengler) - Can this be cached and not `toArray`ed each frame?
    shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);

    //TODO can this be optimised?
    shader.syncUniforms();
/*
    gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
*/

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);

    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
    this.renderer.drawCount++;
};

/*
 * Calculates the mapped matrix
 * @param filterArea {Rectangle} The filter area
 * @param sprite {Sprite} the target sprite
 * @param outputMatrix {Matrix} @alvin
 */
// TODO playing around here.. this is temporary - (will end up in the shader)
FilterManager.prototype.calculateMappedMatrix = function (filterArea, sprite, outputMatrix)
{
    var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),
    texture = sprite._texture.baseTexture;

    var mappedMatrix = outputMatrix.identity();

    // scale..
    var ratio = this.textureSize.height / this.textureSize.width;

    mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height );

    mappedMatrix.scale(1 , ratio);

    var translateScaleX = (this.textureSize.width / texture.width);
    var translateScaleY = (this.textureSize.height / texture.height);

    worldTransform.tx /= texture.width * translateScaleX;
    worldTransform.ty /= texture.width * translateScaleX;

    worldTransform.invert();

    mappedMatrix.prepend(worldTransform);

    // apply inverse scale..
    mappedMatrix.scale(1 , 1/ratio);

    mappedMatrix.scale( translateScaleX , translateScaleY );

    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

    //zhangyun 2016.3.9 translate the mask according to frame
	var currFrame = sprite._texture.frame;
	mappedMatrix.translate(currFrame.x/texture.width, currFrame.y/texture.height);
	return mappedMatrix;

    // Keeping the orginal as a reminder to me on how this works!
    //
    // var m = new math.Matrix();

    // // scale..
    // var ratio = this.textureSize.height / this.textureSize.width;

    // m.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);


    // m.scale(1 , ratio);


    // var transform = wt.clone();

    // var translateScaleX = (this.textureSize.width / 620);
    // var translateScaleY = (this.textureSize.height / 380);

    // transform.tx /= 620 * translateScaleX;
    // transform.ty /= 620 * translateScaleX;

    // transform.invert();

    // transform.append(m);

    // // apply inverse scale..
    // transform.scale(1 , 1/ratio);

    // transform.scale( translateScaleX , translateScaleY );

    // return transform;
};

/*
 * Constrains the filter area to the texture size
 * @param filterArea {Rectangle} The filter area we want to cap
 */
FilterManager.prototype.capFilterArea = function (filterArea)
{
    if (filterArea.x < 0)
    {
        filterArea.width += filterArea.x;
        filterArea.x = 0;
    }

    if (filterArea.y < 0)
    {
        filterArea.height += filterArea.y;
        filterArea.y = 0;
    }

    if ( filterArea.x + filterArea.width > this.textureSize.width )
    {
        filterArea.width = this.textureSize.width - filterArea.x;
    }

    if ( filterArea.y + filterArea.height > this.textureSize.height )
    {
        filterArea.height = this.textureSize.height - filterArea.y;
    }
};

/*
 * Resizes all the render targets in the pool
 * @param width {number} the new width
 * @param height {number} the new height
 */
FilterManager.prototype.resize = function ( width, height )
{
    this.textureSize.width = width;
    this.textureSize.height = height;

    for (var i = 0; i < this.texturePool.length; i++)
    {
        this.texturePool[i].resize( width, height );
    }
};

/**
 * Destroys the filter and removes it from the filter stack.
 *
 */
FilterManager.prototype.destroy = function ()
{
    this.quad.destroy();
    
    WebGLManager.prototype.destroy.call(this);
    
    this.filterStack = null;
    this.offsetY = 0;

    // destroy textures
    for (var i = 0; i < this.texturePool.length; i++)
    {
        this.texturePool[i].destroy();
    }

    this.texturePool = null;
};

},{"../../../const":16,"../../../math":26,"../utils/Quad":57,"../utils/RenderTarget":58,"./WebGLManager":51}],48:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    AlphaMaskFilter = require('../filters/SpriteMaskFilter');

/**
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function MaskManager(renderer)
{
    WebGLManager.call(this, renderer);

    this.stencilStack = [];
    this.reverse = true;
    this.count = 0;

    this.alphaMaskPool = [];
}

MaskManager.prototype = Object.create(WebGLManager.prototype);
MaskManager.prototype.constructor = MaskManager;
module.exports = MaskManager;

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
MaskManager.prototype.pushMask = function (target, maskData)
{
    if (maskData.texture)
    {
        this.pushSpriteMask(target, maskData);
    }
    else
    {
        this.pushStencilMask(target, maskData);
    }

};

/**
 * Removes the last mask from the mask stack and doesn't return it.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.popMask = function (target, maskData)
{
    if (maskData.texture)
    {
        this.popSpriteMask(target, maskData);
    }
    else
    {
        this.popStencilMask(target, maskData);
    }
};

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.pushSpriteMask = function (target, maskData)
{
    var alphaMaskFilter = this.alphaMaskPool.pop();

    if (!alphaMaskFilter)
    {
        alphaMaskFilter = [new AlphaMaskFilter(maskData)];
    }

    alphaMaskFilter[0].maskSprite = maskData;
    this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 */
MaskManager.prototype.popSpriteMask = function ()
{
    var filters = this.renderer.filterManager.popFilter();

    this.alphaMaskPool.push(filters);
};


/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.pushStencilMask = function (target, maskData)
{
    this.renderer.stencilManager.pushMask(maskData);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 * @param target {PIXI.RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.popStencilMask = function (target, maskData)
{
    this.renderer.stencilManager.popMask(maskData);
};


},{"../filters/SpriteMaskFilter":45,"./WebGLManager":51}],49:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    TextureShader = require('../shaders/TextureShader'),
    ComplexPrimitiveShader = require('../shaders/ComplexPrimitiveShader'),
    PrimitiveShader = require('../shaders/PrimitiveShader'),
    utils = require('../../../utils');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.WebGLManager
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function ShaderManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {number}
     */
    this.maxAttibs = 10;

    /**
     * @member {any[]}
     */
    this.attribState = [];

    /**
     * @member {any[]}
     */
    this.tempAttribState = [];

    for (var i = 0; i < this.maxAttibs; i++)
    {
        this.attribState[i] = false;
    }

    /**
     * @member {any[]}
     */
    this.stack = [];

    /**
     * @member {number}
     * @private
     */
    this._currentId = -1;

    /**
     * @member {PIXI.Shader}
     * @private
     */
    this.currentShader = null;

//    this.initPlugins();
}

ShaderManager.prototype = Object.create(WebGLManager.prototype);
ShaderManager.prototype.constructor = ShaderManager;
utils.pluginTarget.mixin(ShaderManager);

module.exports = ShaderManager;

/**
 * Called when there is a WebGL context change.
 *
 */
ShaderManager.prototype.onContextChange = function ()
{
    this.initPlugins();

    var gl = this.renderer.gl;

    // get the maximum number of attribute correctly as this tends to vary
    this.maxAttibs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

    this.attribState = [];

    for (var i = 0; i < this.maxAttibs; i++)
    {
        this.attribState[i] = false;
    }

    // TODO - Why are these not plugins? We can't decouple primitives unless they are....
    this.defaultShader = new TextureShader(this);
    this.primitiveShader = new PrimitiveShader(this);
    this.complexPrimitiveShader = new ComplexPrimitiveShader(this);
};

/**
 * Takes the attributes given in parameters and uploads them.
 *
 * @param attribs {any[]} attribs
 */
ShaderManager.prototype.setAttribs = function (attribs)
{
    // reset temp state
    var i;

    for (i = 0; i < this.tempAttribState.length; i++)
    {
        this.tempAttribState[i] = false;
    }

    // set the new attribs
    for (var a in attribs)
    {
        this.tempAttribState[attribs[a]] = true;
    }

    var gl = this.renderer.gl;

    for (i = 0; i < this.attribState.length; i++)
    {
        if (this.attribState[i] !== this.tempAttribState[i])
        {
            this.attribState[i] = this.tempAttribState[i];

            if (this.attribState[i])
            {
                gl.enableVertexAttribArray(i);
            }
            else
            {
                gl.disableVertexAttribArray(i);
            }
        }
    }
};

/**
 * Sets the current shader.
 *
 * @param shader {PIXI.Shader} the shader to upload
 */
ShaderManager.prototype.setShader = function (shader)
{
    if (this._currentId === shader.uid)
    {
        return false;
    }

    this._currentId = shader.uid;

    this.currentShader = shader;

    this.renderer.gl.useProgram(shader.program);
    this.setAttribs(shader.attributes);

    return true;
};

/**
 * Destroys this object.
 *
 */
ShaderManager.prototype.destroy = function ()
{
    this.primitiveShader.destroy();
    this.complexPrimitiveShader.destroy();
    WebGLManager.prototype.destroy.call(this);

    this.destroyPlugins();

    this.attribState = null;

    this.tempAttribState = null;
};

},{"../../../utils":70,"../shaders/ComplexPrimitiveShader":52,"../shaders/PrimitiveShader":53,"../shaders/TextureShader":55,"./WebGLManager":51}],50:[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    utils = require('../../../utils');

/**
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function WebGLMaskManager(renderer)
{
    WebGLManager.call(this, renderer);
    this.stencilMaskStack = null;
}

WebGLMaskManager.prototype = Object.create(WebGLManager.prototype);
WebGLMaskManager.prototype.constructor = WebGLMaskManager;
module.exports = WebGLMaskManager;

/**
 * Changes the mask stack that is used by this manager.
 *
 * @param stencilMaskStack {PIXI.StencilMaskStack} The mask stack
 */
WebGLMaskManager.prototype.setMaskStack = function ( stencilMaskStack )
{
    this.stencilMaskStack = stencilMaskStack;

    var gl = this.renderer.gl;

    if (stencilMaskStack.stencilStack.length === 0)
    {
        gl.disable(gl.STENCIL_TEST);
    }
    else
    {
        gl.enable(gl.STENCIL_TEST);
    }
};

/**
 * Applies the Mask and adds it to the current filter stack. @alvin
 *
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
WebGLMaskManager.prototype.pushStencil = function (graphics, webGLData)
{
    this.renderer.currentRenderTarget.attachStencilBuffer();

    var gl = this.renderer.gl,
        sms = this.stencilMaskStack;

    this.bindGraphics(graphics, webGLData);

    if (sms.stencilStack.length === 0)
    {
        gl.enable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        sms.reverse = true;
        sms.count = 0;
    }

    sms.stencilStack.push(webGLData);

    var level = sms.count;

    gl.colorMask(false, false, false, false);

    gl.stencilFunc(gl.ALWAYS,0,0xFF);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

    // draw the triangle strip!

    if (webGLData.mode === 1)
    {
        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );

        if (sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        // draw a quad to increment..
        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

        if (sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }

        sms.reverse = !sms.reverse;
    }
    else
    {
        if (!sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

        if (!sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }
    }

    gl.colorMask(true, true, true, true);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);

    sms.count++;
};

/**
 * TODO this does not belong here!
 *
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
WebGLMaskManager.prototype.bindGraphics = function (graphics, webGLData)
{
    //if (this._currentGraphics === graphics)return;
    var gl = this.renderer.gl;

     // bind the graphics object..
    var shader;// = this.renderer.shaderManager.plugins.primitiveShader;

    if (webGLData.mode === 1)
    {
        shader = this.renderer.shaderManager.complexPrimitiveShader;

        this.renderer.shaderManager.setShader(shader);

        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));

        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

        gl.uniform3fv(shader.uniforms.color._location, webGLData.color);

        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);


        // now do the rest..
        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
    else
    {
        //this.renderer.shaderManager.activatePrimitiveShader();
        shader = this.renderer.shaderManager.primitiveShader;

        this.renderer.shaderManager.setShader(shader);

        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));

        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);

        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
};

/**
 * TODO @alvin
 * @param graphics {PIXI.Graphics}
 * @param webGLData {any[]}
 */
WebGLMaskManager.prototype.popStencil = function (graphics, webGLData)
{
    var gl = this.renderer.gl,
        sms = this.stencilMaskStack;

    sms.stencilStack.pop();

    sms.count--;

    if (sms.stencilStack.length === 0)
    {
        // the stack is empty!
        gl.disable(gl.STENCIL_TEST);

    }
    else
    {

        var level = sms.count;

        this.bindGraphics(graphics, webGLData);

        gl.colorMask(false, false, false, false);

        if (webGLData.mode === 1)
        {
            sms.reverse = !sms.reverse;

            if (sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            // draw a quad to increment..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

            gl.stencilFunc(gl.ALWAYS,0,0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

            // draw the triangle strip!
            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );

            this.renderer.drawCount += 2;

            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }

        }
        else
        {
          //  console.log("<<>>")
            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

            this.renderer.drawCount++;

            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }
        }

        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);


    }
};

/**
 * Destroys the mask stack.
 *
 */
WebGLMaskManager.prototype.destroy = function ()
{
    WebGLManager.prototype.destroy.call(this);

    this.stencilMaskStack.stencilStack = null;
};

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param maskData {any[]} The mask data structure to use
 */
WebGLMaskManager.prototype.pushMask = function (maskData)
{


    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

    if (maskData.dirty)
    {
        this.renderer.plugins.graphics.updateGraphics(maskData, this.renderer.gl);
    }

    if (!maskData._webGL[this.renderer.gl.id].data.length)
    {
        return;
    }

    this.pushStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 * @param maskData {any[]}
 */
WebGLMaskManager.prototype.popMask = function (maskData)
{
    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

    this.popStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);
};


},{"../../../utils":70,"./WebGLManager":51}],51:[function(require,module,exports){
/**
 * @class
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
 */
function WebGLManager(renderer)
{
    /**
     * The renderer this manager works for.
     *
     * @member {PIXI.WebGLRenderer}
     */
    this.renderer = renderer;

    this.renderer.on('context', this.onContextChange, this);
}

WebGLManager.prototype.constructor = WebGLManager;
module.exports = WebGLManager;

/**
 * Generic method called when there is a WebGL context change.
 *
 */
WebGLManager.prototype.onContextChange = function ()
{
	// do some codes init!
};

/**
 * Generic destroy methods to be overridden by the subclass
 *
 */
WebGLManager.prototype.destroy = function ()
{
    this.renderer.off('context', this.onContextChange, this);

    this.renderer = null;
};

},{}],52:[function(require,module,exports){
var Shader = require('./Shader');

/**
 * This shader is used to draw complex primitive shapes for {@link PIXI.Graphics}.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
 */
function ComplexPrimitiveShader(shaderManager)
{
    Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'uniform vec3 tint;',
            'uniform float alpha;',
            'uniform vec3 color;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vColor = vec4(color * alpha * tint, alpha);',//" * vec4(tint * alpha, alpha);',
            '}'
        ].join('\n'),
        // fragment shader
        [
            'precision mediump float;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_FragColor = vColor;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            tint:   { type: '3f', value: [0, 0, 0] },
            alpha:  { type: '1f', value: 0 },
            color:  { type: '3f', value: [0,0,0] },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // attributes
        {
            aVertexPosition:0
        }
    );
}

ComplexPrimitiveShader.prototype = Object.create(Shader.prototype);
ComplexPrimitiveShader.prototype.constructor = ComplexPrimitiveShader;
module.exports = ComplexPrimitiveShader;

},{"./Shader":54}],53:[function(require,module,exports){
var Shader = require('./Shader');

/**
 * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 */
function PrimitiveShader(shaderManager)
{
    Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',
            'attribute vec4 aColor;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'uniform float alpha;',
            'uniform float flipY;',
            'uniform vec3 tint;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vColor = aColor * vec4(tint * alpha, alpha);',
            '}'
        ].join('\n'),
        // fragment shader
        [
            'precision mediump float;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_FragColor = vColor;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            tint:   { type: '3f', value: [0, 0, 0] },
            alpha:  { type: '1f', value: 0 },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // custom attributes
        {
            aVertexPosition:0,
            aColor:0
        }
    );
}

PrimitiveShader.prototype = Object.create(Shader.prototype);
PrimitiveShader.prototype.constructor = PrimitiveShader;
module.exports = PrimitiveShader;

},{"./Shader":54}],54:[function(require,module,exports){
/*global console */
var utils = require('../../../utils');

/**
 * Base shader class for PIXI managed shaders.
 *
 * @class
 * @memberof PIXI
 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
 * @param [vertexSrc] {string} The source of the vertex shader.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 * @param [uniforms] {object} Uniforms for this shader.
 * @param [attributes] {object} Attributes for this shader.
 */
function Shader(shaderManager, vertexSrc, fragmentSrc, uniforms, attributes)
{
    if (!vertexSrc || !fragmentSrc)
    {
         throw new Error('Pixi.js Error. Shader requires vertexSrc and fragmentSrc');
    }

    /**
     * A unique id
     * @member {number}
     * @readonly
     */
    this.uid = utils.uid();

    /**
     * The current WebGL drawing context
     * @member {WebGLRenderingContext}
     * @readonly
     */
    this.gl = shaderManager.renderer.gl;

    //TODO maybe we should pass renderer rather than shader manger?? food for thought..
    this.shaderManager = shaderManager;

    /**
     * The WebGL program.
     *
     * @member {WebGLProgram}
     * @readonly
     */
    this.program = null;

    /**
     * The uniforms as an object
     * @member {object}
     * @private
     */
    this.uniforms = uniforms || {};

    /**
     * The attributes as an object
     * @member {object}
     * @private
     */
    this.attributes = attributes || {};

    /**
     * Internal texture counter
     * @member {number}
     * @private
     */
    this.textureCount = 1;

    /**
     * The vertex shader as an array of strings
     *
     * @member {string}
     */
    this.vertexSrc = vertexSrc;

    /**
     * The fragment shader as an array of strings
     *
     * @member {string}
     */
    this.fragmentSrc = fragmentSrc;

    this.init();
}

Shader.prototype.constructor = Shader;
module.exports = Shader;

/**
 * Creates the shader and uses it
 *
 */
Shader.prototype.init = function ()
{
    this.compile();

    this.gl.useProgram(this.program);

    this.cacheUniformLocations(Object.keys(this.uniforms));
    this.cacheAttributeLocations(Object.keys(this.attributes));
};

/**
 * Caches the locations of the uniform for reuse.
 *
 * @param keys {string} the uniforms to cache
 */
Shader.prototype.cacheUniformLocations = function (keys)
{
    for (var i = 0; i < keys.length; ++i)
    {
        this.uniforms[keys[i]]._location = this.gl.getUniformLocation(this.program, keys[i]);
    }
};

/**
 * Caches the locations of the attribute for reuse.
 *
 * @param keys {string} the attributes to cache
 */
Shader.prototype.cacheAttributeLocations = function (keys)
{
    for (var i = 0; i < keys.length; ++i)
    {
        this.attributes[keys[i]] = this.gl.getAttribLocation(this.program, keys[i]);
    }

    // TODO: Check if this is needed anymore...

    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    // if (this.attributes.aColor === -1){
    //     this.attributes.aColor = 2;
    // }

    // End worst hack eva //
};

/**
 * Attaches the shaders and creates the program.
 *
 * @return {WebGLProgram}
 */
Shader.prototype.compile = function ()
{
    var gl = this.gl;

    var glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexSrc);
    var glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);
    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return (this.program = program);
};

/*
Shader.prototype.buildSync = function ()
{
   // var str = ""

   // str =  "Shader.prototype.syncUniforms = function()";
   // str += "{\n";

    for (var key in this.uniforms)
    {
        var uniform = this.uniforms[key];

        Object.defineProperty(this, key, {

            get: function ()
            {
                return uniform.value
            },
            set: function (value)
            {
                this.setUniform(uniform, value);
            }
        });

        console.log( makePropSetter( key, " bloop", uniform.type )  )
  //      Object.def
        //    location = uniform._location,
          //  value = uniform.value,
            //i, il;

    //    str += "gl.uniform1i(this.uniforms."+ key +"._location, this.uniforms." + key + ".value );\n"

    }

}*/

/**
* Adds a new uniform
*
* @param uniform {object} the new uniform to attach
*/
Shader.prototype.syncUniform = function (uniform)
{
    var location = uniform._location,
        value = uniform.value,
        gl = this.gl,
        i, il;

    switch (uniform.type)
    {
        case 'b':
        case 'bool':
        case 'boolean':
            gl.uniform1i(location, value ? 1 : 0);
            break;

        // single int value
        case 'i':
        case '1i':
            gl.uniform1i(location, value);
            break;

        // single float value
        case 'f':
        case '1f':
            gl.uniform1f(location, value);
            break;

        // Float32Array(2) or JS Arrray
        case '2f':
            gl.uniform2f(location, value[0], value[1]);
            break;

        // Float32Array(3) or JS Arrray
        case '3f':
            gl.uniform3f(location, value[0], value[1], value[2]);
            break;

        // Float32Array(4) or JS Arrray
        case '4f':
            gl.uniform4f(location, value[0], value[1], value[2], value[3]);
            break;

        // a 2D Point object
        case 'v2':
            gl.uniform2f(location, value.x, value.y);
            break;

        // a 3D Point object
        case 'v3':
            gl.uniform3f(location, value.x, value.y, value.z);
            break;

        // a 4D Point object
        case 'v4':
            gl.uniform4f(location, value.x, value.y, value.z, value.w);
            break;

        // Int32Array or JS Array
        case '1iv':
            gl.uniform1iv(location, value);
            break;

        // Int32Array or JS Array
        case '2iv':
            gl.uniform2iv(location, value);
            break;

        // Int32Array or JS Array
        case '3iv':
            gl.uniform3iv(location, value);
            break;

        // Int32Array or JS Array
        case '4iv':
            gl.uniform4iv(location, value);
            break;

        // Float32Array or JS Array
        case '1fv':
            gl.uniform1fv(location, value);
            break;

        // Float32Array or JS Array
        case '2fv':
            gl.uniform2fv(location, value);
            break;

        // Float32Array or JS Array
        case '3fv':
            gl.uniform3fv(location, value);
            break;

        // Float32Array or JS Array
        case '4fv':
            gl.uniform4fv(location, value);
            break;

        // Float32Array or JS Array
        case 'm2':
        case 'mat2':
        case 'Matrix2fv':
            gl.uniformMatrix2fv(location, uniform.transpose, value);
            break;

        // Float32Array or JS Array
        case 'm3':
        case 'mat3':
        case 'Matrix3fv':

            gl.uniformMatrix3fv(location, uniform.transpose, value);
            break;

        // Float32Array or JS Array
        case 'm4':
        case 'mat4':
        case 'Matrix4fv':
            gl.uniformMatrix4fv(location, uniform.transpose, value);
            break;

        // a Color Value
        case 'c':
            if (typeof value === 'number')
            {
                value = utils.hex2rgb(value);
            }

            gl.uniform3f(location, value[0], value[1], value[2]);
            break;

        // flat array of integers (JS or typed array)
        case 'iv1':
            gl.uniform1iv(location, value);
            break;

        // flat array of integers with 3 x N size (JS or typed array)
        case 'iv':
            gl.uniform3iv(location, value);
            break;

        // flat array of floats (JS or typed array)
        case 'fv1':
            gl.uniform1fv(location, value);
            break;

        // flat array of floats with 3 x N size (JS or typed array)
        case 'fv':
            gl.uniform3fv(location, value);
            break;

        // array of 2D Point objects
        case 'v2v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(2 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 2]       = value[i].x;
                uniform._array[i * 2 + 1]   = value[i].y;
            }

            gl.uniform2fv(location, uniform._array);
            break;

        // array of 3D Point objects
        case 'v3v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(3 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 3]       = value[i].x;
                uniform._array[i * 3 + 1]   = value[i].y;
                uniform._array[i * 3 + 2]   = value[i].z;

            }

            gl.uniform3fv(location, uniform._array);
            break;

        // array of 4D Point objects
        case 'v4v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(4 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 4]       = value[i].x;
                uniform._array[i * 4 + 1]   = value[i].y;
                uniform._array[i * 4 + 2]   = value[i].z;
                uniform._array[i * 4 + 3]   = value[i].w;

            }

            gl.uniform4fv(location, uniform._array);
            break;

        // PIXI.Texture
        case 't':
        case 'sampler2D':

            if (!uniform.value || !uniform.value.baseTexture.hasLoaded)
            {
                break;
            }

            // activate this texture
            gl.activeTexture(gl['TEXTURE' + this.textureCount]);

            var texture = uniform.value.baseTexture._glTextures[gl.id];

            if (!texture)
            {
                this.initSampler2D(uniform);

                // set the textur to the newly created one..
                texture = uniform.value.baseTexture._glTextures[gl.id];
            }

            // bind the texture
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // set uniform to texture index
            gl.uniform1i(uniform._location, this.textureCount);

            // increment next texture id
            this.textureCount++;

            break;

        default:
            console.warn('Pixi.js Shader Warning: Unknown uniform type: ' + uniform.type);
    }
};

/**
 * Updates the shader uniform values.
 *
 */
Shader.prototype.syncUniforms = function ()
{
    this.textureCount = 1;

    for (var key in this.uniforms)
    {
        this.syncUniform(this.uniforms[key]);
    }
};


/**
 * Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
 *
 */
Shader.prototype.initSampler2D = function (uniform)
{
    var gl = this.gl;

    var texture = uniform.value.baseTexture;

    if(!texture.hasLoaded)
    {
        return;
    }



    if (uniform.textureData)
    {

        //TODO move this...
        var data = uniform.textureData;

        texture._glTextures[gl.id] = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
        // GLTextureLinear = mag/min linear, wrap clamp
        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
        // GLTextureNearest = mag/min nearest, wrap clamp
        // AudioTexture = whatever + luminance + width 512, height 2, border 0
        // KeyTexture = whatever + luminance + width 256, height 2, border 0

        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT

        gl.texImage2D(gl.TEXTURE_2D, 0, data.luminance ? gl.LUMINANCE : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, data.magFilter ? data.magFilter : gl.LINEAR );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE );

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE);
    }
    else
    {
        this.shaderManager.renderer.updateTexture(texture);
    }
};

/**
 * Destroys the shader.
 *
 */
Shader.prototype.destroy = function ()
{
    this.gl.deleteProgram(this.program);

    this.gl = null;
    this.uniforms = null;
    this.attributes = null;

    this.vertexSrc = null;
    this.fragmentSrc = null;
};

Shader.prototype._glCompile = function (type, src)
{
    var shader = this.gl.createShader(type);

    this.gl.shaderSource(shader, src);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS))
    {
        console.log(this.gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

},{"../../../utils":70}],55:[function(require,module,exports){
var Shader = require('./Shader');

/**
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
 * @param [vertexSrc] {string} The source of the vertex shader.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 * @param [customUniforms] {object} Custom uniforms to use to augment the built-in ones.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 */
function TextureShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes)
{
    var uniforms = {

        uSampler:           { type: 'sampler2D', value: 0 },
        projectionMatrix:   { type: 'mat3', value: new Float32Array([1, 0, 0,
                                                                     0, 1, 0,
                                                                     0, 0, 1]) }
    };

    if (customUniforms)
    {
        for (var u in customUniforms)
        {
            uniforms[u] = customUniforms[u];
        }
    }


    var attributes = {
        aVertexPosition:    0,
        aTextureCoord:      0,
        aColor:             0
    };

    if (customAttributes)
    {
        for (var a in customAttributes)
        {
            attributes[a] = customAttributes[a];
        }
    }

    /**
     * The vertex shader.
     *
     * @member {string}
     */
    vertexSrc = vertexSrc || TextureShader.defaultVertexSrc;

    /**
     * The fragment shader.
     *
     * @member {string}
     */
    fragmentSrc = fragmentSrc || TextureShader.defaultFragmentSrc;

    Shader.call(this, shaderManager, vertexSrc, fragmentSrc, uniforms, attributes);
}

// constructor
TextureShader.prototype = Object.create(Shader.prototype);
TextureShader.prototype.constructor = TextureShader;
module.exports = TextureShader;

/**
 * The default vertex shader source
 *
 * @static
 * @constant
 */
TextureShader.defaultVertexSrc = [
    'precision lowp float;',
    'attribute vec2 aVertexPosition;',
    'attribute vec2 aTextureCoord;',
    'attribute vec4 aColor;',

    'uniform mat3 projectionMatrix;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'void main(void){',
    '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
    '   vTextureCoord = aTextureCoord;',
    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
    '}'
].join('\n');

/**
 * The default fragment shader source
 *
 * @static
 * @constant
 */
TextureShader.defaultFragmentSrc = [
    'precision lowp float;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'uniform sampler2D uSampler;',

    'void main(void){',
    '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
    '}'
].join('\n');

},{"./Shader":54}],56:[function(require,module,exports){
var WebGLManager = require('../managers/WebGLManager');

/**
 * Base for a common object renderer that can be used as a system renderer plugin.
 *
 * @class
 * @extends PIXI.WebGLManager
 * @memberof PIXI
 * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.
 */
function ObjectRenderer(renderer)
{
    WebGLManager.call(this, renderer);
}


ObjectRenderer.prototype = Object.create(WebGLManager.prototype);
ObjectRenderer.prototype.constructor = ObjectRenderer;
module.exports = ObjectRenderer;

/**
 * Starts the renderer and sets the shader
 *
 */
ObjectRenderer.prototype.start = function ()
{
    // set the shader..
};

/**
 * Stops the renderer
 *
 */
ObjectRenderer.prototype.stop = function ()
{
    this.flush();
};

/**
 * flushes
 *
 */
ObjectRenderer.prototype.flush = function ()
{
    // flush!
};

/**
 * Renders an object
 *
 * @param object {PIXI.DisplayObject} The object to render.
 */
ObjectRenderer.prototype.render = function (object) // jshint unused:false
{
    // render the object
};

},{"../managers/WebGLManager":51}],57:[function(require,module,exports){
/**
 * Helper class to create a quad
 *
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} The gl context for this quad to use.
 */
function Quad(gl)
{
    /*
     * the current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

//    this.textures = new TextureUvs();

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = new Float32Array([
        0,0,
        200,0,
        200,200,
        0,200
    ]);

    /**
     * The Uvs of the quad
     *
     * @member {Float32Array}
     */
    this.uvs = new Float32Array([
        0,0,
        1,0,
        1,1,
        0,1
    ]);

//    var white = (0xFFFFFF >> 16) + (0xFFFFFF & 0xff00) + ((0xFFFFFF & 0xff) << 16) + (1 * 255 << 24);
    //TODO convert this to a 32 unsigned int array
    /**
     * The color components of the triangles
     *
     * @member {Float32Array}
     */
    this.colors = new Float32Array([
        1,1,1,1,
        1,1,1,1,
        1,1,1,1,
        1,1,1,1
    ]);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = new Uint16Array([
        0, 1, 2, 0, 3, 2
    ]);

    /*
     * @member {WebGLBuffer} The vertex buffer
     */
    this.vertexBuffer = gl.createBuffer();

    /*
     * @member {WebGLBuffer} The index buffer
     */
    this.indexBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    this.upload();
}

Quad.prototype.constructor = Quad;

/**
 * Maps two Rectangle to the quad
 * @param rect {PIXI.Rectangle} the first rectangle
 * @param rect2 {PIXI.Rectangle} the second rectangle
 */
Quad.prototype.map = function(rect, rect2)
{
    var x = 0; //rect2.x / rect.width;
    var y = 0; //rect2.y / rect.height;

    this.uvs[0] = x;
    this.uvs[1] = y;

    this.uvs[2] = x + rect2.width / rect.width;
    this.uvs[3] = y;

    this.uvs[4] = x + rect2.width / rect.width;
    this.uvs[5] = y + rect2.height / rect.height;

    this.uvs[6] = x;
    this.uvs[7] = y + rect2.height / rect.height;

    /// -----
    x = rect2.x;
    y = rect2.y;

    this.vertices[0] = x;
    this.vertices[1] = y;

    this.vertices[2] = x + rect2.width;
    this.vertices[3] = y;

    this.vertices[4] = x + rect2.width;
    this.vertices[5] = y + rect2.height;

    this.vertices[6] = x;
    this.vertices[7] = y + rect2.height;

    this.upload();
};

/**
 * Binds the buffer and uploads the data
 */
Quad.prototype.upload = function()
{
    var gl = this.gl;

    // TODO could probably be pushed into one upload!
    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);

    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this.uvs);

    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this.colors);
};

Quad.prototype.destroy = function()
{
    var gl = this.gl;
    
     gl.deleteBuffer(this.vertexBuffer);
     gl.deleteBuffer(this.indexBuffer);
};

module.exports = Quad;



},{}],58:[function(require,module,exports){
var math = require('../../../math'),
    utils = require('../../../utils'),
    CONST = require('../../../const'),
    //StencilManager = require('../managers/StencilManager'),
    StencilMaskStack = require('./StencilMaskStack');

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 * @param width {number} the horizontal range of the filter
 * @param height {number} the vertical range of the filter
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} the current resolution
 * @param root {boolean} Whether this object is the root element or not
 */
var RenderTarget = function(gl, width, height, scaleMode, resolution, root)
{
    //TODO Resolution could go here ( eg low res blurs )

    /**
     * The current WebGL drawing context.
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // next time to create a frame buffer and texture

    /**
     * A frame buffer
     *
     * @member {WebGLFrameBuffer}
     */
    this.frameBuffer = null;

    /**
     * The texture
     *
     * @member {PIXI.Texture}
     */
    this.texture = null;

    /**
     * The size of the object as a rectangle
     *
     * @member {PIXI.Rectangle}
     */
    this.size = new math.Rectangle(0, 0, 1, 1);

    /**
     * The current resolution
     *
     * @member {number}
     */
    this.resolution = resolution || CONST.RESOLUTION;

    /**
     * The projection matrix
     *
     * @member {PIXI.Matrix}
     */
    this.projectionMatrix = new math.Matrix();

    /**
     * The object's transform
     *
     * @member {PIXI.Matrix}
     */
    this.transform = null;

    /**
     * The frame.
     *
     * @member {PIXI.Rectangle}
     */
    this.frame = null;

    /**
     * The stencil buffer stores masking data for the render target
     *
     * @member {WebGLRenderBuffer}
     */
    this.stencilBuffer = null;

    /**
     * The data structure for the stencil masks
     *
     * @member {PIXI.StencilMaskStack}
     */
    this.stencilMaskStack = new StencilMaskStack();

    /**
     * Stores filter data for the render target
     *
     * @member {object[]}
     */
    this.filterStack = [
        {
            renderTarget:this,
            filter:[],
            bounds:this.size
        }
    ];


    /**
     * The scale mode.
     *
     * @member {number}
     * @default PIXI.SCALE_MODES.DEFAULT
     * @see PIXI.SCALE_MODES
     */
    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;

    /**
     * Whether this object is the root element or not
     *
     * @member {boolean}
     */
    this.root = root;

    if (!this.root)
    {
       // this.flipY = true;
        this.frameBuffer = gl.createFramebuffer();

        /*
            A frame buffer needs a target to render to..
            create a texture and bind it attach it to the framebuffer..
         */

        this.texture = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D,  this.texture);

        // set the scale properties of the texture..
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);

        // check to see if the texture is a power of two!
        var isPowerOfTwo = utils.isPowerOfTwo(width, height);

        //TODO for 99% of use cases if a texture is power of two we should tile the texture...
         if (!isPowerOfTwo)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    }

    this.resize(width, height);
};

RenderTarget.prototype.constructor = RenderTarget;
module.exports = RenderTarget;

/**
 * Clears the filter texture.
 *
 * @param [bind=false] {boolean} Should we bind our framebuffer before clearing?
 */
RenderTarget.prototype.clear = function(bind)
{
    var gl = this.gl;
    if(bind)
    {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
    }

    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/**
 * Binds the stencil buffer.
 *
 */
RenderTarget.prototype.attachStencilBuffer = function()
{

    if (this.stencilBuffer)
    {
        return;
    }

    /**
     * The stencil buffer is used for masking in pixi
     * lets create one and then add attach it to the framebuffer..
     */
    if (!this.root)
    {
        var gl = this.gl;

        this.stencilBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.size.width * this.resolution  , this.size.height * this.resolution );
    }
};

/**
 * Binds the buffers and initialises the viewport.
 *
 */
RenderTarget.prototype.activate = function()
{
    //TOOD refactor usage of frame..
    var gl = this.gl;

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

    var projectionFrame = this.frame || this.size;

    // TODO add a dirty flag to this of a setter for the frame?
    this.calculateProjection( projectionFrame );

    if(this.transform)
    {
        this.projectionMatrix.append(this.transform);
    }

    gl.viewport(0,0, projectionFrame.width * this.resolution, projectionFrame.height * this.resolution);
};

/**
 * Updates the projection matrix based on a projection frame (which is a rectangle)
 *
 */
RenderTarget.prototype.calculateProjection = function (projectionFrame)
{
    var pm = this.projectionMatrix;

    pm.identity();

    if (!this.root)
    {
        pm.a = 1 / projectionFrame.width*2;
        pm.d = 1 / projectionFrame.height*2;

        pm.tx = -1 - projectionFrame.x * pm.a;
        pm.ty = -1 - projectionFrame.y * pm.d;
    }
    else
    {
        pm.a = 1 / projectionFrame.width*2;
        pm.d = -1 / projectionFrame.height*2;

        pm.tx = -1 - projectionFrame.x * pm.a;
        pm.ty = 1 - projectionFrame.y * pm.d;
    }
};


/**
 * Resizes the texture to the specified width and height
 *
 * @param width {Number} the new width of the texture
 * @param height {Number} the new height of the texture
 */
RenderTarget.prototype.resize = function (width, height)
{
    width = width | 0;
    height = height | 0;

    if (this.size.width === width && this.size.height === height) {
        return;
    }

    this.size.width = width;
    this.size.height = height;

    if (!this.root)
    {
        var gl = this.gl;

        gl.bindTexture(gl.TEXTURE_2D,  this.texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width * this.resolution, height * this.resolution , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        if (this.stencilBuffer )
        {
            // update the stencil buffer width and height
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  width * this.resolution, height * this.resolution );
        }
    }

    var projectionFrame = this.frame || this.size;

    this.calculateProjection( projectionFrame );
};

/**
 * Destroys the render target.
 *
 */
RenderTarget.prototype.destroy = function ()
{
    var gl = this.gl;
    gl.deleteRenderbuffer( this.stencilBuffer );
    gl.deleteFramebuffer( this.frameBuffer );
    gl.deleteTexture( this.texture );

    this.frameBuffer = null;
    this.texture = null;
};

},{"../../../const":16,"../../../math":26,"../../../utils":70,"./StencilMaskStack":59}],59:[function(require,module,exports){
/**
 * Generic Mask Stack data structure
 * @class
 * @memberof PIXI
 */
function StencilMaskStack()
{
	/**
     * The actual stack
     *
     * @member {any[]}
     */
    this.stencilStack = [];

    /**
     * TODO @alvin
     *
     * @member {boolean}
     */
    this.reverse = true;

    /**
     * Internal count
     *
     * @member {number}
     */
    this.count = 0;
}

StencilMaskStack.prototype.constructor = StencilMaskStack;
module.exports = StencilMaskStack;

},{}],60:[function(require,module,exports){
var math = require('../math'),
    Texture = require('../textures/Texture'),
    Container = require('../display/Container'),
    CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),
    utils = require('../utils'),
    CONST = require('../const'),
    tempPoint = new math.Point();

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * A sprite can be created directly from an image like this:
 *
 * ```js
 * var sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * ```
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 * @param texture {PIXI.Texture} The texture for this sprite
 */
function Sprite(texture)
{
    Container.call(this);

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting the anchor to 0.5,0.5 means the texture's origin is centered
     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
     *
     * @member {PIXI.Point}
     */
    this.anchor = new math.Point();

    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @private
     */
    this._texture = null;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._height = 0;

    /**
     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;

    /**
     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * The shader that will be used to render the sprite. Set to null to remove a current shader.
     *
     * @member {PIXI.AbstractFilter|PIXI.Shader}
     */
    this.shader = null;

    /**
     * An internal cached value of the tint.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.cachedTint = 0xFFFFFF;

    // call texture setter
    this.texture = texture || Texture.EMPTY;
}

// constructor
Sprite.prototype = Object.create(Container.prototype);
Sprite.prototype.constructor = Sprite;
module.exports = Sprite;

Object.defineProperties(Sprite.prototype, {
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Sprite#
     */
    width: {
        get: function ()
        {
            return Math.abs(this.scale.x) * this.texture._frame.width;
        },
        set: function (value)
        {
            var sign = utils.sign(this.scale.x) || 1;
            this.scale.x = sign * value / this.texture._frame.width;
            this._width = value;
        }
    },

    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Sprite#
     */
    height: {
        get: function ()
        {
            return  Math.abs(this.scale.y) * this.texture._frame.height;
        },
        set: function (value)
        {
            var sign = utils.sign(this.scale.y) || 1;
            this.scale.y = sign * value / this.texture._frame.height;
            this._height = value;
        }
    },

    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.Sprite#
     */
    texture: {
        get: function ()
        {
            return  this._texture;
        },
        set: function (value)
        {
            if (this._texture === value)
            {
                return;
            }

            this._texture = value;
            this.cachedTint = 0xFFFFFF;

            if (value)
            {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded)
                {
                    this._onTextureUpdate();
                }
                else
                {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }
});

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @private
 */
Sprite.prototype._onTextureUpdate = function ()
{
    // so if _width is 0 then width was not set..
    if (this._width)
    {
        this.scale.x = utils.sign(this.scale.x) * this._width / this.texture.frame.width;
    }

    if (this._height)
    {
        this.scale.y = utils.sign(this.scale.y) * this._height / this.texture.frame.height;
    }
};

/**
*
* Renders the object using the WebGL renderer
*
* @param renderer {PIXI.WebGLRenderer}
* @private
*/
Sprite.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render(this);
};

/**
 * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
 * @return {PIXI.Rectangle} the framing rectangle
 */
Sprite.prototype.getBounds = function (matrix)
{
    if(!this._currentBounds)
    {

        var width = this._texture._frame.width;
        var height = this._texture._frame.height;

        var w0 = width * (1-this.anchor.x);
        var w1 = width * -this.anchor.x;

        var h0 = height * (1-this.anchor.y);
        var h1 = height * -this.anchor.y;

        var worldTransform = matrix || this.worldTransform ;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var minX,
            maxX,
            minY,
            maxY;

        //TODO - I am SURE this can be optimised, but the below is not accurate enough..
        /*
        if (b === 0 && c === 0)
        {
            // scale may be negative!
            if (a < 0)
            {
                a *= -1;
            }

            if (d < 0)
            {
                d *= -1;
            }

            // this means there is no rotation going on right? RIGHT?
            // if thats the case then we can avoid checking the bound values! yay
            minX = a * w1 + tx;
            maxX = a * w0 + tx;
            minY = d * h1 + ty;
            maxY = d * h0 + ty;
        }
        else
        {
        */
       
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 =  a * w1 + c * h0 + tx;
        var y4 =  d * h0 + b * w1 + ty;

        minX = x1;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y1;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x1;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y1;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;

        //}

        // check for children
        if(this.children.length)
        {
            var childBounds = this.containerGetBounds();

            w0 = childBounds.x;
            w1 = childBounds.x + childBounds.width;
            h0 = childBounds.y;
            h1 = childBounds.y + childBounds.height;

            minX = (minX < w0) ? minX : w0;
            minY = (minY < h0) ? minY : h0;

            maxX = (maxX > w1) ? maxX : w1;
            maxY = (maxY > h1) ? maxY : h1;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.width = maxX - minX;

        bounds.y = minY;
        bounds.height = maxY - minY;

        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

/**
 * Gets the local bounds of the sprite object.
 *
 */
Sprite.prototype.getLocalBounds = function ()
{
    this._bounds.x = -this._texture._frame.width * this.anchor.x;
    this._bounds.y = -this._texture._frame.height * this.anchor.y;
    this._bounds.width = this._texture._frame.width;
    this._bounds.height = this._texture._frame.height;
    return this._bounds;
};

/**
* Tests if a point is inside this sprite
*
* @param point {PIXI.Point} the point to test
* @return {boolean} the result of the test
*/
Sprite.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var width = this._texture._frame.width;
    var height = this._texture._frame.height;
    var x1 = -width * this.anchor.x;
    var y1;

    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
    {
        y1 = -height * this.anchor.y;

        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
        {
            return true;
        }
    }

    return false;
};

/**
* Renders the object using the Canvas renderer
*
* @param renderer {PIXI.CanvasRenderer} The renderer
* @private
*/
Sprite.prototype._renderCanvas = function (renderer)
{
    if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0)
    {
        return;
    }

    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== renderer.context.globalCompositeOperation)
    {
        renderer.context.globalCompositeOperation = compositeOperation;
    }

    //  Ignore null sources
    if (this.texture.valid)
    {
        var texture = this._texture,
            wt = this.worldTransform,
            dx,
            dy,
            width,
            height;

        renderer.context.globalAlpha = this.worldAlpha;

        // If smoothingEnabled is supported and we need to change the smoothing property for this texture
        var smoothingEnabled = texture.baseTexture.scaleMode === CONST.SCALE_MODES.LINEAR;
        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)
        {
            renderer.context[renderer.smoothProperty] = smoothingEnabled;
        }

        // If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions

        if(texture.rotate)
        {
            width = texture.crop.height;
            height = texture.crop.width;

            dx = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
            dy = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
       
            dx += width;

            wt.tx = dy * wt.a + dx * wt.c + wt.tx;
            wt.ty = dy * wt.b + dx * wt.d + wt.ty;

            var temp = wt.a;
            wt.a  = -wt.c;
            wt.c  =  temp;

            temp = wt.b;
            wt.b  = -wt.d;
            wt.d  =  temp;

            // the anchor has already been applied above, so lets set it to zero
            dx = 0;
            dy = 0;

        }
        else
        {
            width = texture.crop.width;
            height = texture.crop.height;

            dx = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
            dy = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
        }



        // Allow for pixel rounding
        if (renderer.roundPixels)
        {
            renderer.context.setTransform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                (wt.tx * renderer.resolution) | 0,
                (wt.ty * renderer.resolution) | 0
            );

            dx = dx | 0;
            dy = dy | 0;
        }
        else
        {

            renderer.context.setTransform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                wt.tx * renderer.resolution,
                wt.ty * renderer.resolution
            );


        }

        var resolution = texture.baseTexture.resolution;

        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;

                // TODO clean up caching - how to clean up the caches?
                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
            }

            renderer.context.drawImage(
                this.tintedTexture,
                0,
                0,
                width * resolution,
                height * resolution,
                dx * renderer.resolution,
                dy * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
        else
        {
            renderer.context.drawImage(
                texture.baseTexture.source,
                texture.crop.x * resolution,
                texture.crop.y * resolution,
                width * resolution,
                height * resolution,
                dx  * renderer.resolution,
                dy  * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
    }
};

/**
 * Destroys this sprite and optionally its texture
 *
 * @param [destroyTexture=false] {boolean} Should it destroy the current texture of the sprite as well
 * @param [destroyBaseTexture=false] {boolean} Should it destroy the base texture of the sprite as well
 */
Sprite.prototype.destroy = function (destroyTexture, destroyBaseTexture)
{
    Container.prototype.destroy.call(this);

    this.anchor = null;

    if (destroyTexture)
    {
        this._texture.destroy(destroyBaseTexture);
    }

    this._texture = null;
    this.shader = null;
};

// some helper functions..

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
 */
Sprite.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
    }

    return new Sprite(texture);
};

/**
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @static
 * @param imageId {string} The image url of the texture
 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
 */
Sprite.fromImage = function (imageId, crossorigin, scaleMode)
{
    return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));
};

},{"../const":16,"../display/Container":17,"../math":26,"../renderers/canvas/utils/CanvasTinter":41,"../textures/Texture":65,"../utils":70}],61:[function(require,module,exports){
var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    CONST = require('../../const');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's SpriteRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteRenderer.java
 */

/**
 * Renderer dedicated to drawing and batching sprites.
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
 */
function SpriteRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    /**
     * Number of values sent in the vertex buffer.
     * positionX, positionY, colorR, colorG, colorB = 5
     *
     * @member {number}
     */
    this.vertSize = 5;

    /**
     * The size of the vertex information in bytes.
     *
     * @member {number}
     */
    this.vertByteSize = this.vertSize * 4;

    /**
     * The number of images in the SpriteBatch before it flushes.
     *
     * @member {number}
     */
    this.size = CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

    // the total number of bytes in our batch
    var numVerts = (this.size * 4) * this.vertByteSize;

    // the total number of indices in our batch, there are 6 points per quad.
    var numIndices = this.size * 6;

    /**
     * Holds the vertex data that will be sent to the vertex shader.
     *
     * @member {ArrayBuffer}
     */
    this.vertices = new ArrayBuffer(numVerts);

    /**
     * View on the vertices as a Float32Array for positions
     *
     * @member {Float32Array}
     */
    this.positions = new Float32Array(this.vertices);

    /**
     * View on the vertices as a Uint32Array for colors
     *
     * @member {Uint32Array}
     */
    this.colors = new Uint32Array(this.vertices);

    /**
     * Holds the indices of the geometry (quads) to draw
     *
     * @member {Uint16Array}
     */
    this.indices = new Uint16Array(numIndices);

    // fill the indices with the quads to draw
    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     * The current size of the batch, each render() call adds to this number.
     *
     * @member {number}
     */
    this.currentBatchSize = 0;

    /**
     * The current sprites in the batch.
     *
     * @member {PIXI.Sprite[]}
     */
    this.sprites = [];

    /**
     * The default shader that is used if a sprite doesn't have a more specific one.
     *
     * @member {PIXI.Shader}
     */
    this.shader = null;
}

SpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);
SpriteRenderer.prototype.constructor = SpriteRenderer;
module.exports = SpriteRenderer;

WebGLRenderer.registerPlugin('sprite', SpriteRenderer);

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 */
SpriteRenderer.prototype.onContextChange = function ()
{
    var gl = this.renderer.gl;

    // setup default shader
    this.shader = this.renderer.shaderManager.defaultShader;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;
};

/**
 * Renders the sprite object.
 *
 * @param sprite {PIXI.Sprite} the sprite to render when using this spritebatch
 */
SpriteRenderer.prototype.render = function (sprite)
{
    var texture = sprite._texture;

    //TODO set blend modes..
    // check texture..
    if (this.currentBatchSize >= this.size)
    {
        this.flush();
    }

    // get the uvs for the texture
    var uvs = texture._uvs;

    // if the uvs have not updated then no point rendering just yet!
    if (!uvs)
    {
        return;
    }

    // TODO trim??
    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;

    var w0, w1, h0, h1;

    if (texture.trim && sprite.tileScale === undefined)
    {
        // if the sprite is trimmed and is not a tilingsprite then we need to add the extra space before transforming the sprite coords..
        var trim = texture.trim;

        w1 = trim.x - aX * trim.width;
        w0 = w1 + texture.crop.width;

        h1 = trim.y - aY * trim.height;
        h0 = h1 + texture.crop.height;

    }
    else
    {
        w0 = (texture._frame.width ) * (1-aX);
        w1 = (texture._frame.width ) * -aX;

        h0 = texture._frame.height * (1-aY);
        h1 = texture._frame.height * -aY;
    }

    var index = this.currentBatchSize * this.vertByteSize;

    var worldTransform = sprite.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var colors = this.colors;
    var positions = this.positions;

    if (this.renderer.roundPixels)
    {
        var resolution = this.renderer.resolution;

        // xy
        positions[index] = (((a * w1 + c * h1 + tx) * resolution) | 0) / resolution;
        positions[index+1] = (((d * h1 + b * w1 + ty) * resolution) | 0) / resolution;

        // xy
        positions[index+5] = (((a * w0 + c * h1 + tx) * resolution) | 0) / resolution;
        positions[index+6] = (((d * h1 + b * w0 + ty) * resolution) | 0) / resolution;

         // xy
        positions[index+10] = (((a * w0 + c * h0 + tx) * resolution) | 0) / resolution;
        positions[index+11] = (((d * h0 + b * w0 + ty) * resolution) | 0) / resolution;

        // xy
        positions[index+15] = (((a * w1 + c * h0 + tx) * resolution) | 0) / resolution;
        positions[index+16] = (((d * h0 + b * w1 + ty) * resolution) | 0) / resolution;
    }
    else
    {

        // xy
        positions[index] = a * w1 + c * h1 + tx;
        positions[index+1] = d * h1 + b * w1 + ty;

        // xy
        positions[index+5] = a * w0 + c * h1 + tx;
        positions[index+6] = d * h1 + b * w0 + ty;

         // xy
        positions[index+10] = a * w0 + c * h0 + tx;
        positions[index+11] = d * h0 + b * w0 + ty;

        // xy
        positions[index+15] = a * w1 + c * h0 + tx;
        positions[index+16] = d * h0 + b * w1 + ty;
    }

    // uv
    positions[index+2] = uvs.x0;
    positions[index+3] = uvs.y0;

    // uv
    positions[index+7] = uvs.x1;
    positions[index+8] = uvs.y1;

     // uv
    positions[index+12] = uvs.x2;
    positions[index+13] = uvs.y2;

    // uv
    positions[index+17] = uvs.x3;
    positions[index+18] = uvs.y3;

    // color and alpha
    var tint = sprite.tint;
    colors[index+4] = colors[index+9] = colors[index+14] = colors[index+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);

    // increment the batchsize
    this.sprites[this.currentBatchSize++] = sprite;
};

/**
 * Renders the content and empties the current batch.
 *
 */
SpriteRenderer.prototype.flush = function ()
{
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize === 0)
    {
        return;
    }

    var gl = this.renderer.gl;
    var shader;

    // upload the verts to the buffer
    if (this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }

    var nextTexture, nextBlendMode, nextShader;
    var batchSize = 0;
    var start = 0;

    var currentBaseTexture = null;
    var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;
    var currentShader = null;

    var blendSwap = false;
    var shaderSwap = false;
    var sprite;

    for (var i = 0, j = this.currentBatchSize; i < j; i++)
    {

        sprite = this.sprites[i];

        nextTexture = sprite._texture.baseTexture;
        nextBlendMode = sprite.blendMode;
        nextShader = sprite.shader || this.shader;

        blendSwap = currentBlendMode !== nextBlendMode;
        shaderSwap = currentShader !== nextShader; // should I use uidS???

        if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap)
        {
            this.renderBatch(currentBaseTexture, batchSize, start);

            start = i;
            batchSize = 0;
            currentBaseTexture = nextTexture;

            if (blendSwap)
            {
                currentBlendMode = nextBlendMode;
                this.renderer.blendModeManager.setBlendMode( currentBlendMode );
            }

            if (shaderSwap)
            {
                currentShader = nextShader;



                shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;

                if (!shader)
                {
                    shader = currentShader.getShader(this.renderer);

                }

                // set shader function???
                this.renderer.shaderManager.setShader(shader);

                //TODO - i KNOW this can be optimised! Once v3 is stable il look at this next...
                shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);
                //Make this a little more dynamic / intelligent!
                shader.syncUniforms();

                //TODO investigate some kind of texture state managment??
                // need to make sure this texture is the active one for all the batch swaps..
                gl.activeTexture(gl.TEXTURE0);

                // both thease only need to be set if they are changing..
                // set the projection
                //gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));


            }
        }

        batchSize++;
    }

    this.renderBatch(currentBaseTexture, batchSize, start);

    // then reset the batch!
    this.currentBatchSize = 0;
};

/**
 * Draws the currently batches sprites.
 *
 * @private
 * @param texture {PIXI.Texture}
 * @param size {number}
 * @param startIndex {number}
 */
SpriteRenderer.prototype.renderBatch = function (texture, size, startIndex)
{
    if (size === 0)
    {
        return;
    }

    var gl = this.renderer.gl;

    if (!texture._glTextures[gl.id])
    {
        this.renderer.updateTexture(texture);
    }
    else
    {
        // bind the current texture
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
    }

    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);

    // increment the draw count
    this.renderer.drawCount++;
};

/**
 * Starts a new sprite batch.
 *
 */
SpriteRenderer.prototype.start = function ()
{
    var gl = this.renderer.gl;

    // bind the main texture


    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // this is the same for each shader?
    var stride =  this.vertByteSize;
    gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);

    // color attributes will be interpreted as unsigned bytes and normalized
    gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);
};

/**
 * Destroys the SpriteBatch.
 *
 */
SpriteRenderer.prototype.destroy = function ()
{
    this.renderer.gl.deleteBuffer(this.vertexBuffer);
    this.renderer.gl.deleteBuffer(this.indexBuffer);

    ObjectRenderer.prototype.destroy.call(this);

    this.shader.destroy();

    this.renderer = null;

    this.vertices = null;
    this.positions = null;
    this.colors = null;
    this.indices = null;

    this.vertexBuffer = null;
    this.indexBuffer = null;

    this.sprites = null;
    this.shader = null;
};

},{"../../const":16,"../../renderers/webgl/WebGLRenderer":42,"../../renderers/webgl/utils/ObjectRenderer":56}],62:[function(require,module,exports){
var Sprite = require('../sprites/Sprite'),
    Texture = require('../textures/Texture'),
    math = require('../math'),
    utils = require('../utils'),
    CONST = require('../const');

/**
 * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
 *
 * A Text can be created directly from a string and a style object
 *
 * ```js
 * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});
 * ```
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI
 * @param text {string} The copy that you would like the text to display
 * @param [style] {object} The style parameters
 * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font
 * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true
 * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
 * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
 * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius
 * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
 *      prevent this from happening by adding padding to the top and bottom of text height.
 * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
 * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
 *      spiked text issues. Default is 'miter' (creates a sharp corner).
 * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
 *      or increase the spikiness of rendered text.
 */
function Text(text, style, resolution)
{
    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * The canvas 2d context that everything is drawn with
     * @member {HTMLCanvasElement}
     */
    this.context = this.canvas.getContext('2d');

    /**
     * The resolution of the canvas.
     * @member {number}
     */
    this.resolution = resolution || CONST.RESOLUTION;

    /**
     * Private tracker for the current text.
     *
     * @member {string}
     * @private
     */
    this._text = null;

    /**
     * Private tracker for the current style.
     *
     * @member {object}
     * @private
     */
    this._style = null;

    var texture = Texture.fromCanvas(this.canvas);
    texture.trim = new math.Rectangle();
    Sprite.call(this, texture);

    this.text = text;
    this.style = style;
}

// constructor
Text.prototype = Object.create(Sprite.prototype);
Text.prototype.constructor = Text;
module.exports = Text;

Text.fontPropertiesCache = {};
Text.fontPropertiesCanvas = document.createElement('canvas');
Text.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');

Object.defineProperties(Text.prototype, {
    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Text#
     */
    width: {
        get: function ()
        {
            if (this.dirty)
            {
                this.updateText();
            }

            return this.scale.x * this._texture._frame.width;
        },
        set: function (value)
        {
            this.scale.x = value / this._texture._frame.width;
            this._width = value;
        }
    },

    /**
     * The height of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Text#
     */
    height: {
        get: function ()
        {
            if (this.dirty)
            {
                this.updateText();
            }

            return  this.scale.y * this._texture._frame.height;
        },
        set: function (value)
        {
            this.scale.y = value / this._texture._frame.height;
            this._height = value;
        }
    },

    /**
     * Set the style of the text
     *
     * @param [style] {object} The style parameters
     * @param [style.font='bold 20pt Arial'] {string} The style and size of the font
     * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'
     * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'
     * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
     * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
     * @param [style.wordWrapWidth=100] {number} The width at which text will wrap
     * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
     * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
     * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow
     * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
     * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius
     * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
     *      prevent this from happening by adding padding to the top and bottom of text height.
     * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
     * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
     *      spiked text issues. Default is 'miter' (creates a sharp corner).
     * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
     *      or increase the spikiness of rendered text.
     * @memberof PIXI.Text#
     */
    style: {
        get: function ()
        {
            return this._style;
        },
        set: function (style)
        {
            style = style || {};

            if (typeof style.fill === 'number') {
                style.fill = utils.hex2string(style.fill);
            }

            if (typeof style.stroke === 'number') {
                style.stroke = utils.hex2string(style.stroke);
            }

            if (typeof style.dropShadowColor === 'number') {
                style.dropShadowColor = utils.hex2string(style.dropShadowColor);
            }

            style.font = style.font || 'bold 20pt Arial';
            style.fill = style.fill || 'black';
            style.align = style.align || 'left';
            style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/pixijs/pixi.js/issues/136
            style.strokeThickness = style.strokeThickness || 0;
            style.wordWrap = style.wordWrap || false;
            style.wordWrapWidth = style.wordWrapWidth || 100;

            style.dropShadow = style.dropShadow || false;
            style.dropShadowColor = style.dropShadowColor || '#000000';
            style.dropShadowAngle = style.dropShadowAngle !== undefined ? style.dropShadowAngle : Math.PI / 6;
            style.dropShadowDistance = style.dropShadowDistance !== undefined ? style.dropShadowDistance : 5;
            style.dropShadowBlur = style.dropShadowBlur !== undefined ? style.dropShadowBlur : 0; //shadowBlur is '0' by default according to HTML

            style.padding = style.padding || 0;

            style.textBaseline = style.textBaseline || 'alphabetic';

            style.lineJoin = style.lineJoin || 'miter';
            style.miterLimit = style.miterLimit || 10;

            this._style = style;
            this.dirty = true;
        }
    },

    /**
     * Set the copy for the text object. To split a line you can use '\n'.
     *
     * @param text {string} The copy that you would like the text to display
     * @memberof PIXI.Text#
     */
    text: {
        get: function()
        {
            return this._text;
        },
        set: function (text){
            text = text.toString() || ' ';
            if (this._text === text)
            {
                return;
            }
            this._text = text;
            this.dirty = true;
        }
    }
});

/**
 * Renders text and updates it when needed
 *
 * @private
 */
Text.prototype.updateText = function ()
{
    var style = this._style;
    this.context.font = style.font;

    // word wrap
    // preserve original text
    var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;

    // split text into lines
    var lines = outputText.split(/(?:\r\n|\r|\n)/);

    // calculate text width
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    var fontProperties = this.determineFontProperties(style.font);
    for (var i = 0; i < lines.length; i++)
    {
        var lineWidth = this.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }

    var width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow)
    {
        width += style.dropShadowDistance;
    }

    this.canvas.width = ( width + this.context.lineWidth ) * this.resolution;

    // calculate text height
    var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;

    var height = lineHeight * lines.length;
    if (style.dropShadow)
    {
        height += style.dropShadowDistance;
    }

    this.canvas.height = ( height + this._style.padding * 2 ) * this.resolution;

    this.context.scale( this.resolution, this.resolution);

    if (navigator.isCocoonJS)
    {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    }

    //this.context.fillStyle="#FF0000";
    //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

    this.context.font = style.font;
    this.context.strokeStyle = style.stroke;
    this.context.lineWidth = style.strokeThickness;
    this.context.textBaseline = style.textBaseline;
    this.context.lineJoin = style.lineJoin;
    this.context.miterLimit = style.miterLimit;

    var linePositionX;
    var linePositionY;

    if (style.dropShadow)
    {
        if (style.dropShadowBlur > 0) {
            this.context.shadowColor = style.dropShadowColor;
            this.context.shadowBlur = style.dropShadowBlur;
        } else {
            this.context.fillStyle = style.dropShadowColor;
        }

        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;

        for (i = 0; i < lines.length; i++)
        {
            linePositionX = style.strokeThickness / 2;
            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;

            if (style.align === 'right')
            {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if (style.align === 'center')
            {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }

            if (style.fill)
            {
                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);
            }
        }
    }

    //set canvas text styles
    this.context.fillStyle = style.fill;

    //draw lines line by line
    for (i = 0; i < lines.length; i++)
    {
        linePositionX = style.strokeThickness / 2;
        linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;

        if (style.align === 'right')
        {
            linePositionX += maxLineWidth - lineWidths[i];
        }
        else if (style.align === 'center')
        {
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        }

        if (style.stroke && style.strokeThickness)
        {
            this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);
        }

        if (style.fill)
        {
            this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);
        }
    }

    this.updateTexture();
};

/**
 * Updates texture size based on canvas size
 *
 * @private
 */
Text.prototype.updateTexture = function ()
{
    var texture = this._texture;

    texture.baseTexture.hasLoaded = true;
    texture.baseTexture.resolution = this.resolution;

    texture.baseTexture.width = this.canvas.width / this.resolution;
    texture.baseTexture.height = this.canvas.height / this.resolution;
    texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;
    texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;

    texture.trim.x = 0;
    texture.trim.y = -this._style.padding;

    texture.trim.width = texture._frame.width;
    texture.trim.height = texture._frame.height - this._style.padding*2;

    this._width = this.canvas.width / this.resolution;
    this._height = this.canvas.height / this.resolution;

    texture.baseTexture.emit('update',  texture.baseTexture);

    this.dirty = false;
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer}
 */
Text.prototype.renderWebGL = function (renderer)
{
    if (this.dirty)
    {
        //this.resolution = 1//renderer.resolution;

        this.updateText();
    }

    Sprite.prototype.renderWebGL.call(this, renderer);
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer}
 * @private
 */
Text.prototype._renderCanvas = function (renderer)
{
    if (this.dirty)
    {
     //   this.resolution = 1//renderer.resolution;

        this.updateText();
    }

    Sprite.prototype._renderCanvas.call(this, renderer);
};

/**
 * Calculates the ascent, descent and fontSize of a given fontStyle
 *
 * @param fontStyle {object}
 * @private
 */
Text.prototype.determineFontProperties = function (fontStyle)
{
    var properties = Text.fontPropertiesCache[fontStyle];

    if (!properties)
    {
        properties = {};

        var canvas = Text.fontPropertiesCanvas;
        var context = Text.fontPropertiesContext;

        context.font = fontStyle;

        var width = Math.ceil(context.measureText('|MÉq').width);
        var baseline = Math.ceil(context.measureText('M').width);
        var height = 2 * baseline;

        baseline = baseline * 1.4 | 0;

        canvas.width = width;
        canvas.height = height;

        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);

        context.font = fontStyle;

        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText('|MÉq', 0, baseline);

        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;

        var i, j;

        var idx = 0;
        var stop = false;

        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; i++)
        {
            for (j = 0; j < line; j += 4)
            {
                if (imagedata[idx + j] !== 255)
                {
                    stop = true;
                    break;
                }
            }
            if (!stop)
            {
                idx += line;
            }
            else
            {
                break;
            }
        }

        properties.ascent = baseline - i;

        idx = pixels - line;
        stop = false;

        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; i--)
        {
            for (j = 0; j < line; j += 4)
            {
                if (imagedata[idx + j] !== 255)
                {
                    stop = true;
                    break;
                }
            }
            if (!stop)
            {
                idx -= line;
            }
            else
            {
                break;
            }
        }

        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;

        Text.fontPropertiesCache[fontStyle] = properties;
    }

    return properties;
};

/**
 * Applies newlines to a string to have it optimally fit into the horizontal
 * bounds set by the Text object's wordWrapWidth property.
 *
 * @param text {string}
 * @private
 */
Text.prototype.wordWrap = function (text)
{
    // Greedy wrapping algorithm that will wrap words as the line grows longer
    // than its horizontal bounds.
    var result = '';
    var lines = text.split('\n');
    var wordWrapWidth = this._style.wordWrapWidth;
    for (var i = 0; i < lines.length; i++)
    {
        var spaceLeft = wordWrapWidth;
        var words = lines[i].split(' ');
        for (var j = 0; j < words.length; j++)
        {
            var wordWidth = this.context.measureText(words[j]).width;
            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
            if (j === 0 || wordWidthWithSpace > spaceLeft)
            {
                // Skip printing the newline if it's the first word of the line that is
                // greater than the word wrap width.
                if (j > 0)
                {
                    result += '\n';
                }
                result += words[j];
                spaceLeft = wordWrapWidth - wordWidth;
            }
            else
            {
                spaceLeft -= wordWidthWithSpace;
                result += ' ' + words[j];
            }
        }

        if (i < lines.length-1)
        {
            result += '\n';
        }
    }
    return result;
};

/**
 * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the Text
 * @return {PIXI.Rectangle} the framing rectangle
 */
Text.prototype.getBounds = function (matrix)
{
    if (this.dirty)
    {
        this.updateText();
    }

    return Sprite.prototype.getBounds.call(this, matrix);
};

/**
 * Destroys this text object.
 *
 * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well
 */
Text.prototype.destroy = function (destroyBaseTexture)
{
    // make sure to reset the the context and canvas.. dont want this hanging around in memory!
    this.context = null;
    this.canvas = null;

    this._style = null;

    this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
};

},{"../const":16,"../math":26,"../sprites/Sprite":60,"../textures/Texture":65,"../utils":70}],63:[function(require,module,exports){
var utils = require('../utils'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3');

/**
 * A texture stores the information that represents an image. All textures have a base texture.
 *
 * @class
 * @memberof PIXI
 * @param source {Image|Canvas} the source object of the texture.
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} the resolution of the texture for devices with different pixel ratios
 */
function BaseTexture(source, scaleMode, resolution)
{
    EventEmitter.call(this);

    this.uid = utils.uid();

    /**
     * The Resolution of the texture.
     *
     * @member {number}
     */
    this.resolution = resolution || 1;

    /**
     * The width of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.width = 100;

    /**
     * The height of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.height = 100;

    // TODO docs
    // used to store the actual dimensions of the source
    /**
     * Used to store the actual width of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realWidth = 100;
    /**
     * Used to store the actual height of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realHeight = 100;

    /**
     * The scale mode to apply when scaling this texture
     *
     * @member {number}
     * @default PIXI.SCALE_MODES.LINEAR
     * @see PIXI.SCALE_MODES
     */
    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;

    /**
     * Set to true once the base texture has successfully loaded.
     *
     * This is never true if the underlying source fails to load or has no texture data.
     *
     * @member {boolean}
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * Set to true if the source is currently loading.
     *
     * If an Image source is loading the 'loaded' or 'error' event will be
     * dispatched when the operation ends. An underyling source that is
     * immediately-available bypasses loading entirely.
     *
     * @member {boolean}
     * @readonly
     */
    this.isLoading = false;

    /**
     * The image source that is used to create the texture.
     *
     * TODO: Make this a setter that calls loadSource();
     *
     * @member {Image|Canvas}
     * @readonly
     */
    this.source = null; // set in loadSource, if at all

    /**
     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
     *
     * @member {boolean}
     * @default true
     */
    this.premultipliedAlpha = true;

    /**
     * @member {string}
     */
    this.imageUrl = null;

    /**
     * Wether or not the texture is a power of two, try to use power of two textures as much as you can
     * @member {boolean}
     * @private
     */
    this.isPowerOfTwo = false;

    // used for webGL

    /**
     *
     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
     * Also the texture must be a power of two size to work
     *
     * @member {boolean}
     */
    this.mipmap = false;

    /**
     * A map of renderer IDs to webgl textures
     *
     * @member {object<number, WebGLTexture>}
     * @private
     */
    this._glTextures = {};

    // if no source passed don't try to load
    if (source)
    {
        this.loadSource(source);
    }

    /**
     * Fired when a not-immediately-available source finishes loading.
     *
     * @event loaded
     * @memberof PIXI.BaseTexture#
     * @protected
     */

    /**
     * Fired when a not-immediately-available source fails to load.
     *
     * @event error
     * @memberof PIXI.BaseTexture#
     * @protected
     */
}

BaseTexture.prototype = Object.create(EventEmitter.prototype);
BaseTexture.prototype.constructor = BaseTexture;
module.exports = BaseTexture;

/**
 * Updates the texture on all the webgl renderers, this also assumes the src has changed.
 *
 * @fires update
 */
BaseTexture.prototype.update = function ()
{
    this.realWidth = this.source.naturalWidth || this.source.width;
    this.realHeight = this.source.naturalHeight || this.source.height;

    this.width = this.realWidth / this.resolution;
    this.height = this.realHeight / this.resolution;

    this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);

    this.emit('update', this);
};

/**
 * Load a source.
 *
 * If the source is not-immediately-available, such as an image that needs to be
 * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
 * and `hasLoaded` will remain false after this call.
 *
 * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
 *
 *     if (texture.hasLoaded)
 {
 *        // texture ready for use
 *     } else if (texture.isLoading)
 {
 *        // listen to 'loaded' and/or 'error' events on texture
 *     } else {
 *        // not loading, not going to load UNLESS the source is reloaded
 *        // (it may still make sense to listen to the events)
 *     }
 *
 * @protected
 * @param source {Image|Canvas} the source object of the texture.
 */
BaseTexture.prototype.loadSource = function (source)
{
    var wasLoading = this.isLoading;
    this.hasLoaded = false;
    this.isLoading = false;

    if (wasLoading && this.source)
    {
        this.source.onload = null;
        this.source.onerror = null;
    }

    this.source = source;

    // Apply source if loaded. Otherwise setup appropriate loading monitors.
    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
    {
        this._sourceLoaded();
    }
    else if (!source.getContext)
    {

        // Image fail / not ready
        this.isLoading = true;

        var scope = this;

        source.onload = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope._sourceLoaded();

            scope.emit('loaded', scope);
        };

        source.onerror = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope.emit('error', scope);
        };

        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
        //   "The value of `complete` can thus change while a script is executing."
        // So complete needs to be re-checked after the callbacks have been added..
        // NOTE: complete will be true if the image has no src so best to check if the src is set.
        if (source.complete && source.src)
        {
            this.isLoading = false;

            // ..and if we're complete now, no need for callbacks
            source.onload = null;
            source.onerror = null;

            if (source.width && source.height)
            {
                this._sourceLoaded();

                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('loaded', this);
                }
            }
            else
            {
                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('error', this);
                }
            }
        }
    }
};

/**
 * Used internally to update the width, height, and some other tracking vars once
 * a source has successfully loaded.
 *
 * @private
 */
BaseTexture.prototype._sourceLoaded = function ()
{
    this.hasLoaded = true;
    this.update();
};

/**
 * Destroys this base texture
 *
 */
BaseTexture.prototype.destroy = function ()
{
    if (this.imageUrl)
    {
        delete utils.BaseTextureCache[this.imageUrl];
        delete utils.TextureCache[this.imageUrl];

        this.imageUrl = null;

        if (!navigator.isCocoonJS)
        {
            this.source.src = '';
        }
    }
    else if (this.source && this.source._pixiId)
    {
        delete utils.BaseTextureCache[this.source._pixiId];
    }

    this.source = null;

    this.dispose();
};

/**
 * Frees the texture from WebGL memory without destroying this texture object.
 * This means you can still use the texture later which will upload it to GPU
 * memory again.
 *
 */
BaseTexture.prototype.dispose = function ()
{
    this.emit('dispose', this);

    // this should no longer be needed, the renderers should cleanup all the gl textures.
    // this._glTextures = {};
};

/**
 * Changes the source image of the texture.
 * The original source must be an Image element.
 *
 * @param newSrc {string} the path of the image
 */
BaseTexture.prototype.updateSourceImage = function (newSrc)
{
    this.source.src = newSrc;

    this.loadSource(this.source);
};

/**
 * Helper function that creates a base texture from the given image url.
 * If the image is not in the base texture cache it will be created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return PIXI.BaseTexture
 */
BaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var baseTexture = utils.BaseTextureCache[imageUrl];

    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)
    {
        crossorigin = true;
    }

    if (!baseTexture)
    {
        // new Image() breaks tex loading in some versions of Chrome.
        // See https://code.google.com/p/chromium/issues/detail?id=238071
        var image = new Image();//document.createElement('img');
        if (crossorigin)
        {
            image.crossOrigin = '';
        }

        baseTexture = new BaseTexture(image, scaleMode);
        baseTexture.imageUrl = imageUrl;

        image.src = imageUrl;

        utils.BaseTextureCache[imageUrl] = baseTexture;

        // if there is an @2x at the end of the url we are going to assume its a highres image
        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);
    }

    return baseTexture;
};

/**
 * Helper function that creates a base texture from the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return PIXI.BaseTexture
 */
BaseTexture.fromCanvas = function (canvas, scaleMode)
{
    if (!canvas._pixiId)
    {
        canvas._pixiId = 'canvas_' + utils.uid();
    }

    var baseTexture = utils.BaseTextureCache[canvas._pixiId];

    if (!baseTexture)
    {
        baseTexture = new BaseTexture(canvas, scaleMode);
        utils.BaseTextureCache[canvas._pixiId] = baseTexture;
    }

    return baseTexture;
};

},{"../const":16,"../utils":70,"eventemitter3":10}],64:[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    Texture = require('./Texture'),
    RenderTarget = require('../renderers/webgl/utils/RenderTarget'),
    FilterManager = require('../renderers/webgl/managers/FilterManager'),
    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
    math = require('../math'),
    CONST = require('../const'),
    tempMatrix = new math.Matrix();

/**
 * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. The position
 * and rotation of the given Display Objects is ignored. For example:
 *
 * ```js
 * var renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
 * var renderTexture = new PIXI.RenderTexture(renderer, 800, 600);
 * var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderTexture.render(sprite);
 * ```
 *
 * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual
 * position a Container should be used:
 *
 * ```js
 * var doc = new PIXI.Container();
 *
 * doc.addChild(sprite);
 *
 * renderTexture.render(doc);  // Renders to center of renderTexture
 * ```
 *
 * @class
 * @extends PIXI.Texture
 * @memberof PIXI
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used for this RenderTexture
 * @param [width=100] {number} The width of the render texture
 * @param [height=100] {number} The height of the render texture
 * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param [resolution=1] {number} The resolution of the texture being generated
 */
function RenderTexture(renderer, width, height, scaleMode, resolution)
{
    if (!renderer)
    {
        throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');
    }

    width = width || 100;
    height = height || 100;
    resolution = resolution || CONST.RESOLUTION;

    /**
     * The base texture object that this texture uses
     *
     * @member {BaseTexture}
     */
    var baseTexture = new BaseTexture();
    baseTexture.width = width;
    baseTexture.height = height;
    baseTexture.resolution = resolution;
    baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
    baseTexture.hasLoaded = true;


    Texture.call(this,
        baseTexture,
        new math.Rectangle(0, 0, width, height)
    );


    /**
     * The with of the render texture
     *
     * @member {number}
     */
    this.width = width;

    /**
     * The height of the render texture
     *
     * @member {number}
     */
    this.height = height;

    /**
     * The Resolution of the texture.
     *
     * @member {number}
     */
    this.resolution = resolution;

    /**
     * Draw/render the given DisplayObject onto the texture.
     *
     * The displayObject and descendents are transformed during this operation.
     * If `updateTransform` is true then the transformations will be restored before the
     * method returns. Otherwise it is up to the calling code to correctly use or reset
     * the transformed display objects.
     *
     * The display object is always rendered with a worldAlpha value of 1.
     *
     * @method
     * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
     * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
     * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
     * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
     *  transformations will be restored. Not restoring this information will be a little faster.
     */
    this.render = null;

    /**
     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.
     *
     * @member {PIXI.CanvasRenderer|PIXI.WebGLRenderer}
     */
    this.renderer = renderer;

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;

        this.textureBuffer = new RenderTarget(gl, this.width, this.height, baseTexture.scaleMode, this.resolution);//, this.baseTexture.scaleMode);
        this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;

        //TODO refactor filter manager.. as really its no longer a manager if we use it here..
        this.filterManager = new FilterManager(this.renderer);
        this.filterManager.onContextChange();
        this.filterManager.resize(width, height);
        this.render = this.renderWebGL;

        // the creation of a filter manager unbinds the buffers..
        this.renderer.currentRenderer.start();
        this.renderer.currentRenderTarget.activate();
    }
    else
    {

        this.render = this.renderCanvas;
        this.textureBuffer = new CanvasBuffer(this.width* this.resolution, this.height* this.resolution);
        this.baseTexture.source = this.textureBuffer.canvas;
    }

    /**
     * @member {boolean}
     */
    this.valid = true;

    this._updateUvs();
}

RenderTexture.prototype = Object.create(Texture.prototype);
RenderTexture.prototype.constructor = RenderTexture;
module.exports = RenderTexture;

/**
 * Resizes the RenderTexture.
 *
 * @param width {number} The width to resize to.
 * @param height {number} The height to resize to.
 * @param updateBase {boolean} Should the baseTexture.width and height values be resized as well?
 */
RenderTexture.prototype.resize = function (width, height, updateBase)
{
    if (width === this.width && height === this.height)
    {
        return;
    }

    this.valid = (width > 0 && height > 0);

    this.width = this._frame.width = this.crop.width = width;
    this.height =  this._frame.height = this.crop.height = height;

    if (updateBase)
    {
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
    }

    if (!this.valid)
    {
        return;
    }

    this.textureBuffer.resize(this.width, this.height);

    if(this.filterManager)
    {
        this.filterManager.resize(this.width, this.height);
    }
};

/**
 * Clears the RenderTexture.
 *
 */
RenderTexture.prototype.clear = function ()
{
    if (!this.valid)
    {
        return;
    }

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
    }

    this.textureBuffer.clear();
};

/**
 * Internal method assigned to the `render` property if using a CanvasRenderer.
 *
 * @private
 * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
 * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
 * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
 * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
 *  transformations will be restored. Not restoring this information will be a little faster.
 */
RenderTexture.prototype.renderWebGL = function (displayObject, matrix, clear, updateTransform)
{
    if (!this.valid)
    {
        return;
    }


    updateTransform = (updateTransform !== undefined) ? updateTransform : true;//!updateTransform;

    this.textureBuffer.transform = matrix;

    //TODO not a fan that this is here... it will move!
    this.textureBuffer.activate();

    // setWorld Alpha to ensure that the object is renderer at full opacity
    displayObject.worldAlpha = 1;

    if (updateTransform)
    {

        // reset the matrix of the displatyObject..
        displayObject.worldTransform.identity();

        displayObject.currentBounds = null;

        // Time to update all the children of the displayObject with the new matrix..
        var children = displayObject.children;
        var i, j;

        for (i = 0, j = children.length; i < j; ++i)
        {
            children[i].updateTransform();
        }
    }

    //TODO rename textureBuffer to renderTarget..
    var temp =  this.renderer.filterManager;

    this.renderer.filterManager = this.filterManager;
    this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);

    this.renderer.filterManager = temp;
};


/**
 * Internal method assigned to the `render` property if using a CanvasRenderer.
 *
 * @private
 * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
 * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
 * @param [clear] {boolean} If true the texture will be cleared before the displayObject is drawn
 */
RenderTexture.prototype.renderCanvas = function (displayObject, matrix, clear, updateTransform)
{
    if (!this.valid)
    {
        return;
    }

    updateTransform = !!updateTransform;

    var wt = tempMatrix;

    wt.identity();

    if (matrix)
    {
        wt.append(matrix);
    }

    var cachedWt = displayObject.worldTransform;
    displayObject.worldTransform = wt;

    // setWorld Alpha to ensure that the object is renderer at full opacity
    displayObject.worldAlpha = 1;

    // Time to update all the children of the displayObject with the new matrix..
    var children = displayObject.children;
    var i, j;

    for (i = 0, j = children.length; i < j; ++i)
    {
        children[i].updateTransform();
    }

    if (clear)
    {
        this.textureBuffer.clear();
    }


//    this.textureBuffer.
    var context = this.textureBuffer.context;

    var realResolution = this.renderer.resolution;

    this.renderer.resolution = this.resolution;

    this.renderer.renderDisplayObject(displayObject, context);

    this.renderer.resolution = realResolution;

    if(displayObject.worldTransform === wt)
    {
        // fixes cacheAsBitmap Happening during the above..
        displayObject.worldTransform = cachedWt;
    }

};

/**
 * Destroys this texture
 *
 * @param destroyBase {boolean} Whether to destroy the base texture as well
 */
RenderTexture.prototype.destroy = function ()
{
    Texture.prototype.destroy.call(this, true);

    this.textureBuffer.destroy();

    // destroy the filtermanager..
    if(this.filterManager)
    {
        this.filterManager.destroy();
    }

    this.renderer = null;
};

/**
 * Will return a HTML Image of the texture
 *
 * @return {Image}
 */
RenderTexture.prototype.getImage = function ()
{
    var image = new Image();
    image.src = this.getBase64();
    return image;
};

/**
 * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.
 *
 * @return {string} A base64 encoded string of the texture.
 */
RenderTexture.prototype.getBase64 = function ()
{
    return this.getCanvas().toDataURL();
};

/**
 * Creates a Canvas element, renders this RenderTexture to it and then returns it.
 *
 * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
 */
RenderTexture.prototype.getCanvas = function ()
{
    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;
        var width = this.textureBuffer.size.width;
        var height = this.textureBuffer.size.height;

        var webGLPixels = new Uint8Array(4 * width * height);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        var tempCanvas = new CanvasBuffer(width, height);
        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
        canvasData.data.set(webGLPixels);

        tempCanvas.context.putImageData(canvasData, 0, 0);

        return tempCanvas.canvas;
    }
    else
    {
        return this.textureBuffer.canvas;
    }
};

/**
 * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA order, with integer values between 0 and 255 (included).
 *
 * @return {Uint8ClampedArray}
 */
RenderTexture.prototype.getPixels = function ()
{
    var width, height;

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;
        width = this.textureBuffer.size.width;
        height = this.textureBuffer.size.height;

        var webGLPixels = new Uint8Array(4 * width * height);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return webGLPixels;
    }
    else
    {
        width = this.textureBuffer.canvas.width;
        height = this.textureBuffer.canvas.height;

        return this.textureBuffer.canvas.getContext('2d').getImageData(0, 0, width, height).data;
    }
};

/**
 * Will return a one-dimensional array containing the pixel data of a pixel within the texture in RGBA order, with integer values between 0 and 255 (included).
 *
 * @param x {number} The x coordinate of the pixel to retrieve.
 * @param y {number} The y coordinate of the pixel to retrieve.
 * @return {Uint8ClampedArray}
 */
RenderTexture.prototype.getPixel = function (x, y)
{
    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;

        var webGLPixels = new Uint8Array(4);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return webGLPixels;
    }
    else
    {
        return this.textureBuffer.canvas.getContext('2d').getImageData(x, y, 1, 1).data;
    }
};

},{"../const":16,"../math":26,"../renderers/canvas/utils/CanvasBuffer":38,"../renderers/webgl/managers/FilterManager":47,"../renderers/webgl/utils/RenderTarget":58,"./BaseTexture":63,"./Texture":65}],65:[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    VideoBaseTexture = require('./VideoBaseTexture'),
    TextureUvs = require('./TextureUvs'),
    EventEmitter = require('eventemitter3'),
    math = require('../math'),
    utils = require('../utils');

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
 *
 * You can directly create a texture from an image and then reuse it multiple times like this :
 *
 * ```js
 * var texture = PIXI.Texture.fromImage('assets/image.png');
 * var sprite1 = new PIXI.Sprite(texture);
 * var sprite2 = new PIXI.Sprite(texture);
 * ```
 *
 * @class
 * @memberof PIXI
 * @param baseTexture {PIXI.BaseTexture} The base texture source to create the texture from
 * @param [frame] {PIXI.Rectangle} The rectangle frame of the texture to show
 * @param [crop] {PIXI.Rectangle} The area of original texture
 * @param [trim] {PIXI.Rectangle} Trimmed texture rectangle
 * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )
 */
function Texture(baseTexture, frame, crop, trim, rotate)
{
    EventEmitter.call(this);

    /**
     * Does this Texture have any frame data assigned to it?
     *
     * @member {boolean}
     */
    this.noFrame = false;

    if (!frame)
    {
        this.noFrame = true;
        frame = new math.Rectangle(0, 0, 1, 1);
    }

    if (baseTexture instanceof Texture)
    {
        baseTexture = baseTexture.baseTexture;
    }

    /**
     * The base texture that this texture uses.
     *
     * @member {PIXI.BaseTexture}
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._frame = frame;

    /**
     * The texture trim data.
     *
     * @member {PIXI.Rectangle}
     */
    this.trim = trim;

    /**
     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
     *
     * @member {boolean}
     */
    this.valid = false;

    /**
     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
     *
     * @member {boolean}
     */
    this.requiresUpdate = false;

    /**
     * The WebGL UV data cache.
     *
     * @member {PIXI.TextureUvs}
     * @private
     */
    this._uvs = null;

    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    this.width = 0;

    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    this.height = 0;

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @member {PIXI.Rectangle}
     */
    this.crop = crop || frame;//new math.Rectangle(0, 0, 1, 1);

    /**
     * Indicates whether the texture should be rotated by 90 degrees
     *
     * @private
     * @member {boolean}
     */
    this.rotate = !!rotate;

    if (baseTexture.hasLoaded)
    {
        if (this.noFrame)
        {
            frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);

            // if there is no frame we should monitor for any base texture changes..
            baseTexture.on('update', this.onBaseTextureUpdated, this);
        }
        this.frame = frame;
    }
    else
    {
        baseTexture.once('loaded', this.onBaseTextureLoaded, this);
    }

    /**
     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
     *
     * @event update
     * @memberof PIXI.Texture#
     * @protected
     */
}

Texture.prototype = Object.create(EventEmitter.prototype);
Texture.prototype.constructor = Texture;
module.exports = Texture;

Object.defineProperties(Texture.prototype, {
    /**
     * The frame specifies the region of the base texture that this texture uses.
     *
     * @member {PIXI.Rectangle}
     * @memberof PIXI.Texture#
     */
    frame: {
        get: function ()
        {
            return this._frame;
        },
        set: function (frame)
        {
            this._frame = frame;

            this.noFrame = false;

            this.width = frame.width;
            this.height = frame.height;

            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
            {
                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
            }

            //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;

            if (this.trim)
            {
                this.width = this.trim.width;
                this.height = this.trim.height;
                this._frame.width = this.trim.width;
                this._frame.height = this.trim.height;
            }
            else
            {
                this.crop = frame;
            }

            if (this.valid)
            {
                this._updateUvs();
            }
        }
    }
});

/**
 * Updates this texture on the gpu.
 *
 */
Texture.prototype.update = function ()
{
    this.baseTexture.update();
};

/**
 * Called when the base texture is loaded
 *
 * @private
 */
Texture.prototype.onBaseTextureLoaded = function (baseTexture)
{
    // TODO this code looks confusing.. boo to abusing getters and setterss!
    if (this.noFrame)
    {
        this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
    }
    else
    {
        this.frame = this._frame;
    }

    this.emit('update', this);
};

/**
 * Called when the base texture is updated
 *
 * @private
 */
Texture.prototype.onBaseTextureUpdated = function (baseTexture)
{
    this._frame.width = baseTexture.width;
    this._frame.height = baseTexture.height;

    this.emit('update', this);
};

/**
 * Destroys this texture
 *
 * @param [destroyBase=false] {boolean} Whether to destroy the base texture as well
 */
Texture.prototype.destroy = function (destroyBase)
{
    if (this.baseTexture)
    {
        if (destroyBase)
        {
            this.baseTexture.destroy();
        }

        this.baseTexture.off('update', this.onBaseTextureUpdated, this);
        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);

        this.baseTexture = null;
    }

    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.crop = null;

    this.valid = false;

    this.off('dispose', this.dispose, this);
    this.off('update', this.update, this);
};

/**
 * Creates a new texture object that acts the same as this one.
 *
 * @return {PIXI.Texture}
 */
Texture.prototype.clone = function ()
{
    return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);
};

/**
 * Updates the internal WebGL UV cache.
 *
 * @private
 */
Texture.prototype._updateUvs = function ()
{
    if (!this._uvs)
    {
        this._uvs = new TextureUvs();
    }

    this._uvs.set(this.crop, this.baseTexture, this.rotate);
};

/**
 * Helper function that creates a Texture object from the given image url.
 * If the image is not in the texture cache it will be  created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param crossorigin {boolean} Whether requests should be treated as crossorigin
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} The newly created texture
 */
Texture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var texture = utils.TextureCache[imageUrl];

    if (!texture)
    {
        texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
        utils.TextureCache[imageUrl] = texture;
    }

    return texture;
};

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @return {PIXI.Texture} The newly created texture
 */
Texture.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
    }

    return texture;
};

/**
 * Helper function that creates a new Texture based on the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture}
 */
Texture.fromCanvas = function (canvas, scaleMode)
{
    return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));
};

/**
 * Helper function that creates a new Texture based on the given video element.
 *
 * @static
 * @param video {HTMLVideoElement}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} A Texture
 */
Texture.fromVideo = function (video, scaleMode)
{
    if (typeof video === 'string')
    {
        return Texture.fromVideoUrl(video, scaleMode);
    }
    else
    {
        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));
    }
};

/**
 * Helper function that creates a new Texture based on the video url.
 *
 * @static
 * @param videoUrl {string}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} A Texture
 */
Texture.fromVideoUrl = function (videoUrl, scaleMode)
{
    return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));
};

/**
 * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.
 *
 * @static
 * @param texture {PIXI.Texture} The Texture to add to the cache.
 * @param id {string} The id that the texture will be stored against.
 */
Texture.addTextureToCache = function (texture, id)
{
    utils.TextureCache[id] = texture;
};

/**
 * Remove a texture from the global utils.TextureCache.
 *
 * @static
 * @param id {string} The id of the texture to be removed
 * @return {PIXI.Texture} The texture that was removed
 */
Texture.removeTextureFromCache = function (id)
{
    var texture = utils.TextureCache[id];

    delete utils.TextureCache[id];
    delete utils.BaseTextureCache[id];

    return texture;
};

/**
 * An empty texture, used often to not have to create multiple empty textures.
 *
 * @static
 * @constant
 */
Texture.EMPTY = new Texture(new BaseTexture());

},{"../math":26,"../utils":70,"./BaseTexture":63,"./TextureUvs":66,"./VideoBaseTexture":67,"eventemitter3":10}],66:[function(require,module,exports){

/**
 * A standard object to store the Uvs of a texture
 *
 * @class
 * @private
 * @memberof PIXI
 */
function TextureUvs()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 1;
    this.y1 = 0;

    this.x2 = 1;
    this.y2 = 1;

    this.x3 = 0;
    this.y3 = 1;
}

module.exports = TextureUvs;

/**
 * Sets the texture Uvs based on the given frame information
 * @param frame {PIXI.Rectangle}
 * @param baseFrame {PIXI.Rectangle}
 * @param rotate {boolean} Whether or not the frame is rotated
 * @private
 */
TextureUvs.prototype.set = function (frame, baseFrame, rotate)
{
    var tw = baseFrame.width;
    var th = baseFrame.height;

    if(rotate)
    {
        this.x0 = (frame.x + frame.height) / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.height) / tw;
        this.y1 = (frame.y + frame.width) / th;

        this.x2 = frame.x / tw;
        this.y2 = (frame.y + frame.width) / th;

        this.x3 = frame.x / tw;
        this.y3 = frame.y / th;
    }
    else
    {

        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;

        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;

        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
    }
};

},{}],67:[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    utils = require('../utils');

/**
 * A texture of a [playing] Video.
 *
 * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
 *
 * This can be used in several ways, such as:
 *
 * ```js
 * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
 *
 * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
 *
 * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
 *
 * var texture = PIXI.VideoBaseTexture.fromUrls([
 *     { src: '/video.webm', mime: 'video/webm' },
 *     { src: '/video.mp4', mime: 'video/mp4' }
 * ]);
 * ```
 *
 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 * @param source {HTMLVideoElement}
 * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values
 */
function VideoBaseTexture(source, scaleMode)
{
    if (!source)
    {
        throw new Error('No video source element specified.');
    }

    // hook in here to check if video is already available.
    // BaseTexture looks for a source.complete boolean, plus width & height.

    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height)
    {
        source.complete = true;
    }

    BaseTexture.call(this, source, scaleMode);

    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     * @default true
     */
    this.autoUpdate = false;

    this._onUpdate = this._onUpdate.bind(this);
    this._onCanPlay = this._onCanPlay.bind(this);

    if (!source.complete)
    {
        source.addEventListener('canplay', this._onCanPlay);
        source.addEventListener('canplaythrough', this._onCanPlay);

        // started playing..
        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));
    }

    this.__loaded = false;
}

VideoBaseTexture.prototype = Object.create(BaseTexture.prototype);
VideoBaseTexture.prototype.constructor = VideoBaseTexture;
module.exports = VideoBaseTexture;

/**
 * The internal update loop of the video base texture, only runs when autoUpdate is set to true
 *
 * @private
 */
VideoBaseTexture.prototype._onUpdate = function ()
{
    if (this.autoUpdate)
    {
        window.requestAnimationFrame(this._onUpdate);
        this.update();
    }
};

/**
 * Runs the update loop when the video is ready to play
 *
 * @private
 */
VideoBaseTexture.prototype._onPlayStart = function ()
{
    if (!this.autoUpdate)
    {
        window.requestAnimationFrame(this._onUpdate);
        this.autoUpdate = true;
    }
};

/**
 * Fired when a pause event is triggered, stops the update loop
 *
 * @private
 */
VideoBaseTexture.prototype._onPlayStop = function ()
{
    this.autoUpdate = false;
};

/**
 * Fired when the video is loaded and ready to play
 *
 * @private
 */
VideoBaseTexture.prototype._onCanPlay = function ()
{
    this.hasLoaded = true;

    if (this.source)
    {
        this.source.removeEventListener('canplay', this._onCanPlay);
        this.source.removeEventListener('canplaythrough', this._onCanPlay);

        this.width = this.source.videoWidth;
        this.height = this.source.videoHeight;

        this.source.play();

        // prevent multiple loaded dispatches..
        if (!this.__loaded)
        {
            this.__loaded = true;
            this.emit('loaded', this);
        }
    }
};

/**
 * Destroys this texture
 *
 */
VideoBaseTexture.prototype.destroy = function ()
{
    if (this.source && this.source._pixiId)
    {
        delete utils.BaseTextureCache[ this.source._pixiId ];
        delete this.source._pixiId;
    }

    BaseTexture.prototype.destroy.call(this);
};

/**
 * Mimic Pixi BaseTexture.from.... method.
 *
 * @static
 * @param video {HTMLVideoElement}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.VideoBaseTexture}
 */
VideoBaseTexture.fromVideo = function (video, scaleMode)
{
    if (!video._pixiId)
    {
        video._pixiId = 'video_' + utils.uid();
    }

    var baseTexture = utils.BaseTextureCache[video._pixiId];

    if (!baseTexture)
    {
        baseTexture = new VideoBaseTexture(video, scaleMode);
        utils.BaseTextureCache[ video._pixiId ] = baseTexture;
    }

    return baseTexture;
};

/**
 * Helper function that creates a new BaseTexture based on the given video element.
 * This BaseTexture can then be used to create a texture
 *
 * @static
 * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.
 * @param [videoSrc.src] {string} One of the source urls for the video
 * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified
 *  the url's extension will be used as the second part of the mime type.
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.VideoBaseTexture}
 */
VideoBaseTexture.fromUrl = function (videoSrc, scaleMode)
{
    var video = document.createElement('video');

    // array of objects or strings
    if (Array.isArray(videoSrc))
    {
        for (var i = 0; i < videoSrc.length; ++i)
        {
            video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
        }
    }
    // single object or string
    else
    {
        video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
    }

    video.load();
    video.play();

    return VideoBaseTexture.fromVideo(video, scaleMode);
};

VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

function createSource(path, type)
{
    if (!type)
    {
        type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = path;
    source.type = type;

    return source;
}

},{"../utils":70,"./BaseTexture":63}],68:[function(require,module,exports){
var CONST = require('../const'),
    EventEmitter = require('eventemitter3'),
    // Internal event used by composed emitter
    TICK = 'tick';

/**
 * A Ticker class that runs an update loop that other objects listen to.
 * This class is composed around an EventEmitter object to add listeners
 * meant for execution on the next requested animation frame.
 * Animation frames are requested only when necessary,
 * e.g. When the ticker is started and the emitter has listeners.
 *
 * @class
 * @memberof PIXI.ticker
 */
function Ticker()
{
    var _this = this;

    /**
     * Internal tick method bound to ticker instance.
     * This is because in early 2015, Function.bind
     * is still 60% slower in high performance scenarios.
     * Also separating frame requests from update method
     * so listeners may be called at any time and with
     * any animation API, just invoke ticker.update(time).
     *
     * @private
     */
    this._tick = function _tick(time) {

        _this._requestId = null;

        if (_this.started)
        {
            // Invoke listeners now
            _this.update(time);
            // Listener side effects may have modified ticker state.
            if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true))
            {
                _this._requestId = requestAnimationFrame(_this._tick);
            }
        }
    };

    /**
     * Internal emitter used to fire 'tick' event
     * @private
     */
    this._emitter = new EventEmitter();

    /**
     * Internal current frame request ID
     * @private
     */
    this._requestId = null;

    /**
     * Internal value managed by minFPS property setter and getter.
     * This is the maximum allowed milliseconds between updates.
     * @private
     */
    this._maxElapsedMS = 100;

    /**
     * Whether or not this ticker should invoke the method
     * {@link PIXI.ticker.Ticker#start} automatically
     * when a listener is added.
     *
     * @member {boolean}
     * @default false
     */
    this.autoStart = false;

    /**
     * Scalar time value from last frame to this frame.
     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
     * and is scaled with {@link PIXI.ticker.Ticker#speed}.
     * **Note:** The cap may be exceeded by scaling.
     *
     * @member {number}
     * @default 1
     */
    this.deltaTime = 1;

    /**
     * Time elapsed in milliseconds from last frame to this frame.
     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
     * is based, this value is neither capped nor scaled.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 µs.
     *
     * @member {DOMHighResTimeStamp|number}
     * @default 1 / TARGET_FPMS
     */
    this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time

    /**
     * The last time {@link PIXI.ticker.Ticker#update} was invoked.
     * This value is also reset internally outside of invoking
     * update, but only when a new animation frame is requested.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 µs.
     *
     * @member {DOMHighResTimeStamp|number}
     * @default 0
     */
    this.lastTime = 0;

    /**
     * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
     * @example
     * // Scales ticker.deltaTime to what would be
     * // the equivalent of approximately 120 FPS
     * ticker.speed = 2;
     *
     * @member {number}
     * @default 1
     */
    this.speed = 1;

    /**
     * Whether or not this ticker has been started.
     * `true` if {@link PIXI.ticker.Ticker#start} has been called.
     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
     * While `false`, this value may change to `true` in the
     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
     * and a listener is added.
     *
     * @member {boolean}
     * @default false
     */
    this.started = false;
}

Object.defineProperties(Ticker.prototype, {
    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.ticker.Ticker#speed}, which is specific
     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @readonly
     */
    FPS: {
        get: function()
        {
            return 1000 / this.elapsedMS;
        }
    },

    /**
     * Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.ticker.Ticker#update}.
     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.TARGET_FPMS * 1000`.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @default 10
     */
    minFPS: {
        get: function()
        {
            return 1000 / this._maxElapsedMS;
        },
        set: function(fps)
        {
            // Clamp: 0 to TARGET_FPMS
            var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);
            this._maxElapsedMS = 1 / minFPMS;
        }
    }
});

/**
 * Conditionally requests a new animation frame.
 * If a frame has not already been requested, and if the internal
 * emitter has listeners, a new frame is requested.
 *
 * @private
 */
Ticker.prototype._requestIfNeeded = function _requestIfNeeded()
{
    if (this._requestId === null && this._emitter.listeners(TICK, true))
    {
        // ensure callbacks get correct delta
        this.lastTime = performance.now();
        this._requestId = requestAnimationFrame(this._tick);
    }
};

/**
 * Conditionally cancels a pending animation frame.
 *
 * @private
 */
Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded()
{
    if (this._requestId !== null)
    {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
    }
};

/**
 * Conditionally requests a new animation frame.
 * If the ticker has been started it checks if a frame has not already
 * been requested, and if the internal emitter has listeners. If these
 * conditions are met, a new frame is requested. If the ticker has not
 * been started, but autoStart is `true`, then the ticker starts now,
 * and continues with the previous conditions to request a new frame.
 *
 * @private
 */
Ticker.prototype._startIfPossible = function _startIfPossible()
{
    if (this.started)
    {
        this._requestIfNeeded();
    }
    else if (this.autoStart)
    {
        this.start();
    }
};

/**
 * Calls {@link module:eventemitter3.EventEmitter#on} internally for the
 * internal 'tick' event. It checks if the emitter has listeners,
 * and if so it requests a new animation frame at this point.
 *
 * @param fn {Function} The listener function to be added for updates
 * @param [context] {Function} The listener context
 * @returns {PIXI.ticker.Ticker} this
 */
Ticker.prototype.add = function add(fn, context)
{
    this._emitter.on(TICK, fn, context);

    this._startIfPossible();

    return this;
};

/**
 * Calls {@link module:eventemitter3.EventEmitter#once} internally for the
 * internal 'tick' event. It checks if the emitter has listeners,
 * and if so it requests a new animation frame at this point.
 *
 * @param fn {Function} The listener function to be added for one update
 * @param [context] {Function} The listener context
 * @returns {PIXI.ticker.Ticker} this
 */
Ticker.prototype.addOnce = function addOnce(fn, context)
{
    this._emitter.once(TICK, fn, context);

    this._startIfPossible();

    return this;
};

/**
 * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.
 * It checks if the emitter has listeners for 'tick' event.
 * If it does, then it cancels the animation frame.
 *
 * @param [fn] {Function} The listener function to be removed
 * @param [context] {Function} The listener context to be removed
 * @returns {PIXI.ticker.Ticker} this
 */
Ticker.prototype.remove = function remove(fn, context)
{
    this._emitter.off(TICK, fn, context);

    if (!this._emitter.listeners(TICK, true))
    {
        this._cancelIfNeeded();
    }

    return this;
};

/**
 * Starts the ticker. If the ticker has listeners
 * a new animation frame is requested at this point.
 */
Ticker.prototype.start = function start()
{
    if (!this.started)
    {
        this.started = true;
        this._requestIfNeeded();
    }
};

/**
 * Stops the ticker. If the ticker has requested
 * an animation frame it is canceled at this point.
 */
Ticker.prototype.stop = function stop()
{
    if (this.started)
    {
        this.started = false;
        this._cancelIfNeeded();
    }
};

/**
 * Triggers an update. An update entails setting the
 * current {@link PIXI.ticker.Ticker#elapsedMS},
 * the current {@link PIXI.ticker.Ticker#deltaTime},
 * invoking all listeners with current deltaTime,
 * and then finally setting {@link PIXI.ticker.Ticker#lastTime}
 * with the value of currentTime that was provided.
 * This method will be called automatically by animation
 * frame callbacks if the ticker instance has been started
 * and listeners are added.
 *
 * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution
 */
Ticker.prototype.update = function update(currentTime)
{
    var elapsedMS;

    // Allow calling update directly with default currentTime.
    currentTime = currentTime || performance.now();
    // Save uncapped elapsedMS for measurement
    elapsedMS = this.elapsedMS = currentTime - this.lastTime;

    // cap the milliseconds elapsed used for deltaTime
    if (elapsedMS > this._maxElapsedMS)
    {
        elapsedMS = this._maxElapsedMS;
    }

    this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed;

    // Invoke listeners added to internal emitter
    this._emitter.emit(TICK, this.deltaTime);

    this.lastTime = currentTime;
};

module.exports = Ticker;

},{"../const":16,"eventemitter3":10}],69:[function(require,module,exports){
var Ticker = require('./Ticker');

/**
 * The shared ticker instance used by {@link PIXI.extras.MovieClip}.
 * and by {@link PIXI.interaction.InteractionManager}.
 * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`
 * for this instance. Please follow the examples for usage, including
 * how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * var ticker = PIXI.ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * var renderer = PIXI.autoDetectRenderer(800, 600);
 * var stage = new PIXI.Container();
 * var interactionManager = PIXI.interaction.InteractionManager(renderer);
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 *     renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 *     ticker.update(time);
 *     renderer.render(stage);
 *     requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @type {PIXI.ticker.Ticker}
 * @memberof PIXI.ticker
 */
var shared = new Ticker();
shared.autoStart = true;

/**
 * @namespace PIXI.ticker
 */
module.exports = {
    shared: shared,
    Ticker: Ticker
};

},{"./Ticker":68}],70:[function(require,module,exports){
var CONST = require('../const');

/**
 * @namespace PIXI.utils
 */
var utils = module.exports = {
    _uid: 0,
    _saidHello: false,

    EventEmitter:   require('eventemitter3'),
    pluginTarget:   require('./pluginTarget'),
    async:          require('async'),

    /**
     * Gets the next unique identifier
     *
     * @return {number} The next unique identifier to use.
     */
    uid: function ()
    {
        return ++utils._uid;
    },

    /**
     * Converts a hex color number to an [R, G, B] array
     *
     * @param hex {number}
     * @param  {number[]} [out=[]]
     * @return {number[]} An array representing the [R, G, B] of the color.
     */
    hex2rgb: function (hex, out)
    {
        out = out || [];

        out[0] = (hex >> 16 & 0xFF) / 255;
        out[1] = (hex >> 8 & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;

        return out;
    },

    /**
     * Converts a hex color number to a string.
     *
     * @param hex {number}
     * @return {string} The string color.
     */
    hex2string: function (hex)
    {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;

        return '#' + hex;
    },

    /**
     * Converts a color as an [R, G, B] array to a hex number
     *
     * @param rgb {number[]}
     * @return {number} The color number
     */
    rgb2hex: function (rgb)
    {
        return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
    },

    /**
     * Checks whether the Canvas BlendModes are supported by the current browser
     *
     * @return {boolean} whether they are supported
     */
    canUseNewCanvasBlendModes: function ()
    {
        if (typeof document === 'undefined')
        {
            return false;
        }

        var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
        var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

        var magenta = new Image();
        magenta.src = pngHead + 'AP804Oa6' + pngEnd;

        var yellow = new Image();
        yellow.src = pngHead + '/wCKxvRF' + pngEnd;

        var canvas = document.createElement('canvas');
        canvas.width = 6;
        canvas.height = 1;

        var context = canvas.getContext('2d');
        context.globalCompositeOperation = 'multiply';
        context.drawImage(magenta, 0, 0);
        context.drawImage(yellow, 2, 0);

        var data = context.getImageData(2,0,1,1).data;

        return (data[0] === 255 && data[1] === 0 && data[2] === 0);
    },

    /**
     * Given a number, this function returns the closest number that is a power of two
     * this function is taken from Starling Framework as its pretty neat ;)
     *
     * @param number {number}
     * @return {number} the closest number that is a power of two
     */
    getNextPowerOfTwo: function (number)
    {
        // see: http://en.wikipedia.org/wiki/Power_of_two#Fast_algorithm_to_check_if_a_positive_number_is_a_power_of_two
        if (number > 0 && (number & (number - 1)) === 0)
        {
            return number;
        }
        else
        {
            var result = 1;

            while (result < number)
            {
                result <<= 1;
            }

            return result;
        }
    },

    /**
     * checks if the given width and height make a power of two rectangle
     *
     * @param width {number}
     * @param height {number}
     * @return {boolean}
     */
    isPowerOfTwo: function (width, height)
    {
        return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
    },

    /**
     * get the resolution of an asset by looking for the prefix
     * used by spritesheets and image urls
     *
     * @param url {string} the image path
     * @return {number}
     */
    getResolutionOfUrl: function (url)
    {
        var resolution = CONST.RETINA_PREFIX.exec(url);

        if (resolution)
        {
           return parseFloat(resolution[1]);
        }

        return 1;
    },

    /**
     * Logs out the version and renderer information for this running instance of PIXI.
     * If you don't want to see this message you can set `PIXI.utils._saidHello = true;`
     * so the library thinks it already said it. Keep in mind that doing that will forever
     * makes you a jerk face.
     *
     * @param {string} type - The string renderer type to log.
     * @constant
     * @static
     */
    sayHello: function (type)
    {
        if (utils._saidHello)
        {
            return;
        }

        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1)
        {
            var args = [
                '\n %c %c %c Pixi.js ' + CONST.VERSION + ' - ✰ ' + type + ' ✰  %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n',
                'background: #ff66a5; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'color: #ff66a5; background: #030307; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'background: #ffc3dc; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;'
            ];

            window.console.log.apply(console, args); //jshint ignore:line
        }
        else if (window.console)
        {
            window.console.log('Pixi.js ' + CONST.VERSION + ' - ' + type + ' - http://www.pixijs.com/'); //jshint ignore:line
        }

        utils._saidHello = true;
    },

    /**
     * Helper for checking for webgl support
     *
     * @return {boolean}
     */
    isWebGLSupported: function ()
    {
        var contextOptions = { stencil: true };
        try
        {
            if (!window.WebGLRenderingContext)
            {
                return false;
            }

            var canvas = document.createElement('canvas'),
                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);

            return !!(gl && gl.getContextAttributes().stencil);
        }
        catch (e)
        {
            return false;
        }
    },

    /**
     * Returns sign of number
     *
     * @param n {number}
     * @returns {number} 0 if n is 0, -1 if n is negative, 1 if n i positive
     */
    sign: function (n)
    {
        return n ? (n < 0 ? -1 : 1) : 0;
    },

    /**
     * removeItems
     *
     * @param {array} arr The target array
     * @param {number} startIdx The index to begin removing from (inclusive)
     * @param {number} removeCount How many items to remove
     */
    removeItems: function (arr, startIdx, removeCount)
    {
        var length = arr.length;

        if (startIdx >= length || removeCount === 0)
        {
            return;
        }

        removeCount = (startIdx+removeCount > length ? length-startIdx : removeCount);
        for (var i = startIdx, len = length-removeCount; i < len; ++i)
        {
            arr[i] = arr[i + removeCount];
        }

        arr.length = len;
    },

    /**
     * @todo Describe property usage
     * @private
     */
    TextureCache: {},

    /**
     * @todo Describe property usage
     * @private
     */
    BaseTextureCache: {}
};

},{"../const":16,"./pluginTarget":71,"async":1,"eventemitter3":10}],71:[function(require,module,exports){
/**
 * Mixins functionality to make an object have "plugins".
 *
 * @mixin
 * @memberof PIXI.utils
 * @param obj {object} The object to mix into.
 * @example
 *      function MyObject() {}
 *
 *      pluginTarget.mixin(MyObject);
 */
function pluginTarget(obj)
{
    obj.__plugins = {};

    /**
     * Adds a plugin to an object
     *
     * @param pluginName {string} The events that should be listed.
     * @param ctor {Function} The constructor function for the plugin.
     */
    obj.registerPlugin = function (pluginName, ctor)
    {
        obj.__plugins[pluginName] = ctor;
    };

    /**
     * Instantiates all the plugins of this object
     *
     */
    obj.prototype.initPlugins = function ()
    {
        this.plugins = this.plugins || {};

        for (var o in obj.__plugins)
        {
            this.plugins[o] = new (obj.__plugins[o])(this);
        }
    };

    /**
     * Removes all the plugins of this object
     *
     */
    obj.prototype.destroyPlugins = function ()
    {
        for (var o in this.plugins)
        {
            this.plugins[o].destroy();
            this.plugins[o] = null;
        }

        this.plugins = null;
    };
}


module.exports = {
    /**
     * Mixes in the properties of the pluginTarget into another object
     *
     * @param object {object} The obj to mix into
     */
    mixin: function mixin(obj)
    {
        pluginTarget(obj);
    }
};

},{}],72:[function(require,module,exports){
/*global console */
var core = require('./core'),
    mesh = require('./mesh'),
    extras = require('./extras'),
    filters = require('./filters');

/**
 * @class
 * @private
 * @name SpriteBatch
 * @memberof PIXI
 * @see PIXI.ParticleContainer
 * @throws {ReferenceError} SpriteBatch does not exist any more, please use the new ParticleContainer instead.
 * @deprecated since version 3.0.0
 */
core.SpriteBatch = function()
{
    throw new ReferenceError('SpriteBatch does not exist any more, please use the new ParticleContainer instead.');
};

/**
 * @class
 * @private
 * @name AssetLoader
 * @memberof PIXI
 * @see PIXI.loaders.Loader
 * @throws {ReferenceError} The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.
 * @deprecated since version 3.0.0
 */
core.AssetLoader = function()
{
    throw new ReferenceError('The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.');
};

Object.defineProperties(core, {

    /**
     * @class
     * @private
     * @name Stage
     * @memberof PIXI
     * @see PIXI.Container
     * @deprecated since version 3.0.0
     */
    Stage: {
        get: function()
        {
            console.warn('You do not need to use a PIXI Stage any more, you can simply render any container.');
            return core.Container;
        }
    },

    /**
     * @class
     * @private
     * @name DisplayObjectContainer
     * @memberof PIXI
     * @see PIXI.Container
     * @deprecated since version 3.0.0
     */
    DisplayObjectContainer: {
        get: function()
        {
            console.warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.');
            return core.Container;
        }
    },

    /**
     * @class
     * @private
     * @name Strip
     * @memberof PIXI
     * @see PIXI.mesh.Mesh
     * @deprecated since version 3.0.0
     */
    Strip: {
        get: function()
        {
            console.warn('The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.');
            return mesh.Mesh;
        }
    },

    /**
     * @class
     * @private
     * @name Rope
     * @memberof PIXI
     * @see PIXI.mesh.Rope
     * @deprecated since version 3.0.0
     */
    Rope: {
        get: function()
        {
            console.warn('The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.');
            return mesh.Rope;
        }
    },

    /**
     * @class
     * @private
     * @name MovieClip
     * @memberof PIXI
     * @see PIXI.extras.MovieClip
     * @deprecated since version 3.0.0
     */
    MovieClip: {
        get: function()
        {
            console.warn('The MovieClip class has been moved to extras.MovieClip, please use extras.MovieClip from now on.');
            return extras.MovieClip;
        }
    },

    /**
     * @class
     * @private
     * @name TilingSprite
     * @memberof PIXI
     * @see PIXI.extras.TilingSprite
     * @deprecated since version 3.0.0
     */
    TilingSprite: {
        get: function()
        {
            console.warn('The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on.');
            return extras.TilingSprite;
        }
    },

    /**
     * @class
     * @private
     * @name BitmapText
     * @memberof PIXI
     * @see PIXI.extras.BitmapText
     * @deprecated since version 3.0.0
     */
    BitmapText: {
        get: function()
        {
            console.warn('The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on.');
            return extras.BitmapText;
        }
    },

    /**
     * @class
     * @private
     * @name blendModes
     * @memberof PIXI
     * @see PIXI.BLEND_MODES
     * @deprecated since version 3.0.0
     */
    blendModes: {
        get: function()
        {
            console.warn('The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.');
            return core.BLEND_MODES;
        }
    },

    /**
     * @class
     * @private
     * @name scaleModes
     * @memberof PIXI
     * @see PIXI.SCALE_MODES
     * @deprecated since version 3.0.0
     */
    scaleModes: {
        get: function()
        {
            console.warn('The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.');
            return core.SCALE_MODES;
        }
    },

    /**
     * @class
     * @private
     * @name BaseTextureCache
     * @memberof PIXI
     * @see PIXI.utils.BaseTextureCache
     * @deprecated since version 3.0.0
     */
    BaseTextureCache: {
        get: function ()
        {
            console.warn('The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on.');
            return core.utils.BaseTextureCache;
        }
    },

    /**
     * @class
     * @private
     * @name TextureCache
     * @memberof PIXI
     * @see PIXI.utils.TextureCache
     * @deprecated since version 3.0.0
     */
    TextureCache: {
        get: function ()
        {
            console.warn('The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on.');
            return core.utils.TextureCache;
        }
    },

    /**
     * @namespace
     * @private
     * @name math
     * @memberof PIXI
     * @see PIXI
     * @deprecated since version 3.0.6
     */
    math: {
        get: function ()
        {
            console.warn('The math namespace is deprecated, please access members already accessible on PIXI.');
            return core;
        }
    }
});

/**
 * @method
 * @private
 * @name PIXI.Sprite#setTexture
 * @see PIXI.Sprite#texture
 * @deprecated since version 3.0.0
 */
core.Sprite.prototype.setTexture = function(texture)
{
    this.texture = texture;
    console.warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;');
};

/**
 * @method
 * @name PIXI.extras.BitmapText#setText
 * @see PIXI.extras.BitmapText#text
 * @deprecated since version 3.0.0
 */
extras.BitmapText.prototype.setText = function(text)
{
    this.text = text;
    console.warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \'my text\';');
};

/**
 * @method
 * @name PIXI.Text#setText
 * @see PIXI.Text#text
 * @deprecated since version 3.0.0
 */
core.Text.prototype.setText = function(text)
{
    this.text = text;
    console.warn('setText is now deprecated, please use the text property, e.g : myText.text = \'my text\';');
};

/**
 * @method
 * @name PIXI.Text#setStyle
 * @see PIXI.Text#style
 * @deprecated since version 3.0.0
 */
core.Text.prototype.setStyle = function(style)
{
    this.style = style;
    console.warn('setStyle is now deprecated, please use the style property, e.g : myText.style = style;');
};

/**
 * @method
 * @name PIXI.Texture#setFrame
 * @see PIXI.Texture#setFrame
 * @deprecated since version 3.0.0
 */
core.Texture.prototype.setFrame = function(frame)
{
    this.frame = frame;
    console.warn('setFrame is now deprecated, please use the frame property, e.g : myTexture.frame = frame;');
};

Object.defineProperties(filters, {

    /**
     * @class
     * @private
     * @name PIXI.filters.AbstractFilter
     * @see PIXI.AbstractFilter
     * @deprecated since version 3.0.6
     */
    AbstractFilter: {
        get: function()
        {
            console.warn('filters.AbstractFilter is an undocumented alias, please use AbstractFilter from now on.');
            return core.AbstractFilter;
        }
    },

    /**
     * @class
     * @private
     * @name PIXI.filters.FXAAFilter
     * @see PIXI.FXAAFilter
     * @deprecated since version 3.0.6
     */
    FXAAFilter: {
        get: function()
        {
            console.warn('filters.FXAAFilter is an undocumented alias, please use FXAAFilter from now on.');
            return core.FXAAFilter;
        }
    },

    /**
     * @class
     * @private
     * @name PIXI.filters.SpriteMaskFilter
     * @see PIXI.SpriteMaskFilter
     * @deprecated since version 3.0.6
     */
    SpriteMaskFilter: {
        get: function()
        {
            console.warn('filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.');
            return core.SpriteMaskFilter;
        }
    }
});

/**
 * @method
 * @name PIXI.utils.uuid
 * @see PIXI.utils.uid
 * @deprecated since version 3.0.6
 */
core.utils.uuid = function ()
{
    console.warn('utils.uuid() is deprecated, please use utils.uid() from now on.');
    return core.utils.uid();
};

},{"./core":23,"./extras":79,"./filters":96,"./mesh":121}],73:[function(require,module,exports){
var core = require('../core');

/**
 * A BitmapText object will create a line or multiple lines of text using bitmap font. To
 * split a line you can use '\n', '\r' or '\r\n' in your string. You can generate the fnt files using:
 *
 * A BitmapText can only be created when the font is loaded
 *
 * ```js
 * // in this case the font is in a file called 'desyrel.fnt'
 * var bitmapText = new PIXI.extras.BitmapText("text using a fancy font!", {font: "35px Desyrel", align: "right"});
 * ```
 *
 *
 * http://www.angelcode.com/products/bmfont/ for windows or
 * http://www.bmglyph.com/ for mac.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.extras
 * @param text {string} The copy that you would like the text to display
 * @param style {object} The style parameters
 * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form
 *      "24px FontName" or "FontName" or as an object with explicit name/size properties.
 * @param [style.font.name] {string} The bitmap font id
 * @param [style.font.size] {number} The size of the font in pixels, e.g. 24
 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect
 *      single line text
 * @param [style.tint=0xFFFFFF] {number} The tint color
 */
function BitmapText(text, style)
{
    core.Container.call(this);

    style = style || {};

    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @member {number}
     * @readOnly
     */
    this.textWidth = 0;

    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @member {number}
     * @readOnly
     */
    this.textHeight = 0;

    /**
     * Private tracker for the letter sprite pool.
     *
     * @member {PIXI.Sprite[]}
     * @private
     */
    this._glyphs = [];

    /**
     * Private tracker for the current style.
     *
     * @member {object}
     * @private
     */
    this._font = {
        tint: style.tint !== undefined ? style.tint : 0xFFFFFF,
        align: style.align || 'left',
        name: null,
        size: 0
    };

    /**
     * Private tracker for the current font.
     *
     * @member {object}
     * @private
     */
    this.font = style.font; // run font setter

    /**
     * Private tracker for the current text.
     *
     * @member {string}
     * @private
     */
    this._text = text;

    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting value to 0
     *
     * @member {number}
     */
    this.maxWidth = 0;

    /**
     * The max line height. This is useful when trying to use the total height of the Text, ie: when trying to vertically align.
     *
     * @member {number}
     */
    this.maxLineHeight = 0;

    /**
     * The dirty state of this object.
     *
     * @member {boolean}
     */
    this.dirty = false;

    this.updateText();
}

// constructor
BitmapText.prototype = Object.create(core.Container.prototype);
BitmapText.prototype.constructor = BitmapText;
module.exports = BitmapText;

Object.defineProperties(BitmapText.prototype, {
    /**
     * The tint of the BitmapText object
     *
     * @member {number}
     * @memberof PIXI.extras.BitmapText#
     */
    tint: {
        get: function ()
        {
            return this._font.tint;
        },
        set: function (value)
        {
            this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;

            this.dirty = true;
        }
    },

    /**
     * The alignment of the BitmapText object
     *
     * @member {string}
     * @default 'left'
     * @memberof PIXI.extras.BitmapText#
     */
    align: {
        get: function ()
        {
            return this._font.align;
        },
        set: function (value)
        {
            this._font.align = value || 'left';

            this.dirty = true;
        }
    },

    /**
     * The font descriptor of the BitmapText object
     *
     * @member {Font}
     * @memberof PIXI.extras.BitmapText#
     */
    font: {
        get: function ()
        {
            return this._font;
        },
        set: function (value)
        {
            if (!value) {
                return;
            }

            if (typeof value === 'string') {
                value = value.split(' ');

                this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
                this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;
            }
            else {
                this._font.name = value.name;
                this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);
            }

            this.dirty = true;
        }
    },

    /**
     * The text of the BitmapText object
     *
     * @member {string}
     * @memberof PIXI.extras.BitmapText#
     */
    text: {
        get: function ()
        {
            return this._text;
        },
        set: function (value)
        {
            value = value.toString() || ' ';
            if (this._text === value)
            {
                return;
            }
            this._text = value;
            this.dirty = true;
        }
    }
});

/**
 * Renders text and updates it when needed
 *
 * @private
 */
BitmapText.prototype.updateText = function ()
{
    var data = BitmapText.fonts[this._font.name];
    var pos = new core.Point();
    var prevCharCode = null;
    var chars = [];
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var lineWidths = [];
    var line = 0;
    var scale = this._font.size / data.size;
    var lastSpace = -1;
    var maxLineHeight = 0;

    for (var i = 0; i < this.text.length; i++)
    {
        var charCode = this.text.charCodeAt(i);
        lastSpace = /(\s)/.test(this.text.charAt(i)) ? i : lastSpace;

        if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i)))
        {
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)
        {
            core.utils.removeItems(chars, lastSpace, i - lastSpace);
            i = lastSpace;
            lastSpace = -1;

            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        var charData = data.chars[charCode];

        if (!charData)
        {
            continue;
        }

        if (prevCharCode && charData.kerning[prevCharCode])
        {
            pos.x += charData.kerning[prevCharCode];
        }

        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});
        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);
        pos.x += charData.xAdvance;
        maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));
        prevCharCode = charCode;
    }

    lineWidths.push(lastLineWidth);
    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);

    var lineAlignOffsets = [];

    for (i = 0; i <= line; i++)
    {
        var alignOffset = 0;

        if (this._font.align === 'right')
        {
            alignOffset = maxLineWidth - lineWidths[i];
        }
        else if (this._font.align === 'center')
        {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        }

        lineAlignOffsets.push(alignOffset);
    }

    var lenChars = chars.length;
    var tint = this.tint;

    for (i = 0; i < lenChars; i++)
    {
        var c = this._glyphs[i]; // get the next glyph sprite

        if (c)
        {
            c.texture = chars[i].texture;
        }
        else
        {
            c = new core.Sprite(chars[i].texture);
            this._glyphs.push(c);
        }

        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
        c.position.y = chars[i].position.y * scale;
        c.scale.x = c.scale.y = scale;
        c.tint = tint;

        if (!c.parent)
        {
            this.addChild(c);
        }
    }

    // remove unnecessary children.
    for (i = lenChars; i < this._glyphs.length; ++i)
    {
        this.removeChild(this._glyphs[i]);
    }

    this.textWidth = maxLineWidth * scale;
    this.textHeight = (pos.y + data.lineHeight) * scale;
    this.maxLineHeight = maxLineHeight * scale;
};

/**
 * Updates the transform of this object
 *
 * @private
 */
BitmapText.prototype.updateTransform = function ()
{
    this.validate();
    this.containerUpdateTransform();
};

/**
 * Validates text before calling parent's getLocalBounds
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */

BitmapText.prototype.getLocalBounds = function()
{
    this.validate();
    return core.Container.prototype.getLocalBounds.call(this);
};

/**
 * Updates text when needed
 *
 * @private
 */
BitmapText.prototype.validate = function()
{
    if (this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }
};

BitmapText.fonts = {};

},{"../core":23}],74:[function(require,module,exports){
var core = require('../core');

/**
 * A MovieClip is a simple way to display an animation depicted by a list of textures.
 *
 * ```js
 * var alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
 * var textureArray = [];
 *
 * for (var i=0; i < 4; i++)
 * {
 *      var texture = PIXI.Texture.fromImage(alienImages[i]);
 *      textureArray.push(texture);
 * };
 *
 * var mc = new PIXI.MovieClip(textureArray);
 * ```
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI.extras
 * @param textures {PIXI.Texture[]|Object[]} an array of {@link PIXI.Texture} or frame objects that make up the animation
 * @param textures[].texture {PIXI.Texture} the {@link PIXI.Texture} of the frame
 * @param textures[].time {number} the duration of the frame in ms
 * zhangyun  2016.3.7 Add support for mask, so we can use jpg + mask as source of movieclip
 */
function MovieClip(textures)
{
    core.Sprite.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);

    /**
     * @private
     */
    this._textures = null;
	//zhangyun 2016.3.7
	this._maskTextures = null;
	this.maskTextures = null;
	this.maskSprite = null;

    /**
     * @private
     */
    this._durations = null;

    this.textures = textures;

    /**
     * The speed that the MovieClip will play at. Higher is faster, lower is slower
     *
     * @member {number}
     * @default 1
     */
    this.animationSpeed = 1;

    /**
     * Whether or not the movie clip repeats after playing.
     *
     * @member {boolean}
     * @default true
     */
    this.loop = true;

    /**
     * Function to call when a MovieClip finishes playing
     *
     * @method
     * @memberof PIXI.extras.MovieClip#
     */
    this.onComplete = null;

    /**
     * Elapsed time since animation has been started, used internally to display current texture
     *
     * @member {number}
     * @private
     */
    this._currentTime = 0;

    /**
     * Indicates if the MovieClip is currently playing
     *
     * @member {boolean}
     * @readonly
     */
    this.playing = false;
}

// constructor
MovieClip.prototype = Object.create(core.Sprite.prototype);
MovieClip.prototype.constructor = MovieClip;
module.exports = MovieClip;

Object.defineProperties(MovieClip.prototype, {
    /**
     * totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
     * assigned to the MovieClip.
     *
     * @member {number}
     * @memberof PIXI.extras.MovieClip#
     * @default 0
     * @readonly
     */
    totalFrames: {
        get: function()
        {
            return this._textures.length;
        }
    },

    /**
     * The array of textures used for this MovieClip
     *
     * @member {PIXI.Texture[]}
     * @memberof PIXI.extras.MovieClip#
     *
     */
    textures: {
        get: function ()
        {
            return this._textures;
        },
        set: function (value)
        {
            if(value[0] instanceof core.Texture)
            {
                this._textures = value;
                this._durations = null;
            }
            else
            {
                this._textures = [];
                this._durations = [];
                for(var i = 0; i < value.length; i++)
                {
                    this._textures.push(value[i].texture);
                    this._durations.push(value[i].time);
                }
            }
        }
    },

    //zhangyun 216.3.7
	/**
     * The array of mask textures used for this MovieClip
     *
     * @member {PIXI.Texture[]}
     * @memberof PIXI.extras.MovieClip#
     *
     */
    maskTextures: {
        get: function ()
        {
            return this._maskTextures;
        },
        set: function (value)
        {
			if ((!value) || (!value.length)) return;
			
			this._maskTextures = value;
			
			//if no mask sprite, then create one
			if (!this.maskSprite) {
				this.maskSprite = new PIXI.Sprite(this._maskTextures[0]);
				this.mask = this.maskSprite;
			}
        }
    },
	/**
    * The MovieClips current frame index
    *
    * @member {number}
    * @memberof PIXI.extras.MovieClip#
    * @readonly
    */
    currentFrame: {
        get: function ()
        {
            var currentFrame = Math.floor(this._currentTime) % this._textures.length;
            if (currentFrame < 0)
            {
                currentFrame += this._textures.length;
            }
            return currentFrame;
        }
    }

});

/**
 * Stops the MovieClip
 *
 */
MovieClip.prototype.stop = function ()
{
    if(!this.playing)
    {
        return;
    }

    this.playing = false;
    core.ticker.shared.remove(this.update, this);
};

/**
 * Plays the MovieClip
 *
 */
MovieClip.prototype.play = function ()
{
    if(this.playing)
    {
        return;
    }

    this.playing = true;
    core.ticker.shared.add(this.update, this);
};

/**
 * Stops the MovieClip and goes to a specific frame
 *
 * @param frameNumber {number} frame index to stop at
 */
MovieClip.prototype.gotoAndStop = function (frameNumber)
{
    this.stop();

    this._currentTime = frameNumber;

    this._texture = this._textures[this.currentFrame];
	//zhangyun, change texture of mask sprite
	if (this._maskTextures){
		this.maskSprite.texture = this._maskTextures[this.currentFrame];
		this.copyTransformation();
	}
};

/**
 * Goes to a specific frame and begins playing the MovieClip
 *
 * @param frameNumber {number} frame index to start at
 */
MovieClip.prototype.gotoAndPlay = function (frameNumber)
{
    this._currentTime = frameNumber;

    this.play();
};

/*
 * Updates the object transform for rendering
 * @private
 */
MovieClip.prototype.update = function (deltaTime)
{
    var elapsed = this.animationSpeed * deltaTime;

    if (this._durations !== null)
    {
        var lag = this._currentTime % 1 * this._durations[this.currentFrame];

        lag += elapsed / 60 * 1000;

        while (lag < 0)
        {
            this._currentTime--;
            lag += this._durations[this.currentFrame];
        }

        var sign = Math.sign(this.animationSpeed * deltaTime);
        this._currentTime = Math.floor(this._currentTime);

        while (lag >= this._durations[this.currentFrame])
        {
            lag -= this._durations[this.currentFrame] * sign;
            this._currentTime += sign;
        }

        this._currentTime += lag / this._durations[this.currentFrame];
    }
    else
    {
        this._currentTime += elapsed;
    }

    if (this._currentTime < 0 && !this.loop)
    {
        this.gotoAndStop(0);

        if (this.onComplete)
        {
            this.onComplete();
        }
    }
    else if (this._currentTime >= this._textures.length && !this.loop)
    {
        this.gotoAndStop(this._textures.length - 1);

        if (this.onComplete)
        {
            this.onComplete();
        }
    }
    else
    {
        this._texture = this._textures[this.currentFrame];
		//zhangyun, change texture of mask sprite
		if (this.maskSprite){
			this.maskSprite.texture = this._maskTextures[this.currentFrame];
			this.copyTransformation();
		}
    }

};

/*
 * Stops the MovieClip and destroys it
 *
 */
MovieClip.prototype.destroy = function ( )
{
    this.stop();
    core.Sprite.prototype.destroy.call(this);
	//zhangyun, should remove texture of movieclip
	this._maskTextures = null;
	this.maskSprite = null;
};

/*
 * Copy Sprite transformation to mask Sprite
*/

MovieClip.prototype.copyTransformation = function (){
	
	this.maskSprite.position.x = this.position.x;
	this.maskSprite.position.y = this.position.y;
	this.maskSprite.width = this.width;
	this.maskSprite.height = this.height;
	this.maskSprite.rotation = this.rotation;
	this.maskSprite.scale.x = this.scale.x;
	this.maskSprite.scale.y = this.scale.y;
	this.maskSprite.pivot.x = this.pivot.x;
	this.maskSprite.pivot.y = this.pivot.y;
}

/**
 * A short hand way of creating a movieclip from an array of frame ids
 *
 * @static
 * @param frames {string[]} the array of frames ids the movieclip will use as its texture frames
 */
MovieClip.fromFrames = function (frames)
{
    var textures = [];

    for (var i = 0; i < frames.length; ++i)
    {
        textures.push(new core.Texture.fromFrame(frames[i]));
    }

    return new MovieClip(textures);
};

/**
 * A short hand way of creating a movieclip from an array of image ids
 *
 * @static
 * @param images {string[]} the array of image urls the movieclip will use as its texture frames
 */
MovieClip.fromImages = function (images)
{
    var textures = [];

    for (var i = 0; i < images.length; ++i)
    {
        textures.push(new core.Texture.fromImage(images[i]));
    }

    return new MovieClip(textures);
};
},{"../core":23}],75:[function(require,module,exports){
var core = require('../core'),
    // a sprite use dfor rendering textures..
    tempPoint = new core.Point(),
    CanvasTinter = require('../core/renderers/canvas/utils/CanvasTinter');

/**
 * A tiling sprite is a fast way of rendering a tiling image
 *
 * @class
 * @extends PIXI.Sprite
 * @memberof PIXI.extras
 * @param texture {Texture} the texture of the tiling sprite
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 */
function TilingSprite(texture, width, height)
{
    core.Sprite.call(this, texture);

    /**
     * The scaling of the image that is being tiled
     *
     * @member {PIXI.Point}
     */
    this.tileScale = new core.Point(1,1);


    /**
     * The offset position of the image that is being tiled
     *
     * @member {PIXI.Point}
     */
    this.tilePosition = new core.Point(0,0);

    ///// private

    /**
     * The with of the tiling sprite
     *
     * @member {number}
     * @private
     */
    this._width = width || 100;

    /**
     * The height of the tiling sprite
     *
     * @member {number}
     * @private
     */
    this._height = height || 100;

    /**
     * An internal WebGL UV cache.
     *
     * @member {PIXI.TextureUvs}
     * @private
     */
    this._uvs = new core.TextureUvs();

    this._canvasPattern = null;

    //TODO move..
    this.shader = new core.AbstractFilter(

      [
        'precision lowp float;',
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aTextureCoord;',
        'attribute vec4 aColor;',

        'uniform mat3 projectionMatrix;',

        'uniform vec4 uFrame;',
        'uniform vec4 uTransform;',

        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',

        'void main(void){',
        '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',

        '   vec2 coord = aTextureCoord;',
        '   coord -= uTransform.xy;',
        '   coord /= uTransform.zw;',
        '   vTextureCoord = coord;',

        '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
        '}'
      ].join('\n'),
      [
        'precision lowp float;',

        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',

        'uniform sampler2D uSampler;',
        'uniform vec4 uFrame;',
        'uniform vec2 uPixelSize;',

        'void main(void){',

        '   vec2 coord = mod(vTextureCoord, uFrame.zw);',
        '   coord = clamp(coord, uPixelSize, uFrame.zw - uPixelSize);',
        '   coord += uFrame.xy;',

        '   gl_FragColor =  texture2D(uSampler, coord) * vColor ;',
        '}'
      ].join('\n'),

            // set the uniforms
            {
                uFrame: { type: '4fv', value: [0,0,1,1] },
                uTransform: { type: '4fv', value: [0,0,1,1] },
                uPixelSize : { type : '2fv', value: [1, 1]}
            }
      );
}

TilingSprite.prototype = Object.create(core.Sprite.prototype);
TilingSprite.prototype.constructor = TilingSprite;
module.exports = TilingSprite;


Object.defineProperties(TilingSprite.prototype, {
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.extras.TilingSprite#
     */
    width: {
        get: function ()
        {
            return this._width;
        },
        set: function (value)
        {
            this._width = value;
        }
    },

    /**
     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.extras.TilingSprite#
     */
    height: {
        get: function ()
        {
            return this._height;
        },
        set: function (value)
        {
            this._height = value;
        }
    }
});

TilingSprite.prototype._onTextureUpdate = function ()
{
    return;
};


/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer}
 * @private
 */
TilingSprite.prototype._renderWebGL = function (renderer)
{
    // tweak our texture temporarily..
    var texture = this._texture;

    if(!texture || !texture._uvs)
    {
        return;
    }

    var tempUvs = texture._uvs,
        tempWidth = texture._frame.width,
        tempHeight = texture._frame.height,
        tw = texture.baseTexture.width,
        th = texture.baseTexture.height;

    texture._uvs = this._uvs;
    texture._frame.width = this.width;
    texture._frame.height = this.height;

    this.shader.uniforms.uPixelSize.value[0] = 1.0/tw;
    this.shader.uniforms.uPixelSize.value[1] = 1.0/th;

    this.shader.uniforms.uFrame.value[0] = tempUvs.x0;
    this.shader.uniforms.uFrame.value[1] = tempUvs.y0;
    this.shader.uniforms.uFrame.value[2] = tempUvs.x1 - tempUvs.x0;
    this.shader.uniforms.uFrame.value[3] = tempUvs.y2 - tempUvs.y0;

    this.shader.uniforms.uTransform.value[0] = (this.tilePosition.x % (tempWidth * this.tileScale.x)) / this._width;
    this.shader.uniforms.uTransform.value[1] = (this.tilePosition.y % (tempHeight * this.tileScale.y)) / this._height;
    this.shader.uniforms.uTransform.value[2] = ( tw / this._width ) * this.tileScale.x;
    this.shader.uniforms.uTransform.value[3] = ( th / this._height ) * this.tileScale.y;

    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render(this);

    texture._uvs = tempUvs;
    texture._frame.width = tempWidth;
    texture._frame.height = tempHeight;
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} a reference to the canvas renderer
 * @private
 */
TilingSprite.prototype._renderCanvas = function (renderer)
{
    var texture = this._texture;

    if (!texture.baseTexture.hasLoaded)
    {
      return;
    }

    var context = renderer.context,
        transform = this.worldTransform,
        resolution = renderer.resolution,
        baseTexture = texture.baseTexture,
        modX = (this.tilePosition.x / this.tileScale.x) % texture._frame.width,
        modY = (this.tilePosition.y / this.tileScale.y) % texture._frame.height;

    // create a nice shiny pattern!
    // TODO this needs to be refreshed if texture changes..
    if(!this._canvasPattern)
    {
        // cut an object from a spritesheet..
        var tempCanvas = new core.CanvasBuffer(texture._frame.width, texture._frame.height);

        // Tint the tiling sprite
        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;

                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
            }
            tempCanvas.context.drawImage(this.tintedTexture, 0, 0);
        }
        else
        {
            tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y);
        }
        this._canvasPattern = tempCanvas.context.createPattern( tempCanvas.canvas, 'repeat' );
    }

    // set context state..
    context.globalAlpha = this.worldAlpha;
    context.setTransform(transform.a * resolution,
                       transform.b * resolution,
                       transform.c * resolution,
                       transform.d * resolution,
                       transform.tx * resolution,
                       transform.ty * resolution);

    // TODO - this should be rolled into the setTransform above..
    context.scale(this.tileScale.x,this.tileScale.y);

    context.translate(modX + (this.anchor.x * -this._width ),
                      modY + (this.anchor.y * -this._height));

    // check blend mode
    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== renderer.context.globalCompositeOperation)
    {
        context.globalCompositeOperation = compositeOperation;
    }

    // fill the pattern!
    context.fillStyle = this._canvasPattern;
    context.fillRect(-modX,
                     -modY,
                     this._width / this.tileScale.x,
                     this._height / this.tileScale.y);


    //TODO - pretty sure this can be deleted...
    //context.translate(-this.tilePosition.x + (this.anchor.x * this._width), -this.tilePosition.y + (this.anchor.y * this._height));
    //context.scale(1 / this.tileScale.x, 1 / this.tileScale.y);
};


/**
 * Returns the framing rectangle of the sprite as a Rectangle object
*
 * @return {PIXI.Rectangle} the framing rectangle
 */
TilingSprite.prototype.getBounds = function ()
{
    var width = this._width;
    var height = this._height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var minX,
        maxX,
        minY,
        maxY;

    minX = x1;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
 * Checks if a point is inside this tiling sprite
 * @param point {PIXI.Point} the point to check
 */
TilingSprite.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var width = this._width;
    var height = this._height;
    var x1 = -width * this.anchor.x;
    var y1;

    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
    {
        y1 = -height * this.anchor.y;

        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
        {
            return true;
        }
    }

    return false;
};

/**
 * Destroys this tiling sprite
 *
 */
TilingSprite.prototype.destroy = function () {
    core.Sprite.prototype.destroy.call(this);

    this.tileScale = null;
    this._tileScaleOffset = null;
    this.tilePosition = null;

    this._uvs = null;
};

/**
 * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 */
TilingSprite.fromFrame = function (frameId,width,height)
{
    var texture = core.utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
    }

    return new TilingSprite(texture,width,height);
};

/**
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @static
 * @param imageId {string} The image url of the texture
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
 */
TilingSprite.fromImage = function (imageId, width, height, crossorigin, scaleMode)
{
    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode),width,height);
};

},{"../core":23,"../core/renderers/canvas/utils/CanvasTinter":41}],76:[function(require,module,exports){
var core = require('../core'),
    DisplayObject = core.DisplayObject,
    _tempMatrix = new core.Matrix();

DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._originalRenderWebGL = null;
DisplayObject.prototype._originalRenderCanvas = null;

DisplayObject.prototype._originalUpdateTransform = null;
DisplayObject.prototype._originalHitTest = null;
DisplayObject.prototype._originalDestroy = null;
DisplayObject.prototype._cachedSprite = null;

Object.defineProperties(DisplayObject.prototype, {

    /**
     * Set this to true if you want this display object to be cached as a bitmap.
     * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.
     * To remove simply set this property to 'false'
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    cacheAsBitmap: {
        get: function ()
        {
            return this._cacheAsBitmap;
        },
        set: function (value)
        {
            if (this._cacheAsBitmap === value)
            {
                return;
            }

            this._cacheAsBitmap = value;

            if (value)
            {
                this._originalRenderWebGL = this.renderWebGL;
                this._originalRenderCanvas = this.renderCanvas;

                this._originalUpdateTransform = this.updateTransform;
                this._originalGetBounds = this.getBounds;

                this._originalDestroy = this.destroy;

                this._originalContainsPoint = this.containsPoint;

                this.renderWebGL = this._renderCachedWebGL;
                this.renderCanvas = this._renderCachedCanvas;

                this.destroy = this._cacheAsBitmapDestroy;

            }
            else
            {
                if (this._cachedSprite)
                {
                    this._destroyCachedDisplayObject();
                }

                this.renderWebGL = this._originalRenderWebGL;
                this.renderCanvas = this._originalRenderCanvas;
                this.getBounds = this._originalGetBounds;

                this.destroy = this._originalDestroy;

                this.updateTransform = this._originalUpdateTransform;
                this.containsPoint = this._originalContainsPoint;
            }
        }
    }
});
/**
* Renders a cached version of the sprite with WebGL
*
* @param renderer {PIXI.WebGLRenderer} the WebGL renderer
* @private
*/
DisplayObject.prototype._renderCachedWebGL = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    this._initCachedDisplayObject( renderer );

    this._cachedSprite.worldAlpha = this.worldAlpha;

    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render( this._cachedSprite );
};

/**
* Prepares the WebGL renderer to cache the sprite
*
* @param renderer {PIXI.WebGLRenderer} the WebGL renderer
* @private
*/
DisplayObject.prototype._initCachedDisplayObject = function (renderer)
{
    if(this._cachedSprite)
    {
        return;
    }

    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
    renderer.currentRenderer.flush();
    //this.filters= [];
    // next we find the dimensions of the untransformed object
    // this function also calls updatetransform on all its children as part of the measuring. This means we don't need to update the transform again in this function
    // TODO pass an object to clone too? saves having to create a new one each time!
    var bounds = this.getLocalBounds().clone();

    // add some padding!
    if(this._filters)
    {
        var padding = this._filters[0].padding;
        bounds.x -= padding;
        bounds.y -= padding;

        bounds.width += padding * 2;
        bounds.height += padding * 2;
    }

    // for now we cache the current renderTarget that the webGL renderer is currently using.
    // this could be more elegent..
    var cachedRenderTarget = renderer.currentRenderTarget;
    // We also store the filter stack - I will definitely look to change how this works a little later down the line.
    var stack = renderer.filterManager.filterStack;

    // this renderTexture will be used to store the cached DisplayObject
    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;



    // set all properties to there original so we can render to a texture
    this.renderWebGL = this._originalRenderWebGL;

    renderTexture.render(this, m, true, true);

    // now restore the state be setting the new properties
    renderer.setRenderTarget(cachedRenderTarget);
    renderer.filterManager.filterStack = stack;

    this.renderWebGL     = this._renderCachedWebGL;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.getBounds       = this._getCachedBounds;


    // create our cached sprite
    this._cachedSprite = new core.Sprite(renderTexture);
    this._cachedSprite.worldTransform = this.worldTransform;
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    // restore the transform of the cached sprite to avoid the nasty flicker..
    this.updateTransform();

    // map the hit test..
    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
};

/**
* Renders a cached version of the sprite with canvas
*
* @param renderer {PIXI.CanvasRenderer} the Canvas renderer
* @private
*/
DisplayObject.prototype._renderCachedCanvas = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    this._initCachedDisplayObjectCanvas( renderer );

    this._cachedSprite.worldAlpha = this.worldAlpha;

    this._cachedSprite.renderCanvas(renderer);
};

//TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..
/**
* Prepares the Canvas renderer to cache the sprite
*
* @param renderer {PIXI.CanvasRenderer} the Canvas renderer
* @private
*/
DisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer)
{
    if(this._cachedSprite)
    {
        return;
    }

    //get bounds actually transforms the object for us already!
    var bounds = this.getLocalBounds();

    var cachedRenderTarget = renderer.context;

    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;

    // set all properties to there original so we can render to a texture
    this.renderCanvas = this._originalRenderCanvas;

    renderTexture.render(this, m, true);

    // now restore the state be setting the new properties
    renderer.context = cachedRenderTarget;

    this.renderCanvas = this._renderCachedCanvas;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.getBounds  = this._getCachedBounds;


    // create our cached sprite
    this._cachedSprite = new core.Sprite(renderTexture);
    this._cachedSprite.worldTransform = this.worldTransform;
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    this.updateTransform();

    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
};

/**
* Calculates the bounds of the cached sprite
*
* @private
*/
DisplayObject.prototype._getCachedBounds = function ()
{
    this._cachedSprite._currentBounds = null;

    return this._cachedSprite.getBounds();
};

/**
* Destroys the cached sprite.
*
* @private
*/
DisplayObject.prototype._destroyCachedDisplayObject = function ()
{
    this._cachedSprite._texture.destroy();
    this._cachedSprite = null;
};

DisplayObject.prototype._cacheAsBitmapDestroy = function ()
{
    this.cacheAsBitmap = false;
    this._originalDestroy();
};

},{"../core":23}],77:[function(require,module,exports){
var core = require('../core');

/**
 * The instance name of the object.
 *
 * @memberof PIXI.DisplayObject#
 * @member {string}
 */
core.DisplayObject.prototype.name = null;

/**
* Returns the display object in the container
*
* @memberof PIXI.Container#
* @param name {string} instance name
* @return {PIXI.DisplayObject}
*/
core.Container.prototype.getChildByName = function (name)
{
    for (var i = 0; i < this.children.length; i++)
    {
        if (this.children[i].name === name)
        {
            return this.children[i];
        }
    }
    return null;
};

},{"../core":23}],78:[function(require,module,exports){
var core = require('../core');

/**
* Returns the global position of the displayObject
*
* @memberof PIXI.DisplayObject#
* @param point {Point} the point to write the global value to. If null a new point will be returned
* @return {Point}
*/
core.DisplayObject.prototype.getGlobalPosition = function (point)
{
    point = point || new core.Point();

    if(this.parent)
    {
        this.displayObjectUpdateTransform();

        point.x = this.worldTransform.tx;
        point.y = this.worldTransform.ty;
    }
    else
    {
        point.x = this.position.x;
        point.y = this.position.y;
    }

    return point;
};

},{"../core":23}],79:[function(require,module,exports){
/**
 * @file        Main export of the PIXI extras library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

require('./cacheAsBitmap');
require('./getChildByName');
require('./getGlobalPosition');

/**
 * @namespace PIXI.extras
 */
module.exports = {
    MovieClip:      require('./MovieClip'),
    TilingSprite:   require('./TilingSprite'),
    BitmapText:     require('./BitmapText')
};

},{"./BitmapText":73,"./MovieClip":74,"./TilingSprite":75,"./cacheAsBitmap":76,"./getChildByName":77,"./getGlobalPosition":78}],80:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


// TODO (cengler) - The Y is flipped in this shader for some reason.

/**
 * @author Vico @vicocotea
 * original shader : https://www.shadertoy.com/view/lssGDj by @movAX13h
 */

/**
 * An ASCII filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function AsciiFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nuniform vec4 dimensions;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n    {\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy;\n\n    vec3 col = texture2D(uSampler, floor( uv / pixelSize ) * pixelSize / dimensions.xy).rgb;\n\n    float gray = (col.r + col.g + col.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    vec2 p = mod( uv / ( pixelSize * 0.5 ), 2.0) - vec2(1.0);\n    col = col * character(n, p);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n",
        // custom uniforms
        {
            dimensions: { type: '4fv', value: new Float32Array([0, 0, 0, 0]) },
            pixelSize:  { type: '1f', value: 8 }
        }
    );
}

AsciiFilter.prototype = Object.create(core.AbstractFilter.prototype);
AsciiFilter.prototype.constructor = AsciiFilter;
module.exports = AsciiFilter;

Object.defineProperties(AsciiFilter.prototype, {
    /**
     * The pixel size used by the filter.
     *
     * @member {number}
     * @memberof PIXI.filters.AsciiFilter#
     */
    size: {
        get: function ()
        {
            return this.uniforms.pixelSize.value;
        },
        set: function (value)
        {
            this.uniforms.pixelSize.value = value;
        }
    }
});

},{"../../core":23}],81:[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('../blur/BlurXFilter'),
    BlurYFilter = require('../blur/BlurYFilter');

/**
 * The BloomFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BloomFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYFilter = new BlurYFilter();

    this.defaultFilter = new core.AbstractFilter();
}

BloomFilter.prototype = Object.create(core.AbstractFilter.prototype);
BloomFilter.prototype.constructor = BloomFilter;
module.exports = BloomFilter;

BloomFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    //TODO - copyTexSubImage2D could be used here?
    this.defaultFilter.applyFilter(renderer, input, output);

    this.blurXFilter.applyFilter(renderer, input, renderTarget);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.SCREEN);

    this.blurYFilter.applyFilter(renderer, renderTarget, output);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(BloomFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf PIXI.filters.BloomFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = this.blurYFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf PIXI.filters.BloomFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf PIXI.filters.BloomFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYFilter.blur;
        },
        set: function (value)
        {
            this.blurYFilter.blur = value;
        }
    }
});

},{"../../core":23,"../blur/BlurXFilter":84,"../blur/BlurYFilter":85}],82:[function(require,module,exports){
var core = require('../../core');


/**
 * The BlurDirFilter applies a Gaussian blur toward a direction to an object.
 *
 * @class
 * @param {number} dirX
 * @param {number} dirY
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurDirFilter(dirX, dirY)
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform float dirX;\nuniform float dirY;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[3];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[0] = aTextureCoord + vec2( (0.004 * strength) * dirX, (0.004 * strength) * dirY );\n    vBlurTexCoords[1] = aTextureCoord + vec2( (0.008 * strength) * dirX, (0.008 * strength) * dirY );\n    vBlurTexCoords[2] = aTextureCoord + vec2( (0.012 * strength) * dirX, (0.012 * strength) * dirY );\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[3];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vTextureCoord     ) * 0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0]) * 0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1]) * 0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2]) * 0.004431848411938341;\n}\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 },
            dirX: { type: '1f', value: dirX || 0 },
            dirY: { type: '1f', value: dirY || 0 }
        }
    );

    this.defaultFilter = new core.AbstractFilter();

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    this.passes = 1;

    /**
     * Sets the X direction of the blur
     *
     * @member {number}
     * @default 0
     */
    this.dirX = dirX || 0;

    /**
     * Sets the Y direction of the blur
     *
     * @member {number}
     * @default 0
     */
    this.dirY = dirY || 0;

    this.strength = 4;
}

BlurDirFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurDirFilter.prototype.constructor = BlurDirFilter;
module.exports = BlurDirFilter;

BlurDirFilter.prototype.applyFilter = function (renderer, input, output, clear) {

    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);

    if (this.passes === 1) {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    } else {
        var renderTarget = renderer.filterManager.getRenderTarget(true);

        renderer.filterManager.applyFilter(shader, input, renderTarget, clear);

        for(var i = 0; i < this.passes-2; i++)
        {
            //this.uniforms.strength.value = this.strength / 4 / (this.passes+(i*2)) * (input.frame.width / input.size.width);
            renderer.filterManager.applyFilter(shader, renderTarget, renderTarget, clear);
        }

        renderer.filterManager.applyFilter(shader, renderTarget, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurDirFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurDirFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.strength;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.strength = value;
        }
    },
    /**
     * Sets the X direction of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYFilter#
     * @default 0
     */
    dirX: {
        get: function ()
        {
            return this.dirX;
        },
        set: function (value)
        {
            this.uniforms.dirX.value = value;
        }
    },
    /**
     * Sets the Y direction of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurDirFilter#
     * @default 0
     */
    dirY: {
        get: function ()
        {
            return this.dirY;
        },
        set: function (value)
        {
            this.uniforms.dirY.value = value;
        }
    }
});

},{"../../core":23}],83:[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('./BlurXFilter'),
    BlurYFilter = require('./BlurYFilter');

/**
 * The BlurFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYFilter = new BlurYFilter();
}

BlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurFilter.prototype.constructor = BlurFilter;
module.exports = BlurFilter;

BlurFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    this.blurXFilter.applyFilter(renderer, input, renderTarget);
    this.blurYFilter.applyFilter(renderer, renderTarget, output);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(BlurFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf PIXI.filters.BlurFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.padding = Math.abs(value) * 0.5;
            this.blurXFilter.blur = this.blurYFilter.blur = value;
        }
    },

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYFilter#
     * @default 1
     */
    passes: {
        get: function ()
        {
            return  this.blurXFilter.passes;
        },
        set: function (value)
        {
            this.blurXFilter.passes = this.blurYFilter.passes = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf PIXI.filters.BlurFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf PIXI.filters.BlurFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYFilter.blur;
        },
        set: function (value)
        {
            this.blurYFilter.blur = value;
        }
    }
});

},{"../../core":23,"./BlurXFilter":84,"./BlurYFilter":85}],84:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurXFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurXFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 }
        }
    );

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    this.passes = 1;

    this.strength = 4;
}

BlurXFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurXFilter.prototype.constructor = BlurXFilter;
module.exports = BlurXFilter;

BlurXFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, true);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurXFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurXFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding =  Math.abs(value) * 0.5;
            this.strength = value;
        }
    }
});

},{"../../core":23}],85:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurYFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurYFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 }
        }
    );

    this.passes = 1;
    this.strength = 4;
}

BlurYFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurYFilter.prototype.constructor = BlurYFilter;
module.exports = BlurYFilter;

BlurYFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = Math.abs(this.strength) / 4 / this.passes * (input.frame.height / input.size.height);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, true);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurYFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding = Math.abs(value) * 0.5;
            this.strength = value;
        }
    }
});

},{"../../core":23}],86:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * A Smart Blur Filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function SmartBlurFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 delta;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta * percent);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n",
        // uniforms
        {
          delta: { type: 'v2', value: { x: 0.1, y: 0.0 } }
        }
    );
}

SmartBlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
SmartBlurFilter.prototype.constructor = SmartBlurFilter;
module.exports = SmartBlurFilter;

},{"../../core":23}],87:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ColorMatrixFilter class lets you apply a 5x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * ```js
 *  var colorMatrix = new PIXI.ColorMatrixFilter();
 *  container.filters = [colorMatrix];
 *  colorMatrix.contrast(2);
 * ```
 * @author Clément Chenebault <clement@goodboydigital.com>
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function ColorMatrixFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[25];\n\nvoid main(void)\n{\n\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor.r = (m[0] * c.r);\n        gl_FragColor.r += (m[1] * c.g);\n        gl_FragColor.r += (m[2] * c.b);\n        gl_FragColor.r += (m[3] * c.a);\n        gl_FragColor.r += m[4];\n\n    gl_FragColor.g = (m[5] * c.r);\n        gl_FragColor.g += (m[6] * c.g);\n        gl_FragColor.g += (m[7] * c.b);\n        gl_FragColor.g += (m[8] * c.a);\n        gl_FragColor.g += m[9];\n\n     gl_FragColor.b = (m[10] * c.r);\n        gl_FragColor.b += (m[11] * c.g);\n        gl_FragColor.b += (m[12] * c.b);\n        gl_FragColor.b += (m[13] * c.a);\n        gl_FragColor.b += m[14];\n\n     gl_FragColor.a = (m[15] * c.r);\n        gl_FragColor.a += (m[16] * c.g);\n        gl_FragColor.a += (m[17] * c.b);\n        gl_FragColor.a += (m[18] * c.a);\n        gl_FragColor.a += m[19];\n\n}\n",
        // custom uniforms
        {
            m: {
                type: '1fv', value: [
                    1, 0, 0, 0, 0,
                    0, 1, 0, 0, 0,
                    0, 0, 1, 0, 0,
                    0, 0, 0, 1, 0
                ]
            }
        }
    );
}

ColorMatrixFilter.prototype = Object.create(core.AbstractFilter.prototype);
ColorMatrixFilter.prototype.constructor = ColorMatrixFilter;
module.exports = ColorMatrixFilter;


/**
 * Transforms current matrix and set the new one
 *
 * @param matrix {number[]} (mat 5x4)
 * @param multiply {boolean} if true, current matrix and matrix are multiplied. If false, just set the current matrix with @param matrix
 */
ColorMatrixFilter.prototype._loadMatrix = function (matrix, multiply)
{
    multiply = !!multiply;

    var newMatrix = matrix;

    if (multiply) {
        this._multiply(newMatrix, this.uniforms.m.value, matrix);
        newMatrix = this._colorMatrix(newMatrix);
    }

    // set the new matrix
    this.uniforms.m.value = newMatrix;
};

/**
 * Multiplies two mat5's
 *
 * @param out {number[]} (mat 5x4) the receiving matrix
 * @param a {number[]} (mat 5x4) the first operand
 * @param b {number[]} (mat 5x4) the second operand
 * @returns out {number[]} (mat 5x4)
 */
ColorMatrixFilter.prototype._multiply = function (out, a, b)
{

    // Red Channel
    out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
    out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
    out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
    out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
    out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]);

    // Green Channel
    out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
    out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
    out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
    out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
    out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]);

    // Blue Channel
    out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
    out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
    out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
    out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
    out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]);

    // Alpha Channel
    out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
    out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
    out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
    out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
    out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]);

    return out;
};

/**
 * Create a Float32 Array and normalize the offset component to 0-1
 *
 * @param matrix {number[]} (mat 5x4)
 * @return m {number[]} (mat 5x4) with all values between 0-1
 */
ColorMatrixFilter.prototype._colorMatrix = function (matrix)
{
    // Create a Float32 Array and normalize the offset component to 0-1
    var m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;

    return m;
};

/**
 * Adjusts brightness
 *
 * @param b {number} value of the brigthness (0 is black)
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.brightness = function (b, multiply)
{
    var matrix = [
        b, 0, 0, 0, 0,
        0, b, 0, 0, 0,
        0, 0, b, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the matrices in grey scales
 *
 * @param scale {number} value of the grey (0 is black)
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.greyscale = function (scale, multiply)
{
    var matrix = [
        scale, scale, scale, 0, 0,
        scale, scale, scale, 0, 0,
        scale, scale, scale, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};
//Americanized alias
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;

/**
 * Set the black and white matrice
 * Multiply the current matrix
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.blackAndWhite = function (multiply)
{
    var matrix = [
        0.3, 0.6, 0.1, 0, 0,
        0.3, 0.6, 0.1, 0, 0,
        0.3, 0.6, 0.1, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the hue property of the color
 *
 * @param rotation {number} in degrees
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.hue = function (rotation, multiply)
{
    rotation = (rotation || 0) / 180 * Math.PI;
    var cos = Math.cos(rotation),
        sin = Math.sin(rotation);

    // luminanceRed, luminanceGreen, luminanceBlue
    var lumR = 0.213, // or 0.3086
        lumG = 0.715, // or 0.6094
        lumB = 0.072; // or 0.0820

    var matrix = [
        lumR + cos * (1 - lumR) + sin * (-lumR), lumG + cos * (-lumG) + sin * (-lumG), lumB + cos * (-lumB) + sin * (1 - lumB), 0, 0,
        lumR + cos * (-lumR) + sin * (0.143), lumG + cos * (1 - lumG) + sin * (0.140), lumB + cos * (-lumB) + sin * (-0.283), 0, 0,
        lumR + cos * (-lumR) + sin * (-(1 - lumR)), lumG + cos * (-lumG) + sin * (lumG), lumB + cos * (1 - lumB) + sin * (lumB), 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};


/**
 * Set the contrast matrix, increase the separation between dark and bright
 * Increase contrast : shadows darker and highlights brighter
 * Decrease contrast : bring the shadows up and the highlights down
 *
 * @param amount {number} value of the contrast
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.contrast = function (amount, multiply)
{
    var v = (amount || 0) + 1;
    var o = -128 * (v - 1);

    var matrix = [
        v, 0, 0, 0, o,
        0, v, 0, 0, o,
        0, 0, v, 0, o,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the saturation matrix, increase the separation between colors
 * Increase saturation : increase contrast, brightness, and sharpness
 *
 * @param amount {number}
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.saturate = function (amount, multiply)
{
    var x = (amount || 0) * 2 / 3 + 1;
    var y = ((x - 1) * -0.5);

    var matrix = [
        x, y, y, 0, 0,
        y, x, y, 0, 0,
        y, y, x, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Desaturate image (remove color)
 *
 * Call the saturate function
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.desaturate = function (multiply) // jshint unused:false
{
    this.saturate(-1);
};

/**
 * Negative image (inverse of classic rgb matrix)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.negative = function (multiply)
{
    var matrix = [
        0, 1, 1, 0, 0,
        1, 0, 1, 0, 0,
        1, 1, 0, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Sepia image
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.sepia = function (multiply)
{
    var matrix = [
        0.393, 0.7689999, 0.18899999, 0, 0,
        0.349, 0.6859999, 0.16799999, 0, 0,
        0.272, 0.5339999, 0.13099999, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.technicolor = function (multiply)
{
    var matrix = [
        1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
        -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
        -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Polaroid filter
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.polaroid = function (multiply)
{
    var matrix = [
        1.438, -0.062, -0.062, 0, 0,
        -0.122, 1.378, -0.122, 0, 0,
        -0.016, -0.016, 1.483, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Filter who transforms : Red -> Blue and Blue -> Red
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.toBGR = function (multiply)
{
    var matrix = [
        0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.kodachrome = function (multiply)
{
    var matrix = [
        1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
        -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
        -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Brown delicious browni filter (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.browni = function (multiply)
{
    var matrix = [
        0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
        -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
        0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Vintage filter (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.vintage = function (multiply)
{
    var matrix = [
        0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
        0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
        0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * We don't know exactly what it does, kind of gradient map, but funny to play with!
 *
 * @param desaturation {number}
 * @param toned {number}
 * @param lightColor {string} (example : "0xFFE580")
 * @param darkColor {string}  (example : "0xFFE580")
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.colorTone = function (desaturation, toned, lightColor, darkColor, multiply)
{
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 0xFFE580;
    darkColor = darkColor || 0x338000;

    var lR = ((lightColor >> 16) & 0xFF) / 255;
    var lG = ((lightColor >> 8) & 0xFF) / 255;
    var lB = (lightColor & 0xFF) / 255;

    var dR = ((darkColor >> 16) & 0xFF) / 255;
    var dG = ((darkColor >> 8) & 0xFF) / 255;
    var dB = (darkColor & 0xFF) / 255;

    var matrix = [
        0.3, 0.59, 0.11, 0, 0,
        lR, lG, lB, desaturation, 0,
        dR, dG, dB, toned, 0,
        lR - dR, lG - dG, lB - dB, 0, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Night effect
 *
 * @param intensity {number}
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.night = function (intensity, multiply)
{
    intensity = intensity || 0.1;
    var matrix = [
        intensity * ( -2.0), -intensity, 0, 0, 0,
        -intensity, 0, intensity, 0, 0,
        0, intensity, intensity * 2.0, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};


/*
 * Predator effect
 *
 * Erase the current matrix by setting a new indepent one
 *
 * @param amount {number} how much the predator feels his future victim
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.predator = function (amount, multiply)
{
    var matrix = [
        11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount,
        -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount,
        -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * LSD effect
 *
 * Multiply the current matrix
 *
 * @param amount {number} How crazy is your effect
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.lsd = function (multiply)
{
    var matrix = [
        2, -0.4, 0.5, 0, 0,
        -0.5, 2, -0.4, 0, 0,
        -0.4, -0.5, 3, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Erase the current matrix by setting the default one
 *
 */
ColorMatrixFilter.prototype.reset = function ()
{
    var matrix = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
    ];

    this._loadMatrix(matrix, false);
};


Object.defineProperties(ColorMatrixFilter.prototype, {
    /**
     * Sets the matrix of the color matrix filter
     *
     * @member {number[]}
     * @memberof PIXI.filters.ColorMatrixFilter#
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    matrix: {
        get: function ()
        {
            return this.uniforms.m.value;
        },
        set: function (value)
        {
            this.uniforms.m.value = value;
        }
    }
});

},{"../../core":23}],88:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function ColorStepFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float step;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    color = floor(color * step) / step;\n\n    gl_FragColor = color;\n}\n",
        // custom uniforms
        {
            step: { type: '1f', value: 5 }
        }
    );
}

ColorStepFilter.prototype = Object.create(core.AbstractFilter.prototype);
ColorStepFilter.prototype.constructor = ColorStepFilter;
module.exports = ColorStepFilter;

Object.defineProperties(ColorStepFilter.prototype, {
    /**
     * The number of steps to reduce the palette by.
     *
     * @member {number}
     * @memberof PIXI.filters.ColorStepFilter#
     */
    step: {
        get: function ()
        {
            return this.uniforms.step.value;
        },
        set: function (value)
        {
            this.uniforms.step.value = value;
        }
    }
});

},{"../../core":23}],89:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ConvolutionFilter class applies a matrix convolution filter effect.
 * A convolution combines pixels in the input image with neighboring pixels to produce a new image.
 * A wide variety of image effects can be achieved through convolutions, including blurring, edge
 * detection, sharpening, embossing, and beveling. The matrix should be specified as a 9 point Array.
 * See http://docs.gimp.org/en/plug-in-convmatrix.html for more info.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 * @param matrix {number[]} An array of values used for matrix transformation. Specified as a 9 point Array.
 * @param width {number} Width of the object you are transforming
 * @param height {number} Height of the object you are transforming
 */
function ConvolutionFilter(matrix, width, height)
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n",
        // custom uniforms
        {
            matrix:     { type: '1fv', value: new Float32Array(matrix) },
            texelSize:  { type: 'v2', value: { x: 1 / width, y: 1 / height } }
        }
    );
}

ConvolutionFilter.prototype = Object.create(core.AbstractFilter.prototype);
ConvolutionFilter.prototype.constructor = ConvolutionFilter;
module.exports = ConvolutionFilter;

Object.defineProperties(ConvolutionFilter.prototype, {
    /**
     * An array of values used for matrix transformation. Specified as a 9 point Array.
     *
     * @member {number[]}
     * @memberof PIXI.filters.ConvolutionFilter#
     */
    matrix: {
        get: function ()
        {
            return this.uniforms.matrix.value;
        },
        set: function (value)
        {
            this.uniforms.matrix.value = new Float32Array(value);
        }
    },

    /**
     * Width of the object you are transforming
     *
     * @member {number}
     * @memberof PIXI.filters.ConvolutionFilter#
     */
    width: {
        get: function ()
        {
            return 1/this.uniforms.texelSize.value.x;
        },
        set: function (value)
        {
            this.uniforms.texelSize.value.x = 1/value;
        }
    },

    /**
     * Height of the object you are transforming
     *
     * @member {number}
     * @memberof PIXI.filters.ConvolutionFilter#
     */
    height: {
        get: function ()
        {
            return 1/this.uniforms.texelSize.value.y;
        },
        set: function (value)
        {
            this.uniforms.texelSize.value.y = 1/value;
        }
    }
});

},{"../../core":23}],90:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * A Cross Hatch effect filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function CrossHatchFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n"
    );
}

CrossHatchFilter.prototype = Object.create(core.AbstractFilter.prototype);
CrossHatchFilter.prototype.constructor = CrossHatchFilter;
module.exports = CrossHatchFilter;

},{"../../core":23}],91:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used to offset the x and the g property of the texture is used to offset the y.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 * @param sprite {PIXI.Sprite} the sprite used for the displacement map. (make sure its added to the scene!)
 */
function DisplacementFilter(sprite, scale)
{
    var maskMatrix = new core.Matrix();
    sprite.renderable = false;

    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vMapCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nvoid main(void)\n{\n   vec4 map =  texture2D(mapSampler, vMapCoord);\n\n   map -= 0.5;\n   map.xy *= scale;\n\n   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y));\n}\n",
        // uniforms
        {
            mapSampler:     { type: 'sampler2D', value: sprite.texture },
            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) },
            scale:          { type: 'v2', value: { x: 1, y: 1 } }
        }
    );

    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;

    if (scale === null || scale === undefined)
    {
        scale = 20;
    }

    this.scale = new core.Point(scale, scale);
}

DisplacementFilter.prototype = Object.create(core.AbstractFilter.prototype);
DisplacementFilter.prototype.constructor = DisplacementFilter;
module.exports = DisplacementFilter;

DisplacementFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);

    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
    this.uniforms.scale.value.x = this.scale.x * (1/input.frame.width);
    this.uniforms.scale.value.y = this.scale.y * (1/input.frame.height);

    var shader = this.getShader(renderer);
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};


Object.defineProperties(DisplacementFilter.prototype, {
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.filters.DisplacementFilter#
     */
    map: {
        get: function ()
        {
            return this.uniforms.mapSampler.value;
        },
        set: function (value)
        {
            this.uniforms.mapSampler.value = value;

        }
    }
});

},{"../../core":23}],92:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js
 */

/**
 * This filter applies a dotscreen effect making display objects appear to be made out of
 * black and white halftone dots like an old printer.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function DotScreenFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 dimensions;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * dimensions.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n",
        // custom uniforms
        {
            scale:      { type: '1f', value: 1 },
            angle:      { type: '1f', value: 5 },
            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
        }
    );
}

DotScreenFilter.prototype = Object.create(core.AbstractFilter.prototype);
DotScreenFilter.prototype.constructor = DotScreenFilter;
module.exports = DotScreenFilter;

Object.defineProperties(DotScreenFilter.prototype, {
    /**
     * The scale of the effect.
     * @member {number}
     * @memberof PIXI.filters.DotScreenFilter#
     */
    scale: {
        get: function ()
        {
            return this.uniforms.scale.value;
        },
        set: function (value)
        {
            this.uniforms.scale.value = value;
        }
    },

    /**
     * The radius of the effect.
     * @member {number}
     * @memberof PIXI.filters.DotScreenFilter#
     */
    angle: {
        get: function ()
        {
            return this.uniforms.angle.value;
        },
        set: function (value)
        {
            this.uniforms.angle.value = value;
        }
    }
});

},{"../../core":23}],93:[function(require,module,exports){
var core = require('../../core');

// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurYTintFilter applies a vertical Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function BlurYTintFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform vec2 offset;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition+offset), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform vec3 color;\nuniform float alpha;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec4 sum = vec4(0.0);\n\n    sum += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    sum += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    sum += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    sum += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    sum += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n\n    gl_FragColor = vec4( color.rgb * sum.a * alpha, sum.a * alpha );\n}\n",
        // set the uniforms
        {
            blur: { type: '1f', value: 1 / 512 },
            color: { type: 'c', value: [0,0,0]},
            alpha: { type: '1f', value: 0.7 },
            offset: { type: '2f', value:[5, 5]},
            strength: { type: '1f', value:1}
        }
    );

    this.passes = 1;
    this.strength = 4;
}

BlurYTintFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurYTintFilter.prototype.constructor = BlurYTintFilter;
module.exports = BlurYTintFilter;

BlurYTintFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.height / input.size.height);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, clear);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurYTintFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.BlurYTintFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.strength = value;
        }
    }
});

},{"../../core":23}],94:[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('../blur/BlurXFilter'),
    BlurYTintFilter = require('./BlurYTintFilter');

/**
 * The DropShadowFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function DropShadowFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYTintFilter = new BlurYTintFilter();

    this.defaultFilter = new core.AbstractFilter();

    this.padding = 30;

    this._dirtyPosition = true;
    this._angle = 45 * Math.PI / 180;
    this._distance = 10;
    this.alpha = 0.75;
    this.hideObject = false;
    this.blendMode = core.BLEND_MODES.MULTIPLY;
}

DropShadowFilter.prototype = Object.create(core.AbstractFilter.prototype);
DropShadowFilter.prototype.constructor = DropShadowFilter;
module.exports = DropShadowFilter;

DropShadowFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    //TODO - copyTexSubImage2D could be used here?
    if(this._dirtyPosition)
    {
        this._dirtyPosition = false;

        this.blurYTintFilter.uniforms.offset.value[0] = Math.sin(this._angle) * this._distance;
        this.blurYTintFilter.uniforms.offset.value[1] = Math.cos(this._angle) * this._distance;
    }

    this.blurXFilter.applyFilter(renderer, input, renderTarget);

    renderer.blendModeManager.setBlendMode(this.blendMode);

    this.blurYTintFilter.applyFilter(renderer, renderTarget, output);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);

    if(!this.hideObject)
    {

        this.defaultFilter.applyFilter(renderer, input, output);
    }


    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(DropShadowFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = this.blurYTintFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYTintFilter.blur;
        },
        set: function (value)
        {
            this.blurYTintFilter.blur = value;
        }
    },

    /**
     * Sets the color of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    color: {
        get: function ()
        {
            return  core.utils.rgb2hex( this.blurYTintFilter.uniforms.color.value );
        },
        set: function (value)
        {
            this.blurYTintFilter.uniforms.color.value = core.utils.hex2rgb(value);
        }
    },

    /**
     * Sets the alpha of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    alpha: {
        get: function ()
        {
            return  this.blurYTintFilter.uniforms.alpha.value;
        },
        set: function (value)
        {
            this.blurYTintFilter.uniforms.alpha.value = value;
        }
    },

    /**
     * Sets the distance of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    distance: {
        get: function ()
        {
            return  this._distance;
        },
        set: function (value)
        {
            this._dirtyPosition = true;
            this._distance = value;
        }
    },

    /**
     * Sets the angle of the shadow
     *
     * @member {number}
     * @memberOf PIXI.filters.DropShadowFilter#
     */
    angle: {
        get: function ()
        {
            return  this._angle;
        },
        set: function (value)
        {
            this._dirtyPosition = true;
            this._angle = value;
        }
    }
});

},{"../../core":23,"../blur/BlurXFilter":84,"./BlurYTintFilter":93}],95:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This greyscales the palette of your Display Objects.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function GrayFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float gray;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);\n}\n",
        // set the uniforms
        {
            gray: { type: '1f', value: 1 }
        }
    );
}

GrayFilter.prototype = Object.create(core.AbstractFilter.prototype);
GrayFilter.prototype.constructor = GrayFilter;
module.exports = GrayFilter;

Object.defineProperties(GrayFilter.prototype, {
    /**
     * The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color.
     *
     * @member {number}
     * @memberof PIXI.filters.GrayFilter#
     */
    gray: {
        get: function ()
        {
            return this.uniforms.gray.value;
        },
        set: function (value)
        {
            this.uniforms.gray.value = value;
        }
    }
});

},{"../../core":23}],96:[function(require,module,exports){
/**
 * @file        Main export of the PIXI filters library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.filters
 */
module.exports = {
    AsciiFilter:        require('./ascii/AsciiFilter'),
    BloomFilter:        require('./bloom/BloomFilter'),
    BlurFilter:         require('./blur/BlurFilter'),
    BlurXFilter:        require('./blur/BlurXFilter'),
    BlurYFilter:        require('./blur/BlurYFilter'),
    BlurDirFilter:      require('./blur/BlurDirFilter'),
    ColorMatrixFilter:  require('./color/ColorMatrixFilter'),
    ColorStepFilter:    require('./color/ColorStepFilter'),
    ConvolutionFilter:  require('./convolution/ConvolutionFilter'),
    CrossHatchFilter:   require('./crosshatch/CrossHatchFilter'),
    DisplacementFilter: require('./displacement/DisplacementFilter'),
    DotScreenFilter:    require('./dot/DotScreenFilter'),
    GrayFilter:         require('./gray/GrayFilter'),
    DropShadowFilter:   require('./dropshadow/DropShadowFilter'),
    InvertFilter:       require('./invert/InvertFilter'),
    NoiseFilter:        require('./noise/NoiseFilter'),
    PixelateFilter:     require('./pixelate/PixelateFilter'),
    RGBSplitFilter:     require('./rgb/RGBSplitFilter'),
    ShockwaveFilter:    require('./shockwave/ShockwaveFilter'),
    SepiaFilter:        require('./sepia/SepiaFilter'),
    SmartBlurFilter:    require('./blur/SmartBlurFilter'),
    TiltShiftFilter:    require('./tiltshift/TiltShiftFilter'),
    TiltShiftXFilter:   require('./tiltshift/TiltShiftXFilter'),
    TiltShiftYFilter:   require('./tiltshift/TiltShiftYFilter'),
    TwistFilter:        require('./twist/TwistFilter')
};

},{"./ascii/AsciiFilter":80,"./bloom/BloomFilter":81,"./blur/BlurDirFilter":82,"./blur/BlurFilter":83,"./blur/BlurXFilter":84,"./blur/BlurYFilter":85,"./blur/SmartBlurFilter":86,"./color/ColorMatrixFilter":87,"./color/ColorStepFilter":88,"./convolution/ConvolutionFilter":89,"./crosshatch/CrossHatchFilter":90,"./displacement/DisplacementFilter":91,"./dot/DotScreenFilter":92,"./dropshadow/DropShadowFilter":94,"./gray/GrayFilter":95,"./invert/InvertFilter":97,"./noise/NoiseFilter":98,"./pixelate/PixelateFilter":99,"./rgb/RGBSplitFilter":100,"./sepia/SepiaFilter":101,"./shockwave/ShockwaveFilter":102,"./tiltshift/TiltShiftFilter":104,"./tiltshift/TiltShiftXFilter":105,"./tiltshift/TiltShiftYFilter":106,"./twist/TwistFilter":107}],97:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This inverts your Display Objects colors.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function InvertFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform float invert;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);\n}\n",
        // custom uniforms
        {
            invert: { type: '1f', value: 1 }
        }
    );
}

InvertFilter.prototype = Object.create(core.AbstractFilter.prototype);
InvertFilter.prototype.constructor = InvertFilter;
module.exports = InvertFilter;

Object.defineProperties(InvertFilter.prototype, {
    /**
     * The strength of the invert. `1` will fully invert the colors, and
     * `0` will make the object its normal color.
     *
     * @member {number}
     * @memberof PIXI.filters.InvertFilter#
     */
    invert: {
        get: function ()
        {
            return this.uniforms.invert.value;
        },
        set: function (value)
        {
            this.uniforms.invert.value = value;
        }
    }
});

},{"../../core":23}],98:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Vico @vicocotea
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js
 */

/**
 * A Noise effect filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function NoiseFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float noise;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    float diff = (rand(vTextureCoord) - 0.5) * noise;\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    gl_FragColor = color;\n}\n",
        // custom uniforms
        {
            noise: { type: '1f', value: 0.5 }
        }
    );
}

NoiseFilter.prototype = Object.create(core.AbstractFilter.prototype);
NoiseFilter.prototype.constructor = NoiseFilter;
module.exports = NoiseFilter;

Object.defineProperties(NoiseFilter.prototype, {
    /**
     * The amount of noise to apply.
     *
     * @member {number}
     * @memberof PIXI.filters.NoiseFilter#
     * @default 0.5
     */
    noise: {
        get: function ()
        {
            return this.uniforms.noise.value;
        },
        set: function (value)
        {
            this.uniforms.noise.value = value;
        }
    }
});

},{"../../core":23}],99:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This filter applies a pixelate effect making display objects appear 'blocky'.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function PixelateFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 dimensions;\nuniform vec2 pixelSize;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord;\n\n    vec2 size = dimensions.xy / pixelSize;\n\n    vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;\n\n    gl_FragColor = texture2D(uSampler, color);\n}\n",
        // custom uniforms
        {
            dimensions: { type: '4fv',  value: new Float32Array([0, 0, 0, 0]) },
            pixelSize:  { type: 'v2',   value: { x: 10, y: 10 } }
        }
    );
}

PixelateFilter.prototype = Object.create(core.AbstractFilter.prototype);
PixelateFilter.prototype.constructor = PixelateFilter;
module.exports = PixelateFilter;

Object.defineProperties(PixelateFilter.prototype, {
    /**
     * This a point that describes the size of the blocks.
     * x is the width of the block and y is the height.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.PixelateFilter#
     */
    size: {
        get: function ()
        {
            return this.uniforms.pixelSize.value;
        },
        set: function (value)
        {
            this.uniforms.pixelSize.value = value;
        }
    }
});

},{"../../core":23}],100:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * An RGB Split Filter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function RGBSplitFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 dimensions;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n",
        // custom uniforms
        {
            red:        { type: 'v2', value: { x: 20, y: 20 } },
            green:      { type: 'v2', value: { x: -20, y: 20 } },
            blue:       { type: 'v2', value: { x: 20, y: -20 } },
            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
        }
    );
}

RGBSplitFilter.prototype = Object.create(core.AbstractFilter.prototype);
RGBSplitFilter.prototype.constructor = RGBSplitFilter;
module.exports = RGBSplitFilter;

Object.defineProperties(RGBSplitFilter.prototype, {
    /**
     * Red channel offset.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.RGBSplitFilter#
     */
    red: {
        get: function ()
        {
            return this.uniforms.red.value;
        },
        set: function (value)
        {
            this.uniforms.red.value = value;
        }
    },

    /**
     * Green channel offset.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.RGBSplitFilter#
     */
    green: {
        get: function ()
        {
            return this.uniforms.green.value;
        },
        set: function (value)
        {
            this.uniforms.green.value = value;
        }
    },

    /**
     * Blue offset.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.RGBSplitFilter#
     */
    blue: {
        get: function ()
        {
            return this.uniforms.blue.value;
        },
        set: function (value)
        {
            this.uniforms.blue.value = value;
        }
    }
});

},{"../../core":23}],101:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This applies a sepia effect to your Display Objects.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function SepiaFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float sepia;\n\nconst mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);\n}\n",
        // custom uniforms
        {
            sepia: { type: '1f', value: 1 }
        }
    );
}

SepiaFilter.prototype = Object.create(core.AbstractFilter.prototype);
SepiaFilter.prototype.constructor = SepiaFilter;
module.exports = SepiaFilter;

Object.defineProperties(SepiaFilter.prototype, {
    /**
     * The strength of the sepia. `1` will apply the full sepia effect, and
     * `0` will make the object its normal color.
     *
     * @member {number}
     * @memberof PIXI.filters.SepiaFilter#
     */
    sepia: {
        get: function ()
        {
            return this.uniforms.sepia.value;
        },
        set: function (value)
        {
            this.uniforms.sepia.value = value;
        }
    }
});

},{"../../core":23}],102:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function ShockwaveFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nuniform vec2 center;\nuniform vec3 params; // 10.0, 0.8, 0.1\nuniform float time;\n\nvoid main()\n{\n    vec2 uv = vTextureCoord;\n    vec2 texCoord = uv;\n\n    float dist = distance(uv, center);\n\n    if ( (dist <= (time + params.z)) && (dist >= (time - params.z)) )\n    {\n        float diff = (dist - time);\n        float powDiff = 1.0 - pow(abs(diff*params.x), params.y);\n\n        float diffTime = diff  * powDiff;\n        vec2 diffUV = normalize(uv - center);\n        texCoord = uv + (diffUV * diffTime);\n    }\n\n    gl_FragColor = texture2D(uSampler, texCoord);\n}\n",
        // custom uniforms
        {
            center: { type: 'v2', value: { x: 0.5, y: 0.5 } },
            params: { type: 'v3', value: { x: 10, y: 0.8, z: 0.1 } },
            time: { type: '1f', value: 0 }
        }
    );
}

ShockwaveFilter.prototype = Object.create(core.AbstractFilter.prototype);
ShockwaveFilter.prototype.constructor = ShockwaveFilter;
module.exports = ShockwaveFilter;

Object.defineProperties(ShockwaveFilter.prototype, {
    /**
     * Sets the center of the shockwave in normalized screen coords. That is
     * (0,0) is the top-left and (1,1) is the bottom right.
     *
     * @member {object<string, number>}
     * @memberof PIXI.filters.ShockwaveFilter#
     */
    center: {
        get: function ()
        {
            return this.uniforms.center.value;
        },
        set: function (value)
        {
            this.uniforms.center.value = value;
        }
    },
    /**
     * Sets the params of the shockwave. These modify the look and behavior of
     * the shockwave as it ripples out.
     *
     * @member {object<string, number>}
     * @memberof PIXI.filters.ShockwaveFilter#
     */
    params: {
        get: function ()
        {
            return this.uniforms.params.value;
        },
        set: function (value)
        {
            this.uniforms.params.value = value;
        }
    },
    /**
     * Sets the elapsed time of the shockwave. This controls the speed at which
     * the shockwave ripples out.
     *
     * @member {number}
     * @memberof PIXI.filters.ShockwaveFilter#
     */
    time: {
        get: function ()
        {
            return this.uniforms.time.value;
        },
        set: function (value)
        {
            this.uniforms.time.value = value;
        }
    }
});

},{"../../core":23}],103:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftAxisFilter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function TiltShiftAxisFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n",
        // custom uniforms
        {
            blur:           { type: '1f', value: 100 },
            gradientBlur:   { type: '1f', value: 600 },
            start:          { type: 'v2', value: { x: 0,    y: window.innerHeight / 2 } },
            end:            { type: 'v2', value: { x: 600,  y: window.innerHeight / 2 } },
            delta:          { type: 'v2', value: { x: 30,   y: 30 } },
            texSize:        { type: 'v2', value: { x: window.innerWidth, y: window.innerHeight } }
        }
    );

    this.updateDelta();
}

TiltShiftAxisFilter.prototype = Object.create(core.AbstractFilter.prototype);
TiltShiftAxisFilter.prototype.constructor = TiltShiftAxisFilter;
module.exports = TiltShiftAxisFilter;

/**
 * Updates the filter delta values.
 * This is overridden in the X and Y filters, does nothing for this class.
 *
 */
TiltShiftAxisFilter.prototype.updateDelta = function ()
{
    this.uniforms.delta.value.x = 0;
    this.uniforms.delta.value.y = 0;
};

Object.defineProperties(TiltShiftAxisFilter.prototype, {
    /**
     * The strength of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    blur: {
        get: function ()
        {
            return this.uniforms.blur.value;
        },
        set: function (value)
        {
            this.uniforms.blur.value = value;
        }
    },

    /**
     * The strength of the gradient blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    gradientBlur: {
        get: function ()
        {
            return this.uniforms.gradientBlur.value;
        },
        set: function (value)
        {
            this.uniforms.gradientBlur.value = value;
        }
    },

    /**
     * The X value to start the effect at.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    start: {
        get: function ()
        {
            return this.uniforms.start.value;
        },
        set: function (value)
        {
            this.uniforms.start.value = value;
            this.updateDelta();
        }
    },

    /**
     * The X value to end the effect at.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.TiltShiftAxisFilter#
     */
    end: {
        get: function ()
        {
            return this.uniforms.end.value;
        },
        set: function (value)
        {
            this.uniforms.end.value = value;
            this.updateDelta();
        }
    }
});

},{"../../core":23}],104:[function(require,module,exports){
var core = require('../../core'),
    TiltShiftXFilter = require('./TiltShiftXFilter'),
    TiltShiftYFilter = require('./TiltShiftYFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShift Filter. Manages the pass of both a TiltShiftXFilter and TiltShiftYFilter.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function TiltShiftFilter()
{
    core.AbstractFilter.call(this);

    this.tiltShiftXFilter = new TiltShiftXFilter();
    this.tiltShiftYFilter = new TiltShiftYFilter();
}

TiltShiftFilter.prototype = Object.create(core.AbstractFilter.prototype);
TiltShiftFilter.prototype.constructor = TiltShiftFilter;
module.exports = TiltShiftFilter;

TiltShiftFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    this.tiltShiftXFilter.applyFilter(renderer, input, renderTarget);

    this.tiltShiftYFilter.applyFilter(renderer, renderTarget, output);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(TiltShiftFilter.prototype, {
    /**
     * The strength of the blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    blur: {
        get: function ()
        {
            return this.tiltShiftXFilter.blur;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = value;
        }
    },

    /**
     * The strength of the gradient blur.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    gradientBlur: {
        get: function ()
        {
            return this.tiltShiftXFilter.gradientBlur;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = value;
        }
    },

    /**
     * The Y value to start the effect at.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    start: {
        get: function ()
        {
            return this.tiltShiftXFilter.start;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = value;
        }
    },

    /**
     * The Y value to end the effect at.
     *
     * @member {number}
     * @memberof PIXI.filters.TiltShiftFilter#
     */
    end: {
        get: function ()
        {
            return this.tiltShiftXFilter.end;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = value;
        }
    }
});

},{"../../core":23,"./TiltShiftXFilter":105,"./TiltShiftYFilter":106}],105:[function(require,module,exports){
var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftXFilter.
 *
 * @class
 * @extends PIXI.TiltShiftAxisFilter
 * @memberof PIXI.filters
 */
function TiltShiftXFilter()
{
    TiltShiftAxisFilter.call(this);
}

TiltShiftXFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
TiltShiftXFilter.prototype.constructor = TiltShiftXFilter;
module.exports = TiltShiftXFilter;

/**
 * Updates the filter delta values.
 *
 */
TiltShiftXFilter.prototype.updateDelta = function ()
{
    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
    var d = Math.sqrt(dx * dx + dy * dy);

    this.uniforms.delta.value.x = dx / d;
    this.uniforms.delta.value.y = dy / d;
};

},{"./TiltShiftAxisFilter":103}],106:[function(require,module,exports){
var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftYFilter.
 *
 * @class
 * @extends PIXI.TiltShiftAxisFilter
 * @memberof PIXI.filters
 */
function TiltShiftYFilter()
{
    TiltShiftAxisFilter.call(this);
}

TiltShiftYFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
TiltShiftYFilter.prototype.constructor = TiltShiftYFilter;
module.exports = TiltShiftYFilter;

/**
 * Updates the filter delta values.
 *
 */
TiltShiftYFilter.prototype.updateDelta = function ()
{
    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
    var d = Math.sqrt(dx * dx + dy * dy);

    this.uniforms.delta.value.x = -dy / d;
    this.uniforms.delta.value.y = dx / d;
};

},{"./TiltShiftAxisFilter":103}],107:[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This filter applies a twist effect making display objects appear twisted in the given direction.
 *
 * @class
 * @extends PIXI.AbstractFilter
 * @memberof PIXI.filters
 */
function TwistFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\n\nvoid main(void)\n{\n   vec2 coord = vTextureCoord - offset;\n   float dist = length(coord);\n\n   if (dist < radius)\n   {\n       float ratio = (radius - dist) / radius;\n       float angleMod = ratio * ratio * angle;\n       float s = sin(angleMod);\n       float c = cos(angleMod);\n       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n   }\n\n   gl_FragColor = texture2D(uSampler, coord+offset);\n}\n",
        // custom uniforms
        {
            radius:     { type: '1f', value: 0.5 },
            angle:      { type: '1f', value: 5 },
            offset:     { type: 'v2', value: { x: 0.5, y: 0.5 } }
        }
    );
}

TwistFilter.prototype = Object.create(core.AbstractFilter.prototype);
TwistFilter.prototype.constructor = TwistFilter;
module.exports = TwistFilter;

Object.defineProperties(TwistFilter.prototype, {
    /**
     * This point describes the the offset of the twist.
     *
     * @member {PIXI.Point}
     * @memberof PIXI.filters.TwistFilter#
     */
    offset: {
        get: function ()
        {
            return this.uniforms.offset.value;
        },
        set: function (value)
        {
            this.uniforms.offset.value = value;
        }
    },

    /**
     * This radius of the twist.
     *
     * @member {number}
     * @memberof PIXI.filters.TwistFilter#
     */
    radius: {
        get: function ()
        {
            return this.uniforms.radius.value;
        },
        set: function (value)
        {
            this.uniforms.radius.value = value;
        }
    },

    /**
     * This angle of the twist.
     *
     * @member {number}
     * @memberof PIXI.filters.TwistFilter#
     */
    angle: {
        get: function ()
        {
            return this.uniforms.angle.value;
        },
        set: function (value)
        {
            this.uniforms.angle.value = value;
        }
    }
});

},{"../../core":23}],108:[function(require,module,exports){
(function (global){
// run the polyfills
require('./polyfill');

var core = module.exports = require('./core');

// add core plugins.
core.extras         = require('./extras');
core.filters        = require('./filters');
core.interaction    = require('./interaction');
core.loaders        = require('./loaders');
core.mesh           = require('./mesh');
core.accessibility  = require('./accessibility');

// export a premade loader instance
/**
 * A premade instance of the loader that can be used to loader resources.
 *
 * @name loader
 * @memberof PIXI
 * @property {PIXI.loaders.Loader}
 */
core.loader = new core.loaders.Loader();

// mixin the deprecation features.
Object.assign(core, require('./deprecation'));

// Always export pixi globally.
global.PIXI = core;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./accessibility":15,"./core":23,"./deprecation":72,"./extras":79,"./filters":96,"./interaction":111,"./loaders":114,"./mesh":121,"./polyfill":126}],109:[function(require,module,exports){
var core = require('../core');

/**
 * Holds all information related to an Interaction event
 *
 * @class
 * @memberof PIXI.interaction
 */
function InteractionData()
{
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @member {PIXI.Point}
     */
    this.global = new core.Point();

    /**
     * The target Sprite that was interacted with
     *
     * @member {PIXI.Sprite}
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @member {Event}
     */
    this.originalEvent = null;
}

InteractionData.prototype.constructor = InteractionData;
module.exports = InteractionData;

/**
 * This will return the local coordinates of the specified displayObject for this InteractionData
 *
 * @param displayObject {PIXI.DisplayObject} The DisplayObject that you would like the local coords off
 * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new point)
 * @param [globalPos] {PIXI.Point} A Point object containing your custom global coords, optional (otherwise will use the current global coords)
 * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject
 */
InteractionData.prototype.getLocalPosition = function (displayObject, point, globalPos)
{
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
};

},{"../core":23}],110:[function(require,module,exports){
var core = require('../core'),
    InteractionData = require('./InteractionData');

// Mix interactiveTarget into core.DisplayObject.prototype
Object.assign(
    core.DisplayObject.prototype,
    require('./interactiveTarget')
);

/**
 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * @class
 * @memberof PIXI.interaction
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer
 * @param [options] {object}
 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.
 */
function InteractionManager(renderer, options)
{
    options = options || {};

    /**
     * The renderer this interaction manager works for.
     *
     * @member {PIXI.SystemRenderer}
     */
    this.renderer = renderer;

    /**
     * Should default browser actions automatically be prevented.
     *
     * @member {boolean}
     * @default true
     */
    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;

    /**
     * As this frequency increases the interaction events will be checked more often.
     *
     * @member {number}
     * @default 10
     */
    this.interactionFrequency = options.interactionFrequency || 10;

    /**
     * The mouse data
     *
     * @member {PIXI.interaction.InteractionData}
     */
    this.mouse = new InteractionData();

    /**
     * An event data object to handle all the event tracking/dispatching
     *
     * @member {object}
     */
    this.eventData = {
        stopped: false,
        target: null,
        type: null,
        data: this.mouse,
        stopPropagation:function(){
            this.stopped = true;
        }
    };

    /**
     * Tiny little interactiveData pool !
     *
     * @member {PIXI.interaction.InteractionData[]}
     */
    this.interactiveDataPool = [];

    /**
     * The DOM element to bind to.
     *
     * @member {HTMLElement}
     * @private
     */
    this.interactionDOMElement = null;

    /**
     * Have events been attached to the dom element?
     *
     * @member {boolean}
     * @private
     */
    this.eventsAdded = false;

    //this will make it so that you don't have to call bind all the time

    /**
     * @member {Function}
     */
    this.onMouseUp = this.onMouseUp.bind(this);
    this.processMouseUp = this.processMouseUp.bind( this );


    /**
     * @member {Function}
     */
    this.onMouseDown = this.onMouseDown.bind(this);
    this.processMouseDown = this.processMouseDown.bind( this );

    /**
     * @member {Function}
     */
    this.onMouseMove = this.onMouseMove.bind( this );
    this.processMouseMove = this.processMouseMove.bind( this );

    /**
     * @member {Function}
     */
    this.onMouseOut = this.onMouseOut.bind(this);
    this.processMouseOverOut = this.processMouseOverOut.bind( this );


    /**
     * @member {Function}
     */
    this.onTouchStart = this.onTouchStart.bind(this);
    this.processTouchStart = this.processTouchStart.bind(this);

    /**
     * @member {Function}
     */
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.processTouchEnd = this.processTouchEnd.bind(this);

    /**
     * @member {Function}
     */
    this.onTouchMove = this.onTouchMove.bind(this);
    this.processTouchMove = this.processTouchMove.bind(this);

    /**
     * @member {number}
     */
    this.last = 0;

    /**
     * The css style of the cursor that is being used
     * @member {string}
     */
    this.currentCursorStyle = 'inherit';

    /**
     * Internal cached var
     * @member {PIXI.Point}
     * @private
     */
    this._tempPoint = new core.Point();

    /**
     * The current resolution
     * @member {number}
     */
    this.resolution = 1;

    this.setTargetElement(this.renderer.view, this.renderer.resolution);
}

InteractionManager.prototype.constructor = InteractionManager;
module.exports = InteractionManager;

/**
 * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
 * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
 * another DOM element to receive those events.
 *
 * @param element {HTMLElement} the DOM element which will receive mouse and touch events.
 * @param [resolution=1] {number} THe resolution of the new element (relative to the canvas).
 * @private
 */
InteractionManager.prototype.setTargetElement = function (element, resolution)
{
    this.removeEvents();

    this.interactionDOMElement = element;

    this.resolution = resolution || 1;

    this.addEvents();
};

/**
 * Registers all the DOM events
 *
 * @private
 */
InteractionManager.prototype.addEvents = function ()
{
    if (!this.interactionDOMElement)
    {
        return;
    }

    core.ticker.shared.add(this.update, this);

    if (window.navigator.msPointerEnabled)
    {
        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
        this.interactionDOMElement.style['-ms-touch-action'] = 'none';
    }

    window.document.addEventListener('mousemove',    this.onMouseMove, true);
    this.interactionDOMElement.addEventListener('mousedown',    this.onMouseDown, true);
    this.interactionDOMElement.addEventListener('mouseout',     this.onMouseOut, true);

    this.interactionDOMElement.addEventListener('touchstart',   this.onTouchStart, true);
    this.interactionDOMElement.addEventListener('touchend',     this.onTouchEnd, true);
    this.interactionDOMElement.addEventListener('touchmove',    this.onTouchMove, true);

    window.addEventListener('mouseup',  this.onMouseUp, true);

    this.eventsAdded = true;
};

/**
 * Removes all the DOM events that were previously registered
 *
 * @private
 */
InteractionManager.prototype.removeEvents = function ()
{
    if (!this.interactionDOMElement)
    {
        return;
    }

    core.ticker.shared.remove(this.update);

    if (window.navigator.msPointerEnabled)
    {
        this.interactionDOMElement.style['-ms-content-zooming'] = '';
        this.interactionDOMElement.style['-ms-touch-action'] = '';
    }

    window.document.removeEventListener('mousemove', this.onMouseMove, true);
    this.interactionDOMElement.removeEventListener('mousedown', this.onMouseDown, true);
    this.interactionDOMElement.removeEventListener('mouseout',  this.onMouseOut, true);

    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
    this.interactionDOMElement.removeEventListener('touchend',  this.onTouchEnd, true);
    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);

    this.interactionDOMElement = null;

    window.removeEventListener('mouseup',  this.onMouseUp, true);

    this.eventsAdded = false;
};

/**
 * Updates the state of interactive objects.
 * Invoked by a throttled ticker update from
 * {@link PIXI.ticker.shared}.
 *
 * @param deltaTime {number}
 */
InteractionManager.prototype.update = function (deltaTime)
{
    this._deltaTime += deltaTime;

    if (this._deltaTime < this.interactionFrequency)
    {
        return;
    }

    this._deltaTime = 0;

    if (!this.interactionDOMElement)
    {
        return;
    }

    // if the user move the mouse this check has already been dfone using the mouse move!
    if(this.didMove)
    {
        this.didMove = false;
        return;
    }

    this.cursor = 'inherit';

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, true );

    if (this.currentCursorStyle !== this.cursor)
    {
        this.currentCursorStyle = this.cursor;
        this.interactionDOMElement.style.cursor = this.cursor;
    }

    //TODO
};

/**
 * Dispatches an event on the display object that was interacted with
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the display object in question
 * @param eventString {string} the name of the event (e.g, mousedown)
 * @param eventData {object} the event data object
 * @private
 */
InteractionManager.prototype.dispatchEvent = function ( displayObject, eventString, eventData )
{
    if(!eventData.stopped)
    {
        eventData.target = displayObject;
        eventData.type = eventString;

        displayObject.emit( eventString, eventData );

        if( displayObject[eventString] )
        {
            displayObject[eventString]( eventData );
        }
    }
};

/**
 * Maps x and y coords from a DOM object and maps them correctly to the pixi view. The resulting value is stored in the point.
 * This takes into account the fact that the DOM element could be scaled and positioned anywhere on the screen.
 *
 * @param  {PIXI.Point} point the point that the result will be stored in
 * @param  {number} x     the x coord of the position to map
 * @param  {number} y     the y coord of the position to map
 */
InteractionManager.prototype.mapPositionToPoint = function ( point, x, y )
{
    var rect = this.interactionDOMElement.getBoundingClientRect();
    point.x = ( ( x - rect.left ) * (this.interactionDOMElement.width  / rect.width  ) ) / this.resolution;
    point.y = ( ( y - rect.top  ) * (this.interactionDOMElement.height / rect.height ) ) / this.resolution;
};

/**
 * This function is provides a neat way of crawling through the scene graph and running a specified function on all interactive objects it finds.
 * It will also take care of hit testing the interactive objects and passes the hit across in the function.
 *
 * @param  {PIXI.Point} point the point that is tested for collision
 * @param  {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject the displayObject that will be hit test (recurcsivly crawls its children)
 * @param  {Function} func the function that will be called on each interactive object. The displayObject and hit will be passed to the function
 * @param  {boolean} hitTest this indicates if the objects inside should be hit test against the point
 * @return {boolean} returns true if the displayObject hit the point
 */
InteractionManager.prototype.processInteractive = function (point, displayObject, func, hitTest, interactive)
{
    if(!displayObject || !displayObject.visible)
    {
        return false;
    }

    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
    // 
    // This function will now loop through all objects and then only hit test the objects it HAS to, not all of them. MUCH faster..
    // An object will be hit test if the following is true:
    // 
    // 1: It is interactive.
    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
    // 
    // As another little optimisation once an interactive object has been hit we can carry on through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
    // A final optimisation is that an object is not hit test directly if a child has already been hit.
    
    var hit = false,
        interactiveParent = interactive = displayObject.interactive || interactive;

    // if the displayobject has a hitArea, then it does not need to hitTest children.
    if(displayObject.hitArea)
    {
        interactiveParent = false;
    }

    // ** FREE TIP **! If an object is not interacttive or has no buttons in it (such as a game scene!) set interactiveChildren to false for that displayObject.
    // This will allow pixi to completly ignore and bypass checking the displayObjects children.
    if(displayObject.interactiveChildren)
    {       
        var children = displayObject.children;
        
        for (var i = children.length-1; i >= 0; i--)
        {
            // time to get recursive.. if this function will return if somthing is hit..
            if( this.processInteractive(point, children[i], func, hitTest, interactiveParent) )
            {
                hit = true;

                // we no longer need to hit test any more objects in this container as we we now know the parent has been hit
                interactiveParent = false;
                
                // If the child is interactive , that means that the object hit was actually interactive and not just the child of an interactive object. 
                // This means we no longer need to hit test anything else. We still need to run through all objects, but we don't need to perform any hit tests.
                if(children[i].interactive)
                {
                    hitTest = false;
                }
            }
        }
    }

    // no point running this if the item is not interactive or does not have an interactive parent.
    if(interactive)
    {
        // if we are hit testing (as in we have no hit any objects yet)
        // We also don't need to worry about hit testing if once of the displayObjects children has already been hit!
        if(hitTest && !hit)
        {  
            if(displayObject.hitArea)
            {
                displayObject.worldTransform.applyInverse(point,  this._tempPoint);
                hit = displayObject.hitArea.contains( this._tempPoint.x, this._tempPoint.y );
            }
            else if(displayObject.containsPoint)
            {
                hit = displayObject.containsPoint(point);
            }
        }

        if(displayObject.interactive)
        {
            func(displayObject, hit); 
        }
    }

    return hit;
  
};


/**
 * Is called when the mouse button is pressed down on the renderer element
 *
 * @param event {Event} The DOM event of a mouse button being pressed down
 * @private
 */
InteractionManager.prototype.onMouseDown = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    // Update internal mouse reference
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    if (this.autoPreventDefault)
    {
        this.mouse.originalEvent.preventDefault();
    }

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, true );
};

/**
 * Processes the result of the mouse down check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the dispay object
 * @private
 */
InteractionManager.prototype.processMouseDown = function ( displayObject, hit )
{
    var e = this.mouse.originalEvent;
    
    var isRightButton = e.button === 2 || e.which === 3;

    if(hit)
    {
        displayObject[ isRightButton ? '_isRightDown' : '_isLeftDown' ] = true;
        this.dispatchEvent( displayObject, isRightButton ? 'rightdown' : 'mousedown', this.eventData );
    }
};



/**
 * Is called when the mouse button is released on the renderer element
 *
 * @param event {Event} The DOM event of a mouse button being released
 * @private
 */
InteractionManager.prototype.onMouseUp = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    // Update internal mouse reference
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, true );
};

/**
 * Processes the result of the mouse up check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseUp = function ( displayObject, hit )
{
    var e = this.mouse.originalEvent;

    var isRightButton = e.button === 2 || e.which === 3;
    var isDown =  isRightButton ? '_isRightDown' : '_isLeftDown';

    if(hit)
    {
        this.dispatchEvent( displayObject, isRightButton ? 'rightup' : 'mouseup', this.eventData );

        if( displayObject[ isDown ] )
        {
            displayObject[ isDown ] = false;
            this.dispatchEvent( displayObject, isRightButton ? 'rightclick' : 'click', this.eventData );
        }
    }
    else
    {
        if( displayObject[ isDown ] )
        {
            displayObject[ isDown ] = false;
            this.dispatchEvent( displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', this.eventData );
        }
    }
};


/**
 * Is called when the mouse moves across the renderer element
 *
 * @param event {Event} The DOM event of the mouse moving
 * @private
 */
InteractionManager.prototype.onMouseMove = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    this.didMove = true;

    this.cursor = 'inherit';

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, true );

    if (this.currentCursorStyle !== this.cursor)
    {
        this.currentCursorStyle = this.cursor;
        this.interactionDOMElement.style.cursor = this.cursor;
    }

    //TODO BUG for parents ineractive object (border order issue)
};

/**
 * Processes the result of the mouse move check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseMove = function ( displayObject, hit )
{
    this.dispatchEvent( displayObject, 'mousemove', this.eventData);
    this.processMouseOverOut(displayObject, hit);
};


/**
 * Is called when the mouse is moved out of the renderer element
 *
 * @param event {Event} The DOM event of a mouse being moved out
 * @private
 */
InteractionManager.prototype.onMouseOut = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.stopped = false;

    // Update internal mouse reference
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    this.interactionDOMElement.style.cursor = 'inherit';

    // TODO optimize by not check EVERY TIME! maybe half as often? //
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY );

    this.processInteractive( this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, false );
};

/**
 * Processes the result of the mouse over/out check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseOverOut = function ( displayObject, hit )
{
    if(hit)
    {
        if(!displayObject._over)
        {
            displayObject._over = true;
            this.dispatchEvent( displayObject, 'mouseover', this.eventData );
        }

        if (displayObject.buttonMode)
        {
            this.cursor = displayObject.defaultCursor;
        }
    }
    else
    {
        if(displayObject._over)
        {
            displayObject._over = false;
            this.dispatchEvent( displayObject, 'mouseout', this.eventData);
        }
    }
};


/**
 * Is called when a touch is started on the renderer element
 *
 * @param event {Event} The DOM event of a touch starting on the renderer view
 * @private
 */
InteractionManager.prototype.onTouchStart = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];
        //TODO POOL
        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        this.eventData.data = touchData;
        this.eventData.stopped = false;

        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchStart, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of a touch check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchStart = function ( displayObject, hit )
{
    if(hit)
    {
        displayObject._touchDown = true;
        this.dispatchEvent( displayObject, 'touchstart', this.eventData );
    }
};


/**
 * Is called when a touch ends on the renderer element
 *
 * @param event {Event} The DOM event of a touch ending on the renderer view
 */
InteractionManager.prototype.onTouchEnd = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        //TODO this should be passed along.. no set
        this.eventData.data = touchData;
        this.eventData.stopped = false;


        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchEnd, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of the end of a touch and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchEnd = function ( displayObject, hit )
{
    if(hit)
    {
        this.dispatchEvent( displayObject, 'touchend', this.eventData );

        if( displayObject._touchDown )
        {
            displayObject._touchDown = false;
            this.dispatchEvent( displayObject, 'tap', this.eventData );
        }
    }
    else
    {
        if( displayObject._touchDown )
        {
            displayObject._touchDown = false;
            this.dispatchEvent( displayObject, 'touchendoutside', this.eventData );
        }
    }
};

/**
 * Is called when a touch is moved across the renderer element
 *
 * @param event {Event} The DOM event of a touch moving across the renderer view
 * @private
 */
InteractionManager.prototype.onTouchMove = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        this.eventData.data = touchData;
        this.eventData.stopped = false;

        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchMove, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of a touch move check and dispatches the event if need be
 *
 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchMove = function ( displayObject, hit )
{
    hit = hit;
    this.dispatchEvent( displayObject, 'touchmove', this.eventData);
};

/**
 * Grabs an interaction data object from the internal pool
 *
 * @param touchEvent {EventData} The touch event we need to pair with an interactionData object
 *
 * @private
 */
InteractionManager.prototype.getTouchData = function (touchEvent)
{
    var touchData = this.interactiveDataPool.pop();

    if(!touchData)
    {
        touchData = new InteractionData();
    }

    touchData.identifier = touchEvent.identifier;
    this.mapPositionToPoint( touchData.global, touchEvent.clientX, touchEvent.clientY );

    if(navigator.isCocoonJS)
    {
        touchData.global.x = touchData.global.x / this.resolution;
        touchData.global.y = touchData.global.y / this.resolution;
    }

    touchEvent.globalX = touchData.global.x;
    touchEvent.globalY = touchData.global.y;

    return touchData;
};

/**
 * Returns an interaction data object to the internal pool
 *
 * @param touchData {PIXI.interaction.InteractionData} The touch data object we want to return to the pool
 *
 * @private
 */
InteractionManager.prototype.returnTouchData = function ( touchData )
{
    this.interactiveDataPool.push( touchData );
};

/**
 * Destroys the interaction manager
 *
 */
InteractionManager.prototype.destroy = function () {
    this.removeEvents();

    this.renderer = null;

    this.mouse = null;

    this.eventData = null;

    this.interactiveDataPool = null;

    this.interactionDOMElement = null;

    this.onMouseUp = null;
    this.processMouseUp = null;


    this.onMouseDown = null;
    this.processMouseDown = null;

    this.onMouseMove = null;
    this.processMouseMove = null;

    this.onMouseOut = null;
    this.processMouseOverOut = null;


    this.onTouchStart = null;
    this.processTouchStart = null;

    this.onTouchEnd = null;
    this.processTouchEnd = null;

    this.onTouchMove = null;
    this.processTouchMove = null;

    this._tempPoint = null;
};

core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
core.CanvasRenderer.registerPlugin('interaction', InteractionManager);

},{"../core":23,"./InteractionData":109,"./interactiveTarget":112}],111:[function(require,module,exports){
/**
 * @file        Main export of the PIXI interactions library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.interaction
 */
module.exports = {
    InteractionData:    require('./InteractionData'),
    InteractionManager: require('./InteractionManager'),
    interactiveTarget:  require('./interactiveTarget')
};

},{"./InteractionData":109,"./InteractionManager":110,"./interactiveTarget":112}],112:[function(require,module,exports){
/**
 * Default property values of interactive objects
 * used by {@link PIXI.interaction.InteractionManager}.
 *
 * @mixin
 * @memberof PIXI.interaction
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.interaction.interactiveTarget
 *      );
 */
var interactiveTarget = {
    /**
     * @todo Needs docs.
     */
    interactive: false,
    /**
     * @todo Needs docs.
     */
    buttonMode: false,
    /**
     * @todo Needs docs.
     */
    interactiveChildren: true,
    /**
     * @todo Needs docs.
     */
    defaultCursor: 'pointer',

    // some internal checks..

    /**
     * @todo Needs docs.
     * @private
     */
    _over: false,
    /**
     * @todo Needs docs.
     * @private
     */
    _touchDown: false
};

module.exports = interactiveTarget;

},{}],113:[function(require,module,exports){
var Resource = require('resource-loader').Resource,
    core = require('../core'),
    extras = require('../extras'),
    path = require('path');


function parse(resource, texture) {
    var data = {};
    var info = resource.data.getElementsByTagName('info')[0];
    var common = resource.data.getElementsByTagName('common')[0];

    data.font = info.getAttribute('face');
    data.size = parseInt(info.getAttribute('size'), 10);
    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
    data.chars = {};

    //parse letters
    var letters = resource.data.getElementsByTagName('char');

    for (var i = 0; i < letters.length; i++)
    {
        var charCode = parseInt(letters[i].getAttribute('id'), 10);

        var textureRect = new core.Rectangle(
            parseInt(letters[i].getAttribute('x'), 10) + texture.frame.x,
            parseInt(letters[i].getAttribute('y'), 10) + texture.frame.y,
            parseInt(letters[i].getAttribute('width'), 10),
            parseInt(letters[i].getAttribute('height'), 10)
        );

        data.chars[charCode] = {
            xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
            yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
            xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
            kerning: {},
            texture: new core.Texture(texture.baseTexture, textureRect)

        };
    }

    //parse kernings
    var kernings = resource.data.getElementsByTagName('kerning');
    for (i = 0; i < kernings.length; i++)
    {
        var first = parseInt(kernings[i].getAttribute('first'), 10);
        var second = parseInt(kernings[i].getAttribute('second'), 10);
        var amount = parseInt(kernings[i].getAttribute('amount'), 10);

        data.chars[second].kerning[first] = amount;
    }

    resource.bitmapFont = data;

    // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3
    // but it's very likely to change
    extras.BitmapText.fonts[data.font] = data;
}


module.exports = function ()
{
    return function (resource, next)
    {
        // skip if no data or not xml data
        if (!resource.data || !resource.isXml)
        {
            return next();
        }

        // skip if not bitmap font data, using some silly duck-typing
        if (
            resource.data.getElementsByTagName('page').length === 0 ||
            resource.data.getElementsByTagName('info').length === 0 ||
            resource.data.getElementsByTagName('info')[0].getAttribute('face') === null
            )
        {
            return next();
        }

        var xmlUrl = path.dirname(resource.url);

        if (xmlUrl === '.') {
            xmlUrl = '';
        }

        if (this.baseUrl && xmlUrl) {
            // if baseurl has a trailing slash then add one to xmlUrl so the replace works below
            if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {
                xmlUrl += '/';
            }

            // remove baseUrl from xmlUrl
            xmlUrl = xmlUrl.replace(this.baseUrl, '');
        }

        // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.
        if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {
            xmlUrl += '/';
        }
        var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');
        if (core.utils.TextureCache[textureUrl]) {
            //reuse existing texture
            parse(resource, core.utils.TextureCache[textureUrl]);
            next();
        }
        else {
            var loadOptions = {
                crossOrigin: resource.crossOrigin,
                loadType: Resource.LOAD_TYPE.IMAGE,
                metadata: resource.metadata.imageMetadata
            };
            // load the texture for the font
            this.add(resource.name + '_image', textureUrl, loadOptions, function (res) {
                parse(resource, res.texture);
                next();
            });
        }
    };
};

},{"../core":23,"../extras":79,"path":2,"resource-loader":133}],114:[function(require,module,exports){
/**
 * @file        Main export of the PIXI loaders library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.loaders
 */
module.exports = {
    Loader:             require('./loader'),

    // parsers
    bitmapFontParser:   require('./bitmapFontParser'),
    spritesheetParser:  require('./spritesheetParser'),
    textureParser:      require('./textureParser'),
    Resource:           require('resource-loader').Resource
};

},{"./bitmapFontParser":113,"./loader":115,"./spritesheetParser":116,"./textureParser":117,"resource-loader":133}],115:[function(require,module,exports){
var ResourceLoader = require('resource-loader'),
    textureParser = require('./textureParser'),
    spritesheetParser = require('./spritesheetParser'),
    bitmapFontParser = require('./bitmapFontParser');

/**
 *
 * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader
 *
 * ```js
 * var loader = PIXI.loader; // pixi exposes a premade instance for you to use.
 * //or
 * var loader = new PIXI.loaders.Loader(); // you can also create your own if you want
 *
 * loader.add('bunny',"data/bunny.png");
 *
 * loader.once('complete',onAssetsLoaded);
 *
 * loader.load();
 * ```
 *
 * @class
 * @extends PIXI.ResourceLoader
 * @memberof PIXI.loaders
 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
 * @param [concurrency=10] {number} The number of resources to load concurrently.
 */
function Loader(baseUrl, concurrency)
{
    ResourceLoader.call(this, baseUrl, concurrency);

    for (var i = 0; i < Loader._pixiMiddleware.length; ++i) {
        this.use(Loader._pixiMiddleware[i]());
    }
}

Loader.prototype = Object.create(ResourceLoader.prototype);
Loader.prototype.constructor = Loader;

module.exports = Loader;

Loader._pixiMiddleware = [
    // parse any blob into more usable objects (e.g. Image)
    ResourceLoader.middleware.parsing.blob,
    // parse any Image objects into textures
    textureParser,
    // parse any spritesheet data into multiple textures
    spritesheetParser,
    // parse any spritesheet data into multiple textures
    bitmapFontParser
];

Loader.addPixiMiddleware = function (fn) {
    Loader._pixiMiddleware.push(fn);
};

// Add custom extentions
var Resource = ResourceLoader.Resource;

Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);

},{"./bitmapFontParser":113,"./spritesheetParser":116,"./textureParser":117,"resource-loader":133}],116:[function(require,module,exports){
var Resource = require('resource-loader').Resource,
    path = require('path'),
    core = require('../core');

module.exports = function ()
{
    return function (resource, next)
    {
        // skip if no data, its not json, or it isn't spritesheet data
        if (!resource.data || !resource.isJson || !resource.data.frames)
        {
            return next();
        }

        var loadOptions = {
            crossOrigin: resource.crossOrigin,
            loadType: Resource.LOAD_TYPE.IMAGE,
            metadata: resource.metadata.imageMetadata
        };
		
		//zhangyun, 2016.2.16, using url variable of a image instead of json file, 24890
		var theUrl = resource.url;
		var theIndex = theUrl.indexOf("?");
		//paras from url
		var colsCount = 0;
		var rowsCount = 0;
		var totalCount = 0;
		var fps = 10;
		
		//if we found parameters from url 
		if (-1 != theIndex){
				
			var urlParams = theUrl.substr(theIndex+1);
				
			//parse parameters
			urlParams = urlParams.split("&");
			// split param and value into individual pieces
			var imageUrl = null;
			
			for (var i=0; i<urlParams.length; i++)
			{
				var temp = urlParams[i].split("=");
				switch (i) {
					case 0:
						imageUrl = temp[1];
						break;
					case 1:
						colsCount = parseInt(temp[1]);
						break;
					case 2:
						rowsCount = parseInt(temp[1]);
						break;
					case 3:
						totalCount = parseInt(temp[1]);
						break;
					default:
						fps = parseInt(temp[1]);
						break;
					}
			}
				
			if ((imageUrl) && (colsCount) && (rowsCount) && (totalCount)) {
				//set the resource.data.meta 
				var meta = resource.data.meta;
				meta.image = imageUrl;
				meta.size.w = 0;
				meta.size.h = 0;
			}
		}
		
		//zhangyun, end of modification part 1

        var route = path.dirname(resource.url.replace(this.baseUrl, '')) + '/' ;
		if (-1 != theIndex){//if we have special url
			route = "";
		}

        var resolution = core.utils.getResolutionOfUrl( resource.url );

        // load the image for this sheet
        this.add(resource.name + '_image', route + resource.data.meta.image, loadOptions, function (res)
        {
            resource.textures = {};

            var frames = resource.data.frames;
			
			//zhangyun, we move para calculation here because we can get image size now
			//reconstruct frames data here
			if (-1 != theIndex){//if we have special url
				var meta = resource.data.meta;
				meta.size.w = res.texture.baseTexture.width;
				meta.size.h = res.texture.baseTexture.height;
						
				//set the frames data
				delete frames.frame1;
						
				var imageFilename = (resource.data.meta.image).replace(/^.*[\\\/]/, '');
						
				for (var i=0; i<totalCount; i++){
					var frameName = "" + i + "-" + imageFilename;
					var theFrame = {};
							
					theFrame.sourceSize = {};
					theFrame.sourceSize.w = Math.floor(meta.size.w / colsCount);
					theFrame.sourceSize.h = Math.floor(meta.size.h / rowsCount);
							
					theFrame.rotated = false;
					theFrame.trimmed = false;
							
					theFrame.spriteSourceSize = {};
					theFrame.spriteSourceSize.x = 0;
					theFrame.spriteSourceSize.y = 0;
					theFrame.spriteSourceSize.w = theFrame.sourceSize.w;
					theFrame.spriteSourceSize.h = theFrame.sourceSize.h;
							
					theFrame.frame = {};
					theFrame.frame.x = ( i % colsCount ) * theFrame.sourceSize.w;
					theFrame.frame.y = Math.floor( i / colsCount ) * theFrame.sourceSize.h;
					theFrame.frame.w = theFrame.sourceSize.w;
					theFrame.frame.h = theFrame.sourceSize.h;
							
					frames[frameName] = theFrame;
				}
			}
			//end
			
            for (var i in frames)
            {
                var rect = frames[i].frame;

                if (rect)
                {
                    var size = null;
                    var trim = null;

                    if (frames[i].rotated) {
                        size = new core.Rectangle(rect.x, rect.y, rect.h, rect.w);
                    }
                    else {
                        size = new core.Rectangle(rect.x, rect.y, rect.w, rect.h);
                    }

                    //  Check to see if the sprite is trimmed
                    if (frames[i].trimmed)
                    {
                        trim = new core.Rectangle(
                            frames[i].spriteSourceSize.x / resolution,
                            frames[i].spriteSourceSize.y / resolution,
                            frames[i].sourceSize.w / resolution,
                            frames[i].sourceSize.h / resolution
                         );
                    }

                    // flip the width and height!
                    if (frames[i].rotated)
                    {
                        var temp = size.width;
                        size.width = size.height;
                        size.height = temp;
                    }

                    size.x /= resolution;
                    size.y /= resolution;
                    size.width /= resolution;
                    size.height /= resolution;

                    resource.textures[i] = new core.Texture(res.texture.baseTexture, size, size.clone(), trim, frames[i].rotated);

                    // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                    core.utils.TextureCache[i] = resource.textures[i];
                }
            }

            next();
        });
    };
};

},{"../core":23,"path":2,"resource-loader":133}],117:[function(require,module,exports){
var core = require('../core');

module.exports = function ()
{
    return function (resource, next)
    {
        // create a new texture if the data is an Image object
        if (resource.data && resource.isImage)
        {
            var baseTexture = new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url));
            baseTexture.imageUrl = resource.url;
            resource.texture = new core.Texture(baseTexture);
            // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
            core.utils.BaseTextureCache[resource.url] = baseTexture;
            core.utils.TextureCache[resource.url] = resource.texture;
        }

        next();
    };
};

},{"../core":23}],118:[function(require,module,exports){
var core = require('../core'),
    tempPoint = new core.Point(),
    tempPolygon = new core.Polygon();

/**
 * Base mesh class
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.mesh
 * @param texture {PIXI.Texture} The texture to use
 * @param [vertices] {Float32Arrif you want to specify the vertices
 * @param [uvs] {Float32Array} if you want to specify the uvs
 * @param [indices] {Uint16Array} if you want to specify the indices
 * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts
 */
function Mesh(texture, vertices, uvs, indices, drawMode)
{
    core.Container.call(this);

    /**
     * The texture of the Mesh
     *
     * @member {PIXI.Texture}
     * @private
     */
    this._texture = null;

    /**
     * The Uvs of the Mesh
     *
     * @member {Float32Array}
     */
    this.uvs = uvs || new Float32Array([0, 0,
        1, 0,
        1, 1,
        0, 1]);

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = vertices || new Float32Array([0, 0,
        100, 0,
        100, 100,
        0, 100]);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    //  TODO auto generate this based on draw mode!
    this.indices = indices || new Uint16Array([0, 1, 3, 2]);

    /**
     * Whether the Mesh is dirty or not
     *
     * @member {boolean}
     */
    this.dirty = true;

    /**
     * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove any blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = core.BLEND_MODES.NORMAL;

    /**
     * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.
     *
     * @member {number}
     */
    this.canvasPadding = 0;

    /**
     * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts
     *
     * @member {number}
     * @see PIXI.mesh.Mesh.DRAW_MODES
     */
    this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;

    // run texture setter;
    this.texture = texture;

     /**
     * The default shader that is used if a mesh doesn't have a more specific one.
     *
     * @member {PIXI.Shader}
     */
    this.shader = null;
}

// constructor
Mesh.prototype = Object.create(core.Container.prototype);
Mesh.prototype.constructor = Mesh;
module.exports = Mesh;

Object.defineProperties(Mesh.prototype, {
    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.mesh.Mesh#
     */
    texture: {
        get: function ()
        {
            return  this._texture;
        },
        set: function (value)
        {
            if (this._texture === value)
            {
                return;
            }

            this._texture = value;

            if (value)
            {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded)
                {
                    this._onTextureUpdate();
                }
                else
                {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }
});

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} a reference to the WebGL renderer
 * @private
 */
Mesh.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.mesh);
    renderer.plugins.mesh.render(this);
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer}
 * @private
 */
Mesh.prototype._renderCanvas = function (renderer)
{
    var context = renderer.context;

    var transform = this.worldTransform;

    if (renderer.roundPixels)
    {
        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);
    }
    else
    {
        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    }

    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)
    {
        this._renderCanvasTriangleMesh(context);
    }
    else
    {
        this._renderCanvasTriangles(context);
    }
};

/**
 * Draws the object in Triangle Mesh mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangleMesh = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;

    var length = vertices.length / 2;
    // this.count++;

    for (var i = 0; i < length - 2; i++)
    {
        // draw some triangles!
        var index = i * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));
    }
};

/**
 * Draws the object in triangle mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangles = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;
    var indices = this.indices;

    var length = indices.length;
    // this.count++;

    for (var i = 0; i < length; i += 3)
    {
        // draw some triangles!
        var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
    }
};

/**
 * Draws one of the triangles that form this Mesh
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @param vertices {Float32Array} a reference to the vertices of the Mesh
 * @param uvs {Float32Array} a reference to the uvs of the Mesh
 * @param index0 {number} the index of the first vertex
 * @param index1 {number} the index of the second vertex
 * @param index2 {number} the index of the third vertex
 * @private
 */
Mesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2)
{
    var textureSource = this._texture.baseTexture.source;
    var textureWidth = this._texture.baseTexture.width;
    var textureHeight = this._texture.baseTexture.height;

    var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];
    var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];

    var u0 = uvs[index0] * textureWidth, u1 = uvs[index1] * textureWidth, u2 = uvs[index2] * textureWidth;
    var v0 = uvs[index0 + 1] * textureHeight, v1 = uvs[index1 + 1] * textureHeight, v2 = uvs[index2 + 1] * textureHeight;

    if (this.canvasPadding > 0)
    {
        var paddingX = this.canvasPadding / this.worldTransform.a;
        var paddingY = this.canvasPadding / this.worldTransform.d;
        var centerX = (x0 + x1 + x2) / 3;
        var centerY = (y0 + y1 + y2) / 3;

        var normX = x0 - centerX;
        var normY = y0 - centerY;

        var dist = Math.sqrt(normX * normX + normY * normY);
        x0 = centerX + (normX / dist) * (dist + paddingX);
        y0 = centerY + (normY / dist) * (dist + paddingY);

        //

        normX = x1 - centerX;
        normY = y1 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x1 = centerX + (normX / dist) * (dist + paddingX);
        y1 = centerY + (normY / dist) * (dist + paddingY);

        normX = x2 - centerX;
        normY = y2 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x2 = centerX + (normX / dist) * (dist + paddingX);
        y2 = centerY + (normY / dist) * (dist + paddingY);
    }

    context.save();
    context.beginPath();


    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);

    context.closePath();

    context.clip();

    // Compute matrix transform
    var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2);
    var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2);
    var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2);
    var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
    var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2);
    var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2);
    var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);

    context.transform(deltaA / delta, deltaD / delta,
        deltaB / delta, deltaE / delta,
        deltaC / delta, deltaF / delta);

    context.drawImage(textureSource, 0, 0);
    context.restore();
};



/**
 * Renders a flat Mesh
 *
 * @param Mesh {PIXI.mesh.Mesh} The Mesh to render
 * @private
 */
Mesh.prototype.renderMeshFlat = function (Mesh)
{
    var context = this.context;
    var vertices = Mesh.vertices;

    var length = vertices.length/2;
    // this.count++;

    context.beginPath();
    for (var i=1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4];
        var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5];

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
    }

    context.fillStyle = '#FF0000';
    context.fill();
    context.closePath();
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @param event
 * @private
 */
Mesh.prototype._onTextureUpdate = function ()
{
    this.updateFrame = true;
};

/**
 * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
 * @return {PIXI.Rectangle} the framing rectangle
 */
Mesh.prototype.getBounds = function (matrix)
{
    if (!this._currentBounds) {
        var worldTransform = matrix || this.worldTransform;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var maxX = -Infinity;
        var maxY = -Infinity;

        var minX = Infinity;
        var minY = Infinity;

        var vertices = this.vertices;
        for (var i = 0, n = vertices.length; i < n; i += 2) {
            var rawX = vertices[i], rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;

            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;

            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }

        if (minX === -Infinity || maxY === Infinity) {
            return core.Rectangle.EMPTY;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.width = maxX - minX;

        bounds.y = minY;
        bounds.height = maxY - minY;

        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

/**
 * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH
 *
 * @param point {PIXI.Point} the point to test
 * @return {boolean} the result of the test
 */
Mesh.prototype.containsPoint = function( point ) {
    if (!this.getBounds().contains(point.x, point.y)) {
        return false;
    }
    this.worldTransform.applyInverse(point,  tempPoint);

    var vertices = this.vertices;
    var points = tempPolygon.points;
    var i, len;

    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {
        var indices = this.indices;
        len = this.indices.length;
        //TODO: inline this.
        for (i=0;i<len;i+=3) {
            var ind0 = indices[i]*2, ind1 = indices[i+1]*2, ind2 = indices[i+2]*2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0+1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1+1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2+1];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
                return true;
            }
        }
    } else {
        len = vertices.length;
        for (i=0;i<len;i+=6) {
            points[0] = vertices[i];
            points[1] = vertices[i+1];
            points[2] = vertices[i+2];
            points[3] = vertices[i+3];
            points[4] = vertices[i+4];
            points[5] = vertices[i+5];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
                return true;
            }
        }
    }
    return false;
};

/**
 * Different drawing buffer modes supported
 *
 * @static
 * @constant
 * @property {object} DRAW_MODES
 * @property {number} DRAW_MODES.TRIANGLE_MESH
 * @property {number} DRAW_MODES.TRIANGLES
 */
Mesh.DRAW_MODES = {
    TRIANGLE_MESH: 0,
    TRIANGLES: 1
};

},{"../core":23}],119:[function(require,module,exports){
var Mesh = require('./Mesh');

/**
 * The Plane allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (var i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * var Plane = new PIXI.Plane(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 * @param {PIXI.Texture} texture - The texture to use on the Plane.
 * @param {int} segmentsX - The number ox x segments
 * @param {int} segmentsY - The number of y segments
 *
 */
function Plane(texture, segmentsX, segmentsY)
{
    Mesh.call(this, texture);

    /**
     * Tracker for if the Plane is ready to be drawn. Needed because Mesh ctor can
     * call _onTextureUpdated which could call refresh too early.
     *
     * @member {boolean}
     * @private
     */
    this._ready = true;

    this.segmentsX =  segmentsX || 10;
    this.segmentsY = segmentsY || 10;

    this.drawMode = Mesh.DRAW_MODES.TRIANGLES;
    this.refresh();

}


// constructor
Plane.prototype = Object.create( Mesh.prototype );
Plane.prototype.constructor = Plane;
module.exports = Plane;

/**
 * Refreshes
 *
 */
Plane.prototype.refresh = function()
{
    var total = this.segmentsX * this.segmentsY;
    var verts = [];
    var colors = [];
    var uvs = [];
    var indices = [];
    var texture = this.texture;

  //  texture.width = 800 texture.width || 800;
 //   texture.height = 800//texture.height || 800;

    var segmentsXSub = this.segmentsX - 1;
    var segmentsYSub = this.segmentsY - 1;
    var i = 0;

    // TODO MAP UVS..
    var sizeX = texture.width / segmentsXSub;
    var sizeY = texture.height / segmentsYSub;

    for (i = 0; i < total; i++) {

        var x = (i % this.segmentsX);
        var y = ( (i / this.segmentsX ) | 0 );


        verts.push((x * sizeX),
                   (y * sizeY));

        uvs.push(x / (this.segmentsX-1), y/ (this.segmentsY-1));
    }

    //  cons

    var totalSub = segmentsXSub * segmentsYSub;

    for (i = 0; i < totalSub; i++) {

        var xpos = i % segmentsXSub;
        var ypos = (i / segmentsXSub ) | 0;


        var  value = (ypos * this.segmentsX) + xpos;
        var  value2 = (ypos * this.segmentsX) + xpos + 1;
        var  value3 = ((ypos+1) * this.segmentsX) + xpos;
        var  value4 = ((ypos+1) * this.segmentsX) + xpos + 1;

        indices.push(value, value2, value3);
        indices.push(value2, value4, value3);
    }


    //console.log(indices)
    this.vertices = new Float32Array(verts);
    this.uvs = new Float32Array(uvs);
    this.colors = new Float32Array(colors);
    this.indices = new Uint16Array(indices);
};

/**
 * Clear texture UVs when new texture is set
 *
 * @private
 */
Plane.prototype._onTextureUpdate = function ()
{
    Mesh.prototype._onTextureUpdate.call(this);

    // wait for the Plane ctor to finish before calling refresh
    if (this._ready) {
        this.refresh();
    }
};

},{"./Mesh":118}],120:[function(require,module,exports){
var Mesh = require('./Mesh');
var core = require('../core');

/**
 * The rope allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (var i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * var rope = new PIXI.Rope(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 * @param {PIXI.Texture} texture - The texture to use on the rope.
 * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.
 *
 */
function Rope(texture, points)
{
    Mesh.call(this, texture);

    /*
     * @member {PIXI.Point[]} An array of points that determine the rope
     */
    this.points = points;

    /*
     * @member {Float32Array} An array of vertices used to construct this rope.
     */
    this.vertices = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} The WebGL Uvs of the rope.
     */
    this.uvs = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} An array containing the color components
     */
    this.colors = new Float32Array(points.length * 2);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = new Uint16Array(points.length * 2);

    /**
     * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can
     * call _onTextureUpdated which could call refresh too early.
     *
     * @member {boolean}
     * @private
     */
     this._ready = true;

     this.refresh();
}


// constructor
Rope.prototype = Object.create(Mesh.prototype);
Rope.prototype.constructor = Rope;
module.exports = Rope;

/**
 * Refreshes
 *
 */
Rope.prototype.refresh = function ()
{
    var points = this.points;

    // if too little points, or texture hasn't got UVs set yet just move on.
    if (points.length < 1 || !this._texture._uvs)
    {
        return;
    }

    var uvs = this.uvs;

    var indices = this.indices;
    var colors = this.colors;

    var textureUvs = this._texture._uvs;
    var offset = new core.Point(textureUvs.x0, textureUvs.y0);
    var factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);

    uvs[0] = 0 + offset.x;
    uvs[1] = 0 + offset.y;
    uvs[2] = 0 + offset.x;
    uvs[3] = 1 * factor.y + offset.y;

    colors[0] = 1;
    colors[1] = 1;

    indices[0] = 0;
    indices[1] = 1;

    var total = points.length,
        point, index, amount;

    for (var i = 1; i < total; i++)
    {
        point = points[i];
        index = i * 4;
        // time to do some smart drawing!
        amount = i / (total-1);

        uvs[index] = amount * factor.x + offset.x;
        uvs[index+1] = 0 + offset.y;

        uvs[index+2] = amount * factor.x + offset.x;
        uvs[index+3] = 1 * factor.y + offset.y;

        index = i * 2;
        colors[index] = 1;
        colors[index+1] = 1;

        index = i * 2;
        indices[index] = index;
        indices[index + 1] = index + 1;
    }

    this.dirty = true;
};

/**
 * Clear texture UVs when new texture is set
 *
 * @private
 */
Rope.prototype._onTextureUpdate = function ()
{
    Mesh.prototype._onTextureUpdate.call(this);

    // wait for the Rope ctor to finish before calling refresh
    if (this._ready) {
        this.refresh();
    }
};

/**
 * Updates the object transform for rendering
 *
 * @private
 */
Rope.prototype.updateTransform = function ()
{
    var points = this.points;

    if (points.length < 1)
    {
        return;
    }

    var lastPoint = points[0];
    var nextPoint;
    var perpX = 0;
    var perpY = 0;

    // this.count -= 0.2;

    var vertices = this.vertices;
    var total = points.length,
        point, index, ratio, perpLength, num;

    for (var i = 0; i < total; i++)
    {
        point = points[i];
        index = i * 4;

        if (i < points.length-1)
        {
            nextPoint = points[i+1];
        }
        else
        {
            nextPoint = point;
        }

        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;

        ratio = (1 - (i / (total-1))) * 10;

        if (ratio > 1)
        {
            ratio = 1;
        }

        perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        num = this._texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
        perpX /= perpLength;
        perpY /= perpLength;

        perpX *= num;
        perpY *= num;

        vertices[index] = point.x + perpX;
        vertices[index+1] = point.y + perpY;
        vertices[index+2] = point.x - perpX;
        vertices[index+3] = point.y - perpY;

        lastPoint = point;
    }

    this.containerUpdateTransform();
};

},{"../core":23,"./Mesh":118}],121:[function(require,module,exports){
/**
 * @file        Main export of the PIXI extras library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.mesh
 */
module.exports = {
    Mesh:           require('./Mesh'),
    Plane:           require('./Plane'),
    Rope:           require('./Rope'),
    MeshRenderer:   require('./webgl/MeshRenderer'),
    MeshShader:     require('./webgl/MeshShader')
};

},{"./Mesh":118,"./Plane":119,"./Rope":120,"./webgl/MeshRenderer":122,"./webgl/MeshShader":123}],122:[function(require,module,exports){
var core = require('../../core'),
    Mesh = require('../Mesh');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's MeshRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/MeshRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI.mesh
 * @extends PIXI.ObjectRenderer
 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
 */
function MeshRenderer(renderer)
{
    core.ObjectRenderer.call(this, renderer);


    /**
     * Holds the indices
     *
     * @member {Uint16Array}
     */
    
    this.indices = new Uint16Array(15000);

    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers
    for (var i=0, j=0; i < 15000; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    this.currentShader = null;
}

MeshRenderer.prototype = Object.create(core.ObjectRenderer.prototype);
MeshRenderer.prototype.constructor = MeshRenderer;
module.exports = MeshRenderer;

core.WebGLRenderer.registerPlugin('mesh', MeshRenderer);

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 */
MeshRenderer.prototype.onContextChange = function ()
{

};

/**
 * Renders the sprite object.
 *
 * @param mesh {PIXI.mesh.Mesh} the mesh to render
 */
MeshRenderer.prototype.render = function (mesh)
{
    if(!mesh._vertexBuffer)
    {
        this._initWebGL(mesh);
    }

    var renderer = this.renderer,
        gl = renderer.gl,
        texture = mesh._texture.baseTexture,
        shader = mesh.shader;// || renderer.shaderManager.plugins.meshShader;

    var drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;

    renderer.blendModeManager.setBlendMode(mesh.blendMode);

    //TODO cache custom state..
    if (!shader)
    {
        shader = renderer.shaderManager.plugins.meshShader;
    }
    else
    {
        shader = shader.shaders[gl.id] || shader.getShader(renderer);// : shader;
    }

    this.renderer.shaderManager.setShader(shader);

    shader.uniforms.translationMatrix.value = mesh.worldTransform.toArray(true);
    shader.uniforms.projectionMatrix.value = renderer.currentRenderTarget.projectionMatrix.toArray(true);
    shader.uniforms.alpha.value = mesh.worldAlpha;

    shader.syncUniforms();

    if (!mesh.dirty)
    {

        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, mesh.vertices);
        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);


        gl.activeTexture(gl.TEXTURE0);

       if (!texture._glTextures[gl.id])
        {
            this.renderer.updateTexture(texture);
        }
        else
        {
            // bind the current texture
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, mesh.indices);
    }
    else
    {

        mesh.dirty = false;
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

         gl.activeTexture(gl.TEXTURE0);

        if (!texture._glTextures[gl.id])
        {
            this.renderer.updateTexture(texture);
        }
        else
        {
            // bind the current texture
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }

        // dont need to upload!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);

    }

    gl.drawElements(drawMode, mesh.indices.length, gl.UNSIGNED_SHORT, 0);

};

/**
 * Prepares all the buffers to render this mesh
 * @param mesh {PIXI.mesh.Mesh} the mesh to render
 */
MeshRenderer.prototype._initWebGL = function (mesh)
{
    // build the strip!
    var gl = this.renderer.gl;

    mesh._vertexBuffer = gl.createBuffer();
    mesh._indexBuffer = gl.createBuffer();
    mesh._uvBuffer = gl.createBuffer();



    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER,  mesh.uvs, gl.STATIC_DRAW);

    if(mesh.colors){
        mesh._colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.colors, gl.STATIC_DRAW);
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
};


/**
 * Empties the current batch.
 *
 */
MeshRenderer.prototype.flush = function ()
{

};

/**
 * Starts a new mesh renderer.
 *
 */
MeshRenderer.prototype.start = function ()
{
    

    this.currentShader = null;
};

/**
 * Destroys the Mesh renderer
 *
 */
MeshRenderer.prototype.destroy = function ()
{
    core.ObjectRenderer.prototype.destroy.call(this);
};

},{"../../core":23,"../Mesh":118}],123:[function(require,module,exports){
var core = require('../../core');

/**
 * @class
 * @extends PIXI.Shader
 * @memberof PIXI.mesh
 * @param shaderManager {PIXI.ShaderManager} The WebGL shader manager this shader works for.
 */
function MeshShader(shaderManager)
{
    core.Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'precision lowp float;',
            'attribute vec2 aVertexPosition;',
            'attribute vec2 aTextureCoord;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'varying vec2 vTextureCoord;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vTextureCoord = aTextureCoord;',
            '}'
        ].join('\n'),
        [
            'precision lowp float;',

            'varying vec2 vTextureCoord;',
            'uniform float alpha;',

            'uniform sampler2D uSampler;',

            'void main(void){',
            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * alpha ;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            alpha:  { type: '1f', value: 0 },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // custom attributes
        {
            aVertexPosition:0,
            aTextureCoord:0
        }
    );
}

MeshShader.prototype = Object.create(core.Shader.prototype);
MeshShader.prototype.constructor = MeshShader;
module.exports = MeshShader;

core.ShaderManager.registerPlugin('meshShader', MeshShader);

},{"../../core":23}],124:[function(require,module,exports){
// References:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

if (!Math.sign)
{
    Math.sign = function (x) {
        x = +x;
        if (x === 0 || isNaN(x))
        {
            return x;
        }
        return x > 0 ? 1 : -1;
    };
}

},{}],125:[function(require,module,exports){
// References:
// https://github.com/sindresorhus/object-assign
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

if (!Object.assign)
{
    Object.assign = require('object-assign');
}

},{"object-assign":11}],126:[function(require,module,exports){
require('./Object.assign');
require('./requestAnimationFrame');
require('./Math.sign');

},{"./Math.sign":124,"./Object.assign":125,"./requestAnimationFrame":127}],127:[function(require,module,exports){
(function (global){
// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],128:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":3}],129:[function(require,module,exports){
'use strict';

//
// We store our EE objects in a plain object whose properties are event names.
// If `Object.create(null)` is not supported we prefix the event names with a
// `~` to make sure that the built-in object properties are not overridden or
// used as an attack vector.
// We also assume that `Object.create(null)` is available when the event name
// is an ES6 Symbol.
//
var prefix = typeof Object.create !== 'function' ? '~' : false;

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @param {Boolean} exists We only need to know if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events && this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (this._events[evt].fn) return [this._events[evt].fn];

  for (var i = 0, l = this._events[evt].length, ee = new Array(l); i < l; i++) {
    ee[i] = this._events[evt][i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Mixed} context Only remove listeners matching this context.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once && !listeners.once)
        || (context && listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i < length; i++) {
        if (
             listeners[i].fn !== fn
          || (once && !listeners[i].once)
          || (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Expose the module.
//
module.exports = EventEmitter;

},{}],130:[function(require,module,exports){
var async       = require('async'),
    urlParser   = require('url'),
    Resource    = require('./Resource'),
    EventEmitter = require('eventemitter3');

/**
 * Manages the state and loading of multiple resources to load.
 *
 * @class
 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
 * @param [concurrency=10] {number} The number of resources to load concurrently.
 */
function Loader(baseUrl, concurrency) {
    EventEmitter.call(this);

    concurrency = concurrency || 10;

    /**
     * The base url for all resources loaded by this loader.
     *
     * @member {string}
     */
    this.baseUrl = baseUrl || '';

    /**
     * The progress percent of the loader going through the queue.
     *
     * @member {number}
     */
    this.progress = 0;

    /**
     * Loading state of the loader, true if it is currently loading resources.
     *
     * @member {boolean}
     */
    this.loading = false;

    /**
     * The percentage of total progress that a single resource represents.
     *
     * @member {number}
     */
    this._progressChunk = 0;

    /**
     * The middleware to run before loading each resource.
     *
     * @member {function[]}
     */
    this._beforeMiddleware = [];

    /**
     * The middleware to run after loading each resource.
     *
     * @member {function[]}
     */
    this._afterMiddleware = [];

    /**
     * The `_loadResource` function bound with this object context.
     *
     * @private
     * @member {function}
     */
    this._boundLoadResource = this._loadResource.bind(this);

    /**
     * The `_onLoad` function bound with this object context.
     *
     * @private
     * @member {function}
     */
    this._boundOnLoad = this._onLoad.bind(this);

    /**
     * The resource buffer that fills until `load` is called to start loading resources.
     *
     * @private
     * @member {Resource[]}
     */
    this._buffer = [];

    /**
     * Used to track load completion.
     *
     * @private
     * @member {number}
     */
    this._numToLoad = 0;

    /**
     * The resources waiting to be loaded.
     *
     * @private
     * @member {Resource[]}
     */
    this._queue = async.queue(this._boundLoadResource, concurrency);

    /**
     * All the resources for this loader keyed by name.
     *
     * @member {object<string, Resource>}
     */
    this.resources = {};

    /**
     * Emitted once per loaded or errored resource.
     *
     * @event progress
     * @memberof Loader#
     */

    /**
     * Emitted once per errored resource.
     *
     * @event error
     * @memberof Loader#
     */

    /**
     * Emitted once per loaded resource.
     *
     * @event load
     * @memberof Loader#
     */

    /**
     * Emitted when the loader begins to process the queue.
     *
     * @event start
     * @memberof Loader#
     */

    /**
     * Emitted when the queued resources all load.
     *
     * @event complete
     * @memberof Loader#
     */
}

Loader.prototype = Object.create(EventEmitter.prototype);
Loader.prototype.constructor = Loader;
module.exports = Loader;

/**
 * Adds a resource (or multiple resources) to the loader queue.
 *
 * This function can take a wide variety of different parameters. The only thing that is always
 * required the url to load. All the following will work:
 *
 * ```js
 * loader
 *     // normal param syntax
 *     .add('key', 'http://...', function () {})
 *     .add('http://...', function () {})
 *     .add('http://...')
 *
 *     // object syntax
 *     .add({
 *         name: 'key2',
 *         url: 'http://...'
 *     }, function () {})
 *     .add({
 *         url: 'http://...'
 *     }, function () {})
 *     .add({
 *         name: 'key3',
 *         url: 'http://...'
 *         onComplete: function () {}
 *     })
 *     .add({
 *         url: 'https://...',
 *         onComplete: function () {},
 *         crossOrigin: true
 *     })
 *
 *     // you can also pass an array of objects or urls or both
 *     .add([
 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
 *         { url: 'http://...', onComplete: function () {} },
 *         'http://...'
 *     ]);
 * ```
 *
 * @alias enqueue
 * @param [name] {string} The name of the resource to load, if not passed the url is used.
 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
 * @param [options] {object} The options for the load.
 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
 *      loaded be interpreted when using XHR?
 * @param [callback] {function} Function to call when this specific resource completes loading.
 * @return {Loader}
 */
Loader.prototype.add = Loader.prototype.enqueue = function (name, url, options, cb) {
    // special case of an array of objects or urls
    if (Array.isArray(name)) {
        for (var i = 0; i < name.length; ++i) {
            this.add(name[i]);
        }

        return this;
    }

    // if an object is passed instead of params
    if (typeof name === 'object') {
        cb = url || name.callback || name.onComplete;
        options = name;
        url = name.url;
        name = name.name || name.key || name.url;
    }

    // case where no name is passed shift all args over by one.
    if (typeof url !== 'string') {
        cb = options;
        options = url;
        url = name;
    }

    // now that we shifted make sure we have a proper url.
    if (typeof url !== 'string') {
        throw new Error('No url passed to add resource to loader.');
    }

    // options are optional so people might pass a function and no options
    if (typeof options === 'function') {
        cb = options;
        options = null;
    }

    // check if resource already exists.
    if (this.resources[name]) {
        throw new Error('Resource with name "' + name + '" already exists.');
    }

    // add base url if this isn't an absolute url
    url = this._handleBaseUrl(url);

    // create the store the resource
    this.resources[name] = new Resource(name, url, options);

    if (typeof cb === 'function') {
        this.resources[name].once('afterMiddleware', cb);
    }

    this._numToLoad++;

    // if already loading add it to the worker queue
    if (this._queue.started) {
        this._queue.push(this.resources[name]);
        this._progressChunk = (100 - this.progress) / (this._queue.length() + this._queue.running());
    }
    // otherwise buffer it to be added to the queue later
    else {
        this._buffer.push(this.resources[name]);
        this._progressChunk = 100 / this._buffer.length;
    }

    return this;
};

Loader.prototype._handleBaseUrl = function (url) {
    var parsedUrl = urlParser.parse(url);

    // absolute url, just use it as is.
    if (parsedUrl.protocol || parsedUrl.pathname.indexOf('//') === 0) {
        return url;
    }

    // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween
    if (
        this.baseUrl.length &&
        this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 &&
        url.charAt(0) !== '/'
    ) {
        return this.baseUrl + '/' + url;
    }
    else {
        return this.baseUrl + url;
    }
};


/**
 * Sets up a middleware function that will run *before* the
 * resource is loaded.
 *
 * @alias pre
 * @param middleware {function} The middleware function to register.
 * @return {Loader}
 */
Loader.prototype.before = Loader.prototype.pre = function (fn) {
    this._beforeMiddleware.push(fn);

    return this;
};

/**
 * Sets up a middleware function that will run *after* the
 * resource is loaded.
 *
 * @alias use
 * @param middleware {function} The middleware function to register.
 * @return {Loader}
 */
Loader.prototype.after = Loader.prototype.use = function (fn) {
    this._afterMiddleware.push(fn);

    return this;
};

/**
 * Resets the queue of the loader to prepare for a new load.
 *
 * @return {Loader}
 */
Loader.prototype.reset = function () {
    // this.baseUrl = baseUrl || '';

    this.progress = 0;

    this.loading = false;

    this._progressChunk = 0;

    // this._beforeMiddleware.length = 0;
    // this._afterMiddleware.length = 0;

    this._buffer.length = 0;

    this._numToLoad = 0;

    this._queue.kill();
    this._queue.started = false;

    this.resources = {};
};

/**
 * Starts loading the queued resources.
 *
 * @fires start
 * @param [callback] {function} Optional callback that will be bound to the `complete` event.
 * @return {Loader}
 */
Loader.prototype.load = function (cb) {
    // register complete callback if they pass one
    if (typeof cb === 'function') {
        this.once('complete', cb);
    }

    // if the queue has already started we are done here
    if (this._queue.started) {
        return this;
    }

    // notify of start
    this.emit('start', this);

    // start the internal queue
    for (var i = 0; i < this._buffer.length; ++i) {
        this._queue.push(this._buffer[i]);
    }

    // empty the buffer
    this._buffer.length = 0;

    return this;
};

/**
 * Loads a single resource.
 *
 * @fires progress
 * @private
 */
Loader.prototype._loadResource = function (resource, dequeue) {
    var self = this;

    resource._dequeue = dequeue;

    this._runMiddleware(resource, this._beforeMiddleware, function () {
        // resource.on('progress', self.emit.bind(self, 'progress'));

        resource.load(self._boundOnLoad);
    });
};

/**
 * Called once each resource has loaded.
 *
 * @fires complete
 * @private
 */
Loader.prototype._onComplete = function () {
    this.emit('complete', this, this.resources);
};

/**
 * Called each time a resources is loaded.
 *
 * @fires progress
 * @fires error
 * @fires load
 * @private
 */
Loader.prototype._onLoad = function (resource) {
    this.progress += this._progressChunk;

    this.emit('progress', this, resource);

    // run middleware, this *must* happen before dequeue so sub-assets get added properly
    this._runMiddleware(resource, this._afterMiddleware, function () {
        resource.emit('afterMiddleware', resource);

        this._numToLoad--;

        // do completion check
        if (this._numToLoad === 0) {
            this.progress = 100;
            this._onComplete();
        }
        
        if (resource.error) {
            this.emit('error', resource.error, this, resource);
        }
        else {
            this.emit('load', this, resource);
        }
    });
    


    // remove this resource from the async queue
    resource._dequeue();
};

/**
 * Run middleware functions on a resource.
 *
 * @private
 */
Loader.prototype._runMiddleware = function (resource, fns, cb) {
    var self = this;

    async.eachSeries(fns, function (fn, next) {
        fn.call(self, resource, next);
    }, cb.bind(this, resource));
};

Loader.LOAD_TYPE = Resource.LOAD_TYPE;
Loader.XHR_READY_STATE = Resource.XHR_READY_STATE;
Loader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;

},{"./Resource":131,"async":128,"eventemitter3":129,"url":8}],131:[function(require,module,exports){
var EventEmitter = require('eventemitter3'),
    _url = require('url'),
    // tests is CORS is supported in XHR, if not we need to use XDR
    useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest()))),
    tempAnchor = null;

/**
 * Manages the state and loading of a single resource represented by
 * a single URL.
 *
 * @class
 * @param name {string} The name of the resource to load.
 * @param url {string|string[]} The url for this resource, for audio/video loads you can pass an array of sources.
 * @param [options] {object} The options for the load.
 * @param [options.crossOrigin] {string|boolean} Is this request cross-origin? Default is to determine automatically.
 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.LOAD_TYPE} How should this resource be loaded?
 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
 *      loaded be interpreted when using XHR?
 * @param [options.metadata] {object} Extra info for middleware.
 */
function Resource(name, url, options) {
    EventEmitter.call(this);

    options = options || {};

    if (typeof name !== 'string' || typeof url !== 'string') {
        throw new Error('Both name and url are required for constructing a resource.');
    }

    /**
     * The name of this resource.
     *
     * @member {string}
     * @readonly
     */
    this.name = name;

    /**
     * The url used to load this resource.
     *
     * @member {string}
     * @readonly
     */
    this.url = url;

    /**
     * Stores whether or not this url is a data url.
     *
     * @member {boolean}
     * @readonly
     */
    this.isDataUrl = this.url.indexOf('data:') === 0;

    /**
     * The data that was loaded by the resource.
     *
     * @member {any}
     */
    this.data = null;

    /**
     * Is this request cross-origin? If unset, determined automatically.
     *
     * @member {string}
     */
    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;

    /**
     * The method of loading to use for this resource.
     *
     * @member {Resource.LOAD_TYPE}
     */
    this.loadType = options.loadType || this._determineLoadType();

    /**
     * The type used to load the resource via XHR. If unset, determined automatically.
     *
     * @member {string}
     */
    this.xhrType = options.xhrType;

    /**
     * Extra info for middleware
     *
     * @member {object}
     */
    this.metadata = options.metadata || {};

    /**
     * The error that occurred while loading (if any).
     *
     * @member {Error}
     * @readonly
     */
    this.error = null;

    /**
     * The XHR object that was used to load this resource. This is only set
     * when `loadType` is `Resource.LOAD_TYPE.XHR`.
     *
     * @member {XMLHttpRequest}
     */
    this.xhr = null;

    /**
     * Describes if this resource was loaded as json. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isJson = false;

    /**
     * Describes if this resource was loaded as xml. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isXml = false;

    /**
     * Describes if this resource was loaded as an image tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isImage = false;

    /**
     * Describes if this resource was loaded as an audio tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isAudio = false;

    /**
     * Describes if this resource was loaded as a video tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {boolean}
     */
    this.isVideo = false;

    /**
     * The `dequeue` method that will be used a storage place for the async queue dequeue method
     * used privately by the loader.
     *
     * @member {function}
     * @private
     */
    this._dequeue = null;

    /**
     * The `complete` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundComplete = this.complete.bind(this);

    /**
     * The `_onError` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundOnError = this._onError.bind(this);

    /**
     * The `_onProgress` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundOnProgress = this._onProgress.bind(this);

    // xhr callbacks
    this._boundXhrOnError = this._xhrOnError.bind(this);
    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);

    /**
     * Emitted when the resource beings to load.
     *
     * @event start
     * @memberof Resource#
     */

    /**
     * Emitted each time progress of this resource load updates.
     * Not all resources types and loader systems can support this event
     * so sometimes it may not be available. If the resource
     * is being loaded on a modern browser, using XHR, and the remote server
     * properly sets Content-Length headers, then this will be available.
     *
     * @event progress
     * @memberof Resource#
     */

    /**
     * Emitted once this resource has loaded, if there was an error it will
     * be in the `error` property.
     *
     * @event complete
     * @memberof Resource#
     */
}

Resource.prototype = Object.create(EventEmitter.prototype);
Resource.prototype.constructor = Resource;
module.exports = Resource;

/**
 * Marks the resource as complete.
 *
 * @fires complete
 */
Resource.prototype.complete = function () {
    // TODO: Clean this up in a wrapper or something...gross....
    if (this.data && this.data.removeEventListener) {
        this.data.removeEventListener('error', this._boundOnError);
        this.data.removeEventListener('load', this._boundComplete);
        this.data.removeEventListener('progress', this._boundOnProgress);
        this.data.removeEventListener('canplaythrough', this._boundComplete);
    }

    if (this.xhr) {
        if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener('error', this._boundXhrOnError);
            this.xhr.removeEventListener('abort', this._boundXhrOnAbort);
            this.xhr.removeEventListener('progress', this._boundOnProgress);
            this.xhr.removeEventListener('load', this._boundXhrOnLoad);
        }
        else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
        }
    }

    this.emit('complete', this);
};

/**
 * Kicks off loading of this resource.
 *
 * @fires start
 * @param [callback] {function} Optional callback to call once the resource is loaded.
 */
Resource.prototype.load = function (cb) {
    this.emit('start', this);

    // if a callback is set, listen for complete event
    if (cb) {
        this.once('complete', cb);
    }

    // if unset, determine the value
    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {
        this.crossOrigin = this._determineCrossOrigin(this.url);
    }

    switch(this.loadType) {
        case Resource.LOAD_TYPE.IMAGE:
            this._loadImage();
            break;

        case Resource.LOAD_TYPE.AUDIO:
            this._loadElement('audio');
            break;

        case Resource.LOAD_TYPE.VIDEO:
            this._loadElement('video');
            break;

        case Resource.LOAD_TYPE.XHR:
            /* falls through */
        default:
            if (useXdr && this.crossOrigin) {
                this._loadXdr();
            }
            else {
                this._loadXhr();
            }
            break;
    }
};

/**
 * Loads this resources using an Image object.
 *
 * @private
 */
Resource.prototype._loadImage = function () {
    this.data = new Image();

    if (this.crossOrigin) {
        this.data.crossOrigin = this.crossOrigin;
    }

    this.data.src = this.url;

    this.isImage = true;

    this.data.addEventListener('error', this._boundOnError, false);
    this.data.addEventListener('load', this._boundComplete, false);
    this.data.addEventListener('progress', this._boundOnProgress, false);
};

/**
 * Loads this resources using an HTMLAudioElement or HTMLVideoElement.
 *
 * @private
 */
Resource.prototype._loadElement = function (type) {
    if (type === 'audio' && typeof Audio !== 'undefined') {
        this.data = new Audio();
    }
    else {
        this.data = document.createElement(type);
    }

    if (this.data === null) {
        this.error = new Error('Unsupported element ' + type);
        this.complete();
        return;
    }

    // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
    if (navigator.isCocoonJS) {
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
    }
    else {
        if (Array.isArray(this.url)) {
            for (var i = 0; i < this.url.length; ++i) {
                this.data.appendChild(this._createSource(type, this.url[i]));
            }
        }
        else {
            this.data.appendChild(this._createSource(type, this.url));
        }
    }

    this['is' + type[0].toUpperCase() + type.substring(1)] = true;

    this.data.addEventListener('error', this._boundOnError, false);
    this.data.addEventListener('load', this._boundComplete, false);
    this.data.addEventListener('progress', this._boundOnProgress, false);
    this.data.addEventListener('canplaythrough', this._boundComplete, false);

    this.data.load();
};

/**
 * Loads this resources using an XMLHttpRequest.
 *
 * @private
 */
Resource.prototype._loadXhr = function () {
    // if unset, determine the value
    if (typeof this.xhrType !== 'string') {
        this.xhrType = this._determineXhrType();
    }

    var xhr = this.xhr = new XMLHttpRequest();

    // set the request type and url
    xhr.open('GET', this.url, true);

    // load json as text and parse it ourselves. We do this because some browsers
    // *cough* safari *cough* can't deal with it.
    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
    }
    else {
        xhr.responseType = this.xhrType;
    }

    xhr.addEventListener('error', this._boundXhrOnError, false);
    xhr.addEventListener('abort', this._boundXhrOnAbort, false);
    xhr.addEventListener('progress', this._boundOnProgress, false);
    xhr.addEventListener('load', this._boundXhrOnLoad, false);

    xhr.send();
};

/**
 * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
 *
 * @private
 */
Resource.prototype._loadXdr = function () {
    // if unset, determine the value
    if (typeof this.xhrType !== 'string') {
        this.xhrType = this._determineXhrType();
    }

    var xdr = this.xhr = new XDomainRequest();

    // XDomainRequest has a few quirks. Occasionally it will abort requests
    // A way to avoid this is to make sure ALL callbacks are set even if not used
    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
    xdr.timeout = 5000;

    xdr.onerror = this._boundXhrOnError;
    xdr.ontimeout = this._boundXdrOnTimeout;
    xdr.onprogress = this._boundOnProgress;
    xdr.onload = this._boundXhrOnLoad;

    xdr.open('GET', this.url, true);

    //  Note: The xdr.send() call is wrapped in a timeout to prevent an issue with the interface where some requests are lost
    //  if multiple XDomainRequests are being sent at the same time.
    // Some info here: https://github.com/photonstorm/phaser/issues/1248
    setTimeout(function () {
        xdr.send();
    }, 0);
};

/**
 * Creates a source used in loading via an element.
 *
 * @param type {string} The element type (video or audio).
 * @param url {string} The source URL to load from.
 * @param [mime] {string} The mime type of the video
 * @private
 */
Resource.prototype._createSource = function (type, url, mime) {
    if (!mime) {
        mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = url;
    source.type = mime;

    return source;
};

/**
 * Called if a load errors out.
 *
 * @param event {Event} The error event from the element that emits it.
 * @private
 */
Resource.prototype._onError = function (event) {
    this.error = new Error('Failed to load element using ' + event.target.nodeName);
    this.complete();
};

/**
 * Called if a load progress event fires for xhr/xdr.
 *
 * @fires progress
 * @param event {XMLHttpRequestProgressEvent|Event}
 * @private
 */
Resource.prototype._onProgress =  function (event) {
    if (event && event.lengthComputable) {
        this.emit('progress', this, event.loaded / event.total);
    }
};

/**
 * Called if an error event fires for xhr/xdr.
 *
 * @param event {XMLHttpRequestErrorEvent|Event}
 * @private
 */
Resource.prototype._xhrOnError = function () {
    this.error = new Error(
        reqType(this.xhr) + ' Request failed. ' +
        'Status: ' + this.xhr.status + ', text: "' + this.xhr.statusText + '"'
    );

    this.complete();
};

/**
 * Called if an abort event fires for xhr.
 *
 * @param event {XMLHttpRequestAbortEvent}
 * @private
 */
Resource.prototype._xhrOnAbort = function () {
    this.error = new Error(reqType(this.xhr) + ' Request was aborted by the user.');
    this.complete();
};

/**
 * Called if a timeout event fires for xdr.
 *
 * @param event {Event}
 * @private
 */
Resource.prototype._xdrOnTimeout = function () {
    this.error = new Error(reqType(this.xhr) + ' Request timed out.');
    this.complete();
};

/**
 * Called when data successfully loads from an xhr/xdr request.
 *
 * @param event {XMLHttpRequestLoadEvent|Event}
 * @private
 */
Resource.prototype._xhrOnLoad = function () {
    var xhr = this.xhr,
        status = xhr.status !== undefined ? xhr.status : 200; //XDR has no `.status`, assume 200.

    // status can be 0 when using the file:// protocol, also check if a response was found
    if (status === 200 || status === 204 || (status === 0 && xhr.responseText.length > 0)) {
        // if text, just return it
        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
            this.data = xhr.responseText;
        }
        // if json, parse into json object
        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
            try {
                this.data = JSON.parse(xhr.responseText);
                this.isJson = true;
            } catch(e) {
                this.error = new Error('Error trying to parse loaded json:', e);
            }
        }
        // if xml, parse into an xml document or div element
        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
                if (window.DOMParser) {
                    var domparser = new DOMParser();
                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml');
                }
                else {
                    var div = document.createElement('div');
                    div.innerHTML = xhr.responseText;
                    this.data = div;
                }
                this.isXml = true;
            } catch (e) {
                this.error = new Error('Error trying to parse loaded xml:', e);
            }
        }
        // other types just return the response
        else {
            this.data = xhr.response || xhr.responseText;
        }
    }
    else {
        this.error = new Error('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);
    }

    this.complete();
};

function reqType(xhr) {
    return xhr.toString().replace('object ', '');
}

/**
 * Sets the `crossOrigin` property for this resource based on if the url
 * for this resource is cross-origin. If crossOrigin was manually set, this
 * function does nothing.
 *
 * @private
 * @param url {string} The url to test.
 * @param [location=window.location] {object} The location object to test against.
 * @return {string} The crossOrigin value to use (or empty string for none).
 */
Resource.prototype._determineCrossOrigin = function (url, loc) {
    // data: and javascript: urls are considered same-origin
    if (url.indexOf('data:') === 0) {
        return '';
    }

    // default is window.location
    loc = loc || window.location;

    if (!tempAnchor) {
        tempAnchor = document.createElement('a');
    }

    // let the browser determine the full href for the url of this resource and then
    // parse with the node url lib, we can't use the properties of the anchor element
    // because they don't work in IE9 :(
    tempAnchor.href = url;
    url = _url.parse(tempAnchor.href);

    var samePort = (!url.port && loc.port === '') || (url.port === loc.port);

    // if cross origin
    if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
        return 'anonymous';
    }

    return '';
};

/**
 * Determines the responseType of an XHR request based on the extension of the
 * resource being loaded.
 *
 * @private
 * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
 */
Resource.prototype._determineXhrType = function () {
    return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;
};

Resource.prototype._determineLoadType = function () {
    return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;
};

Resource.prototype._getExtension = function () {
    var url = this.url,
        ext;

    if (this.isDataUrl) {
        var slashIndex = url.indexOf('/');
        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
    }
    else {
        var queryStart = url.indexOf('?');
        if (queryStart !== -1) {
            url = url.substring(0, queryStart);
        }

        ext = url.substring(url.lastIndexOf('.') + 1);
    }

    return ext;
};

/**
 * Determines the mime type of an XHR request based on the responseType of
 * resource being loaded.
 *
 * @private
 * @return {string} The mime type to use.
 */
Resource.prototype._getMimeFromXhrType = function (type) {
    switch(type) {
        case Resource.XHR_RESPONSE_TYPE.BUFFER:
            return 'application/octet-binary';

        case Resource.XHR_RESPONSE_TYPE.BLOB:
            return 'application/blob';

        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
            return 'application/xml';

        case Resource.XHR_RESPONSE_TYPE.JSON:
            return 'application/json';

        case Resource.XHR_RESPONSE_TYPE.DEFAULT:
        case Resource.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
        default:
            return 'text/plain';

    }
};

/**
 * The types of loading a resource can use.
 *
 * @static
 * @constant
 * @property {object} LOAD_TYPE
 * @property {number} LOAD_TYPE.XHR - Uses XMLHttpRequest to load the resource.
 * @property {number} LOAD_TYPE.IMAGE - Uses an `Image` object to load the resource.
 * @property {number} LOAD_TYPE.AUDIO - Uses an `Audio` object to load the resource.
 * @property {number} LOAD_TYPE.VIDEO - Uses a `Video` object to load the resource.
 */
Resource.LOAD_TYPE = {
    XHR:    1,
    IMAGE:  2,
    AUDIO:  3,
    VIDEO:  4
};

/**
 * The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_READY_STATE
 * @property {number} XHR_READY_STATE.UNSENT - open()has not been called yet.
 * @property {number} XHR_READY_STATE.OPENED - send()has not been called yet.
 * @property {number} XHR_READY_STATE.HEADERS_RECEIVED - send() has been called, and headers and status are available.
 * @property {number} XHR_READY_STATE.LOADING - Downloading; responseText holds partial data.
 * @property {number} XHR_READY_STATE.DONE - The operation is complete.
 */
Resource.XHR_READY_STATE = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
};

/**
 * The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_RESPONSE_TYPE
 * @property {string} XHR_RESPONSE_TYPE.DEFAULT - defaults to text
 * @property {string} XHR_RESPONSE_TYPE.BUFFER - ArrayBuffer
 * @property {string} XHR_RESPONSE_TYPE.BLOB - Blob
 * @property {string} XHR_RESPONSE_TYPE.DOCUMENT - Document
 * @property {string} XHR_RESPONSE_TYPE.JSON - Object
 * @property {string} XHR_RESPONSE_TYPE.TEXT - String
 */
Resource.XHR_RESPONSE_TYPE = {
    DEFAULT:    'text',
    BUFFER:     'arraybuffer',
    BLOB:       'blob',
    DOCUMENT:   'document',
    JSON:       'json',
    TEXT:       'text'
};

Resource._loadTypeMap = {
    'gif':      Resource.LOAD_TYPE.IMAGE,
    'png':      Resource.LOAD_TYPE.IMAGE,
    'bmp':      Resource.LOAD_TYPE.IMAGE,
    'jpg':      Resource.LOAD_TYPE.IMAGE,
    'jpeg':     Resource.LOAD_TYPE.IMAGE,
    'tif':      Resource.LOAD_TYPE.IMAGE,
    'tiff':     Resource.LOAD_TYPE.IMAGE,
    'webp':     Resource.LOAD_TYPE.IMAGE,
    'tga':      Resource.LOAD_TYPE.IMAGE
};

Resource._xhrTypeMap = {
    // xml
    'xhtml':    Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'html':     Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'htm':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'xml':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'tmx':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'tsx':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    'svg':      Resource.XHR_RESPONSE_TYPE.DOCUMENT,

    // images
    'gif':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'png':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'bmp':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'jpg':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'jpeg':     Resource.XHR_RESPONSE_TYPE.BLOB,
    'tif':      Resource.XHR_RESPONSE_TYPE.BLOB,
    'tiff':     Resource.XHR_RESPONSE_TYPE.BLOB,
    'webp':     Resource.XHR_RESPONSE_TYPE.BLOB,
    'tga':      Resource.XHR_RESPONSE_TYPE.BLOB,

    // json
    'json':     Resource.XHR_RESPONSE_TYPE.JSON,

    // text
    'text':     Resource.XHR_RESPONSE_TYPE.TEXT,
    'txt':      Resource.XHR_RESPONSE_TYPE.TEXT
};

/**
 * Sets the load type to be used for a specific extension.
 *
 * @static
 * @param extname {string} The extension to set the type for, e.g. "png" or "fnt"
 * @param loadType {Resource.LOAD_TYPE} The load type to set it to.
 */
Resource.setExtensionLoadType = function (extname, loadType) {
    setExtMap(Resource._loadTypeMap, extname, loadType);
};

/**
 * Sets the load type to be used for a specific extension.
 *
 * @static
 * @param extname {string} The extension to set the type for, e.g. "png" or "fnt"
 * @param xhrType {Resource.XHR_RESPONSE_TYPE} The xhr type to set it to.
 */
Resource.setExtensionXhrType = function (extname, xhrType) {
    setExtMap(Resource._xhrTypeMap, extname, xhrType);
};

function setExtMap(map, extname, val) {
    if (extname && extname.indexOf('.') === 0) {
        extname = extname.substring(1);
    }

    if (!extname) {
        return;
    }

    map[extname] = val;
}

},{"eventemitter3":129,"url":8}],132:[function(require,module,exports){
module.exports = {

    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    encodeBinary: function (input) {
        var output = "";
        var bytebuffer;
        var encodedCharIndexes = new Array(4);
        var inx = 0;
        var jnx = 0;
        var paddingBytes = 0;

        while (inx < input.length) {
            // Fill byte buffer array
            bytebuffer = new Array(3);
            for (jnx = 0; jnx < bytebuffer.length; jnx++) {
                if (inx < input.length) {
                    // throw away high-order byte, as documented at:
                    // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
                    bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
                }
                else {
                    bytebuffer[jnx] = 0;
                }
            }

            // Get each encoded character, 6 bits at a time
            // index 1: first 6 bits
            encodedCharIndexes[0] = bytebuffer[0] >> 2;
            // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
            encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);
            // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
            encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);
            // index 3: forth 6 bits (6 least significant bits from input byte 3)
            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;

            // Determine whether padding happened, and adjust accordingly
            paddingBytes = inx - (input.length - 1);
            switch (paddingBytes) {
                case 2:
                    // Set last 2 characters to padding char
                    encodedCharIndexes[3] = 64;
                    encodedCharIndexes[2] = 64;
                    break;

                case 1:
                    // Set last character to padding char
                    encodedCharIndexes[3] = 64;
                    break;

                default:
                    break; // No padding - proceed
            }

            // Now we will grab each appropriate character out of our keystring
            // based on our index array and append it to the output string
            for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {
                output += this._keyStr.charAt(encodedCharIndexes[jnx]);
            }
        }
        return output;
    }
};

},{}],133:[function(require,module,exports){
module.exports = require('./Loader');

module.exports.Resource = require('./Resource');

module.exports.middleware = {
    caching: {
        memory: require('./middlewares/caching/memory')
    },
    parsing: {
        blob: require('./middlewares/parsing/blob')
    }
};

},{"./Loader":130,"./Resource":131,"./middlewares/caching/memory":134,"./middlewares/parsing/blob":135}],134:[function(require,module,exports){
// a simple in-memory cache for resources
var cache = {};

module.exports = function () {
    return function (resource, next) {
        // if cached, then set data and complete the resource
        if (cache[resource.url]) {
            resource.data = cache[resource.url];
            resource.complete();
        }
        // if not cached, wait for complete and store it in the cache.
        else {
            resource.once('complete', function () {
               cache[this.url] = this.data;
            });
        }
        
        next();
    };
};

},{}],135:[function(require,module,exports){
var Resource = require('../../Resource'),
    b64 = require('../../b64');

window.URL = window.URL || window.webkitURL;

// a middleware for transforming XHR loaded Blobs into more useful objects

module.exports = function () {
    return function (resource, next) {
        if (!resource.data) {
            return next();
        }

        // if this was an XHR load of a blob
        if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
            // if there is no blob support we probably got a binary string back
            if (!window.Blob || typeof resource.data === 'string') {
                var type = resource.xhr.getResponseHeader('content-type');

                // this is an image, convert the binary string into a data url
                if (type && type.indexOf('image') === 0) {
                    resource.data = new Image();
                    resource.data.src = 'data:' + type + ';base64,' + b64.encodeBinary(resource.xhr.responseText);

                    resource.isImage = true;

                    // wait until the image loads and then callback
                    resource.data.onload = function () {
                        resource.data.onload = null;

                        next();
                    };
                }
            }
            // if content type says this is an image, then we should transform the blob into an Image object
            else if (resource.data.type.indexOf('image') === 0) {
                var src = URL.createObjectURL(resource.data);

                resource.blob = resource.data;
                resource.data = new Image();
                resource.data.src = src;

                resource.isImage = true;

                // cleanup the no longer used blob after the image loads
                resource.data.onload = function () {
                    URL.revokeObjectURL(src);
                    resource.data.onload = null;

                    next();
                };
            }
        }
        else {
            next();
        }
    };
};

},{"../../Resource":131,"../../b64":132}]},{},[108])(108)
});



/*!
 * VERSION: 1.11.1
 * DATE: 2013-10-29
 * UPDATES AND DOCS AT: http://www.greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
;(window._gsQueue||(window._gsQueue=[])).push(function(){"use strict";window._gsDefine("TweenMax",["core.Animation","core.SimpleTimeline","TweenLite"],function(t,e,i){var s=[].slice,r=function(t,e,s){i.call(this,t,e,s),this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._dirty=!0,this.render=r.prototype.render},n=1e-10,a=i._internals.isSelector,o=i._internals.isArray,h=r.prototype=i.to({},.1,{}),l=[];r.version="1.11.1",h.constructor=r,h.kill()._gc=!1,r.killTweensOf=r.killDelayedCallsTo=i.killTweensOf,r.getTweensOf=i.getTweensOf,r.ticker=i.ticker,h.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),i.prototype.invalidate.call(this)},h.updateTo=function(t,e){var s,r=this.ratio;e&&this.timeline&&this._startTime<this._timeline._time&&(this._startTime=this._timeline._time,this._uncache(!1),this._gc?this._enabled(!0,!1):this._timeline.insert(this,this._startTime-this._delay));for(s in t)this.vars[s]=t[s];if(this._initted)if(e)this._initted=!1;else if(this._notifyPluginsOfEnabled&&this._firstPT&&i._onPluginEvent("_onDisable",this),this._time/this._duration>.998){var n=this._time;this.render(0,!0,!1),this._initted=!1,this.render(n,!0,!1)}else if(this._time>0){this._initted=!1,this._init();for(var a,o=1/(1-r),h=this._firstPT;h;)a=h.s+h.c,h.c*=o,h.s=a-h.c,h=h._next}return this},h.render=function(t,e,i){this._initted||0===this._duration&&this.vars.repeat&&this.invalidate();var s,r,a,o,h,_,u,p,f=this._dirty?this.totalDuration():this._totalDuration,c=this._time,m=this._totalTime,d=this._cycle,g=this._duration;if(t>=f?(this._totalTime=f,this._cycle=this._repeat,this._yoyo&&0!==(1&this._cycle)?(this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0):(this._time=g,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1),this._reversed||(s=!0,r="onComplete"),0===g&&(p=this._rawPrevTime,(0===t||0>p||p===n)&&p!==t&&(i=!0,p>n&&(r="onReverseComplete")),this._rawPrevTime=p=!e||t?t:n)):1e-7>t?(this._totalTime=this._time=this._cycle=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==m||0===g&&this._rawPrevTime>n)&&(r="onReverseComplete",s=this._reversed),0>t?(this._active=!1,0===g&&(this._rawPrevTime>=0&&(i=!0),this._rawPrevTime=p=!e||t?t:n)):this._initted||(i=!0)):(this._totalTime=this._time=t,0!==this._repeat&&(o=g+this._repeatDelay,this._cycle=this._totalTime/o>>0,0!==this._cycle&&this._cycle===this._totalTime/o&&this._cycle--,this._time=this._totalTime-this._cycle*o,this._yoyo&&0!==(1&this._cycle)&&(this._time=g-this._time),this._time>g?this._time=g:0>this._time&&(this._time=0)),this._easeType?(h=this._time/g,_=this._easeType,u=this._easePower,(1===_||3===_&&h>=.5)&&(h=1-h),3===_&&(h*=2),1===u?h*=h:2===u?h*=h*h:3===u?h*=h*h*h:4===u&&(h*=h*h*h*h),this.ratio=1===_?1-h:2===_?h:.5>this._time/g?h/2:1-h/2):this.ratio=this._ease.getRatio(this._time/g)),c===this._time&&!i&&d===this._cycle)return m!==this._totalTime&&this._onUpdate&&(e||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||l)),void 0;if(!this._initted){if(this._init(),!this._initted||this._gc)return;this._time&&!s?this.ratio=this._ease.getRatio(this._time/g):s&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._active||!this._paused&&this._time!==c&&t>=0&&(this._active=!0),0===m&&(this._startAt&&(t>=0?this._startAt.render(t,e,i):r||(r="_dummyGS")),this.vars.onStart&&(0!==this._totalTime||0===g)&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||l))),a=this._firstPT;a;)a.f?a.t[a.p](a.c*this.ratio+a.s):a.t[a.p]=a.c*this.ratio+a.s,a=a._next;this._onUpdate&&(0>t&&this._startAt&&this._startTime&&this._startAt.render(t,e,i),e||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||l)),this._cycle!==d&&(e||this._gc||this.vars.onRepeat&&this.vars.onRepeat.apply(this.vars.onRepeatScope||this,this.vars.onRepeatParams||l)),r&&(this._gc||(0>t&&this._startAt&&!this._onUpdate&&this._startTime&&this._startAt.render(t,e,i),s&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[r]&&this.vars[r].apply(this.vars[r+"Scope"]||this,this.vars[r+"Params"]||l),0===g&&this._rawPrevTime===n&&p!==n&&(this._rawPrevTime=0)))},r.to=function(t,e,i){return new r(t,e,i)},r.from=function(t,e,i){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,new r(t,e,i)},r.fromTo=function(t,e,i,s){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,new r(t,e,s)},r.staggerTo=r.allTo=function(t,e,n,h,_,u,p){h=h||0;var f,c,m,d,g=n.delay||0,v=[],y=function(){n.onComplete&&n.onComplete.apply(n.onCompleteScope||this,arguments),_.apply(p||this,u||l)};for(o(t)||("string"==typeof t&&(t=i.selector(t)||t),a(t)&&(t=s.call(t,0))),f=t.length,m=0;f>m;m++){c={};for(d in n)c[d]=n[d];c.delay=g,m===f-1&&_&&(c.onComplete=y),v[m]=new r(t[m],e,c),g+=h}return v},r.staggerFrom=r.allFrom=function(t,e,i,s,n,a,o){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,r.staggerTo(t,e,i,s,n,a,o)},r.staggerFromTo=r.allFromTo=function(t,e,i,s,n,a,o,h){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,r.staggerTo(t,e,s,n,a,o,h)},r.delayedCall=function(t,e,i,s,n){return new r(e,0,{delay:t,onComplete:e,onCompleteParams:i,onCompleteScope:s,onReverseComplete:e,onReverseCompleteParams:i,onReverseCompleteScope:s,immediateRender:!1,useFrames:n,overwrite:0})},r.set=function(t,e){return new r(t,0,e)},r.isTweening=function(t){return i.getTweensOf(t,!0).length>0};var _=function(t,e){for(var s=[],r=0,n=t._first;n;)n instanceof i?s[r++]=n:(e&&(s[r++]=n),s=s.concat(_(n,e)),r=s.length),n=n._next;return s},u=r.getAllTweens=function(e){return _(t._rootTimeline,e).concat(_(t._rootFramesTimeline,e))};r.killAll=function(t,i,s,r){null==i&&(i=!0),null==s&&(s=!0);var n,a,o,h=u(0!=r),l=h.length,_=i&&s&&r;for(o=0;l>o;o++)a=h[o],(_||a instanceof e||(n=a.target===a.vars.onComplete)&&s||i&&!n)&&(t?a.totalTime(a.totalDuration()):a._enabled(!1,!1))},r.killChildTweensOf=function(t,e){if(null!=t){var n,h,l,_,u,p=i._tweenLookup;if("string"==typeof t&&(t=i.selector(t)||t),a(t)&&(t=s(t,0)),o(t))for(_=t.length;--_>-1;)r.killChildTweensOf(t[_],e);else{n=[];for(l in p)for(h=p[l].target.parentNode;h;)h===t&&(n=n.concat(p[l].tweens)),h=h.parentNode;for(u=n.length,_=0;u>_;_++)e&&n[_].totalTime(n[_].totalDuration()),n[_]._enabled(!1,!1)}}};var p=function(t,i,s,r){i=i!==!1,s=s!==!1,r=r!==!1;for(var n,a,o=u(r),h=i&&s&&r,l=o.length;--l>-1;)a=o[l],(h||a instanceof e||(n=a.target===a.vars.onComplete)&&s||i&&!n)&&a.paused(t)};return r.pauseAll=function(t,e,i){p(!0,t,e,i)},r.resumeAll=function(t,e,i){p(!1,t,e,i)},r.globalTimeScale=function(e){var s=t._rootTimeline,r=i.ticker.time;return arguments.length?(e=e||n,s._startTime=r-(r-s._startTime)*s._timeScale/e,s=t._rootFramesTimeline,r=i.ticker.frame,s._startTime=r-(r-s._startTime)*s._timeScale/e,s._timeScale=t._rootTimeline._timeScale=e,e):s._timeScale},h.progress=function(t){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-t:t)+this._cycle*(this._duration+this._repeatDelay),!1):this._time/this.duration()},h.totalProgress=function(t){return arguments.length?this.totalTime(this.totalDuration()*t,!1):this._totalTime/this.totalDuration()},h.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),t>this._duration&&(t=this._duration),this._yoyo&&0!==(1&this._cycle)?t=this._duration-t+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(t+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(t,e)):this._time},h.duration=function(e){return arguments.length?t.prototype.duration.call(this,e):this._duration},h.totalDuration=function(t){return arguments.length?-1===this._repeat?this:this.duration((t-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat,this._dirty=!1),this._totalDuration)},h.repeat=function(t){return arguments.length?(this._repeat=t,this._uncache(!0)):this._repeat},h.repeatDelay=function(t){return arguments.length?(this._repeatDelay=t,this._uncache(!0)):this._repeatDelay},h.yoyo=function(t){return arguments.length?(this._yoyo=t,this):this._yoyo},r},!0),window._gsDefine("TimelineLite",["core.Animation","core.SimpleTimeline","TweenLite"],function(t,e,i){var s=function(t){e.call(this,t),this._labels={},this.autoRemoveChildren=this.vars.autoRemoveChildren===!0,this.smoothChildTiming=this.vars.smoothChildTiming===!0,this._sortChildren=!0,this._onUpdate=this.vars.onUpdate;var i,s,r=this.vars;for(s in r)i=r[s],a(i)&&-1!==i.join("").indexOf("{self}")&&(r[s]=this._swapSelfInParams(i));a(r.tweens)&&this.add(r.tweens,0,r.align,r.stagger)},r=1e-10,n=i._internals.isSelector,a=i._internals.isArray,o=[],h=function(t){var e,i={};for(e in t)i[e]=t[e];return i},l=function(t,e,i,s){t._timeline.pause(t._startTime),e&&e.apply(s||t._timeline,i||o)},_=o.slice,u=s.prototype=new e;return s.version="1.11.0",u.constructor=s,u.kill()._gc=!1,u.to=function(t,e,s,r){return e?this.add(new i(t,e,s),r):this.set(t,s,r)},u.from=function(t,e,s,r){return this.add(i.from(t,e,s),r)},u.fromTo=function(t,e,s,r,n){return e?this.add(i.fromTo(t,e,s,r),n):this.set(t,r,n)},u.staggerTo=function(t,e,r,a,o,l,u,p){var f,c=new s({onComplete:l,onCompleteParams:u,onCompleteScope:p});for("string"==typeof t&&(t=i.selector(t)||t),n(t)&&(t=_.call(t,0)),a=a||0,f=0;t.length>f;f++)r.startAt&&(r.startAt=h(r.startAt)),c.to(t[f],e,h(r),f*a);return this.add(c,o)},u.staggerFrom=function(t,e,i,s,r,n,a,o){return i.immediateRender=0!=i.immediateRender,i.runBackwards=!0,this.staggerTo(t,e,i,s,r,n,a,o)},u.staggerFromTo=function(t,e,i,s,r,n,a,o,h){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,this.staggerTo(t,e,s,r,n,a,o,h)},u.call=function(t,e,s,r){return this.add(i.delayedCall(0,t,e,s),r)},u.set=function(t,e,s){return s=this._parseTimeOrLabel(s,0,!0),null==e.immediateRender&&(e.immediateRender=s===this._time&&!this._paused),this.add(new i(t,0,e),s)},s.exportRoot=function(t,e){t=t||{},null==t.smoothChildTiming&&(t.smoothChildTiming=!0);var r,n,a=new s(t),o=a._timeline;for(null==e&&(e=!0),o._remove(a,!0),a._startTime=0,a._rawPrevTime=a._time=a._totalTime=o._time,r=o._first;r;)n=r._next,e&&r instanceof i&&r.target===r.vars.onComplete||a.add(r,r._startTime-r._delay),r=n;return o.add(a,0),a},u.add=function(r,n,o,h){var l,_,u,p,f,c;if("number"!=typeof n&&(n=this._parseTimeOrLabel(n,0,!0,r)),!(r instanceof t)){if(r instanceof Array||r&&r.push&&a(r)){for(o=o||"normal",h=h||0,l=n,_=r.length,u=0;_>u;u++)a(p=r[u])&&(p=new s({tweens:p})),this.add(p,l),"string"!=typeof p&&"function"!=typeof p&&("sequence"===o?l=p._startTime+p.totalDuration()/p._timeScale:"start"===o&&(p._startTime-=p.delay())),l+=h;return this._uncache(!0)}if("string"==typeof r)return this.addLabel(r,n);if("function"!=typeof r)throw"Cannot add "+r+" into the timeline; it is not a tween, timeline, function, or string.";r=i.delayedCall(0,r)}if(e.prototype.add.call(this,r,n),this._gc&&!this._paused&&this._duration<this.duration())for(f=this,c=f.rawTime()>r._startTime;f._gc&&f._timeline;)f._timeline.smoothChildTiming&&c?f.totalTime(f._totalTime,!0):f._enabled(!0,!1),f=f._timeline;return this},u.remove=function(e){if(e instanceof t)return this._remove(e,!1);if(e instanceof Array||e&&e.push&&a(e)){for(var i=e.length;--i>-1;)this.remove(e[i]);return this}return"string"==typeof e?this.removeLabel(e):this.kill(null,e)},u._remove=function(t,i){e.prototype._remove.call(this,t,i);var s=this._last;return s?this._time>s._startTime+s._totalDuration/s._timeScale&&(this._time=this.duration(),this._totalTime=this._totalDuration):this._time=this._totalTime=0,this},u.append=function(t,e){return this.add(t,this._parseTimeOrLabel(null,e,!0,t))},u.insert=u.insertMultiple=function(t,e,i,s){return this.add(t,e||0,i,s)},u.appendMultiple=function(t,e,i,s){return this.add(t,this._parseTimeOrLabel(null,e,!0,t),i,s)},u.addLabel=function(t,e){return this._labels[t]=this._parseTimeOrLabel(e),this},u.addPause=function(t,e,i,s){return this.call(l,["{self}",e,i,s],this,t)},u.removeLabel=function(t){return delete this._labels[t],this},u.getLabelTime=function(t){return null!=this._labels[t]?this._labels[t]:-1},u._parseTimeOrLabel=function(e,i,s,r){var n;if(r instanceof t&&r.timeline===this)this.remove(r);else if(r&&(r instanceof Array||r.push&&a(r)))for(n=r.length;--n>-1;)r[n]instanceof t&&r[n].timeline===this&&this.remove(r[n]);if("string"==typeof i)return this._parseTimeOrLabel(i,s&&"number"==typeof e&&null==this._labels[i]?e-this.duration():0,s);if(i=i||0,"string"!=typeof e||!isNaN(e)&&null==this._labels[e])null==e&&(e=this.duration());else{if(n=e.indexOf("="),-1===n)return null==this._labels[e]?s?this._labels[e]=this.duration()+i:i:this._labels[e]+i;i=parseInt(e.charAt(n-1)+"1",10)*Number(e.substr(n+1)),e=n>1?this._parseTimeOrLabel(e.substr(0,n-1),0,s):this.duration()}return Number(e)+i},u.seek=function(t,e){return this.totalTime("number"==typeof t?t:this._parseTimeOrLabel(t),e!==!1)},u.stop=function(){return this.paused(!0)},u.gotoAndPlay=function(t,e){return this.play(t,e)},u.gotoAndStop=function(t,e){return this.pause(t,e)},u.render=function(t,e,i){this._gc&&this._enabled(!0,!1);var s,n,a,h,l,_=this._dirty?this.totalDuration():this._totalDuration,u=this._time,p=this._startTime,f=this._timeScale,c=this._paused;if(t>=_?(this._totalTime=this._time=_,this._reversed||this._hasPausedChild()||(n=!0,h="onComplete",0===this._duration&&(0===t||0>this._rawPrevTime||this._rawPrevTime===r)&&this._rawPrevTime!==t&&this._first&&(l=!0,this._rawPrevTime>r&&(h="onReverseComplete"))),this._rawPrevTime=this._duration||!e||t?t:r,t=_+1e-6):1e-7>t?(this._totalTime=this._time=0,(0!==u||0===this._duration&&(this._rawPrevTime>r||0>t&&this._rawPrevTime>=0))&&(h="onReverseComplete",n=this._reversed),0>t?(this._active=!1,0===this._duration&&this._rawPrevTime>=0&&this._first&&(l=!0),this._rawPrevTime=t):(this._rawPrevTime=this._duration||!e||t?t:r,t=0,this._initted||(l=!0))):this._totalTime=this._time=this._rawPrevTime=t,this._time!==u&&this._first||i||l){if(this._initted||(this._initted=!0),this._active||!this._paused&&this._time!==u&&t>0&&(this._active=!0),0===u&&this.vars.onStart&&0!==this._time&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||o)),this._time>=u)for(s=this._first;s&&(a=s._next,!this._paused||c);)(s._active||s._startTime<=this._time&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=a;else for(s=this._last;s&&(a=s._prev,!this._paused||c);)(s._active||u>=s._startTime&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=a;this._onUpdate&&(e||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||o)),h&&(this._gc||(p===this._startTime||f!==this._timeScale)&&(0===this._time||_>=this.totalDuration())&&(n&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[h]&&this.vars[h].apply(this.vars[h+"Scope"]||this,this.vars[h+"Params"]||o)))}},u._hasPausedChild=function(){for(var t=this._first;t;){if(t._paused||t instanceof s&&t._hasPausedChild())return!0;t=t._next}return!1},u.getChildren=function(t,e,s,r){r=r||-9999999999;for(var n=[],a=this._first,o=0;a;)r>a._startTime||(a instanceof i?e!==!1&&(n[o++]=a):(s!==!1&&(n[o++]=a),t!==!1&&(n=n.concat(a.getChildren(!0,e,s)),o=n.length))),a=a._next;return n},u.getTweensOf=function(t,e){for(var s=i.getTweensOf(t),r=s.length,n=[],a=0;--r>-1;)(s[r].timeline===this||e&&this._contains(s[r]))&&(n[a++]=s[r]);return n},u._contains=function(t){for(var e=t.timeline;e;){if(e===this)return!0;e=e.timeline}return!1},u.shiftChildren=function(t,e,i){i=i||0;for(var s,r=this._first,n=this._labels;r;)r._startTime>=i&&(r._startTime+=t),r=r._next;if(e)for(s in n)n[s]>=i&&(n[s]+=t);return this._uncache(!0)},u._kill=function(t,e){if(!t&&!e)return this._enabled(!1,!1);for(var i=e?this.getTweensOf(e):this.getChildren(!0,!0,!1),s=i.length,r=!1;--s>-1;)i[s]._kill(t,e)&&(r=!0);return r},u.clear=function(t){var e=this.getChildren(!1,!0,!0),i=e.length;for(this._time=this._totalTime=0;--i>-1;)e[i]._enabled(!1,!1);return t!==!1&&(this._labels={}),this._uncache(!0)},u.invalidate=function(){for(var t=this._first;t;)t.invalidate(),t=t._next;return this},u._enabled=function(t,i){if(t===this._gc)for(var s=this._first;s;)s._enabled(t,!0),s=s._next;return e.prototype._enabled.call(this,t,i)},u.duration=function(t){return arguments.length?(0!==this.duration()&&0!==t&&this.timeScale(this._duration/t),this):(this._dirty&&this.totalDuration(),this._duration)},u.totalDuration=function(t){if(!arguments.length){if(this._dirty){for(var e,i,s=0,r=this._last,n=999999999999;r;)e=r._prev,r._dirty&&r.totalDuration(),r._startTime>n&&this._sortChildren&&!r._paused?this.add(r,r._startTime-r._delay):n=r._startTime,0>r._startTime&&!r._paused&&(s-=r._startTime,this._timeline.smoothChildTiming&&(this._startTime+=r._startTime/this._timeScale),this.shiftChildren(-r._startTime,!1,-9999999999),n=0),i=r._startTime+r._totalDuration/r._timeScale,i>s&&(s=i),r=e;this._duration=this._totalDuration=s,this._dirty=!1}return this._totalDuration}return 0!==this.totalDuration()&&0!==t&&this.timeScale(this._totalDuration/t),this},u.usesFrames=function(){for(var e=this._timeline;e._timeline;)e=e._timeline;return e===t._rootFramesTimeline},u.rawTime=function(){return this._paused?this._totalTime:(this._timeline.rawTime()-this._startTime)*this._timeScale},s},!0),window._gsDefine("TimelineMax",["TimelineLite","TweenLite","easing.Ease"],function(t,e,i){var s=function(e){t.call(this,e),this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._dirty=!0},r=1e-10,n=[],a=new i(null,null,1,0),o=s.prototype=new t;return o.constructor=s,o.kill()._gc=!1,s.version="1.11.0",o.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),t.prototype.invalidate.call(this)},o.addCallback=function(t,i,s,r){return this.add(e.delayedCall(0,t,s,r),i)},o.removeCallback=function(t,e){if(t)if(null==e)this._kill(null,t);else for(var i=this.getTweensOf(t,!1),s=i.length,r=this._parseTimeOrLabel(e);--s>-1;)i[s]._startTime===r&&i[s]._enabled(!1,!1);return this},o.tweenTo=function(t,i){i=i||{};var s,r,o={ease:a,overwrite:2,useFrames:this.usesFrames(),immediateRender:!1};for(s in i)o[s]=i[s];return o.time=this._parseTimeOrLabel(t),r=new e(this,Math.abs(Number(o.time)-this._time)/this._timeScale||.001,o),o.onStart=function(){r.target.paused(!0),r.vars.time!==r.target.time()&&r.duration(Math.abs(r.vars.time-r.target.time())/r.target._timeScale),i.onStart&&i.onStart.apply(i.onStartScope||r,i.onStartParams||n)},r},o.tweenFromTo=function(t,e,i){i=i||{},t=this._parseTimeOrLabel(t),i.startAt={onComplete:this.seek,onCompleteParams:[t],onCompleteScope:this},i.immediateRender=i.immediateRender!==!1;var s=this.tweenTo(e,i);return s.duration(Math.abs(s.vars.time-t)/this._timeScale||.001)},o.render=function(t,e,i){this._gc&&this._enabled(!0,!1);var s,a,o,h,l,_,u=this._dirty?this.totalDuration():this._totalDuration,p=this._duration,f=this._time,c=this._totalTime,m=this._startTime,d=this._timeScale,g=this._rawPrevTime,v=this._paused,y=this._cycle;if(t>=u?(this._locked||(this._totalTime=u,this._cycle=this._repeat),this._reversed||this._hasPausedChild()||(a=!0,h="onComplete",0===this._duration&&(0===t||0>g||g===r)&&g!==t&&this._first&&(l=!0,g>r&&(h="onReverseComplete"))),this._rawPrevTime=this._duration||!e||t?t:r,this._yoyo&&0!==(1&this._cycle)?this._time=t=0:(this._time=p,t=p+1e-6)):1e-7>t?(this._locked||(this._totalTime=this._cycle=0),this._time=0,(0!==f||0===p&&(g>r||0>t&&g>=0)&&!this._locked)&&(h="onReverseComplete",a=this._reversed),0>t?(this._active=!1,0===p&&g>=0&&this._first&&(l=!0),this._rawPrevTime=t):(this._rawPrevTime=p||!e||t?t:r,t=0,this._initted||(l=!0))):(0===p&&0>g&&(l=!0),this._time=this._rawPrevTime=t,this._locked||(this._totalTime=t,0!==this._repeat&&(_=p+this._repeatDelay,this._cycle=this._totalTime/_>>0,0!==this._cycle&&this._cycle===this._totalTime/_&&this._cycle--,this._time=this._totalTime-this._cycle*_,this._yoyo&&0!==(1&this._cycle)&&(this._time=p-this._time),this._time>p?(this._time=p,t=p+1e-6):0>this._time?this._time=t=0:t=this._time))),this._cycle!==y&&!this._locked){var T=this._yoyo&&0!==(1&y),w=T===(this._yoyo&&0!==(1&this._cycle)),x=this._totalTime,b=this._cycle,P=this._rawPrevTime,S=this._time;if(this._totalTime=y*p,y>this._cycle?T=!T:this._totalTime+=p,this._time=f,this._rawPrevTime=0===p?g-1e-5:g,this._cycle=y,this._locked=!0,f=T?0:p,this.render(f,e,0===p),e||this._gc||this.vars.onRepeat&&this.vars.onRepeat.apply(this.vars.onRepeatScope||this,this.vars.onRepeatParams||n),w&&(f=T?p+1e-6:-1e-6,this.render(f,!0,!1)),this._locked=!1,this._paused&&!v)return;this._time=S,this._totalTime=x,this._cycle=b,this._rawPrevTime=P}if(!(this._time!==f&&this._first||i||l))return c!==this._totalTime&&this._onUpdate&&(e||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||n)),void 0;if(this._initted||(this._initted=!0),this._active||!this._paused&&this._totalTime!==c&&t>0&&(this._active=!0),0===c&&this.vars.onStart&&0!==this._totalTime&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||n)),this._time>=f)for(s=this._first;s&&(o=s._next,!this._paused||v);)(s._active||s._startTime<=this._time&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=o;else for(s=this._last;s&&(o=s._prev,!this._paused||v);)(s._active||f>=s._startTime&&!s._paused&&!s._gc)&&(s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=o;this._onUpdate&&(e||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||n)),h&&(this._locked||this._gc||(m===this._startTime||d!==this._timeScale)&&(0===this._time||u>=this.totalDuration())&&(a&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[h]&&this.vars[h].apply(this.vars[h+"Scope"]||this,this.vars[h+"Params"]||n)))},o.getActive=function(t,e,i){null==t&&(t=!0),null==e&&(e=!0),null==i&&(i=!1);var s,r,n=[],a=this.getChildren(t,e,i),o=0,h=a.length;for(s=0;h>s;s++)r=a[s],r.isActive()&&(n[o++]=r);return n},o.getLabelAfter=function(t){t||0!==t&&(t=this._time);var e,i=this.getLabelsArray(),s=i.length;for(e=0;s>e;e++)if(i[e].time>t)return i[e].name;return null},o.getLabelBefore=function(t){null==t&&(t=this._time);for(var e=this.getLabelsArray(),i=e.length;--i>-1;)if(t>e[i].time)return e[i].name;return null},o.getLabelsArray=function(){var t,e=[],i=0;for(t in this._labels)e[i++]={time:this._labels[t],name:t};return e.sort(function(t,e){return t.time-e.time}),e},o.progress=function(t){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-t:t)+this._cycle*(this._duration+this._repeatDelay),!1):this._time/this.duration()},o.totalProgress=function(t){return arguments.length?this.totalTime(this.totalDuration()*t,!1):this._totalTime/this.totalDuration()},o.totalDuration=function(e){return arguments.length?-1===this._repeat?this:this.duration((e-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(t.prototype.totalDuration.call(this),this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat),this._totalDuration)},o.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),t>this._duration&&(t=this._duration),this._yoyo&&0!==(1&this._cycle)?t=this._duration-t+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(t+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(t,e)):this._time},o.repeat=function(t){return arguments.length?(this._repeat=t,this._uncache(!0)):this._repeat},o.repeatDelay=function(t){return arguments.length?(this._repeatDelay=t,this._uncache(!0)):this._repeatDelay},o.yoyo=function(t){return arguments.length?(this._yoyo=t,this):this._yoyo},o.currentLabel=function(t){return arguments.length?this.seek(t,!0):this.getLabelBefore(this._time+1e-8)},s},!0),function(){var t=180/Math.PI,e=[],i=[],s=[],r={},n=function(t,e,i,s){this.a=t,this.b=e,this.c=i,this.d=s,this.da=s-t,this.ca=i-t,this.ba=e-t},a=",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",o=function(t,e,i,s){var r={a:t},n={},a={},o={c:s},h=(t+e)/2,l=(e+i)/2,_=(i+s)/2,u=(h+l)/2,p=(l+_)/2,f=(p-u)/8;return r.b=h+(t-h)/4,n.b=u+f,r.c=n.a=(r.b+n.b)/2,n.c=a.a=(u+p)/2,a.b=p-f,o.b=_+(s-_)/4,a.c=o.a=(a.b+o.b)/2,[r,n,a,o]},h=function(t,r,n,a,h){var l,_,u,p,f,c,m,d,g,v,y,T,w,x=t.length-1,b=0,P=t[0].a;for(l=0;x>l;l++)f=t[b],_=f.a,u=f.d,p=t[b+1].d,h?(y=e[l],T=i[l],w=.25*(T+y)*r/(a?.5:s[l]||.5),c=u-(u-_)*(a?.5*r:0!==y?w/y:0),m=u+(p-u)*(a?.5*r:0!==T?w/T:0),d=u-(c+((m-c)*(3*y/(y+T)+.5)/4||0))):(c=u-.5*(u-_)*r,m=u+.5*(p-u)*r,d=u-(c+m)/2),c+=d,m+=d,f.c=g=c,f.b=0!==l?P:P=f.a+.6*(f.c-f.a),f.da=u-_,f.ca=g-_,f.ba=P-_,n?(v=o(_,P,g,u),t.splice(b,1,v[0],v[1],v[2],v[3]),b+=4):b++,P=m;f=t[b],f.b=P,f.c=P+.4*(f.d-P),f.da=f.d-f.a,f.ca=f.c-f.a,f.ba=P-f.a,n&&(v=o(f.a,P,f.c,f.d),t.splice(b,1,v[0],v[1],v[2],v[3]))},l=function(t,s,r,a){var o,h,l,_,u,p,f=[];if(a)for(t=[a].concat(t),h=t.length;--h>-1;)"string"==typeof(p=t[h][s])&&"="===p.charAt(1)&&(t[h][s]=a[s]+Number(p.charAt(0)+p.substr(2)));if(o=t.length-2,0>o)return f[0]=new n(t[0][s],0,0,t[-1>o?0:1][s]),f;for(h=0;o>h;h++)l=t[h][s],_=t[h+1][s],f[h]=new n(l,0,0,_),r&&(u=t[h+2][s],e[h]=(e[h]||0)+(_-l)*(_-l),i[h]=(i[h]||0)+(u-_)*(u-_));return f[h]=new n(t[h][s],0,0,t[h+1][s]),f},_=function(t,n,o,_,u,p){var f,c,m,d,g,v,y,T,w={},x=[],b=p||t[0];u="string"==typeof u?","+u+",":a,null==n&&(n=1);for(c in t[0])x.push(c);if(t.length>1){for(T=t[t.length-1],y=!0,f=x.length;--f>-1;)if(c=x[f],Math.abs(b[c]-T[c])>.05){y=!1;break}y&&(t=t.concat(),p&&t.unshift(p),t.push(t[1]),p=t[t.length-3])}for(e.length=i.length=s.length=0,f=x.length;--f>-1;)c=x[f],r[c]=-1!==u.indexOf(","+c+","),w[c]=l(t,c,r[c],p);for(f=e.length;--f>-1;)e[f]=Math.sqrt(e[f]),i[f]=Math.sqrt(i[f]);if(!_){for(f=x.length;--f>-1;)if(r[c])for(m=w[x[f]],v=m.length-1,d=0;v>d;d++)g=m[d+1].da/i[d]+m[d].da/e[d],s[d]=(s[d]||0)+g*g;for(f=s.length;--f>-1;)s[f]=Math.sqrt(s[f])}for(f=x.length,d=o?4:1;--f>-1;)c=x[f],m=w[c],h(m,n,o,_,r[c]),y&&(m.splice(0,d),m.splice(m.length-d,d));return w},u=function(t,e,i){e=e||"soft";var s,r,a,o,h,l,_,u,p,f,c,m={},d="cubic"===e?3:2,g="soft"===e,v=[];if(g&&i&&(t=[i].concat(t)),null==t||d+1>t.length)throw"invalid Bezier data";for(p in t[0])v.push(p);for(l=v.length;--l>-1;){for(p=v[l],m[p]=h=[],f=0,u=t.length,_=0;u>_;_++)s=null==i?t[_][p]:"string"==typeof(c=t[_][p])&&"="===c.charAt(1)?i[p]+Number(c.charAt(0)+c.substr(2)):Number(c),g&&_>1&&u-1>_&&(h[f++]=(s+h[f-2])/2),h[f++]=s;for(u=f-d+1,f=0,_=0;u>_;_+=d)s=h[_],r=h[_+1],a=h[_+2],o=2===d?0:h[_+3],h[f++]=c=3===d?new n(s,r,a,o):new n(s,(2*r+s)/3,(2*r+a)/3,a);h.length=f}return m},p=function(t,e,i){for(var s,r,n,a,o,h,l,_,u,p,f,c=1/i,m=t.length;--m>-1;)for(p=t[m],n=p.a,a=p.d-n,o=p.c-n,h=p.b-n,s=r=0,_=1;i>=_;_++)l=c*_,u=1-l,s=r-(r=(l*l*a+3*u*(l*o+u*h))*l),f=m*i+_-1,e[f]=(e[f]||0)+s*s},f=function(t,e){e=e>>0||6;var i,s,r,n,a=[],o=[],h=0,l=0,_=e-1,u=[],f=[];for(i in t)p(t[i],a,e);for(r=a.length,s=0;r>s;s++)h+=Math.sqrt(a[s]),n=s%e,f[n]=h,n===_&&(l+=h,n=s/e>>0,u[n]=f,o[n]=l,h=0,f=[]);return{length:l,lengths:o,segments:u}},c=window._gsDefine.plugin({propName:"bezier",priority:-1,API:2,global:!0,init:function(t,e,i){this._target=t,e instanceof Array&&(e={values:e}),this._func={},this._round={},this._props=[],this._timeRes=null==e.timeResolution?6:parseInt(e.timeResolution,10);var s,r,n,a,o,h=e.values||[],l={},p=h[0],c=e.autoRotate||i.vars.orientToBezier;this._autoRotate=c?c instanceof Array?c:[["x","y","rotation",c===!0?0:Number(c)||0]]:null;for(s in p)this._props.push(s);for(n=this._props.length;--n>-1;)s=this._props[n],this._overwriteProps.push(s),r=this._func[s]="function"==typeof t[s],l[s]=r?t[s.indexOf("set")||"function"!=typeof t["get"+s.substr(3)]?s:"get"+s.substr(3)]():parseFloat(t[s]),o||l[s]!==h[0][s]&&(o=l);if(this._beziers="cubic"!==e.type&&"quadratic"!==e.type&&"soft"!==e.type?_(h,isNaN(e.curviness)?1:e.curviness,!1,"thruBasic"===e.type,e.correlate,o):u(h,e.type,l),this._segCount=this._beziers[s].length,this._timeRes){var m=f(this._beziers,this._timeRes);this._length=m.length,this._lengths=m.lengths,this._segments=m.segments,this._l1=this._li=this._s1=this._si=0,this._l2=this._lengths[0],this._curSeg=this._segments[0],this._s2=this._curSeg[0],this._prec=1/this._curSeg.length}if(c=this._autoRotate)for(c[0]instanceof Array||(this._autoRotate=c=[c]),n=c.length;--n>-1;)for(a=0;3>a;a++)s=c[n][a],this._func[s]="function"==typeof t[s]?t[s.indexOf("set")||"function"!=typeof t["get"+s.substr(3)]?s:"get"+s.substr(3)]:!1;return!0},set:function(e){var i,s,r,n,a,o,h,l,_,u,p=this._segCount,f=this._func,c=this._target;if(this._timeRes){if(_=this._lengths,u=this._curSeg,e*=this._length,r=this._li,e>this._l2&&p-1>r){for(l=p-1;l>r&&e>=(this._l2=_[++r]););this._l1=_[r-1],this._li=r,this._curSeg=u=this._segments[r],this._s2=u[this._s1=this._si=0]}else if(this._l1>e&&r>0){for(;r>0&&(this._l1=_[--r])>=e;);0===r&&this._l1>e?this._l1=0:r++,this._l2=_[r],this._li=r,this._curSeg=u=this._segments[r],this._s1=u[(this._si=u.length-1)-1]||0,this._s2=u[this._si]}if(i=r,e-=this._l1,r=this._si,e>this._s2&&u.length-1>r){for(l=u.length-1;l>r&&e>=(this._s2=u[++r]););this._s1=u[r-1],this._si=r}else if(this._s1>e&&r>0){for(;r>0&&(this._s1=u[--r])>=e;);0===r&&this._s1>e?this._s1=0:r++,this._s2=u[r],this._si=r}o=(r+(e-this._s1)/(this._s2-this._s1))*this._prec}else i=0>e?0:e>=1?p-1:p*e>>0,o=(e-i*(1/p))*p;for(s=1-o,r=this._props.length;--r>-1;)n=this._props[r],a=this._beziers[n][i],h=(o*o*a.da+3*s*(o*a.ca+s*a.ba))*o+a.a,this._round[n]&&(h=h+(h>0?.5:-.5)>>0),f[n]?c[n](h):c[n]=h;if(this._autoRotate){var m,d,g,v,y,T,w,x=this._autoRotate;for(r=x.length;--r>-1;)n=x[r][2],T=x[r][3]||0,w=x[r][4]===!0?1:t,a=this._beziers[x[r][0]],m=this._beziers[x[r][1]],a&&m&&(a=a[i],m=m[i],d=a.a+(a.b-a.a)*o,v=a.b+(a.c-a.b)*o,d+=(v-d)*o,v+=(a.c+(a.d-a.c)*o-v)*o,g=m.a+(m.b-m.a)*o,y=m.b+(m.c-m.b)*o,g+=(y-g)*o,y+=(m.c+(m.d-m.c)*o-y)*o,h=Math.atan2(y-g,v-d)*w+T,f[n]?c[n](h):c[n]=h)}}}),m=c.prototype;c.bezierThrough=_,c.cubicToQuadratic=o,c._autoCSS=!0,c.quadraticToCubic=function(t,e,i){return new n(t,(2*e+t)/3,(2*e+i)/3,i)},c._cssRegister=function(){var t=window._gsDefine.globals.CSSPlugin;if(t){var e=t._internals,i=e._parseToProxy,s=e._setPluginRatio,r=e.CSSPropTween;e._registerComplexSpecialProp("bezier",{parser:function(t,e,n,a,o,h){e instanceof Array&&(e={values:e}),h=new c;var l,_,u,p=e.values,f=p.length-1,m=[],d={};if(0>f)return o;for(l=0;f>=l;l++)u=i(t,p[l],a,o,h,f!==l),m[l]=u.end;for(_ in e)d[_]=e[_];return d.values=m,o=new r(t,"bezier",0,0,u.pt,2),o.data=u,o.plugin=h,o.setRatio=s,0===d.autoRotate&&(d.autoRotate=!0),!d.autoRotate||d.autoRotate instanceof Array||(l=d.autoRotate===!0?0:Number(d.autoRotate),d.autoRotate=null!=u.end.left?[["left","top","rotation",l,!1]]:null!=u.end.x?[["x","y","rotation",l,!1]]:!1),d.autoRotate&&(a._transform||a._enableTransforms(!1),u.autoRotate=a._target._gsTransform),h._onInitTween(u.proxy,d,a._tween),o}})}},m._roundProps=function(t,e){for(var i=this._overwriteProps,s=i.length;--s>-1;)(t[i[s]]||t.bezier||t.bezierThrough)&&(this._round[i[s]]=e)},m._kill=function(t){var e,i,s=this._props;
for(e in this._beziers)if(e in t)for(delete this._beziers[e],delete this._func[e],i=s.length;--i>-1;)s[i]===e&&s.splice(i,1);return this._super._kill.call(this,t)}}(),window._gsDefine("plugins.CSSPlugin",["plugins.TweenPlugin","TweenLite"],function(t,e){var i,s,r,n,a=function(){t.call(this,"css"),this._overwriteProps.length=0,this.setRatio=a.prototype.setRatio},o={},h=a.prototype=new t("css");h.constructor=a,a.version="1.11.0",a.API=2,a.defaultTransformPerspective=0,h="px",a.suffixMap={top:h,right:h,bottom:h,left:h,width:h,height:h,fontSize:h,padding:h,margin:h,perspective:h};var l,_,u,p,f,c,m=/(?:\d|\-\d|\.\d|\-\.\d)+/g,d=/(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,g=/(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,v=/[^\d\-\.]/g,y=/(?:\d|\-|\+|=|#|\.)*/g,T=/opacity *= *([^)]*)/,w=/opacity:([^;]*)/,x=/alpha\(opacity *=.+?\)/i,b=/^(rgb|hsl)/,P=/([A-Z])/g,S=/-([a-z])/gi,k=/(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,R=function(t,e){return e.toUpperCase()},A=/(?:Left|Right|Width)/i,C=/(M11|M12|M21|M22)=[\d\-\.e]+/gi,O=/progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,D=/,(?=[^\)]*(?:\(|$))/gi,M=Math.PI/180,I=180/Math.PI,F={},E=document,N=E.createElement("div"),L=E.createElement("img"),X=a._internals={_specialProps:o},z=navigator.userAgent,U=function(){var t,e=z.indexOf("Android"),i=E.createElement("div");return u=-1!==z.indexOf("Safari")&&-1===z.indexOf("Chrome")&&(-1===e||Number(z.substr(e+8,1))>3),f=u&&6>Number(z.substr(z.indexOf("Version/")+8,1)),p=-1!==z.indexOf("Firefox"),/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(z),c=parseFloat(RegExp.$1),i.innerHTML="<a style='top:1px;opacity:.55;'>a</a>",t=i.getElementsByTagName("a")[0],t?/^0.55/.test(t.style.opacity):!1}(),Y=function(t){return T.test("string"==typeof t?t:(t.currentStyle?t.currentStyle.filter:t.style.filter)||"")?parseFloat(RegExp.$1)/100:1},j=function(t){window.console&&console.log(t)},B="",q="",V=function(t,e){e=e||N;var i,s,r=e.style;if(void 0!==r[t])return t;for(t=t.charAt(0).toUpperCase()+t.substr(1),i=["O","Moz","ms","Ms","Webkit"],s=5;--s>-1&&void 0===r[i[s]+t];);return s>=0?(q=3===s?"ms":i[s],B="-"+q.toLowerCase()+"-",q+t):null},Z=E.defaultView?E.defaultView.getComputedStyle:function(){},G=a.getStyle=function(t,e,i,s,r){var n;return U||"opacity"!==e?(!s&&t.style[e]?n=t.style[e]:(i=i||Z(t,null))?(t=i.getPropertyValue(e.replace(P,"-$1").toLowerCase()),n=t||i.length?t:i[e]):t.currentStyle&&(n=t.currentStyle[e]),null==r||n&&"none"!==n&&"auto"!==n&&"auto auto"!==n?n:r):Y(t)},$=function(t,e,i,s,r){if("px"===s||!s)return i;if("auto"===s||!i)return 0;var n,a=A.test(e),o=t,h=N.style,l=0>i;return l&&(i=-i),"%"===s&&-1!==e.indexOf("border")?n=i/100*(a?t.clientWidth:t.clientHeight):(h.cssText="border-style:solid;border-width:0;position:absolute;line-height:0;","%"!==s&&o.appendChild?h[a?"borderLeftWidth":"borderTopWidth"]=i+s:(o=t.parentNode||E.body,h[a?"width":"height"]=i+s),o.appendChild(N),n=parseFloat(N[a?"offsetWidth":"offsetHeight"]),o.removeChild(N),0!==n||r||(n=$(t,e,i,s,!0))),l?-n:n},Q=function(t,e,i){if("absolute"!==G(t,"position",i))return 0;var s="left"===e?"Left":"Top",r=G(t,"margin"+s,i);return t["offset"+s]-($(t,e,parseFloat(r),r.replace(y,""))||0)},W=function(t,e){var i,s,r={};if(e=e||Z(t,null))if(i=e.length)for(;--i>-1;)r[e[i].replace(S,R)]=e.getPropertyValue(e[i]);else for(i in e)r[i]=e[i];else if(e=t.currentStyle||t.style)for(i in e)"string"==typeof i&&void 0!==r[i]&&(r[i.replace(S,R)]=e[i]);return U||(r.opacity=Y(t)),s=be(t,e,!1),r.rotation=s.rotation,r.skewX=s.skewX,r.scaleX=s.scaleX,r.scaleY=s.scaleY,r.x=s.x,r.y=s.y,xe&&(r.z=s.z,r.rotationX=s.rotationX,r.rotationY=s.rotationY,r.scaleZ=s.scaleZ),r.filters&&delete r.filters,r},H=function(t,e,i,s,r){var n,a,o,h={},l=t.style;for(a in i)"cssText"!==a&&"length"!==a&&isNaN(a)&&(e[a]!==(n=i[a])||r&&r[a])&&-1===a.indexOf("Origin")&&("number"==typeof n||"string"==typeof n)&&(h[a]="auto"!==n||"left"!==a&&"top"!==a?""!==n&&"auto"!==n&&"none"!==n||"string"!=typeof e[a]||""===e[a].replace(v,"")?n:0:Q(t,a),void 0!==l[a]&&(o=new ue(l,a,l[a],o)));if(s)for(a in s)"className"!==a&&(h[a]=s[a]);return{difs:h,firstMPT:o}},K={width:["Left","Right"],height:["Top","Bottom"]},J=["marginLeft","marginRight","marginTop","marginBottom"],te=function(t,e,i){var s=parseFloat("width"===e?t.offsetWidth:t.offsetHeight),r=K[e],n=r.length;for(i=i||Z(t,null);--n>-1;)s-=parseFloat(G(t,"padding"+r[n],i,!0))||0,s-=parseFloat(G(t,"border"+r[n]+"Width",i,!0))||0;return s},ee=function(t,e){(null==t||""===t||"auto"===t||"auto auto"===t)&&(t="0 0");var i=t.split(" "),s=-1!==t.indexOf("left")?"0%":-1!==t.indexOf("right")?"100%":i[0],r=-1!==t.indexOf("top")?"0%":-1!==t.indexOf("bottom")?"100%":i[1];return null==r?r="0":"center"===r&&(r="50%"),("center"===s||isNaN(parseFloat(s))&&-1===(s+"").indexOf("="))&&(s="50%"),e&&(e.oxp=-1!==s.indexOf("%"),e.oyp=-1!==r.indexOf("%"),e.oxr="="===s.charAt(1),e.oyr="="===r.charAt(1),e.ox=parseFloat(s.replace(v,"")),e.oy=parseFloat(r.replace(v,""))),s+" "+r+(i.length>2?" "+i[2]:"")},ie=function(t,e){return"string"==typeof t&&"="===t.charAt(1)?parseInt(t.charAt(0)+"1",10)*parseFloat(t.substr(2)):parseFloat(t)-parseFloat(e)},se=function(t,e){return null==t?e:"string"==typeof t&&"="===t.charAt(1)?parseInt(t.charAt(0)+"1",10)*Number(t.substr(2))+e:parseFloat(t)},re=function(t,e,i,s){var r,n,a,o,h=1e-6;return null==t?o=e:"number"==typeof t?o=t:(r=360,n=t.split("_"),a=Number(n[0].replace(v,""))*(-1===t.indexOf("rad")?1:I)-("="===t.charAt(1)?0:e),n.length&&(s&&(s[i]=e+a),-1!==t.indexOf("short")&&(a%=r,a!==a%(r/2)&&(a=0>a?a+r:a-r)),-1!==t.indexOf("_cw")&&0>a?a=(a+9999999999*r)%r-(0|a/r)*r:-1!==t.indexOf("ccw")&&a>0&&(a=(a-9999999999*r)%r-(0|a/r)*r)),o=e+a),h>o&&o>-h&&(o=0),o},ne={aqua:[0,255,255],lime:[0,255,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,255],navy:[0,0,128],white:[255,255,255],fuchsia:[255,0,255],olive:[128,128,0],yellow:[255,255,0],orange:[255,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[255,0,0],pink:[255,192,203],cyan:[0,255,255],transparent:[255,255,255,0]},ae=function(t,e,i){return t=0>t?t+1:t>1?t-1:t,0|255*(1>6*t?e+6*(i-e)*t:.5>t?i:2>3*t?e+6*(i-e)*(2/3-t):e)+.5},oe=function(t){var e,i,s,r,n,a;return t&&""!==t?"number"==typeof t?[t>>16,255&t>>8,255&t]:(","===t.charAt(t.length-1)&&(t=t.substr(0,t.length-1)),ne[t]?ne[t]:"#"===t.charAt(0)?(4===t.length&&(e=t.charAt(1),i=t.charAt(2),s=t.charAt(3),t="#"+e+e+i+i+s+s),t=parseInt(t.substr(1),16),[t>>16,255&t>>8,255&t]):"hsl"===t.substr(0,3)?(t=t.match(m),r=Number(t[0])%360/360,n=Number(t[1])/100,a=Number(t[2])/100,i=.5>=a?a*(n+1):a+n-a*n,e=2*a-i,t.length>3&&(t[3]=Number(t[3])),t[0]=ae(r+1/3,e,i),t[1]=ae(r,e,i),t[2]=ae(r-1/3,e,i),t):(t=t.match(m)||ne.transparent,t[0]=Number(t[0]),t[1]=Number(t[1]),t[2]=Number(t[2]),t.length>3&&(t[3]=Number(t[3])),t)):ne.black},he="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";for(h in ne)he+="|"+h+"\\b";he=RegExp(he+")","gi");var le=function(t,e,i,s){if(null==t)return function(t){return t};var r,n=e?(t.match(he)||[""])[0]:"",a=t.split(n).join("").match(g)||[],o=t.substr(0,t.indexOf(a[0])),h=")"===t.charAt(t.length-1)?")":"",l=-1!==t.indexOf(" ")?" ":",",_=a.length,u=_>0?a[0].replace(m,""):"";return _?r=e?function(t){var e,p,f,c;if("number"==typeof t)t+=u;else if(s&&D.test(t)){for(c=t.replace(D,"|").split("|"),f=0;c.length>f;f++)c[f]=r(c[f]);return c.join(",")}if(e=(t.match(he)||[n])[0],p=t.split(e).join("").match(g)||[],f=p.length,_>f--)for(;_>++f;)p[f]=i?p[0|(f-1)/2]:a[f];return o+p.join(l)+l+e+h+(-1!==t.indexOf("inset")?" inset":"")}:function(t){var e,n,p;if("number"==typeof t)t+=u;else if(s&&D.test(t)){for(n=t.replace(D,"|").split("|"),p=0;n.length>p;p++)n[p]=r(n[p]);return n.join(",")}if(e=t.match(g)||[],p=e.length,_>p--)for(;_>++p;)e[p]=i?e[0|(p-1)/2]:a[p];return o+e.join(l)+h}:function(t){return t}},_e=function(t){return t=t.split(","),function(e,i,s,r,n,a,o){var h,l=(i+"").split(" ");for(o={},h=0;4>h;h++)o[t[h]]=l[h]=l[h]||l[(h-1)/2>>0];return r.parse(e,o,n,a)}},ue=(X._setPluginRatio=function(t){this.plugin.setRatio(t);for(var e,i,s,r,n=this.data,a=n.proxy,o=n.firstMPT,h=1e-6;o;)e=a[o.v],o.r?e=e>0?0|e+.5:0|e-.5:h>e&&e>-h&&(e=0),o.t[o.p]=e,o=o._next;if(n.autoRotate&&(n.autoRotate.rotation=a.rotation),1===t)for(o=n.firstMPT;o;){if(i=o.t,i.type){if(1===i.type){for(r=i.xs0+i.s+i.xs1,s=1;i.l>s;s++)r+=i["xn"+s]+i["xs"+(s+1)];i.e=r}}else i.e=i.s+i.xs0;o=o._next}},function(t,e,i,s,r){this.t=t,this.p=e,this.v=i,this.r=r,s&&(s._prev=this,this._next=s)}),pe=(X._parseToProxy=function(t,e,i,s,r,n){var a,o,h,l,_,u=s,p={},f={},c=i._transform,m=F;for(i._transform=null,F=e,s=_=i.parse(t,e,s,r),F=m,n&&(i._transform=c,u&&(u._prev=null,u._prev&&(u._prev._next=null)));s&&s!==u;){if(1>=s.type&&(o=s.p,f[o]=s.s+s.c,p[o]=s.s,n||(l=new ue(s,"s",o,l,s.r),s.c=0),1===s.type))for(a=s.l;--a>0;)h="xn"+a,o=s.p+"_"+h,f[o]=s.data[h],p[o]=s[h],n||(l=new ue(s,h,o,l,s.rxp[h]));s=s._next}return{proxy:p,end:f,firstMPT:l,pt:_}},X.CSSPropTween=function(t,e,s,r,a,o,h,l,_,u,p){this.t=t,this.p=e,this.s=s,this.c=r,this.n=h||e,t instanceof pe||n.push(this.n),this.r=l,this.type=o||0,_&&(this.pr=_,i=!0),this.b=void 0===u?s:u,this.e=void 0===p?s+r:p,a&&(this._next=a,a._prev=this)}),fe=a.parseComplex=function(t,e,i,s,r,n,a,o,h,_){i=i||n||"",a=new pe(t,e,0,0,a,_?2:1,null,!1,o,i,s),s+="";var u,p,f,c,g,v,y,T,w,x,P,S,k=i.split(", ").join(",").split(" "),R=s.split(", ").join(",").split(" "),A=k.length,C=l!==!1;for((-1!==s.indexOf(",")||-1!==i.indexOf(","))&&(k=k.join(" ").replace(D,", ").split(" "),R=R.join(" ").replace(D,", ").split(" "),A=k.length),A!==R.length&&(k=(n||"").split(" "),A=k.length),a.plugin=h,a.setRatio=_,u=0;A>u;u++)if(c=k[u],g=R[u],T=parseFloat(c),T||0===T)a.appendXtra("",T,ie(g,T),g.replace(d,""),C&&-1!==g.indexOf("px"),!0);else if(r&&("#"===c.charAt(0)||ne[c]||b.test(c)))S=","===g.charAt(g.length-1)?"),":")",c=oe(c),g=oe(g),w=c.length+g.length>6,w&&!U&&0===g[3]?(a["xs"+a.l]+=a.l?" transparent":"transparent",a.e=a.e.split(R[u]).join("transparent")):(U||(w=!1),a.appendXtra(w?"rgba(":"rgb(",c[0],g[0]-c[0],",",!0,!0).appendXtra("",c[1],g[1]-c[1],",",!0).appendXtra("",c[2],g[2]-c[2],w?",":S,!0),w&&(c=4>c.length?1:c[3],a.appendXtra("",c,(4>g.length?1:g[3])-c,S,!1)));else if(v=c.match(m)){if(y=g.match(d),!y||y.length!==v.length)return a;for(f=0,p=0;v.length>p;p++)P=v[p],x=c.indexOf(P,f),a.appendXtra(c.substr(f,x-f),Number(P),ie(y[p],P),"",C&&"px"===c.substr(x+P.length,2),0===p),f=x+P.length;a["xs"+a.l]+=c.substr(f)}else a["xs"+a.l]+=a.l?" "+c:c;if(-1!==s.indexOf("=")&&a.data){for(S=a.xs0+a.data.s,u=1;a.l>u;u++)S+=a["xs"+u]+a.data["xn"+u];a.e=S+a["xs"+u]}return a.l||(a.type=-1,a.xs0=a.e),a.xfirst||a},ce=9;for(h=pe.prototype,h.l=h.pr=0;--ce>0;)h["xn"+ce]=0,h["xs"+ce]="";h.xs0="",h._next=h._prev=h.xfirst=h.data=h.plugin=h.setRatio=h.rxp=null,h.appendXtra=function(t,e,i,s,r,n){var a=this,o=a.l;return a["xs"+o]+=n&&o?" "+t:t||"",i||0===o||a.plugin?(a.l++,a.type=a.setRatio?2:1,a["xs"+a.l]=s||"",o>0?(a.data["xn"+o]=e+i,a.rxp["xn"+o]=r,a["xn"+o]=e,a.plugin||(a.xfirst=new pe(a,"xn"+o,e,i,a.xfirst||a,0,a.n,r,a.pr),a.xfirst.xs0=0),a):(a.data={s:e+i},a.rxp={},a.s=e,a.c=i,a.r=r,a)):(a["xs"+o]+=e+(s||""),a)};var me=function(t,e){e=e||{},this.p=e.prefix?V(t)||t:t,o[t]=o[this.p]=this,this.format=e.formatter||le(e.defaultValue,e.color,e.collapsible,e.multi),e.parser&&(this.parse=e.parser),this.clrs=e.color,this.multi=e.multi,this.keyword=e.keyword,this.dflt=e.defaultValue,this.pr=e.priority||0},de=X._registerComplexSpecialProp=function(t,e,i){"object"!=typeof e&&(e={parser:i});var s,r,n=t.split(","),a=e.defaultValue;for(i=i||[a],s=0;n.length>s;s++)e.prefix=0===s&&e.prefix,e.defaultValue=i[s]||a,r=new me(n[s],e)},ge=function(t){if(!o[t]){var e=t.charAt(0).toUpperCase()+t.substr(1)+"Plugin";de(t,{parser:function(t,i,s,r,n,a,h){var l=(window.GreenSockGlobals||window).com.greensock.plugins[e];return l?(l._cssRegister(),o[s].parse(t,i,s,r,n,a,h)):(j("Error: "+e+" js file not loaded."),n)}})}};h=me.prototype,h.parseComplex=function(t,e,i,s,r,n){var a,o,h,l,_,u,p=this.keyword;if(this.multi&&(D.test(i)||D.test(e)?(o=e.replace(D,"|").split("|"),h=i.replace(D,"|").split("|")):p&&(o=[e],h=[i])),h){for(l=h.length>o.length?h.length:o.length,a=0;l>a;a++)e=o[a]=o[a]||this.dflt,i=h[a]=h[a]||this.dflt,p&&(_=e.indexOf(p),u=i.indexOf(p),_!==u&&(i=-1===u?h:o,i[a]+=" "+p));e=o.join(", "),i=h.join(", ")}return fe(t,this.p,e,i,this.clrs,this.dflt,s,this.pr,r,n)},h.parse=function(t,e,i,s,n,a){return this.parseComplex(t.style,this.format(G(t,this.p,r,!1,this.dflt)),this.format(e),n,a)},a.registerSpecialProp=function(t,e,i){de(t,{parser:function(t,s,r,n,a,o){var h=new pe(t,r,0,0,a,2,r,!1,i);return h.plugin=o,h.setRatio=e(t,s,n._tween,r),h},priority:i})};var ve="scaleX,scaleY,scaleZ,x,y,z,skewX,rotation,rotationX,rotationY,perspective".split(","),ye=V("transform"),Te=B+"transform",we=V("transformOrigin"),xe=null!==V("perspective"),be=function(t,e,i,s){if(t._gsTransform&&i&&!s)return t._gsTransform;var r,n,o,h,l,_,u,p,f,c,m,d,g,v=i?t._gsTransform||{skewY:0}:{skewY:0},y=0>v.scaleX,T=2e-5,w=1e5,x=179.99,b=x*M,P=xe?parseFloat(G(t,we,e,!1,"0 0 0").split(" ")[2])||v.zOrigin||0:0;for(ye?r=G(t,Te,e,!0):t.currentStyle&&(r=t.currentStyle.filter.match(C),r=r&&4===r.length?[r[0].substr(4),Number(r[2].substr(4)),Number(r[1].substr(4)),r[3].substr(4),v.x||0,v.y||0].join(","):""),n=(r||"").match(/(?:\-|\b)[\d\-\.e]+\b/gi)||[],o=n.length;--o>-1;)h=Number(n[o]),n[o]=(l=h-(h|=0))?(0|l*w+(0>l?-.5:.5))/w+h:h;if(16===n.length){var S=n[8],k=n[9],R=n[10],A=n[12],O=n[13],D=n[14];if(v.zOrigin&&(D=-v.zOrigin,A=S*D-n[12],O=k*D-n[13],D=R*D+v.zOrigin-n[14]),!i||s||null==v.rotationX){var F,E,N,L,X,z,U,Y=n[0],j=n[1],B=n[2],q=n[3],V=n[4],Z=n[5],$=n[6],Q=n[7],W=n[11],H=Math.atan2($,R),K=-b>H||H>b;v.rotationX=H*I,H&&(L=Math.cos(-H),X=Math.sin(-H),F=V*L+S*X,E=Z*L+k*X,N=$*L+R*X,S=V*-X+S*L,k=Z*-X+k*L,R=$*-X+R*L,W=Q*-X+W*L,V=F,Z=E,$=N),H=Math.atan2(S,Y),v.rotationY=H*I,H&&(z=-b>H||H>b,L=Math.cos(-H),X=Math.sin(-H),F=Y*L-S*X,E=j*L-k*X,N=B*L-R*X,k=j*X+k*L,R=B*X+R*L,W=q*X+W*L,Y=F,j=E,B=N),H=Math.atan2(j,Z),v.rotation=H*I,H&&(U=-b>H||H>b,L=Math.cos(-H),X=Math.sin(-H),Y=Y*L+V*X,E=j*L+Z*X,Z=j*-X+Z*L,$=B*-X+$*L,j=E),U&&K?v.rotation=v.rotationX=0:U&&z?v.rotation=v.rotationY=0:z&&K&&(v.rotationY=v.rotationX=0),v.scaleX=(0|Math.sqrt(Y*Y+j*j)*w+.5)/w,v.scaleY=(0|Math.sqrt(Z*Z+k*k)*w+.5)/w,v.scaleZ=(0|Math.sqrt($*$+R*R)*w+.5)/w,v.skewX=0,v.perspective=W?1/(0>W?-W:W):0,v.x=A,v.y=O,v.z=D}}else if(!(xe&&!s&&n.length&&v.x===n[4]&&v.y===n[5]&&(v.rotationX||v.rotationY)||void 0!==v.x&&"none"===G(t,"display",e))){var J=n.length>=6,te=J?n[0]:1,ee=n[1]||0,ie=n[2]||0,se=J?n[3]:1;v.x=n[4]||0,v.y=n[5]||0,_=Math.sqrt(te*te+ee*ee),u=Math.sqrt(se*se+ie*ie),p=te||ee?Math.atan2(ee,te)*I:v.rotation||0,f=ie||se?Math.atan2(ie,se)*I+p:v.skewX||0,c=_-Math.abs(v.scaleX||0),m=u-Math.abs(v.scaleY||0),Math.abs(f)>90&&270>Math.abs(f)&&(y?(_*=-1,f+=0>=p?180:-180,p+=0>=p?180:-180):(u*=-1,f+=0>=f?180:-180)),d=(p-v.rotation)%180,g=(f-v.skewX)%180,(void 0===v.skewX||c>T||-T>c||m>T||-T>m||d>-x&&x>d&&false|d*w||g>-x&&x>g&&false|g*w)&&(v.scaleX=_,v.scaleY=u,v.rotation=p,v.skewX=f),xe&&(v.rotationX=v.rotationY=v.z=0,v.perspective=parseFloat(a.defaultTransformPerspective)||0,v.scaleZ=1)}v.zOrigin=P;for(o in v)T>v[o]&&v[o]>-T&&(v[o]=0);return i&&(t._gsTransform=v),v},Pe=function(t){var e,i,s=this.data,r=-s.rotation*M,n=r+s.skewX*M,a=1e5,o=(0|Math.cos(r)*s.scaleX*a)/a,h=(0|Math.sin(r)*s.scaleX*a)/a,l=(0|Math.sin(n)*-s.scaleY*a)/a,_=(0|Math.cos(n)*s.scaleY*a)/a,u=this.t.style,p=this.t.currentStyle;if(p){i=h,h=-l,l=-i,e=p.filter,u.filter="";var f,m,d=this.t.offsetWidth,g=this.t.offsetHeight,v="absolute"!==p.position,w="progid:DXImageTransform.Microsoft.Matrix(M11="+o+", M12="+h+", M21="+l+", M22="+_,x=s.x,b=s.y;if(null!=s.ox&&(f=(s.oxp?.01*d*s.ox:s.ox)-d/2,m=(s.oyp?.01*g*s.oy:s.oy)-g/2,x+=f-(f*o+m*h),b+=m-(f*l+m*_)),v?(f=d/2,m=g/2,w+=", Dx="+(f-(f*o+m*h)+x)+", Dy="+(m-(f*l+m*_)+b)+")"):w+=", sizingMethod='auto expand')",u.filter=-1!==e.indexOf("DXImageTransform.Microsoft.Matrix(")?e.replace(O,w):w+" "+e,(0===t||1===t)&&1===o&&0===h&&0===l&&1===_&&(v&&-1===w.indexOf("Dx=0, Dy=0")||T.test(e)&&100!==parseFloat(RegExp.$1)||-1===e.indexOf("gradient("&&e.indexOf("Alpha"))&&u.removeAttribute("filter")),!v){var P,S,k,R=8>c?1:-1;for(f=s.ieOffsetX||0,m=s.ieOffsetY||0,s.ieOffsetX=Math.round((d-((0>o?-o:o)*d+(0>h?-h:h)*g))/2+x),s.ieOffsetY=Math.round((g-((0>_?-_:_)*g+(0>l?-l:l)*d))/2+b),ce=0;4>ce;ce++)S=J[ce],P=p[S],i=-1!==P.indexOf("px")?parseFloat(P):$(this.t,S,parseFloat(P),P.replace(y,""))||0,k=i!==s[S]?2>ce?-s.ieOffsetX:-s.ieOffsetY:2>ce?f-s.ieOffsetX:m-s.ieOffsetY,u[S]=(s[S]=Math.round(i-k*(0===ce||2===ce?1:R)))+"px"}}},Se=function(){var t,e,i,s,r,n,a,o,h,l,_,u,f,c,m,d,g,v,y,T,w,x,b,P,S,k,R=this.data,A=this.t.style,C=R.rotation*M,O=R.scaleX,D=R.scaleY,I=R.scaleZ,F=R.perspective;if(p&&(P=A.top?"top":A.bottom?"bottom":parseFloat(G(this.t,"top",null,!1))?"bottom":"top",T=G(this.t,P,null,!1),S=parseFloat(T)||0,k=T.substr((S+"").length)||"px",R._ffFix=!R._ffFix,A[P]=(R._ffFix?S+.05:S-.05)+k),C||R.skewX)v=Math.cos(C),y=Math.sin(C),t=v,r=y,R.skewX&&(C-=R.skewX*M,v=Math.cos(C),y=Math.sin(C)),e=-y,n=v;else{if(!(R.rotationY||R.rotationX||1!==I||F))return A[ye]="translate3d("+R.x+"px,"+R.y+"px,"+R.z+"px)"+(1!==O||1!==D?" scale("+O+","+D+")":""),void 0;t=n=1,e=r=0}_=1,i=s=a=o=h=l=u=f=c=0,m=F?-1/F:0,d=R.zOrigin,g=1e5,C=R.rotationY*M,C&&(v=Math.cos(C),y=Math.sin(C),h=_*-y,f=m*-y,i=t*y,a=r*y,_*=v,m*=v,t*=v,r*=v),C=R.rotationX*M,C&&(v=Math.cos(C),y=Math.sin(C),T=e*v+i*y,w=n*v+a*y,x=l*v+_*y,b=c*v+m*y,i=e*-y+i*v,a=n*-y+a*v,_=l*-y+_*v,m=c*-y+m*v,e=T,n=w,l=x,c=b),1!==I&&(i*=I,a*=I,_*=I,m*=I),1!==D&&(e*=D,n*=D,l*=D,c*=D),1!==O&&(t*=O,r*=O,h*=O,f*=O),d&&(u-=d,s=i*u,o=a*u,u=_*u+d),s=(T=(s+=R.x)-(s|=0))?(0|T*g+(0>T?-.5:.5))/g+s:s,o=(T=(o+=R.y)-(o|=0))?(0|T*g+(0>T?-.5:.5))/g+o:o,u=(T=(u+=R.z)-(u|=0))?(0|T*g+(0>T?-.5:.5))/g+u:u,A[ye]="matrix3d("+[(0|t*g)/g,(0|r*g)/g,(0|h*g)/g,(0|f*g)/g,(0|e*g)/g,(0|n*g)/g,(0|l*g)/g,(0|c*g)/g,(0|i*g)/g,(0|a*g)/g,(0|_*g)/g,(0|m*g)/g,s,o,u,F?1+-u/F:1].join(",")+")"},ke=function(){var t,e,i,s,r,n,a,o,h,l=this.data,_=this.t,u=_.style;p&&(t=u.top?"top":u.bottom?"bottom":parseFloat(G(_,"top",null,!1))?"bottom":"top",e=G(_,t,null,!1),i=parseFloat(e)||0,s=e.substr((i+"").length)||"px",l._ffFix=!l._ffFix,u[t]=(l._ffFix?i+.05:i-.05)+s),l.rotation||l.skewX?(r=l.rotation*M,n=r-l.skewX*M,a=1e5,o=l.scaleX*a,h=l.scaleY*a,u[ye]="matrix("+(0|Math.cos(r)*o)/a+","+(0|Math.sin(r)*o)/a+","+(0|Math.sin(n)*-h)/a+","+(0|Math.cos(n)*h)/a+","+l.x+","+l.y+")"):u[ye]="matrix("+l.scaleX+",0,0,"+l.scaleY+","+l.x+","+l.y+")"};de("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D",{parser:function(t,e,i,s,n,a,o){if(s._transform)return n;var h,l,_,u,p,f,c,m=s._transform=be(t,r,!0,o.parseTransform),d=t.style,g=1e-6,v=ve.length,y=o,T={};if("string"==typeof y.transform&&ye)_=d.cssText,d[ye]=y.transform,d.display="block",h=be(t,null,!1),d.cssText=_;else if("object"==typeof y){if(h={scaleX:se(null!=y.scaleX?y.scaleX:y.scale,m.scaleX),scaleY:se(null!=y.scaleY?y.scaleY:y.scale,m.scaleY),scaleZ:se(null!=y.scaleZ?y.scaleZ:y.scale,m.scaleZ),x:se(y.x,m.x),y:se(y.y,m.y),z:se(y.z,m.z),perspective:se(y.transformPerspective,m.perspective)},c=y.directionalRotation,null!=c)if("object"==typeof c)for(_ in c)y[_]=c[_];else y.rotation=c;h.rotation=re("rotation"in y?y.rotation:"shortRotation"in y?y.shortRotation+"_short":"rotationZ"in y?y.rotationZ:m.rotation,m.rotation,"rotation",T),xe&&(h.rotationX=re("rotationX"in y?y.rotationX:"shortRotationX"in y?y.shortRotationX+"_short":m.rotationX||0,m.rotationX,"rotationX",T),h.rotationY=re("rotationY"in y?y.rotationY:"shortRotationY"in y?y.shortRotationY+"_short":m.rotationY||0,m.rotationY,"rotationY",T)),h.skewX=null==y.skewX?m.skewX:re(y.skewX,m.skewX),h.skewY=null==y.skewY?m.skewY:re(y.skewY,m.skewY),(l=h.skewY-m.skewY)&&(h.skewX+=l,h.rotation+=l)}for(null!=y.force3D&&(m.force3D=y.force3D,f=!0),p=m.force3D||m.z||m.rotationX||m.rotationY||h.z||h.rotationX||h.rotationY||h.perspective,p||null==y.scale||(h.scaleZ=1);--v>-1;)i=ve[v],u=h[i]-m[i],(u>g||-g>u||null!=F[i])&&(f=!0,n=new pe(m,i,m[i],u,n),i in T&&(n.e=T[i]),n.xs0=0,n.plugin=a,s._overwriteProps.push(n.n));return u=y.transformOrigin,(u||xe&&p&&m.zOrigin)&&(ye?(f=!0,i=we,u=(u||G(t,i,r,!1,"50% 50%"))+"",n=new pe(d,i,0,0,n,-1,"transformOrigin"),n.b=d[i],n.plugin=a,xe?(_=m.zOrigin,u=u.split(" "),m.zOrigin=(u.length>2&&(0===_||"0px"!==u[2])?parseFloat(u[2]):_)||0,n.xs0=n.e=d[i]=u[0]+" "+(u[1]||"50%")+" 0px",n=new pe(m,"zOrigin",0,0,n,-1,n.n),n.b=_,n.xs0=n.e=m.zOrigin):n.xs0=n.e=d[i]=u):ee(u+"",m)),f&&(s._transformType=p||3===this._transformType?3:2),n},prefix:!0}),de("boxShadow",{defaultValue:"0px 0px 0px 0px #999",prefix:!0,color:!0,multi:!0,keyword:"inset"}),de("borderRadius",{defaultValue:"0px",parser:function(t,e,i,n,a){e=this.format(e);var o,h,l,_,u,p,f,c,m,d,g,v,y,T,w,x,b=["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],P=t.style;for(m=parseFloat(t.offsetWidth),d=parseFloat(t.offsetHeight),o=e.split(" "),h=0;b.length>h;h++)this.p.indexOf("border")&&(b[h]=V(b[h])),u=_=G(t,b[h],r,!1,"0px"),-1!==u.indexOf(" ")&&(_=u.split(" "),u=_[0],_=_[1]),p=l=o[h],f=parseFloat(u),v=u.substr((f+"").length),y="="===p.charAt(1),y?(c=parseInt(p.charAt(0)+"1",10),p=p.substr(2),c*=parseFloat(p),g=p.substr((c+"").length-(0>c?1:0))||""):(c=parseFloat(p),g=p.substr((c+"").length)),""===g&&(g=s[i]||v),g!==v&&(T=$(t,"borderLeft",f,v),w=$(t,"borderTop",f,v),"%"===g?(u=100*(T/m)+"%",_=100*(w/d)+"%"):"em"===g?(x=$(t,"borderLeft",1,"em"),u=T/x+"em",_=w/x+"em"):(u=T+"px",_=w+"px"),y&&(p=parseFloat(u)+c+g,l=parseFloat(_)+c+g)),a=fe(P,b[h],u+" "+_,p+" "+l,!1,"0px",a);return a},prefix:!0,formatter:le("0px 0px 0px 0px",!1,!0)}),de("backgroundPosition",{defaultValue:"0 0",parser:function(t,e,i,s,n,a){var o,h,l,_,u,p,f="background-position",m=r||Z(t,null),d=this.format((m?c?m.getPropertyValue(f+"-x")+" "+m.getPropertyValue(f+"-y"):m.getPropertyValue(f):t.currentStyle.backgroundPositionX+" "+t.currentStyle.backgroundPositionY)||"0 0"),g=this.format(e);if(-1!==d.indexOf("%")!=(-1!==g.indexOf("%"))&&(p=G(t,"backgroundImage").replace(k,""),p&&"none"!==p)){for(o=d.split(" "),h=g.split(" "),L.setAttribute("src",p),l=2;--l>-1;)d=o[l],_=-1!==d.indexOf("%"),_!==(-1!==h[l].indexOf("%"))&&(u=0===l?t.offsetWidth-L.width:t.offsetHeight-L.height,o[l]=_?parseFloat(d)/100*u+"px":100*(parseFloat(d)/u)+"%");d=o.join(" ")}return this.parseComplex(t.style,d,g,n,a)},formatter:ee}),de("backgroundSize",{defaultValue:"0 0",formatter:ee}),de("perspective",{defaultValue:"0px",prefix:!0}),de("perspectiveOrigin",{defaultValue:"50% 50%",prefix:!0}),de("transformStyle",{prefix:!0}),de("backfaceVisibility",{prefix:!0}),de("userSelect",{prefix:!0}),de("margin",{parser:_e("marginTop,marginRight,marginBottom,marginLeft")}),de("padding",{parser:_e("paddingTop,paddingRight,paddingBottom,paddingLeft")}),de("clip",{defaultValue:"rect(0px,0px,0px,0px)",parser:function(t,e,i,s,n,a){var o,h,l;return 9>c?(h=t.currentStyle,l=8>c?" ":",",o="rect("+h.clipTop+l+h.clipRight+l+h.clipBottom+l+h.clipLeft+")",e=this.format(e).split(",").join(l)):(o=this.format(G(t,this.p,r,!1,this.dflt)),e=this.format(e)),this.parseComplex(t.style,o,e,n,a)}}),de("textShadow",{defaultValue:"0px 0px 0px #999",color:!0,multi:!0}),de("autoRound,strictUnits",{parser:function(t,e,i,s,r){return r}}),de("border",{defaultValue:"0px solid #000",parser:function(t,e,i,s,n,a){return this.parseComplex(t.style,this.format(G(t,"borderTopWidth",r,!1,"0px")+" "+G(t,"borderTopStyle",r,!1,"solid")+" "+G(t,"borderTopColor",r,!1,"#000")),this.format(e),n,a)},color:!0,formatter:function(t){var e=t.split(" ");return e[0]+" "+(e[1]||"solid")+" "+(t.match(he)||["#000"])[0]}}),de("float,cssFloat,styleFloat",{parser:function(t,e,i,s,r){var n=t.style,a="cssFloat"in n?"cssFloat":"styleFloat";return new pe(n,a,0,0,r,-1,i,!1,0,n[a],e)}});var Re=function(t){var e,i=this.t,s=i.filter||G(this.data,"filter"),r=0|this.s+this.c*t;100===r&&(-1===s.indexOf("atrix(")&&-1===s.indexOf("radient(")&&-1===s.indexOf("oader(")?(i.removeAttribute("filter"),e=!G(this.data,"filter")):(i.filter=s.replace(x,""),e=!0)),e||(this.xn1&&(i.filter=s=s||"alpha(opacity="+r+")"),-1===s.indexOf("opacity")?0===r&&this.xn1||(i.filter=s+" alpha(opacity="+r+")"):i.filter=s.replace(T,"opacity="+r))};de("opacity,alpha,autoAlpha",{defaultValue:"1",parser:function(t,e,i,s,n,a){var o=parseFloat(G(t,"opacity",r,!1,"1")),h=t.style,l="autoAlpha"===i;return"string"==typeof e&&"="===e.charAt(1)&&(e=("-"===e.charAt(0)?-1:1)*parseFloat(e.substr(2))+o),l&&1===o&&"hidden"===G(t,"visibility",r)&&0!==e&&(o=0),U?n=new pe(h,"opacity",o,e-o,n):(n=new pe(h,"opacity",100*o,100*(e-o),n),n.xn1=l?1:0,h.zoom=1,n.type=2,n.b="alpha(opacity="+n.s+")",n.e="alpha(opacity="+(n.s+n.c)+")",n.data=t,n.plugin=a,n.setRatio=Re),l&&(n=new pe(h,"visibility",0,0,n,-1,null,!1,0,0!==o?"inherit":"hidden",0===e?"hidden":"inherit"),n.xs0="inherit",s._overwriteProps.push(n.n),s._overwriteProps.push(i)),n}});var Ae=function(t,e){e&&(t.removeProperty?t.removeProperty(e.replace(P,"-$1").toLowerCase()):t.removeAttribute(e))},Ce=function(t){if(this.t._gsClassPT=this,1===t||0===t){this.t.className=0===t?this.b:this.e;for(var e=this.data,i=this.t.style;e;)e.v?i[e.p]=e.v:Ae(i,e.p),e=e._next;1===t&&this.t._gsClassPT===this&&(this.t._gsClassPT=null)}else this.t.className!==this.e&&(this.t.className=this.e)};de("className",{parser:function(t,e,s,n,a,o,h){var l,_,u,p,f,c=t.className,m=t.style.cssText;if(a=n._classNamePT=new pe(t,s,0,0,a,2),a.setRatio=Ce,a.pr=-11,i=!0,a.b=c,_=W(t,r),u=t._gsClassPT){for(p={},f=u.data;f;)p[f.p]=1,f=f._next;u.setRatio(1)}return t._gsClassPT=a,a.e="="!==e.charAt(1)?e:c.replace(RegExp("\\s*\\b"+e.substr(2)+"\\b"),"")+("+"===e.charAt(0)?" "+e.substr(2):""),n._tween._duration&&(t.className=a.e,l=H(t,_,W(t),h,p),t.className=c,a.data=l.firstMPT,t.style.cssText=m,a=a.xfirst=n.parse(t,l.difs,a,o)),a}});var Oe=function(t){if((1===t||0===t)&&this.data._totalTime===this.data._totalDuration&&"isFromStart"!==this.data.data){var e,i,s,r,n=this.t.style,a=o.transform.parse;if("all"===this.e)n.cssText="",r=!0;else for(e=this.e.split(","),s=e.length;--s>-1;)i=e[s],o[i]&&(o[i].parse===a?r=!0:i="transformOrigin"===i?we:o[i].p),Ae(n,i);r&&(Ae(n,ye),this.t._gsTransform&&delete this.t._gsTransform)}};for(de("clearProps",{parser:function(t,e,s,r,n){return n=new pe(t,s,0,0,n,2),n.setRatio=Oe,n.e=e,n.pr=-10,n.data=r._tween,i=!0,n}}),h="bezier,throwProps,physicsProps,physics2D".split(","),ce=h.length;ce--;)ge(h[ce]);h=a.prototype,h._firstPT=null,h._onInitTween=function(t,e,o){if(!t.nodeType)return!1;this._target=t,this._tween=o,this._vars=e,l=e.autoRound,i=!1,s=e.suffixMap||a.suffixMap,r=Z(t,""),n=this._overwriteProps;var h,p,c,m,d,g,v,y,T,x=t.style;if(_&&""===x.zIndex&&(h=G(t,"zIndex",r),("auto"===h||""===h)&&(x.zIndex=0)),"string"==typeof e&&(m=x.cssText,h=W(t,r),x.cssText=m+";"+e,h=H(t,h,W(t)).difs,!U&&w.test(e)&&(h.opacity=parseFloat(RegExp.$1)),e=h,x.cssText=m),this._firstPT=p=this.parse(t,e,null),this._transformType){for(T=3===this._transformType,ye?u&&(_=!0,""===x.zIndex&&(v=G(t,"zIndex",r),("auto"===v||""===v)&&(x.zIndex=0)),f&&(x.WebkitBackfaceVisibility=this._vars.WebkitBackfaceVisibility||(T?"visible":"hidden"))):x.zoom=1,c=p;c&&c._next;)c=c._next;y=new pe(t,"transform",0,0,null,2),this._linkCSSP(y,null,c),y.setRatio=T&&xe?Se:ye?ke:Pe,y.data=this._transform||be(t,r,!0),n.pop()}if(i){for(;p;){for(g=p._next,c=m;c&&c.pr>p.pr;)c=c._next;(p._prev=c?c._prev:d)?p._prev._next=p:m=p,(p._next=c)?c._prev=p:d=p,p=g}this._firstPT=m}return!0},h.parse=function(t,e,i,n){var a,h,_,u,p,f,c,m,d,g,v=t.style;for(a in e)f=e[a],h=o[a],h?i=h.parse(t,f,a,this,i,n,e):(p=G(t,a,r)+"",d="string"==typeof f,"color"===a||"fill"===a||"stroke"===a||-1!==a.indexOf("Color")||d&&b.test(f)?(d||(f=oe(f),f=(f.length>3?"rgba(":"rgb(")+f.join(",")+")"),i=fe(v,a,p,f,!0,"transparent",i,0,n)):!d||-1===f.indexOf(" ")&&-1===f.indexOf(",")?(_=parseFloat(p),c=_||0===_?p.substr((_+"").length):"",(""===p||"auto"===p)&&("width"===a||"height"===a?(_=te(t,a,r),c="px"):"left"===a||"top"===a?(_=Q(t,a,r),c="px"):(_="opacity"!==a?0:1,c="")),g=d&&"="===f.charAt(1),g?(u=parseInt(f.charAt(0)+"1",10),f=f.substr(2),u*=parseFloat(f),m=f.replace(y,"")):(u=parseFloat(f),m=d?f.substr((u+"").length)||"":""),""===m&&(m=s[a]||c),f=u||0===u?(g?u+_:u)+m:e[a],c!==m&&""!==m&&(u||0===u)&&(_||0===_)&&(_=$(t,a,_,c),"%"===m?(_/=$(t,a,100,"%")/100,_>100&&(_=100),e.strictUnits!==!0&&(p=_+"%")):"em"===m?_/=$(t,a,1,"em"):(u=$(t,a,u,m),m="px"),g&&(u||0===u)&&(f=u+_+m)),g&&(u+=_),!_&&0!==_||!u&&0!==u?void 0!==v[a]&&(f||"NaN"!=f+""&&null!=f)?(i=new pe(v,a,u||_||0,0,i,-1,a,!1,0,p,f),i.xs0="none"!==f||"display"!==a&&-1===a.indexOf("Style")?f:p):j("invalid "+a+" tween value: "+e[a]):(i=new pe(v,a,_,u-_,i,0,a,l!==!1&&("px"===m||"zIndex"===a),0,p,f),i.xs0=m)):i=fe(v,a,p,f,!0,null,i,0,n)),n&&i&&!i.plugin&&(i.plugin=n);return i},h.setRatio=function(t){var e,i,s,r=this._firstPT,n=1e-6;if(1!==t||this._tween._time!==this._tween._duration&&0!==this._tween._time)if(t||this._tween._time!==this._tween._duration&&0!==this._tween._time||this._tween._rawPrevTime===-1e-6)for(;r;){if(e=r.c*t+r.s,r.r?e=e>0?0|e+.5:0|e-.5:n>e&&e>-n&&(e=0),r.type)if(1===r.type)if(s=r.l,2===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2;else if(3===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3;else if(4===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3+r.xn3+r.xs4;else if(5===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3+r.xn3+r.xs4+r.xn4+r.xs5;else{for(i=r.xs0+e+r.xs1,s=1;r.l>s;s++)i+=r["xn"+s]+r["xs"+(s+1)];r.t[r.p]=i}else-1===r.type?r.t[r.p]=r.xs0:r.setRatio&&r.setRatio(t);else r.t[r.p]=e+r.xs0;r=r._next}else for(;r;)2!==r.type?r.t[r.p]=r.b:r.setRatio(t),r=r._next;else for(;r;)2!==r.type?r.t[r.p]=r.e:r.setRatio(t),r=r._next},h._enableTransforms=function(t){this._transformType=t||3===this._transformType?3:2,this._transform=this._transform||be(this._target,r,!0)},h._linkCSSP=function(t,e,i,s){return t&&(e&&(e._prev=t),t._next&&(t._next._prev=t._prev),t._prev?t._prev._next=t._next:this._firstPT===t&&(this._firstPT=t._next,s=!0),i?i._next=t:s||null!==this._firstPT||(this._firstPT=t),t._next=e,t._prev=i),t},h._kill=function(e){var i,s,r,n=e;if(e.autoAlpha||e.alpha){n={};for(s in e)n[s]=e[s];n.opacity=1,n.autoAlpha&&(n.visibility=1)}return e.className&&(i=this._classNamePT)&&(r=i.xfirst,r&&r._prev?this._linkCSSP(r._prev,i._next,r._prev._prev):r===this._firstPT&&(this._firstPT=i._next),i._next&&this._linkCSSP(i._next,i._next._next,r._prev),this._classNamePT=null),t.prototype._kill.call(this,n)};var De=function(t,e,i){var s,r,n,a;if(t.slice)for(r=t.length;--r>-1;)De(t[r],e,i);else for(s=t.childNodes,r=s.length;--r>-1;)n=s[r],a=n.type,n.style&&(e.push(W(n)),i&&i.push(n)),1!==a&&9!==a&&11!==a||!n.childNodes.length||De(n,e,i)};return a.cascadeTo=function(t,i,s){var r,n,a,o=e.to(t,i,s),h=[o],l=[],_=[],u=[],p=e._internals.reservedProps;for(t=o._targets||o.target,De(t,l,u),o.render(i,!0),De(t,_),o.render(0,!0),o._enabled(!0),r=u.length;--r>-1;)if(n=H(u[r],l[r],_[r]),n.firstMPT){n=n.difs;for(a in s)p[a]&&(n[a]=s[a]);h.push(e.to(u[r],i,n))}return h},t.activate([a]),a},!0),function(){var t=window._gsDefine.plugin({propName:"roundProps",priority:-1,API:2,init:function(t,e,i){return this._tween=i,!0}}),e=t.prototype;e._onInitAllProps=function(){for(var t,e,i,s=this._tween,r=s.vars.roundProps instanceof Array?s.vars.roundProps:s.vars.roundProps.split(","),n=r.length,a={},o=s._propLookup.roundProps;--n>-1;)a[r[n]]=1;for(n=r.length;--n>-1;)for(t=r[n],e=s._firstPT;e;)i=e._next,e.pg?e.t._roundProps(a,!0):e.n===t&&(this._add(e.t,t,e.s,e.c),i&&(i._prev=e._prev),e._prev?e._prev._next=i:s._firstPT===e&&(s._firstPT=i),e._next=e._prev=null,s._propLookup[t]=o),e=i;return!1},e._add=function(t,e,i,s){this._addTween(t,e,i,i+s,e,!0),this._overwriteProps.push(e)}}(),window._gsDefine.plugin({propName:"attr",API:2,init:function(t,e){var i;
if("function"!=typeof t.setAttribute)return!1;this._target=t,this._proxy={};for(i in e)this._addTween(this._proxy,i,parseFloat(t.getAttribute(i)),e[i],i)&&this._overwriteProps.push(i);return!0},set:function(t){this._super.setRatio.call(this,t);for(var e,i=this._overwriteProps,s=i.length;--s>-1;)e=i[s],this._target.setAttribute(e,this._proxy[e]+"")}}),window._gsDefine.plugin({propName:"directionalRotation",API:2,init:function(t,e){"object"!=typeof e&&(e={rotation:e}),this.finals={};var i,s,r,n,a,o,h=e.useRadians===!0?2*Math.PI:360,l=1e-6;for(i in e)"useRadians"!==i&&(o=(e[i]+"").split("_"),s=o[0],r=parseFloat("function"!=typeof t[i]?t[i]:t[i.indexOf("set")||"function"!=typeof t["get"+i.substr(3)]?i:"get"+i.substr(3)]()),n=this.finals[i]="string"==typeof s&&"="===s.charAt(1)?r+parseInt(s.charAt(0)+"1",10)*Number(s.substr(2)):Number(s)||0,a=n-r,o.length&&(s=o.join("_"),-1!==s.indexOf("short")&&(a%=h,a!==a%(h/2)&&(a=0>a?a+h:a-h)),-1!==s.indexOf("_cw")&&0>a?a=(a+9999999999*h)%h-(0|a/h)*h:-1!==s.indexOf("ccw")&&a>0&&(a=(a-9999999999*h)%h-(0|a/h)*h)),(a>l||-l>a)&&(this._addTween(t,i,r,r+a,i),this._overwriteProps.push(i)));return!0},set:function(t){var e;if(1!==t)this._super.setRatio.call(this,t);else for(e=this._firstPT;e;)e.f?e.t[e.p](this.finals[e.p]):e.t[e.p]=this.finals[e.p],e=e._next}})._autoCSS=!0,window._gsDefine("easing.Back",["easing.Ease"],function(t){var e,i,s,r=window.GreenSockGlobals||window,n=r.com.greensock,a=2*Math.PI,o=Math.PI/2,h=n._class,l=function(e,i){var s=h("easing."+e,function(){},!0),r=s.prototype=new t;return r.constructor=s,r.getRatio=i,s},_=t.register||function(){},u=function(t,e,i,s){var r=h("easing."+t,{easeOut:new e,easeIn:new i,easeInOut:new s},!0);return _(r,t),r},p=function(t,e,i){this.t=t,this.v=e,i&&(this.next=i,i.prev=this,this.c=i.v-e,this.gap=i.t-t)},f=function(e,i){var s=h("easing."+e,function(t){this._p1=t||0===t?t:1.70158,this._p2=1.525*this._p1},!0),r=s.prototype=new t;return r.constructor=s,r.getRatio=i,r.config=function(t){return new s(t)},s},c=u("Back",f("BackOut",function(t){return(t-=1)*t*((this._p1+1)*t+this._p1)+1}),f("BackIn",function(t){return t*t*((this._p1+1)*t-this._p1)}),f("BackInOut",function(t){return 1>(t*=2)?.5*t*t*((this._p2+1)*t-this._p2):.5*((t-=2)*t*((this._p2+1)*t+this._p2)+2)})),m=h("easing.SlowMo",function(t,e,i){e=e||0===e?e:.7,null==t?t=.7:t>1&&(t=1),this._p=1!==t?e:0,this._p1=(1-t)/2,this._p2=t,this._p3=this._p1+this._p2,this._calcEnd=i===!0},!0),d=m.prototype=new t;return d.constructor=m,d.getRatio=function(t){var e=t+(.5-t)*this._p;return this._p1>t?this._calcEnd?1-(t=1-t/this._p1)*t:e-(t=1-t/this._p1)*t*t*t*e:t>this._p3?this._calcEnd?1-(t=(t-this._p3)/this._p1)*t:e+(t-e)*(t=(t-this._p3)/this._p1)*t*t*t:this._calcEnd?1:e},m.ease=new m(.7,.7),d.config=m.config=function(t,e,i){return new m(t,e,i)},e=h("easing.SteppedEase",function(t){t=t||1,this._p1=1/t,this._p2=t+1},!0),d=e.prototype=new t,d.constructor=e,d.getRatio=function(t){return 0>t?t=0:t>=1&&(t=.999999999),(this._p2*t>>0)*this._p1},d.config=e.config=function(t){return new e(t)},i=h("easing.RoughEase",function(e){e=e||{};for(var i,s,r,n,a,o,h=e.taper||"none",l=[],_=0,u=0|(e.points||20),f=u,c=e.randomize!==!1,m=e.clamp===!0,d=e.template instanceof t?e.template:null,g="number"==typeof e.strength?.4*e.strength:.4;--f>-1;)i=c?Math.random():1/u*f,s=d?d.getRatio(i):i,"none"===h?r=g:"out"===h?(n=1-i,r=n*n*g):"in"===h?r=i*i*g:.5>i?(n=2*i,r=.5*n*n*g):(n=2*(1-i),r=.5*n*n*g),c?s+=Math.random()*r-.5*r:f%2?s+=.5*r:s-=.5*r,m&&(s>1?s=1:0>s&&(s=0)),l[_++]={x:i,y:s};for(l.sort(function(t,e){return t.x-e.x}),o=new p(1,1,null),f=u;--f>-1;)a=l[f],o=new p(a.x,a.y,o);this._prev=new p(0,0,0!==o.t?o:o.next)},!0),d=i.prototype=new t,d.constructor=i,d.getRatio=function(t){var e=this._prev;if(t>e.t){for(;e.next&&t>=e.t;)e=e.next;e=e.prev}else for(;e.prev&&e.t>=t;)e=e.prev;return this._prev=e,e.v+(t-e.t)/e.gap*e.c},d.config=function(t){return new i(t)},i.ease=new i,u("Bounce",l("BounceOut",function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}),l("BounceIn",function(t){return 1/2.75>(t=1-t)?1-7.5625*t*t:2/2.75>t?1-(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1-(7.5625*(t-=2.25/2.75)*t+.9375):1-(7.5625*(t-=2.625/2.75)*t+.984375)}),l("BounceInOut",function(t){var e=.5>t;return t=e?1-2*t:2*t-1,t=1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375,e?.5*(1-t):.5*t+.5})),u("Circ",l("CircOut",function(t){return Math.sqrt(1-(t-=1)*t)}),l("CircIn",function(t){return-(Math.sqrt(1-t*t)-1)}),l("CircInOut",function(t){return 1>(t*=2)?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)})),s=function(e,i,s){var r=h("easing."+e,function(t,e){this._p1=t||1,this._p2=e||s,this._p3=this._p2/a*(Math.asin(1/this._p1)||0)},!0),n=r.prototype=new t;return n.constructor=r,n.getRatio=i,n.config=function(t,e){return new r(t,e)},r},u("Elastic",s("ElasticOut",function(t){return this._p1*Math.pow(2,-10*t)*Math.sin((t-this._p3)*a/this._p2)+1},.3),s("ElasticIn",function(t){return-(this._p1*Math.pow(2,10*(t-=1))*Math.sin((t-this._p3)*a/this._p2))},.3),s("ElasticInOut",function(t){return 1>(t*=2)?-.5*this._p1*Math.pow(2,10*(t-=1))*Math.sin((t-this._p3)*a/this._p2):.5*this._p1*Math.pow(2,-10*(t-=1))*Math.sin((t-this._p3)*a/this._p2)+1},.45)),u("Expo",l("ExpoOut",function(t){return 1-Math.pow(2,-10*t)}),l("ExpoIn",function(t){return Math.pow(2,10*(t-1))-.001}),l("ExpoInOut",function(t){return 1>(t*=2)?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*(t-1)))})),u("Sine",l("SineOut",function(t){return Math.sin(t*o)}),l("SineIn",function(t){return-Math.cos(t*o)+1}),l("SineInOut",function(t){return-.5*(Math.cos(Math.PI*t)-1)})),h("easing.EaseLookup",{find:function(e){return t.map[e]}},!0),_(r.SlowMo,"SlowMo","ease,"),_(i,"RoughEase","ease,"),_(e,"SteppedEase","ease,"),c},!0)}),function(t){"use strict";var e=t.GreenSockGlobals||t;if(!e.TweenLite){var i,s,r,n,a,o=function(t){var i,s=t.split("."),r=e;for(i=0;s.length>i;i++)r[s[i]]=r=r[s[i]]||{};return r},h=o("com.greensock"),l=1e-10,_=[].slice,u=function(){},p=function(){var t=Object.prototype.toString,e=t.call([]);return function(i){return i instanceof Array||"object"==typeof i&&!!i.push&&t.call(i)===e}}(),f={},c=function(i,s,r,n){this.sc=f[i]?f[i].sc:[],f[i]=this,this.gsClass=null,this.func=r;var a=[];this.check=function(h){for(var l,_,u,p,m=s.length,d=m;--m>-1;)(l=f[s[m]]||new c(s[m],[])).gsClass?(a[m]=l.gsClass,d--):h&&l.sc.push(this);if(0===d&&r)for(_=("com.greensock."+i).split("."),u=_.pop(),p=o(_.join("."))[u]=this.gsClass=r.apply(r,a),n&&(e[u]=p,"function"==typeof define&&define.amd?define((t.GreenSockAMDPath?t.GreenSockAMDPath+"/":"")+i.split(".").join("/"),[],function(){return p}):"undefined"!=typeof module&&module.exports&&(module.exports=p)),m=0;this.sc.length>m;m++)this.sc[m].check()},this.check(!0)},m=t._gsDefine=function(t,e,i,s){return new c(t,e,i,s)},d=h._class=function(t,e,i){return e=e||function(){},m(t,[],function(){return e},i),e};m.globals=e;var g=[0,0,1,1],v=[],y=d("easing.Ease",function(t,e,i,s){this._func=t,this._type=i||0,this._power=s||0,this._params=e?g.concat(e):g},!0),T=y.map={},w=y.register=function(t,e,i,s){for(var r,n,a,o,l=e.split(","),_=l.length,u=(i||"easeIn,easeOut,easeInOut").split(",");--_>-1;)for(n=l[_],r=s?d("easing."+n,null,!0):h.easing[n]||{},a=u.length;--a>-1;)o=u[a],T[n+"."+o]=T[o+n]=r[o]=t.getRatio?t:t[o]||new t};for(r=y.prototype,r._calcEnd=!1,r.getRatio=function(t){if(this._func)return this._params[0]=t,this._func.apply(null,this._params);var e=this._type,i=this._power,s=1===e?1-t:2===e?t:.5>t?2*t:2*(1-t);return 1===i?s*=s:2===i?s*=s*s:3===i?s*=s*s*s:4===i&&(s*=s*s*s*s),1===e?1-s:2===e?s:.5>t?s/2:1-s/2},i=["Linear","Quad","Cubic","Quart","Quint,Strong"],s=i.length;--s>-1;)r=i[s]+",Power"+s,w(new y(null,null,1,s),r,"easeOut",!0),w(new y(null,null,2,s),r,"easeIn"+(0===s?",easeNone":"")),w(new y(null,null,3,s),r,"easeInOut");T.linear=h.easing.Linear.easeIn,T.swing=h.easing.Quad.easeInOut;var x=d("events.EventDispatcher",function(t){this._listeners={},this._eventTarget=t||this});r=x.prototype,r.addEventListener=function(t,e,i,s,r){r=r||0;var o,h,l=this._listeners[t],_=0;for(null==l&&(this._listeners[t]=l=[]),h=l.length;--h>-1;)o=l[h],o.c===e&&o.s===i?l.splice(h,1):0===_&&r>o.pr&&(_=h+1);l.splice(_,0,{c:e,s:i,up:s,pr:r}),this!==n||a||n.wake()},r.removeEventListener=function(t,e){var i,s=this._listeners[t];if(s)for(i=s.length;--i>-1;)if(s[i].c===e)return s.splice(i,1),void 0},r.dispatchEvent=function(t){var e,i,s,r=this._listeners[t];if(r)for(e=r.length,i=this._eventTarget;--e>-1;)s=r[e],s.up?s.c.call(s.s||i,{type:t,target:i}):s.c.call(s.s||i)};var b=t.requestAnimationFrame,P=t.cancelAnimationFrame,S=Date.now||function(){return(new Date).getTime()},k=S();for(i=["ms","moz","webkit","o"],s=i.length;--s>-1&&!b;)b=t[i[s]+"RequestAnimationFrame"],P=t[i[s]+"CancelAnimationFrame"]||t[i[s]+"CancelRequestAnimationFrame"];d("Ticker",function(t,e){var i,s,r,o,h,l=this,_=S(),p=e!==!1&&b,f=function(t){k=S(),l.time=(k-_)/1e3;var e,n=l.time-h;(!i||n>0||t===!0)&&(l.frame++,h+=n+(n>=o?.004:o-n),e=!0),t!==!0&&(r=s(f)),e&&l.dispatchEvent("tick")};x.call(l),l.time=l.frame=0,l.tick=function(){f(!0)},l.sleep=function(){null!=r&&(p&&P?P(r):clearTimeout(r),s=u,r=null,l===n&&(a=!1))},l.wake=function(){null!==r&&l.sleep(),s=0===i?u:p&&b?b:function(t){return setTimeout(t,0|1e3*(h-l.time)+1)},l===n&&(a=!0),f(2)},l.fps=function(t){return arguments.length?(i=t,o=1/(i||60),h=this.time+o,l.wake(),void 0):i},l.useRAF=function(t){return arguments.length?(l.sleep(),p=t,l.fps(i),void 0):p},l.fps(t),setTimeout(function(){p&&(!r||5>l.frame)&&l.useRAF(!1)},1500)}),r=h.Ticker.prototype=new h.events.EventDispatcher,r.constructor=h.Ticker;var R=d("core.Animation",function(t,e){if(this.vars=e=e||{},this._duration=this._totalDuration=t||0,this._delay=Number(e.delay)||0,this._timeScale=1,this._active=e.immediateRender===!0,this.data=e.data,this._reversed=e.reversed===!0,U){a||n.wake();var i=this.vars.useFrames?z:U;i.add(this,i._time),this.vars.paused&&this.paused(!0)}});n=R.ticker=new h.Ticker,r=R.prototype,r._dirty=r._gc=r._initted=r._paused=!1,r._totalTime=r._time=0,r._rawPrevTime=-1,r._next=r._last=r._onUpdate=r._timeline=r.timeline=null,r._paused=!1;var A=function(){S()-k>2e3&&n.wake(),setTimeout(A,2e3)};A(),r.play=function(t,e){return arguments.length&&this.seek(t,e),this.reversed(!1).paused(!1)},r.pause=function(t,e){return arguments.length&&this.seek(t,e),this.paused(!0)},r.resume=function(t,e){return arguments.length&&this.seek(t,e),this.paused(!1)},r.seek=function(t,e){return this.totalTime(Number(t),e!==!1)},r.restart=function(t,e){return this.reversed(!1).paused(!1).totalTime(t?-this._delay:0,e!==!1,!0)},r.reverse=function(t,e){return arguments.length&&this.seek(t||this.totalDuration(),e),this.reversed(!0).paused(!1)},r.render=function(){},r.invalidate=function(){return this},r.isActive=function(){var t,e=this._timeline,i=this._startTime;return!e||!this._gc&&!this._paused&&e.isActive()&&(t=e.rawTime())>=i&&i+this.totalDuration()/this._timeScale>t},r._enabled=function(t,e){return a||n.wake(),this._gc=!t,this._active=this.isActive(),e!==!0&&(t&&!this.timeline?this._timeline.add(this,this._startTime-this._delay):!t&&this.timeline&&this._timeline._remove(this,!0)),!1},r._kill=function(){return this._enabled(!1,!1)},r.kill=function(t,e){return this._kill(t,e),this},r._uncache=function(t){for(var e=t?this:this.timeline;e;)e._dirty=!0,e=e.timeline;return this},r._swapSelfInParams=function(t){for(var e=t.length,i=t.concat();--e>-1;)"{self}"===t[e]&&(i[e]=this);return i},r.eventCallback=function(t,e,i,s){if("on"===(t||"").substr(0,2)){var r=this.vars;if(1===arguments.length)return r[t];null==e?delete r[t]:(r[t]=e,r[t+"Params"]=p(i)&&-1!==i.join("").indexOf("{self}")?this._swapSelfInParams(i):i,r[t+"Scope"]=s),"onUpdate"===t&&(this._onUpdate=e)}return this},r.delay=function(t){return arguments.length?(this._timeline.smoothChildTiming&&this.startTime(this._startTime+t-this._delay),this._delay=t,this):this._delay},r.duration=function(t){return arguments.length?(this._duration=this._totalDuration=t,this._uncache(!0),this._timeline.smoothChildTiming&&this._time>0&&this._time<this._duration&&0!==t&&this.totalTime(this._totalTime*(t/this._duration),!0),this):(this._dirty=!1,this._duration)},r.totalDuration=function(t){return this._dirty=!1,arguments.length?this.duration(t):this._totalDuration},r.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),this.totalTime(t>this._duration?this._duration:t,e)):this._time},r.totalTime=function(t,e,i){if(a||n.wake(),!arguments.length)return this._totalTime;if(this._timeline){if(0>t&&!i&&(t+=this.totalDuration()),this._timeline.smoothChildTiming){this._dirty&&this.totalDuration();var s=this._totalDuration,r=this._timeline;if(t>s&&!i&&(t=s),this._startTime=(this._paused?this._pauseTime:r._time)-(this._reversed?s-t:t)/this._timeScale,r._dirty||this._uncache(!1),r._timeline)for(;r._timeline;)r._timeline._time!==(r._startTime+r._totalTime)/r._timeScale&&r.totalTime(r._totalTime,!0),r=r._timeline}this._gc&&this._enabled(!0,!1),(this._totalTime!==t||0===this._duration)&&this.render(t,e,!1)}return this},r.progress=r.totalProgress=function(t,e){return arguments.length?this.totalTime(this.duration()*t,e):this._time/this.duration()},r.startTime=function(t){return arguments.length?(t!==this._startTime&&(this._startTime=t,this.timeline&&this.timeline._sortChildren&&this.timeline.add(this,t-this._delay)),this):this._startTime},r.timeScale=function(t){if(!arguments.length)return this._timeScale;if(t=t||l,this._timeline&&this._timeline.smoothChildTiming){var e=this._pauseTime,i=e||0===e?e:this._timeline.totalTime();this._startTime=i-(i-this._startTime)*this._timeScale/t}return this._timeScale=t,this._uncache(!1)},r.reversed=function(t){return arguments.length?(t!=this._reversed&&(this._reversed=t,this.totalTime(this._totalTime,!0)),this):this._reversed},r.paused=function(t){if(!arguments.length)return this._paused;if(t!=this._paused&&this._timeline){a||t||n.wake();var e=this._timeline,i=e.rawTime(),s=i-this._pauseTime;!t&&e.smoothChildTiming&&(this._startTime+=s,this._uncache(!1)),this._pauseTime=t?i:null,this._paused=t,this._active=this.isActive(),!t&&0!==s&&this._initted&&this.duration()&&this.render(e.smoothChildTiming?this._totalTime:(i-this._startTime)/this._timeScale,!0,!0)}return this._gc&&!t&&this._enabled(!0,!1),this};var C=d("core.SimpleTimeline",function(t){R.call(this,0,t),this.autoRemoveChildren=this.smoothChildTiming=!0});r=C.prototype=new R,r.constructor=C,r.kill()._gc=!1,r._first=r._last=null,r._sortChildren=!1,r.add=r.insert=function(t,e){var i,s;if(t._startTime=Number(e||0)+t._delay,t._paused&&this!==t._timeline&&(t._pauseTime=t._startTime+(this.rawTime()-t._startTime)/t._timeScale),t.timeline&&t.timeline._remove(t,!0),t.timeline=t._timeline=this,t._gc&&t._enabled(!0,!0),i=this._last,this._sortChildren)for(s=t._startTime;i&&i._startTime>s;)i=i._prev;return i?(t._next=i._next,i._next=t):(t._next=this._first,this._first=t),t._next?t._next._prev=t:this._last=t,t._prev=i,this._timeline&&this._uncache(!0),this},r._remove=function(t,e){return t.timeline===this&&(e||t._enabled(!1,!0),t.timeline=null,t._prev?t._prev._next=t._next:this._first===t&&(this._first=t._next),t._next?t._next._prev=t._prev:this._last===t&&(this._last=t._prev),this._timeline&&this._uncache(!0)),this},r.render=function(t,e,i){var s,r=this._first;for(this._totalTime=this._time=this._rawPrevTime=t;r;)s=r._next,(r._active||t>=r._startTime&&!r._paused)&&(r._reversed?r.render((r._dirty?r.totalDuration():r._totalDuration)-(t-r._startTime)*r._timeScale,e,i):r.render((t-r._startTime)*r._timeScale,e,i)),r=s},r.rawTime=function(){return a||n.wake(),this._totalTime};var O=d("TweenLite",function(e,i,s){if(R.call(this,i,s),this.render=O.prototype.render,null==e)throw"Cannot tween a null target.";this.target=e="string"!=typeof e?e:O.selector(e)||e;var r,n,a,o=e.jquery||e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType),h=this.vars.overwrite;if(this._overwrite=h=null==h?X[O.defaultOverwrite]:"number"==typeof h?h>>0:X[h],(o||e instanceof Array||e.push&&p(e))&&"number"!=typeof e[0])for(this._targets=a=_.call(e,0),this._propLookup=[],this._siblings=[],r=0;a.length>r;r++)n=a[r],n?"string"!=typeof n?n.length&&n!==t&&n[0]&&(n[0]===t||n[0].nodeType&&n[0].style&&!n.nodeType)?(a.splice(r--,1),this._targets=a=a.concat(_.call(n,0))):(this._siblings[r]=Y(n,this,!1),1===h&&this._siblings[r].length>1&&j(n,this,null,1,this._siblings[r])):(n=a[r--]=O.selector(n),"string"==typeof n&&a.splice(r+1,1)):a.splice(r--,1);else this._propLookup={},this._siblings=Y(e,this,!1),1===h&&this._siblings.length>1&&j(e,this,null,1,this._siblings);(this.vars.immediateRender||0===i&&0===this._delay&&this.vars.immediateRender!==!1)&&this.render(-this._delay,!1,!0)},!0),D=function(e){return e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType)},M=function(t,e){var i,s={};for(i in t)L[i]||i in e&&"x"!==i&&"y"!==i&&"width"!==i&&"height"!==i&&"className"!==i&&"border"!==i||!(!F[i]||F[i]&&F[i]._autoCSS)||(s[i]=t[i],delete t[i]);t.css=s};r=O.prototype=new R,r.constructor=O,r.kill()._gc=!1,r.ratio=0,r._firstPT=r._targets=r._overwrittenProps=r._startAt=null,r._notifyPluginsOfEnabled=!1,O.version="1.11.1",O.defaultEase=r._ease=new y(null,null,1,1),O.defaultOverwrite="auto",O.ticker=n,O.autoSleep=!0,O.selector=t.$||t.jQuery||function(e){return t.$?(O.selector=t.$,t.$(e)):t.document?t.document.getElementById("#"===e.charAt(0)?e.substr(1):e):e};var I=O._internals={isArray:p,isSelector:D},F=O._plugins={},E=O._tweenLookup={},N=0,L=I.reservedProps={ease:1,delay:1,overwrite:1,onComplete:1,onCompleteParams:1,onCompleteScope:1,useFrames:1,runBackwards:1,startAt:1,onUpdate:1,onUpdateParams:1,onUpdateScope:1,onStart:1,onStartParams:1,onStartScope:1,onReverseComplete:1,onReverseCompleteParams:1,onReverseCompleteScope:1,onRepeat:1,onRepeatParams:1,onRepeatScope:1,easeParams:1,yoyo:1,immediateRender:1,repeat:1,repeatDelay:1,data:1,paused:1,reversed:1,autoCSS:1},X={none:0,all:1,auto:2,concurrent:3,allOnStart:4,preexisting:5,"true":1,"false":0},z=R._rootFramesTimeline=new C,U=R._rootTimeline=new C;U._startTime=n.time,z._startTime=n.frame,U._active=z._active=!0,R._updateRoot=function(){if(U.render((n.time-U._startTime)*U._timeScale,!1,!1),z.render((n.frame-z._startTime)*z._timeScale,!1,!1),!(n.frame%120)){var t,e,i;for(i in E){for(e=E[i].tweens,t=e.length;--t>-1;)e[t]._gc&&e.splice(t,1);0===e.length&&delete E[i]}if(i=U._first,(!i||i._paused)&&O.autoSleep&&!z._first&&1===n._listeners.tick.length){for(;i&&i._paused;)i=i._next;i||n.sleep()}}},n.addEventListener("tick",R._updateRoot);var Y=function(t,e,i){var s,r,n=t._gsTweenID;if(E[n||(t._gsTweenID=n="t"+N++)]||(E[n]={target:t,tweens:[]}),e&&(s=E[n].tweens,s[r=s.length]=e,i))for(;--r>-1;)s[r]===e&&s.splice(r,1);return E[n].tweens},j=function(t,e,i,s,r){var n,a,o,h;if(1===s||s>=4){for(h=r.length,n=0;h>n;n++)if((o=r[n])!==e)o._gc||o._enabled(!1,!1)&&(a=!0);else if(5===s)break;return a}var _,u=e._startTime+l,p=[],f=0,c=0===e._duration;for(n=r.length;--n>-1;)(o=r[n])===e||o._gc||o._paused||(o._timeline!==e._timeline?(_=_||B(e,0,c),0===B(o,_,c)&&(p[f++]=o)):u>=o._startTime&&o._startTime+o.totalDuration()/o._timeScale+l>u&&((c||!o._initted)&&2e-10>=u-o._startTime||(p[f++]=o)));for(n=f;--n>-1;)o=p[n],2===s&&o._kill(i,t)&&(a=!0),(2!==s||!o._firstPT&&o._initted)&&o._enabled(!1,!1)&&(a=!0);return a},B=function(t,e,i){for(var s=t._timeline,r=s._timeScale,n=t._startTime;s._timeline;){if(n+=s._startTime,r*=s._timeScale,s._paused)return-100;s=s._timeline}return n/=r,n>e?n-e:i&&n===e||!t._initted&&2*l>n-e?l:(n+=t.totalDuration()/t._timeScale/r)>e+l?0:n-e-l};r._init=function(){var t,e,i,s,r=this.vars,n=this._overwrittenProps,a=this._duration,o=r.immediateRender,h=r.ease;if(r.startAt){if(this._startAt&&this._startAt.render(-1,!0),r.startAt.overwrite=0,r.startAt.immediateRender=!0,this._startAt=O.to(this.target,0,r.startAt),o)if(this._time>0)this._startAt=null;else if(0!==a)return}else if(r.runBackwards&&0!==a)if(this._startAt)this._startAt.render(-1,!0),this._startAt=null;else{i={};for(s in r)L[s]&&"autoCSS"!==s||(i[s]=r[s]);if(i.overwrite=0,i.data="isFromStart",this._startAt=O.to(this.target,0,i),r.immediateRender){if(0===this._time)return}else this._startAt.render(-1,!0)}if(this._ease=h?h instanceof y?r.easeParams instanceof Array?h.config.apply(h,r.easeParams):h:"function"==typeof h?new y(h,r.easeParams):T[h]||O.defaultEase:O.defaultEase,this._easeType=this._ease._type,this._easePower=this._ease._power,this._firstPT=null,this._targets)for(t=this._targets.length;--t>-1;)this._initProps(this._targets[t],this._propLookup[t]={},this._siblings[t],n?n[t]:null)&&(e=!0);else e=this._initProps(this.target,this._propLookup,this._siblings,n);if(e&&O._onPluginEvent("_onInitAllProps",this),n&&(this._firstPT||"function"!=typeof this.target&&this._enabled(!1,!1)),r.runBackwards)for(i=this._firstPT;i;)i.s+=i.c,i.c=-i.c,i=i._next;this._onUpdate=r.onUpdate,this._initted=!0},r._initProps=function(e,i,s,r){var n,a,o,h,l,_;if(null==e)return!1;this.vars.css||e.style&&e!==t&&e.nodeType&&F.css&&this.vars.autoCSS!==!1&&M(this.vars,e);for(n in this.vars){if(_=this.vars[n],L[n])_&&(_ instanceof Array||_.push&&p(_))&&-1!==_.join("").indexOf("{self}")&&(this.vars[n]=_=this._swapSelfInParams(_,this));else if(F[n]&&(h=new F[n])._onInitTween(e,this.vars[n],this)){for(this._firstPT=l={_next:this._firstPT,t:h,p:"setRatio",s:0,c:1,f:!0,n:n,pg:!0,pr:h._priority},a=h._overwriteProps.length;--a>-1;)i[h._overwriteProps[a]]=this._firstPT;(h._priority||h._onInitAllProps)&&(o=!0),(h._onDisable||h._onEnable)&&(this._notifyPluginsOfEnabled=!0)}else this._firstPT=i[n]=l={_next:this._firstPT,t:e,p:n,f:"function"==typeof e[n],n:n,pg:!1,pr:0},l.s=l.f?e[n.indexOf("set")||"function"!=typeof e["get"+n.substr(3)]?n:"get"+n.substr(3)]():parseFloat(e[n]),l.c="string"==typeof _&&"="===_.charAt(1)?parseInt(_.charAt(0)+"1",10)*Number(_.substr(2)):Number(_)-l.s||0;l&&l._next&&(l._next._prev=l)}return r&&this._kill(r,e)?this._initProps(e,i,s,r):this._overwrite>1&&this._firstPT&&s.length>1&&j(e,this,i,this._overwrite,s)?(this._kill(i,e),this._initProps(e,i,s,r)):o},r.render=function(t,e,i){var s,r,n,a,o=this._time,h=this._duration;if(t>=h)this._totalTime=this._time=h,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1,this._reversed||(s=!0,r="onComplete"),0===h&&(a=this._rawPrevTime,(0===t||0>a||a===l)&&a!==t&&(i=!0,a>l&&(r="onReverseComplete")),this._rawPrevTime=a=!e||t?t:l);else if(1e-7>t)this._totalTime=this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==o||0===h&&this._rawPrevTime>l)&&(r="onReverseComplete",s=this._reversed),0>t?(this._active=!1,0===h&&(this._rawPrevTime>=0&&(i=!0),this._rawPrevTime=a=!e||t?t:l)):this._initted||(i=!0);else if(this._totalTime=this._time=t,this._easeType){var _=t/h,u=this._easeType,p=this._easePower;(1===u||3===u&&_>=.5)&&(_=1-_),3===u&&(_*=2),1===p?_*=_:2===p?_*=_*_:3===p?_*=_*_*_:4===p&&(_*=_*_*_*_),this.ratio=1===u?1-_:2===u?_:.5>t/h?_/2:1-_/2}else this.ratio=this._ease.getRatio(t/h);if(this._time!==o||i){if(!this._initted){if(this._init(),!this._initted||this._gc)return;this._time&&!s?this.ratio=this._ease.getRatio(this._time/h):s&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._active||!this._paused&&this._time!==o&&t>=0&&(this._active=!0),0===o&&(this._startAt&&(t>=0?this._startAt.render(t,e,i):r||(r="_dummyGS")),this.vars.onStart&&(0!==this._time||0===h)&&(e||this.vars.onStart.apply(this.vars.onStartScope||this,this.vars.onStartParams||v))),n=this._firstPT;n;)n.f?n.t[n.p](n.c*this.ratio+n.s):n.t[n.p]=n.c*this.ratio+n.s,n=n._next;this._onUpdate&&(0>t&&this._startAt&&this._startTime&&this._startAt.render(t,e,i),e||i&&0===this._time&&0===o||this._onUpdate.apply(this.vars.onUpdateScope||this,this.vars.onUpdateParams||v)),r&&(this._gc||(0>t&&this._startAt&&!this._onUpdate&&this._startTime&&this._startAt.render(t,e,i),s&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[r]&&this.vars[r].apply(this.vars[r+"Scope"]||this,this.vars[r+"Params"]||v),0===h&&this._rawPrevTime===l&&a!==l&&(this._rawPrevTime=0)))}},r._kill=function(t,e){if("all"===t&&(t=null),null==t&&(null==e||e===this.target))return this._enabled(!1,!1);e="string"!=typeof e?e||this._targets||this.target:O.selector(e)||e;var i,s,r,n,a,o,h,l;if((p(e)||D(e))&&"number"!=typeof e[0])for(i=e.length;--i>-1;)this._kill(t,e[i])&&(o=!0);else{if(this._targets){for(i=this._targets.length;--i>-1;)if(e===this._targets[i]){a=this._propLookup[i]||{},this._overwrittenProps=this._overwrittenProps||[],s=this._overwrittenProps[i]=t?this._overwrittenProps[i]||{}:"all";break}}else{if(e!==this.target)return!1;a=this._propLookup,s=this._overwrittenProps=t?this._overwrittenProps||{}:"all"}if(a){h=t||a,l=t!==s&&"all"!==s&&t!==a&&("object"!=typeof t||!t._tempKill);for(r in h)(n=a[r])&&(n.pg&&n.t._kill(h)&&(o=!0),n.pg&&0!==n.t._overwriteProps.length||(n._prev?n._prev._next=n._next:n===this._firstPT&&(this._firstPT=n._next),n._next&&(n._next._prev=n._prev),n._next=n._prev=null),delete a[r]),l&&(s[r]=1);!this._firstPT&&this._initted&&this._enabled(!1,!1)}}return o},r.invalidate=function(){return this._notifyPluginsOfEnabled&&O._onPluginEvent("_onDisable",this),this._firstPT=null,this._overwrittenProps=null,this._onUpdate=null,this._startAt=null,this._initted=this._active=this._notifyPluginsOfEnabled=!1,this._propLookup=this._targets?{}:[],this},r._enabled=function(t,e){if(a||n.wake(),t&&this._gc){var i,s=this._targets;if(s)for(i=s.length;--i>-1;)this._siblings[i]=Y(s[i],this,!0);else this._siblings=Y(this.target,this,!0)}return R.prototype._enabled.call(this,t,e),this._notifyPluginsOfEnabled&&this._firstPT?O._onPluginEvent(t?"_onEnable":"_onDisable",this):!1},O.to=function(t,e,i){return new O(t,e,i)},O.from=function(t,e,i){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,new O(t,e,i)},O.fromTo=function(t,e,i,s){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,new O(t,e,s)},O.delayedCall=function(t,e,i,s,r){return new O(e,0,{delay:t,onComplete:e,onCompleteParams:i,onCompleteScope:s,onReverseComplete:e,onReverseCompleteParams:i,onReverseCompleteScope:s,immediateRender:!1,useFrames:r,overwrite:0})},O.set=function(t,e){return new O(t,0,e)},O.getTweensOf=function(t,e){if(null==t)return[];t="string"!=typeof t?t:O.selector(t)||t;var i,s,r,n;if((p(t)||D(t))&&"number"!=typeof t[0]){for(i=t.length,s=[];--i>-1;)s=s.concat(O.getTweensOf(t[i],e));for(i=s.length;--i>-1;)for(n=s[i],r=i;--r>-1;)n===s[r]&&s.splice(i,1)}else for(s=Y(t).concat(),i=s.length;--i>-1;)(s[i]._gc||e&&!s[i].isActive())&&s.splice(i,1);return s},O.killTweensOf=O.killDelayedCallsTo=function(t,e,i){"object"==typeof e&&(i=e,e=!1);for(var s=O.getTweensOf(t,e),r=s.length;--r>-1;)s[r]._kill(i,t)};var q=d("plugins.TweenPlugin",function(t,e){this._overwriteProps=(t||"").split(","),this._propName=this._overwriteProps[0],this._priority=e||0,this._super=q.prototype},!0);if(r=q.prototype,q.version="1.10.1",q.API=2,r._firstPT=null,r._addTween=function(t,e,i,s,r,n){var a,o;return null!=s&&(a="number"==typeof s||"="!==s.charAt(1)?Number(s)-i:parseInt(s.charAt(0)+"1",10)*Number(s.substr(2)))?(this._firstPT=o={_next:this._firstPT,t:t,p:e,s:i,c:a,f:"function"==typeof t[e],n:r||e,r:n},o._next&&(o._next._prev=o),o):void 0},r.setRatio=function(t){for(var e,i=this._firstPT,s=1e-6;i;)e=i.c*t+i.s,i.r?e=0|e+(e>0?.5:-.5):s>e&&e>-s&&(e=0),i.f?i.t[i.p](e):i.t[i.p]=e,i=i._next},r._kill=function(t){var e,i=this._overwriteProps,s=this._firstPT;if(null!=t[this._propName])this._overwriteProps=[];else for(e=i.length;--e>-1;)null!=t[i[e]]&&i.splice(e,1);for(;s;)null!=t[s.n]&&(s._next&&(s._next._prev=s._prev),s._prev?(s._prev._next=s._next,s._prev=null):this._firstPT===s&&(this._firstPT=s._next)),s=s._next;return!1},r._roundProps=function(t,e){for(var i=this._firstPT;i;)(t[this._propName]||null!=i.n&&t[i.n.split(this._propName+"_").join("")])&&(i.r=e),i=i._next},O._onPluginEvent=function(t,e){var i,s,r,n,a,o=e._firstPT;if("_onInitAllProps"===t){for(;o;){for(a=o._next,s=r;s&&s.pr>o.pr;)s=s._next;(o._prev=s?s._prev:n)?o._prev._next=o:r=o,(o._next=s)?s._prev=o:n=o,o=a}o=e._firstPT=r}for(;o;)o.pg&&"function"==typeof o.t[t]&&o.t[t]()&&(i=!0),o=o._next;return i},q.activate=function(t){for(var e=t.length;--e>-1;)t[e].API===q.API&&(F[(new t[e])._propName]=t[e]);return!0},m.plugin=function(t){if(!(t&&t.propName&&t.init&&t.API))throw"illegal plugin definition.";var e,i=t.propName,s=t.priority||0,r=t.overwriteProps,n={init:"_onInitTween",set:"setRatio",kill:"_kill",round:"_roundProps",initAll:"_onInitAllProps"},a=d("plugins."+i.charAt(0).toUpperCase()+i.substr(1)+"Plugin",function(){q.call(this,i,s),this._overwriteProps=r||[]},t.global===!0),o=a.prototype=new q(i);o.constructor=a,a.API=t.API;for(e in n)"function"==typeof t[e]&&(o[n[e]]=t[e]);return a.version=t.version,q.activate([a]),a},i=t._gsQueue){for(s=0;i.length>s;s++)i[s]();for(r in f)f[r].func||t.console.log("GSAP encountered missing dependency: com.greensock."+r)}a=!1}}(window);
/*!
 * VERSION: 0.9.0
 * DATE: 2013-10-21
 * JavaScript (also available in ActionScript 3 and 2)
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
 * ThrowPropsPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
 * this code without violating the terms of use. Visit http://www.greensock.com/club/ to sign up or get more details.
 * This work is subject to the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
;(window._gsQueue||(window._gsQueue=[])).push(function(){"use strict";window._gsDefine("plugins.ThrowPropsPlugin",["plugins.TweenPlugin","TweenLite","easing.Ease","utils.VelocityTracker"],function(t,e,i,s){var r,n,a,o,l=function(){t.call(this,"throwProps"),this._overwriteProps.length=0},h=999999999999999,u={x:1,y:1,z:2,scale:1,scaleX:1,scaleY:1,rotation:1,rotationZ:1,rotationX:2,rotationY:2,skewX:1,skewY:1},_=function(t,e,i,s){for(var r,n,a=e.length,o=0,l=h;--a>-1;)r=e[a],n=r-t,0>n&&(n=-n),l>n&&r>=s&&i>=r&&(o=a,l=n);return e[o]},p=function(t,e,i,s){if("auto"===t.end)return t;i=isNaN(i)?h:i,s=isNaN(s)?-h:s;var r="function"==typeof t.end?t.end(e):t.end instanceof Array?_(e,t.end,i,s):Number(t.end);return r>i?r=i:s>r&&(r=s),{max:r,min:r}},c=l.calculateChange=function(t,s,r,n){null==n&&(n=.05);var a=s instanceof i?s:s?new i(s):e.defaultEase;return r*n*t/a.getRatio(n)},f=l.calculateDuration=function(t,s,r,n,a){a=a||.05;var o=n instanceof i?n:n?new i(n):e.defaultEase;return Math.abs((s-t)*o.getRatio(a)/r/a)},d=l.calculateTweenDuration=function(t,r,n,a,o){if("string"==typeof t&&(t=e.selector(t)),!t)return 0;null==n&&(n=10),null==a&&(a=.2),null==o&&(o=1),t.length&&(t=t[0]||t);var h,u,_,d,m,g,v,y,w,x,T=0,b=9999999999,P=r.throwProps||r,k=r.ease instanceof i?r.ease:r.ease?new i(r.ease):e.defaultEase,S=isNaN(P.checkpoint)?.05:Number(P.checkpoint),C=isNaN(P.resistance)?l.defaultResistance:Number(P.resistance);for(h in P)"resistance"!==h&&"checkpoint"!==h&&(u=P[h],"object"!=typeof u&&(w=w||s.getByTarget(t),w&&w.isTrackingProp(h)?u="number"==typeof u?{velocity:u}:{velocity:w.getVelocity(h)}:(d=Number(u)||0,_=d*C>0?d/C:d/-C)),"object"==typeof u&&(void 0!==u.velocity&&"number"==typeof u.velocity?d=Number(u.velocity)||0:(w=w||s.getByTarget(t),d=w&&w.isTrackingProp(h)?w.getVelocity(h):0),m=isNaN(u.resistance)?C:Number(u.resistance),_=d*m>0?d/m:d/-m,g="function"==typeof t[h]?t[h.indexOf("set")||"function"!=typeof t["get"+h.substr(3)]?h:"get"+h.substr(3)]():t[h]||0,v=g+c(d,k,_,S),void 0!==u.end&&(u=p(u,v,u.max,u.min)),void 0!==u.max&&v>Number(u.max)?(x=u.unitFactor||1,y=g>u.max&&u.min!==u.max||d*x>-15&&45>d*x?a+.1*(n-a):f(g,u.max,d,k,S),b>y+o&&(b=y+o)):void 0!==u.min&&Number(u.min)>v&&(x=u.unitFactor||1,y=u.min>g&&u.min!==u.max||d*x>-45&&15>d*x?a+.1*(n-a):f(g,u.min,d,k,S),b>y+o&&(b=y+o)),y>T&&(T=y)),_>T&&(T=_));return T>b&&(T=b),T>n?n:a>T?a:T},m=l.prototype=new t("throwProps");return m.constructor=l,l.version="0.9.0",l.API=2,l._autoCSS=!0,l.defaultResistance=100,l.track=function(t,e,i){return s.track(t,e,i)},l.untrack=function(t,e){s.untrack(t,e)},l.isTracking=function(t,e){return s.isTracking(t,e)},l.getVelocity=function(t,e){var i=s.getByTarget(t);return i?i.getVelocity(e):0/0},l._cssRegister=function(){var t=(window.GreenSockGlobals||window).com.greensock.plugins.CSSPlugin;if(t){var e=t._internals,i=e._parseToProxy,a=e._setPluginRatio,o=e.CSSPropTween;e._registerComplexSpecialProp("throwProps",{parser:function(t,e,h,_,p,c){c=new l;var f,d,m,g,v,y={},w={},x={},T={},b={};n={};for(m in e)"resistance"!==m&&(d=e[m],"object"==typeof d?(void 0!==d.velocity&&"number"==typeof d.velocity?y[m]=Number(d.velocity)||0:(v=v||s.getByTarget(t),y[m]=v&&v.isTrackingProp(m)?v.getVelocity(m):0),void 0!==d.end&&(T[m]=d.end),void 0!==d.min&&(w[m]=d.min),void 0!==d.max&&(x[m]=d.max),void 0!==d.resistance&&(f=!0,b[m]=d.resistance)):"number"==typeof d?y[m]=d:(v=v||s.getByTarget(t),y[m]=v&&v.isTrackingProp(m)?v.getVelocity(m):d||0),u[m]&&_._enableTransforms(2===u[m]));g=i(t,y,_,p,c),r=g.proxy,y=g.end;for(m in r)n[m]={velocity:y[m],min:w[m],max:x[m],end:T[m],resistance:b[m]};return null!=e.resistance&&(n.resistance=e.resistance),p=new o(t,"throwProps",0,0,g.pt,2),p.plugin=c,p.setRatio=a,p.data=g,c._onInitTween(r,n,_._tween),p}})}},l.to=function(t,i,s,l,h){i.throwProps||(i={throwProps:i});var u=new e(t,1,i);return u.render(0,!0,!0),u.vars.css?(u.duration(d(r,{throwProps:n,ease:i.ease},s,l,h)),u._delay&&!u.vars.immediateRender?u.invalidate():a._onInitTween(r,o,u),u):(u.kill(),new e(t,d(t,i,s,l,h),i))},m._onInitTween=function(t,e,i){this.target=t,this._props=[],a=this,o=e;var r,n,l,h,u,_,f,d,m,g=i._ease,v=isNaN(e.checkpoint)?.05:Number(e.checkpoint),y=i._duration,w=0;for(r in e)if("resistance"!==r&&"checkpoint"!==r){if(n=e[r],"number"==typeof n)u=Number(n)||0;else if("object"!=typeof n||isNaN(n.velocity)){if(m=m||s.getByTarget(t),!m||!m.isTrackingProp(r))throw"ERROR: No velocity was defined in the throwProps tween of "+t+" property: "+r;u=m.getVelocity(r)}else u=Number(n.velocity);_=c(u,g,y,v),d=0,h="function"==typeof t[r],l=h?t[r.indexOf("set")||"function"!=typeof t["get"+r.substr(3)]?r:"get"+r.substr(3)]():t[r],"object"==typeof n&&(f=l+_,void 0!==n.end&&(n=p(n,f,n.max,n.min)),void 0!==n.max&&f>Number(n.max)?d=n.max-l-_:void 0!==n.min&&Number(n.min)>f&&(d=n.min-l-_)),this._props[w++]={p:r,s:l,c1:_,c2:d,f:h,r:!1},this._overwriteProps[w]=r}return!0},m._kill=function(e){for(var i=this._props.length;--i>-1;)null!=e[this._props[i].p]&&this._props.splice(i,1);return t.prototype._kill.call(this,e)},m._roundProps=function(t,e){for(var i=this._props,s=i.length;--s>-1;)(t[i[s]]||t.throwProps)&&(i[s].r=e)},m.setRatio=function(t){for(var e,i,s=this._props.length;--s>-1;)e=this._props[s],i=e.s+e.c1*t+e.c2*t*t,e.r&&(i=0|i+(i>0?.5:-.5)),e.f?this.target[e.p](i):this.target[e.p]=i},t.activate([l]),l},!0),window._gsDefine("utils.VelocityTracker",["TweenLite"],function(t){var e,i,s,r,n=/([A-Z])/g,a={},o={x:1,y:1,z:2,scale:1,scaleX:1,scaleY:1,rotation:1,rotationZ:1,rotationX:2,rotationY:2,skewX:1,skewY:1},l=document.defaultView?document.defaultView.getComputedStyle:function(){},h=function(t,e,i){var s=(t._gsTransform||a)[e];return s||0===s?s:(t.style[e]?s=t.style[e]:(i=i||l(t,null))?(t=i.getPropertyValue(e.replace(n,"-$1").toLowerCase()),s=t||i.length?t:i[e]):t.currentStyle&&(i=t.currentStyle,s=i[e]),parseFloat(s)||0)},u=t.ticker,_=function(t,e,i){this.p=t,this.f=e,this.v1=this.v2=0,this.t1=this.t2=u.time,this.css=!1,this.type="",this._prev=null,i&&(this._next=i,i._prev=this)},p=function(){var t,i,n=e,a=u.time;if(a-s>=.03)for(r=s,s=a;n;){for(i=n._firstVP;i;)t=i.css?h(n.target,i.p):i.f?n.target[i.p]():n.target[i.p],(t!==i.v1||a-i.t1>.15)&&(i.v2=i.v1,i.v1=t,i.t2=i.t1,i.t1=a),i=i._next;n=n._next}},c=function(t){this._lookup={},this.target=t,this.elem=t.style&&t.nodeType?!0:!1,i||(u.addEventListener("tick",p,null,!1,-100),s=r=u.time,i=!0),e&&(this._next=e,e._prev=this),e=this},f=c.getByTarget=function(t){for(var i=e;i;){if(i.target===t)return i;i=i._next}},d=c.prototype;return d.addProp=function(e,i){if(!this._lookup[e]){var s=this.target,r="function"==typeof s[e],n=r?this._altProp(e):e,a=this._firstVP;this._firstVP=this._lookup[e]=this._lookup[n]=a=new _(n!==e&&0===e.indexOf("set")?n:e,r,a),a.css=this.elem&&(void 0!==this.target.style[a.p]||o[a.p]),a.css&&o[a.p]&&!s._gsTransform&&t.set(s,{x:"+=0"}),a.type=i||a.css&&0===e.indexOf("rotation")?"deg":"",a.v1=a.v2=a.css?h(s,a.p):r?s[a.p]():s[a.p]}},d.removeProp=function(t){var e=this._lookup[t];e&&(e._prev?e._prev._next=e._next:e===this._firstVP&&(this._firstVP=e._next),e._next&&(e._next._prev=e._prev),this._lookup[t]=0,e.f&&(this._lookup[this._altProp(t)]=0))},d.isTrackingProp=function(t){return this._lookup[t]instanceof _},d.getVelocity=function(t){var e,i,s,r=this._lookup[t],n=this.target;if(!r)throw"The velocity of "+t+" is not being tracked.";return e=r.css?h(n,r.p):r.f?n[r.p]():n[r.p],i=e-r.v2,("rad"===r.type||"deg"===r.type)&&(s="rad"===r.type?2*Math.PI:360,i%=s,i!==i%(s/2)&&(i=0>i?i+s:i-s)),i/(u.time-r.t2)},d._altProp=function(t){var e=t.substr(0,3),i=("get"===e?"set":"set"===e?"get":e)+t.substr(3);return"function"==typeof this.target[i]?i:t},c.getByTarget=function(t){for(var i=e;i;){if(i.target===t)return i;i=i._next}},c.track=function(t,e,i){var s=f(t),r=e.split(","),n=r.length;for(i=(i||"").split(","),s||(s=new c(t));--n>-1;)s.addProp(r[n],i[n]||i[0]);return s},c.untrack=function(t,i){var s=f(t),r=(i||"").split(","),n=r.length;if(s){for(;--n>-1;)s.removeProp(r[n]);s._firstVP&&i||(s._prev?s._prev._next=s._next:s===e&&(e=s._next),s._next&&(s._next._prev=s._prev))}},c.isTracking=function(t,e){var i=f(t);return i?!e&&i._firstVP?!0:i.isTrackingProp(e):!1},c},!0)}),window._gsDefine&&window._gsQueue.pop()();
/**
 * Pptanimation.js - PPT Animation for Zepto/jQuery.
 *requestAnimationFrame
 * 参数说明
 * pageType: 页面类型
 * chapterId: 当前页ID
 * element: 动画对象
 * itemArray: 动画参数数组
 * container: 父容器
 * hasLoop: 是否循环动画
 * startEvent: 整个动画开始事件
 * completeEvent: 整个动画结束事件
 *
 **/
function PptAnimation(pageIndex, pageType, chapterId, element, itemArray, container, hasLoop, startEvent, completeEvent) {
	this.screenWidth = document.documentElement.clientWidth;
	this.screenHeight = document.documentElement.clientHeight;
	this.container = container ? $(container) : $(document.body); //父容器(主要用于手势控制路径动画)
	this.isDebug = false; //是否显示调试信息
	
	this.pageIndex = pageIndex;
// console.log(element.attr('id'))
	if (typeof(element) == "object") {
		this.pageType = pageType;
		this.chapterId = chapterId;
		this.element = element;
		this.elementStyle = ''; //动画对象默认样式
		this.elementVisibility = 'visible'; //初始化后对象状态
		this.options = [];
		if (Array.isArray(itemArray))
			this.options = itemArray;
		else
			console.log("Animation options error is not Array.");
		this.useMask = (PptAni.isDesktop || PptAni.isMacOS) ? true : false; //是否使用CSS渐变效果
		this.hasLoop = (hasLoop == true) ? true : false;
		this.startEvent = startEvent;
		this.completeEvent = completeEvent;
		this.parameter0 = null; //第一个动画参数（默认支持多个动画作用于一个对象）
		this.isExit0 = false; //第一个动画类型（进入/退出）
		this.preCode = ''; //动画前脚本
		this.postCode = ''; //动画后脚本
		this.codeDelay = 0; //延时
		this.hasRunning = true; //是否继续运行
		this.isCompleted = false; //是否完全执行过(用于解决重复执行问题)
		//初始对象状态:opacity(visibility)
		this.initElement();
	}
};

PptAnimation.prototype = {
	//解锁处理
	unlockHandler: function() {
		//购买解锁
		var unlock = Xut.Application.Unlock ? Xut.Application.Unlock() : "undefind";
		//脚本解锁
		if (typeof(this.preCode) == "function") {
			try {
				unlock = this.preCode();
			} catch (error) {
				console.log("Run preCode is error in initElement:" + error);
			}
			unlock = !!unlock;
		}
		//如果其值为1，并且当前未解锁，则执行动画(显示)，否则不执行。
		if (unlock == false && this.parameter0.inapp == 1)
			this.element.css("visibility", "visible");
		//如果其值为2，并且当前已解锁，则执行动画(显示)，否则不执行。
		else if (unlock == true && this.parameter0.inapp == 2)
			this.element.css("visibility", "visible");
		else
			this.element.css("visibility", "hidden"); //默认隐藏
	},

	//对象初始化(visibility)
	initElement: function() {
		if (this.options.length >= 1) {
			var data = this.options[0];
			this.parameter0 = this.parseJSON(data.parameter); //eval("("+data.parameter+")");

			//为高级动画修改增加
			//2016.3.16
			this.parameter0.pageType  = this.pageType;
			this.parameter0.pageIndex = this.pageIndex;

			this.isExit0 = this.parameter0.exit ? (this.parameter0.exit).toLowerCase() == "true" : false;
			try {
				//获取动画前脚本
				if (data.preCode && data.preCode.length > 0)
					this.preCode = new Function("(function(){" + this.enterReplace(data.preCode) + "})");
				else if (this.parameter0.preCode && this.parameter0.preCode.length > 0)
					this.preCode = new Function("(function(){" + this.enterReplace(this.parameter0.preCode) + "})");
				//获取动画后脚本
				if (data.postCode && data.postCode.length > 0)
					this.postCode = new Function("(function(){" + this.enterReplace(data.postCode) + "})");
				else if (this.parameter0.postCode && this.parameter0.postCode.length > 0)
					this.postCode = new Function("(function(){" + this.enterReplace(this.parameter0.postCode) + "})");
				//获取延时时间
				if (data.codeDelay && data.codeDelay > 0)
					this.codeDelay = data.codeDelay;
				else if (this.parameter0.codeDelay && this.parameter0.codeDelay > 0)
					this.codeDelay = this.parameter0.codeDelay;
			} catch (error) {
				console.error("Gets the preCode and postCode parameters error:" + error);
			}

			var initPpt = this.element.attr("data-pptAnimation");
			if (initPpt == null) {
				//解锁支持(In-app购买解锁、脚本解锁)
				if (this.parameter0.inapp > 0) {
					this.hasRunning = false;
					this.unlockHandler();
				} else {
					//路径动画对象默认显示
					if (data.animationName.indexOf("EffectPath") == 0 || data.animationName == "EffectCustom")
						this.element.css("visibility", "visible");
					else {
						switch (data.animationName) {
							//强调动画默认显示
							case "EffectFlashBulb": //脉冲
							case "EffectFlicker": //彩色脉冲
							case "EffectTeeter": //跷跷板
							case "EffectSpin": //陀螺旋转
							case "EffectGrowShrink": //放大/缩小
							case "EffectDesaturate": //不饱和
							case "EffectDarken": //加深
							case "EffectLighten": //变淡
							case "EffectTransparency": //透明
							case "EffectColorBlend": //对象颜色
							case "EffectComplementaryColor": //补色
							case "EffectChangeLineColor": //线条颜色
							case "EffectChangeFillColor": //填允颜色
							case "EffectFlashOnce": //闪烁(一次)
								this.element.css("visibility", "visible");
								break;
							case "EffectCredits": //字幕式特殊处理
								this.element.css("visibility", "hidden");
								break;
							default:
								if (this.isExit0)
									this.element.css("visibility", "visible"); //退出动画默认显示
								else
									this.element.css("visibility", "hidden"); //进入动画默认隐藏
								break;
						}
					}
				}
				//标识初始化状态
				this.element.attr("data-pptAnimation", true);
				this.elementStyle = this.element[0].style.cssText;
				this.elementVisibility = this.element.css("visibility");
			}
		}
	},

	//初始化
	initAnimation: function(startEvent, completeEvent) {
		var self = this;

		function startHandler(preCode) {
			//整个动画开始事件(外部事件)
			if (typeof(startEvent) == "function") startEvent();
			//条件判断动画是否执行
			if (typeof(preCode) == "function") {
				self.animation.pause();
				var result = false;
				try {
					result = preCode();
				} catch (error) {
					console.log("Run preCode is error in startHandler:" + error);
				}
				if (result == true)
					self.animation.resume();
				else{
					self.animation.stop();
					//整个动画完成事件(动画不需继续执行视为执行完成)
					if (typeof(completeEvent) == "function") completeEvent();
				}
			}
		}

		function completeHandler(postCode, codeDelay) {
			self.isCompleted = true;
			//延迟执行postCode代码
			try {
				if (typeof(postCode) == "function") {
					if (codeDelay > 0)
						setTimeout(postCode, codeDelay);
					else
						postCode();
				}
			} catch (error) {
				console.log("Run postCode is error in completeHandler:" + error);
			}
			//整个动画完成事件(外部事件)
			if (typeof(completeEvent) == "function") completeEvent();
		}

		var start = new TimelineLite({
			paused: true,
			onStart: startHandler,
			onStartParams: [this.preCode],
			onComplete: completeHandler,
			onCompleteParams: [this.postCode, this.codeDelay]
		});
		for (var i = 0; i < this.options.length; i++) {
			if (i == 0) {
				start.add(this.getTimeline(this.options[i], i), "shape0");
			} else {
				var invokeMode = this.options[i].invokeMode;
				if (invokeMode == 2)
					start.add(this.getTimeline(this.options[i], i));
				else
					start.add(this.getTimeline(this.options[i], i), "shape0"); //"shape"+(i-1)
			}
		}
		return start;
	},

	//执行动画
	runAnimation: function(scopeComplete) {
		if (this.hasRunning == false) return;
		/*
		if (this.animation instanceof TimelineLite && this.isCompleted)
			this.animation.restart();
		else {
			this.animation = this.initAnimation(this.startEvent, scopeComplete || this.completeEvent);
			this.animation.play();
		}
		*/
		if (this.isCompleted) this.resetAnimation();
		this.animation = this.initAnimation(this.startEvent, scopeComplete || this.completeEvent);
		this.animation.play();
	},

	//停止动画
	stopAnimation: function() {
		if (this.animation instanceof TimelineLite) {
			this.animation.stop();
			this.animation.kill();
			this.animation.clear();
		}
		this.animation = null;
	},

	//复位动画
	resetAnimation: function() {
		this.stopAnimation();
		if (this.elementStyle && this.elementStyle.length > 0) {
			var origin = this.element.css("-webkit-transform-origin");
			var isscroll = this.element.attr("isscroll");
			if(isscroll==null) this.element[0].style.cssText = this.elementStyle; //卷滚区域里的对象不需要还原
			this.element.css("-webkit-transform-origin", origin);
			this.element.css("visibility", this.elementVisibility);
			this.element.css("-webkit-transform", "none");
			this.element[0]["_gsTransform"] = null; //清理对象上绑定的动画属性
		}
		if (this.hasRunning == false) this.unlockHandler();
		this.isCompleted = false;
	},

	//销毁动画
	destroyAnimation: function() {
		this.stopAnimation();
		this.container = null;
		this.options = null;
		this.element = null;
	},

	//返回动画对象
	getTimeline: function(data, index) {
		var object = this.element;
		var parameter = this.parameter0;
		var isExit = this.isExit0;
		if (index > 0 || this.parameter0 == null) {
			parameter = this.parseJSON(data.parameter); //eval("("+data.parameter+")");
			isExit = parameter.exit ? (parameter.exit).toLowerCase() == "true" : false; //false:进入 true:消失
			if (index == 0) {
				this.parameter0 = parameter;
				this.isExit0 = isExit;
			}
		}
		var duration = data.speed / 1000; //执行时间
		var delay = data.delay / 1000; //延时时间
		if (navigator.epubReadingSystem) delay += 0.15; //如果是epub阅读器则动画延时0.15秒
		var repeat = (data.repeat >= 0) ? data.repeat - 1 : 0; //重复次数
		if (this.hasLoop) repeat = -1;
		parameter.pageType = this.pageType;
		parameter.chapterId = this.chapterId;
		parameter.animationName = data.animationName;
		//赋给动画音频Id
		parameter.videoId = data.videoId;

		//文字动画
		if (data.animationName == "xxtTextEffect") {
			return this.getTextAnimation(parameter, object, duration, delay, repeat);
		}

		//路径动画
		if (data.animationName.indexOf("EffectPath") == 0 || data.animationName == "EffectCustom") {
			return this.getPathAnimation(parameter, object, duration, delay, repeat);
		}

		switch (data.animationName) {
			//进入退出动画
			default:
			case "EffectAppear": //出现/消失
				return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);
			case "EffectFade": //淡出
				return this.getEffectFade(parameter, object, isExit, duration, delay, repeat);
			case "EffectFly": //飞入/飞出
				return this.getEffectFly(parameter, object, isExit, duration, delay, repeat);
			case "EffectAscend": //浮入/浮出(上升)
				return this.getEffectAscend(parameter, object, isExit, duration, delay, repeat);
			case "EffectDescend": //浮入/浮出(下降)
				return this.getEffectDescend(parameter, object, isExit, duration, delay, repeat);
			case "EffectSplit": //劈裂(分割)
				return this.getEffectSplit(parameter, object, isExit, duration, delay, repeat);
			case "EffectWipe": //擦除
				return this.getEffectWipe(parameter, object, isExit, duration, delay, repeat);
			case "EffectCircle": //形状一(圆)
				return this.getEffectCircle(parameter, object, isExit, duration, delay, repeat);
			case "EffectBox": //形状二(方框)
				return this.getEffectBox(parameter, object, isExit, duration, delay, repeat);
			case "EffectDiamond": //形状三(菱形)
				return this.getEffectDiamond(parameter, object, isExit, duration, delay, repeat);
			case "EffectPlus": //形状四(加号)
				return this.getEffectPlus(parameter, object, isExit, duration, delay, repeat);
				/*
			case "EffectWheel": //轮子
				return;
			case "EffectRandomBars": //随机线条
				return;
			*/
			case "EffectGrowAndTurn": //翻转式由远及近
				return this.getEffectGrowAndTurn(parameter, object, isExit, duration, delay, repeat);
			case "EffectZoom": //基本缩放
				return this.getEffectZoom(parameter, object, isExit, duration, delay, repeat);
			case "EffectFadedZoom": //淡出式缩放
				return this.getEffectFadedZoom(parameter, object, isExit, duration, delay, repeat);
			case "EffectSwivel": //基本旋转
				return this.getEffectSwivel(parameter, object, isExit, duration, delay, repeat);
			case "EffectFadedSwivel": //旋转(淡出式回旋)
				return this.getEffectFadedSwivel(parameter, object, isExit, duration, delay, repeat);
			case "EffectBounce": //弹跳
				return this.getEffectBounce(parameter, object, isExit, duration, delay, repeat);
			case "EffectBlinds": //百叶窗
				return this.getEffectBlinds(parameter, object, isExit, duration, delay, repeat);
			case "EffectPeek": //切入/出
				return this.getEffectPeek(parameter, object, isExit, duration, delay, repeat);
				/*
			case "EffectWedge": //楔入
				return;
			case "EffectStrips": //阶梯状
				return;
			case "EffectCheckerboard": //棋盘
				return;
			case "EffectDissolve": //向内/外溶解
				return;
			*/
			case "EffectExpand": //展开/收缩
				return this.getEffectExpand(parameter, object, isExit, duration, delay, repeat);
			case "EffectRiseUp": //升起/下沉
				return this.getEffectRiseUp(parameter, object, isExit, duration, delay, repeat);
			case "EffectCenterRevolve": //中心旋转
				return this.getEffectCenterRevolve(parameter, object, isExit, duration, delay, repeat);
			case "EffectSpinner": //回旋
				return this.getEffectSpinner(parameter, object, isExit, duration, delay, repeat);
			case "EffectFloat": //浮动
				return this.getEffectFloat(parameter, object, isExit, duration, delay, repeat);
			case "EffectSpiral": //螺旋飞入/出
				return this.getEffectSpiral(parameter, object, isExit, duration, delay, repeat);
			case "EffectPinwheel": //玩具风车
				return this.getEffectPinwheel(parameter, object, isExit, duration, delay, repeat);
			case "EffectCredits": //字幕式
				return this.getEffectCredits(parameter, object, isExit, duration, delay, repeat);
			case "EffectBoomerang": //飞旋
				return this.getEffectBoomerang(parameter, object, isExit, duration, delay, repeat);
			case "EffectArcUp": //曲线向上/下
				return this.getEffectArcUp(parameter, object, isExit, duration, delay, repeat);

				//强调动画
			case "EffectFlashBulb": //脉冲
				return this.getEffectFlashBulb(parameter, object, duration, delay, repeat);
			case "EffectFlicker": //彩色脉冲
				return this.getEffectFlicker(parameter, object, duration, delay, repeat);
			case "EffectTeeter": //跷跷板
				return this.getEffectTeeter(parameter, object, duration, delay, repeat);
			case "EffectSpin": //陀螺旋转
				return this.getEffectSpin(parameter, object, duration, delay, repeat);
			case "EffectGrowShrink": //放大/缩小
				return this.getEffectGrowShrink(parameter, object, duration, delay, repeat);
			case "EffectDesaturate": //不饱和
				return this.getEffectDesaturate(parameter, object, duration, delay, repeat);
			case "EffectDarken": //加深
				return this.getEffectDarken(parameter, object, duration, delay, repeat);
			case "EffectLighten": //变淡
				return this.getEffectLighten(parameter, object, duration, delay, repeat);
			case "EffectTransparency": //透明
				return this.getEffectTransparency(parameter, object, duration, delay, repeat);
			case "EffectColorBlend": //对象颜色
				return new TimelineMax();
			case "EffectComplementaryColor": //补色
				return this.getEffectComplementaryColor(parameter, object, duration, delay, repeat);
			case "EffectChangeLineColor": //线条颜色
				return new TimelineMax();
			case "EffectChangeFillColor": //填允颜色
				return new TimelineMax();
			case "EffectFlashOnce": //闪烁(一次)
				return this.getEffectFlashOnce(parameter, object, duration, delay, repeat);
				/*
			//路径动画
			case "EffectPathDown": //直线（下） M 0 0 L 0 0.25 E
			case "EffectPathLeft": //直线（靠左）
			case "EffectPathRight": //直线（靠右）
			case "EffectPathUp": //直线（上）
			case "EffectPathDiamond": //形状（菱形）
			case "EffectPathEqualTriangle": //形状（等边三角形）
			case "EffectPathHexagon": //形状（六边形）
			case "EffectPathOctagon": //形状（八边形）
			case "EffectPathParallelogram": //形状（平行四边形）
			case "EffectPathPentagon": //形状（五边形）
			case "EffectPathRightTriangle": //形状（直角三角形）
			case "EffectPathSquare": //形状（正方形）
			case "EffectPathTrapezoid": //形状（梯形）
			case "EffectPathArcDown": //弧线（向下）
			case "EffectPathArcLeft": //弧线（靠左）
			case "EffectPathArcRight": //弧线（向右）
			case "EffectPathArcUp": //弧线（向上
			case "EffectPathTurnDown": //转弯(下) M 0 0 L 0.125 0 C 0.181 0 0.25 0.069 0.25 0.125 L 0.25 0.25 E
			case "EffectPathTurnRight": //转弯（右下）
			case "EffectPathTurnUp": //转弯（上）
			case "EffectPathTurnUpRight": //转弯（右上）
			case "EffectPathCircle": //形状（圆）
			case "EffectPathHorizontalFigure8": //循环（水平数字）
			case "EffectPathVerticalFigure8": //循环（垂直数字）
			case "EffectPathLoopdeLoop": //循环（反复循环）
			case "EffectPathTeardrop": //形状（泪滴形）
			case "EffectPath5PointStar": //形状（五角形）
			case "EffectPathCrescentMoon": //形状（新月形）
			case "EffectCustom": //自定义路径
				return this.getPathAnimation(parameter,object,duration,delay,repeat);
			*/
		}
	},
	//文字动画
	getTextAnimation: function(parameter, object, duration, delay, repeat) {
		if (delay == 0) delay = 0.1; //子对象间延时不能为0
		var type = (parameter.effectType) ? parameter.effectType : "text1";
		var color = (parameter.startColor) ? parameter.startColor : "";
		var svgElement = object.find("svg").children();
		var t1 = new TimelineMax({
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		switch (type) {
			default:
			case "text5": //文字逐行蹦出(以行为单位)
			case "text1": //文字逐个蹦出(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0
					}
				}, delay);
				break;
			case "text2": //文字放大出现(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0,
						"font-size": 120
					},
					ease: "Strong.easeOut"
				}, delay);
				break;
			case "text3": //文字缩小出现(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0,
						"font-size": 0
					},
					ease: "Power1.easeIn"
				}, delay);
				break;
			case "text4": //文字渐变出现(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0,
						"fill": color
					},
					ease: "Power1.easeIn"
				}, delay);
				break;
		}
		return t1;
	},
	//出现/消失
	getEffectAppear: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		if (isExit == false)
			t1.to(object, 0.001, {
				autoAlpha: 1
			});
		else
			t1.to(object, 0.001, {
				css: {
					visibility: "hidden"
				}
			});
		return t1;
	},
	//淡出
	getEffectFade: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				autoAlpha: 0,
				ease: parameter.tweenEase,
				immediateRender: false
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//飞入效果
	getEffectFly: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(上、下、左、右、左上、左下、右上、右下)
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		var easeString = Expo.easeOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (parameter.smoothStart == 1 || parameter.smoothEnd == 1 || parameter.bounceEnd == 1) {
			if (isExit == true)
				easeString = Power4.easeOut;
			else
				easeString = Elastic.easeOut;
		}

		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: "visible"
				}]
			});
			switch (direction) {
				case "DirectionDown":
					var y = objInfo.offsetBottom + objInfo.height;
					t1.from(object, duration, {
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					t1.from(object, duration, {
						x: x,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionUp":
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.from(object, duration, {
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionRight":
					var x = objInfo.offsetRight + objInfo.width;
					t1.from(object, duration, {
						x: x,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionDownLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = objInfo.offsetBottom + objInfo.height;
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionDownRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = objInfo.offsetBottom + objInfo.height;
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionUpLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionUpRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				default:
					console.log("getEffectFly:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					x: 0,
					y: 0,
					visibility: "hidden" //clearProps功能(对象被还原)必须隐藏对象
				}]
			});
			switch (direction) {
				case "DirectionDown":
					var y = objInfo.offsetBottom + objInfo.height;
					t1.to(object, duration, {
						y: y,
						//clearProps: "y",
						ease: easeString
					});
					break;
				case "DirectionLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					t1.to(object, duration, {
						x: x,
						//clearProps: "x",
						ease: easeString
					});
					break;
				case "DirectionUp":
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.to(object, duration, {
						y: y,
						//clearProps: "y",
						ease: easeString
					});
					break;
				case "DirectionRight":
					var x = objInfo.offsetRight + objInfo.width;
					t1.to(object, duration, {
						x: x,
						//clearProps: "x",
						ease: easeString
					});
					break;
				case "DirectionDownLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = objInfo.offsetBottom + objInfo.height;
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				case "DirectionDownRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = objInfo.offsetBottom + objInfo.height;
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				case "DirectionUpLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				case "DirectionUpRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				default:
					console.log("getEffectFly:parameter error.")
					break;
			}
		}
		return t1;
	},
	//浮入/浮出(下方)
	getEffectAscend: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			//t1.to(object, 0.001, {opacity: 0, y: 100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
			t1.from(object, duration, {
				autoAlpha: 0,
				y: 100,
				ease: parameter.tweenEase,
				immediateRender: false
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1, y: 0
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				y: 100,
				//clearProps: "y", //己失效
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//浮入/浮出(上方)
	getEffectDescend: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			//t1.to(object, 0.001, {y: -100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
			t1.from(object, duration, {
				autoAlpha: 0,
				y: -100,
				ease: parameter.tweenEase,
				immediateRender: false
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				y: -100,
				ease: parameter.tweenEase,
				clearProps: "y"
			});
		}
		return t1;
	},
	//形状一(圆)
	getEffectCircle: function(parameter, object, isExit, duration, delay, repeat) {
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});;
		var result = this.getObjectInfo(object);
		var radius = Math.ceil(Math.sqrt(result.width * result.width / 4 + result.height * result.height / 4));
		switch (direction) {
			case "DirectionIn": //放大
			case "DirectionOut": //缩小
				if (isExit == false) {
					t1.to(object, duration, {
						onUpdate: updateCircleGradient
					});
				} else {
					t1.to(object, duration, {
						onUpdate: updateCircleGradient
					});
				}
				break;
			default:
				console.log("getEffectCircle:parameter error.");
				break;
		}
		return t1;

		function updateCircleGradient() {
			var progress = t1.progress();
			var len = parseInt(progress * radius);
			if (isExit == false)
				switch (direction) {
					case "DirectionIn": //DirectionIn放大
						object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,1)),to(rgba(0,0,0,0)),color-stop(10%,rgba(0,0,0,0)))");
						if (len == radius) object.css("-webkit-mask", "none");
						break;
					case "DirectionOut": //DirectionOut缩小
						object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,1)), to(rgba(0,0,0,0)), color-stop(90%, rgba(0,0,0,1)))");
						if (len == radius) object.css("-webkit-mask", "none");
						break;
				} else {
					switch (direction) {
						case "DirectionIn": //DirectionIn放大
							object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,0)),to(rgba(0,0,0,1)),color-stop(10%,rgba(0,0,0,1)))");
							if (len == radius) {
								//object.css("opacity","0");
								object.css("visibility", "hidden");
								object.css("-webkit-mask", "none");
							}
							break;
						case "DirectionOut": //DirectionOut缩小
							object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,0)), to(rgba(0,0,0,1)), color-stop(90%, rgba(0,0,0,0)))");
							if (len == radius) {
								//object.css("opacity","0");
								object.css("visibility", "hidden");
								object.css("-webkit-mask", "none");
							}
							break;
					}
				}
		}
	},
	//形状二(方框)
	getEffectBox: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		if (this.useMask == false) direction = "DirectionOut";

		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		t1.to(object, duration, {
			onUpdate: updateEffectBox
		});
		return t1;

		function updateEffectBox() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				switch (direction) {
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionOut":
						var top = objInfo.height * (0.5 - percent);
						var height = objInfo.height - top;
						var left = objInfo.width * (0.5 - percent);
						var width = objInfo.width - left;
						object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionOut":
						var top = objInfo.height * percent;
						var height = objInfo.height - top;
						var left = objInfo.width * percent;
						var width = objInfo.width - left;
						object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//形状三(菱形)
	getEffectDiamond: function(parameter, object, isExit, duration, delay, repeat) {
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		t1.to(object, duration, {
			onUpdate: updateEffectBox
		});
		return t1;

		function updateEffectBox() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				switch (direction) {
					case "DirectionOut":
						//break;
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionOut":
						//break;
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//形状四(加号)
	getEffectPlus: function(parameter, object, isExit, duration, delay, repeat) {
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectPlus
		});
		return t1;

		function updateEffectPlus() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				switch (direction) {
					case "DirectionIn":
						//break;
					case "DirectionOut":
						object.css("-webkit-mask",
							"-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))");
						break;
					default:
						console.log("getEffectPlus:parameter error.");
						break;
				}
				if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionIn":
						//break;
					case "DirectionOut":
						object.css("-webkit-mask",
							"-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (percent) + ",transparent),color-stop(" + (percent) + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (percent) + ",transparent),color-stop(" + (percent) + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))");
						break;
					default:
						console.log("getEffectPlus:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}

	},
	//百叶窗
	getEffectBlinds: function(parameter, object, isExit, duration, delay, repeat) {
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical）
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectBlinds
		});
		return t1;

		function updateEffectBlinds() {
			var num = 6; //分成N等份
			var progress = t1.progress();
			var percent = progress / num;
			var avg = 1 / num;
			var temp = 0.01; //渐变的过渡区
			var str = "";
			if (isExit == false) {
				switch (direction) {
					case "DirectionHorizontal": //水平
						str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg + temp) + ",rgba(0,0,0,1))";
							str += ",color-stop(" + (i * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg + percent + temp) + ",rgba(0,0,0,0))";
						}
						str += ")";
						break;
					case "DirectionVertical": //垂直
						str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg + temp) + ",rgba(0,0,0,1))";
							str += ",color-stop(" + (i * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg + percent + temp) + ",rgba(0,0,0,0))";
						}
						str += ")";
						break;
					default:
						console.log("getEffectBlinds:parameter error.");
						break;
				}
				object.css("-webkit-mask", str);
				if (percent >= (avg - temp)) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionHorizontal": //水平
						str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg - temp) + ",rgba(0,0,0,0))";
							str += ",color-stop(" + (i * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg - percent - temp) + ",rgba(0,0,0,1))";
						}
						str += ")";
						break;
					case "DirectionVertical": //垂直
						str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg - temp) + ",rgba(0,0,0,0))";
							str += ",color-stop(" + (i * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg - percent - temp) + ",rgba(0,0,0,1))";
						}
						str += ")";
						break;
					default:
						console.log("getEffectBlinds:parameter error.");
						break;
				}
				object.css("-webkit-mask", str);
				if (percent >= (avg - temp)) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//劈裂
	getEffectSplit: function(parameter, object, isExit, duration, delay, repeat) {
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionVerticalIn、DirectionHorizontalIn、DirectionHorizontalOut、DirectionVerticalOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectSplit
		});
		return t1;

		function updateEffectSplit() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				if (progress > 0.9) { //跳过最后10%（解决iPad的闪问题）
					object.css("-webkit-mask", "none");
					return;
				}
				switch (direction) {
					case "DirectionVerticalIn": //左右向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionHorizontalIn": //上下向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionHorizontalOut": //中间向上下展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
						break;
					case "DirectionVerticalOut": //中间向左右展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
						break;
					default:
						console.log("getEffectSplit:parameter error.");
						break;
				}
				//if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				if (progress < 0.1) return; //跳过前面10%（解决iPad的闪问题）
				switch (direction) {
					case "DirectionVerticalIn": //左右向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
						break;
					case "DirectionHorizontalIn": //上下向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
						break;
					case "DirectionHorizontalOut": //中间向上下展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionVerticalOut": //中间向左右展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
						break;
					default:
						console.log("getEffectSplit:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//切入/出
	getEffectPeek: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(上下左右)
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionUp":
					t1.from(object, duration, {
						y: -objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
					});
					break;
				case "DirectionDown":
					t1.from(object, duration, {
						y: objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
					});
					break;
				case "DirectionLeft":
					t1.from(object, duration, {
						x: -objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
					});
					break;
				case "DirectionRight":
					t1.from(object, duration, {
						x: objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
					});
					break;
				default:
					console.log("getEffectPeek:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionUp":
					t1.to(object, duration, {
						y: -objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
					});
					break;
				case "DirectionDown":
					t1.to(object, duration, {
						y: objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
					});
					break;
				case "DirectionLeft":
					t1.to(object, duration, {
						x: -objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
					});
					break;
				case "DirectionRight":
					t1.to(object, duration, {
						x: objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
					});
					break;
				default:
					console.log("getEffectPeek:parameter error.");
					break;
			}
		}
		return t1;
	},
	//擦除
	getEffectWipe: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(上下左右)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			//t1.to(object,duration,{onStart:this.startHandler,onStartParams:[object],onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
			t1.to(object, duration, {
				onUpdate: this.updateClipRect,
				onUpdateParams: [t1, object, isExit, direction, objInfo]
			});
		} else {
			//t1.to(object,duration,{onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
			t1.to(object, duration, {
				onUpdate: this.updateClipRect,
				onUpdateParams: [t1, object, isExit, direction, objInfo]
			});
		}
		return t1;
	},
	//翻转式由远及近
	getEffectGrowAndTurn: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				autoAlpha: 0,
				scale: 0,
				rotation: "90deg",
				ease: parameter.tweenEase,
				clearProps: "scale,rotation"
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1,
					scale: 1,
					rotation: "0deg"
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				scale: 0,
				rotation: "90deg",
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//升起/下沉
	getEffectRiseUp: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		var y = objInfo.offsetBottom + objInfo.height;
		var easeString = Back.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				autoAlpha: 0,
				y: y,
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				y: y,
				ease: easeString
			});
		}
		return t1;
	},
	//基本缩放
	getEffectZoom: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(放大:DirectionIn、屏幕中心放大:DirectionInCenter、轻微放大:DirectionInSlightly、缩小:DirectionOut、屏幕底部缩小:DirectionOutBottom、轻微缩小:DirectionOutSlightly)
		var t1 = null;
		object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionIn":
					t1.from(object, duration, {
						scale: 0,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInCenter":
					var result = this.getDirectionInCenter(object);
					t1.from(object, duration, {
						scale: 0,
						x: result.x,
						y: result.y,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInSlightly":
					t1.from(object, duration, {
						scale: 0.7,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOut":
					t1.from(object, duration, {
						scale: 3,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutBottom":
					//屏幕底部缩小(理解为底部的中间开始)
					t1.from(object, duration, {
						scale: 2,
						top: this.screenWidth + "px",
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutSlightly":
					t1.from(object, duration, {
						scale: 1.5,
						ease: parameter.tweenEase
					});
					break;
				default:
					console.log("getEffectZoom:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: "hidden"
				}]
			});
			switch (direction) {
				case "DirectionIn":
					t1.to(object, duration, {
						scale: 0,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInCenter":
					var result = this.getDirectionInCenter(object);
					t1.to(object, duration, {
						scale: 0,
						x: result.x,
						y: result.y,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInSlightly":
					t1.to(object, duration, {
						scale: 0.7,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOut":
					t1.to(object, duration, {
						scale: 3,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutBottom":
					t1.to(object, duration, {
						scale: 2,
						top: this.screenHeight + "px",
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutSlightly":
					t1.to(object, duration, {
						scale: 1.5,
						ease: parameter.tweenEase
					});
					break;
				default:
					console.log("getEffectZoom:parameter error.");
					break;
			}
		}
		return t1;
	},
	//缩放 淡出式缩放
	getEffectFadedZoom: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(对象中心DirectionIn、幻灯片中心DirectionInCenter)
		var t1 = null;
		object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
		var svgElement = object.find("svg"); //获取SVG对象
		if (svgElement) svgElement.css('-webkit-transform', 'translate3d(0px, 0px, 0px)'); //解决SVG文字错乱问题

		var keepRatio = (parameter.keepRatio == 0) ? false : true; //保持长宽比
		var fullScreen = (parameter.fullScreen == 1) ? true : false; //缩放到全屏
		var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
		var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
		if (fullScreen == true) {
			//计算比例
			var xScale = this.screenWidth / object.width();
			var yScale = this.screenHeight / object.height();
			var scaleValue = xScale;
			if (xScale > yScale) scaleValue = yScale;
			var result = this.getDirectionInCenter(object);
			if (isExit == false) {
				t1 = new TimelineMax({
					delay: delay,
					repeat: repeat,
					onStart: this.startHandler,
					onStartParams: [parameter, object, {
						opacity: 0
					}],
					onComplete: this.completeHandler,
					onCompleteParams: [parameter, object]
				});
				t1.to(object, duration, {
					x: result.x,
					y: result.y,
					autoAlpha: 1,
					scale: scaleValue,
					ease: parameter.tweenEase
				});
			} else {
				t1 = new TimelineMax({
					delay: delay,
					repeat: repeat,
					onStart: this.startHandler,
					onStartParams: [parameter, object],
					onComplete: this.completeHandler,
					onCompleteParams: [parameter, object]
				});
				t1.to(object, duration, {
					x: result.x,
					y: result.y,
					autoAlpha: 0,
					scale: scaleValue,
					ease: parameter.tweenEase
				});
			}
		} else if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionIn":
					if (keepRatio == true)
						t1.from(object, duration, {
							autoAlpha: 0,
							scale: 0,
							ease: parameter.tweenEase
						});
					else {
						t1.from(object, duration, {
							autoAlpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					}
					break;
				case "DirectionInCenter":
					var result = this.getDirectionInCenter(object);
					if (keepRatio == true)
						t1.from(object, duration, {
							x: result.x,
							y: result.y,
							autoAlpha: 0,
							scale: 0,
							ease: parameter.tweenEase
						});
					else
						t1.from(object, duration, {
							x: result.x,
							y: result.y,
							autoAlpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					break;
				default:
					console.log("getEffectFadedZoom:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			switch (direction) {
				case "DirectionOut":
					if (keepRatio == true)
						t1.to(object, duration, {
							autoAlpha: 0,
							scale: 0,
							ease: parameter.tweenEase,
							clearProps: "scale"
						});
					else
						t1.to(object, duration, {
							autoAlpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					break;
				case "DirectionOutCenter":
					var result = this.getDirectionInCenter(object);
					if (keepRatio == true)
						t1.to(object, duration, {
							x: result.x,
							y: result.y,
							autoAlpha: 0,
							scale: 0,
							ease: parameter.tweenEase
						});
					else
						t1.to(object, duration, {
							x: result.x,
							y: result.y,
							autoAlpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					break;
				default:
					console.log("getEffectFadedZoom:parameter error.");
					break;
			}
		}
		return t1;
	},
	//玩具风车
	getEffectPinwheel: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				autoAlpha: 0,
				scale: 0,
				rotation: "540deg",
				ease: parameter.tweenEase
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1,
					scale: 1,
					rotation: "0deg"
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				scale: 0,
				rotation: "540deg",
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//回旋
	getEffectSpinner: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Expo.easeOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				scale: 0,
				rotation: "180deg",
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: "hidden",
					scale: 1,
					rotation: "0deg"
				}]
			});
			t1.to(object, duration, {
				scale: 0,
				rotation: "180deg",
				ease: easeString
			});
		}
		return t1;
	},
	//旋转(淡出式回旋)
	getEffectFadedSwivel: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Linear.easeNone;
		var degree = Math.abs(parameter.degree) > 0 ? Number(parameter.degree) : 90;
		if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
		switch (parameter.centerPos) {
			case 1: //左上角
				object.css("-webkit-transform-origin", "left top");
				break;
			case 2: //上边中心
				object.css("-webkit-transform-origin", "center top");
				break;
			case 3: //右上角
				object.css("-webkit-transform-origin", "right top");
				break;
			case 4: //左边中心
				object.css("-webkit-transform-origin", "left cneter");
				break;
			case 5: //右边中心
				object.css("-webkit-transform-origin", "right center");
				break;
			case 6: //左下角
				object.css("-webkit-transform-origin", "left bottom");
				break;
			case 7: //下边中心
				object.css("-webkit-transform-origin", "center bottom");
				break;
			case 8: //右下角
				object.css("-webkit-transform-origin", "right bottom");
				break;
			case 0:
			default: //默认中心0
				object.css("-webkit-transform-origin", "center");
				break;
		}
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			//t1.from(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
			switch (parameter.axis) {
				case 0: //Z轴
					t1.from(object, duration, {
						autoAlpha: 0,
						rotation: degree + "deg",
						ease: easeString,
						immediateRender: false
					});
					break;
				case 1: //X轴
					t1.from(object, duration, {
						autoAlpha: 0,
						rotationX: degree + "deg",
						ease: easeString,
						immediateRender: false
					});
					break;
				case 2: //Y轴
				default:
					t1.from(object, duration, {
						autoAlpha: 0,
						rotationY: degree + "deg",
						ease: easeString,
						immediateRender: false
					});
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			//t1.to(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
			switch (parameter.axis) {
				case 0: //Z轴
					t1.to(object, duration, {
						autoAlpha: 0,
						rotation: degree + "deg",
						ease: easeString
					});
					break;
				case 1: //X轴
					t1.to(object, duration, {
						autoAlpha: 0,
						rotationX: degree + "deg",
						ease: easeString
					});
					break;
				case 2: //Y轴
				default:
					t1.to(object, duration, {
						autoAlpha: 0,
						rotationY: degree + "deg",
						ease: easeString
					});
					break;
			}
		}
		return t1;
	},
	//展开/收缩
	getEffectExpand: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				autoAlpha: 0,
				rotationY: "45deg",
				ease: parameter.tweenEase
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1,
					rotationY: "0deg"
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				rotationY: "45deg",
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//基本旋转
	getEffectSwivel: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical
		var t1 = null;
		var easeString = Linear.easeNone;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionHorizontal":
					t1.from(object, duration, {
						rotationY: "480deg",
						ease: easeString
					});
					break;
				case "DirectionVertical":
					t1.from(object, duration, {
						rotationX: "480deg",
						ease: easeString
					});
					break;
				default:
					console.log("getEffectSwivel:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: "hidden"
				}]
			});
			switch (direction) {
				case "DirectionHorizontal":
					t1.to(object, duration, {
						rotationY: "480deg",
						ease: easeString
					});
					break;
				case "DirectionVertical":
					t1.to(object, duration, {
						rotationX: "480deg",
						ease: easeString
					});
					break;
				default:
					console.log("getEffectSwivel:parameter error.");
					break;
			}
		}
		return t1;
	},
	//浮动
	getEffectFloat: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			var x = objInfo.offsetRight + objInfo.width;
			var y = 0 - (objInfo.offsetTop + objInfo.height);
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				autoAlpha: 0,
				rotation: "-45deg",
				x: x,
				y: y,
				ease: parameter.tweenEase
			});
		} else {
			var x = objInfo.offsetRight + objInfo.width;
			var y = 0 - (objInfo.offsetTop + objInfo.height);
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				rotation: "-45deg",
				x: x,
				y: y,
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//字幕式
	getEffectCredits: function(parameter, object, isExit, duration, delay, repeat) {
		var objInfo = this.getObjectInfo(object);
		var y = 0,
			top = 0;
		if (isExit == false) {
			//从下往上移
			y = 0 - (this.screenHeight + objInfo.height);
			top = objInfo.top + objInfo.offsetBottom + objInfo.height;
		} else {
			//从上往下移
			y = this.screenHeight + objInfo.height;
			top = objInfo.top - (objInfo.offsetTop + objInfo.height);
		}
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible",
				top: top + "px"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			y: y,
			ease: parameter.tweenEase
		});
		return t1;
	},
	//弹跳
	getEffectBounce: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			var total = duration;
			var time1 = total / 5;
			time2 = total / 10;
			time3 = total / 20;
			time4 = total / 40;
			time5 = total / 80;
			var width = 50 + 20 + 10 + 5 + 2.5 + 1 + 0.5 + 0.2 + 0.1;
			var height = this.screenHeight / 4;
			var y1 = height / 2;
			y2 = height / 4;
			y3 = height / 8;
			y4 = height / 16;
			var lastY = objInfo.offsetBottom - height + objInfo.height;

			t1.to(object, 0.01, {
				x: -width,
				y: -height
			})
				.to(object, time1, {
					x: "+=50",
					y: "+=" + height,
					ease: Circ.easeIn
				}) //慢到快
			.to(object, time1, {
				x: "+=20",
				y: "-=" + y1,
				scaleY: 0.8,
				ease: Circ.easeOut
			}) //快到慢
			.to(object, time1, {
				x: "+=10",
				y: "+=" + y1,
				scaleY: 1,
				ease: Circ.easeIn
			})
				.to(object, time2, {
					x: "+=5",
					y: "-=" + y2,
					scaleY: 0.85,
					ease: Circ.easeOut
				})
				.to(object, time2, {
					x: "+=2.5",
					y: "+=" + y2,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time3, {
					x: "+=1",
					y: "-=" + y3,
					scaleY: 0.9,
					ease: Circ.easeOut
				})
				.to(object, time3, {
					x: "+=0.5",
					y: "+=" + y3,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time4, {
					x: "+=0.2",
					y: "-=" + y4,
					scaleY: 0.95,
					ease: Circ.easeOut
				})
				.to(object, time4, {
					x: "+=0.1",
					y: "+=" + y4,
					scaleY: 1,
					ease: Circ.easeIn,
					clearProps: "x,y"
				});
			return t1;
		} else {
			var total = duration;
			var time1 = total / 5;
			time2 = total / 10;
			time3 = total / 20;
			time4 = total / 40;
			time5 = total / 80;
			var height = this.screenHeight / 4;
			var y1 = height / 2;
			y2 = height / 4;
			y3 = height / 8;
			y4 = height / 16;
			var lastY = objInfo.offsetBottom - height + objInfo.height;
			t1.to(object, time1, {
				x: "+=50",
				y: "+=" + height,
				ease: Circ.easeIn
			}) //慢到快
			.to(object, time1, {
				x: "+=20",
				y: "-=" + y1,
				scaleY: 0.8,
				ease: Circ.easeOut
			}) //快到慢
			.to(object, time1, {
				x: "+=10",
				y: "+=" + y1,
				scaleY: 1,
				ease: Circ.easeIn
			})
				.to(object, time2, {
					x: "+=5",
					y: "-=" + y2,
					scaleY: 0.85,
					ease: Circ.easeOut
				})
				.to(object, time2, {
					x: "+=2.5",
					y: "+=" + y2,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time3, {
					x: "+=1",
					y: "-=" + y3,
					scaleY: 0.9,
					ease: Circ.easeOut
				})
				.to(object, time3, {
					x: "+=0.5",
					y: "+=" + y3,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time4, {
					x: "+=0.2",
					y: "-=" + y4,
					scaleY: 0.95,
					ease: Circ.easeOut
				})
				.to(object, time4, {
					x: "+=0.1",
					y: "+=" + y4,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time5, {
					x: "+=0.1",
					y: "+=" + lastY,
					ease: Circ.easeIn
				});
		}
		return t1;
	},
	//飞旋
	getEffectBoomerang: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var time = duration / 3;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.add(TweenMax.to(object, 0.01, {
				x: 300,
				y: -200,
				rotation: "-60deg"
			}), "first");
			t1.add(TweenMax.to(object, time, {
				autoAlpha: 1,
				x: 0,
				y: 0,
				rotation: "0deg"
			}), "second");
			t1.add(TweenMax.to(object, time, {
				rotationY: "-80deg"
			}), "second");
			t1.add(TweenMax.to(object, time, {
				rotationY: "0deg"
			}));
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1,
					x: 0,
					y: 0,
					rotation: "0deg"
				}]
			});
			t1.add(TweenMax.to(object, time, {
				rotationY: "-80deg"
			}), "frist");
			t1.add(TweenMax.to(object, time, {
				autoAlpha: 0,
				x: 300,
				y: -200,
				rotation: "-60deg"
			}), "second");
			t1.add(TweenMax.to(object, time, {
				rotationY: "0deg"
			}), "second");
		}
		return t1;
	},
	//中心旋转
	getEffectCenterRevolve: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Power1.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 100
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 300
					}]
				},
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: "hidden"
				}]
			});
			t1.to(object, duration, {
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 100
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 300
					}]
				},
				ease: easeString
			});
		}
		return t1;
	},
	//螺旋飞入/出
	getEffectSpiral: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var easeString = Power1.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1.from(object, duration, {
				scale: 0,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: -200
					}, {
						x: 0,
						y: -400
					}, {
						x: -500,
						y: -600
					}]
				},
				ease: easeString
			});
		} else {
			t1.to(object, duration, {
				scale: 0,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: -200
					}, {
						x: 0,
						y: -400
					}, {
						x: -500,
						y: -600
					}]
				},
				ease: easeString
			});
		}
		return t1;
	},
	//曲线向上/下
	getEffectArcUp: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Power1.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				autoAlpha: 0,
				scale: 2,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 400
					}, {
						x: -500,
						y: 600
					}]
				},
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1,
					scale: 1
				}]
			});
			t1.to(object, duration, {
				autoAlpha: 0,
				scale: 2,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 400
					}, {
						x: -500,
						y: 600
					}]
				},
				ease: easeString,
				clearProps: "x,y"
			});
		}
		return t1;
	},
	//脉冲
	getEffectFlashBulb: function(parameter, object, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var range = (Number(parameter.range)) ? parameter.range : 0.1;
		var time = duration / 2;
		t1.to(object, time, {
			autoAlpha: 0.5,
			scale: "+=" + range
		})
			.to(object, time, {
				autoAlpha: 1,
				scale: "-=" + range
			});
		return t1;
	},
	//彩色脉冲
	getEffectFlicker: function(parameter, object, duration, delay, repeat) {
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		//if (repeat < 2) repeat = 2; //默认三次
		var color2 = parameter.color2 ? parameter.color2 : "#fff"; //颜色
		var maxGlowSize = (parameter.maxGlowSize) ? parameter.maxGlowSize : 0.1; //光晕最大尺寸(百分比)
		var minGlowSize = (parameter.minGlowSize) ? parameter.minGlowSize : 0.05; //光晕最小尺寸(百分比)
		var size = (object.width() > object.height()) ? object.height() : object.width();
		var maxSize = maxGlowSize * size;
		var minSize = minGlowSize * size;
		var opacity = (Number(parameter.opacity)) ? parameter.opcity : 0.75; //不透明度
		var distance = (Number(parameter.distance)) ? parameter.distance * size : 0;; //距离
		var color = this.colorHexToRGB(color2, opacity);
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				//"box-shadow": "none"
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectFlicker
		});
		return t1;

		function updateEffectFlicker() {
			var progress = t1.progress();
			var percent = parseInt(progress * (maxSize - minSize));
			if (progress > 0.5) percent = parseInt((1 - progress) * (maxSize - minSize));
			//object.css("box-shadow", distance + "px " + distance + "px " + minSize + "px " + (minSize + percent) + "px " + color);
			object.css("-webkit-filter", "drop-shadow(" + color + " " + distance + "px " + distance + "px " + (minSize + percent) + "px)");
		}
	},
	//跷跷板
	getEffectTeeter: function(parameter, object, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var mode = parameter.mode;
		var range = (Number(parameter.range)) ? parameter.range : 0.02;
		var time = duration / 8; //计算指定动画时间内每次运动时间(总时长不变，循环除外)
		switch (parameter.mode) {
			case 1: //左右移动
				range = range * object.width();
				t1.to(object, time, {
					x: -range
				})
					.to(object, time * 2, {
						x: range
					});
				//for (var i = 1; i < repeat; i++) {
				t1.to(object, time * 2, {
					x: -range
				});
				t1.to(object, time * 2, {
					x: range
				});
				//}
				t1.to(object, time, {
					x: 0
				});
				break;
			case 2: //上下移动
				range = range * object.height();
				t1.to(object, time, {
					y: -range
				})
					.to(object, time * 2, {
						y: range
					});
				//for (var i = 1; i < repeat; i++) {
				t1.to(object, time * 2, {
					y: -range
				});
				t1.to(object, time * 2, {
					y: range
				});
				//}
				t1.to(object, time, {
					y: 0
				});
				break;
			case 3: //左右挤压
				t1.to(object, time, {
					scaleX: 1 + range
				})
					.to(object, time * 2, {
						scaleX: 1 - range
					});
				//for (var i = 1; i < repeat; i++) {
				t1.to(object, time * 2, {
					scaleX: 1 + range
				});
				t1.to(object, time * 2, {
					scaleX: 1 - range
				});
				//}
				t1.to(object, time, {
					scaleX: 1
				});
				break;
			case 4: //上下挤压
				t1.to(object, time, {
					scaleY: 1 + range
				})
					.to(object, time * 2, {
						scaleY: 1 - range
					});
				//for (var i = 1; i < repeat; i++) {
				t1.to(object, time * 2, {
					scaleY: 1 + range
				});
				t1.to(object, time * 2, {
					scaleY: 1 - range
				});
				//}
				t1.to(object, time, {
					scaleY: 1
				});
				break;
			case 0: //左右晃晃
			default:
				range = range * 100;
				t1.to(object, time, {
					rotation: range + "deg"
				})
					.to(object, time * 2, {
						rotation: (-range) + "deg"
					});
				//for (var i = 1; i < repeat; i++) {
				t1.to(object, time * 2, {
					rotation: range + "deg"
				});
				t1.to(object, time * 2, {
					rotation: (-range) + "deg"
				});
				//}
				t1.to(object, time, {
					rotation: "0deg"
				});
				break;
		}
		return t1;
	},
	//陀螺旋转
	getEffectSpin: function(parameter, object, duration, delay, repeat) {
		var degree = parameter.amount ? parameter.amount : 360; //陀螺旋转角度
		if (Math.abs(parameter.degree) > 0) degree = parameter.degree;
		if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
		switch (parameter.centerPos) {
			case 1: //左上角
				object.css("-webkit-transform-origin", "left top");
				break;
			case 2: //上边中心
				object.css("-webkit-transform-origin", "center top");
				break;
			case 3: //右上角
				object.css("-webkit-transform-origin", "right top");
				break;
			case 4: //左边中心
				object.css("-webkit-transform-origin", "left cneter");
				break;
			case 5: //右边中心
				object.css("-webkit-transform-origin", "right center");
				break;
			case 6: //左下角
				object.css("-webkit-transform-origin", "left bottom");
				break;
			case 7: //下边中心
				object.css("-webkit-transform-origin", "center bottom");
				break;
			case 8: //右下角
				object.css("-webkit-transform-origin", "right bottom");
				break;
			case 0:
			default: //默认中心0
				object.css("-webkit-transform-origin", "center");
				break;
		}

		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		//t1.to(object, duration, {rotation:degree+"deg",ease:parameter.tweenEase});
		switch (parameter.axis) {
			case 1: //X轴
				t1.to(object, duration, {
					rotationX: "+=" + degree + "deg",
					ease: parameter.tweenEase
				});
				break;
			case 2: //Y轴
				t1.to(object, duration, {
					rotationY: "+=" + degree + "deg",
					ease: parameter.tweenEase
				});
				break;
			case 0: //Z轴
			default:
				t1.to(object, duration, {
					rotation: "+=" + degree + "deg",
					ease: parameter.tweenEase
				});
				break;
		}
		return t1;
	},
	//放大/缩小
	getEffectGrowShrink: function(parameter, object, duration, delay, repeat) {
		var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
		var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
		var keepRatio = (parameter.keepRatio == 0) ? false : true; //保持长宽比
		var fullScreen = (parameter.fullScreen == 1) ? true : false; //缩放到全屏
		var resetSize = (parameter.resetSize == 1) ? true : false; //恢复默认尺寸
		var easeString = Linear.easeNone; //Elastic.easeOut
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		if (fullScreen == true) {
			//计算比例
			var xScale = this.screenWidth / object.width();
			var yScale = this.screenHeight / object.height();
			var scaleValue = xScale;
			if (xScale > yScale) scaleValue = yScale;
			var result = this.getDirectionInCenter(object);
			t1.to(object, duration, {
				x: result.x,
				y: result.y,
				scale: scaleValue,
				ease: parameter.tweenEase
			});
		} else if (resetSize == true) {
			t1.to(object, duration, {
				scaleX: 1,
				scaleY: 1,
				ease: easeString
			});
		} else
			t1.to(object, duration, {
				scaleX: scaleX,
				scaleY: scaleY,
				ease: easeString
			});
		return t1;
	},
	//不饱和
	getEffectDesaturate: function(parameter, object, duration, delay, repeat) {
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		var saturation = parameter.saturation ? parameter.saturation : 0.5; //饱和度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateSaturate
		});
		return t1;

		function updateSaturate() {
			var progress = t1.progress();
			var percent = (progress <= 0.5) ? progress * 2 : 1;
			var val = 1 + (saturation - 1) * percent;
			object.css("-webkit-filter", "saturate(" + val + ")");
		}
	},
	//加深
	getEffectDarken: function(parameter, object, duration, delay, repeat) {
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		var brightness = (parameter.brightness && parameter.brightness < 1) ? brightness.saturation : 0.5; //亮度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateBrightness
		});
		return t1;

		function updateBrightness() {
			var progress = t1.progress();
			var percent = (progress <= 0.5) ? progress * 2 : 1;
			var val = 1 + (brightness - 1) * percent;
			object.css("-webkit-filter", "brightness(" + val + ")");
		}
	},
	//变淡
	getEffectLighten: function(parameter, object, duration, delay, repeat) {
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		var brightness = (parameter.brightness && parameter.brightness > 1) ? parameter.brightness : 1.5; //亮度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateBrightness
		});
		return t1;

		function updateBrightness() {
			var progress = t1.progress();
			var percent = (progress <= 0.5) ? progress * 2 : 1;
			var val = 1 + (brightness - 1) * percent;
			object.css("-webkit-filter", "brightness(" + val + ")");
		}
	},
	//透明
	getEffectTransparency: function(parameter, object, duration, delay, repeat) {
		var opacity = parameter.amount ? parameter.amount : 0.5; //透明度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			autoAlpha: opacity,
			ease: parameter.tweenEase
		});
		return t1;
	},
	//补色
	getEffectComplementaryColor: function(parameter, object, duration, delay, repeat) {
		var zIndex = Number(object.css("z-index"));
		if (isNaN(zIndex)) {
			zIndex = 10;
			console.log("The Z-index property for this object to get error.");
		}
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				"z-Index": zIndex + 100
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"z-Index": zIndex
			}]
		});
		t1.to(object, duration, {
			autoAlpha: 1
		});
		return t1;
	},
	//闪烁(一次)
	getEffectFlashOnce: function(parameter, object, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var time = duration / 3;
		t1.to(object, 0.001, {
			css: {
				visibility: "hidden"
			}
		}).to(object, time * 2, {}).to(object, time, {
			css: {
				visibility: "visible"
			}
		});
		return t1;
	},
	//路径动画
	getPathAnimation: function(parameter, object, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var path = (parameter.path) ? parameter.path : ""; //路径
		if (!path || path == "") return t1;
		var autoReverse = (parameter.autoReverse == 1) ? true : false; //自动翻转(系统自带,实为沿路径返回)
		var subRepeat = (autoReverse == true) ? 1 : 0; //如果autoReverse为真而子动画必须为1，否则默认为0
		var autoRotate = (parameter.objFollow == 1) ? true : false; //是否跟随路径旋转对象(Z轴)
		var autoTurn = (parameter.objFollow == 2) ? true : false; //反向运动时自动翻转对象(Y轴)
		//连续行为参数处理
		var axis = 0;
		var degree = 0; //旋转角度
		var scaleFactor = null; //缩放比例(未设置时必须为null才能不影响其它动画效果)
		var motionScript = ""; //连续脚本
		if (parameter.attrAlongPath) {
			axis = parameter.attrAlongPath.axis ? parameter.attrAlongPath.axis : 0;
			degree = Math.abs(parameter.attrAlongPath.degree) > 0 ? Number(parameter.attrAlongPath.degree) : 0;
			scaleFactor = (parameter.attrAlongPath.scaleFactor > 0) ? parameter.attrAlongPath.scaleFactor : null;
			motionScript = parameter.attrAlongPath.motionScript;
		}

		var currentFrame = 0; //当前帧
		var currentDegree = 0; //当前翻转角度
		var currentOffset = object.offset(); //对象当前位置
		var turnState = ""; //当前运动状态(左/右)
		//对象原点坐标（相对页面原点）
		var objInfo = {
			top: currentOffset.top,
			left: currentOffset.left,
			oX: currentOffset.left + object.width() / 2, //计算object的中心点x坐标
			oY: currentOffset.top + object.height() / 2 //计算object的中心点有y坐标
		};
		//移动起点坐标（默认为对象原点0,0）
		var x0 = 0,
			y0 = 0;
		//对象当前坐标
		var cx = 0,
			cy = 0;

		function resetStartPoint(x, y) {
			//如果路径动画为：EffectPathStairsDown向下阶梯、EffectPathBounceLeft向左弹跳、EffectPathBounceRight 向右弹跳，则需要重置起点坐标(此问题待验证,暂取消)
			/*if (parameter.animationName == "EffectPathStairsDown" || parameter.animationName == "EffectPathBounceLeft" || parameter.animationName == "EffectPathBounceRight") {
				x0 = x;
				y0 = y;
			}*/
			//更新当前坐标
			cx = x;
			cy = y;
		}
		var isCurve = (path.indexOf("C") < 0 && path.indexOf("c") < 0); //是否为曲线路径
		var ArrPath = path.split(' ');
		var svgPath = ''; //VML路径转SVG路径(测试)
		var quArr = [];
		for (var k = 0; k < ArrPath.length; k++) {
			var str = ArrPath[k];
			switch (str) {
				case "M": //移动（开始）
				case "m":
					var x = Math.round(ArrPath[k + 1] * this.screenWidth);
					var y = Math.round(ArrPath[k + 2] * this.screenHeight);
					/*t1.add(TweenMax.to(object, 0.001, {
						x: x,
						y: y
					}));*/
					quArr.push({
						x: x,
						y: y
					});
					k = k + 2;
					resetStartPoint(x, y);
					svgPath += 'M ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
					break;
				case "C": //曲线
				case "c":
					var x1 = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
					var y1 = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
					var x2 = x0 + Math.round(ArrPath[k + 3] * this.screenWidth);
					var y2 = y0 + Math.round(ArrPath[k + 4] * this.screenHeight);
					var x3 = x0 + Math.round(ArrPath[k + 5] * this.screenWidth);
					var y3 = y0 + Math.round(ArrPath[k + 6] * this.screenHeight);
					quArr.push({
						x: x1,
						y: y1
					}, {
						x: x2,
						y: y2
					}, {
						x: x3,
						y: y3
					});
					k = k + 6;
					resetStartPoint(x3, y3);
					svgPath += ' C ' + (objInfo.oX + x1) + ' ' + (objInfo.oY + y1) + ' ' + (objInfo.oX + x2) + ' ' + (objInfo.oY + y2) + ' ' + (objInfo.oX + x3) + ' ' + (objInfo.oY + y3);
					break;
				case "L": //直线
				case "l":
					var x = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
					var y = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
					if (x == cx && y == cy) {
						k = k + 2;
						break;
					}
					quArr.push({
						x: x,
						y: y
					});
					k = k + 2;
					resetStartPoint(x, y);
					svgPath += ' L ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
					break;
				case "Z": //闭合
					if (quArr[0].x != quArr[quArr.length - 1].x || quArr[0].y != quArr[quArr.length - 1].y) {
						quArr.push({
							x: quArr[0].x,
							y: quArr[0].y
						});
					}
					svgPath += ' Z';
					break;
				case "E": //结束
					break;
			}
		}
		//启用手势
		if (parameter.gesture) {
			t1 = new TimelineMax({
				paused: true,
				useFrames: true
			});
			parameter.tweenEase = "Linear.easeNone"; //手势控制必须为匀速运动

			//创建SVG路径(用于测试)
			/*if (PptAni.isDesktop) {
				if ($("#svgPathContainer").length == 0)
					this.container.append('<div id="svgPathContainer" style="position:absolute;width:100%;height:100%;"><svg width="100%" height="100%"  xmlns="http://www.w3.org/2000/svg" version="1.1"></svg></div>');
				var svgDocument = $("#svgPathContainer").find("svg")[0];
				//创建当前路径
				var p = PptAni.makeShape("Path", {
					id: "Path_" + object[0].id,
					d: svgPath
				});
				svgDocument.appendChild(p);
			}*/

			//创建手势控制区域
			var controlId = object[0].id; //控制区ID
			if (parameter.gesture.controlType == 1) {
				if (parameter.pathContent > 0) {
					controlId = controlId.replace(/\d+$/, parameter.pathContent);
				} else {
					controlId = "Cont_" + object[0].id;
					var expandArea = 20; //最小可触摸尺寸(扩展外框)
					var rect = p.getBoundingClientRect();
					this.container.append('<div id="' + controlId + '" style="z-index:9999;position:absolute;left:' + (rect.left - expandArea) + 'px;top:' + (rect.top - expandArea) + 'px;width:' + (rect.width + expandArea * 2) + 'px;height:' + (rect.height + expandArea * 2) + 'px;"></div>');
				}
			}
			//计算路径距离
			var distance = 0;
			//distance = p.getTotalLength(); //SVG路径获取长度
			var sprotInfo = [];
			for (var k = 1; k < quArr.length; k++) {
				//获取距离
				distance += this.calculateDistance(quArr[k], quArr[k - 1]);
				sprotInfo.push({
					start: 0,
					end: distance,
					quadrant: this.calculateDirection(quArr[k], quArr[k - 1])
				});
			}
			//修改时间为帧数(距离转换为帧)
			duration = Math.floor(distance);
			//触发点列表
			var cuePoints = [];
			if (parameter.gesture.cuePoints) {
				for (var i = 0; i < parameter.gesture.cuePoints.length; i++) {
					cuePoints.push({
						cueStart: Math.floor(parameter.gesture.cuePoints[i].cueStart * duration),
						cueEnd: Math.floor(parameter.gesture.cuePoints[i].cueEnd * duration),
						valueStart: parameter.gesture.cuePoints[i].valueStart,
						valueEnd: parameter.gesture.cuePoints[i].valueEnd,
						mouseEnter: false,
						mouseLeave: false
					});
				}
			}

			//绑定手势事件
			var self = this;
			var historyPoint = null;
			var throwStart = throwEnd = {};

			function throwProps(time, dist) {
				if (time < 300) {
					var toX, deceleration = 0.0006,
						speed = Math.abs(dist) / time,
						newDist = (speed * speed) / (2 * deceleration);
					if (dist > 0) {
						toX = currentFrame + newDist;
						newTime = speed / deceleration;
						step = newDist / newTime * 10;
					} else {
						toX = currentFrame - newDist;
						newTime = speed / deceleration;
						step = newDist / newTime * 10;
					}
					var medialSpeed = newDist / newTime * 10; //平均速度
					var startSpeed = medialSpeed * 10; //开始速度
					var throwTimer = setInterval(function() {
						var newFrame = 0;
						if (dist > 0)
							newFrame = currentFrame + startSpeed;
						else
							newFrame = currentFrame - startSpeed;
						if (newFrame >= duration) newFrame = duration;
						else if (newFrame <= 0) newFrame = 0;
						t1.seek(newFrame);
						currentFrame = newFrame;
						startSpeed -= medialSpeed;
						if (startSpeed <= 0 || currentFrame <= 0 || currentFrame >= duration) clearInterval(throwTimer);
					}, 10);
				}
			}

			function startEvent(e) {
				throwStart = {
					time: Date.now(),
					frame: currentFrame
				};
				historyPoint = {
					x: (PptAni.hasTouch ? e.changedTouches[0].pageX : e.clientX),
					y: (PptAni.hasTouch ? e.changedTouches[0].pageY : e.clientY)
				};
			}

			function moveEnd(e) {
				throwEnd = {
					time: Date.now(),
					frame: currentFrame
				};
				//throwProps(throwEnd.time - throwStart.time, throwEnd.frame - throwStart.frame);
				historyPoint = null;
				//松手后行为(辅助对象ID)
				if (parameter.gesture.afterTouch > 0)
					Xut.Assist.Run(parameter.pageType, parameter.gesture.afterTouch, null);
			}

			function moveEvent(e) {
				var currentPoint = {
					x: (PptAni.hasTouch ? e.changedTouches[0].pageX : e.clientX),
					y: (PptAni.hasTouch ? e.changedTouches[0].pageY : e.clientY)
				}
				var d = self.calculateDistance(currentPoint, historyPoint); //鼠示移动距离
				var quadrant1 = 0; //对象移动方向
				for (var i = 0; i < sprotInfo.length; i++) {
					if (currentFrame <= sprotInfo[i].end) {
						quadrant1 = sprotInfo[i].quadrant;
						break;
					}
				}
				var quadrant2 = self.calculateDirection(currentPoint, historyPoint); //鼠标移动方向
				switch (quadrant1) {
					case "1":
					case "2":
						if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame + (currentPoint.x - historyPoint.x);
						else if (quadrant1 == "1" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
						else if (quadrant1 == "2" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
						break;
					case "3":
					case "4":
						if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame - (currentPoint.x - historyPoint.x);
						else if (quadrant1 == "3" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
						else if (quadrant1 == "4" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
						break;
					case "+x":
						if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame + (currentPoint.x - historyPoint.x);
						break;
					case "-x":
						if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame - (currentPoint.x - historyPoint.x);
						break;
					case "+y":
						if (quadrant2 == "1" || quadrant2 == "4")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "2" || quadrant2 == "3")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "+y" || quadrant2 == "-y")
							currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
						break;
					case "-y":
						if (quadrant2 == "1" || quadrant2 == "4")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "2" || quadrant2 == "3")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+y" || quadrant2 == "-y")
							currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
						break;
				}
				if (currentFrame <= 0) currentFrame = 0;
				if (currentFrame >= duration) currentFrame = duration;
				t1.seek(currentFrame);
				updateTurnState();
				historyPoint = currentPoint;
				//处理触发点列表
				for (var i = 0; i < cuePoints.length; i++) {
					if (cuePoints[i].mouseEnter == false && currentFrame >= cuePoints[i].cueStart && currentFrame <= cuePoints[i].cueEnd) {
						cuePoints[i].mouseEnter = true;
						cuePoints[i].mouseLeave = false;
						if (cuePoints[i].valueStart > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueStart, null);
						break;
					} else if (cuePoints[i].mouseEnter == true && cuePoints[i].mouseLeave == false && (currentFrame < cuePoints[i].cueStart || currentFrame > cuePoints[i].cueEnd)) {
						cuePoints[i].mouseEnter = false;
						cuePoints[i].mouseLeave = true;
						if (cuePoints[i].valueEnd > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueEnd, null);
						break;
					}
				}
			}
			var objectId = object[0].id;
			if (parameter.gesture.controlType == 1) objectId = controlId;
			new PptAni.onTouchMove(parameter.pageType, controlId, objectId, startEvent, moveEvent, moveEnd);
		}
		//贝赛尔曲线参数构造
		var bezierObj = {
			type: "soft",
			values: quArr,
			autoRotate: autoRotate
		};
		if (isCurve == true) bezierObj = {
			curviness: 0, //curviness圆滑度(数字越大越圆滑),默认为1,0是直线运动
			values: quArr,
			autoRotate: autoRotate
		};
		//实例化动画参数
		if (degree == 0) {
			t1.to(object, duration, {
				scale: scaleFactor,
				bezier: bezierObj,
				repeat: subRepeat,
				yoyo: autoReverse,
				onUpdate: updateTurnState,
				ease: parameter.tweenEase
			});
		} else {
			switch (axis) {
				default:
				case 0: //Z轴
					t1.to(object, duration, {
						scale: scaleFactor,
						rotation: degree + "deg",
						bezier: bezierObj,
						repeat: subRepeat,
						yoyo: autoReverse,
						onUpdate: updateTurnState,
						ease: parameter.tweenEase
					});
					break;
				case 1: //X轴
					t1.to(object, duration, {
						scale: scaleFactor,
						rotationX: degree + "deg",
						bezier: bezierObj,
						repeat: subRepeat,
						yoyo: autoReverse,
						onUpdate: updateTurnState,
						ease: parameter.tweenEase
					});
					break;
				case 2: //Y轴
					t1.to(object, duration, {
						scale: scaleFactor,
						rotationY: degree + "deg",
						bezier: bezierObj,
						repeat: subRepeat,
						yoyo: autoReverse,
						onUpdate: updateTurnState,
						ease: parameter.tweenEase
					});
					break;
			}
		}
		//初始化定位(百分比)
		if (parameter.gesture && parameter.gesture.initPos > 0) {
			currentFrame = duration * parameter.gesture.initPos;
			t1.seek(currentFrame);
		}
		return t1;

		function updateTurnState() {
			/*var sel=object[0]
			sel.style.display = 'none';
			sel.offsetHeight;
			sel.style.display = 'block';*/
			if (autoTurn == false) return;
			var oldOffset = currentOffset;
			currentOffset = object.offset();
			if (turnState == "") {
				if (currentOffset.left > oldOffset.left) {
					turnState = "left";
				} else if (currentOffset.left < oldOffset.left) {
					turnState = "right";
				}
			} else {
				if (currentOffset.left > oldOffset.left) {
					if (turnState == "right") {
						if (currentDegree == 0) currentDegree = 180;
						else currentDegree = 0;
						TweenLite.set(object.children(), {
							rotationY: currentDegree
						});
						turnState = "left";
					}
				} else if (currentOffset.left < oldOffset.left) {
					if (turnState == "left") {
						if (currentDegree == 0) currentDegree = 180;
						else currentDegree = 0;
						TweenLite.set(object.children(), {
							rotationY: currentDegree
						});
						turnState = "right";
					}
				}
			}
		}
	},
	//=======================================================
	//子动画通用开始事件
	startHandler: function(parameter, object, params) {
		for (var item in params) {
			switch (item) {
				case "x":
					TweenLite.set(object, {
						x: params[item]
					});
					break;
				case "y":
					TweenLite.set(object, {
						y: params[item]
					});
					break;
				case "rotation":
					TweenLite.set(object, {
						rotation: params[item]
					});
					break;
				case "rotationX":
					TweenLite.set(object, {
						rotationX: params[item]
					});
					break;
				case "rotationY":
					TweenLite.set(object, {
						rotationY: params[item]
					});
					break;
				case "scale":
					TweenLite.set(object, {
						scale: params[item]
					});
					break;
				default:
					object.css(item, params[item]);
					break;
			}
		}
		//ppt动画音频
		if (parameter.videoId > 0) {
			Xut.AudioManager.contentAudio(parameter.chapterId, parameter.videoId)
		}


		var callSpiritWidget = function() {
			var pageObj = Xut.Presentation.GetPageObj(parameter.pageIndex, parameter.pageType)
			if (pageObj) {
				//启动了canvas模式
				if (pageObj.canvasRelated.enable) {
					var components, domId;
					if ((components = pageObj.baseGetComponent())) {
						components.length && components.forEach(function(componentObj) {
							domId = object.attr('id');
							if (domId == componentObj.getIdName()) {
								componentObj.play();
							}
						})
					}
					return;
				}
			}
			spiritWidget.updateAction(object.attr("id"), params);
		}


		//ppt动画扩展处理
		if (parameter.pptanimation && parameter.pptanimation.pptapi) {
			var params = parameter.pptanimation.parameters ? parameter.pptanimation.parameters : {};
			switch (parameter.pptanimation.pptapi) {
				case "bonesWidget": //骨骼动画
					bonesWidget.updateAction(object.attr("id"), params.actList);
					break;
				case "spiritWidget":
					callSpiritWidget();
					break;
			}
		}


	},
	//子动画通用结束事件
	completeHandler: function(parameter, object, params) {
		//if(parameter.pptAudio) parameter.pptAudio.end(); //声音存在延时问题，马上结束可导制无法听到声音
		for (var item in params) {
			switch (item) {
				case "x":
					TweenLite.set(object, {
						x: params[item]
					});
					break;
				case "y":
					TweenLite.set(object, {
						y: params[item]
					});
					break;
				case "rotation":
					TweenLite.set(object, {
						rotation: params[item]
					});
					break;
				case "rotationX":
					TweenLite.set(object, {
						rotationX: params[item]
					});
					break;
				case "rotationY":
					TweenLite.set(object, {
						rotationY: params[item]
					});
					break;
				case "scale":
					TweenLite.set(object, {
						scale: params[item]
					});
					break;
				default:
					object.css(item, params[item]);
					break;
			}
		}
	},
	//线性渐变效果更新(己注释)
	updateLineGradient: function(t1, object, isExit, direction) {
		var len = parseInt(t1.progress() * 100);
		if (isExit == false) {
			switch (direction) {
				case "DirectionUp":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% " + len + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionDown":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 100%, 0% " + (100 - len) + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionLeft":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, " + len + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionRight":
					object.css("-webkit-mask", "-webkit-gradient(linear,100% 0%, " + (100 - len) + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				default:
					console.log("updateLineGradient:parameter error.");
					break;
			}
			if (len == 100) object.css("-webkit-mask", "none");
		} else {
			switch (direction) {
				case "DirectionUp":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 100%, 0% " + len + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionDown":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% " + (100 - len) + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionLeft":
					object.css("-webkit-mask", "-webkit-gradient(linear,100% 0%, " + len + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionRight":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, " + (100 - len) + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				default:
					console.log("updateLineGradient:parameter error.");
					break;
			}
			if (len == 100) {
				//object.css("opacity","0");
				object.css("visibility", "hidden");
				object.css("-webkit-mask", "none");
			}
		}
	},
	//rect切割效果更新
	updateClipRect: function(t1, object, isExit, direction, objInfo) {
		var progress = t1.progress();
		var len = progress;
		if (isExit == false) {
			var top = objInfo.height * (1 - len);
			var height = objInfo.height - top;
			var left = objInfo.width * (1 - len);
			var width = objInfo.width - left;
			switch (direction) {
				case "DirectionUp":
					object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
					break;
				case "DirectionDown":
					object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
					break;
				case "DirectionLeft":
					object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
					break;
				case "DirectionRight":
					object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
					break;
				default:
					console.log("updateClipRect:parameter error.");
					break;
			}
		} else {
			var top = objInfo.height * len;
			var height = objInfo.height - top;
			var left = objInfo.width * len;
			var width = objInfo.width - left;
			switch (direction) {
				case "DirectionUp":
					object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
					break;
				case "DirectionDown":
					object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
					break;
				case "DirectionLeft":
					object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
					break;
				case "DirectionRight":
					object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
					break;
				default:
					console.log("updateClipRect:parameter error.");
					break;
			}
		}
	},
	//获取对象至屏幕中心的距离
	getDirectionInCenter: function(object) {
		var objInfo = this.getObjectInfo(object);
		var x = Math.round(this.screenWidth / 2 - objInfo.offsetLeft - objInfo.width / 2);
		var y = Math.round(this.screenHeight / 2 - objInfo.offsetTop - objInfo.height / 2);
		return {
			x: x,
			y: y
		};
	},
	//获取对象相关信息
	getObjectInfo: function(object) {
		var width = Math.round(object.width()); //四舍五入取整
		var height = Math.round(object.height());
		var top = Math.round(object.css("top").replace("px", ""));
		var left = Math.round(object.css("left").replace("px", ""));
		var offsetTop = Math.round(object.offset().top);
		if (object.attr("offsetTop"))
			offsetTop = parseInt(object.attr("offsetTop"));
		else
			object.attr("offsetTop", offsetTop);
		var offsetBottom = Math.ceil(this.screenHeight - offsetTop - height);
		var offsetLeft = Math.round(object.offset().left);
		if (object.attr("offsetLeft"))
			offsetLeft = parseInt(object.attr("offsetLeft"));
		else
			object.attr("offsetLeft", offsetLeft);
		var offsetRight = Math.ceil(this.screenWidth - offsetLeft - width);
		return {
			width: width,
			height: height,
			top: top,
			left: left,
			offsetTop: offsetTop,
			offsetLeft: offsetLeft,
			offsetBottom: offsetBottom,
			offsetRight: offsetRight
		};
	},
	//JSON解析
	parseJSON: function(itemArray) {
		var anminJson;
		try {
			anminJson = JSON.parse(itemArray);
		} catch (error) {
			console.log("parseJSON:" + error);
			anminJson = (new Function("return " + itemArray))();
		}
		return anminJson;
	},
	//回车符处理
	enterReplace: function(str) {
		return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
	},
	//计算两点直线距离
	calculateDistance: function(currentPoint, historyPoint) {
		var xdiff = currentPoint.x - historyPoint.x;
		var ydiff = currentPoint.y - historyPoint.y;
		return Math.ceil(Math.pow(xdiff * xdiff + ydiff * ydiff, 0.5));
	},
	//区间计算
	calculateDirection: function(currentPoint, historyPoint) {
		var quadrant = ""; //象限
		if (currentPoint.y == historyPoint.y && currentPoint.x > historyPoint.x)
			quadrant = "+x"; //水平正方向
		else if (currentPoint.y == historyPoint.y && currentPoint.x < historyPoint.x)
			quadrant = "-x"; //水平负方向
		else if (currentPoint.x == historyPoint.x && currentPoint.y > historyPoint.y)
			quadrant = "+y"; //垂直正方向
		else if (currentPoint.x == historyPoint.x && currentPoint.y < historyPoint.y)
			quadrant = "-y"; //垂直负方向
		else if (currentPoint.x > historyPoint.x && currentPoint.y < historyPoint.y)
			quadrant = "1"; //第一象限
		else if (currentPoint.x > historyPoint.x && currentPoint.y > historyPoint.y)
			quadrant = "2"; //第二象限
		else if (currentPoint.x < historyPoint.x && currentPoint.y > historyPoint.y)
			quadrant = "3"; //第三象限
		else if (currentPoint.x < historyPoint.x && currentPoint.y < historyPoint.y)
			quadrant = "4"; //第四象限
		return quadrant;
	},
	/**
	 * 十六进制颜色转换为RGB颜色
	 * @param color 要转换的十六进制颜色
	 * @return RGB颜色
	 */
	colorHexToRGB: function(color, opacity) {
		color = color.toUpperCase();
		var regexpHex = /^#[0-9a-fA-F]{3,6}$/; //Hex
		if (regexpHex.test(color)) {
			var hexArray = new Array();
			var count = 1;
			for (var i = 1; i <= 3; i++) {
				if (color.length - 2 * i > 3 - i) {
					hexArray.push(Number("0x" + color.substring(count, count + 2)));
					count += 2;　　　　　　
				} else {
					hexArray.push(Number("0x" + color.charAt(count) + color.charAt(count)));
					count += 1;
				}
			}
			if (opacity && opacity > 0)
				return "RGBA(" + hexArray.join(",") + "," + opacity + ")";
			else
				return "RGB(" + hexArray.join(",") + ")";
		} else {
			console.error("Hex Color string(" + color + ") format conversion error.")
			return color;　　
		}
	},
	/**
	 * RGB颜色转换为十六进制颜色
	 * @param color 要转换的RGB颜色
	 * @return 十六进制颜色
	 */
	colorRGBToHex: function(color) {
		var regexpRGB = /^(rgb|RGB)\([0-9]{1,3},\s?[0-9]{1,3},\s?[0-9]{1,3}\)$/; //RGB
		if (regexpRGB.test(color)) {
			color = color.replace(/(\(|\)|rgb|RGB)*/g, "").split(",");
			var colorHex = "#";
			for (var i = 0; i < color.length; i++) {
				var hex = Number(color[i]).toString(16);
				if (hex.length == 1) hex = "0" + hex;
				colorHex += hex;
			}
			return colorHex;
		} else {
			console.error("RGB Color string(" + color + ") format conversion error.")
			return color;
		}
	}
};

/*基本动画类鼠标响应事件*/
(function($) {
	//支持触屏
	var hasTouch = 'ontouchstart' in window;;
	//针对win8的处理
	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
	//移动端仅仅只支持touch
	var onlyTouch = hasTouch && MOBILE_REGEX.test(navigator.userAgent);
	//可以点击与触摸
	var isSurface = hasTouch && ('onmousedown' in window) && !onlyTouch;
	var isMacOS = (navigator.userAgent.indexOf("Mac") < 0) ? false : true;
	var startEventType = isSurface ? "touchstart mousedown" : (hasTouch ? "touchstart" : "mousedown");
	var moveEventType = isSurface ? "touchmove mousemove" : (hasTouch ? "touchmove" : "mousemove");
	var endEventType = isSurface ? "touchend mouseup" : (hasTouch ? "touchend" : "mouseup");
	var cancelEventType = isSurface ? "touchcancel mouseup" : (hasTouch ? 'touchcancel' : 'mouseup');

	var onTouchMove = function(pageType, parentId, objectId, startCallback, moveCallback, endCallback) {
		this.hasTouch = hasTouch;
		this.parent = document.getElementById(parentId);
		this.scroller = document.getElementById(objectId);
		this.startCallback = startCallback;
		this.moveCallback = moveCallback;
		this.endCallback = endCallback;
		if (this.scroller == null) {
			console.error("The control area of the object is empty.");
			return;
		}
		if (Xut.Contents.ResetDefaultControl) Xut.Contents.ResetDefaultControl(pageType, parentId); //取消默认翻页行为

		if (this.scroller["initTouchMove"]) this.scroller["initTouchMove"]._unbind(startEventType); //注销重复事件
		this._bind(startEventType, null);
		this.scroller["initTouchMove"] = this; //实例化对象绑定到元素，便于后期调用
	};
	onTouchMove.prototype = {
		handleEvent: function(e) {
			switch (e.type) {
				case startEventType:
					this._start(e);
					break;
				case moveEventType:
					this._move(e);
					break;
				case endEventType:
					this._end(e);
					break;
				case cancelEventType:
					this._end(e);
					break;
				case 'mouseout':
					this._end(e);
					break;
			}
		},
		_start: function(e) {
			e.preventDefault();
			if (typeof(this.startCallback) == "function") this.startCallback(e);
			this._bind(moveEventType);
			this._bind(endEventType);
			this._bind(cancelEventType);
			if (!this.hasTouch) this._bind('mouseout', this.parent);
		},
		_move: function(e) {
			if (typeof(this.moveCallback) == "function") this.moveCallback(e);
		},
		_end: function(e) {
			this._unbind(moveEventType);
			this._unbind(endEventType);
			this._unbind(cancelEventType);
			if (!this.hasTouch) this._unbind('mouseout', this.parent);
			if (typeof(this.endCallback) == "function") this.endCallback(e);
		},
		_bind: function(type, el, bubble) {
			(el || this.scroller).addEventListener(type, this, !!bubble);
		},
		_unbind: function(type, el, bubble) {
			(el || this.scroller).removeEventListener(type, this, !!bubble);
		}
	};
	var makeShape = function(type, params) {
		var shape = null;
		var svgns = "http://www.w3.org/2000/svg";
		switch (type) {
			case "Circle": //圆
				shape = document.createElementNS(svgns, "circle");
				shape.setAttributeNS(null, "cx", 25);
				shape.setAttributeNS(null, "cy", 25);
				shape.setAttributeNS(null, "r", 20);
				shape.setAttributeNS(null, "fill", "green");
				break;
			case "Ellipse": //椭圆
				shape = document.createElementNS(svgns, "ellipse");
				shape.setAttributeNS(null, "cx", 25);
				shape.setAttributeNS(null, "cy", 25);
				shape.setAttributeNS(null, "rx", 20);
				shape.setAttributeNS(null, "ry", 10);
				shape.setAttributeNS(null, "fill", "green");
				break;
			case "Line": //直线
				shape = document.createElementNS(svgns, "line");
				shape.setAttributeNS(null, "x1", 5);
				shape.setAttributeNS(null, "y1", 5);
				shape.setAttributeNS(null, "x2", 45);
				shape.setAttributeNS(null, "y2", 45);
				shape.setAttributeNS(null, "stroke", "green");
				break;
			case "Path": //路径
				shape = document.createElementNS(svgns, "path");
				shape.setAttributeNS(null, "id", params.id);
				shape.setAttributeNS(null, "d", params.d);
				shape.setAttributeNS(null, "fill", "none");
				shape.setAttributeNS(null, "stroke", "green");
				//shape.setAttributeNS(null, "stroke-width", 2);
				break;
			case "Polygon": //多边形
				shape = document.createElementNS(svgns, "polygon");
				shape.setAttributeNS(null, "points", "5,5 45,45 5,45 45,5");
				shape.setAttributeNS(null, "fill", "none");
				shape.setAttributeNS(null, "stroke", "green");
				break;
			case "Polyline": //折线
				shape = document.createElementNS(svgns, "polyline");
				shape.setAttributeNS(null, "points", "5,5 45,45 5,45 45,5");
				shape.setAttributeNS(null, "fill", "none");
				shape.setAttributeNS(null, "stroke", "green");
				break;
			case "Rectangle": //(圆角)矩形
				shape = document.createElementNS(svgns, "rect");
				shape.setAttributeNS(null, "x", 5);
				shape.setAttributeNS(null, "y", 5);
				shape.setAttributeNS(null, "rx", 5); //圆角大小
				shape.setAttributeNS(null, "ry", 5); //圆角大小
				shape.setAttributeNS(null, "width", 40);
				shape.setAttributeNS(null, "height", 40);
				shape.setAttributeNS(null, "fill", "green");
				break;
		}
		//svgDocument.appendChild(shape);
		return shape;
	};
	window.PptAni = {
		isMacOS: isMacOS,
		hasTouch: hasTouch,
		isDesktop: !hasTouch,
		makeShape: makeShape,
		onTouchMove: onTouchMove
	};
})(window.jQuery || window.Zepto);

/*基本动画API*/
(function($) {
	var methods = {
		init: function(options) {
			return {
				parameter: {
					direction: "Direction" + options.direction,
					tweenEase: options.tweenEase,
					keepRatio: options.keepRatio,
					scaleX: options.scaleX,
					scaleY: options.scaleY,
					fullScreen: options.fullScreen,
					resetSize: options.resetSize,
					amount: options.amount,
					centerPos: options.centerPos,
					axis: options.axis,
					degree: options.degree,
					clockWise: options.clockWise,
					mode: options.mode,
					range: options.range,
					path: options.path,
					objFollow: options.objFollow,
					distance: options.distance,
					scaleFactor: options.scaleFactor
				},
				isExit: (options.isExit) ? true : false,
				duration: (options.duration > 0) ? options.duration / 1000 : 1,
				delay: Number(options.delay) ? Number(options.delay) / 1000 : 0,
				repeat: options.repeat
			}
		},
		//出现/消失
		appear: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectAppear(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//渐渐出现/消失
		fade: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectFade(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//飞入/出
		fly: function(options) {
			if (options.direction.length == 0) options.direction = "Down";
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectFly(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//浮入/浮出(上方)
		ascend: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectAscend(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//浮入/浮出(上方)
		descend: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectDescend(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//缩放(淡出式缩放)
		zoom: function(options) {
			if (options.direction.length == 0) {
				if ((options.isExit + "").toLowerCase() == "true")
					options.direction = "Out";
				else
					options.direction = "In";
			}
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectFadedZoom(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//旋转(淡出式回旋)
		swivel: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectFadedSwivel(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//弹跳
		bounce: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectBounce(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//切入/出
		peek: function(options) {
			if (options.direction.length == 0) options.direction = "Down";
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectPeek(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//浮动
		floats: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectFloat(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//螺旋飞入/出
		spiral: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectSpiral(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//曲线向上/下
		arcup: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectArcUp(data.parameter, this, data.isExit, data.duration, data.delay, data.repeat);
		},
		//脉冲
		bulb: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectFlashBulb(data.parameter, this, data.duration, data.delay, data.repeat);
		},
		//彩色脉冲
		flicker: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectFlicker(data.parameter, this, data.duration, data.delay, data.repeat);
		},
		//跷跷板
		teeter: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectTeeter(data.parameter, this, data.duration, data.delay, data.repeat);
		},
		//陀螺旋转
		spin: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectSpin(data.parameter, this, data.duration, data.delay, data.repeat);
		},
		//放大/缩小
		growshrink: function(options) {
			var data = methods.init(options);
			var t1 = new PptAnimation().getEffectGrowShrink(data.parameter, this, data.duration, data.delay, data.repeat);
		},
		//路径动画
		path: function(options) {
			var data = methods.init(options);
			//this.css("visibility","visible");
			var t1 = new PptAnimation().getPathAnimation(data.parameter, this, data.duration, data.delay, data.repeat);
		},
		destroy: function() {}
	};
	$.fn.pptani = function(method, options) {
		var opts = $.extend({}, $.fn.pptani.defaults, options);
		opts.repeat = (opts.repeat > 0) ? opts.repeat - 1 : -1;
		if (methods[method]) {
			method = methods[method];
			return this.each(function() {
				return method.apply($(this), [opts]);
			});
		} else {
			console.error('Method ' + method + ' does not exist on jQuery.pptapi.');
			return this;
		}
	};
	//插件的defaults
	$.fn.pptani.defaults = {
		isExit: false, //是否为退出动画(默认为显示动画)
		direction: '', //运动方向(Down、Up、Left、Right)
		duration: 1000, //动画时间(毫秒)
		delay: 0, //延时时间(毫秒)
		repeat: 1, //执行次数
		//keepRatio : 1, //保持长宽比(1、0)
		//scaleX : 1, //横向缩放比例
		//scaleY : 1, //纵向缩放比例
		//fullScreen : 0, //是否缩放至全屏
		//resetSize : 0, //恢复默认尺寸
		//amount : 0, //陀螺旋转角度或透明度(用于强调动画)
		//centerPos : 0, //中心位置(0~8)
		//axis : 0, //旋转轴(Z:0、X:1、Y:2)
		//degree : 0, //旋转角度
		//clockWise : 1, //顺时针旋转(1:顺时针、0:逆时针)
		//mode : 0, //跷跷板模式(0`4)
		//range : 0.02, //运动幅度(百分比)
		//path : '', //路径(M 0 0 L 0.25 0 E)
		//objFollow : 0, //对象跟随(0:无变化、1:自动旋转、2:自动翻转)
		//distance : 0, //距离
		//scaleFactor : 1, //缩放比例
		tweenEase: 'Linear.easeNone' //ease效果(Linear.easeNone)
	};
})(window.jQuery || window.Zepto);
/**
 * Pptanimation.js - PPT Animation for Zepto/jQuery.
 *requestAnimationFrame
 * 参数说明
 * pageType: 页面类型
 * chapterId: 当前页ID
 * element: 动画对象
 * itemArray: 动画参数数组
 * container: 父容器
 * hasLoop: 是否循环动画
 * startEvent: 整个动画开始事件
 * completeEvent: 整个动画结束事件
 *
 **/
function CanvasAnimation(pageIndex, pageType, chapterId, element, itemArray, container, hasLoop, startEvent, completeEvent) {
	this.screenWidth = document.documentElement.clientWidth;
	this.screenHeight = document.documentElement.clientHeight;
	this.container = container ? $(container) : $(document.body); //父容器(主要用于手势控制路径动画)
	this.isDebug = false; //是否显示调试信息
	if(element.width>0 && element.height>0)
   		this.canvas={width:element.width ,height:element.height};
   	else{
   		console.error("Get width & height parameter error.");
   		return;
   	}

	if (typeof(element) == "object") {
		this.pageType = pageType;
		this.chapterId = chapterId;
		this.element = element;
		this.elementStyle = ''; //动画对象默认样式
		this.elementVisibility = 'visible'; //初始化后对象状态
		this.options = [];
		if (Array.isArray(itemArray))
			this.options = itemArray;
		else
			console.log("Animation options error is not Array.");
		this.useMask = (PptAni.isDesktop || PptAni.isMacOS) ? true : false; //是否使用CSS渐变效果
		this.hasLoop = (hasLoop == true) ? true : false;
		this.startEvent = startEvent;
		this.completeEvent = completeEvent;
		this.parameter0 = null; //第一个动画参数（默认支持多个动画作用于一个对象）
		this.isExit0 = false; //第一个动画类型（进入/退出）
		this.preCode = ''; //动画前脚本
		this.postCode = ''; //动画后脚本
		this.codeDelay = 0; //延时
		this.hasRunning = true; //是否继续运行
		this.isCompleted = false; //是否完全执行过(用于解决重复执行问题)
		//初始对象状态:opacity(visibility)
		this.initElement();
	}
};

CanvasAnimation.prototype = {
	//解锁处理
	unlockHandler: function() {
		//购买解锁
		var unlock = Xut.Application.Unlock ? Xut.Application.Unlock() : "undefind";
		//脚本解锁
		if (typeof(this.preCode) == "function") {
			try {
				unlock = this.preCode();
			} catch (error) {
				console.log("Run preCode is error in initElement:" + error);
			}
			unlock = !!unlock;
		}
		//如果其值为1，并且当前未解锁，则执行动画(显示)，否则不执行。
		if (unlock == false && this.parameter0.inapp == 1)
			this.element.css("visibility", "visible");
		//如果其值为2，并且当前已解锁，则执行动画(显示)，否则不执行。
		else if (unlock == true && this.parameter0.inapp == 2)
			this.element.css("visibility", "visible");
		else
			this.element.css("visibility", "hidden"); //默认隐藏
	},
	//对象初始化(visibility)
	initElement: function() {

		if (this.options.length >= 1) {
			var data = this.options[0];
			this.parameter0 = this.parseJSON(data.parameter); //eval("("+data.parameter+")");
			this.isExit0 = this.parameter0.exit ? (this.parameter0.exit).toLowerCase() == "true" : false;
			try {
				//获取动画前脚本
				if (data.preCode && data.preCode.length > 0)
					this.preCode = new Function("(function(){" + this.enterReplace(data.preCode) + "})");
				else if (this.parameter0.preCode && this.parameter0.preCode.length > 0)
					this.preCode = new Function("(function(){" + this.enterReplace(this.parameter0.preCode) + "})");
				//获取动画后脚本
				if (data.postCode && data.postCode.length > 0)
					this.postCode = new Function("(function(){" + this.enterReplace(data.postCode) + "})");
				else if (this.parameter0.postCode && this.parameter0.postCode.length > 0)
					this.postCode = new Function("(function(){" + this.enterReplace(this.parameter0.postCode) + "})");
				//获取延时时间
				if (data.codeDelay && data.codeDelay > 0)
					this.codeDelay = data.codeDelay;
				else if (this.parameter0.codeDelay && this.parameter0.codeDelay > 0)
					this.codeDelay = this.parameter0.codeDelay;
			} catch (error) {
				console.error("Gets the preCode and postCode parameters error:" + error);
			}

			var initPpt = this.element.initPptAnimation;
			
			//console.log(this.element)
			//var initPpt=null;
			if (initPpt == null) {
				//解锁支持(In-app购买解锁、脚本解锁)
				if (this.parameter0.inapp > 0) {
					this.hasRunning = false;
					this.unlockHandler();
				}else{
					//路径动画对象默认显示
					if (data.animationName.indexOf("EffectPath") == 0 || data.animationName == "EffectCustom")
						//this.element.css("visibility", "visible");
						this.element.visible=true;
					else {

						switch (data.animationName) {
							//强调动画默认显示
							case "EffectFlashBulb": //脉冲
							case "EffectFlicker": //彩色脉冲
							case "EffectTeeter": //跷跷板
							case "EffectSpin": //陀螺旋转
							case "EffectGrowShrink": //放大/缩小
							case "EffectDesaturate": //不饱和
							case "EffectDarken": //加深
							case "EffectLighten": //变淡
							case "EffectTransparency": //透明
							case "EffectColorBlend": //对象颜色
							case "EffectComplementaryColor": //补色
							case "EffectChangeLineColor": //线条颜色
							case "EffectChangeFillColor": //填允颜色
							case "EffectFlashOnce": //闪烁(一次)
								//this.element.css("visibility", "visible");
									this.element.visible=true;
								break;
							case "EffectCredits": //字幕式特殊处理
								//this.element.css("visibility", "hidden");
									this.element.visible=false;
								break;
							default:
								if (this.isExit0)
										this.element.visible=true;
									//this.element.css("visibility", "visible"); //退出动画默认显示
								else
										this.element.visible=false;
									//this.element.css("visibility", "hidden"); //进入动画默认隐藏
								break;
						}
					}
				}
				//console.log(this.element,data.animationName,this.isExit0)
				//标识初始化状态
				this.elementClone={
					x:this.element.x,
					y:this.element.y,
					alpha:this.element.alpha,
					visible:this.element.visible
				}
			
				this.element.initPptAnimation= true;
		
				//this.elementStyle = this.element[0].style.cssText;
				this.elementVisibility = this.element.visible;
			}
		}
	},

	//初始化
	initAnimation: function(startEvent, completeEvent) {
		var self = this;

		function startHandler(preCode) {
		
			//整个动画开始事件(外部事件)
			if (typeof(startEvent) == "function") startEvent();
			//条件判断动画是否执行
			if (typeof(preCode) == "function") {
				self.animation.pause();
				var result = false;
				try {
					result = preCode();
				} catch (error) {
					console.log("Run preCode is error in startHandler:" + error);
				}
				if (result == true)
					self.animation.resume();
				else{
					self.animation.stop();
					//整个动画完成事件(动画不需继续执行视为执行完成)
					if (typeof(completeEvent) == "function") completeEvent();
				}

			}

		}

		function completeHandler(postCode, codeDelay) {
			self.isCompleted = true;
			//延迟执行postCode代码
			try {
				if (typeof(postCode) == "function") {
					if (codeDelay > 0)
						setTimeout(postCode, codeDelay);
					else
						postCode();
				}
			} catch (error) {
				console.log("Run postCode is error in completeHandler:" + error);
			}
			//整个动画完成事件(外部事件)
			if (typeof(completeEvent) == "function") completeEvent();
		}

		var start = new TimelineLite({
			paused: true,
			onStart: startHandler,
			onStartParams: [this.preCode],
			onComplete: completeHandler,
			onCompleteParams: [this.postCode, this.codeDelay]
		});
		for (var i = 0; i < this.options.length; i++) {

			if (i == 0) {
				start.add(this.getTimeline(this.options[i], i), "shape0");
			} else {
				var invokeMode = this.options[i].invokeMode;
				if (invokeMode == 2)
					start.add(this.getTimeline(this.options[i], i));
				else
					start.add(this.getTimeline(this.options[i], i), "shape0"); //"shape"+(i-1)
			}
		}
		
		return start;
	},

	//执行动画
	runAnimation: function(scopeComplete) {
		if (this.hasRunning == false) return;
	
		if (this.animation instanceof TimelineLite && this.isCompleted){


			this.animation.restart();
				}
		else {
		//console.log(this.element.x)
			this.animation = this.initAnimation(this.startEvent, scopeComplete || this.completeEvent);
	
			this.animation.play();
		}
	},

	//停止动画
	stopAnimation: function() {
		if (this.animation instanceof TimelineLite) {
			this.animation.stop();
			this.animation.kill();
			this.animation.clear();
		}
		this.animation = null;
	},

	//复位动画
	resetAnimation: function() {
		this.stopAnimation();
		if (this.elementClone) {
			this.element.x = this.elementClone.x;
			this.element.y = this.elementClone.y;
			this.element.alpha = this.elementClone.alpha;
			this.element.visible = this.elementVisibility;
			//console.log(this.element.visible)
			this.element.initPptAnimation = false;
		}
		if (this.hasRunning == false) this.unlockHandler();

		/*if (this.elementStyle && this.elementStyle.length > 0) {
			var origin = this.element.css("-webkit-transform-origin");
			this.element[0].style.cssText = this.elementStyle;
			this.element.css("-webkit-transform-origin", origin);
			this.element.css("visibility", this.elementVisibility);
			this.element.css("-webkit-transform", "none");
			this.element[0]["_gsTransform"] = null; //清理对象上绑定的动画属性
		}*/
	},
	//销毁动画
	destroyAnimation: function() {
		this.stopAnimation();
		this.container = null;
		this.options = null;
		this.element = null;
	},

	//返回动画对象
	getTimeline: function(data, index) {
		// console.log(data,this.element.texture.baseTexture.source)
		//console.log(data,this.element.texture.baseTexture.source)
		// console.log(data,this.element.texture.baseTexture.source)

		var object = this.element;
		var parameter = this.parameter0;
		var isExit = this.isExit0;
		if (index > 0 || this.parameter0 == null) {
			parameter = this.parseJSON(data.parameter); //eval("("+data.parameter+")");
			isExit = parameter.exit ? (parameter.exit).toLowerCase() == "true" : false; //false:进入 true:消失
			if (index == 0) {
				this.parameter0 = parameter;
				this.isExit0 = isExit;
			}
		}
		var duration = data.speed / 1000; //执行时间
		var delay = data.delay / 1000; //延时时间
		if (navigator.epubReadingSystem) delay += 0.15; //如果是epub阅读器则动画延时0.15秒
		var repeat = (data.repeat >= 0) ? data.repeat - 1 : 0; //重复次数
		if (this.hasLoop) repeat = -1;
		parameter.pageType = this.pageType;
		parameter.chapterId = this.chapterId;
		parameter.animationName = data.animationName;
		//赋给动画音频Id
		parameter.videoId = data.videoId;

		//文字动画
		if (data.animationName == "xxtTextEffect") {
			return this.getTextAnimation(parameter, object, duration, delay, repeat);
		}

		//路径动画
		if (data.animationName.indexOf("EffectPath") == 0 || data.animationName == "EffectCustom") {
			return this.getPathAnimation(parameter, object, duration, delay, repeat);
		}
		
		switch (data.animationName) {
			//进入退出动画
			default:
			case "EffectAppear": //出现/消失
				return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);
			case "EffectFade": //淡出
				return this.getEffectFade(parameter, object, isExit, duration, delay, repeat);
			case "EffectFly": //飞入/飞出
				return this.getEffectFly(parameter, object, isExit, duration, delay, repeat);
			case "EffectAscend": //浮入/浮出(上升)
				return this.getEffectAscend(parameter, object, isExit, duration, delay, repeat);
			case "EffectDescend": //浮入/浮出(下降)
				return this.getEffectDescend(parameter, object, isExit, duration, delay, repeat);
			case "EffectSplit": //劈裂(分割)
				return this.getEffectSplit(parameter, object, isExit, duration, delay, repeat);
			case "EffectWipe": //擦除
				return this.getEffectWipe(parameter, object, isExit, duration, delay, repeat);
			case "EffectCircle": //形状一(圆)
				return this.getEffectCircle(parameter, object, isExit, duration, delay, repeat);
			case "EffectBox": //形状二(方框)
				return this.getEffectBox(parameter, object, isExit, duration, delay, repeat);
			case "EffectDiamond": //形状三(菱形)
				return this.getEffectDiamond(parameter, object, isExit, duration, delay, repeat);
			case "EffectPlus": //形状四(加号)
				return this.getEffectPlus(parameter, object, isExit, duration, delay, repeat);
				/*
			case "EffectWheel": //轮子
				return;
			case "EffectRandomBars": //随机线条
				return;
			*/
			case "EffectGrowAndTurn": //翻转式由远及近
				return this.getEffectGrowAndTurn(parameter, object, isExit, duration, delay, repeat);
			case "EffectZoom": //基本缩放
				return this.getEffectZoom(parameter, object, isExit, duration, delay, repeat);
			case "EffectFadedZoom": //淡出式缩放
				return this.getEffectFadedZoom(parameter, object, isExit, duration, delay, repeat);
			case "EffectSwivel": //基本旋转
				return this.getEffectSwivel(parameter, object, isExit, duration, delay, repeat);
			case "EffectFadedSwivel": //旋转(淡出式回旋)
				return this.getEffectFadedSwivel(parameter, object, isExit, duration, delay, repeat);
			case "EffectBounce": //弹跳
				return this.getEffectBounce(parameter, object, isExit, duration, delay, repeat);
			case "EffectBlinds": //百叶窗
				return this.getEffectBlinds(parameter, object, isExit, duration, delay, repeat);
			case "EffectPeek": //切入/出
				return this.getEffectPeek(parameter, object, isExit, duration, delay, repeat);
				/*
			case "EffectWedge": //楔入
				return;
			case "EffectStrips": //阶梯状
				return;
			case "EffectCheckerboard": //棋盘
				return;
			case "EffectDissolve": //向内/外溶解
				return;
			*/
			case "EffectExpand": //展开/收缩
				return this.getEffectExpand(parameter, object, isExit, duration, delay, repeat);
			case "EffectRiseUp": //升起/下沉
				return this.getEffectRiseUp(parameter, object, isExit, duration, delay, repeat);
			case "EffectCenterRevolve": //中心旋转
				return this.getEffectCenterRevolve(parameter, object, isExit, duration, delay, repeat);
			case "EffectSpinner": //回旋
				return this.getEffectSpinner(parameter, object, isExit, duration, delay, repeat);
			case "EffectFloat": //浮动
				return this.getEffectFloat(parameter, object, isExit, duration, delay, repeat);
			case "EffectSpiral": //螺旋飞入/出
				return this.getEffectSpiral(parameter, object, isExit, duration, delay, repeat);
			case "EffectPinwheel": //玩具风车
				return this.getEffectPinwheel(parameter, object, isExit, duration, delay, repeat);
			case "EffectCredits": //字幕式
				return this.getEffectCredits(parameter, object, isExit, duration, delay, repeat);
			case "EffectBoomerang": //飞旋
				return this.getEffectBoomerang(parameter, object, isExit, duration, delay, repeat);
			case "EffectArcUp": //曲线向上/下
				return this.getEffectArcUp(parameter, object, isExit, duration, delay, repeat);

				//强调动画
			case "EffectFlashBulb": //脉冲
				return this.getEffectFlashBulb(parameter, object, duration, delay, repeat);
			case "EffectFlicker": //彩色脉冲
				return this.getEffectFlicker(parameter, object, duration, delay, repeat);
			case "EffectTeeter": //跷跷板
				return this.getEffectTeeter(parameter, object, duration, delay, repeat);
			case "EffectSpin": //陀螺旋转
				return this.getEffectSpin(parameter, object, duration, delay, repeat);
			case "EffectGrowShrink": //放大/缩小
				return this.getEffectGrowShrink(parameter, object, duration, delay, repeat);
			case "EffectDesaturate": //不饱和
				return this.getEffectDesaturate(parameter, object, duration, delay, repeat);
			case "EffectDarken": //加深
				return this.getEffectDarken(parameter, object, duration, delay, repeat);
			case "EffectLighten": //变淡
				return this.getEffectLighten(parameter, object, duration, delay, repeat);
			case "EffectTransparency": //透明
				return this.getEffectTransparency(parameter, object, duration, delay, repeat);
			case "EffectColorBlend": //对象颜色
				return new TimelineMax();
			case "EffectComplementaryColor": //补色
				return this.getEffectComplementaryColor(parameter, object, duration, delay, repeat);
			case "EffectChangeLineColor": //线条颜色
				return new TimelineMax();
			case "EffectChangeFillColor": //填允颜色
				return new TimelineMax();
			case "EffectFlashOnce": //闪烁(一次)
				return this.getEffectFlashOnce(parameter, object, duration, delay, repeat);
				/*
			//路径动画
			case "EffectPathDown": //直线（下） M 0 0 L 0 0.25 E
			case "EffectPathLeft": //直线（靠左）
			case "EffectPathRight": //直线（靠右）
			case "EffectPathUp": //直线（上）
			case "EffectPathDiamond": //形状（菱形）
			case "EffectPathEqualTriangle": //形状（等边三角形）
			case "EffectPathHexagon": //形状（六边形）
			case "EffectPathOctagon": //形状（八边形）
			case "EffectPathParallelogram": //形状（平行四边形）
			case "EffectPathPentagon": //形状（五边形）
			case "EffectPathRightTriangle": //形状（直角三角形）
			case "EffectPathSquare": //形状（正方形）
			case "EffectPathTrapezoid": //形状（梯形）
			case "EffectPathArcDown": //弧线（向下）
			case "EffectPathArcLeft": //弧线（靠左）
			case "EffectPathArcRight": //弧线（向右）
			case "EffectPathArcUp": //弧线（向上
			case "EffectPathTurnDown": //转弯(下) M 0 0 L 0.125 0 C 0.181 0 0.25 0.069 0.25 0.125 L 0.25 0.25 E
			case "EffectPathTurnRight": //转弯（右下）
			case "EffectPathTurnUp": //转弯（上）
			case "EffectPathTurnUpRight": //转弯（右上）
			case "EffectPathCircle": //形状（圆）
			case "EffectPathHorizontalFigure8": //循环（水平数字）
			case "EffectPathVerticalFigure8": //循环（垂直数字）
			case "EffectPathLoopdeLoop": //循环（反复循环）
			case "EffectPathTeardrop": //形状（泪滴形）
			case "EffectPath5PointStar": //形状（五角形）
			case "EffectPathCrescentMoon": //形状（新月形）
			case "EffectCustom": //自定义路径
				return this.getPathAnimation(parameter,object,duration,delay,repeat);
			*/
		}
	},
	//文字动画
	getTextAnimation: function(parameter, object, duration, delay, repeat) {
		if (delay == 0) delay = 0.1; //子对象间延时不能为0
		var type = (parameter.effectType) ? parameter.effectType : "text1";
		var color = (parameter.startColor) ? parameter.startColor : "";
		var svgElement = object.find("svg").children();
		var t1 = new TimelineMax({
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		switch (type) {
			default:
			case "text5": //文字逐行蹦出(以行为单位)
			case "text1": //文字逐个蹦出(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0
					}
				}, delay);
				break;
			case "text2": //文字放大出现(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0,
						"font-size": 120
					},
					ease: "Strong.easeOut"
				}, delay);
				break;
			case "text3": //文字缩小出现(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0,
						"font-size": 0
					},
					ease: "Power1.easeIn"
				}, delay);
				break;
			case "text4": //文字渐变出现(以字为单位)
				t1.staggerFrom(svgElement.children(), duration, {
					css: {
						'opacity': 0,
						"fill": color
					},
					ease: "Power1.easeIn"
				}, delay);
				break;
		}
		return t1;
	},
	//出现/消失
	/*updata canvas*/
	getEffectAppear: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object,{visible:true}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		if (isExit == false)
			t1.to(object, 0.001, {
				alpha: 1
			});
		else
			t1.to(object, 0.001, {
				visible:false
			});
		return t1;
	},
	/*updata canvas*/
	//淡出
	getEffectFade: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;

		if (isExit == false) {
			// console.log(object,33)
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				alpha: 0,

				ease: parameter.tweenEase,
				immediateRender: false
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//updata canvas
	//飞入效果
	getEffectFly: function(parameter, object, isExit, duration, delay, repeat) {
   var self=this;
		var direction = parameter.direction; //方向(上、下、左、右、左上、左下、右上、右下)
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		var easeString = Expo.easeOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (parameter.smoothStart == 1 || parameter.smoothEnd == 1 || parameter.bounceEnd == 1) {
			if (isExit == true)
				easeString = Power4.easeOut;
			else
				easeString = Elastic.easeOut;
		}

		if (isExit == false) {
			
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visible: true
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visible: true
				}]
			});

			switch (direction) {
				case "DirectionDown":
					var y = objInfo.offsetBottom + objInfo.height;
                
					t1.from(object, duration, {
						y: y,
						
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					t1.from(object, duration, {
						x: x,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionUp":
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.from(object, duration, {
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionRight":
					var x = objInfo.offsetRight + objInfo.width;
					t1.from(object, duration, {
						x: x,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionDownLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = objInfo.offsetBottom + objInfo.height;
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionDownRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = objInfo.offsetBottom + objInfo.height;
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionUpLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				case "DirectionUpRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.from(object, duration, {
						x: x,
						y: y,
						ease: easeString,
						immediateRender: false
					});
					break;
				default:
					// console.log("getEffectFly:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					x: 0,
					y: 0,
					visibility: "hidden" //clearProps功能(对象被还原)必须隐藏对象
				}]
			});
			switch (direction) {
				case "DirectionDown":
					var y = objInfo.offsetBottom + objInfo.height;
					t1.to(object, duration, {
						y: y,
						//clearProps: "y",
						ease: easeString
					});
					break;
				case "DirectionLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					t1.to(object, duration, {
						x: x,
						//clearProps: "x",
						ease: easeString
					});
					break;
				case "DirectionUp":
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.to(object, duration, {
						y: y,
						//clearProps: "y",
						ease: easeString
					});
					break;
				case "DirectionRight":
					var x = objInfo.offsetRight + objInfo.width;
					t1.to(object, duration, {
						x: x,
						//clearProps: "x",
						ease: easeString
					});
					break;
				case "DirectionDownLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = objInfo.offsetBottom + objInfo.height;
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				case "DirectionDownRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = objInfo.offsetBottom + objInfo.height;
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				case "DirectionUpLeft":
					var x = 0 - (objInfo.offsetLeft + objInfo.width);
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				case "DirectionUpRight":
					var x = objInfo.offsetRight + objInfo.width;
					var y = 0 - (objInfo.offsetTop + objInfo.height);
					t1.to(object, duration, {
						x: x,
						y: y,
						//clearProps: "x,y",
						ease: easeString
					});
					break;
				default:
					// console.log("getEffectFly:parameter error.")
					break;
			}
		}
		return t1;
	},
	//浮入/浮出(下方)
	getEffectAscend: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
	
		if (isExit == false) {

			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			//t1.to(object, 0.001, {opacity: 0, y: 100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
			t1.from(object, duration, {
				alpha: 0,
				y: 100,
				ease: parameter.tweenEase,
				immediateRender: false
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				y: 100,
				ease: parameter.tweenEase,
				clearProps: "y"
			});
		}
		return t1;
	},
	//浮入/浮出(上方)
	getEffectDescend: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		//console.log(object,isExit)
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			//t1.to(object, 0.001, {y: -100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
			t1.from(object, duration, {
				alpha: 0,
				y: -100,
				ease: parameter.tweenEase,
				immediateRender: false
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				y: -100,
				ease: parameter.tweenEase,
				clearProps: "y"
			});
		}
		return t1;
	},
	//形状一(圆)
	getEffectCircle: function(parameter, object, isExit, duration, delay, repeat) {

		return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});;
		var result = this.getObjectInfo(object);
		var radius = Math.ceil(Math.sqrt(result.width * result.width / 4 + result.height * result.height / 4));
		switch (direction) {
			case "DirectionIn": //放大
			case "DirectionOut": //缩小
				if (isExit == false) {
					t1.to(object, duration, {
						onUpdate: updateCircleGradient
					});
				} else {
					t1.to(object, duration, {
						onUpdate: updateCircleGradient
					});
				}
				break;
			default:
				console.log("getEffectCircle:parameter error.");
				break;
		}
		return t1;

		function updateCircleGradient() {
			var progress = t1.progress();
			var len = parseInt(progress * radius);
			if (isExit == false)
				switch (direction) {
					case "DirectionIn": //DirectionIn放大
						object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,1)),to(rgba(0,0,0,0)),color-stop(10%,rgba(0,0,0,0)))");
						if (len == radius) object.css("-webkit-mask", "none");
						break;
					case "DirectionOut": //DirectionOut缩小
						object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,1)), to(rgba(0,0,0,0)), color-stop(90%, rgba(0,0,0,1)))");
						if (len == radius) object.css("-webkit-mask", "none");
						break;
				} else {
					switch (direction) {
						case "DirectionIn": //DirectionIn放大
							object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,0)),to(rgba(0,0,0,1)),color-stop(10%,rgba(0,0,0,1)))");
							if (len == radius) {
								//object.css("opacity","0");
								object.css("visibility", "hidden");
								object.css("-webkit-mask", "none");
							}
							break;
						case "DirectionOut": //DirectionOut缩小
							object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,0)), to(rgba(0,0,0,1)), color-stop(90%, rgba(0,0,0,0)))");
							if (len == radius) {
								//object.css("opacity","0");
								object.css("visibility", "hidden");
								object.css("-webkit-mask", "none");
							}
							break;
					}
				}
		}
	},
	//形状二(方框)
	getEffectBox: function(parameter, object, isExit, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);
		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		if (this.useMask == false) direction = "DirectionOut";

		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		t1.to(object, duration, {
			onUpdate: updateEffectBox
		});
		return t1;

		function updateEffectBox() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				switch (direction) {
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionOut":
						var top = objInfo.height * (0.5 - percent);
						var height = objInfo.height - top;
						var left = objInfo.width * (0.5 - percent);
						var width = objInfo.width - left;
						object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionOut":
						var top = objInfo.height * percent;
						var height = objInfo.height - top;
						var left = objInfo.width * percent;
						var width = objInfo.width - left;
						object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//形状三(菱形)
	getEffectDiamond: function(parameter, object, isExit, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		t1.to(object, duration, {
			onUpdate: updateEffectBox
		});
		return t1;

		function updateEffectBox() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				switch (direction) {
					case "DirectionOut":
						//break;
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent) + ",rgba(0,0,0,1)),color-stop(" + (percent) + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionOut":
						//break;
					case "DirectionIn":
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
						break;
					default:
						console.log("getEffectBox:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//形状四(加号)
	getEffectPlus: function(parameter, object, isExit, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectPlus
		});
		return t1;

		function updateEffectPlus() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				switch (direction) {
					case "DirectionIn":
						//break;
					case "DirectionOut":
						object.css("-webkit-mask",
							"-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))");
						break;
					default:
						console.log("getEffectPlus:parameter error.");
						break;
				}
				if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionIn":
						//break;
					case "DirectionOut":
						object.css("-webkit-mask",
							"-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (percent) + ",transparent),color-stop(" + (percent) + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (percent) + ",transparent),color-stop(" + (percent) + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))");
						break;
					default:
						console.log("getEffectPlus:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}

	},
	//百叶窗
	getEffectBlinds: function(parameter, object, isExit, duration, delay, repeat) {
		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical）
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectBlinds
		});
		return t1;

		function updateEffectBlinds() {
			var num = 6; //分成N等份
			var progress = t1.progress();
			var percent = progress / num;
			var avg = 1 / num;
			var temp = 0.01; //渐变的过渡区
			var str = "";
			if (isExit == false) {
				switch (direction) {
					case "DirectionHorizontal": //水平
						str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg + temp) + ",rgba(0,0,0,1))";
							str += ",color-stop(" + (i * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg + percent + temp) + ",rgba(0,0,0,0))";
						}
						str += ")";
						break;
					case "DirectionVertical": //垂直
						str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg + temp) + ",rgba(0,0,0,1))";
							str += ",color-stop(" + (i * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg + percent + temp) + ",rgba(0,0,0,0))";
						}
						str += ")";
						break;
					default:
						console.log("getEffectBlinds:parameter error.");
						break;
				}
				object.css("-webkit-mask", str);
				if (percent >= (avg - temp)) object.css("-webkit-mask", "none");
			} else {
				switch (direction) {
					case "DirectionHorizontal": //水平
						str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg - temp) + ",rgba(0,0,0,0))";
							str += ",color-stop(" + (i * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg - percent - temp) + ",rgba(0,0,0,1))";
						}
						str += ")";
						break;
					case "DirectionVertical": //垂直
						str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
						for (var i = 1; i < num; i++) {
							str += ",color-stop(" + (i * avg) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg - temp) + ",rgba(0,0,0,0))";
							str += ",color-stop(" + (i * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg - percent - temp) + ",rgba(0,0,0,1))";
						}
						str += ")";
						break;
					default:
						console.log("getEffectBlinds:parameter error.");
						break;
				}
				object.css("-webkit-mask", str);
				if (percent >= (avg - temp)) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//劈裂
	getEffectSplit: function(parameter, object, isExit, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		if (this.useMask == false) return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(DirectionVerticalIn、DirectionHorizontalIn、DirectionHorizontalOut、DirectionVerticalOut)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectSplit
		});
		return t1;

		function updateEffectSplit() {
			var progress = t1.progress();
			var percent = progress / 2;
			if (isExit == false) {
				if (progress > 0.9) { //跳过最后10%（解决iPad的闪问题）
					object.css("-webkit-mask", "none");
					return;
				}
				switch (direction) {
					case "DirectionVerticalIn": //左右向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionHorizontalIn": //上下向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionHorizontalOut": //中间向上下展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
						break;
					case "DirectionVerticalOut": //中间向左右展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
						break;
					default:
						console.log("getEffectSplit:parameter error.");
						break;
				}
				//if (percent >= 0.5) object.css("-webkit-mask", "none");
			} else {
				if (progress < 0.1) return; //跳过前面10%（解决iPad的闪问题）
				switch (direction) {
					case "DirectionVerticalIn": //左右向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
						break;
					case "DirectionHorizontalIn": //上下向中间收
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
						break;
					case "DirectionHorizontalOut": //中间向上下展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
						break;
					case "DirectionVerticalOut": //中间向左右展开
						object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
						break;
					default:
						console.log("getEffectSplit:parameter error.");
						break;
				}
				if (percent >= 0.5) {
					//object.css("opacity","0");
					object.css("visibility", "hidden");
					object.css("-webkit-mask", "none");
				}
			}
		}
	},
	//切入/出
	getEffectPeek: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(上下左右)
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionUp":
					t1.from(object, duration, {
						y: -objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
					});
					break;
				case "DirectionDown":
					t1.from(object, duration, {
						y: objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
					});
					break;
				case "DirectionLeft":
					t1.from(object, duration, {
						x: -objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
					});
					break;
				case "DirectionRight":
					t1.from(object, duration, {
						x: objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
					});
					break;
				default:
					console.log("getEffectPeek:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionUp":
					t1.to(object, duration, {
						y: -objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
					});
					break;
				case "DirectionDown":
					t1.to(object, duration, {
						y: objInfo.height,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
					});
					break;
				case "DirectionLeft":
					t1.to(object, duration, {
						x: -objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
					});
					break;
				case "DirectionRight":
					t1.to(object, duration, {
						x: objInfo.width,
						ease: Linear.easeNone,
						onUpdate: this.updateClipRect,
						onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
					});
					break;
				default:
					console.log("getEffectPeek:parameter error.");
					break;
			}
		}
		return t1;
	},
	//擦除
	getEffectWipe: function(parameter, object, isExit, duration, delay, repeat) {
    	return this.getEffectAppear(parameter, object, isExit, duration, delay, repeat);

		var direction = parameter.direction; //方向(上下左右)
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			//t1.to(object,duration,{onStart:this.startHandler,onStartParams:[object],onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
			/*t1.to(object, duration, {
				onUpdate: this.updateClipRect,
				onUpdateParams: [t1, object, isExit, direction, objInfo]
			});*/
           
		} else {
			//t1.to(object,duration,{onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
			t1.to(object, duration, {
				onUpdate: this.updateClipRect,
				onUpdateParams: [t1, object, isExit, direction, objInfo]
			});
		}
		return t1;
	},
	//翻转式由远及近
	getEffectGrowAndTurn: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				alpha: 0,
				scaleX: 0,
				scaleY: 0,
				rotation: Math.PI / 180 * 90,
				ease: parameter.tweenEase
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1,
					scaleX: 1,
					scaleY: 1,
					rotation: 0
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				scaleX: 0,
				scaleY: 0,
				rotation: Math.PI / 180 * 90,
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//升起/下沉
	getEffectRiseUp: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		var y = objInfo.offsetBottom + objInfo.height;
		var easeString = Back.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				alpha: 0,
				y: y,
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				y: y,
				ease: easeString
			});
		}
		return t1;
	},
	//基本缩放
	getEffectZoom: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(放大:DirectionIn、屏幕中心放大:DirectionInCenter、轻微放大:DirectionInSlightly、缩小:DirectionOut、屏幕底部缩小:DirectionOutBottom、轻微缩小:DirectionOutSlightly)
		var t1 = null;
		//object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visible: true
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionIn":
					t1.from(object, duration, {
						scaleX: 0,
						scaleY: 0,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInCenter":
					var result = this.getDirectionInCenter(object);
					t1.from(object, duration, {
						scaleX: 0,
						scaleY: 0,
						x: result.x,
						y: result.y,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInSlightly":
					t1.from(object, duration, {
						scaleX: 0.7,
						scaleY: 0.7,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOut":
					t1.from(object, duration, {
						scaleX: 3,
						scaleY: 3,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutBottom":
					//屏幕底部缩小(理解为底部的中间开始)
					t1.from(object, duration, {
						scaleX: 2,
						scaleY: 2,
						x: this.screenWidth ,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutSlightly":
					t1.from(object, duration, {
						scaleX: 1.5,
						scaleY: 1.5,
						ease: parameter.tweenEase
					});
					break;
				default:
					console.log("getEffectZoom:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: "hidden"
				}]
			});
			switch (direction) {
				case "DirectionIn":
					t1.to(object, duration, {
						scale: 0,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInCenter":
					var result = this.getDirectionInCenter(object);
					t1.to(object, duration, {
						scale: 0,
						x: result.x,
						y: result.y,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionInSlightly":
					t1.to(object, duration, {
						scale: 0.7,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOut":
					t1.to(object, duration, {
						scale: 3,
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutBottom":
					t1.to(object, duration, {
						scale: 2,
						top: this.screenHeight + "px",
						ease: parameter.tweenEase
					});
					break;
				case "DirectionOutSlightly":
					t1.to(object, duration, {
						scale: 1.5,
						ease: parameter.tweenEase
					});
					break;
				default:
					console.log("getEffectZoom:parameter error.");
					break;
			}
		}
		return t1;
	},
	//缩放 淡出式缩放
	getEffectFadedZoom: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向(对象中心DirectionIn、幻灯片中心DirectionInCenter)
		var t1 = null;
		//object.css("-webkit-transform-origin", "center"); //设置缩放基点(默认是正中心点)
		//var svgElement = object.find("svg"); //获取SVG对象
		//if (svgElement) svgElement.css('-webkit-transform', 'translate3d(0px, 0px, 0px)'); //解决SVG文字错乱问题

		var keepRatio = (parameter.keepRatio == 0) ? false : true; //保持长宽比
		var fullScreen = (parameter.fullScreen == 1) ? true : false; //缩放到全屏
		var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
		var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
		if (fullScreen == true) {
			//计算比例
			var xScale = this.canvas.width/ object.width;
			var yScale = this.canvas.height / object.height;
			var scaleValue = xScale;
			if (xScale > yScale) scaleValue = yScale;
			var result = this.getDirectionInCenter(object);
			if (isExit == false) {
				t1 = new TimelineMax({
					delay: delay,
					repeat: repeat,
					onStart: this.startHandler,
					onStartParams: [parameter, object, {
						alpha: 0,
						visible:true
					}],
					onComplete: this.completeHandler,
					onCompleteParams: [parameter, object]
				});
				t1.to(object, duration, {
					x: result.x,
					y: result.y,
					alpha: 1,
					scaleX: scaleValue,
					scaleY: scaleValue,
					ease: parameter.tweenEase
				});
			} else {
				t1 = new TimelineMax({
					delay: delay,
					repeat: repeat,
					onStart: this.startHandler,
					onStartParams: [parameter, object,{visible:true}],
					onComplete: this.completeHandler,
					onCompleteParams: [parameter, object]
				});
				t1.to(object, duration, {
					x: result.x,
					y: result.y,
					alpha: 0,
					scale: scaleValue,
					ease: parameter.tweenEase
				});
			}
		} else if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionIn":
					if (keepRatio == true)
						t1.from(object, duration, {
							alpha: 0,
							scaleX: 0,
							scaleY: 0,
							ease: parameter.tweenEase
						});
					else {
						t1.from(object, duration, {
							alpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					}
					break;
				case "DirectionInCenter":
					var result = this.getDirectionInCenter(object);
					if (keepRatio == true)
						t1.from(object, duration, {
							x: result.x,
							y: result.y,
							alpha: 0,
							scaleX: 0,
							scaleY: 0,
							ease: parameter.tweenEase
						});
					else
						t1.from(object, duration, {
							x: result.x,
							y: result.y,
							alpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					break;
				default:
					console.log("getEffectFadedZoom:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			switch (direction) {
				case "DirectionOut":
					if (keepRatio == true)
						t1.to(object, duration, {
							autoAlpha: 0,
							scale: 0,
							ease: parameter.tweenEase,
							clearProps: "scale"
						});
					else
						t1.to(object, duration, {
							autoAlpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					break;
				case "DirectionOutCenter":
					var result = this.getDirectionInCenter(object);
					if (keepRatio == true)
						t1.to(object, duration, {
							x: result.x,
							y: result.y,
							autoAlpha: 0,
							scale: 0,
							ease: parameter.tweenEase
						});
					else
						t1.to(object, duration, {
							x: result.x,
							y: result.y,
							autoAlpha: 0,
							scaleX: scaleX,
							scaleY: scaleY,
							ease: parameter.tweenEase
						});
					break;
				default:
					console.log("getEffectFadedZoom:parameter error.");
					break;
			}
		}
		return t1;
	},
	//玩具风车
	getEffectPinwheel: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				alpha: 0,
				scaleX: 0,
				scaleY: 0,
				rotation: Math.PI/180*540,
				ease: parameter.tweenEase
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1,
					scaleX: 1,
					scaleY:1,
					rotation: 0
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				scaleX: 0,
				scaleY: 0,
				rotation: Math.PI/180*540,
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//updata canvas
	//回旋
	getEffectSpinner: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Expo.easeOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visible: true
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				scaleX: 0,
				scaleY: 0,
				rotation: Math.PI/180*180,
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visible: false,
					scaleX: 1,
					scaleY: 1,
					rotation: 0
				}]
			});
			t1.to(object, duration, {
				scaleX: 0,
				scaleY: 0,
				rotation: Math.PI/180*180,
				ease: easeString
			});
		}
		return t1;
	},
	// updata canvas
	//旋转(淡出式回旋)
	getEffectFadedSwivel: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Linear.easeNone;
		var degree = Math.abs(parameter.degree) > 0 ? Number(parameter.degree) : 90;
		if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
		switch (parameter.centerPos) {
			case 1: //左上角
				//object.css("-webkit-transform-origin", "left top");
				break;
			case 2: //上边中心
			//	object.css("-webkit-transform-origin", "center top");
				break;
			case 3: //右上角
			//	object.css("-webkit-transform-origin", "right top");
				break;
			case 4: //左边中心
			//	object.css("-webkit-transform-origin", "left cneter");
				break;
			case 5: //右边中心
			//	object.css("-webkit-transform-origin", "right center");
				break;
			case 6: //左下角
				//object.css("-webkit-transform-origin", "left bottom");
				break;
			case 7: //下边中心
			//	object.css("-webkit-transform-origin", "center bottom");
				break;
			case 8: //右下角
			//	object.css("-webkit-transform-origin", "right bottom");
				break;
			case 0:
			default: //默认中心0
			//	object.css("-webkit-transform-origin", "center");
				break;
		}
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			//t1.from(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
			switch (parameter.axis) {
				case 0: //Z轴
					t1.from(object, duration, {
						alpha: 0,
						rotation:  Math.PI/180*degree,
						ease: easeString,
						immediateRender: false
					});
					break;
				case 1: //X轴
					t1.from(object, duration, {
						alpha: 0,
						rotation:  Math.PI/180*degree,
						ease: easeString,
						immediateRender: false
					});
					break;
				case 2: //Y轴
				default:
					t1.from(object, duration, {
						alpha: 0,
						rotation:  Math.PI/180*degree,
						ease: easeString,
						immediateRender: false
					});
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					opacity: 1
				}]
			});
			//t1.to(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
			switch (parameter.axis) {
				case 0: //Z轴
					t1.to(object, duration, {
						alpha: 0,
						rotation:  Math.PI/180*degree,
						ease: easeString
					});
					break;
				case 1: //X轴
					t1.to(object, duration, {
						alpha: 0,
						rotation:  Math.PI/180*degree,
						ease: easeString
					});
					break;
				case 2: //Y轴
				default:
					t1.to(object, duration, {
						alpha: 0,
						rotation:  Math.PI/180*degree,
						ease: easeString
					});
					break;
			}
		}
		return t1;
	},
	//展开/收缩
	getEffectExpand: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				alpha: 0,
				rotation: Math.PI/180*45,
				ease: parameter.tweenEase
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1,
					rotation: 0
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				rotation: Math.PI/180*45,
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//基本旋转
	getEffectSwivel: function(parameter, object, isExit, duration, delay, repeat) {
		var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical
		var t1 = null;
		var easeString = Linear.easeNone;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visibility: "visible"
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			switch (direction) {
				case "DirectionHorizontal":
					t1.from(object, duration, {
						rotationY: "480deg",
						ease: easeString
					});
					break;
				case "DirectionVertical":
					t1.from(object, duration, {
						rotationX: "480deg",
						ease: easeString
					});
					break;
				default:
					console.log("getEffectSwivel:parameter error.");
					break;
			}
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: "hidden"
				}]
			});
			switch (direction) {
				case "DirectionHorizontal":
					t1.to(object, duration, {
						rotationY: "480deg",
						ease: easeString
					});
					break;
				case "DirectionVertical":
					t1.to(object, duration, {
						rotationX: "480deg",
						ease: easeString
					});
					break;
				default:
					console.log("getEffectSwivel:parameter error.");
					break;
			}
		}
		return t1;
	},
	//浮动
	getEffectFloat: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			var x = objInfo.offsetRight + objInfo.width;
			var y = 0 - (objInfo.offsetTop + objInfo.height);
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				alpha: 0,
				rotation: Math.PI/180*45,
				x: x,
				y: y,
				ease: parameter.tweenEase
			});
		} else {
			var x = objInfo.offsetRight + objInfo.width;
			var y = 0 - (objInfo.offsetTop + objInfo.height);
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				rotation: Math.PI/180*-45,
				x: x,
				y: y,
				ease: parameter.tweenEase
			});
		}
		return t1;
	},
	//字幕式
	getEffectCredits: function(parameter, object, isExit, duration, delay, repeat) {
		var objInfo = this.getObjectInfo(object);
		var y = 0,
			top = 0;
		if (isExit == false) {
			//从下往上移
			y = 0 - (this.screenHeight + objInfo.height);
			top = objInfo.top + objInfo.offsetBottom + objInfo.height;
		} else {
			//从上往下移
			y = this.screenHeight + objInfo.height;
			top = objInfo.top - (objInfo.offsetTop + objInfo.height);
		}
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visible: true,
				x:top
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			y: y,
			ease: parameter.tweenEase
		});
		return t1;
	},
	//弹跳
	getEffectBounce: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var objInfo = this.getObjectInfo(object);
		if (isExit == false) {
			var total = duration;
			var time1 = total / 5;
			time2 = total / 10;
			time3 = total / 20;
			time4 = total / 40;
			time5 = total / 80;
			var width = 50 + 20 + 10 + 5 + 2.5 + 1 + 0.5 + 0.2 + 0.1;
			var height = this.screenHeight / 4;
			var y1 = height / 2;
			y2 = height / 4;
			y3 = height / 8;
			y4 = height / 16;
			var lastY = objInfo.offsetBottom - height + objInfo.height;

			t1.to(object, 0.01, {
				x: -width,
				y: -height
			})
				.to(object, time1, {
					x: "+=50",
					y: "+=" + height,
					ease: Circ.easeIn
				}) //慢到快
			.to(object, time1, {
				x: "+=20",
				y: "-=" + y1,
				scaleY: 0.8,
				ease: Circ.easeOut
			}) //快到慢
			.to(object, time1, {
				x: "+=10",
				y: "+=" + y1,
				scaleY: 1,
				ease: Circ.easeIn
			})
				.to(object, time2, {
					x: "+=5",
					y: "-=" + y2,
					scaleY: 0.85,
					ease: Circ.easeOut
				})
				.to(object, time2, {
					x: "+=2.5",
					y: "+=" + y2,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time3, {
					x: "+=1",
					y: "-=" + y3,
					scaleY: 0.9,
					ease: Circ.easeOut
				})
				.to(object, time3, {
					x: "+=0.5",
					y: "+=" + y3,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time4, {
					x: "+=0.2",
					y: "-=" + y4,
					scaleY: 0.95,
					ease: Circ.easeOut
				})
				.to(object, time4, {
					x: "+=0.1",
					y: "+=" + y4,
					scaleY: 1,
					ease: Circ.easeIn,
					clearProps: "x,y"
				});
			return t1;
		} else {
			var total = duration;
			var time1 = total / 5;
			time2 = total / 10;
			time3 = total / 20;
			time4 = total / 40;
			time5 = total / 80;
			var height = this.screenHeight / 4;
			var y1 = height / 2;
			y2 = height / 4;
			y3 = height / 8;
			y4 = height / 16;
			var lastY = objInfo.offsetBottom - height + objInfo.height;
			t1.to(object, time1, {
				x: "+=50",
				y: "+=" + height,
				ease: Circ.easeIn
			}) //慢到快
			.to(object, time1, {
				x: "+=20",
				y: "-=" + y1,
				scaleY: 0.8,
				ease: Circ.easeOut
			}) //快到慢
			.to(object, time1, {
				x: "+=10",
				y: "+=" + y1,
				scaleY: 1,
				ease: Circ.easeIn
			})
				.to(object, time2, {
					x: "+=5",
					y: "-=" + y2,
					scaleY: 0.85,
					ease: Circ.easeOut
				})
				.to(object, time2, {
					x: "+=2.5",
					y: "+=" + y2,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time3, {
					x: "+=1",
					y: "-=" + y3,
					scaleY: 0.9,
					ease: Circ.easeOut
				})
				.to(object, time3, {
					x: "+=0.5",
					y: "+=" + y3,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time4, {
					x: "+=0.2",
					y: "-=" + y4,
					scaleY: 0.95,
					ease: Circ.easeOut
				})
				.to(object, time4, {
					x: "+=0.1",
					y: "+=" + y4,
					scaleY: 1,
					ease: Circ.easeIn
				})
				.to(object, time5, {
					x: "+=0.1",
					y: "+=" + lastY,
					ease: Circ.easeIn
				});
		}
		return t1;
	},
	//飞旋
	getEffectBoomerang: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var time = duration / 3;
		var x=object.x,y=object.y;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.add(TweenMax.to(object, 0.01, {
				x: x+300,
				y:y-200,
				rotation: Math.PI/180*(-60)
			}), "first");
			t1.add(TweenMax.to(object, time, {
				alpha: 1,
				x: x,
				y: y,
				rotation: 0
			}), "second");
			t1.add(TweenMax.to(object, time, {
				rotation: Math.PI/180*(80)
			}), "second");
			t1.add(TweenMax.to(object, time, {
				rotation: 0
			}));
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1,
					x: x,
					y: y,
					rotation:0
				}]
			});
			t1.add(TweenMax.to(object, time, {
				rotation: Math.PI/180*(-80)
			}), "frist");
			t1.add(TweenMax.to(object, time, {
				alpha: 0,
				x: x+300,
				y: y-200,
				rotation: Math.PI/180*(-60)
			}), "second");
			t1.add(TweenMax.to(object, time, {
				rotation: 0
			}), "second");
		}
		return t1;
	},
	//中心旋转
	getEffectCenterRevolve: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Power1.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object, {
					visible: true
				}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 100
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 300
					}]
				},
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					visibility: false
				}]
			});
			t1.to(object, duration, {
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 100
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 300
					}]
				},
				ease: easeString
			});
		}
		return t1;
	},
	//螺旋飞入/出
	getEffectSpiral: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				visibility: "visible"
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var easeString = Power1.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1.from(object, duration, {
				scale: 0,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: -200
					}, {
						x: 0,
						y: -400
					}, {
						x: -500,
						y: -600
					}]
				},
				ease: easeString
			});
		} else {
			t1.to(object, duration, {
				scale: 0,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: -200
					}, {
						x: 0,
						y: -400
					}, {
						x: -500,
						y: -600
					}]
				},
				ease: easeString
			});
		}
		return t1;
	},
	//曲线向上/下
	getEffectArcUp: function(parameter, object, isExit, duration, delay, repeat) {
		var t1 = null;
		var easeString = Power1.easeInOut;
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		if (isExit == false) {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object]
			});
			t1.from(object, duration, {
				alpha: 0,
				scaleX: 2,
				scaleY: 2,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 400
					}, {
						x: -500,
						y: 600
					}]
				},
				ease: easeString
			});
		} else {
			t1 = new TimelineMax({
				delay: delay,
				repeat: repeat,
				onStart: this.startHandler,
				onStartParams: [parameter, object,{visible:true}],
				onComplete: this.completeHandler,
				onCompleteParams: [parameter, object, {
					alpha: 1, scaleX: 1,scaleY: 1
				}]
			});
			t1.to(object, duration, {
				alpha: 0,
				scaleX: 2,
					scaleY: 2,
				bezier: {
					type: "cubic",
					values: [{
						x: 0,
						y: 0
					}, {
						x: 200,
						y: 200
					}, {
						x: 0,
						y: 400
					}, {
						x: -500,
						y: 600
					}]
				},
				ease: easeString,
				clearProps: "x,y"
			});
		}
		return t1;
	},
	//脉冲
	getEffectFlashBulb: function(parameter, object, duration, delay, repeat) {
		
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object,{visible:true}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var range = (Number(parameter.range)) ? parameter.range : 0.1;
		var time = duration / 2;
		t1.to(object, time, {
			alpha: 0.5,
			scaleX: range,
			scaleY: range
		}).to(object, time, {
				alpha: 1,
				scaleX: range,
				scaleY: range
			});
		return t1;
	},
	//彩色脉冲
	getEffectFlicker: function(parameter, object, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, duration, delay, repeat)
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		//if (repeat < 2) repeat = 2; //默认三次
		var color2 = parameter.color2 ? parameter.color2 : "#fff"; //颜色
		var maxGlowSize = (parameter.maxGlowSize) ? parameter.maxGlowSize : 0.1; //光晕最大尺寸(百分比)
		var minGlowSize = (parameter.minGlowSize) ? parameter.minGlowSize : 0.05; //光晕最小尺寸(百分比)
		var size = (object.width() > object.height()) ? object.height() : object.width();
		var maxSize = maxGlowSize * size;
		var minSize = minGlowSize * size;
		var opacity = (Number(parameter.opacity)) ? parameter.opcity : 0.75; //不透明度
		var distance = (Number(parameter.distance)) ? parameter.distance * size : 0;; //距离
		var color = this.colorHexToRGB(color2, opacity);
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				//"box-shadow": "none"
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateEffectFlicker
		});
		return t1;

		function updateEffectFlicker() {
			var progress = t1.progress();
			var percent = parseInt(progress * (maxSize - minSize));
			if (progress > 0.5) percent = parseInt((1 - progress) * (maxSize - minSize));
			//object.css("box-shadow", distance + "px " + distance + "px " + minSize + "px " + (minSize + percent) + "px " + color);
			object.css("-webkit-filter", "drop-shadow(" + color + " " + distance + "px " + distance + "px " + (minSize + percent) + "px)");
		}
	},
	//跷跷板
	getEffectTeeter: function(parameter, object, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var x=object.x,y=object.y;
		var mode = parameter.mode;
		var range = (Number(parameter.range)) ? parameter.range : 0.02;
		var time = duration / 8; //计算指定动画时间内每次运动时间(总时长不变，循环除外)
		switch (parameter.mode) {
			case 1: //左右移动
				range = range * object.width;
				t1.to(object, time, {
					x: x-range
				})
					.to(object, time * 2, {
						x: x+range
					});
				//for (var i = 1; i < repeat; i++) {
					t1.to(object, time * 2, {
						x: x-range
					});
					t1.to(object, time * 2, {
						x:x+ range
					});
				//}
				t1.to(object, time, {
					x: x
				});
				break;
			case 2: //上下移动
				range = range * object.height();
				t1.to(object, time, {
					y: y-range
				})
					.to(object, time * 2, {
						y:y+ range
					});
				//for (var i = 1; i < repeat; i++) {
					t1.to(object, time * 2, {
						y: y-range
					});
					t1.to(object, time * 2, {
						y: y+range
					});
				//}
				t1.to(object, time, {
					y: y
				});
				break;
			case 3: //左右挤压
				t1.to(object, time, {
					scaleX: 1 + range
				})
					.to(object, time * 2, {
						scaleX: 1 - range
					});
				//for (var i = 1; i < repeat; i++) {
					t1.to(object, time * 2, {
						scaleX: 1 + range
					});
					t1.to(object, time * 2, {
						scaleX: 1 - range
					});
				//}
				t1.to(object, time, {
					scaleX: 1
				});
				break;
			case 4: //上下挤压
				t1.to(object, time, {
					scaleY: 1 + range
				})
					.to(object, time * 2, {
						scaleY: 1 - range
					});
				//for (var i = 1; i < repeat; i++) {
					t1.to(object, time * 2, {
						scaleY: 1 + range
					});
					t1.to(object, time * 2, {
						scaleY: 1 - range
					});
				//}
				t1.to(object, time, {
					scaleY: 1
				});
				break;
			case 0: //左右晃晃
			default:
				range = range * 100;
				t1.to(object, time, {
					rotation: Math.PI/180*range
				})
					.to(object, time * 2, {
						rotation: Math.PI/180*(-range)
					});
				//for (var i = 1; i < repeat; i++) {
					t1.to(object, time * 2, {
						rotation: Math.PI/180*(range)
					});
					t1.to(object, time * 2, {
						rotation: Math.PI/180*(-range)
					});
				//}
				t1.to(object, time, {
					rotation: 0
				});
				break;
		}
		return t1;
	},
	//陀螺旋转
	getEffectSpin: function(parameter, object, duration, delay, repeat) {
		var degree = parameter.amount ? parameter.amount : 360; //陀螺旋转角度
		if (Math.abs(parameter.degree) > 0) degree = parameter.degree;
		if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
		switch (parameter.centerPos) {
			case 1: //左上角
				//object.css("-webkit-transform-origin", "left top");
				break;
			case 2: //上边中心
				//object.css("-webkit-transform-origin", "center top");
				break;
			case 3: //右上角
				//object.css("-webkit-transform-origin", "right top");
				break;
			case 4: //左边中心
				//object.css("-webkit-transform-origin", "left cneter");
				break;
			case 5: //右边中心
				//object.css("-webkit-transform-origin", "right center");
				break;
			case 6: //左下角
				//object.css("-webkit-transform-origin", "left bottom");
				break;
			case 7: //下边中心
				//object.css("-webkit-transform-origin", "center bottom");
				break;
			case 8: //右下角
				//object.css("-webkit-transform-origin", "right bottom");
				break;
			case 0:
			default: //默认中心0
				//object.css("-webkit-transform-origin", "center");
				break;
		}

		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});

		//t1.to(object, duration, {rotation:degree+"deg",ease:parameter.tweenEase});
		switch (parameter.axis) {
			case 1: //X轴
				/*t1.to(object, duration, {
					rotationX: "+=" + degree + "deg",
					ease: parameter.tweenEase
				});*/
				t1.to(object, duration, {
					rotation:Math.PI/180*-degree ,
					ease: parameter.tweenEase
				});
				break;
			case 2: //Y轴
				/*t1.to(object, duration, {
					rotationY: "+=" + degree + "deg",
					ease: parameter.tweenEase
				});*/
				t1.to(object, duration, {
					rotation:Math.PI/180*-degree ,
					ease: parameter.tweenEase
				});
				break;
			case 0: //Z轴
			default:
			// console.log(object)
				t1.to(object, duration, {
					rotation:Math.PI/180*-degree ,
					ease: parameter.tweenEase
				});
				break;
		}
		return t1;
	},
	//放大/缩小
	getEffectGrowShrink: function(parameter, object, duration, delay, repeat) {
		var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
		var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
		var keepRatio = (parameter.keepRatio == 0) ? false : true; //保持长宽比
		var fullScreen = (parameter.fullScreen == 1) ? true : false; //缩放到全屏
		var resetSize = (parameter.resetSize == 1) ? true : false; //恢复默认尺寸
		var easeString = Linear.easeNone; //Elastic.easeOut
		if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});

		if (fullScreen == true) {
			//计算比例
			var xScale = this.screenWidth / object.width;
			var yScale = this.screenHeight / object.height;
			var scaleValue = xScale;
			if (xScale > yScale) scaleValue = yScale;
			var result = this.getDirectionInCenter(object);
			t1.to(object, duration, {
				x: result.x,
				y: result.y,
				scaleX: scaleValue,
				scaleY: scaleValue,
				ease: parameter.tweenEase
			});
		} else if (resetSize == true) {
			t1.to(object, duration, {
				scaleX: 1,
				scaleY: 1,
				ease: easeString
			});
		} else
			t1.to(object, duration, {
				scaleX: scaleX,
				scaleY: scaleY,
				ease: easeString
			});
		return t1;
	},
	//不饱和
	getEffectDesaturate: function(parameter, object, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, duration, delay, repeat)
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		var saturation = parameter.saturation ? parameter.saturation : 0.5; //饱和度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateSaturate
		});
		return t1;

		function updateSaturate() {
			var progress = t1.progress();
			var percent = (progress <= 0.5) ? progress * 2 : 1;
			var val = 1 + (saturation - 1) * percent;
			object.css("-webkit-filter", "saturate(" + val + ")");
		}
	},
	//加深
	getEffectDarken: function(parameter, object, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, duration, delay, repeat)
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		var brightness = (parameter.brightness && parameter.brightness < 1) ? brightness.saturation : 0.5; //亮度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateBrightness
		});
		return t1;

		function updateBrightness() {
			var progress = t1.progress();
			var percent = (progress <= 0.5) ? progress * 2 : 1;
			var val = 1 + (brightness - 1) * percent;
			object.css("-webkit-filter", "brightness(" + val + ")");
		}
	},
	//变淡
	getEffectLighten: function(parameter, object, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, duration, delay, repeat)
		if (!("-webkit-filter" in object[0].style)) return new TimelineMax();
		var brightness = (parameter.brightness && parameter.brightness > 1) ? parameter.brightness : 1.5; //亮度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"-webkit-filter": "none"
			}]
		});
		t1.to(object, duration, {
			onUpdate: updateBrightness
		});
		return t1;

		function updateBrightness() {
			var progress = t1.progress();
			var percent = (progress <= 0.5) ? progress * 2 : 1;
			var val = 1 + (brightness - 1) * percent;
			object.css("-webkit-filter", "brightness(" + val + ")");
		}
	},
	//透明
	getEffectTransparency: function(parameter, object, duration, delay, repeat) {
		var opacity = parameter.amount ? parameter.amount : 0.5; //透明度
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object,{visible:true}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		t1.to(object, duration, {
			alpha: opacity,
			ease: parameter.tweenEase
		});
		return t1;
	},
	//补色
	getEffectComplementaryColor: function(parameter, object, duration, delay, repeat) {
		return this.getEffectAppear(parameter, object, duration, delay, repeat)
		var zIndex = Number(object.css("z-index"));
		if (isNaN(zIndex)) {
			zIndex = 10;
			console.log("The Z-index property for this object to get error.");
		}
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object, {
				"z-Index": zIndex + 100
			}],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object, {
				"z-Index": zIndex
			}]
		});
		t1.to(object, duration, {
			autoAlpha: 1
		});
		return t1;
	},
	//闪烁(一次)
	getEffectFlashOnce: function(parameter, object, duration, delay, repeat) {
		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		var time = duration / 3;
		t1.to(object, 0.001, {
			visible:false
		}).to(object, time * 2, {}).to(object, time, {
			visible:true
		});
		return t1;
	},
	//路径动画
	getPathAnimation : function(parameter, object, duration, delay, repeat)
	{
		var t1 = new TimelineMax({repeat:repeat,onStart:this.startHandler,onStartParams:[parameter,object,null],onComplete:this.completeHandler,onCompleteParams:[parameter,object]});
		var path = (parameter.path) ? parameter.path : ""; //路径
		if(!path || path=="") return t1;

		var currentOffset = {top: object.y, left: object.x }; //对象当前位置
		//对象原点坐标（相对页面原点）
		var objInfo = {
			top: currentOffset.top,
			left: currentOffset.left,
			oX: currentOffset.left + object.width / 2, //计算object的中心点x坐标
			oY: currentOffset.top + object.height / 2 //计算object的中心点有y坐标
		};
		// console.log(111)
		//移动起点坐标（默认为对象原点0,0）
		var x0 = object.x,
			y0 = object.y;
		//对象当前坐标
		var cx = x0,
			cy = y0;

		function resetStartPoint(x, y) {
			//如果路径动画为：EffectPathStairsDown向下阶梯、EffectPathBounceLeft向左弹跳、EffectPathBounceRight 向右弹跳，则需要重置起点坐标(此问题待验证,暂取消)
			/*if (parameter.animationName == "EffectPathStairsDown" || parameter.animationName == "EffectPathBounceLeft" || parameter.animationName == "EffectPathBounceRight") {
				x0 = x;
				y0 = y;
			}*/
			//更新当前坐标
			cx = x;
			cy = y;
		}
		var isLine = (path.indexOf("C")<0 && path.indexOf("c")<0);
		var ArrPath =  path.split(' ');
		var svgPath = ''; //VML路径转SVG路径(测试)
		var quArr = [];
		for (var k = 0; k < ArrPath.length; k++) {
			var str = ArrPath[k];
			switch (str) {
				case "M": //移动（开始）
				case "m":
					var x = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
					var y = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
					/*t1.add(TweenMax.to(object, 0.001, {
						x: x,
						y: y
					}));*/
					quArr.push({
						x: x,
						y: y
					});
					k = k + 2;
					resetStartPoint(x, y);
					svgPath += 'M ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
					break;
				case "C": //曲线
				case "c":
					var x1 = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
					var y1 = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
					var x2 = x0 + Math.round(ArrPath[k + 3] * this.screenWidth);
					var y2 = y0 + Math.round(ArrPath[k + 4] * this.screenHeight);
					var x3 = x0 + Math.round(ArrPath[k + 5] * this.screenWidth);
					var y3 = y0 + Math.round(ArrPath[k + 6] * this.screenHeight);
					quArr.push({
						x: x1,
						y: y1
					}, {
						x: x2,
						y: y2
					}, {
						x: x3,
						y: y3
					});
					k = k + 6;
					resetStartPoint(x3, y3);
					svgPath += ' C ' + (objInfo.oX + x1) + ' ' + (objInfo.oY + y1) + ' ' + (objInfo.oX + x2) + ' ' + (objInfo.oY + y2) + ' ' + (objInfo.oX + x3) + ' ' + (objInfo.oY + y3);
					break;
				case "L": //直线
				case "l":
					var x = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
					var y = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
					if (x == cx && y == cy) {
						k = k + 2;
						break;
					}
					quArr.push({
						x: x,
						y: y
					});
					k = k + 2;
					resetStartPoint(x, y);
					svgPath += ' L ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
					break;
				case "Z": //闭合
					if (quArr[0].x != quArr[quArr.length - 1].x || quArr[0].y != quArr[quArr.length - 1].y) {
						quArr.push({
							x: quArr[0].x,
							y: quArr[0].y
						});
					}
					svgPath += ' Z';
					break;
				case "E": //结束
					break;
			}
		}

		if(	isLine == true)
			t1.add(TweenMax.to(object, duration, {bezier:{curviness:0, values:quArr}}));//curviness圆滑度(数字越大越圆滑),默认为1,0是直线运动
		else
			t1.add(TweenMax.to(object, duration, {bezier:{type:"soft", values:quArr}}));
		return t1;
	},
	//路径动画  没有完成 
	getPathAnimation0: function(parameter, object, duration, delay, repeat) {

		var t1 = new TimelineMax({
			delay: delay,
			repeat: repeat,
			onStart: this.startHandler,
			onStartParams: [parameter, object],
			onComplete: this.completeHandler,
			onCompleteParams: [parameter, object]
		});
		
		var path = (parameter.path) ? parameter.path : ""; //路径

		if (!path || path == "") return t1;
		var autoReverse = (parameter.autoReverse == 1) ? true : false; //自动翻转(系统自带,实为沿路径返回)
		var subRepeat = (autoReverse == true) ? 1 : 0; //如果autoReverse为真而子动画必须为1，否则默认为0
		var autoRotate = (parameter.objFollow == 1) ? true : false; //是否跟随路径旋转对象(Z轴)
		var autoTurn = (parameter.objFollow == 2) ? true : false; //反向运动时自动翻转对象(Y轴)
		//连续行为参数处理
		var axis = 0;
		var degree = 0; //旋转角度
		var scaleFactor = null; //缩放比例(未设置时必须为null才能不影响其它动画效果)
		var motionScript = ""; //连续脚本
		if (parameter.attrAlongPath) {
			axis = parameter.attrAlongPath.axis ? parameter.attrAlongPath.axis : 0;
			degree = Math.abs(parameter.attrAlongPath.degree) > 0 ? Number(parameter.attrAlongPath.degree) : 0;
			scaleFactor = (parameter.attrAlongPath.scaleFactor > 0) ? parameter.attrAlongPath.scaleFactor : null;
			motionScript = parameter.attrAlongPath.motionScript;
		}

		var currentFrame = 0; //当前帧
		var currentDegree = 0; //当前翻转角度
		var currentOffset = {top: object.y, left: object.x }; //对象当前位置
		//zhangyun, deal with canvas object
		
		var turnState = ""; //当前运动状态(左/右)
		//对象原点坐标（相对页面原点）
		var objInfo = {
			top: currentOffset.top,
			left: currentOffset.left,
			oX: currentOffset.left + object.width / 2, //计算object的中心点x坐标
			oY: currentOffset.top + object.height / 2 //计算object的中心点有y坐标
		};
		// console.log(111)
		//移动起点坐标（默认为对象原点0,0）
		var x0 = 0,
			y0 = 0;
		//对象当前坐标
		var cx = 0,
			cy = 0;

		function resetStartPoint(x, y) {
			//如果路径动画为：EffectPathStairsDown向下阶梯、EffectPathBounceLeft向左弹跳、EffectPathBounceRight 向右弹跳，则需要重置起点坐标(此问题待验证,暂取消)
			/*if (parameter.animationName == "EffectPathStairsDown" || parameter.animationName == "EffectPathBounceLeft" || parameter.animationName == "EffectPathBounceRight") {
				x0 = x;
				y0 = y;
			}*/
			//更新当前坐标
			cx = x;
			cy = y;
		}
		var isCurve = (path.indexOf("C") < 0 && path.indexOf("c") < 0); //是否为曲线路径
		var ArrPath = path.split(' ');
		var svgPath = ''; //VML路径转SVG路径(测试)
		var quArr = [];
		for (var k = 0; k < ArrPath.length; k++) {
			var str = ArrPath[k];
			switch (str) {
				case "M": //移动（开始）
				case "m":
					var x = Math.round(ArrPath[k + 1] * this.screenWidth);
					var y = Math.round(ArrPath[k + 2] * this.screenHeight);
					/*t1.add(TweenMax.to(object, 0.001, {
						x: x,
						y: y
					}));*/
					quArr.push({
						x: x,
						y: y
					});
					k = k + 2;
					resetStartPoint(x, y);
					svgPath += 'M ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
					break;
				case "C": //曲线
				case "c":
					var x1 = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
					var y1 = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
					var x2 = x0 + Math.round(ArrPath[k + 3] * this.screenWidth);
					var y2 = y0 + Math.round(ArrPath[k + 4] * this.screenHeight);
					var x3 = x0 + Math.round(ArrPath[k + 5] * this.screenWidth);
					var y3 = y0 + Math.round(ArrPath[k + 6] * this.screenHeight);
					quArr.push({
						x: x1,
						y: y1
					}, {
						x: x2,
						y: y2
					}, {
						x: x3,
						y: y3
					});
					k = k + 6;
					resetStartPoint(x3, y3);
					svgPath += ' C ' + (objInfo.oX + x1) + ' ' + (objInfo.oY + y1) + ' ' + (objInfo.oX + x2) + ' ' + (objInfo.oY + y2) + ' ' + (objInfo.oX + x3) + ' ' + (objInfo.oY + y3);
					break;
				case "L": //直线
				case "l":
					var x = x0 + Math.round(ArrPath[k + 1] * this.screenWidth);
					var y = y0 + Math.round(ArrPath[k + 2] * this.screenHeight);
					if (x == cx && y == cy) {
						k = k + 2;
						break;
					}
					quArr.push({
						x: x,
						y: y
					});
					k = k + 2;
					resetStartPoint(x, y);
					svgPath += ' L ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
					break;
				case "Z": //闭合
					if (quArr[0].x != quArr[quArr.length - 1].x || quArr[0].y != quArr[quArr.length - 1].y) {
						quArr.push({
							x: quArr[0].x,
							y: quArr[0].y
						});
					}
					svgPath += ' Z';
					break;
				case "E": //结束
					break;
			}
		}
		//启用手势
		parameter.gesture=false;
		if (parameter.gesture) {
			t1 = new TimelineMax({
				paused: true,
				useFrames: true
			});
			parameter.tweenEase = "Linear.easeNone"; //手势控制必须为匀速运动

			//创建SVG路径(用于测试)
			/*if (PptAni.isDesktop) {
				if ($("#svgPathContainer").length == 0)
					this.container.append('<div id="svgPathContainer" style="position:absolute;width:100%;height:100%;"><svg width="100%" height="100%"  xmlns="http://www.w3.org/2000/svg" version="1.1"></svg></div>');
				var svgDocument = $("#svgPathContainer").find("svg")[0];
				//创建当前路径
				var p = PptAni.makeShape("Path", {
					id: "Path_" + object[0].id,
					d: svgPath
				});
				svgDocument.appendChild(p);
			}*/

			//创建手势控制区域
			var controlId = object[0].id; //控制区ID
			if (parameter.gesture.controlType == 1) {
				if (parameter.pathContent > 0) {
					controlId = controlId.replace(/\d+$/, parameter.pathContent);
				} else {
					controlId = "Cont_" + object[0].id;
					var expandArea = 20; //最小可触摸尺寸(扩展外框)
					var rect = p.getBoundingClientRect();
					this.container.append('<div id="' + controlId + '" style="z-index:9999;position:absolute;left:' + (rect.left - expandArea) + 'px;top:' + (rect.top - expandArea) + 'px;width:' + (rect.width + expandArea * 2) + 'px;height:' + (rect.height + expandArea * 2) + 'px;"></div>');
				}
			}
			//计算路径距离
			var distance = 0;
			//distance = p.getTotalLength(); //SVG路径获取长度
			var sprotInfo = [];
			for (var k = 1; k < quArr.length; k++) {
				//获取距离
				distance += this.calculateDistance(quArr[k], quArr[k - 1]);
				sprotInfo.push({
					start: 0,
					end: distance,
					quadrant: this.calculateDirection(quArr[k], quArr[k - 1])
				});
			}
			//修改时间为帧数(距离转换为帧)
			duration = Math.floor(distance);
			//触发点列表
			var cuePoints = [];
			if (parameter.gesture.cuePoints) {
				for (var i = 0; i < parameter.gesture.cuePoints.length; i++) {
					cuePoints.push({
						cueStart: Math.floor(parameter.gesture.cuePoints[i].cueStart * duration),
						cueEnd: Math.floor(parameter.gesture.cuePoints[i].cueEnd * duration),
						valueStart: parameter.gesture.cuePoints[i].valueStart,
						valueEnd: parameter.gesture.cuePoints[i].valueEnd,
						mouseEnter: false,
						mouseLeave: false
					});
				}
			}

			//绑定手势事件
			var self = this;
			var historyPoint = null;
			var throwStart = throwEnd = {};

			function throwProps(time, dist) {
				if (time < 300) {
					var toX, deceleration = 0.0006,
						speed = Math.abs(dist) / time,
						newDist = (speed * speed) / (2 * deceleration);
					if (dist > 0) {
						toX = currentFrame + newDist;
						newTime = speed / deceleration;
						step = newDist / newTime * 10;
					} else {
						toX = currentFrame - newDist;
						newTime = speed / deceleration;
						step = newDist / newTime * 10;
					}
					var medialSpeed = newDist / newTime * 10; //平均速度
					var startSpeed = medialSpeed * 10; //开始速度
					var throwTimer = setInterval(function() {
						var newFrame = 0;
						if (dist > 0)
							newFrame = currentFrame + startSpeed;
						else
							newFrame = currentFrame - startSpeed;
						if (newFrame >= duration) newFrame = duration;
						else if (newFrame <= 0) newFrame = 0;
						t1.seek(newFrame);
						currentFrame = newFrame;
						startSpeed -= medialSpeed;
						if (startSpeed <= 0 || currentFrame <= 0 || currentFrame >= duration) clearInterval(throwTimer);
					}, 10);
				}
			}

			function startEvent(e) {
				throwStart = {
					time: Date.now(),
					frame: currentFrame
				};
				historyPoint = {
					x: (PptAni.hasTouch ? e.changedTouches[0].pageX : e.clientX),
					y: (PptAni.hasTouch ? e.changedTouches[0].pageY : e.clientY)
				};
			}

			function moveEnd(e) {
				throwEnd = {
					time: Date.now(),
					frame: currentFrame
				};
				//throwProps(throwEnd.time - throwStart.time, throwEnd.frame - throwStart.frame);
				historyPoint = null;
				//松手后行为(辅助对象ID)
				if (parameter.gesture.afterTouch > 0)
					Xut.Assist.Run(parameter.pageType, parameter.gesture.afterTouch, null);
			}

			function moveEvent(e) {
				var currentPoint = {
					x: (PptAni.hasTouch ? e.changedTouches[0].pageX : e.clientX),
					y: (PptAni.hasTouch ? e.changedTouches[0].pageY : e.clientY)
				}
				var d = self.calculateDistance(currentPoint, historyPoint); //鼠示移动距离
				var quadrant1 = 0; //对象移动方向
				for (var i = 0; i < sprotInfo.length; i++) {
					if (currentFrame <= sprotInfo[i].end) {
						quadrant1 = sprotInfo[i].quadrant;
						break;
					}
				}
				var quadrant2 = self.calculateDirection(currentPoint, historyPoint); //鼠标移动方向
				switch (quadrant1) {
					case "1":
					case "2":
						if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame + (currentPoint.x - historyPoint.x);
						else if (quadrant1 == "1" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
						else if (quadrant1 == "2" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
						break;
					case "3":
					case "4":
						if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame - (currentPoint.x - historyPoint.x);
						else if (quadrant1 == "3" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
						else if (quadrant1 == "4" && (quadrant2 == "+y" || quadrant2 == "-y"))
							currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
						break;
					case "+x":
						if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame + (currentPoint.x - historyPoint.x);
						break;
					case "-x":
						if (quadrant2 == "1" || quadrant2 == "2")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "3" || quadrant2 == "4")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "+x" || quadrant2 == "-x")
							currentFrame = currentFrame - (currentPoint.x - historyPoint.x);
						break;
					case "+y":
						if (quadrant2 == "1" || quadrant2 == "4")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "2" || quadrant2 == "3")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "+y" || quadrant2 == "-y")
							currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
						break;
					case "-y":
						if (quadrant2 == "1" || quadrant2 == "4")
							currentFrame = currentFrame + d;
						else if (quadrant2 == "2" || quadrant2 == "3")
							currentFrame = currentFrame - d;
						else if (quadrant2 == "+y" || quadrant2 == "-y")
							currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
						break;
				}
				if (currentFrame <= 0) currentFrame = 0;
				if (currentFrame >= duration) currentFrame = duration;
				t1.seek(currentFrame);
				updateTurnState();
				historyPoint = currentPoint;
				//处理触发点列表
				for (var i = 0; i < cuePoints.length; i++) {
					if (cuePoints[i].mouseEnter == false && currentFrame >= cuePoints[i].cueStart && currentFrame <= cuePoints[i].cueEnd) {
						cuePoints[i].mouseEnter = true;
						cuePoints[i].mouseLeave = false;
						if (cuePoints[i].valueStart > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueStart, null);
						break;
					} else if (cuePoints[i].mouseEnter == true && cuePoints[i].mouseLeave == false && (currentFrame < cuePoints[i].cueStart || currentFrame > cuePoints[i].cueEnd)) {
						cuePoints[i].mouseEnter = false;
						cuePoints[i].mouseLeave = true;
						if (cuePoints[i].valueEnd > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueEnd, null);
						break;
					}
				}
			}
			var objectId = object[0].id;
			if (parameter.gesture.controlType == 1) objectId = controlId;
			new PptAni.onTouchMove(parameter.pageType, controlId, objectId, startEvent, moveEvent, moveEnd);
		}
		//贝赛尔曲线参数构造
		var bezierObj = {
			type: "soft",
			values: quArr,
			autoRotate: autoRotate
		};
		if (isCurve == true) bezierObj = {
			curviness: 0, //curviness圆滑度(数字越大越圆滑),默认为1,0是直线运动
			values: quArr,
			autoRotate: autoRotate
		};
		//实例化动画参数

		if (degree == 0) {

			t1.to(object, duration, {
				scale: scaleFactor,
				bezier: bezierObj,
				repeat: subRepeat,
				yoyo: autoReverse,
				onUpdate: updateTurnState,
				ease: parameter.tweenEase
			});
		} else {
			switch (axis) {
				default:
				case 0: //Z轴
					t1.to(object, duration, {
						scale: scaleFactor,
						rotation: degree + "deg",
						bezier: bezierObj,
						repeat: subRepeat,
						yoyo: autoReverse,
						onUpdate: updateTurnState,
						ease: parameter.tweenEase
					});
					break;
				case 1: //X轴
					t1.to(object, duration, {
						scale: scaleFactor,
						rotationX: degree + "deg",
						bezier: bezierObj,
						repeat: subRepeat,
						yoyo: autoReverse,
						onUpdate: updateTurnState,
						ease: parameter.tweenEase
					});
					break;
				case 2: //Y轴
					t1.to(object, duration, {
						scale: scaleFactor,
						rotationY: degree + "deg",
						bezier: bezierObj,
						repeat: subRepeat,
						yoyo: autoReverse,
						onUpdate: updateTurnState,
						ease: parameter.tweenEase
					});
					break;
			}
		}
		//初始化定位(百分比)
		if (parameter.gesture && parameter.gesture.initPos > 0) {
			currentFrame = duration * parameter.gesture.initPos;
			t1.seek(currentFrame);
		}
		return t1;

		function updateTurnState() {
			if (autoTurn == false) return;
			var oldOffset = currentOffset;
			//zhangyun
			//currentOffset = object.offset();
			currentOffset = {top: object.y, left: object.x };
			//end
			if (turnState == "") {
				if (currentOffset.left > oldOffset.left) {
					turnState = "left";
				} else if (currentOffset.left < oldOffset.left) {
					turnState = "right";
				}
			} else {
				if (currentOffset.left > oldOffset.left) {
					if (turnState == "right") {
						if (currentDegree == 0) currentDegree = 180;
						else currentDegree = 0;
						TweenLite.set(object.children(), {
							rotationY: currentDegree
						});
						turnState = "left";
					}
				} else if (currentOffset.left < oldOffset.left) {
					if (turnState == "left") {
						if (currentDegree == 0) currentDegree = 180;
						else currentDegree = 0;
						TweenLite.set(object.children(), {
							rotationY: currentDegree
						});
						turnState = "right";
					}
				}
			}
		}
	},
	//=======================================================
	//子动画通用开始事件
	startHandler: function(parameter, object, params) {
		for (var item in params) {
			switch (item) {
				case "x":
					TweenLite.set(object, {
						x: params[item]
					});
					break;
				case "y":
					TweenLite.set(object, {
						y: params[item]
					});
					break;
				case "rotation":
					TweenLite.set(object, {
						rotation: params[item]
					});
					break;
				case "rotationX":
					TweenLite.set(object, {
						rotationX: params[item]
					});
					break;
				case "rotationY":
					TweenLite.set(object, {
						rotationY: params[item]
					});
					break;
				case "scale":
					TweenLite.set(object, {
						scale: params[item]
					});
					break;
				default:

					object[item]=params[item];
					break;
			}
		}

		//ppt动画音频
		if (parameter.videoId > 0) {
			Xut.AudioManager.contentAudio(parameter.chapterId, parameter.videoId)
		}


		var callSpiritWidget = function() {
			var pageObj = Xut.Presentation.GetPageObj(parameter.pageIndex, parameter.pageType)
			if (pageObj) {
				//启动了canvas模式
				if (pageObj.canvasRelated.enable) {
					var components, domId;
					if ((components = pageObj.baseGetComponent())) {
						components.length && components.forEach(function(componentObj) {
							domId = object.attr('id');
							if (domId == componentObj.getIdName()) {
								componentObj.play();
							}
						})
					}
					return;
				}
			}
			spiritWidget.updateAction(object.attr("id"), params);
		}


		//ppt动画扩展处理
		if (parameter.pptanimation && parameter.pptanimation.pptapi) {
			var params = parameter.pptanimation.parameters ? parameter.pptanimation.parameters : {};
			switch (parameter.pptanimation.pptapi) {
				case "bonesWidget": //骨骼动画
					bonesWidget.updateAction(object.attr("id"), params.actList);
					break;
				case "spiritWidget":
					callSpiritWidget();
					break;
			}
		}

	},
	//子动画通用结束事件
	completeHandler: function(parameter, object, params) {

		//if(parameter.pptAudio) parameter.pptAudio.end(); //声音存在延时问题，马上结束可导制无法听到声音
		for (var item in params) {
			switch (item) {
				case "x":
					TweenLite.set(object, {
						x: params[item]
					});
					break;
				case "y":
					TweenLite.set(object, {
						y: params[item]
					});
					break;
				case "rotation":
					TweenLite.set(object, {
						rotation: params[item]
					});
					break;
				case "rotationX":
					TweenLite.set(object, {
						rotationX: params[item]
					});
					break;
				case "rotationY":
					TweenLite.set(object, {
						rotationY: params[item]
					});
					break;
				case "scale":
					TweenLite.set(object, {
						scale: params[item]
					});
					break;
				default:
					object[item]=params[item];
					//object.css(item, params[item]);
					break;
			}
		}
	},
	//线性渐变效果更新(己注释)
	updateLineGradient: function(t1, object, isExit, direction) {
		var len = parseInt(t1.progress() * 100);
		if (isExit == false) {
			switch (direction) {
				case "DirectionUp":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% " + len + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionDown":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 100%, 0% " + (100 - len) + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionLeft":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, " + len + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionRight":
					object.css("-webkit-mask", "-webkit-gradient(linear,100% 0%, " + (100 - len) + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				default:
					console.log("updateLineGradient:parameter error.");
					break;
			}
			if (len == 100) object.css("-webkit-mask", "none");
		} else {
			switch (direction) {
				case "DirectionUp":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 100%, 0% " + len + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionDown":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% " + (100 - len) + "%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionLeft":
					object.css("-webkit-mask", "-webkit-gradient(linear,100% 0%, " + len + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				case "DirectionRight":
					object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, " + (100 - len) + "% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)),color-stop(0.9,rgba(0,0,0,1)))");
					break;
				default:
					console.log("updateLineGradient:parameter error.");
					break;
			}
			if (len == 100) {
				//object.css("opacity","0");
				object.css("visibility", "hidden");
				object.css("-webkit-mask", "none");
			}
		}
	},
	//rect切割效果更新
	updateClipRect: function(t1, object, isExit, direction, objInfo) {
		return;
		var progress = t1.progress();
		var len = progress;
		if (isExit == false) {
			var top = objInfo.height * (1 - len);
			var height = objInfo.height - top;
			var left = objInfo.width * (1 - len);
			var width = objInfo.width - left;
			switch (direction) {
				case "DirectionUp":
					object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
					break;
				case "DirectionDown":
					object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
					break;
				case "DirectionLeft":
					object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
					break;
				case "DirectionRight":
					object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
					break;
				default:
					console.log("updateClipRect:parameter error.");
					break;
			}
		} else {
			var top = objInfo.height * len;
			var height = objInfo.height - top;
			var left = objInfo.width * len;
			var width = objInfo.width - left;
			switch (direction) {
				case "DirectionUp":
					object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
					break;
				case "DirectionDown":
					object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
					break;
				case "DirectionLeft":
					object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
					break;
				case "DirectionRight":
					object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
					break;
				default:
					console.log("updateClipRect:parameter error.");
					break;
			}
		}
	},
	//获取对象至屏幕中心的距离
	getDirectionInCenter: function(object) {
		var objInfo = this.getObjectInfo(object);
		var x = Math.round(this.screenWidth / 2 - objInfo.offsetLeft - objInfo.width / 2);
		var y = Math.round(this.screenHeight / 2 - objInfo.offsetTop - objInfo.height / 2);
		return {
			x: x,
			y: y
		};
	},
	//获取对象相关信息
	getObjectInfo: function(object) {
		/*var width = Math.round($(object).width()); //四舍五入取整
		var height = Math.round($(object).height());
		var top =  Math.round($(object).css("top").replace("px",""));
		var left =  Math.round($(object).css("left").replace("px",""));
		var offsetTop = Math.round($(object).offset().top);
		var offsetBottom = Math.round(this.screenHeight-offsetTop-height);
		var offsetLeft = Math.round($(object).offset().left);
		var offsetRight = Math.round(this.screenWidth - offsetLeft -width);*/
		var width = object.width;
		var height = object.height;
		var top = object.y;
		var left = object.x;
		var offsetTop = object.y;

		var offsetBottom = this.canvas.height - top - height;
		//console.log(this.canvas.height,top,height,offsetBottom)
		var offsetLeft = object.x;
		var offsetRight = this.canvas.width - left - width;

		return {
			width: width,
			height: height,
			top: top,
			left: left,
			offsetTop: offsetTop,
			offsetLeft: offsetLeft,
			offsetBottom: offsetBottom,
			offsetRight: offsetRight
		};
	},
	/*getObjectInfo: function(object) {
		var width = Math.round(object.width()); //四舍五入取整
		var height = Math.round(object.height());
		var top = Math.round(object.css("top").replace("px", ""));
		var left = Math.round(object.css("left").replace("px", ""));
		var offsetTop = Math.round(object.offset().top);
		if (object.attr("offsetTop"))
			offsetTop = parseInt(object.attr("offsetTop"));
		else
			object.attr("offsetTop", offsetTop);
		var offsetBottom = Math.ceil(this.screenHeight - offsetTop - height);
		var offsetLeft = Math.round(object.offset().left);
		if (object.attr("offsetLeft"))
			offsetLeft = parseInt(object.attr("offsetLeft"));
		else
			object.attr("offsetLeft", offsetLeft);
		var offsetRight = Math.ceil(this.screenWidth - offsetLeft - width);
		return {
			width: width,
			height: height,
			top: top,
			left: left,
			offsetTop: offsetTop,
			offsetLeft: offsetLeft,
			offsetBottom: offsetBottom,
			offsetRight: offsetRight
		};
	},*/
	//JSON解析
	parseJSON: function(itemArray) {
		var anminJson;
		try {
			anminJson = JSON.parse(itemArray);
		} catch (error) {
			console.log("parseJSON:" + error);
			anminJson = (new Function("return " + itemArray))();
		}
		return anminJson;
	},
	//回车符处理
	enterReplace: function(str) {
		return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
	},
	//计算两点直线距离
	calculateDistance: function(currentPoint, historyPoint) {
		var xdiff = currentPoint.x - historyPoint.x;
		var ydiff = currentPoint.y - historyPoint.y;
		return Math.ceil(Math.pow(xdiff * xdiff + ydiff * ydiff, 0.5));
	},
	//区间计算
	calculateDirection: function(currentPoint, historyPoint) {
		var quadrant = ""; //象限
		if (currentPoint.y == historyPoint.y && currentPoint.x > historyPoint.x)
			quadrant = "+x"; //水平正方向
		else if (currentPoint.y == historyPoint.y && currentPoint.x < historyPoint.x)
			quadrant = "-x"; //水平负方向
		else if (currentPoint.x == historyPoint.x && currentPoint.y > historyPoint.y)
			quadrant = "+y"; //垂直正方向
		else if (currentPoint.x == historyPoint.x && currentPoint.y < historyPoint.y)
			quadrant = "-y"; //垂直负方向
		else if (currentPoint.x > historyPoint.x && currentPoint.y < historyPoint.y)
			quadrant = "1"; //第一象限
		else if (currentPoint.x > historyPoint.x && currentPoint.y > historyPoint.y)
			quadrant = "2"; //第二象限
		else if (currentPoint.x < historyPoint.x && currentPoint.y > historyPoint.y)
			quadrant = "3"; //第三象限
		else if (currentPoint.x < historyPoint.x && currentPoint.y < historyPoint.y)
			quadrant = "4"; //第四象限
		return quadrant;
	},
	/**
	 * 十六进制颜色转换为RGB颜色
	 * @param color 要转换的十六进制颜色
	 * @return RGB颜色
	 */
	colorHexToRGB: function(color, opacity) {
		color = color.toUpperCase();
		var regexpHex = /^#[0-9a-fA-F]{3,6}$/; //Hex
		if (regexpHex.test(color)) {
			var hexArray = new Array();
			var count = 1;
			for (var i = 1; i <= 3; i++) {
				if (color.length - 2 * i > 3 - i) {
					hexArray.push(Number("0x" + color.substring(count, count + 2)));
					count += 2;　　　　　　
				} else {
					hexArray.push(Number("0x" + color.charAt(count) + color.charAt(count)));
					count += 1;
				}
			}
			if (opacity && opacity > 0)
				return "RGBA(" + hexArray.join(",") + "," + opacity + ")";
			else
				return "RGB(" + hexArray.join(",") + ")";
		} else {
			console.error("Hex Color string(" + color + ") format conversion error.")
			return color;　　
		}
	},
	/**
	 * RGB颜色转换为十六进制颜色
	 * @param color 要转换的RGB颜色
	 * @return 十六进制颜色
	 */
	colorRGBToHex: function(color) {
		var regexpRGB = /^(rgb|RGB)\([0-9]{1,3},\s?[0-9]{1,3},\s?[0-9]{1,3}\)$/; //RGB
		if (regexpRGB.test(color)) {
			color = color.replace(/(\(|\)|rgb|RGB)*/g, "").split(",");
			var colorHex = "#";
			for (var i = 0; i < color.length; i++) {
				var hex = Number(color[i]).toString(16);
				if (hex.length == 1) hex = "0" + hex;
				colorHex += hex;
			}
			return colorHex;
		} else {
			console.error("RGB Color string(" + color + ") format conversion error.")
			return color;
		}
	}
};

/*!
 * VERSION: 0.9.5
 * DATE: 2013-10-30
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * Requires TweenLite and CSSPlugin version 1.11.0 or later (TweenMax contains both TweenLite and CSSPlugin). ThrowPropsPlugin is required for momentum-based continuation of movement after the mouse/touch is released (ThrowPropsPlugin is a membership benefit of Club GreenSock - http://www.greensock.com/club/).
 *
 * @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
(window._gsQueue||(window._gsQueue=[])).push(function(){"use strict";window._gsDefine("utils.Draggable",["events.EventDispatcher","TweenLite"],function(t,e){var i,s,r,n,a={css:{}},o={css:{}},h={css:{}},l={css:{}},u={},_=document,c=_.documentElement||{},p=[],f=function(){return!1},m=180/Math.PI,d=_.all&&!_.addEventListener,g=[],v={},y=0,T=/^(?:a|input|textarea|button|select)$/i,w=0,x=function(){for(var t=g.length;--t>-1;)g[t]()},b=function(t){g.push(t),1===g.length&&e.ticker.addEventListener("tick",x)},P=function(t){for(var i=g.length;--i>-1;)g[i]===t&&g.splice(i,1);e.to(S,0,{overwrite:"all",delay:15,onComplete:S})},S=function(){g.length||e.ticker.removeEventListener("tick",x)},C=function(t,e){var i;for(i in e)void 0===t[i]&&(t[i]=e[i]);return t},k=function(t,e){return t=t||window.event,u.pageX=t.clientX+_.body.scrollLeft+c.scrollLeft,u.pageY=t.clientY+_.body.scrollTop+c.scrollTop,e&&(t.returnValue=!1),u},R=function(t){return t?("string"==typeof t&&(t=e.selector(t)),t.length&&t!==window&&t[0]&&t[0].style&&!t.nodeType&&(t=t[0]),t===window||t.nodeType&&t.style?t:null):t},A=function(t,e){var s,r,n,a=t.style;if(void 0===a[e]){for(n=["O","Moz","ms","Ms","Webkit"],r=5,s=e.charAt(0).toUpperCase()+e.substr(1);--r>-1&&void 0===a[n[r]+s];);if(0>r)return"";i=3===r?"ms":n[r],e=i+s}return e},D=function(t,e,i){var s=t.style;void 0===s[e]&&(e=A(t,e)),null==i?s.removeProperty?s.removeProperty(e.replace(/([A-Z])/g,"-$1").toLowerCase()):s.removeAttribute(e):void 0!==s[e]&&(s[e]=i)},O=_.defaultView?_.defaultView.getComputedStyle:f,M=function(t,e,i){var s,r=(t._gsTransform||{})[e];return r||0===r?r:(t.style[e]?r=t.style[e]:(s=O(t))?(t=s.getPropertyValue(e.replace(/([A-Z])/g,"-$1").toLowerCase()),r=t||s.length?t:s[e]):t.currentStyle&&(r=t.currentStyle[e]),i?r:parseFloat(r)||0)},L=function(t,e,i){var s=t.vars,r=s[i],n=t._listeners[e];"function"==typeof r&&r.apply(s[i+"Scope"]||t,s[i+"Params"]||[t.pointerEvent]),n&&t.dispatchEvent(e)},E={x:0,y:0},I=function(t,e){var i,s,r,n,a,o,h,l,u=R(t);if(!u)return l=t.min||t.minX||t.minRotation||0,h=t.min||t.minY||0,void 0!==t.left?t:{left:l,top:h,width:(t.max||t.maxX||t.maxRotation||0)-l,height:(t.max||t.maxY||0)-h};if(i=null!=u.pageYOffset?u.pageYOffset:null!=_.scrollTop?_.scrollTop:_.body.scrollTop||c.scrollTop||0,s=null!=u.pageXOffset?u.pageXOffset:null!=_.scrollLeft?_.scrollLeft:_.body.scrollLeft||c.scrollLeft||0,u===window)return{top:i,left:s,width:c.clientWidth||u.innerWidth||_.body.clientWidth||0,height:u.innerHeight-20<c.clientHeight?c.clientHeight:u.innerHeight||_.body.clientHeight||0};if(e){for(a=u.offsetWidth,o=u.offsetHeight,h=u.offsetTop,l=u.offsetLeft;u=u.offsetParent;)h+=u.offsetTop,l+=u.offsetLeft;return{top:h,left:l,width:a,height:o}}return r=u.getBoundingClientRect(),n=u._gsTransform||E,{top:r.top-n.y+i,left:r.left-n.x+s,width:r.right-r.left,height:r.bottom-r.top}},N=_.createElement("div"),F=A(N,"transformOrigin").replace(/([A-Z])/g,"-$1").toLowerCase(),X=A(N,"transform"),U=""!==A(N,"perspective"),Y=function(t){var e=I(t,!0),i=O(t),s=F&&i?i.getPropertyValue(F):"50% 50%",r=s.split(" "),n=-1!==s.indexOf("left")?"0%":-1!==s.indexOf("right")?"100%":r[0],a=-1!==s.indexOf("top")?"0%":-1!==s.indexOf("bottom")?"100%":r[1],o=t._gsTransform||E;return("center"===a||null==a)&&(a="50%"),("center"===n||isNaN(parseFloat(n)))&&(n="50%"),e.left+=o.x+(-1!==n.indexOf("%")?e.width*parseFloat(n)/100:parseFloat(n)),e.top+=o.y+(-1!==a.indexOf("%")?e.height*parseFloat(a)/100:parseFloat(a)),e},B=function(t){return t.length&&t[0]&&(t[0].nodeType&&t[0].style&&!t.nodeType||t[0].length&&t[0][0])?!0:!1},z=function(t){var e,i,s,r=[],n=t.length;for(e=0;n>e;e++)if(i=t[e],B(i))for(s=i.length,s=0;i.length>s;s++)r.push(i[s]);else r.push(i);return r},j="ontouchstart"in c&&"orientation"in window,q=function(t){for(var e=t.split(","),i=(void 0!==N.onmspointerdown?"MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel":void 0!==N.onpointerdown?"pointerdown,pointermove,pointerup,pointercancel":t).split(","),s={},r=7;--r>-1;)s[e[r]]=i[r],s[i[r]]=e[r];return s}("touchstart,touchmove,touchend,touchcancel"),V=function(t,e,i){t.addEventListener?t.addEventListener(q[e]||e,i,!1):t.attachEvent&&t.attachEvent("on"+e,i)},W=function(t,e,i){t.removeEventListener?t.removeEventListener(q[e]||e,i):t.detachEvent&&t.detachEvent("on"+e,i)},H=function(t){s=t.touches&&t.touches.length>w,W(t.target,"touchend",H)},Q=function(t){s=t.touches&&t.touches.length>w,V(t.target,"touchend",H)},G=999999999999999,$=function(t,e,i,s,r,n){var a,o,h,l={};if(e)if(1!==r&&e instanceof Array)for(l.end=a=[],h=e.length,o=0;h>o;o++)a[o]=e[o]*r;else l.end="function"==typeof e?function(i){return e.call(t,i)*r}:e;return(i||0===i)&&(l.max=i),(s||0===s)&&(l.min=s),n&&(l.velocity=0),l},Z=function(t){var e;return t&&t.getAttribute&&"BODY"!==t.nodeName?"true"===(e=t.getAttribute("data-clickable"))||"false"!==e&&(t.onclick||T.test(t.nodeName+""))?!0:Z(t.parentNode):!1},K=function(){var t,e=_.createElement("div"),i=_.createElement("div"),s=i.style,r=_.body||N;return s.display="inline-block",s.position="relative",e.style.cssText=i.innerHTML="width:90px; height:40px; padding:10px; overflow:auto; visibility: hidden",e.appendChild(i),r.appendChild(e),n=i.offsetHeight+18>e.scrollHeight,s.width="100%",X||(s.paddingRight="500px",t=e.scrollLeft=e.scrollWidth-e.clientWidth,s.left="-90px",t=t!==e.scrollLeft),r.removeChild(e),t}(),J=function(t,i){t=R(t),i=i||{};var s,r,a,o,h,l,u=_.createElement("div"),c=u.style,p=t.firstChild,f=0,m=0,g=t.scrollTop,v=t.scrollLeft,y=0,T=0,w=0;U&&i.force3D!==!1?(h="translate3d(",l="px,0px)"):X&&(h="translate(",l="px)"),this.scrollTop=function(t,e){return arguments.length?(this.top(-t,e),void 0):-this.top()},this.scrollLeft=function(t,e){return arguments.length?(this.left(-t,e),void 0):-this.left()},this.left=function(s,r){if(!arguments.length)return-(t.scrollLeft+m);var n=t.scrollLeft-v,a=m;return(n>2||-2>n)&&!r?(v=t.scrollLeft,e.killTweensOf(this,!0,{left:1,scrollLeft:1}),this.left(-v),i.onKill&&i.onKill(),void 0):(s=-s,0>s?(m=0|s-.5,s=0):s>T?(m=0|s-T,s=T):m=0,(m||a)&&(h?this._suspendTransforms||(c[X]=h+-m+"px,"+-f+l):c.left=-m+"px",K&&m+y>=0&&(c.paddingRight=m+y+"px")),t.scrollLeft=0|s,v=t.scrollLeft,void 0)},this.top=function(s,r){if(!arguments.length)return-(t.scrollTop+f);var n=t.scrollTop-g,a=f;return(n>2||-2>n)&&!r?(g=t.scrollTop,e.killTweensOf(this,!0,{top:1,scrollTop:1}),this.top(-g),i.onKill&&i.onKill(),void 0):(s=-s,0>s?(f=0|s-.5,s=0):s>w?(f=0|s-w,s=w):f=0,(f||a)&&(h?this._suspendTransforms||(c[X]=h+-m+"px,"+-f+l):c.top=-f+"px"),t.scrollTop=0|s,g=t.scrollTop,void 0)},this.maxScrollTop=function(){return w},this.maxScrollLeft=function(){return T},this.disable=function(){for(p=u.firstChild;p;)o=p.nextSibling,t.appendChild(p),p=o;t.removeChild(u)},this.enable=function(){if(p=t.firstChild,p!==u){for(;p;)o=p.nextSibling,u.appendChild(p),p=o;t.appendChild(u),this.calibrate()}},this.calibrate=function(e){var i,o,h=t.clientWidth===s;g=t.scrollTop,v=t.scrollLeft,(!h||t.clientHeight!==r||u.offsetHeight!==a||e)&&((f||m)&&(i=this.left(),o=this.top(),this.left(-t.scrollLeft),this.top(-t.scrollTop)),(!h||e)&&(c.display="block",c.width="auto",c.paddingRight="0px",y=Math.max(0,t.scrollWidth-t.clientWidth),y&&(y+=M(t,"paddingLeft")+(n?M(t,"paddingRight"):0))),c.display="inline-block",c.position="relative",c.overflow="visible",c.width="100%",c.paddingRight=y+"px",n&&(c.paddingBottom=M(t,"paddingBottom",!0)),d&&(c.zoom="1"),s=t.clientWidth,r=t.clientHeight,T=t.scrollWidth-s,w=t.scrollHeight-r,a=u.offsetHeight,(i||o)&&(this.left(i),this.top(o)))},this.content=u,this.element=t,this._suspendTransforms=!1,this.enable()},te=function(i,n){t.call(this,i),i=R(i),r||(r=(window.GreenSockGlobals||window).com.greensock.plugins.ThrowPropsPlugin),this.vars=n=n||{},this.target=i,this.x=this.y=this.rotation=0,this.dragResistance=parseFloat(n.dragResistance)||0,this.edgeResistance=isNaN(n.edgeResistance)?1:parseFloat(n.edgeResistance)||0;var u,c,g,T,x,S,A,O,E,N,F,X,U,B,z,H,K,ee,ie,se,re,ne,ae=(n.type||(d?"top,left":"x,y")).toLowerCase(),oe=-1!==ae.indexOf("x")||-1!==ae.indexOf("y"),he=-1!==ae.indexOf("rotation"),le=oe?"x":"left",ue=oe?"y":"top",_e=-1!==ae.indexOf("x")||-1!==ae.indexOf("left")||"scroll"===ae,ce=-1!==ae.indexOf("y")||-1!==ae.indexOf("top")||"scroll"===ae,pe=this,fe=R(n.trigger||i),me={},de=function(t){if(K){var s=pe.x,r=pe.y,n=1e-6;n>s&&s>-n&&(s=0),n>r&&r>-n&&(r=0),he?(U.rotation=pe.rotation=pe.x,e.set(i,X)):u?(ce&&u.top(r),_e&&u.left(s)):oe?(ce&&(U.y=r),_e&&(U.x=s),e.set(i,X)):(ce&&(i.style.top=r+"px"),_e&&(i.style.left=s+"px")),A&&!t&&L(pe,"drag","onDrag")}K=!1},ge=function(t,e){var s;oe?(pe.y=i._gsTransform.y,pe.x=i._gsTransform.x):he?pe.x=pe.rotation=i._gsTransform.rotation:u?(pe.y=u.top(),pe.x=u.left()):(pe.y=parseInt(i.style.top,10)||0,pe.x=parseInt(i.style.left,10)||0),!ie&&!se||e||(ie&&(s=ie(pe.x),s!==pe.x&&(pe.x=s,he&&(pe.rotation=s),K=!0)),se&&(s=se(pe.y),s!==pe.y&&(pe.y=s,K=!0)),K&&de(!0)),n.onThrowUpdate&&!t&&n.onThrowUpdate.apply(n.onThrowUpdateScope||pe,n.onThrowUpdateParams||p)},ve=function(){var t,e,s,r;S=!1,u?(u.calibrate(),pe.minX=E=-u.maxScrollLeft(),pe.minY=F=-u.maxScrollTop(),pe.maxX=O=pe.maxY=N=0,S=!0):n.bounds&&(t=I(n.bounds),he?(pe.minX=E=t.left,pe.maxX=O=t.left+t.width,pe.minY=F=pe.maxY=N=0):void 0!==n.bounds.maxX||void 0!==n.bounds.maxY?(t=n.bounds,pe.minX=E=t.minX,pe.minY=F=t.minY,pe.maxX=O=t.maxX,pe.maxY=N=t.maxY):(e=I(i),pe.minX=E=(oe?0:M(i,"left"))+t.left-e.left,pe.minY=F=(oe?0:M(i,"top"))+t.top-e.top,pe.maxX=O=E+(t.width-e.width),pe.maxY=N=F+(t.height-e.height)),E>O&&(pe.minX=O,pe.maxX=O=E,E=pe.minX),F>N&&(pe.minY=N,pe.maxY=N=F,F=pe.minY),he&&(pe.minRotation=E,pe.maxRotation=O),S=!0),n.liveSnap&&(s=n.liveSnap===!0?n.snap||{}:n.liveSnap,r=s instanceof Array||"function"==typeof s,he?(ie=xe(r?s:s.rotation,E,O,1),se=null):(ie=xe(r?s:s.x||s.left||s.scrollLeft,E,O,u?-1:1),se=xe(r?s:s.y||s.top||s.scrollTop,F,N,u?-1:1)))},ye=function(t,e){var s,a,o;t&&r?(t===!0&&(s=n.snap||{},a=s instanceof Array||"function"==typeof s,t={resistance:(n.throwResistance||n.resistance||1e3)/(he?10:1)},he?t.rotation=$(pe,a?s:s.rotation,O,E,1,e):(_e&&(t[le]=$(pe,a?s:s.x||s.left||s.scrollLeft,O,E,u?-1:1,e)),ce&&(t[ue]=$(pe,a?s:s.y||s.top||s.scrollTop,N,F,u?-1:1,e)))),pe.tween=o=r.to(u||i,{throwProps:t,ease:n.ease||Power3.easeOut,onComplete:n.onThrowComplete,onCompleteParams:n.onThrowCompleteParams,onCompleteScope:n.onThrowCompleteScope||pe,onUpdate:n.fastMode?n.onThrowUpdate:ge,onUpdateParams:n.onThrowUpdateParams,onUpdateScope:n.onThrowUpdateScope||pe},isNaN(n.maxDuration)?2:n.maxDuration,isNaN(n.minDuration)?.5:n.minDuration,isNaN(n.overshootTolerance)?1-pe.edgeResistance+.2:n.overshootTolerance),n.fastMode||(u&&(u._suspendTransforms=!0),o.seek(o.duration()),ge(!0,!0),pe.endX=pe.x,pe.endY=pe.y,he&&(pe.endRotation=pe.x),o.play(0),ge(!0,!0),u&&(u._suspendTransforms=!1))):S&&pe.applyBounds()},Te=function(){var t=1-pe.edgeResistance;u?(ve(),x=u.top(),T=u.left()):(we()?(ge(!0,!0),ve()):pe.applyBounds(),he?(H=Y(i),ge(!0,!0),T=pe.x,x=pe.y=Math.atan2(H.top-g,c-H.left)*m):(x=M(i,ue),T=M(i,le))),S&&t&&(T>O?T=O+(T-O)/t:E>T&&(T=E-(E-T)/t),he||(x>N?x=N+(x-N)/t:F>x&&(x=F-(F-x)/t)))},we=function(){return pe.tween&&pe.tween.isActive()},xe=function(t,e,i,s){return"function"==typeof t?function(r){var n=pe.isDragging?1-pe.edgeResistance:1;return t.call(pe,r>i?i+(r-i)*n:e>r?e+(r-e)*n:r)*s}:t instanceof Array?function(s){for(var r,n,a=t.length,o=0,h=G;--a>-1;)r=t[a],n=r-s,0>n&&(n=-n),h>n&&r>=e&&i>=r&&(o=a,h=n);return t[o]}:isNaN(t)?function(t){return t}:function(){return t*s}},be=function(t){if(!pe.isDragging&&t){if(pe.pointerEvent=t,q[t.type]?(ne=-1!==t.type.indexOf("touch")?fe:_,V(ne,"touchend",Se),V(ne,"touchmove",Pe),V(ne,"touchcancel",Se),V(_,"touchstart",Q)):(ne=null,V(_,"mousemove",Pe),V(_,"mouseup",Se)),re=Z(t.target)&&!n.dragClickables)return V(t.target,"change",Se),void 0;d?t=k(t,!0):t.touches&&t.touches.length>w+1||(t.preventDefault(),t.preventManipulation&&t.preventManipulation()),t.changedTouches?(t=B=t.changedTouches[0],z=t.identifier):t.pointerId?z=t.pointerId:B=null,w++,b(de),pe.tween&&pe.tween.kill(),e.killTweensOf(u||i,!0,me),g=pe.pointerY=t.pageY,c=pe.pointerX=t.pageX,Te(),pe.tween=null,he||u||n.zIndexBoost===!1||(i.style.zIndex=te.zIndex++),pe.isDragging=!0,A=!(!n.onDrag&&!pe._listeners.drag),K=!1,he||D(fe,"cursor",n.cursor||"move"),L(pe,"dragstart","onDragStart")}},Pe=function(t){if(!s&&pe.isDragging){d?t=k(t,!0):(t.preventDefault(),t.preventManipulation&&t.preventManipulation()),pe.pointerEvent=t;var e,i,r,n,a,o,h=t.changedTouches,l=1-pe.dragResistance,u=1-pe.edgeResistance;if(h){if(t=h[0],t!==B&&t.identifier!==z){for(a=h.length;--a>-1&&(t=h[a]).identifier!==z;);if(0>a)return}}else if(t.pointerId&&z&&t.pointerId!==z)return;pe.pointerX=t.pageX,pe.pointerY=t.pageY,K=!0,he?(n=Math.atan2(H.top-t.pageY,t.pageX-H.left)*m,o=pe.y-n,pe.y=n,o>180?x-=360:-180>o&&(x+=360),r=T+(x-n)*l):(i=t.pageY-g,e=t.pageX-c,r=e>2||-2>e?T+e*l:T,n=i>2||-2>i?x+i*l:x),ie||se?(ie&&(r=ie(r)),se&&(n=se(n))):S&&(r>O?r=O+(r-O)*u:E>r&&(r=E+(r-E)*u),he||(n>N?n=N+(n-N)*u:F>n&&(n=F+(n-F)*u))),pe.x!==r||pe.y!==n&&!he?(pe.x=pe.endX=r,he?pe.endRotation=r:pe.y=pe.endY=n):K=!1}},Se=function(t,e){if(!t||!z||e||!t.pointerId||t.pointerId===z){var i,s,r,a,o=t;if(ne?(W(ne,"touchend",Se),W(ne,"touchmove",Pe),W(ne,"touchcancel",Se),W(_,"touchstart",Q)):(W(_,"mouseup",Se),W(_,"mousemove",Pe)),K=!1,re)return t&&W(t.target,"change",Se),L(pe,"click","onClick"),re=!1,void 0;if(P(de),he||D(fe,"cursor",n.cursor||"move"),pe.isDragging=!1,w--,t){if(d&&(t=k(t,!1)),i=t.changedTouches,i&&(t=i[0],t!==B&&t.identifier!==z)){for(a=i.length;--a>-1&&(t=i[a]).identifier!==z;);if(0>a)return}pe.pointerEvent=o,pe.pointerX=t.pageX,pe.pointerY=t.pageY,r=t.pageY-g,s=t.pageX-c}return o&&2>s&&s>-2&&2>r&&r>-2?L(pe,"click","onClick"):(ye(n.throwProps),d||!o||!n.dragClickables&&Z(o.target)||(o.preventDefault(),o.preventManipulation&&o.preventManipulation())),L(pe,"dragend","onDragEnd"),!0}};this.startDrag=be,this.endDrag=function(t){Se(t,!0)},this.applyBounds=function(t){var e,i;return t&&n.bounds!==t?(n.bounds=t,pe.update(!0)):(ge(!0),ve(),S&&(e=pe.x,i=pe.y,S&&(e>O?e=O:E>e&&(e=E),i>N?i=N:F>i&&(i=F)),(pe.x!==e||pe.y!==i)&&(pe.x=pe.endX=e,he?pe.endRotation=e:pe.y=pe.endY=i,K=!0,de())),pe)},this.update=function(t){var e=pe.x,i=pe.y;return t?pe.applyBounds():ge(!0),pe.isDragging&&(e!==pe.x||i!==pe.y&&!he)&&Te(),pe},this.enable=function(){var t;return V(fe,"mousedown",be),V(fe,"touchstart",be),he||D(fe,"cursor",n.cursor||"move"),fe.ondragstart=fe.onselectstart=f,D(fe,"userSelect","none"),D(fe,"touchCallout","none"),D(fe,"touchAction","none"),r&&r.track(u||i,oe?"x,y":he?"rotation":"top,left"),u&&u.enable(),i._gsDragID=t="d"+y++,v[t]=this,u&&(u.element._gsDragID=t),e.set(i,{x:"+=0"}),this.update(),pe},this.disable=function(){var t=this.isDragging;return he||D(fe,"cursor",null),e.killTweensOf(u||i,!0,me),fe.ondragstart=fe.onselectstart=null,D(fe,"userSelect","text"),D(fe,"touchCallout","default"),D(fe,"MSTouchAction","auto"),W(fe,"mousedown",be),W(fe,"touchstart",be),ne&&(W(ne,"touchcancel",Se),W(ne,"touchend",Se),W(ne,"touchmove",Pe)),W(_,"mouseup",Se),W(_,"mousemove",Pe),r&&r.untrack(u||i,oe?"x,y":he?"rotation":"top,left"),u&&u.disable(),P(de),delete v[i._gsDragID],this.isDragging=re=!1,t&&L(this,"dragend","onDragEnd"),pe},-1!==ae.indexOf("scroll")&&(u=this.scrollProxy=new J(i,C({onKill:function(){pe.isDragging&&Se(null)}},n)),i.style.overflowY=ce&&!j?"auto":"hidden",i.style.overflowX=_e&&!j?"auto":"hidden",i=u.content),n.force3D!==!1&&e.set(i,{force3D:!0}),he?me.rotation=1:(_e&&(me[le]=1),ce&&(me[ue]=1)),he?(X=l,U=X.css,X.overwrite=!1):oe&&(X=_e&&ce?a:_e?o:h,U=X.css,X.overwrite=!1),ee=te.get(this.target),ee&&ee.disable(),this.isDragging=!1,this.enable()},ee=te.prototype=new t;return ee.constructor=te,ee.pointerX=ee.pointerY=0,te.version="0.9.5",te.zIndex=1e3,V(_,"touchcancel",function(){}),te.create=function(t,i){"string"==typeof t&&(t=e.selector(t));for(var s=B(t)?z(t):[t],r=s.length;--r>-1;)s[r]=new te(s[r],i);return s},te.get=function(t){return v[(R(t)||{})._gsDragID]},te},!0)}),window._gsDefine&&window._gsQueue.pop()();
/**
 * dragdrop.js - Drag & Drop for Zepto/jQuery with touch and mouse events.
 *requestAnimationFrame
 * 参数说明
 * dragElement: 自动拖动对象
 * dropElement: 拖拽目标对象
 * autoReturn: 1:自动返回 0:留在原地(整型值)
 * dragCallback: 拖动对象时执行的回调方法
 * dropCallback: 结束拖动后执行的回调方法(有一个boolean参数,回调时true代表拖动到了目标对象)
 * container: 允许拖拽区域（当启用缓冲时且未设置拖拽区域即可扔出屏外）
 * throwProps:是否缓冲(默认为true,只有当autoReturn为0时生效)
 *
 **/
;
function CanvasDragDropClass(dragElement, dropElement, autoReturn, dragCallback, dropCallback, container, throwProps) {

    dragElement.visible=true
    this.dragElement = dragElement;

    this.defaultPoint = null;
    this.dropElement = dropElement;
    this.autoReturn = (autoReturn >= 1) ? true : false; //1:自动返回(true) 0:留在原地(false)
    this.dragCallback = (typeof(dragCallback) == "function") ? dragCallback : null;
    this.dropCallback = (typeof(dropCallback) == "function") ? dropCallback : null;
    this.throwProps = (throwProps == false || this.autoReturn) ? false : true;
    this.container = container;
    this.dragObject = null; //创建的拖拽对象实例
     var isInit = this.dragElement.initDragDrop
    if (isInit == null) {
        this.init();
        this.dragElement.initDragDrop= true;
    } else {
        console.log("This element has binding DragDropClass.");
    }
}
CanvasDragDropClass.prototype={
    reset:function(){
        var self = this;
        this.disable();
        if (self.defaultPoint) {
            self.dragElement.x=self.defaultPoint.x;
            self.dragElement.y= self.defaultPoint.y;
        }

    },
    disable:function(){
    this.dragElement.interactive=false;
    this.dragElement.initDragDrop=null;
    },
    destroy:function(){
    this.dragElement.interactive=false;
    this.dragElement.initDragDrop=null;
    },
    init:function(){
        var self=this;
        self.defaultPoint =null;
        this.dragElement.interactive=true;
         this.dragElement.mousedown = this.dragElement.touchstart = function(data) {
            if (self.defaultPoint == null) {
                self.defaultPoint = {
                    x: this.x,
                    y: this.y

                };
            }
            Xut.Contents.Canvas.SupportSwipe=false;
            self.data=data;
            this.alpha = 1;
            this.dragging = true;
            if (self.dragCallback) self.dragCallback();
        }
         this.dragElement.mousemove = this.dragElement.touchmove = function(data) {
            if (this.dragging) {
                var newPosition = self.data.getLocalPosition(this.parent);
                this.position.x = newPosition.x-this.width/2;
                this.position.y = newPosition.y-this.height/2;
            }
        }
        this.dragElement.mouseup= this.dragElement.touchend= this.dragElement.touchcancel=function(data) {
             this.dragging=false;
               var dropElement = self.dropElement,
                    isEnter = false; //是否进入目标
                var newPosition = self.data.getLocalPosition(this.parent);
                if (dropElement) {
                    //获取拖拽对象当前参数
                    var fromOffset = self.dragElement;
                    var fromPoint = {
                        x: fromOffset.x,
                        y: fromOffset.x,
                        w: self.dragElement.width,
                        h: self.dragElement.height
                    }
                    //获取目标对象参数
                    var toOffset = self.dropElement;
                    var toPoint = {
                        x: toOffset.x,
                        y: toOffset.x,
                        w: dropElement.width,
                        h: dropElement.height
                    };
                    //目标对象中心点
                    var targetCenter = {
                        x: toPoint.x + toPoint.w / 2,
                        y: toPoint.y + toPoint.h / 2
                    };
                    //拖拽点位于目标框中或目标中心点位于拖拽框中视为拖拽成功
                    if (newPosition.x > toPoint.x && newPosition.x < (toPoint.x + toPoint.w) && newPosition.y > toPoint.y && newPosition.y < (toPoint.y + toPoint.h)) {
                        isEnter = true;
                          this.dragElement.interactive=false;
                    } else if (targetCenter.x > fromPoint.x && targetCenter.x < (fromPoint.x + fromPoint.w) && targetCenter.x > fromPoint.y && targetCenter.y < (fromPoint.y + fromPoint.h)) {
                        isEnter = true;
                        this.dragElement.interactive=false;
                    }
                    //拖拽成功
                    if (isEnter == true) {
                       //结束后恢复层级关系
                      // self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));
                       
                        //拖拽对象与目标对象中心点差
                        var moveX = targetCenter.x - (self.defaultPoint.x + fromPoint.w / 2);
                        var moveY = targetCenter.y - (self.defaultPoint.y + fromPoint.h / 2);
                        //拖拽对象最终停放位置
                        var newLeft = self.defaultPoint.x + moveX;
                        var newTop = self.defaultPoint.y + moveY;
                        //自动拖拽到位
                        TweenLite.to(self.dragElement, 0.30, {
                                x: newLeft,
                                y: newTop,
                                ease: Expo.easeOut
                        });
                    } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
                      
                            x: self.defaultPoint.x,
                            y: self.defaultPoint.y
                        
                    });
                } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
                   
                        x: self.defaultPoint.x,
                        y: self.defaultPoint.y
                    
                });
                //调用结束事件
                if (self.dropCallback) self.dropCallback(isEnter);
        }

    }



}
function DragDropClass(dragElement, dropElement, autoReturn, dragCallback, dropCallback, container, throwProps) {

    if(!dragElement.length){
      return new CanvasDragDropClass(dragElement, dropElement, autoReturn, dragCallback, dropCallback, container, throwProps); 
    }
    if (!(this instanceof DragDropClass)) {
        return new DragDropClass(dragElement, dropElement, autoReturn, dragCallback, dropCallback, container, throwProps);
    }
    this.dragElement = dragElement;
	this.defaultPoint = null;
    this.dropElement = dropElement;
    this.autoReturn = (autoReturn >= 1) ? true : false; //1:自动返回(true) 0:留在原地(false)
    this.dragCallback = (typeof(dragCallback) == "function") ? dragCallback : null;
    this.dropCallback = (typeof(dropCallback) == "function") ? dropCallback : null;
    this.throwProps = (throwProps == false || this.autoReturn) ? false : true;
    this.container = container;
    this.dragElement.attr("data-defaultindex", this.dragElement.css("z-index"))
    //this.dragObject = null; //创建的拖拽对象实例
    
    var isInit = this.dragElement.attr("data-DragDrop");
    if (isInit == null) {
        this.init();
        this.dragElement.attr("data-DragDrop", true);
    } else {
        console.log("This element has binding DragDropClass.");
    }
}

DragDropClass.prototype = {
    //复位动画与状态
    reset: function() {
        var self = this;
        var dragObject;
        if (dragObject = this.dragObject) {
            dragObject.enable();
			if(self.defaultPoint){
				self.dragElement.css("left",self.defaultPoint.left);
				self.dragElement.css("top",self.defaultPoint.top);
			}
            /*TweenLite.to(self.dragElement, 0, {
                css: {
                    x: 0,
                    y: 0
                }
            });*/
        }
    },

    disable: function() {
        var dragObject;
        if (dragObject = this.dragObject) {
            dragObject.disable();
        }
    },

    destroy: function() {
        this.dragObject && this.dragObject.disable();
        this.dropElement = null;
        this.dragElement = null;
        this.dragObject = null;
    },

    init: function() {
        if (this.dragObject != null) return;

        var dragObject, self = this,
            defaultPoint;
        //now make both boxes draggable.
        dragObject = this.dragObject = Draggable.create(this.dragElement, {
            bounds: this.container,
            dragResistance: 0,
            edgeResistance: 0.8,
            type: "left,top", //rotation、scroll(x+y模式与PPT动画冲突)
			force3D:false, //是否启用硬件加速(left+top模式无需启用，启用后存在闪现问题)
            throwProps: this.throwProps,
            snap: {
                left: function(endValue) {
                    return endValue;
                },
                top: function(endValue) {
                    return endValue;
                }
            },
            onDragStart: function(e) {
                //获取拖拽对象原始参数
                var defaultOffset = self.dragElement.offset();
                self.defaultPoint = {
                    x: defaultOffset.left,
                    y: defaultOffset.top,
                    left: Number(self.dragElement.css("left").replace("px", "")),
                    top: Number(self.dragElement.css("top").replace("px", ""))
                };
                if (self.dragCallback) self.dragCallback();
            },
            onDragEnd: function(e) {
                var dropElement = self.dropElement,
                    isEnter = false; //是否进入目标

                if (dropElement) {
                    //获取拖拽对象当前参数
                    var fromOffset = self.dragElement.offset();
                    var fromPoint = {
                        x: fromOffset.left,
                        y: fromOffset.top,
                        w: self.dragElement.width(),
                        h: self.dragElement.height()
                    }
                    //获取目标对象参数
                    var toOffset = dropElement.offset();
                    var toPoint = {
                        x: toOffset.left,
                        y: toOffset.top,
                        w: dropElement.width(),
                        h: dropElement.height()
                    };
                    //目标对象中心点
                    var targetCenter = {
                        pointerX: toPoint.x + toPoint.w / 2,
                        pointerY: toPoint.y + toPoint.h / 2
                    };
                    //拖拽点位于目标框中或目标中心点位于拖拽框中视为拖拽成功
                    if (dragObject.pointerX > toPoint.x && dragObject.pointerX < (toPoint.x + toPoint.w) && dragObject.pointerY > toPoint.y && dragObject.pointerY < (toPoint.y + toPoint.h)) {
                        isEnter = true;
                        dragObject.disable();
                    } else if (targetCenter.pointerX > fromPoint.x && targetCenter.pointerX < (fromPoint.x + fromPoint.w) && targetCenter.pointerY > fromPoint.y && targetCenter.pointerY < (fromPoint.y + fromPoint.h)) {
                        isEnter = true;
                        dragObject.disable();
                    }
                    self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));
                    //拖拽成功
                    if (isEnter == true) {
                       //结束后恢复层级关系
                      // self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));
                       
                        //拖拽对象与目标对象中心点差
                        var moveX = targetCenter.pointerX - (self.defaultPoint.x + fromPoint.w / 2);
                        var moveY = targetCenter.pointerY - (self.defaultPoint.y + fromPoint.h / 2);
                        //拖拽对象最终停放位置
                        var newLeft = self.defaultPoint.left + moveX;
                        var newTop = self.defaultPoint.top + moveY;
                        //自动拖拽到位
                        TweenLite.to(self.dragElement, 0.30, {
                            css: {
                                left: newLeft,
                                top: newTop
                            },
                            ease: Expo.easeOut
                        });
                    } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
                        css: {
                            left: self.defaultPoint.left,
                            top: self.defaultPoint.top
                        }
                    });
                } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
                    css: {
                        left: self.defaultPoint.left,
                        top: self.defaultPoint.top
                    }
                });
                //调用结束事件
                if (self.dropCallback) self.dropCallback(isEnter);
            }
        })[0];
    }
};
// Snap.svg 0.2.0
// 
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// build: 2013-12-23
;
!function(a){var b,c,d="0.4.2",e="hasOwnProperty",f=/[\.\/]/,g="*",h=function(){},i=function(a,b){return a-b},j={n:{}},k=function(a,d){a=String(a);var e,f=c,g=Array.prototype.slice.call(arguments,2),h=k.listeners(a),j=0,l=[],m={},n=[],o=b;b=a,c=0;for(var p=0,q=h.length;q>p;p++)"zIndex"in h[p]&&(l.push(h[p].zIndex),h[p].zIndex<0&&(m[h[p].zIndex]=h[p]));for(l.sort(i);l[j]<0;)if(e=m[l[j++]],n.push(e.apply(d,g)),c)return c=f,n;for(p=0;q>p;p++)if(e=h[p],"zIndex"in e)if(e.zIndex==l[j]){if(n.push(e.apply(d,g)),c)break;do if(j++,e=m[l[j]],e&&n.push(e.apply(d,g)),c)break;while(e)}else m[e.zIndex]=e;else if(n.push(e.apply(d,g)),c)break;return c=f,b=o,n.length?n:null};k._events=j,k.listeners=function(a){var b,c,d,e,h,i,k,l,m=a.split(f),n=j,o=[n],p=[];for(e=0,h=m.length;h>e;e++){for(l=[],i=0,k=o.length;k>i;i++)for(n=o[i].n,c=[n[m[e]],n[g]],d=2;d--;)b=c[d],b&&(l.push(b),p=p.concat(b.f||[]));o=l}return p},k.on=function(a,b){if(a=String(a),"function"!=typeof b)return function(){};for(var c=a.split(f),d=j,e=0,g=c.length;g>e;e++)d=d.n,d=d.hasOwnProperty(c[e])&&d[c[e]]||(d[c[e]]={n:{}});for(d.f=d.f||[],e=0,g=d.f.length;g>e;e++)if(d.f[e]==b)return h;return d.f.push(b),function(a){+a==+a&&(b.zIndex=+a)}},k.f=function(a){var b=[].slice.call(arguments,1);return function(){k.apply(null,[a,null].concat(b).concat([].slice.call(arguments,0)))}},k.stop=function(){c=1},k.nt=function(a){return a?new RegExp("(?:\\.|\\/|^)"+a+"(?:\\.|\\/|$)").test(b):b},k.nts=function(){return b.split(f)},k.off=k.unbind=function(a,b){if(!a)return k._events=j={n:{}},void 0;var c,d,h,i,l,m,n,o=a.split(f),p=[j];for(i=0,l=o.length;l>i;i++)for(m=0;m<p.length;m+=h.length-2){if(h=[m,1],c=p[m].n,o[i]!=g)c[o[i]]&&h.push(c[o[i]]);else for(d in c)c[e](d)&&h.push(c[d]);p.splice.apply(p,h)}for(i=0,l=p.length;l>i;i++)for(c=p[i];c.n;){if(b){if(c.f){for(m=0,n=c.f.length;n>m;m++)if(c.f[m]==b){c.f.splice(m,1);break}!c.f.length&&delete c.f}for(d in c.n)if(c.n[e](d)&&c.n[d].f){var q=c.n[d].f;for(m=0,n=q.length;n>m;m++)if(q[m]==b){q.splice(m,1);break}!q.length&&delete c.n[d].f}}else{delete c.f;for(d in c.n)c.n[e](d)&&c.n[d].f&&delete c.n[d].f}c=c.n}},k.once=function(a,b){var c=function(){return k.unbind(a,c),b.apply(this,arguments)};return k.on(a,c)},k.version=d,k.toString=function(){return"You are running Eve "+d},"undefined"!=typeof module&&module.exports?module.exports=k:"undefined"!=typeof define?define("eve",[],function(){return k}):a.eve=k}(this),function(a,b){"function"==typeof define&&define.amd?define(["eve"],function(c){return b(a,c)}):b(a,a.eve)}(this,function(a,b){var c=function(b){var c={},d=a.requestAnimationFrame||a.webkitRequestAnimationFrame||a.mozRequestAnimationFrame||a.oRequestAnimationFrame||a.msRequestAnimationFrame||function(a){setTimeout(a,16)},e=Array.isArray||function(a){return a instanceof Array||"[object Array]"==Object.prototype.toString.call(a)},f=0,g="M"+(+new Date).toString(36),h=function(){return g+(f++).toString(36)},i=Date.now||function(){return+new Date},j=function(a){var b=this;if(null==a)return b.s;var c=b.s-a;b.b+=b.dur*c,b.B+=b.dur*c,b.s=a},k=function(a){var b=this;return null==a?b.spd:(b.spd=a,void 0)},l=function(a){var b=this;return null==a?b.dur:(b.s=b.s*a/b.dur,b.dur=a,void 0)},m=function(){var a=this;delete c[a.id],b("mina.stop."+a.id,a)},n=function(){var a=this;a.pdif||(delete c[a.id],a.pdif=a.get()-a.b)},o=function(){var a=this;a.pdif&&(a.b=a.get()-a.pdif,delete a.pdif,c[a.id]=a)},p=function(){var a=0;for(var f in c)if(c.hasOwnProperty(f)){var g,h=c[f],i=h.get();if(a++,h.s=(i-h.b)/(h.dur/h.spd),h.s>=1&&(delete c[f],h.s=1,a--,function(a){setTimeout(function(){b("mina.finish."+a.id,a)})}(h)),e(h.start)){g=[];for(var j=0,k=h.start.length;k>j;j++)g[j]=+h.start[j]+(h.end[j]-h.start[j])*h.easing(h.s)}else g=+h.start+(h.end-h.start)*h.easing(h.s);h.set(g)}a&&d(p)},q=function(a,b,e,f,g,i,r){var s={id:h(),start:a,end:b,b:e,s:0,dur:f-e,spd:1,get:g,set:i,easing:r||q.linear,status:j,speed:k,duration:l,stop:m,pause:n,resume:o};c[s.id]=s;var t,u=0;for(t in c)if(c.hasOwnProperty(t)&&(u++,2==u))break;return 1==u&&d(p),s};return q.time=i,q.getById=function(a){return c[a]||null},q.linear=function(a){return a},q.easeout=function(a){return Math.pow(a,1.7)},q.easein=function(a){return Math.pow(a,.48)},q.easeinout=function(a){if(1==a)return 1;if(0==a)return 0;var b=.48-a/1.04,c=Math.sqrt(.1734+b*b),d=c-b,e=Math.pow(Math.abs(d),1/3)*(0>d?-1:1),f=-c-b,g=Math.pow(Math.abs(f),1/3)*(0>f?-1:1),h=e+g+.5;return 3*(1-h)*h*h+h*h*h},q.backin=function(a){if(1==a)return 1;var b=1.70158;return a*a*((b+1)*a-b)},q.backout=function(a){if(0==a)return 0;a-=1;var b=1.70158;return a*a*((b+1)*a+b)+1},q.elastic=function(a){return a==!!a?a:Math.pow(2,-10*a)*Math.sin((a-.075)*2*Math.PI/.3)+1},q.bounce=function(a){var b,c=7.5625,d=2.75;return 1/d>a?b=c*a*a:2/d>a?(a-=1.5/d,b=c*a*a+.75):2.5/d>a?(a-=2.25/d,b=c*a*a+.9375):(a-=2.625/d,b=c*a*a+.984375),b},a.mina=q,q}("undefined"==typeof b?function(){}:b),d=function(){function d(a,b){if(a){if(a.tagName)return z(a);if(a instanceof u)return a;if(null==b)return a=I.doc.querySelector(a),z(a)}return a=null==a?"100%":a,b=null==b?"100%":b,new y(a,b)}function e(a,b){if(b){if("string"==typeof a&&(a=e(a)),"string"==typeof b)return"xlink:"==b.substring(0,6)?a.getAttributeNS(fb,b.substring(6)):"xml:"==b.substring(0,4)?a.getAttributeNS(gb,b.substring(4)):a.getAttribute(b);for(var c in b)if(b[J](c)){var d=K(b[c]);d?"xlink:"==c.substring(0,6)?a.setAttributeNS(fb,c.substring(6),d):"xml:"==c.substring(0,4)?a.setAttributeNS(gb,c.substring(4),d):a.setAttribute(c,d):a.removeAttribute(c)}}else a=I.doc.createElementNS(gb,a);return a}function f(a,b){return b=K.prototype.toLowerCase.call(b),"finite"==b?isFinite(a):"array"==b&&(a instanceof Array||Array.isArray&&Array.isArray(a))?!0:"null"==b&&null===a||b==typeof a&&null!==a||"object"==b&&a===Object(a)||U.call(a).slice(8,-1).toLowerCase()==b}function h(a){if("function"==typeof a||Object(a)!==a)return a;var b=new a.constructor;for(var c in a)a[J](c)&&(b[c]=h(a[c]));return b}function i(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return a.push(a.splice(c,1)[0])}function j(a,b,c){function d(){var e=Array.prototype.slice.call(arguments,0),f=e.join("␀"),g=d.cache=d.cache||{},h=d.count=d.count||[];return g[J](f)?(i(h,f),c?c(g[f]):g[f]):(h.length>=1e3&&delete g[h.shift()],h.push(f),g[f]=a.apply(b,e),c?c(g[f]):g[f])}return d}function k(a,b,c,d,e,f){if(null==e){var g=a-c,h=b-d;return g||h?(180+180*N.atan2(-h,-g)/R+360)%360:0}return k(a,b,e,f)-k(c,d,e,f)}function l(a){return a%360*R/180}function m(a){return 180*a/R%360}function n(a,b,c,d,e,f){return null==b&&"[object SVGMatrix]"==U.call(a)?(this.a=a.a,this.b=a.b,this.c=a.c,this.d=a.d,this.e=a.e,this.f=a.f,void 0):(null!=a?(this.a=+a,this.b=+b,this.c=+c,this.d=+d,this.e=+e,this.f=+f):(this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0),void 0)}function o(a){var b=[];return a=a.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g,function(a,c,d){return d=d.split(/\s*,\s*|\s+/),"rotate"==c&&1==d.length&&d.push(0,0),"scale"==c&&(2==d.length&&d.push(0,0),1==d.length&&d.push(d[0],0,0)),"skewX"==c?b.push(["m",1,0,N.tan(l(d[0])),1,0,0]):"skewY"==c?b.push(["m",1,N.tan(l(d[0])),0,1,0,0]):b.push([c.charAt(0)].concat(d)),a}),b}function p(a,b){var c=qb(a),d=new n;if(c)for(var e=0,f=c.length;f>e;e++){var g,h,i,j,k,l=c[e],m=l.length,o=K(l[0]).toLowerCase(),p=l[0]!=o,q=p?d.invert():0;"t"==o&&2==m?d.translate(l[1],0):"t"==o&&3==m?p?(g=q.x(0,0),h=q.y(0,0),i=q.x(l[1],l[2]),j=q.y(l[1],l[2]),d.translate(i-g,j-h)):d.translate(l[1],l[2]):"r"==o?2==m?(k=k||b,d.rotate(l[1],k.x+k.width/2,k.y+k.height/2)):4==m&&(p?(i=q.x(l[2],l[3]),j=q.y(l[2],l[3]),d.rotate(l[1],i,j)):d.rotate(l[1],l[2],l[3])):"s"==o?2==m||3==m?(k=k||b,d.scale(l[1],l[m-1],k.x+k.width/2,k.y+k.height/2)):4==m?p?(i=q.x(l[2],l[3]),j=q.y(l[2],l[3]),d.scale(l[1],l[1],i,j)):d.scale(l[1],l[1],l[2],l[3]):5==m&&(p?(i=q.x(l[3],l[4]),j=q.y(l[3],l[4]),d.scale(l[1],l[2],i,j)):d.scale(l[1],l[2],l[3],l[4])):"m"==o&&7==m&&d.add(l[1],l[2],l[3],l[4],l[5],l[6])}return d}function q(a,b){if(null==b){var c=!0;if(b="linearGradient"==a.type||"radialGradient"==a.type?a.node.getAttribute("gradientTransform"):"pattern"==a.type?a.node.getAttribute("patternTransform"):a.node.getAttribute("transform"),!b)return new n;b=o(b)}else b=d._.rgTransform.test(b)?K(b).replace(/\.{3}|\u2026/g,a._.transform||S):o(b),f(b,"array")&&(b=d.path?d.path.toString.call(b):K(b)),a._.transform=b;var e=p(b,a.getBBox(1));return c?e:(a.matrix=e,void 0)}function r(a){var b=d._.someDefs;if(b&&rb(b.ownerDocument.documentElement,b))return b;var c=a.node.ownerSVGElement&&z(a.node.ownerSVGElement)||a.node.parentNode&&z(a.node.parentNode)||d.select("svg")||d(0,0),e=c.select("defs"),f=null==e?!1:e.node;return f||(f=x("defs",c.node).node),d._.someDefs=f,f}function s(a,b,c){function d(a){return null==a?S:a==+a?a:(e(j,{width:a}),j.getBBox().width)}function f(a){return null==a?S:a==+a?a:(e(j,{height:a}),j.getBBox().height)}function g(d,e){null==b?i[d]=e(a.attr(d)):d==b&&(i=e(null==c?a.attr(d):c))}var h=r(a),i={},j=h.querySelector(".svg---mgr");switch(j||(j=e("rect"),e(j,{width:10,height:10,"class":"svg---mgr"}),h.appendChild(j)),a.type){case"rect":g("rx",d),g("ry",f);case"image":g("width",d),g("height",f);case"text":g("x",d),g("y",f);break;case"circle":g("cx",d),g("cy",f),g("r",d);break;case"ellipse":g("cx",d),g("cy",f),g("rx",d),g("ry",f);break;case"line":g("x1",d),g("x2",d),g("y1",f),g("y2",f);break;case"marker":g("refX",d),g("markerWidth",d),g("refY",f),g("markerHeight",f);break;case"radialGradient":g("fx",d),g("fy",f);break;case"tspan":g("dx",d),g("dy",f);break;default:g(b,d)}return i}function t(a){f(a,"array")||(a=Array.prototype.slice.call(arguments,0));for(var b=0,c=0,d=this.node;this[b];)delete this[b++];for(b=0;b<a.length;b++)"set"==a[b].type?a[b].forEach(function(a){d.appendChild(a.node)}):d.appendChild(a[b].node);var e=d.childNodes;for(b=0;b<e.length;b++)this[c++]=z(e[b]);return this}function u(a){if(a.snap in hb)return hb[a.snap];var b,c=this.id=eb();try{b=a.ownerSVGElement}catch(d){}if(this.node=a,b&&(this.paper=new y(b)),this.type=a.tagName,this.anims={},this._={transform:[]},a.snap=c,hb[c]=this,"g"==this.type){this.add=t;for(var e in y.prototype)y.prototype[J](e)&&(this[e]=y.prototype[e])}}function v(a){for(var b,c=0,d=a.length;d>c;c++)if(b=b||a[c])return b}function w(a){this.node=a}function x(a,b){var c=e(a);b.appendChild(c);var d=z(c);return d.type=a,d}function y(a,b){var c,d,f,g=y.prototype;if(a&&"svg"==a.tagName){if(a.snap in hb)return hb[a.snap];c=new u(a),d=a.getElementsByTagName("desc")[0],f=a.getElementsByTagName("defs")[0],d||(d=e("desc"),d.appendChild(I.doc.createTextNode("Created with Snap")),c.node.appendChild(d)),f||(f=e("defs"),c.node.appendChild(f)),c.defs=f;for(var h in g)g[J](h)&&(c[h]=g[h]);c.paper=c.root=c}else c=x("svg",I.doc.body),e(c.node,{height:b,version:1.1,width:a,xmlns:gb});return c}function z(a){return a?a instanceof u||a instanceof w?a:"svg"==a.tagName?new y(a):new u(a):a}function A(){return this.selectAll("stop")}function B(a,b){var c=e("stop"),f={offset:+b+"%"};return a=d.color(a),f["stop-color"]=a.hex,a.opacity<1&&(f["stop-opacity"]=a.opacity),e(c,f),this.node.appendChild(c),this}function C(){if("linearGradient"==this.type){var a=e(this.node,"x1")||0,b=e(this.node,"x2")||1,c=e(this.node,"y1")||0,f=e(this.node,"y2")||0;return d._.box(a,c,N.abs(b-a),N.abs(f-c))}var g=this.node.cx||.5,h=this.node.cy||.5,i=this.node.r||0;return d._.box(g-i,h-i,2*i,2*i)}function D(a,c){function d(a,b){for(var c=(b-j)/(a-k),d=k;a>d;d++)h[d].offset=+(+j+c*(d-k)).toFixed(2);k=a,j=b}var f,g=v(b("snap.util.grad.parse",null,c));if(!g)return null;g.params.unshift(a),f="l"==g.type.toLowerCase()?E.apply(0,g.params):F.apply(0,g.params),g.type!=g.type.toLowerCase()&&e(f.node,{gradientUnits:"userSpaceOnUse"});var h=g.stops,i=h.length,j=0,k=0;i--;for(var l=0;i>l;l++)"offset"in h[l]&&d(l,h[l].offset);for(h[i].offset=h[i].offset||100,d(i,h[i].offset),l=0;i>=l;l++){var m=h[l];f.addStop(m.color,m.offset)}return f}function E(a,b,c,d,f){var g=x("linearGradient",a);return g.stops=A,g.addStop=B,g.getBBox=C,null!=b&&e(g.node,{x1:b,y1:c,x2:d,y2:f}),g}function F(a,b,c,d,f,g){var h=x("radialGradient",a);return h.stops=A,h.addStop=B,h.getBBox=C,null!=b&&e(h.node,{cx:b,cy:c,r:d}),null!=f&&null!=g&&e(h.node,{fx:f,fy:g}),h}function G(a){return function(c){if(b.stop(),c instanceof w&&1==c.node.childNodes.length&&("radialGradient"==c.node.firstChild.tagName||"linearGradient"==c.node.firstChild.tagName||"pattern"==c.node.firstChild.tagName)&&(c=c.node.firstChild,r(this).appendChild(c),c=z(c)),c instanceof u)if("radialGradient"==c.type||"linearGradient"==c.type||"pattern"==c.type){c.node.id||e(c.node,{id:c.id});var f=ib(c.node.id)}else f=c.attr(a);else if(f=d.color(c),f.error){var g=D(r(this),c);g?(g.node.id||e(g.node,{id:g.id}),f=ib(g.node.id)):f=c}else f=K(f);var h={};h[a]=f,e(this.node,h),this.node.style[a]=S}}function H(a){for(var b=[],c=a.childNodes,d=0,e=c.length;e>d;d++){var f=c[d];3==f.nodeType&&b.push(f.nodeValue),"tspan"==f.tagName&&(1==f.childNodes.length&&3==f.firstChild.nodeType?b.push(f.firstChild.nodeValue):b.push(H(f)))}return b}d.version="0.2.0",d.toString=function(){return"Snap v"+this.version},d._={};var I={win:a,doc:a.document};d._.glob=I;var J="hasOwnProperty",K=String,L=parseFloat,M=parseInt,N=Math,O=N.max,P=N.min,Q=N.abs,R=(N.pow,N.PI),S=(N.round,""),T=" ",U=Object.prototype.toString,V=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,W=/^url\(#?([^)]+)\)$/,X="	\n\f\r   ᠎             　\u2028\u2029",Y=new RegExp("[,"+X+"]+"),Z=(new RegExp("["+X+"]","g"),new RegExp("["+X+"]*,["+X+"]*")),$={hs:1,rg:1},_=new RegExp("([a-z])["+X+",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?["+X+"]*,?["+X+"]*)+)","ig"),ab=new RegExp("([rstm])["+X+",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?["+X+"]*,?["+X+"]*)+)","ig"),bb=new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)["+X+"]*,?["+X+"]*","ig"),cb=0,db="S"+(+new Date).toString(36),eb=function(){return db+(cb++).toString(36)},fb="http://www.w3.org/1999/xlink",gb="http://www.w3.org/2000/svg",hb={},ib=d.url=function(a){return"url('#"+a+"')"};d._.$=e,d._.id=eb,d.format=function(){var a=/\{([^\}]+)\}/g,b=/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,c=function(a,c,d){var e=d;return c.replace(b,function(a,b,c,d,f){b=b||d,e&&(b in e&&(e=e[b]),"function"==typeof e&&f&&(e=e()))}),e=(null==e||e==d?a:e)+""};return function(b,d){return K(b).replace(a,function(a,b){return c(a,b,d)})}}();var jb=function(){function a(){this.parentNode.removeChild(this)}return function(b,c){var d=I.doc.createElement("img"),e=I.doc.body;d.style.cssText="position:absolute;left:-9999em;top:-9999em",d.onload=function(){c.call(d),d.onload=d.onerror=null,e.removeChild(d)},d.onerror=a,e.appendChild(d),d.src=b}}();d._.clone=h,d._.cacher=j,d.rad=l,d.deg=m,d.angle=k,d.is=f,d.snapTo=function(a,b,c){if(c=f(c,"finite")?c:10,f(a,"array")){for(var d=a.length;d--;)if(Q(a[d]-b)<=c)return a[d]}else{a=+a;var e=b%a;if(c>e)return b-e;if(e>a-c)return b-e+a}return b},function(a){function b(a){return a[0]*a[0]+a[1]*a[1]}function c(a){var c=N.sqrt(b(a));a[0]&&(a[0]/=c),a[1]&&(a[1]/=c)}a.add=function(a,b,c,d,e,f){var g,h,i,j,k=[[],[],[]],l=[[this.a,this.c,this.e],[this.b,this.d,this.f],[0,0,1]],m=[[a,c,e],[b,d,f],[0,0,1]];for(a&&a instanceof n&&(m=[[a.a,a.c,a.e],[a.b,a.d,a.f],[0,0,1]]),g=0;3>g;g++)for(h=0;3>h;h++){for(j=0,i=0;3>i;i++)j+=l[g][i]*m[i][h];k[g][h]=j}return this.a=k[0][0],this.b=k[1][0],this.c=k[0][1],this.d=k[1][1],this.e=k[0][2],this.f=k[1][2],this},a.invert=function(){var a=this,b=a.a*a.d-a.b*a.c;return new n(a.d/b,-a.b/b,-a.c/b,a.a/b,(a.c*a.f-a.d*a.e)/b,(a.b*a.e-a.a*a.f)/b)},a.clone=function(){return new n(this.a,this.b,this.c,this.d,this.e,this.f)},a.translate=function(a,b){return this.add(1,0,0,1,a,b)},a.scale=function(a,b,c,d){return null==b&&(b=a),(c||d)&&this.add(1,0,0,1,c,d),this.add(a,0,0,b,0,0),(c||d)&&this.add(1,0,0,1,-c,-d),this},a.rotate=function(a,b,c){a=l(a),b=b||0,c=c||0;var d=+N.cos(a).toFixed(9),e=+N.sin(a).toFixed(9);return this.add(d,e,-e,d,b,c),this.add(1,0,0,1,-b,-c)},a.x=function(a,b){return a*this.a+b*this.c+this.e},a.y=function(a,b){return a*this.b+b*this.d+this.f},a.get=function(a){return+this[K.fromCharCode(97+a)].toFixed(4)},a.toString=function(){return"matrix("+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)].join()+")"},a.offset=function(){return[this.e.toFixed(4),this.f.toFixed(4)]},a.split=function(){var a={};a.dx=this.e,a.dy=this.f;var d=[[this.a,this.c],[this.b,this.d]];a.scalex=N.sqrt(b(d[0])),c(d[0]),a.shear=d[0][0]*d[1][0]+d[0][1]*d[1][1],d[1]=[d[1][0]-d[0][0]*a.shear,d[1][1]-d[0][1]*a.shear],a.scaley=N.sqrt(b(d[1])),c(d[1]),a.shear/=a.scaley;var e=-d[0][1],f=d[1][1];return 0>f?(a.rotate=m(N.acos(f)),0>e&&(a.rotate=360-a.rotate)):a.rotate=m(N.asin(e)),a.isSimple=!(+a.shear.toFixed(9)||a.scalex.toFixed(9)!=a.scaley.toFixed(9)&&a.rotate),a.isSuperSimple=!+a.shear.toFixed(9)&&a.scalex.toFixed(9)==a.scaley.toFixed(9)&&!a.rotate,a.noRotation=!+a.shear.toFixed(9)&&!a.rotate,a},a.toTransformString=function(a){var b=a||this.split();return b.isSimple?(b.scalex=+b.scalex.toFixed(4),b.scaley=+b.scaley.toFixed(4),b.rotate=+b.rotate.toFixed(4),(b.dx||b.dy?"t"+[+b.dx.toFixed(4),+b.dy.toFixed(4)]:S)+(1!=b.scalex||1!=b.scaley?"s"+[b.scalex,b.scaley,0,0]:S)+(b.rotate?"r"+[+b.rotate.toFixed(4),0,0]:S)):"m"+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)]}}(n.prototype),d.Matrix=n,d.getRGB=j(function(a){if(!a||(a=K(a)).indexOf("-")+1)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:nb};if("none"==a)return{r:-1,g:-1,b:-1,hex:"none",toString:nb};if(!($[J](a.toLowerCase().substring(0,2))||"#"==a.charAt())&&(a=kb(a)),!a)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:nb};var b,c,e,g,h,i,j=a.match(V);return j?(j[2]&&(e=M(j[2].substring(5),16),c=M(j[2].substring(3,5),16),b=M(j[2].substring(1,3),16)),j[3]&&(e=M((h=j[3].charAt(3))+h,16),c=M((h=j[3].charAt(2))+h,16),b=M((h=j[3].charAt(1))+h,16)),j[4]&&(i=j[4].split(Z),b=L(i[0]),"%"==i[0].slice(-1)&&(b*=2.55),c=L(i[1]),"%"==i[1].slice(-1)&&(c*=2.55),e=L(i[2]),"%"==i[2].slice(-1)&&(e*=2.55),"rgba"==j[1].toLowerCase().slice(0,4)&&(g=L(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100)),j[5]?(i=j[5].split(Z),b=L(i[0]),"%"==i[0].slice(-1)&&(b/=100),c=L(i[1]),"%"==i[1].slice(-1)&&(c/=100),e=L(i[2]),"%"==i[2].slice(-1)&&(e/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsba"==j[1].toLowerCase().slice(0,4)&&(g=L(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),d.hsb2rgb(b,c,e,g)):j[6]?(i=j[6].split(Z),b=L(i[0]),"%"==i[0].slice(-1)&&(b/=100),c=L(i[1]),"%"==i[1].slice(-1)&&(c/=100),e=L(i[2]),"%"==i[2].slice(-1)&&(e/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsla"==j[1].toLowerCase().slice(0,4)&&(g=L(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),d.hsl2rgb(b,c,e,g)):(b=P(N.round(b),255),c=P(N.round(c),255),e=P(N.round(e),255),g=P(O(g,0),1),j={r:b,g:c,b:e,toString:nb},j.hex="#"+(16777216|e|c<<8|b<<16).toString(16).slice(1),j.opacity=f(g,"finite")?g:1,j)):{r:-1,g:-1,b:-1,hex:"none",error:1,toString:nb}},d),d.hsb=j(function(a,b,c){return d.hsb2rgb(a,b,c).hex}),d.hsl=j(function(a,b,c){return d.hsl2rgb(a,b,c).hex}),d.rgb=j(function(a,b,c,d){if(f(d,"finite")){var e=N.round;return"rgba("+[e(a),e(b),e(c),+d.toFixed(2)]+")"}return"#"+(16777216|c|b<<8|a<<16).toString(16).slice(1)});var kb=function(a){var b=I.doc.getElementsByTagName("head")[0],c="rgb(255, 0, 0)";return kb=j(function(a){if("red"==a.toLowerCase())return c;b.style.color=c,b.style.color=a;var d=I.doc.defaultView.getComputedStyle(b,S).getPropertyValue("color");return d==c?null:d}),kb(a)},lb=function(){return"hsb("+[this.h,this.s,this.b]+")"},mb=function(){return"hsl("+[this.h,this.s,this.l]+")"},nb=function(){return 1==this.opacity||null==this.opacity?this.hex:"rgba("+[this.r,this.g,this.b,this.opacity]+")"},ob=function(a,b,c){if(null==b&&f(a,"object")&&"r"in a&&"g"in a&&"b"in a&&(c=a.b,b=a.g,a=a.r),null==b&&f(a,string)){var e=d.getRGB(a);a=e.r,b=e.g,c=e.b}return(a>1||b>1||c>1)&&(a/=255,b/=255,c/=255),[a,b,c]},pb=function(a,b,c,e){a=N.round(255*a),b=N.round(255*b),c=N.round(255*c);var g={r:a,g:b,b:c,opacity:f(e,"finite")?e:1,hex:d.rgb(a,b,c),toString:nb};return f(e,"finite")&&(g.opacity=e),g};d.color=function(a){var b;return f(a,"object")&&"h"in a&&"s"in a&&"b"in a?(b=d.hsb2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):f(a,"object")&&"h"in a&&"s"in a&&"l"in a?(b=d.hsl2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):(f(a,"string")&&(a=d.getRGB(a)),f(a,"object")&&"r"in a&&"g"in a&&"b"in a&&!("error"in a)?(b=d.rgb2hsl(a),a.h=b.h,a.s=b.s,a.l=b.l,b=d.rgb2hsb(a),a.v=b.b):(a={hex:"none"},a.r=a.g=a.b=a.h=a.s=a.v=a.l=-1,a.error=1)),a.toString=nb,a},d.hsb2rgb=function(a,b,c,d){f(a,"object")&&"h"in a&&"s"in a&&"b"in a&&(c=a.b,b=a.s,a=a.h,d=a.o),a*=360;var e,g,h,i,j;return a=a%360/60,j=c*b,i=j*(1-Q(a%2-1)),e=g=h=c-j,a=~~a,e+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],pb(e,g,h,d)},d.hsl2rgb=function(a,b,c,d){f(a,"object")&&"h"in a&&"s"in a&&"l"in a&&(c=a.l,b=a.s,a=a.h),(a>1||b>1||c>1)&&(a/=360,b/=100,c/=100),a*=360;var e,g,h,i,j;return a=a%360/60,j=2*b*(.5>c?c:1-c),i=j*(1-Q(a%2-1)),e=g=h=c-j/2,a=~~a,e+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],pb(e,g,h,d)},d.rgb2hsb=function(a,b,c){c=ob(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g;return f=O(a,b,c),g=f-P(a,b,c),d=0==g?null:f==a?(b-c)/g:f==b?(c-a)/g+2:(a-b)/g+4,d=60*((d+360)%6)/360,e=0==g?0:g/f,{h:d,s:e,b:f,toString:lb}},d.rgb2hsl=function(a,b,c){c=ob(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g,h,i;return g=O(a,b,c),h=P(a,b,c),i=g-h,d=0==i?null:g==a?(b-c)/i:g==b?(c-a)/i+2:(a-b)/i+4,d=60*((d+360)%6)/360,f=(g+h)/2,e=0==i?0:.5>f?i/(2*f):i/(2-2*f),{h:d,s:e,l:f,toString:mb}},d.parsePathString=function(a){if(!a)return null;var b=d.path(a);if(b.arr)return d.path.clone(b.arr);var c={a:7,c:6,o:2,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,u:3,z:0},e=[];return f(a,"array")&&f(a[0],"array")&&(e=d.path.clone(a)),e.length||K(a).replace(_,function(a,b,d){var f=[],g=b.toLowerCase();if(d.replace(bb,function(a,b){b&&f.push(+b)}),"m"==g&&f.length>2&&(e.push([b].concat(f.splice(0,2))),g="l",b="m"==b?"l":"L"),"o"==g&&1==f.length&&e.push([b,f[0]]),"r"==g)e.push([b].concat(f));else for(;f.length>=c[g]&&(e.push([b].concat(f.splice(0,c[g]))),c[g]););}),e.toString=d.path.toString,b.arr=d.path.clone(e),e};var qb=d.parseTransformString=function(a){if(!a)return null;var b=[];return f(a,"array")&&f(a[0],"array")&&(b=d.path.clone(a)),b.length||K(a).replace(ab,function(a,c,d){var e=[];c.toLowerCase(),d.replace(bb,function(a,b){b&&e.push(+b)}),b.push([c].concat(e))}),b.toString=d.path.toString,b};d._.svgTransform2string=o,d._.rgTransform=new RegExp("^[a-z]["+X+"]*-?\\.?\\d","i"),d._.transform2matrix=p,d._unit2px=s;var rb=I.doc.contains||I.doc.compareDocumentPosition?function(a,b){var c=9==a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a==d||!(!d||1!=d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)for(;b;)if(b=b.parentNode,b==a)return!0;return!1};d._.getSomeDefs=r,d.select=function(a){return z(I.doc.querySelector(a))},d.selectAll=function(a){for(var b=I.doc.querySelectorAll(a),c=(d.set||Array)(),e=0;e<b.length;e++)c.push(z(b[e]));return c},function(a){function g(a){function b(a,b){var c=e(a.node,b);c=c&&c.match(g),c=c&&c[2],c&&"#"==c.charAt()&&(c=c.substring(1),c&&(i[c]=(i[c]||[]).concat(function(c){var d={};d[b]=ib(c),e(a.node,d)})))}function c(a){var b=e(a.node,"xlink:href");b&&"#"==b.charAt()&&(b=b.substring(1),b&&(i[b]=(i[b]||[]).concat(function(b){a.attr("xlink:href","#"+b)})))}for(var d,f=a.selectAll("*"),g=/^\s*url\(("|'|)(.*)\1\)\s*$/,h=[],i={},j=0,k=f.length;k>j;j++){d=f[j],b(d,"fill"),b(d,"stroke"),b(d,"filter"),b(d,"mask"),b(d,"clip-path"),c(d);var l=e(d.node,"id");l&&(e(d.node,{id:d.id}),h.push({old:l,id:d.id}))}for(j=0,k=h.length;k>j;j++){var m=i[h[j].old];if(m)for(var n=0,o=m.length;o>n;n++)m[n](h[j].id)}}function h(a,b,c){return function(d){var e=d.slice(a,b);return 1==e.length&&(e=e[0]),c?c(e):e}}function i(a){return function(){var b=a?"<"+this.type:"",c=this.node.attributes,d=this.node.childNodes;if(a)for(var e=0,f=c.length;f>e;e++)b+=" "+c[e].name+'="'+c[e].value.replace(/"/g,'\\"')+'"';if(d.length){for(a&&(b+=">"),e=0,f=d.length;f>e;e++)3==d[e].nodeType?b+=d[e].nodeValue:1==d[e].nodeType&&(b+=z(d[e]).toString());a&&(b+="</"+this.type+">")}else a&&(b+="/>");return b}}a.attr=function(a,c){var d=this;if(d.node,!a)return d;if(f(a,"string")){if(!(arguments.length>1))return v(b("snap.util.getattr."+a,d));var e={};e[a]=c,a=e}for(var g in a)a[J](g)&&b("snap.util.attr."+g,d,a[g]);return d},a.getBBox=function(a){var b=this;if("use"==b.type&&(b=b.original),b.removed)return{};var c=b._;return a?(c.bboxwt=d.path.get[b.type]?d.path.getBBox(b.realPath=d.path.get[b.type](b)):d._.box(b.node.getBBox()),d._.box(c.bboxwt)):(b.realPath=(d.path.get[b.type]||d.path.get.deflt)(b),c.bbox=d.path.getBBox(d.path.map(b.realPath,b.matrix)),d._.box(c.bbox))};var j=function(){return this.string};a.transform=function(a){var b=this._;if(null==a){var c=new n(this.node.getCTM()),d=q(this),f=d.toTransformString(),g=K(d)==K(this.matrix)?b.transform:f;return{string:g,globalMatrix:c,localMatrix:d,diffMatrix:c.clone().add(d.invert()),global:c.toTransformString(),local:f,toString:j}}return a instanceof n&&(a=a.toTransformString()),q(this,a),this.node&&("linearGradient"==this.type||"radialGradient"==this.type?e(this.node,{gradientTransform:this.matrix}):"pattern"==this.type?e(this.node,{patternTransform:this.matrix}):e(this.node,{transform:this.matrix})),this},a.parent=function(){return z(this.node.parentNode)},a.append=a.add=function(a){if(a){if("set"==a.type){var b=this;return a.forEach(function(a){b.add(a)}),this}a=z(a),this.node.appendChild(a.node),a.paper=this.paper}return this},a.appendTo=function(a){return a&&(a=z(a),a.append(this)),this},a.prepend=function(a){if(a){a=z(a);var b=a.parent();this.node.insertBefore(a.node,this.node.firstChild),this.add&&this.add(),a.paper=this.paper,this.parent()&&this.parent().add(),b&&b.add()}return this},a.prependTo=function(a){return a=z(a),a.prepend(this),this},a.before=function(a){if("set"==a.type){var b=this;return a.forEach(function(a){var c=a.parent();b.node.parentNode.insertBefore(a.node,b.node),c&&c.add()}),this.parent().add(),this}a=z(a);var c=a.parent();return this.node.parentNode.insertBefore(a.node,this.node),this.parent()&&this.parent().add(),c&&c.add(),a.paper=this.paper,this},a.after=function(a){a=z(a);var b=a.parent();return this.node.nextSibling?this.node.parentNode.insertBefore(a.node,this.node.nextSibling):this.node.parentNode.appendChild(a.node),this.parent()&&this.parent().add(),b&&b.add(),a.paper=this.paper,this},a.insertBefore=function(a){a=z(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},a.insertAfter=function(a){a=z(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node.nextSibling),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},a.remove=function(){var a=this.parent();return this.node.parentNode&&this.node.parentNode.removeChild(this.node),delete this.paper,this.removed=!0,a&&a.add(),this},a.select=function(a){return z(this.node.querySelector(a))},a.selectAll=function(a){for(var b=this.node.querySelectorAll(a),c=(d.set||Array)(),e=0;e<b.length;e++)c.push(z(b[e]));return c},a.asPX=function(a,b){return null==b&&(b=this.attr(a)),+s(this,a,b)},a.use=function(){var a,b=this.node.id;return b||(b=this.id,e(this.node,{id:b})),a="linearGradient"==this.type||"radialGradient"==this.type||"pattern"==this.type?x(this.type,this.node.parentNode):x("use",this.node.parentNode),e(a.node,{"xlink:href":"#"+b}),a.original=this,a},a.clone=function(){var a=z(this.node.cloneNode(!0));return e(a.node,"id")&&e(a.node,{id:a.id}),g(a),a.insertAfter(this),a},a.toDefs=function(){var a=r(this);return a.appendChild(this.node),this},a.pattern=function(a,b,c,d){var g=x("pattern",r(this));return null==a&&(a=this.getBBox()),f(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,a=a.x),e(g.node,{x:a,y:b,width:c,height:d,patternUnits:"userSpaceOnUse",id:g.id,viewBox:[a,b,c,d].join(" ")}),g.node.appendChild(this.node),g},a.marker=function(a,b,c,d,g,h){var i=x("marker",r(this));return null==a&&(a=this.getBBox()),f(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,g=a.refX||a.cx,h=a.refY||a.cy,a=a.x),e(i.node,{viewBox:[a,b,c,d].join(T),markerWidth:c,markerHeight:d,orient:"auto",refX:g||0,refY:h||0,id:i.id}),i.node.appendChild(this.node),i};var k=function(a,b,d,e){"function"!=typeof d||d.length||(e=d,d=c.linear),this.attr=a,this.dur=b,d&&(this.easing=d),e&&(this.callback=e)};d.animation=function(a,b,c,d){return new k(a,b,c,d)},a.inAnim=function(){var a=this,b=[];for(var c in a.anims)a.anims[J](c)&&!function(a){b.push({anim:new k(a._attrs,a.dur,a.easing,a._callback),curStatus:a.status(),status:function(b){return a.status(b)},stop:function(){a.stop()}})}(a.anims[c]);return b},d.animate=function(a,d,e,f,g,h){"function"!=typeof g||g.length||(h=g,g=c.linear);var i=c.time(),j=c(a,d,i,i+f,c.time,e,g);return h&&b.once("mina.finish."+j.id,h),j},a.stop=function(){for(var a=this.inAnim(),b=0,c=a.length;c>b;b++)a[b].stop();return this},a.animate=function(a,d,e,g){"function"!=typeof e||e.length||(g=e,e=c.linear),a instanceof k&&(g=a.callback,e=a.easing,d=e.dur,a=a.attr);var i,j,l,m,n=[],o=[],p={},q=this;for(var r in a)if(a[J](r)){q.equal?(m=q.equal(r,K(a[r])),i=m.from,j=m.to,l=m.f):(i=+q.attr(r),j=+a[r]);var s=f(i,"array")?i.length:1;p[r]=h(n.length,n.length+s,l),n=n.concat(i),o=o.concat(j)}var t=c.time(),u=c(n,o,t,t+d,c.time,function(a){var b={};for(var c in p)p[J](c)&&(b[c]=p[c](a));q.attr(b)},e);return q.anims[u.id]=u,u._attrs=a,u._callback=g,b.once("mina.finish."+u.id,function(){delete q.anims[u.id],g&&g.call(q)}),b.once("mina.stop."+u.id,function(){delete q.anims[u.id]}),q};var l={};a.data=function(a,c){var e=l[this.id]=l[this.id]||{};if(0==arguments.length)return b("snap.data.get."+this.id,this,e,null),e;if(1==arguments.length){if(d.is(a,"object")){for(var f in a)a[J](f)&&this.data(f,a[f]);return this}return b("snap.data.get."+this.id,this,e[a],a),e[a]}return e[a]=c,b("snap.data.set."+this.id,this,c,a),this},a.removeData=function(a){return null==a?l[this.id]={}:l[this.id]&&delete l[this.id][a],this},a.outerSVG=a.toString=i(1),a.innerSVG=i()}(u.prototype),d.parse=function(a){var b=I.doc.createDocumentFragment(),c=!0,d=I.doc.createElement("div");if(a=K(a),a.match(/^\s*<\s*svg(?:\s|>)/)||(a="<svg>"+a+"</svg>",c=!1),d.innerHTML=a,a=d.getElementsByTagName("svg")[0])if(c)b=a;else for(;a.firstChild;)b.appendChild(a.firstChild);return d.innerHTML=S,new w(b)},w.prototype.select=u.prototype.select,w.prototype.selectAll=u.prototype.selectAll,d.fragment=function(){for(var a=Array.prototype.slice.call(arguments,0),b=I.doc.createDocumentFragment(),c=0,e=a.length;e>c;c++){var f=a[c];f.node&&f.node.nodeType&&b.appendChild(f.node),f.nodeType&&b.appendChild(f),"string"==typeof f&&b.appendChild(d.parse(f).node)}return new w(b)},function(a){a.el=function(a,b){return x(a,this.node).attr(b)},a.rect=function(a,b,c,d,e,g){var h;return null==g&&(g=e),f(a,"object")&&"x"in a?h=a:null!=a&&(h={x:a,y:b,width:c,height:d},null!=e&&(h.rx=e,h.ry=g)),this.el("rect",h)},a.circle=function(a,b,c){var d;return f(a,"object")&&"cx"in a?d=a:null!=a&&(d={cx:a,cy:b,r:c}),this.el("circle",d)},a.image=function(a,b,c,d,g){var h=x("image",this.node);if(f(a,"object")&&"src"in a)h.attr(a);else if(null!=a){var i={"xlink:href":a,preserveAspectRatio:"none"};null!=b&&null!=c&&(i.x=b,i.y=c),null!=d&&null!=g?(i.width=d,i.height=g):jb(a,function(){e(h.node,{width:this.offsetWidth,height:this.offsetHeight})}),e(h.node,i)}return h},a.ellipse=function(a,b,c,d){var e=x("ellipse",this.node);
return f(a,"object")&&"cx"in a?e.attr(a):null!=a&&e.attr({cx:a,cy:b,rx:c,ry:d}),e},a.path=function(a){var b=x("path",this.node);return f(a,"object")&&!f(a,"array")?b.attr(a):a&&b.attr({d:a}),b},a.group=a.g=function(b){var c=x("g",this.node);c.add=t;for(var d in a)a[J](d)&&(c[d]=a[d]);return 1==arguments.length&&b&&!b.type?c.attr(b):arguments.length&&c.add(Array.prototype.slice.call(arguments,0)),c},a.text=function(a,b,c){var d=x("text",this.node);return f(a,"object")?d.attr(a):null!=a&&d.attr({x:a,y:b,text:c||""}),d},a.line=function(a,b,c,d){var e=x("line",this.node);return f(a,"object")?e.attr(a):null!=a&&e.attr({x1:a,x2:c,y1:b,y2:d}),e},a.polyline=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b=x("polyline",this.node);return f(a,"object")&&!f(a,"array")?b.attr(a):null!=a&&b.attr({points:a}),b},a.polygon=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b=x("polygon",this.node);return f(a,"object")&&!f(a,"array")?b.attr(a):null!=a&&b.attr({points:a}),b},function(){a.gradient=function(a){return D(this.defs,a)},a.gradientLinear=function(a,b,c,d){return E(this.defs,a,b,c,d)},a.gradientRadial=function(a,b,c,d,e){return F(this.defs,a,b,c,d,e)},a.toString=function(){var a,b=I.doc.createDocumentFragment(),c=I.doc.createElement("div"),d=this.node.cloneNode(!0);return b.appendChild(c),c.appendChild(d),e(d,{xmlns:gb}),a=c.innerHTML,b.removeChild(b.firstChild),a},a.clear=function(){for(var a,b=this.node.firstChild;b;)a=b.nextSibling,"defs"!=b.tagName&&b.parentNode.removeChild(b),b=a}}()}(y.prototype),d.ajax=function(a,c,d,e){var g=new XMLHttpRequest,h=eb();if(g){if(f(c,"function"))e=d,d=c,c=null;else if(f(c,"object")){var i=[];for(var j in c)c.hasOwnProperty(j)&&i.push(encodeURIComponent(j)+"="+encodeURIComponent(c[j]));c=i.join("&")}return g.open(c?"POST":"GET",a,!0),g.setRequestHeader("X-Requested-With","XMLHttpRequest"),c&&g.setRequestHeader("Content-type","application/x-www-form-urlencoded"),d&&(b.once("snap.ajax."+h+".0",d),b.once("snap.ajax."+h+".200",d),b.once("snap.ajax."+h+".304",d)),g.onreadystatechange=function(){4==g.readyState&&b("snap.ajax."+h+"."+g.status,e,g)},4==g.readyState?g:(g.send(c),g)}},d.load=function(a,b,c){d.ajax(a,function(a){var e=d.parse(a.responseText);c?b.call(c,e):b(e)})},b.on("snap.util.attr.mask",function(a){if(a instanceof u||a instanceof w){if(b.stop(),a instanceof w&&1==a.node.childNodes.length&&(a=a.node.firstChild,r(this).appendChild(a),a=z(a)),"mask"==a.type)var c=a;else c=x("mask",r(this)),c.node.appendChild(a.node),!c.node.id&&e(c.node,{id:c.id});e(this.node,{mask:ib(c.id)})}}),function(a){b.on("snap.util.attr.clip",a),b.on("snap.util.attr.clip-path",a),b.on("snap.util.attr.clipPath",a)}(function(a){if(a instanceof u||a instanceof w){if(b.stop(),"clipPath"==a.type)var c=a;else c=x("clipPath",r(this)),c.node.appendChild(a.node),!c.node.id&&e(c.node,{id:c.id});e(this.node,{"clip-path":ib(c.id)})}}),b.on("snap.util.attr.fill",G("fill")),b.on("snap.util.attr.stroke",G("stroke"));var sb=/^([lr])(?:\(([^)]*)\))?(.*)$/i;b.on("snap.util.grad.parse",function(a){a=K(a);var b=a.match(sb);if(!b)return null;var c=b[1],d=b[2],e=b[3];return d=d.split(/\s*,\s*/).map(function(a){return+a==a?+a:a}),1==d.length&&0==d[0]&&(d=[]),e=e.split("-"),e=e.map(function(a){a=a.split(":");var b={color:a[0]};return a[1]&&(b.offset=a[1]),b}),{type:c,params:d,stops:e}}),b.on("snap.util.attr.d",function(a){b.stop(),f(a,"array")&&f(a[0],"array")&&(a=d.path.toString.call(a)),a=K(a),a.match(/[ruo]/i)&&(a=d.path.toAbsolute(a)),e(this.node,{d:a})})(-1),b.on("snap.util.attr.#text",function(a){b.stop(),a=K(a);for(var c=I.doc.createTextNode(a);this.node.firstChild;)this.node.removeChild(this.node.firstChild);this.node.appendChild(c)})(-1),b.on("snap.util.attr.path",function(a){b.stop(),this.attr({d:a})})(-1),b.on("snap.util.attr.viewBox",function(a){var c;c=f(a,"object")&&"x"in a?[a.x,a.y,a.width,a.height].join(" "):f(a,"array")?a.join(" "):a,e(this.node,{viewBox:c}),b.stop()})(-1),b.on("snap.util.attr.transform",function(a){this.transform(a),b.stop()})(-1),b.on("snap.util.attr.r",function(a){"rect"==this.type&&(b.stop(),e(this.node,{rx:a,ry:a}))})(-1),b.on("snap.util.attr.textpath",function(a){if(b.stop(),"text"==this.type){var c,d,g;if(!a&&this.textPath){for(d=this.textPath;d.node.firstChild;)this.node.appendChild(d.node.firstChild);return d.remove(),delete this.textPath,void 0}if(f(a,"string")){var h=r(this),i=z(h.parentNode).path(a);h.appendChild(i.node),c=i.id,i.attr({id:c})}else a=z(a),a instanceof u&&(c=a.attr("id"),c||(c=a.id,a.attr({id:c})));if(c)if(d=this.textPath,g=this.node,d)d.attr({"xlink:href":"#"+c});else{for(d=e("textPath",{"xlink:href":"#"+c});g.firstChild;)d.appendChild(g.firstChild);g.appendChild(d),this.textPath=z(d)}}})(-1),b.on("snap.util.attr.text",function(a){if("text"==this.type){for(var c=this.node,d=function(a){var b=e("tspan");if(f(a,"array"))for(var c=0;c<a.length;c++)b.appendChild(d(a[c]));else b.appendChild(I.doc.createTextNode(a));return b.normalize&&b.normalize(),b};c.firstChild;)c.removeChild(c.firstChild);for(var g=d(a);g.firstChild;)c.appendChild(g.firstChild)}b.stop()})(-1);var tb={"alignment-baseline":0,"baseline-shift":0,clip:0,"clip-path":0,"clip-rule":0,color:0,"color-interpolation":0,"color-interpolation-filters":0,"color-profile":0,"color-rendering":0,cursor:0,direction:0,display:0,"dominant-baseline":0,"enable-background":0,fill:0,"fill-opacity":0,"fill-rule":0,filter:0,"flood-color":0,"flood-opacity":0,font:0,"font-family":0,"font-size":0,"font-size-adjust":0,"font-stretch":0,"font-style":0,"font-variant":0,"font-weight":0,"glyph-orientation-horizontal":0,"glyph-orientation-vertical":0,"image-rendering":0,kerning:0,"letter-spacing":0,"lighting-color":0,marker:0,"marker-end":0,"marker-mid":0,"marker-start":0,mask:0,opacity:0,overflow:0,"pointer-events":0,"shape-rendering":0,"stop-color":0,"stop-opacity":0,stroke:0,"stroke-dasharray":0,"stroke-dashoffset":0,"stroke-linecap":0,"stroke-linejoin":0,"stroke-miterlimit":0,"stroke-opacity":0,"stroke-width":0,"text-anchor":0,"text-decoration":0,"text-rendering":0,"unicode-bidi":0,visibility:0,"word-spacing":0,"writing-mode":0};b.on("snap.util.attr",function(a){var c=b.nt(),d={};c=c.substring(c.lastIndexOf(".")+1),d[c]=a;var f=c.replace(/-(\w)/gi,function(a,b){return b.toUpperCase()}),g=c.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});tb[J](g)?this.node.style[f]=null==a?S:a:e(this.node,d)}),b.on("snap.util.getattr.transform",function(){return b.stop(),this.transform()})(-1),b.on("snap.util.getattr.textpath",function(){return b.stop(),this.textPath})(-1),function(){function a(a){return function(){b.stop();var c=I.doc.defaultView.getComputedStyle(this.node,null).getPropertyValue("marker-"+a);return"none"==c?c:d(I.doc.getElementById(c.match(W)[1]))}}function c(a){return function(c){b.stop();var d="marker"+a.charAt(0).toUpperCase()+a.substring(1);if(""==c||!c)return this.node.style[d]="none",void 0;if("marker"==c.type){var f=c.node.id;return f||e(c.node,{id:c.id}),this.node.style[d]=ib(f),void 0}}}b.on("snap.util.getattr.marker-end",a("end"))(-1),b.on("snap.util.getattr.markerEnd",a("end"))(-1),b.on("snap.util.getattr.marker-start",a("start"))(-1),b.on("snap.util.getattr.markerStart",a("start"))(-1),b.on("snap.util.getattr.marker-mid",a("mid"))(-1),b.on("snap.util.getattr.markerMid",a("mid"))(-1),b.on("snap.util.attr.marker-end",c("end"))(-1),b.on("snap.util.attr.markerEnd",c("end"))(-1),b.on("snap.util.attr.marker-start",c("start"))(-1),b.on("snap.util.attr.markerStart",c("start"))(-1),b.on("snap.util.attr.marker-mid",c("mid"))(-1),b.on("snap.util.attr.markerMid",c("mid"))(-1)}(),b.on("snap.util.getattr.r",function(){return"rect"==this.type&&e(this.node,"rx")==e(this.node,"ry")?(b.stop(),e(this.node,"rx")):void 0})(-1),b.on("snap.util.getattr.text",function(){if("text"==this.type||"tspan"==this.type){b.stop();var a=H(this.node);return 1==a.length?a[0]:a}})(-1),b.on("snap.util.getattr.#text",function(){return this.node.textContent})(-1),b.on("snap.util.getattr.viewBox",function(){b.stop();var a=e(this.node,"viewBox").split(Y);return d._.box(+a[0],+a[1],+a[2],+a[3])})(-1),b.on("snap.util.getattr.points",function(){var a=e(this.node,"points");return b.stop(),a.split(Y)}),b.on("snap.util.getattr.path",function(){var a=e(this.node,"d");return b.stop(),a}),b.on("snap.util.getattr",function(){var a=b.nt();a=a.substring(a.lastIndexOf(".")+1);var c=a.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});return tb[J](c)?I.doc.defaultView.getComputedStyle(this.node,null).getPropertyValue(c):e(this.node,a)});var ub=function(a){var b=a.getBoundingClientRect(),c=a.ownerDocument,d=c.body,e=c.documentElement,f=e.clientTop||d.clientTop||0,h=e.clientLeft||d.clientLeft||0,i=b.top+(g.win.pageYOffset||e.scrollTop||d.scrollTop)-f,j=b.left+(g.win.pageXOffset||e.scrollLeft||d.scrollLeft)-h;return{y:i,x:j}};return d.getElementByPoint=function(a,b){var c=this,d=(c.canvas,I.doc.elementFromPoint(a,b));if(I.win.opera&&"svg"==d.tagName){var e=ub(d),f=d.createSVGRect();f.x=a-e.x,f.y=b-e.y,f.width=f.height=1;var g=d.getIntersectionList(f,null);g.length&&(d=g[g.length-1])}return d?z(d):null},d.plugin=function(a){a(d,u,y,I)},I.win.Snap=d,d}();return d.plugin(function(a,b){function c(a){var b=c.ps=c.ps||{};return b[a]?b[a].sleep=100:b[a]={sleep:100},setTimeout(function(){for(var c in b)b[L](c)&&c!=a&&(b[c].sleep--,!b[c].sleep&&delete b[c])}),b[a]}function d(a,b,c,d){return null==a&&(a=b=c=d=0),null==b&&(b=a.y,c=a.width,d=a.height,a=a.x),{x:a,y:b,width:c,w:c,height:d,h:d,x2:a+c,y2:b+d,cx:a+c/2,cy:b+d/2,r1:O.min(c,d)/2,r2:O.max(c,d)/2,r0:O.sqrt(c*c+d*d)/2,path:w(a,b,c,d),vb:[a,b,c,d].join(" ")}}function e(){return this.join(",").replace(M,"$1")}function f(a){var b=K(a);return b.toString=e,b}function g(a,b,c,d,e,f,g,h,j){return null==j?n(a,b,c,d,e,f,g,h):i(a,b,c,d,e,f,g,h,o(a,b,c,d,e,f,g,h,j))}function h(c,d){function e(a){return+(+a).toFixed(3)}return a._.cacher(function(a,f,h){a instanceof b&&(a=a.attr("d")),a=F(a);for(var j,k,l,m,n,o="",p={},q=0,r=0,s=a.length;s>r;r++){if(l=a[r],"M"==l[0])j=+l[1],k=+l[2];else{if(m=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6]),q+m>f){if(d&&!p.start){if(n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q),o+=["C"+e(n.start.x),e(n.start.y),e(n.m.x),e(n.m.y),e(n.x),e(n.y)],h)return o;p.start=o,o=["M"+e(n.x),e(n.y)+"C"+e(n.n.x),e(n.n.y),e(n.end.x),e(n.end.y),e(l[5]),e(l[6])].join(),q+=m,j=+l[5],k=+l[6];continue}if(!c&&!d)return n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q)}q+=m,j=+l[5],k=+l[6]}o+=l.shift()+l}return p.end=o,n=c?q:d?p:i(j,k,l[0],l[1],l[2],l[3],l[4],l[5],1)},null,a._.clone)}function i(a,b,c,d,e,f,g,h,i){var j=1-i,k=S(j,3),l=S(j,2),m=i*i,n=m*i,o=k*a+3*l*i*c+3*j*i*i*e+n*g,p=k*b+3*l*i*d+3*j*i*i*f+n*h,q=a+2*i*(c-a)+m*(e-2*c+a),r=b+2*i*(d-b)+m*(f-2*d+b),s=c+2*i*(e-c)+m*(g-2*e+c),t=d+2*i*(f-d)+m*(h-2*f+d),u=j*a+i*c,v=j*b+i*d,w=j*e+i*g,x=j*f+i*h,y=90-180*O.atan2(q-s,r-t)/P;return{x:o,y:p,m:{x:q,y:r},n:{x:s,y:t},start:{x:u,y:v},end:{x:w,y:x},alpha:y}}function j(b,c,e,f,g,h,i,j){a.is(b,"array")||(b=[b,c,e,f,g,h,i,j]);var k=E.apply(null,b);return d(k.min.x,k.min.y,k.max.x-k.min.x,k.max.y-k.min.y)}function k(a,b,c){return b>=a.x&&b<=a.x+a.width&&c>=a.y&&c<=a.y+a.height}function l(a,b){return a=d(a),b=d(b),k(b,a.x,a.y)||k(b,a.x2,a.y)||k(b,a.x,a.y2)||k(b,a.x2,a.y2)||k(a,b.x,b.y)||k(a,b.x2,b.y)||k(a,b.x,b.y2)||k(a,b.x2,b.y2)||(a.x<b.x2&&a.x>b.x||b.x<a.x2&&b.x>a.x)&&(a.y<b.y2&&a.y>b.y||b.y<a.y2&&b.y>a.y)}function m(a,b,c,d,e){var f=-3*b+9*c-9*d+3*e,g=a*f+6*b-12*c+6*d;return a*g-3*b+3*c}function n(a,b,c,d,e,f,g,h,i){null==i&&(i=1),i=i>1?1:0>i?0:i;for(var j=i/2,k=12,l=[-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],n=[.2491,.2491,.2335,.2335,.2032,.2032,.1601,.1601,.1069,.1069,.0472,.0472],o=0,p=0;k>p;p++){var q=j*l[p]+j,r=m(q,a,c,e,g),s=m(q,b,d,f,h),t=r*r+s*s;o+=n[p]*O.sqrt(t)}return j*o}function o(a,b,c,d,e,f,g,h,i){if(!(0>i||n(a,b,c,d,e,f,g,h)<i)){var j,k=1,l=k/2,m=k-l,o=.01;for(j=n(a,b,c,d,e,f,g,h,m);T(j-i)>o;)l/=2,m+=(i>j?1:-1)*l,j=n(a,b,c,d,e,f,g,h,m);return m}}function p(a,b,c,d,e,f,g,h){if(!(R(a,c)<Q(e,g)||Q(a,c)>R(e,g)||R(b,d)<Q(f,h)||Q(b,d)>R(f,h))){var i=(a*d-b*c)*(e-g)-(a-c)*(e*h-f*g),j=(a*d-b*c)*(f-h)-(b-d)*(e*h-f*g),k=(a-c)*(f-h)-(b-d)*(e-g);if(k){var l=i/k,m=j/k,n=+l.toFixed(2),o=+m.toFixed(2);if(!(n<+Q(a,c).toFixed(2)||n>+R(a,c).toFixed(2)||n<+Q(e,g).toFixed(2)||n>+R(e,g).toFixed(2)||o<+Q(b,d).toFixed(2)||o>+R(b,d).toFixed(2)||o<+Q(f,h).toFixed(2)||o>+R(f,h).toFixed(2)))return{x:l,y:m}}}}function q(a,b,c){var d=j(a),e=j(b);if(!l(d,e))return c?0:[];for(var f=n.apply(0,a),g=n.apply(0,b),h=~~(f/5),k=~~(g/5),m=[],o=[],q={},r=c?0:[],s=0;h+1>s;s++){var t=i.apply(0,a.concat(s/h));m.push({x:t.x,y:t.y,t:s/h})}for(s=0;k+1>s;s++)t=i.apply(0,b.concat(s/k)),o.push({x:t.x,y:t.y,t:s/k});for(s=0;h>s;s++)for(var u=0;k>u;u++){var v=m[s],w=m[s+1],x=o[u],y=o[u+1],z=T(w.x-v.x)<.001?"y":"x",A=T(y.x-x.x)<.001?"y":"x",B=p(v.x,v.y,w.x,w.y,x.x,x.y,y.x,y.y);if(B){if(q[B.x.toFixed(4)]==B.y.toFixed(4))continue;q[B.x.toFixed(4)]=B.y.toFixed(4);var C=v.t+T((B[z]-v[z])/(w[z]-v[z]))*(w.t-v.t),D=x.t+T((B[A]-x[A])/(y[A]-x[A]))*(y.t-x.t);C>=0&&1>=C&&D>=0&&1>=D&&(c?r++:r.push({x:B.x,y:B.y,t1:C,t2:D}))}}return r}function r(a,b){return t(a,b)}function s(a,b){return t(a,b,1)}function t(a,b,c){a=F(a),b=F(b);for(var d,e,f,g,h,i,j,k,l,m,n=c?0:[],o=0,p=a.length;p>o;o++){var r=a[o];if("M"==r[0])d=h=r[1],e=i=r[2];else{"C"==r[0]?(l=[d,e].concat(r.slice(1)),d=l[6],e=l[7]):(l=[d,e,d,e,h,i,h,i],d=h,e=i);for(var s=0,t=b.length;t>s;s++){var u=b[s];if("M"==u[0])f=j=u[1],g=k=u[2];else{"C"==u[0]?(m=[f,g].concat(u.slice(1)),f=m[6],g=m[7]):(m=[f,g,f,g,j,k,j,k],f=j,g=k);var v=q(l,m,c);if(c)n+=v;else{for(var w=0,x=v.length;x>w;w++)v[w].segment1=o,v[w].segment2=s,v[w].bez1=l,v[w].bez2=m;n=n.concat(v)}}}}}return n}function u(a,b,c){var d=v(a);return k(d,b,c)&&1==t(a,[["M",b,c],["H",d.x2+10]],1)%2}function v(a){var b=c(a);if(b.bbox)return K(b.bbox);if(!a)return d();a=F(a);for(var e,f=0,g=0,h=[],i=[],j=0,k=a.length;k>j;j++)if(e=a[j],"M"==e[0])f=e[1],g=e[2],h.push(f),i.push(g);else{var l=E(f,g,e[1],e[2],e[3],e[4],e[5],e[6]);h=h.concat(l.min.x,l.max.x),i=i.concat(l.min.y,l.max.y),f=e[5],g=e[6]}var m=Q.apply(0,h),n=Q.apply(0,i),o=R.apply(0,h),p=R.apply(0,i),q=d(m,n,o-m,p-n);return b.bbox=K(q),q}function w(a,b,c,d,f){if(f)return[["M",a+f,b],["l",c-2*f,0],["a",f,f,0,0,1,f,f],["l",0,d-2*f],["a",f,f,0,0,1,-f,f],["l",2*f-c,0],["a",f,f,0,0,1,-f,-f],["l",0,2*f-d],["a",f,f,0,0,1,f,-f],["z"]];var g=[["M",a,b],["l",c,0],["l",0,d],["l",-c,0],["z"]];return g.toString=e,g}function x(a,b,c,d,f){if(null==f&&null==d&&(d=c),null!=f)var g=Math.PI/180,h=a+c*Math.cos(-d*g),i=a+c*Math.cos(-f*g),j=b+c*Math.sin(-d*g),k=b+c*Math.sin(-f*g),l=[["M",h,j],["A",c,c,0,+(f-d>180),0,i,k]];else l=[["M",a,b],["m",0,-d],["a",c,d,0,1,1,0,2*d],["a",c,d,0,1,1,0,-2*d],["z"]];return l.toString=e,l}function y(b){var d=c(b),g=String.prototype.toLowerCase;if(d.rel)return f(d.rel);a.is(b,"array")&&a.is(b&&b[0],"array")||(b=a.parsePathString(b));var h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=b[0][1],j=b[0][2],k=i,l=j,m++,h.push(["M",i,j]));for(var n=m,o=b.length;o>n;n++){var p=h[n]=[],q=b[n];if(q[0]!=g.call(q[0]))switch(p[0]=g.call(q[0]),p[0]){case"a":p[1]=q[1],p[2]=q[2],p[3]=q[3],p[4]=q[4],p[5]=q[5],p[6]=+(q[6]-i).toFixed(3),p[7]=+(q[7]-j).toFixed(3);break;case"v":p[1]=+(q[1]-j).toFixed(3);break;case"m":k=q[1],l=q[2];default:for(var r=1,s=q.length;s>r;r++)p[r]=+(q[r]-(r%2?i:j)).toFixed(3)}else{p=h[n]=[],"m"==q[0]&&(k=q[1]+i,l=q[2]+j);for(var t=0,u=q.length;u>t;t++)h[n][t]=q[t]}var v=h[n].length;switch(h[n][0]){case"z":i=k,j=l;break;case"h":i+=+h[n][v-1];break;case"v":j+=+h[n][v-1];break;default:i+=+h[n][v-2],j+=+h[n][v-1]}}return h.toString=e,d.rel=f(h),h}function z(b){var d=c(b);if(d.abs)return f(d.abs);if(J(b,"array")&&J(b&&b[0],"array")||(b=a.parsePathString(b)),!b||!b.length)return[["M",0,0]];var g,h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=+b[0][1],j=+b[0][2],k=i,l=j,m++,h[0]=["M",i,j]);for(var n,o,p=3==b.length&&"M"==b[0][0]&&"R"==b[1][0].toUpperCase()&&"Z"==b[2][0].toUpperCase(),q=m,r=b.length;r>q;q++){if(h.push(n=[]),o=b[q],g=o[0],g!=g.toUpperCase())switch(n[0]=g.toUpperCase(),n[0]){case"A":n[1]=o[1],n[2]=o[2],n[3]=o[3],n[4]=o[4],n[5]=o[5],n[6]=+(o[6]+i),n[7]=+(o[7]+j);break;case"V":n[1]=+o[1]+j;break;case"H":n[1]=+o[1]+i;break;case"R":for(var s=[i,j].concat(o.slice(1)),t=2,u=s.length;u>t;t++)s[t]=+s[t]+i,s[++t]=+s[t]+j;h.pop(),h=h.concat(H(s,p));break;case"O":h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);break;case"U":h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));break;case"M":k=+o[1]+i,l=+o[2]+j;default:for(t=1,u=o.length;u>t;t++)n[t]=+o[t]+(t%2?i:j)}else if("R"==g)s=[i,j].concat(o.slice(1)),h.pop(),h=h.concat(H(s,p)),n=["R"].concat(o.slice(-2));else if("O"==g)h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);else if("U"==g)h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));else for(var v=0,w=o.length;w>v;v++)n[v]=o[v];if(g=g.toUpperCase(),"O"!=g)switch(n[0]){case"Z":i=k,j=l;break;case"H":i=n[1];break;case"V":j=n[1];break;case"M":k=n[n.length-2],l=n[n.length-1];default:i=n[n.length-2],j=n[n.length-1]}}return h.toString=e,d.abs=f(h),h}function A(a,b,c,d){return[a,b,c,d,c,d]}function B(a,b,c,d,e,f){var g=1/3,h=2/3;return[g*a+h*c,g*b+h*d,g*e+h*c,g*f+h*d,e,f]}function C(b,c,d,e,f,g,h,i,j,k){var l,m=120*P/180,n=P/180*(+f||0),o=[],p=a._.cacher(function(a,b,c){var d=a*O.cos(c)-b*O.sin(c),e=a*O.sin(c)+b*O.cos(c);return{x:d,y:e}});if(k)y=k[0],z=k[1],w=k[2],x=k[3];else{l=p(b,c,-n),b=l.x,c=l.y,l=p(i,j,-n),i=l.x,j=l.y;var q=(O.cos(P/180*f),O.sin(P/180*f),(b-i)/2),r=(c-j)/2,s=q*q/(d*d)+r*r/(e*e);s>1&&(s=O.sqrt(s),d=s*d,e=s*e);var t=d*d,u=e*e,v=(g==h?-1:1)*O.sqrt(T((t*u-t*r*r-u*q*q)/(t*r*r+u*q*q))),w=v*d*r/e+(b+i)/2,x=v*-e*q/d+(c+j)/2,y=O.asin(((c-x)/e).toFixed(9)),z=O.asin(((j-x)/e).toFixed(9));y=w>b?P-y:y,z=w>i?P-z:z,0>y&&(y=2*P+y),0>z&&(z=2*P+z),h&&y>z&&(y-=2*P),!h&&z>y&&(z-=2*P)}var A=z-y;if(T(A)>m){var B=z,D=i,E=j;z=y+m*(h&&z>y?1:-1),i=w+d*O.cos(z),j=x+e*O.sin(z),o=C(i,j,d,e,f,0,h,D,E,[z,B,w,x])}A=z-y;var F=O.cos(y),G=O.sin(y),H=O.cos(z),I=O.sin(z),J=O.tan(A/4),K=4/3*d*J,L=4/3*e*J,M=[b,c],N=[b+K*G,c-L*F],Q=[i+K*I,j-L*H],R=[i,j];if(N[0]=2*M[0]-N[0],N[1]=2*M[1]-N[1],k)return[N,Q,R].concat(o);o=[N,Q,R].concat(o).join().split(",");for(var S=[],U=0,V=o.length;V>U;U++)S[U]=U%2?p(o[U-1],o[U],n).y:p(o[U],o[U+1],n).x;return S}function D(a,b,c,d,e,f,g,h,i){var j=1-i;return{x:S(j,3)*a+3*S(j,2)*i*c+3*j*i*i*e+S(i,3)*g,y:S(j,3)*b+3*S(j,2)*i*d+3*j*i*i*f+S(i,3)*h}}function E(a,b,c,d,e,f,g,h){var i,j=e-2*c+a-(g-2*e+c),k=2*(c-a)-2*(e-c),l=a-c,m=(-k+O.sqrt(k*k-4*j*l))/2/j,n=(-k-O.sqrt(k*k-4*j*l))/2/j,o=[b,h],p=[a,g];return T(m)>"1e12"&&(m=.5),T(n)>"1e12"&&(n=.5),m>0&&1>m&&(i=D(a,b,c,d,e,f,g,h,m),p.push(i.x),o.push(i.y)),n>0&&1>n&&(i=D(a,b,c,d,e,f,g,h,n),p.push(i.x),o.push(i.y)),j=f-2*d+b-(h-2*f+d),k=2*(d-b)-2*(f-d),l=b-d,m=(-k+O.sqrt(k*k-4*j*l))/2/j,n=(-k-O.sqrt(k*k-4*j*l))/2/j,T(m)>"1e12"&&(m=.5),T(n)>"1e12"&&(n=.5),m>0&&1>m&&(i=D(a,b,c,d,e,f,g,h,m),p.push(i.x),o.push(i.y)),n>0&&1>n&&(i=D(a,b,c,d,e,f,g,h,n),p.push(i.x),o.push(i.y)),{min:{x:Q.apply(0,p),y:Q.apply(0,o)},max:{x:R.apply(0,p),y:R.apply(0,o)}}}function F(a,b){var d=!b&&c(a);if(!b&&d.curve)return f(d.curve);for(var e=z(a),g=b&&z(b),h={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},i={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},j=(function(a,b){var c,d;if(!a)return["C",b.x,b.y,b.x,b.y,b.x,b.y];switch(!(a[0]in{T:1,Q:1})&&(b.qx=b.qy=null),a[0]){case"M":b.X=a[1],b.Y=a[2];break;case"A":a=["C"].concat(C.apply(0,[b.x,b.y].concat(a.slice(1))));break;case"S":c=b.x+(b.x-(b.bx||b.x)),d=b.y+(b.y-(b.by||b.y)),a=["C",c,d].concat(a.slice(1));break;case"T":b.qx=b.x+(b.x-(b.qx||b.x)),b.qy=b.y+(b.y-(b.qy||b.y)),a=["C"].concat(B(b.x,b.y,b.qx,b.qy,a[1],a[2]));break;case"Q":b.qx=a[1],b.qy=a[2],a=["C"].concat(B(b.x,b.y,a[1],a[2],a[3],a[4]));break;case"L":a=["C"].concat(A(b.x,b.y,a[1],a[2]));break;case"H":a=["C"].concat(A(b.x,b.y,a[1],b.y));break;case"V":a=["C"].concat(A(b.x,b.y,b.x,a[1]));break;case"Z":a=["C"].concat(A(b.x,b.y,b.X,b.Y))}return a}),k=function(a,b){if(a[b].length>7){a[b].shift();for(var c=a[b];c.length;)a.splice(b++,0,["C"].concat(c.splice(0,6)));a.splice(b,1),n=R(e.length,g&&g.length||0)}},l=function(a,b,c,d,f){a&&b&&"M"==a[f][0]&&"M"!=b[f][0]&&(b.splice(f,0,["M",d.x,d.y]),c.bx=0,c.by=0,c.x=a[f][1],c.y=a[f][2],n=R(e.length,g&&g.length||0))},m=0,n=R(e.length,g&&g.length||0);n>m;m++){e[m]=j(e[m],h),k(e,m),g&&(g[m]=j(g[m],i)),g&&k(g,m),l(e,g,h,i,m),l(g,e,i,h,m);var o=e[m],p=g&&g[m],q=o.length,r=g&&p.length;h.x=o[q-2],h.y=o[q-1],h.bx=N(o[q-4])||h.x,h.by=N(o[q-3])||h.y,i.bx=g&&(N(p[r-4])||i.x),i.by=g&&(N(p[r-3])||i.y),i.x=g&&p[r-2],i.y=g&&p[r-1]}return g||(d.curve=f(e)),g?[e,g]:e}function G(a,b){if(!b)return a;var c,d,e,f,g,h,i;for(a=F(a),e=0,g=a.length;g>e;e++)for(i=a[e],f=1,h=i.length;h>f;f+=2)c=b.x(i[f],i[f+1]),d=b.y(i[f],i[f+1]),i[f]=c,i[f+1]=d;return a}function H(a,b){for(var c=[],d=0,e=a.length;e-2*!b>d;d+=2){var f=[{x:+a[d-2],y:+a[d-1]},{x:+a[d],y:+a[d+1]},{x:+a[d+2],y:+a[d+3]},{x:+a[d+4],y:+a[d+5]}];b?d?e-4==d?f[3]={x:+a[0],y:+a[1]}:e-2==d&&(f[2]={x:+a[0],y:+a[1]},f[3]={x:+a[2],y:+a[3]}):f[0]={x:+a[e-2],y:+a[e-1]}:e-4==d?f[3]=f[2]:d||(f[0]={x:+a[d],y:+a[d+1]}),c.push(["C",(-f[0].x+6*f[1].x+f[2].x)/6,(-f[0].y+6*f[1].y+f[2].y)/6,(f[1].x+6*f[2].x-f[3].x)/6,(f[1].y+6*f[2].y-f[3].y)/6,f[2].x,f[2].y])}return c}var I=b.prototype,J=a.is,K=a._.clone,L="hasOwnProperty",M=/,?([a-z]),?/gi,N=parseFloat,O=Math,P=O.PI,Q=O.min,R=O.max,S=O.pow,T=O.abs,U=h(1),V=h(),W=h(0,1),X=a._unit2px,Y={path:function(a){return a.attr("path")},circle:function(a){var b=X(a);return x(b.cx,b.cy,b.r)},ellipse:function(a){var b=X(a);return x(b.cx,b.cy,b.rx,b.ry)},rect:function(a){var b=X(a);return w(b.x,b.y,b.width,b.height,b.rx,b.ry)},image:function(a){var b=X(a);return w(b.x,b.y,b.width,b.height)},text:function(a){var b=a.node.getBBox();return w(b.x,b.y,b.width,b.height)},g:function(a){var b=a.node.getBBox();return w(b.x,b.y,b.width,b.height)},symbol:function(a){var b=a.getBBox();return w(b.x,b.y,b.width,b.height)},line:function(a){return"M"+[a.attr("x1"),a.attr("y1"),a.attr("x2"),a.attr("y2")]},polyline:function(a){return"M"+a.attr("points")},polygon:function(a){return"M"+a.attr("points")+"z"},svg:function(a){var b=a.node.getBBox();return w(b.x,b.y,b.width,b.height)},deflt:function(a){var b=a.node.getBBox();return w(b.x,b.y,b.width,b.height)}};a.path=c,a.path.getTotalLength=U,a.path.getPointAtLength=V,a.path.getSubpath=function(a,b,c){if(this.getTotalLength(a)-c<1e-6)return W(a,b).end;var d=W(a,c,1);return b?W(d,b).end:d},I.getTotalLength=function(){return this.node.getTotalLength?this.node.getTotalLength():void 0},I.getPointAtLength=function(a){return V(this.attr("d"),a)},I.getSubpath=function(b,c){return a.path.getSubpath(this.attr("d"),b,c)},a._.box=d,a.path.findDotsAtSegment=i,a.path.bezierBBox=j,a.path.isPointInsideBBox=k,a.path.isBBoxIntersect=l,a.path.intersection=r,a.path.intersectionNumber=s,a.path.isPointInside=u,a.path.getBBox=v,a.path.get=Y,a.path.toRelative=y,a.path.toAbsolute=z,a.path.toCubic=F,a.path.map=G,a.path.toString=e,a.path.clone=f}),d.plugin(function(a){var b=Math.max,c=Math.min,d=function(a){if(this.items=[],this.length=0,this.type="set",a)for(var b=0,c=a.length;c>b;b++)a[b]&&(this[this.items.length]=this.items[this.items.length]=a[b],this.length++)},e=d.prototype;e.push=function(){for(var a,b,c=0,d=arguments.length;d>c;c++)a=arguments[c],a&&(b=this.items.length,this[b]=this.items[b]=a,this.length++);return this},e.pop=function(){return this.length&&delete this[this.length--],this.items.pop()},e.forEach=function(a,b){for(var c=0,d=this.items.length;d>c;c++)if(a.call(b,this.items[c],c)===!1)return this;return this},e.remove=function(){for(;this.length;)this.pop().remove();return this},e.attr=function(a){for(var b=0,c=this.items.length;c>b;b++)this.items[b].attr(a);return this},e.clear=function(){for(;this.length;)this.pop()},e.splice=function(a,e){a=0>a?b(this.length+a,0):a,e=b(0,c(this.length-a,e));var f,g=[],h=[],i=[];for(f=2;f<arguments.length;f++)i.push(arguments[f]);for(f=0;e>f;f++)h.push(this[a+f]);for(;f<this.length-a;f++)g.push(this[a+f]);var j=i.length;for(f=0;f<j+g.length;f++)this.items[a+f]=this[a+f]=j>f?i[f]:g[f-j];for(f=this.items.length=this.length-=e-j;this[f];)delete this[f++];return new d(h)},e.exclude=function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]==a)return this.splice(b,1),!0;return!1},e.insertAfter=function(a){for(var b=this.items.length;b--;)this.items[b].insertAfter(a);return this},e.getBBox=function(){for(var a=[],d=[],e=[],f=[],g=this.items.length;g--;)if(!this.items[g].removed){var h=this.items[g].getBBox();a.push(h.x),d.push(h.y),e.push(h.x+h.width),f.push(h.y+h.height)}return a=c.apply(0,a),d=c.apply(0,d),e=b.apply(0,e),f=b.apply(0,f),{x:a,y:d,x2:e,y2:f,width:e-a,height:f-d,cx:a+(e-a)/2,cy:d+(f-d)/2}},e.clone=function(a){a=new d;for(var b=0,c=this.items.length;c>b;b++)a.push(this.items[b].clone());return a},e.toString=function(){return"Snap‘s set"},e.type="set",a.set=function(){var a=new d;return arguments.length&&a.push.apply(a,Array.prototype.slice.call(arguments,0)),a}}),d.plugin(function(a,b){function c(a){var b=a[0];switch(b.toLowerCase()){case"t":return[b,0,0];case"m":return[b,1,0,0,1,0,0];case"r":return 4==a.length?[b,0,a[2],a[3]]:[b,0];case"s":return 5==a.length?[b,1,1,a[3],a[4]]:3==a.length?[b,1,1]:[b,1]}}function d(b,d,e){d=l(d).replace(/\.{3}|\u2026/g,b),b=a.parseTransformString(b)||[],d=a.parseTransformString(d)||[];for(var f,g,j,k,m=Math.max(b.length,d.length),n=[],o=[],p=0;m>p;p++){if(j=b[p]||c(d[p]),k=d[p]||c(j),j[0]!=k[0]||"r"==j[0].toLowerCase()&&(j[2]!=k[2]||j[3]!=k[3])||"s"==j[0].toLowerCase()&&(j[3]!=k[3]||j[4]!=k[4])){b=a._.transform2matrix(b,e()),d=a._.transform2matrix(d,e()),n=[["m",b.a,b.b,b.c,b.d,b.e,b.f]],o=[["m",d.a,d.b,d.c,d.d,d.e,d.f]];break}for(n[p]=[],o[p]=[],f=0,g=Math.max(j.length,k.length);g>f;f++)f in j&&(n[p][f]=j[f]),f in k&&(o[p][f]=k[f])}return{from:i(n),to:i(o),f:h(n)}}function e(a){return a}function f(a){return function(b){return+b.toFixed(3)+a}}function g(b){return a.rgb(b[0],b[1],b[2])}function h(a){var b,c,d,e,f,g,h=0,i=[];for(b=0,c=a.length;c>b;b++){for(f="[",g=['"'+a[b][0]+'"'],d=1,e=a[b].length;e>d;d++)g[d]="val["+h++ +"]";f+=g+"]",i[b]=f}return Function("val","return Snap.path.toString.call(["+i+"])")}function i(a){for(var b=[],c=0,d=a.length;d>c;c++)for(var e=1,f=a[c].length;f>e;e++)b.push(a[c][e]);return b}var j={},k=/[a-z]+$/i,l=String;j.stroke=j.fill="colour",b.prototype.equal=function(b,c){var m,n,o=l(this.attr(b)||""),p=this;if(o==+o&&c==+c)return{from:+o,to:+c,f:e};if("colour"==j[b])return m=a.color(o),n=a.color(c),{from:[m.r,m.g,m.b,m.opacity],to:[n.r,n.g,n.b,n.opacity],f:g};if("transform"==b||"gradientTransform"==b||"patternTransform"==b)return c instanceof a.Matrix&&(c=c.toTransformString()),a._.rgTransform.test(c)||(c=a._.svgTransform2string(c)),d(o,c,function(){return p.getBBox(1)});if("d"==b||"path"==b)return m=a.path.toCubic(o,c),{from:i(m[0]),to:i(m[1]),f:h(m[0])};if("points"==b)return m=l(o).split(","),n=l(c).split(","),{from:m,to:n,f:function(a){return a}};var q=o.match(k),r=l(c).match(k);return q&&q==r?{from:parseFloat(o),to:parseFloat(c),f:f(q)}:{from:this.asPX(b),to:this.asPX(b,c),f:e}}}),d.plugin(function(a,c,d,e){for(var f=c.prototype,g="hasOwnProperty",h=("createTouch"in e.doc),i=["click","dblclick","mousedown","mousemove","mouseout","mouseover","mouseup","touchstart","touchmove","touchend","touchcancel"],j={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},k=function(a){var b="y"==a?"scrollTop":"scrollLeft";return e.doc.documentElement[b]||e.doc.body[b]},l=function(){this.returnValue=!1},m=function(){return this.originalEvent.preventDefault()},n=function(){this.cancelBubble=!0},o=function(){return this.originalEvent.stopPropagation()},p=function(){return e.doc.addEventListener?function(a,b,c,d){var e=h&&j[b]?j[b]:b,f=function(e){var f=k("y"),i=k("x");if(h&&j[g](b))for(var l=0,n=e.targetTouches&&e.targetTouches.length;n>l;l++)if(e.targetTouches[l].target==a||a.contains(e.targetTouches[l].target)){var p=e;e=e.targetTouches[l],e.originalEvent=p,e.preventDefault=m,e.stopPropagation=o;break}var q=e.clientX+i,r=e.clientY+f;return c.call(d,e,q,r)};return b!==e&&a.addEventListener(b,f,!1),a.addEventListener(e,f,!1),function(){return b!==e&&a.removeEventListener(b,f,!1),a.removeEventListener(e,f,!1),!0}}:e.doc.attachEvent?function(a,b,c,d){var f=function(a){a=a||e.win.event;var b=k("y"),f=k("x"),g=a.clientX+f,h=a.clientY+b;return a.preventDefault=a.preventDefault||l,a.stopPropagation=a.stopPropagation||n,c.call(d,a,g,h)};a.attachEvent("on"+b,f);var g=function(){return a.detachEvent("on"+b,f),!0};return g}:void 0}(),q=[],r=function(c){for(var d,e=c.clientX,f=c.clientY,g=k("y"),i=k("x"),j=q.length;j--;){if(d=q[j],h){for(var l,m=c.touches&&c.touches.length;m--;)if(l=c.touches[m],l.identifier==d.el._drag.id||d.el.node.contains(l.target)){e=l.clientX,f=l.clientY,(c.originalEvent?c.originalEvent:c).preventDefault();break}}else c.preventDefault();var n=d.el.node;a._.glob,n.nextSibling,n.parentNode,n.style.display,e+=i,f+=g,b("snap.drag.move."+d.el.id,d.move_scope||d.el,e-d.el._drag.x,f-d.el._drag.y,e,f,c)}},s=function(c){a.unmousemove(r).unmouseup(s);for(var d,e=q.length;e--;)d=q[e],d.el._drag={},b("snap.drag.end."+d.el.id,d.end_scope||d.start_scope||d.move_scope||d.el,c);q=[]},t=i.length;t--;)!function(b){a[b]=f[b]=function(c,d){return a.is(c,"function")&&(this.events=this.events||[],this.events.push({name:b,f:c,unbind:p(this.shape||this.node||e.doc,b,c,d||this)})),this},a["un"+b]=f["un"+b]=function(a){for(var c=this.events||[],d=c.length;d--;)if(c[d].name==b&&(c[d].f==a||!a))return c[d].unbind(),c.splice(d,1),!c.length&&delete this.events,this;return this}}(i[t]);f.hover=function(a,b,c,d){return this.mouseover(a,c).mouseout(b,d||c)},f.unhover=function(a,b){return this.unmouseover(a).unmouseout(b)};var u=[];f.drag=function(c,d,e,f,g,h){function i(i,j,k){(i.originalEvent||i).preventDefault(),this._drag.x=j,this._drag.y=k,this._drag.id=i.identifier,!q.length&&a.mousemove(r).mouseup(s),q.push({el:this,move_scope:f,start_scope:g,end_scope:h}),d&&b.on("snap.drag.start."+this.id,d),c&&b.on("snap.drag.move."+this.id,c),e&&b.on("snap.drag.end."+this.id,e),b("snap.drag.start."+this.id,g||f||this,j,k,i)}if(!arguments.length){var j;return this.drag(function(a,b){this.attr({transform:j+(j?"T":"t")+[a,b]})},function(){j=this.transform().local})}return this._drag={},u.push({el:this,start:i}),this.mousedown(i),this},f.undrag=function(){for(var c=u.length;c--;)u[c].el==this&&(this.unmousedown(u[c].start),u.splice(c,1),b.unbind("snap.drag.*."+this.id));return!u.length&&a.unmousemove(r).unmouseup(s),this}}),d.plugin(function(a,c,d){var e=(c.prototype,d.prototype),f=/^\s*url\((.+)\)/,g=String,h=a._.$;a.filter={},e.filter=function(b){var d=this;"svg"!=d.type&&(d=d.paper);var e=a.parse(g(b)),f=a._.id(),i=(d.node.offsetWidth,d.node.offsetHeight,h("filter"));return h(i,{id:f,filterUnits:"userSpaceOnUse"}),i.appendChild(e.node),d.defs.appendChild(i),new c(i)},b.on("snap.util.getattr.filter",function(){b.stop();var c=h(this.node,"filter");if(c){var d=g(c).match(f);return d&&a.select(d[1])}}),b.on("snap.util.attr.filter",function(d){if(d instanceof c&&"filter"==d.type){b.stop();var e=d.node.id;e||(h(d.node,{id:d.id}),e=d.id),h(this.node,{filter:a.url(e)})}d&&"none"!=d||(b.stop(),this.node.removeAttribute("filter"))}),a.filter.blur=function(b,c){null==b&&(b=2);var d=null==c?b:[b,c];return a.format('<feGaussianBlur stdDeviation="{def}"/>',{def:d})},a.filter.blur.toString=function(){return this()},a.filter.shadow=function(b,c,d,e){return e=e||"#000",null==d&&(d=4),"string"==typeof d&&(e=d,d=4),null==b&&(b=0,c=2),null==c&&(c=b),e=a.color(e),a.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>',{color:e,dx:b,dy:c,blur:d})
},a.filter.shadow.toString=function(){return this()},a.filter.grayscale=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>',{a:.2126+.7874*(1-b),b:.7152-.7152*(1-b),c:.0722-.0722*(1-b),d:.2126-.2126*(1-b),e:.7152+.2848*(1-b),f:.0722-.0722*(1-b),g:.2126-.2126*(1-b),h:.0722+.9278*(1-b)})},a.filter.grayscale.toString=function(){return this()},a.filter.sepia=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>',{a:.393+.607*(1-b),b:.769-.769*(1-b),c:.189-.189*(1-b),d:.349-.349*(1-b),e:.686+.314*(1-b),f:.168-.168*(1-b),g:.272-.272*(1-b),h:.534-.534*(1-b),i:.131+.869*(1-b)})},a.filter.sepia.toString=function(){return this()},a.filter.saturate=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="saturate" values="{amount}"/>',{amount:1-b})},a.filter.saturate.toString=function(){return this()},a.filter.hueRotate=function(b){return b=b||0,a.format('<feColorMatrix type="hueRotate" values="{angle}"/>',{angle:b})},a.filter.hueRotate.toString=function(){return this()},a.filter.invert=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>',{amount:b,amount2:1-b})},a.filter.invert.toString=function(){return this()},a.filter.brightness=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>',{amount:b})},a.filter.brightness.toString=function(){return this()},a.filter.contrast=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>',{amount:b,amount2:.5-b/2})},a.filter.contrast.toString=function(){return this()}}),d});
(function (global, factory) {
     typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
     typeof define === 'function' && define.amd ? define(factory) :
     (factory());
}(this, function () { 'use strict';

     var babelHelpers = {};
     babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
       return typeof obj;
     } : function (obj) {
       return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
     };
     babelHelpers;

     //定义属性
     var def = Object.defineProperty;

     /**
      * 定义一个新的对象
      * 重写属性
      */
     function def$1(obj, key, val, enumerable, writable) {
         def(obj, key, {
             value: val,
             enumerable: enumerable,
             writable: writable,
             configurable: true
         });
     }

     /**
      * 定义访问控制器
      * @return {[type]} [description]
      */
     function defAccess(obj, key, access) {
         def(obj, key, {
             get: access.get,
             set: access.set
         });
     }

     /**
      * 创建一个纯存的hash对象
      */
     function hash() {
         return Object.create(null);
     }

     /**
      * 转化数组
      * @param  {[type]} o [description]
      * @return {[type]}   [description]
      */
     function toNumber(o) {
         return Number(o) || null;
     };

     /**
      * 保证有效值
      * @return {[type]} [description]
      */
     function toEmpty(val) {
         return Number(val);
     }

     /**
      * 简单继承
      * @return {[type]} [description]
      */
     function extend(subClass, superClass) {
         var F = function F() {};
         // 只继承了superClass超级类中的方法并不包括属性（如果是定义在构造函数中，不在prototype里）
         F.prototype = superClass.prototype;
         // 因为F()函数只继承了超级类中prototype中的方法并没有其相关属性，所以subClass.prototype也只有superClass中的方法。　
         var fProto = new F();
         for (var k in fProto) {
             if (subClass.prototype[k]) {
                 console.log('子类与超类的方法名重叠了！');
             } else {
                 subClass.prototype[k] = fProto[k];
             }
         }
         subClass.prototype.constructor = subClass;
         superClass = null;
     }

     /**
      * 全局字体修复
      * @return {[type]} [description]
      */
     function setRootfont() {
         var rootSize = 16;
         switch (window.innerWidth + window.innerHeight) {
             case 3000:
                 //1920+1080
                 //samsumg galaxy s4
                 rootSize = 32;
                 break;
             case 2000:
                 //1280+720
                 //HD Android phone
                 rootSize = 26;
                 break;
             case 2048:
                 //1280+768
                 rootSize = Xut.plat.isIpad ? 16 : 26;
                 break;
             case 1624:
                 //1024+600
                 rootSize = 18;
                 break;
             case 888:
                 //568+320
                 rootSize = 12;
                 break;
             case 800:
                 //480+320
                 rootSize = 14;
                 break;
             case 560:
                 //320+240
                 rootSize = 12;
                 break;
             default:
                 //其他分辨率 取默认值
                 break;
         }
         16 != rootSize && $("html").css("font-size", rootSize + "px");
     }

     function portExtend(object, config) {
         for (var i in config) {
             if (i) {
                 if (object[i]) {
                     console.log('接口方法重复', 'Key->' + i, 'Value->' + object[i]);
                 } else {
                     object[i] = config[i];
                 }
             }
         }
     };

     /**
      * 修正判断是否存在处理
      * @param  {[type]} arr [description]
      * @return {[type]}     [description]
      */
     function arrayUnique(arr) {
         //去重
         if (arr && arr.length) {
             var length = arr.length;
             while (--length) {
                 //如果在前面已经出现，则将该位置的元素删除
                 if (arr.lastIndexOf(arr[length], length - 1) > -1) {
                     arr.splice(length, 1);
                 }
             }
             return arr;
         } else {
             return arr;
         }
     }

     /**
      * 资源加载
      * @return {[type]} [description]
      */
     var loader = function () {
         return {
             /**入口函数,动态脚本加载
              * @param fileList:           需要动态加载的资源列表
              * @param callback:           所有资源都加载完后调用的回调函数,通常是页面上需要onload就执行的函数
              * @param scope:              作用范围
              * @param preserveOrder:      是否保持脚本顺序
              */
             load: function load(fileList, callback, scope, preserveOrder) {
                 //过来数组元素
                 if (fileList.length && preserveOrder) {
                     var temp = [];
                     fileList.forEach(function (val, index) {
                         if (val) {
                             temp.push(val);
                         }
                     });
                     fileList = temp.reverse();
                     temp = null;
                 }

                 var scope = scope || this,

                 //var scope =this,//默认作用范围是当前页面
                 head = document.getElementsByTagName("head")[0],
                     fragment = document.createDocumentFragment(),
                     numFiles = fileList.length,
                     loadedFiles = 0;

                 //加载一个特定的文件从fileList通过索引
                 var loadFileIndex = function loadFileIndex(index) {
                     head.appendChild(scope.buildScriptTag(fileList[index], onFileLoaded));
                 };

                 /**
                  * 调用回调函数,当所有文件都加载完后调用
                  */
                 var onFileLoaded = function onFileLoaded() {
                     loadedFiles++;
                     //如果当前文件是最后一个要加载的文件，则调用回调函数，否则加载下一个文件
                     if (numFiles == loadedFiles && typeof callback == 'function') {
                         callback.call(scope);
                     } else {
                         if (preserveOrder === true) {
                             loadFileIndex(loadedFiles);
                         }
                     }
                 };

                 if (preserveOrder === true) {
                     loadFileIndex.call(this, 0);
                 } else {
                     for (var i = 0, len = fileList.length; i < len; i++) {
                         fragment.appendChild(this.buildScriptTag(fileList[i], onFileLoaded));
                     }
                     head.appendChild(fragment);
                 }
             },

             //构造javascript和link 标签
             buildScriptTag: function buildScriptTag(filename, callback) {
                 var exten = filename.substr(filename.lastIndexOf('.') + 1);
                 if (exten == 'js') {
                     var script = document.createElement('script');
                     script.type = "text/javascript";
                     script.src = filename;
                     script.onload = callback;
                     return script;
                 }
                 if (exten == 'css') {
                     var style = document.createElement('link');
                     style.rel = 'stylesheet';
                     style.type = 'text/css';
                     style.href = filename;
                     callback();
                     return style;
                 }
             }
         };
     }();

     function pollCss(node, callback) {
         var sheet = node.sheet,
             isLoaded;
         var isOldWebKit = +navigator.userAgent.replace(/.*AppleWebKit\/(\d+)\..*/, "$1") < 536;
         // for WebKit < 536
         if (isOldWebKit) {
             if (sheet) {
                 isLoaded = true;
             }
         }
         // for Firefox < 9.0
         else if (sheet) {
                 try {
                     if (sheet.cssRules) {
                         isLoaded = true;
                     }
                 } catch (ex) {
                     // The value of `ex.name` is changed from "NS_ERROR_DOM_SECURITY_ERR"
                     // to "SecurityError" since Firefox 13.0. But Firefox is less than 9.0
                     // in here, So it is ok to just rely on "NS_ERROR_DOM_SECURITY_ERR"
                     if (ex.name === "NS_ERROR_DOM_SECURITY_ERR") {
                         isLoaded = true;
                     }
                 }
             }

         setTimeout(function () {
             if (isLoaded) {
                 // Place callback here to give time for style rendering
                 callback();
             } else {
                 pollCss(node, callback);
             }
         }, 20);
     }

     function addOnload(node, callback, isCSS, url) {
         var supportOnload = "onload" in node;
         var isOldWebKit = +navigator.userAgent.replace(/.*AppleWebKit\/(\d+)\..*/, "$1") < 536;
         // for Old WebKit and Old Firefox
         if (isCSS) {
             setTimeout(function () {
                 pollCss(node, callback);
             }, 1); // Begin after node insertion
             return;
         }

         if (supportOnload) {
             node.onload = onload;
             node.onerror = function () {
                 onload();
             };
         } else {
             node.onreadystatechange = function () {
                 if (/loaded|complete/.test(node.readyState)) {
                     onload();
                 }
             };
         }

         function onload() {
             // Ensure only run once and handle memory leak in IE
             node.onload = node.onerror = node.onreadystatechange = null;
             // Remove the script to reduce memory leak
             if (!isCSS) {
                 var head = document.getElementsByTagName("head")[0] || document.documentElement;
                 head.removeChild(node);
             }
             // Dereference the node
             node = null;
             callback();
         }
     }

     function request(url, callback, charset) {
         var IS_CSS_RE = /\.css(?:\?|$)/i,
             isCSS = IS_CSS_RE.test(url),
             node = document.createElement(isCSS ? "link" : "script");

         if (charset) {
             var cs = isFunction(charset) ? charset(url) : charset;
             if (cs) {
                 node.charset = cs;
             }
         }
         addOnload(node, callback, isCSS, url);
         if (isCSS) {
             node.rel = "stylesheet";
             node.href = url;
         } else {
             node.async = true;
             node.src = url;
         }
         // For some cache cases in IE 6-8, the script executes IMMEDIATELY after
         // the end of the insert execution, so use `currentlyAddingScript` to
         // hold current node, for deriving url in `define` call
         //currentlyAddingScript = node
         var head = document.getElementsByTagName("head")[0] || document.documentElement;
         var baseElement = head.getElementsByTagName("base")[0];
         // ref: #185 & http://dev.jquery.com/ticket/2709
         baseElement ? head.insertBefore(node, baseElement) : head.appendChild(node);
         //currentlyAddingScript = null
     }

     var _loadfile = request;

     var onlyId;
     var storage = window.localStorage;
     var TAG = 'aaron';

     //如果数据库为写入appid ,则创建
     var createAppid = function createAppid() {
         //添加UUID
         var appId = 'aaron-' + new Date().getDate();
         //写入数据库
         Xut.config.db && Xut.config.db.transaction(function (tx) {
             tx.executeSql("UPDATE Setting SET 'value' = " + appId + " WHERE [name] = 'appId'", function () {}, function () {});
         }, function () {
             //  callback && callback();
         }, function () {
             //  callback && callback();
         });
         return appId;
     };

     //过滤
     var filter = function filter(key) {
         //添加头部标示
         if (onlyId) {
             return key + onlyId;
         } else {
             if (!Xut.config.appUUID) {
                 Xut.config.appUUID = createAppid();
             }
             //子文档标记
             if (SUbCONFIGT && SUbCONFIGT.dbId) {
                 onlyId = "-" + Xut.config.appUUID + "-" + SUbCONFIGT.dbId;
             } else {
                 onlyId = "-" + Xut.config.appUUID;
             }
         }
         return key + onlyId;
     };

     /**
      * 设置localStorage
      * @param {[type]} key [description]
      * @param {[type]} val [description]
      */
     function _set(key, val) {
         var setkey;

         //ipad ios8.3setItem出问题
         function set(key, val) {
             try {
                 storage.setItem(key, val);
             } catch (e) {
                 console.log('storage.setItem(setkey, key[i]);');
             }
         }

         if ((typeof key === 'undefined' ? 'undefined' : babelHelpers.typeof(key)) === 'object') {
             for (var i in key) {
                 if (key.hasOwnProperty(i)) {
                     setkey = filter(i);
                     set(setkey, key[i]);
                 }
             }
         } else {
             key = filter(key);
             set(key, val);
         }
     };

     /**
      * 获取localstorage中的值
      * @param  {[type]} key [description]
      * @return {[type]}     [description]
      */
     function _get(key) {
         key = filter(key);
         return storage.getItem(key);
     };

     /**
      * 删除localStorage中指定项
      * @param  {[type]} key [description]
      * @return {[type]}     [description]
      */
     function _remove$1(key) {
         key = filter(key);
         storage.removeItem(key);
     };

     function _save(name, val) {
         set(name || TAG, JSON.stringify(val));
     }

     /**
      * /解析json字符串
      * @param  {[type]} itemArray [description]
      * @return {[type]}           [description]
      */
     function parseJSON(itemArray) {
         var anminJson;
         try {
             anminJson = JSON.parse(itemArray);
         } catch (error) {
             anminJson = new Function("return " + itemArray)();
         }
         return anminJson;
     }

     /**
      * 提示信息
      * @param  {[type]} require [description]
      * @param  {[type]} exports [description]
      * @param  {[type]} module  [description]
      * @return {[type]}         [description]
      */

     var msgBox = void 0;
     var toolTip = void 0;
     var config$1 = void 0;

     /**
      * 显示提示信息
      */
     function show(opts) {

         var prop = config$1.proportion,
             prefix = Xut.plat.prefixStyle,
             fontsize = (prop.width + prop.height) * 0.5 + 'em',
             content = opts.content,
             time = opts.time || 3000,
             css = {
             'font-size': fontsize,
             'background-image': 'url(images/icons/nodeBig.png)',
             'z-index': 99999,
             'bottom': '1%',
             'left': '5%',
             'padding': '0.2em 0.5em',
             'color': 'white',
             'position': 'absolute'
         };

         if (!toolTip) {
             toolTip = $('#toolTip');
             toolTip.css(css);
             toolTip.css(prefix('border-radius'), '5px');
         } else {
             toolTip.empty().show();
         }

         Xut.nextTick({
             'container': toolTip,
             'content': content
         }, hide);
     }

     /**
      * [模拟alert提示框]
      * @param  {[type]} message [description]
      * @return {[type]}         [description]
      */
     function messageBox$1(message) {

         config$1 = Xut.config;

         var size = config$1.screenSize,
             width = size.width * 0.25,
             Box = msgBox || $('#message'),
             html = '<div class="messageBox" style="width:' + width + 'px;">' + '<div class="messageTex" style="line-height:2">' + message + '</div>' + '<div class="messageBtn" style="line-height:1.5">OK</div>' + '</div>';

         //remove the node when user click
         Box.html(html).show().on("touchend mouseup", function (e) {
             if (e.target.className === 'messageBtn') {
                 this.innerHTML = '';
                 this.style.display = 'none';
             }
         });
     }

     function hide() {
         setTimeout(function () {
             toolTip.hide(1000);
         }, 1500);
     }

     /**
      * 执行脚本注入
      */
     function injectScript(code, type) {
         //过滤回车符号
         var enterReplace = function enterReplace(str) {
             return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
         };
         try {
             new Function("(function(){" + enterReplace(code) + "})")();
         } catch (e) {
             console.log('加载脚本错误', type);
         }
     }

     /**
      * [ 消息框]
      * @param  {[type]} message [description]
      * @return {[type]}         [description]
      */
     function messageBox(message) {
         messageBox$1(message);
     }

     //缩放比
     function fiexdProportion$1(width, height, left, top) {
         var proportion = Xut.config.proportion;
         return {
             width: width * proportion.width,
             height: height * proportion.height,
             left: left * proportion.left,
             top: top * proportion.top
         };
     }

     /*
      * 修复元素的尺寸
      * @type {[type]}
      */

     function reviseSize(results) {
         //不同设备下缩放比计算
         var layerSize = fiexdProportion$1(results.width, results.height, results.left, results.top);
         //新的背景图尺寸
         var backSize = fiexdProportion$1(results.backwidth, results.backheight, results.backleft, results.backtop);

         //赋值新的坐标
         results.scaleWidth = Math.ceil(layerSize.width);
         results.scaleHeight = Math.ceil(layerSize.height);
         results.scaleLeft = Math.floor(layerSize.left);
         results.scaleTop = Math.floor(layerSize.top);

         //背景坐标
         results.scaleBackWidth = Math.ceil(backSize.width);
         results.scaleBackHeight = Math.ceil(backSize.height);
         results.scaleBackLeft = Math.floor(backSize.left);
         results.scaleBackTop = Math.floor(backSize.top);

         return results;
     }

     /**
      *  读取SVG内容
      *  @return {[type]} [string]
      */
     function readFile(path, callback, type) {

         var paths, name, data;
         var config = Xut.config;

         /**
          * ibooks模式 单独处理svg转化策划给你js,加载js文件
          * @param  {[type]} IBOOKSCONFIG [description]
          * @return {[type]}              [description]
          */
         if (Xut.IBooks.CONFIG) {
             paths = config.svgPath().replace("svg", 'js') + path;
             name = path.replace(".svg", '');
             request(paths.replace(".svg", '.js'), function () {
                 data = Xut.IBooks.CONFIG[name];
                 if (data) {
                     callback(data);
                     delete Xut.IBooks.CONFIG[name];
                 } else {
                     callback('脚本加载失败,文件名:' + path);
                 }
             });
             return;
         }

         //如果是js动态文件
         //content的html结构
         if (type === "js") {
             paths = config.svgPath() + path;
             name = path.replace(".js", '');
             request(paths, function () {
                 data = window.HTMLCONFIG[name];
                 if (data) {
                     callback(data);
                     delete window.HTMLCONFIG[name];
                 } else {
                     callback('脚本加载失败,文件名:' + path);
                 }
             });
             return;
         }

         //svg文件
         //游览器模式
         if (Xut.plat.isBrowser) {
             $.ajax({
                 type: 'get',
                 dataType: 'html',
                 url: config.svgPath().replace("www/", "") + path,
                 success: function success(svgContent) {
                     callback(svgContent);
                 },
                 error: function error(xhr, type) {
                     callback('ReadFile数据加载失败');
                     console.log('SVG' + path + '解析出错!');
                 }
             });
         } else {
             //手机模式
             Xut.Plugin.ReadAssetsFile.readAssetsFileAction(config.svgPath() + path, function (svgContent) {
                 callback(svgContent);
             }, function (err) {
                 callback('数据加载失败');
             });
         }
     }

     /****************************************************
      *
      *         	缓存池
      *
      * ***************************************************/
     //创建缓存
     function createCache() {
         var keys = [];

         function cache(key, value) {
             if (keys.push(key) > 20) {
                 delete cache[keys.shift()];
             }
             return cache[key] = value;
         }
         return cache;
     }
     var contentCache = createCache();

     /**
      * 创建执行方法
      * @return {[type]} [description]
      */
     function createfactory(sql, fn) {
         var key;
         if (typeof sql === 'string') {
             fn(key, sql);
         } else {
             for (key in sql) {
                 fn(key, sql[key]);
             }
         }
     }

     //模拟database获取数据
     function executeDB(sql, callback, errorCB, tName) {
         //如果存在生成好的数据文件则直接取
         if (window.SQLResult) {
             if (window.SQLResult[tName]) {
                 var data = window.SQLResult[tName],
                     SQLResultSetRowList = {};

                 SQLResultSetRowList = {
                     length: Object.keys(data).length,
                     item: function item(num) {
                         return data[num];
                     }
                 };
                 callback(SQLResultSetRowList);
             } else {
                 errorCB({
                     tName: ':table not exist!!'
                 });
             }
         } else {
             //否则分次查询数据
             $.ajax({
                 url: Xut.config.onlineModeUrl,
                 dataType: 'json',
                 data: {
                     xxtsql: sql
                 },
                 success: function success(rs) {
                     var data = rs,
                         SQLResultSetRowList = {};
                     SQLResultSetRowList = {
                         length: rs.length,
                         item: function item(num) {
                             return data[num];
                         }
                     };
                     callback(SQLResultSetRowList);
                 },
                 error: errorCB
             });
         }
     }

     //建立sql查询,
     function execute(selectSql, callback) {

         var database = Xut.config.db,
             tableName,
             //表名
         successResults = {},
             //成功的数据
         tempClosure = [],
             //临时收集器
         collectError = [],
             //收集错误查询
         buildTotal = function () {
             //如果只有一条
             if (typeof selectSql === 'string') {
                 return 1;
             } else {
                 return Object.keys(selectSql).length;
             }
         }();

         createfactory(selectSql, function (key, value) {
             //开始执行查询
             createSelect(key || 'results', value);
         });

         /**
          * 创建查询
          */
         function createSelect(key, value) {
             buildTotal--;
             tempClosure.push(executeTemplate(key, value));
             0 === buildTotal && executeBuild();
         }

         /**
          * 执行查询
          * @return {[type]} [description]
          */
         function executeBuild() {
             if (tempClosure.length) {
                 var temp = tempClosure.shift();
                 tableName = temp.tableName;
                 temp.execute();
             } else {
                 //successResults['results'] 成功表数据
                 //collectError 失败表
                 callback(successResults['results'] ? successResults['results'] : successResults, collectError);
             }
         }

         //成功后方法
         function success() {
             executeBuild();
         }

         //失败
         function errorCB(error) {
             collectError.push(tableName);
             console.log("数据查询错误 " + error.message, '类型', tableName);
             executeBuild();
         }

         /**
          * 构建执行作用域
          */
         function executeTemplate(tName, sql) {
             return {
                 tableName: tName,
                 execute: function execute() {
                     //查询
                     if (database) {
                         database.transaction(function (tx) {
                             tx.executeSql(sql, [], function (tx, result) {
                                 successResults[tName] = result.rows;
                             });
                         }, errorCB, success);
                     } else {
                         executeDB(sql, function (result) {
                             successResults[tName] = result;
                             success();
                         }, errorCB, tName);
                     }
                 }
             };
         }
     };

     /**
      * 音频动作
      * @param  {[type]} global [description]
      * @return {[type]}        [description]
      */

     //音频动作
     //替换背景图
     //指定动画
     function Action(options) {

         var element = document.querySelector('#Audio_' + options.audioId);

         //页面从属
         var pageType = element.getAttribute('data-belong');

         //切换背景
         function toggle(linker) {
             element.style.backgroundImage = 'url(' + Xut.conifg.pathAddress + linker + ')';
         }

         function run(ids) {
             ids = ids.split(',');
             Xut.Assist.Run(pageType, ids);
         }

         function stop(ids) {
             ids = ids.split(',');
             Xut.Assist.Stop(pageType, ids);
         }
         return {
             play: function play() {
                 options.startImg && toggle(options.startImg);
                 options.startScript && run(options.startScript);
             },
             pause: function pause() {
                 options.stopImg && toggle(options.stopImg);
                 options.stopScript && stop(options.startScript);
             },
             destroy: function destroy() {
                 element = null;
             }
         };
     }

     /**
      * 音频字幕
      * @param  {[type]} global [description]
      * @return {[type]}        [description]
      */
     //字幕检测时间
     var Interval = 50;

     var getStyles = function getStyles(elem, name) {
         var styles = elem.ownerDocument.defaultView.getComputedStyle(elem, null);
         return styles.getPropertyValue(name);
     };

     /**
      * 字幕类
      * audio  音频实例
      * options 参数
      */
     function Subtitle(audio, options, controlDoms) {

         var visibility;
         this.audio = audio;
         this.options = options;
         this.parents = controlDoms.parents;
         this.ancestors = controlDoms.ancestors;

         this.timer = 0;
         //缓存创建的div节点
         this.cacheCreateDivs = {};

         //保存原始的属性
         var orgAncestorVisibility = this.orgAncestorVisibility = {};
         _.each(this.ancestors, function (node, cid) {
             visibility = getStyles(node, 'visibility');
             if (visibility) {
                 orgAncestorVisibility[cid] = visibility;
             }
         });

         //去重记录
         this.recordRepart = {};
         //phonegap getCurrentPosition得到的音频播放位置不从0开始 记录起始位置
         this.changeValue = 0;

         //快速处理匹配数据
         var checkData = {};
         _.each(options.subtitles, function (data) {
             checkData[data.start + '-start'] = data;
             checkData[data.end + '-end'] = data;
         });
         this.createSubtitle(checkData);
     }

     Subtitle.prototype = {
         /**
          * 运行字幕
          * @return {[type]}
          */
         createSubtitle: function createSubtitle(checkData) {
             var self = this,
                 audio = this.audio,
                 options = this.options;

             //准备创建字幕
             function createAction(audioTime) {
                 _.each(checkData, function (data, key) {
                     var match = key.split('-');
                     //创建动作
                     self.action(match[0], audioTime, match[1], data);
                 });
                 self.createSubtitle(checkData);
             }

             function JudgePlat() {
                 var audioTime;
                 //phonegap
                 if (audio.getCurrentPosition) {
                     audio.getCurrentPosition(function (position) {
                         position = position * 1000;
                         if (!self.changeValue) {
                             self.changeValue = position;
                         }
                         position -= self.changeValue;
                         if (position > -1) {
                             audioTime = Math.round(position);
                         }
                         createAction(audioTime);
                     }, function (e) {
                         console.log("error:" + e);
                         //出错继续检测
                         self.createSubtitle(checkData);
                     });
                 } else if (audio.expansionCurrentPosition) {
                     //扩充的对象
                     audioTime = Math.round(audio.expansionCurrentPosition() * 1000);
                     createAction(audioTime);
                 } else {
                     //html5
                     audioTime = Math.round(audio.currentTime * 1000);
                     createAction(audioTime);
                 }
             }

             self.timer = setTimeout(function () {
                 JudgePlat();
             }, Interval);
         },

         //执行动作
         //创建文本框
         //显示/隐藏
         action: function action(currentTime, audioTime, _action, data) {
             if (audioTime > currentTime - Interval && audioTime < currentTime + Interval) {
                 //创建
                 if (!this.recordRepart[data.start] && _action === 'start') {
                     this.recordRepart[data.start] = true;
                     //创建字幕dom
                     this.createDom(data);

                     //如果是一段字幕结束处理
                 } else if (!this.recordRepart[data.end] && _action === 'end') {
                         this.recordRepart[data.end] = true;
                         // //隐藏
                         var ancestorNode = this.ancestors[data.id];
                         if (ancestorNode) {
                             ancestorNode.style.visibility = "hidden";
                         }
                     }
             }
         },

         createDom: function createDom(data) {

             //屏幕分辨率
             var proportion = Xut.config.proportion;
             var proportionWidth = proportion.width;
             var proportionHeight = proportion.height;
             var screenWidth = Xut.config.screenSize.width;
             var screenHeight = Xut.config.screenSize.height;

             var cid = data.id;
             var parentNode = this.parents[cid];
             var ancestorNode = this.ancestors[cid];
             var preDiv = this.cacheCreateDivs[cid];
             var preP = preDiv && preDiv.children[0];

             //缩放
             var sTop = data.top * proportion.top;
             var sLeft = data.left * proportion.left;
             var sHeight = data.height * proportion.height;
             var sWidth = data.width * proportion.width;

             //转换行高
             var sLineHeight = data.lineHeight ? data.lineHeight : '100%';

             //公用同一个contengid,已经存在
             if (preDiv) {
                 createContent(preDiv, preP, data);
             } else {
                 //创建父元素与子元素
                 var createDiv = document.createElement('div');
                 var createP = document.createElement('p');
                 //设置样式
                 createContent(createDiv, createP, data);
                 createDiv.appendChild(createP); //添加到指定的父元素 

                 parentNode.appendChild(createDiv);

                 //保存引用
                 this.cacheCreateDivs[cid] = createDiv;
             }

             //创建内容
             function createContent(parent, p, data) {
                 createDivStyle(parent, data); //设置div
                 createPStyle(p, data);
             }

             //设置父容器div 字体颜色，大小，类型，位置，文本水平、垂直居中
             function createDivStyle(parent, data) {
                 var cssText = 'position       :absolute; ' + 'display        :table;' + 'vertical-align :center;' + 'top            :{0}px;' + 'left           :{1}px;' + 'height         :{2}px;' + 'width          :{3}px;';

                 parent.style.cssText = String.format(cssText, sTop, sLeft, sHeight, sWidth);
             }

             //内容元素的样式
             function createPStyle(p, data) {

                 var cssText = ' text-align     :center;' + ' display        :table-cell;' + ' vertical-align :middle;' + ' color          :{0};' + ' font-family    :{1};' + ' font-bold      :{2};' + ' font-size      :{3}px;' + ' line-height    :{4}%';

                 //设置字体间距
                 p.style.cssText = String.format(cssText, data.fontColor, data.fontName, data.fontBold, data.fontSize * proportionWidth, sLineHeight);
                 //设置文字内容
                 p.innerHTML = data.title;
             }

             //操作最外层的content节点
             if (ancestorNode) {
                 var ancestorNodeValue = getStyles(ancestorNode, 'visibility');
                 if (ancestorNodeValue != 'visible') {
                     ancestorNode.style.visibility = 'visible';
                 }
             }
         },

         /**
          * 清理音频
          * @return {[type]}
          */
         destroy: function destroy() {
             var self = this;
             _.each(this.cacheCreateDivs, function (node) {
                 node.parentNode.removeChild(node);
             });
             //恢复初始状态
             _.each(this.ancestors, function (node, id) {
                 var orgValue = self.orgAncestorVisibility[id];
                 var currValue = getStyles(node, 'visibility');
                 if (currValue != orgValue) {
                     node.style.visibility = orgValue;
                 }
             });
             this.ancestors = null;
             this.cacheCreateDivs = null;
             this.changeValue = 0;
             this.parents = null;
             if (this.timer) {
                 clearTimeout(this.timer);
                 this.timer = 0;
             }
         }

     };

     var instance = hash(); //存放不同音轨的一个实例
     var html5Audio = void 0;

     /**
      * 音频工厂类
      * @param {[type]} options [description]
      */
     var AudioFactory = Xut.CoreObject.extend({

         //构建之前关数据
         preRelated: function preRelated(trackId, options) {
             //完成end后 外部回调删除这个对象
             //单独调用引用对象
             //传递一个 options.complete
             this.innerCallback = options.innerCallback;
             //仅运行一次
             //外部调用
             this.outerCallback = trackId == 9999 ? options.complete : null;
         },

         //构建之后关数据
         afterRelated: function afterRelated(audio, options, controlDoms) {
             //音频重复播放次数
             if (options.data && options.data.repeat) {
                 this.repeat = Number(options.data.repeat); //需要重复
             }
             //音频动作
             if (options.action) {
                 this.acitonObj = Action(options);
             }
             //字幕对象
             if (options.subtitles && options.subtitles.length > 0) {
                 //创建字幕对象
                 this.subtitleObject = new Subtitle(audio, options, controlDoms);
             }

             //如果有外部回调处理
             if (this.outerCallback) {
                 this.outerCallback.call(this);
             }
         },
         //运行成功失败后处理方法
         //phoengap会调用callbackProcess
         //导致乱了
         callbackProcess: function callbackProcess(sysCommand) {
             if (this.outerCallback) {
                 //外部调用结束
                 this.end();
             } else {
                 //安卓没有重复播放
                 //phonegap未处理
                 if (!Xut.plat.isAndroid && this.repeat) {
                     //如果需要重复
                     this.repeatProcess();
                 } else {
                     //外部清理对象
                     //audioManager中直接删当前对象
                     this.innerCallback(this);
                 }
             }
         },

         //重复处理
         repeatProcess: function repeatProcess() {
             --this.repeat;
             this.play();
         },

         //播放
         play: function play() {
             //flash模式不执行
             if (this.audio && !this.isFlash) {
                 this.status = 'playing';
                 this.audio.play();
             }
             this.acitonObj && this.acitonObj.play();
         },

         //停止
         pause: function pause() {
             this.status = 'paused';
             this.audio.pause();
             this.acitonObj && this.acitonObj.pause();
         },

         //销毁
         end: function end() {
             this.status = 'ended';
             this.audio.end();
             this.audio = null;
             this.acitonObj && this.acitonObj.destroy();
         },

         //相关
         destroyRelated: function destroyRelated() {
             //销毁字幕
             if (this.subtitleObject) {
                 this.subtitleObject.destroy();
                 this.subtitleObject = null;
             }
             //动作
             if (this.acitonObj) {
                 this.acitonObj.destroy();
                 this.acitonObj = null;
             }
         }
     });

     /**
      * 使用PhoneGap的Media播放
      * @param  {string} url 路径
      * @return {[type]}      [description]
      */
     var _Media = AudioFactory.extend({

         init: function init(options, controlDoms) {

             var url = Xut.config.audioPath() + options.url,
                 trackId = options.trackId,
                 self = this,
                 audio;

             //构建之前处理
             this.preRelated(trackId, options);

             //音频成功与失败调用
             audio = new GLOBALCONTEXT.Media(url, function () {
                 self.callbackProcess(true);
             }, function () {
                 self.callbackProcess(true);
             });

             //autoplay
             this.audio = audio;
             this.trackId = trackId;
             this.options = options;

             //相关数据
             this.afterRelated(audio, options, controlDoms);
         },
         //取反
         end: function end() {
             if (this.audio) {
                 this.audio.release();
                 this.audio = null;
             }
             this.status = 'ended';
             this.destroyRelated();
         }
     });

     /**
      * 采用Falsh播放
      * @type {[type]}
      */
     var _Flash = AudioFactory.extend({
         init: function init(options, controlDoms) {
             var trackId = options.trackId,
                 url = Xut.config.audioPath() + options.url,
                 self = this,
                 audio;

             //构建之前处理
             this.preRelated(trackId, options);

             audio = new Audio5js({
                 swf_path: './lib/data/audio5js.swf',
                 throw_errors: true,
                 format_time: true,
                 ready: function ready(player) {
                     this.load(url);
                     //如果调用了播放
                     this.play();
                     self.status = "playing";
                 }
             });

             this.audio = audio;
             this.trackId = trackId;
             this.status = 'playing';
             this.options = options;

             this.isFlash = true;

             //相关数据
             this.afterRelated(audio, options, controlDoms);
         },

         end: function end() {
             if (this.audio) {
                 this.audio.destroy();
                 this.audio = null;
             }
             this.status = 'ended';
             this.destroyRelated();
         }
     });

     /**
      * 使用html5的audio播放
      * @param  {string} url    音频路径
      * @param  {object} options 可选参数
      * @return {object}         [description]
      */
     var _Audio = AudioFactory.extend({
         init: function init(options, controlDoms) {
             var trackId = options.trackId,
                 url = Xut.config.audioPath() + options.url,
                 self = this,
                 audio;

             //构建之前处理
             this.preRelated(trackId, options);

             if (instance[trackId]) {
                 audio = Xut.fix.audio ? Xut.fix.audio : instance[trackId];
                 audio.src = url;
             } else {
                 //create a new Audio instance
                 //如果为ios browser 用Xut.fix.audio 指定src 初始化见app.js
                 if (Xut.fix.audio) {
                     audio = Xut.fix.audio;
                     audio.src = url;
                 } else {
                     audio = new Audio(url);
                 }

                 //更新音轨
                 //妙妙学方式不要音轨处理
                 if (!Xut.fix.audio) {
                     instance[trackId] = audio;
                 }

                 audio.addEventListener('ended', function () {
                     self.callbackProcess();
                 }, false);

                 audio.addEventListener('error', function () {
                     self.callbackProcess();
                 }, false);
             }

             this.audio = audio;
             this.trackId = trackId;
             this.status = 'playing';
             this.options = options;

             //相关数据
             this.afterRelated(audio, options, controlDoms);
         },

         end: function end() {
             if (this.audio) {
                 this.audio.pause();
                 this.audio.removeEventListener('ended', this.callbackProcess, false);
                 this.audio.removeEventListener('error', this.callbackProcess, false);
                 this.audio = null;
             }
             this.status = 'ended';
             this.destroyRelated();
         }
     });

     var createUUID = function createUUID() {
         return UUIDcreatePart(4) + '-' + UUIDcreatePart(2) + '-' + UUIDcreatePart(2) + '-' + UUIDcreatePart(2) + '-' + UUIDcreatePart(6);
     };

     function UUIDcreatePart(length) {
         var uuidpart = "";
         for (var i = 0; i < length; i++) {
             var uuidchar = parseInt(Math.random() * 256, 10).toString(16);
             if (uuidchar.length == 1) {
                 uuidchar = "0" + uuidchar;
             }
             uuidpart += uuidchar;
         }
         return uuidpart;
     }

     /**
      * 使用PhoneGap的 js直接调用 cordova Media播放
      * @param  {string} url 路径
      * @return {[type]}      [description]
      */
     var _cordovaMedia = AudioFactory.extend({

         init: function init(options, controlDoms) {

             var url = Xut.config.audioPath() + options.url,
                 trackId = options.trackId,
                 self = this,
                 audio;

             this.id = createUUID();

             //构建之前处理
             this.preRelated(trackId, options);

             var audio = {
                 startPlayingAudio: function startPlayingAudio() {
                     audioHandler.startPlayingAudio(self.id, url);
                 },
                 pausePlayingAudio: function pausePlayingAudio() {
                     audioHandler.pausePlayingAudio(self.id);
                 },
                 release: function release() {
                     audioHandler.release(self.id);
                 },
                 /**
                  * 扩充，获取位置
                  * @return {[type]} [description]
                  */
                 expansionCurrentPosition: function expansionCurrentPosition() {
                     return getCurrentPosition(self.id);
                 }
             };

             //autoplay
             this.audio = audio;
             this.trackId = trackId;
             this.options = options;

             //相关数据
             this.afterRelated(audio, options, controlDoms);
         },

         //播放
         play: function play() {
             if (this.audio) {
                 this.status = 'playing';
                 this.audio.startPlayingAudio();
             }
             this.acitonObj && this.acitonObj.play();
         },

         //停止
         pause: function pause() {
             this.status = 'paused';
             this.audio && this.audio.pausePlayingAudio();
             this.acitonObj && this.acitonObj.pause();
         },

         //结束
         end: function end() {
             if (this.audio) {
                 this.audio.release();
                 this.audio = null;
             }
             this.status = 'ended';
             this.destroyRelated();
         }
     });

     //apk的情况下
     if (Xut.plat.isAndroid && !Xut.plat.isBrowser) {
         html5Audio = _Media;
     } else {

         //妙妙学的 客户端浏览器模式
         if (MMXCONFIG && audioHandler) {
             html5Audio = _cordovaMedia;
         } else {
             //pc
             html5Audio = _Audio;
         }

         //2015.12.23
         //如果不支持audio改用flash
         // supportAudio(function() {
         //     Xut.Audio = _Flash;
         // });
     }

     Xut.Audio = html5Audio;

     function AudioManager() {

         //动作标示
         var ACTIVIT = 'hot'; //热点音频
         var ANIMATE = 'content'; //动画音频
         var SEASON = 'season'; //节音频

         /**
          * 容器合集
          * 1 pageBox 当前待播放的热点音频
          * 2 playBox 播放中的热点音频集合
          */
         //[type][pageId][queryId]
         var pageBox, playBox;

         function initBox() {
             pageBox = hash();
             //[type][pageId][queryId]
             playBox = hash();
         }

         initBox();

         //===============================================
         //
         //              预装配数据
         //
         //===============================================

         /**
          * 解析数据
          * @param  {[type]} type    [description]
          * @param  {[type]} queryId [description]
          * @return {[type]}         [description]
          */
         function parseData(type, queryId) {
             var data;
             switch (type) {
                 case ANIMATE:
                     data = Xut.data.query('Video', queryId, true);
                     break;
                 case SEASON:
                     data = Xut.data.query('Video', queryId, true);
                     break;
                 default:
                     data = Xut.data.query('Video', queryId);
                     break;
             }
             return data;
         }

         /**
          * 获取父容器
          * @return {[type]} [description]
          */
         function getParentDom(subtitles, pageId, queryId) {
             //字幕数据
             var parentDoms = hash();
             var ancestorDoms = hash();
             var contentsFragment;
             var dom;
             var pageIndex = pageId - 1;
             if (subtitles) {
                 //获取文档节点
                 contentsFragment = Xut.Contents.contentsFragment[pageId];

                 //如果maskId大于9000默认为处理
                 var isMask = pageId > 9000;
                 if (isMask) {
                     //指定页码编号
                     pageIndex = Xut.Presentation.GetPageIndex();
                 }

                 //找到对应的节点
                 _.each(subtitles, function (data) {
                     //'Content_0_1' 规则 类型_页码（0开始）_id
                     if (!parentDoms[data.id]) {
                         dom = contentsFragment['Content_' + pageIndex + '_' + data.id];
                         ancestorDoms[data.id] = dom;
                         var $dom = $(dom);
                         if ($dom.length) {
                             var _div = $dom.find('div').last();
                             if (_div.length) {
                                 parentDoms[data.id] = _div[0];
                             }
                         }
                     }
                 });
             }

             return {
                 parents: parentDoms,
                 ancestors: ancestorDoms
             };
         }

         /**
          * 检测数据是否存在
          * @return {[type]}         [description]
          */
         function checkRepeat(pageId, queryId, type) {
             var pBox = pageBox[type];
             if (pBox && pBox[pageId] && pBox[pageId][queryId]) {
                 return true;
             }
             return false;
         }

         /**
          * 组合热点音频数据结构
          * data, pageId, queryId, type
          * 数据，页码编号，videoId, 查询的类型
          * @return {[type]}         [description]
          */
         function combination(data, pageId, queryId, type, eleName) {
             var tempDoms;
             if (!pageBox[type]) {
                 pageBox[type] = hash();
             }
             if (!pageBox[type][pageId]) {
                 pageBox[type][pageId] = hash();
             }
             //有字幕处理
             if (data.theTitle) {
                 var subtitles = parseJSON(data.theTitle);
             }
             //配置音频结构
             return pageBox[type][pageId][queryId] = {
                 'trackId': data.track, //音轨
                 'url': data.md5, //音频名字
                 'subtitles': subtitles,
                 'audioId': queryId,
                 'data': data
             };
         }

         /**
          * 装配音频数据
          * @param  {int} pageId    页面id或节的分组id
          * @param  {int} queryId   查询id,支持activityId,audioId
          * @param  {string} type   音频来源类型[动画音频,节音频,热点音频]
          */
         function deployAudio(pageId, queryId, type, actionData) {
             //避免复重查询
             if (checkRepeat(pageId, queryId, type)) {
                 return false;
             }
             //解析合集数据
             var data = parseData(type, queryId);
             //存在音频文件
             if (data && data.md5) {
                 //新的查询
                 var ret = combination(data, pageId, queryId, type, actionData);
                 //混入新的动作数据
                 //2015.9.24
                 //音频替换图片
                 //触发动画
                 if (actionData) {
                     _.extend(ret, actionData, {
                         action: true //快速判断存在动作数据
                     });
                 }
             }
         }

         //===============================================
         //
         //              初始化加载音频
         //
         //===============================================

         /**
          * 检查要打断的音频
          * @param  {[type]} type    音频类型
          * @param  {[type]} pageId  [description]
          * @param  {[type]} queryId [description]
          * @param  {[type]} pageBox [description]
          * @return {boolen}         不打断返回true,否则返回false
          */
         function checkBreakAudio(type, pageId, queryId, pageBox) {
             var playObj = playBox[type][pageId][queryId],
                 trackId = pageBox.trackId,
                 _trackId = playObj.trackId;

             //如果是节音频，且地址相同，则不打断
             if (type == SEASON && playObj.url == pageBox.url) {
                 return true;
             }

             //如果要用零音轨||零音轨有音乐在播||两音轨相同
             //则打断
             if (trackId == 0 || _trackId == 0 || trackId == _trackId) {
                 playObj.end();
                 delete playBox[type][pageId][queryId];
             }
             return false;
         }

         /**
          * 播放音频之前检查
          * @param  {int} pageId    [description]
          * @param  {int} queryId    查询id
          * @param  {string} type    决定video表按哪个字段查询
          * @return {object}         音频对象/不存在为null
          */
         function preCheck(pageId, queryId, type) {
             var t,
                 p,
                 q,
                 playObj = pageBox[type][pageId][queryId],
                 seasonAudio = null;
             for (t in playBox) {
                 for (p in playBox[t]) {
                     for (q in playBox[t][p]) {
                         if (checkBreakAudio(t, p, q, playObj)) {
                             seasonAudio = playBox[t][p][q];
                         }
                     }
                 }
             }
             return seasonAudio;
         }

         /**
          * 加载音频对象
          * @return {[type]}         [description]
          */
         function loadAudio(pageId, queryId, type) {
             //找到页面对应的音频
             //类型=》页面=》指定音频Id
             var pageObj = pageBox[type][pageId][queryId];
             //检测
             var seAudio = preCheck(pageId, queryId, type);

             //播放音频时关掉视频
             Xut.VideoManager.clearVideo();

             //构建播放列表
             if (!playBox[type]) {
                 playBox[type] = hash();
             }
             if (!playBox[type][pageId]) {
                 playBox[type][pageId] = hash();
             }
             //假如有字幕信息
             //找到对应的文档对象
             if (pageObj.subtitles) {
                 var tempDoms = getParentDom(pageObj.subtitles, pageId, queryId);
             }

             //播放完成处理
             pageObj.innerCallback = function (audio) {
                 if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
                     audio.end();
                     delete playBox[type][pageId][queryId];
                 }
             };

             //new播放对象
             var newObj = seAudio || new html5Audio(pageObj, tempDoms);
             newObj.play();

             //存入播放对象池
             playBox[type][pageId][queryId] = newObj;
         }

         /**
          * 交互点击
          * @param  {int} pageId     [description]
          * @param  {int} queryId    [description]
          * @param  {string} type    ACTIVIT
          * @return {[type]}         [description]
          */
         function loadTiggerAudio(pageId, queryId, type) {
             var playObj, status;
             if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
                 playObj = playBox[type][pageId][queryId];
                 status = playObj.audio ? playObj.status : null;
             }
             switch (status) {
                 case 'playing':
                     playObj.pause();
                     break;
                 case 'paused':
                     playObj.play();
                     break;
                 default:
                     loadAudio(pageId, queryId, type);
                     break;
             }
         }

         /**
          * 清理全部音频
          * @return {[type]} [description]
          */
         function removeAudio() {
             var flag = false,
                 t,
                 p,
                 a;
             for (t in playBox) {
                 for (p in playBox[t]) {
                     for (a in playBox[t][p]) {
                         playBox[t][p][a].end();
                         flag = true;
                     }
                 }
             }
             initBox();
             return flag;
         }

         var out = {

             ///////////////////
             //1 独立音频处理, 音轨/跨页面 //
             //2 动画音频,跟动画一起播放与销毁
             ///////////////////

             //自动播放触发接口
             autoPlay: function autoPlay(pageId, activityId, actionData) {
                 deployAudio(pageId, activityId, ACTIVIT, actionData);
                 loadAudio(pageId, activityId, ACTIVIT);
             },

             //手动触发
             trigger: function trigger(pageId, activityId, actionData) {
                 deployAudio(pageId, activityId, ACTIVIT, actionData);
                 loadTiggerAudio(pageId, activityId, ACTIVIT);
             },

             //动画音频触发接口
             contentAudio: function contentAudio(pageId, audioId) {
                 deployAudio(pageId, audioId, ANIMATE);
                 loadAudio(pageId, audioId, ANIMATE);
             },

             //节音频触发接口
             seasonAudio: function seasonAudio(seasonAudioId, audioId) {
                 deployAudio(seasonAudioId, audioId, SEASON);
                 loadAudio(seasonAudioId, audioId, SEASON);
             },

             //挂起音频
             hangUpAudio: function hangUpAudio() {
                 var t, p, a;
                 for (t in playBox) {
                     for (p in playBox[t]) {
                         for (a in playBox[t][p]) {
                             playBox[t][p][a].pause();
                         }
                     }
                 }
             },

             //销毁动画音频
             clearContentAudio: function clearContentAudio(pageId) {
                 if (!playBox[ANIMATE] || !playBox[ANIMATE][pageId]) {
                     return false;
                 }
                 var playObj = playBox[ANIMATE][pageId];
                 if (playObj) {
                     for (var i in playObj) {
                         playObj[i].end();
                         delete playBox[ANIMATE][pageId][i];
                     }
                 }
             },

             //清理音频
             clearAudio: function clearAudio(pageId) {
                 if (pageId) {
                     //如果只跳槽关闭动画音频
                     out.clearContentAudio(pageId);
                 } else {
                     removeAudio(); //多场景模式,不处理跨页面
                 }
             }

         };

         return out;
     };

     Xut.AudioManager = AudioManager();

     /**
      * 视频和网页模块（统一整合到VideoClass里面了）
      * 这里有四种播放器:
      *    1：基于html5原生实现的video标签 for ios
      *    2：基于phoneGap插件实现的media  for android
      *    3: 基于videoJS用flash实现的播放 for pc
      *    4: 用于插入一个网页的webview
      */

     var VideoPlayer = null;
     var noop$1 = function noop() {};
     var supportVideo = function () {
         var video = document.createElement('video'),
             type = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
         return !!video.canPlayType && "probably" == video.canPlayType(type);
     }();
     var supportFlash = function () {
         var i_flash = false;

         if (navigator.plugins) {
             for (var i = 0; i < navigator.plugins.length; i++) {
                 if (navigator.plugins[i].name.toLowerCase().indexOf("shockwave flash") != -1) {
                     i_flash = true;
                 }
             }
         }
         return i_flash;
     }();
     //移动端浏览器平台
     if (Xut.plat.isBrowser) {
         VideoPlayer = Video5;
     } else {
         //检测平台
         if (Xut.plat.isIOS || top.EduStoreClient) {
             //如果是ibooks模式
             if (Xut.IBooks.Enabled) {
                 VideoPlayer = VideoJS;
             } else {
                 //如果是ios或读酷pc版则使用html5播放
                 VideoPlayer = Video5;
             }
         } else if (Xut.plat.isAndroid) {
             //android平台
             VideoPlayer = _Media$1;
         }
     }

     /**
      * @param {[type]} options   [description]
      *   options.videoId;
      *   options.pageId;
      *   options.pageUrl;
      *   options.left;
      *   options.top;
      *   options.width;
      *   options.height;
      *   options.padding;
      *   options.category;
      * @param {[type]} container 视频元素容器
      */

     function VideoClass(options, container) {
         options.container = container;
         if ('video' == options.category) {
             this.video = VideoPlayer(options);
         } else if ('webpage' == options.category) {
             this.video = WebPage(options);
         } else {
             console.log('options.category must be video or webPage ');
         }
     }

     VideoClass.prototype = {
         play: function play() {
             //隐藏工具栏
             Xut.View.Toolbar("hide");
             this.video.play();
         },
         stop: function stop() {
             //显示工具栏
             Xut.View.Toolbar("show");
             this.video.stop();
         },
         close: function close() {
             this.video.close();
         }
     };

     // 网页
     function WebPage(options) {

         var pageUrl = options.pageUrl;

         //跳转app市场
         //普通网页是1 
         //跳转app市场就是2
         if (options.hyperlink == 2) {
             //跳转到app市场
             window.open(pageUrl);
             //数据统计
             $.get('http://www.appcarrier.cn/index.php/adplugin/recordads?aid=16&esbId=ios');
         } else {

             var padding = options.padding || 0,
                 width = options.width,
                 height = options.height,
                 videoId = options.videoId,
                 left = options.left,
                 top = options.top,
                 $videoNode,
                 eleWidth,
                 eleHeight;

             if (padding) {
                 eleWidth = width - 2 * padding;
                 eleHeight = height - 2 * padding;
             } else {
                 eleWidth = width;
                 eleHeight = height;
             }

             $videoNode = $('<div id="videoWrap_' + videoId + '" style="position:absolute;left:' + left + 'px;top:' + top + 'px;width:' + width + 'px;height:' + height + 'px;z-index:' + Xut.zIndexlevel() + '">' + '<div style="position:absolute;left:' + padding + 'px;top:' + padding + 'px;width:' + eleWidth + 'px;height:' + eleHeight + 'px;">' + '<iframe src="' + pageUrl + '" style="position:absolute;left:0;top:0;width:100%;height:100%;"></iframe>' + '</div>' + '</div>');

             options.container.append($videoNode);
         }

         function play() {
             $videoNode && $videoNode.show();
         }

         function stop() {
             $videoNode && $videoNode.hide();
         }

         function close() {
             if ($videoNode) {
                 $videoNode.remove();
                 $videoNode = null;
             }
         }

         return {
             play: play,
             stop: stop,
             close: close
         };
     }

     /**
      * 安卓phonegap播放器
      * @param  {[type]} options [description]
      * @return {[type]}         [description]
      */
     function _Media$1(options) {
         var url = MMXCONFIG ? options.url : options.url.substring(0, options.url.lastIndexOf('.')),
             width = options.width,
             height = options.height,
             top = options.top || 0,
             left = options.left || 0;

         function play() {
             //var calculate = Xut.config.proportion.calculateContainer();
             //top += Math.ceil(calculate.top);
             //left += Math.ceil(calculate.left);
             Xut.Plugin.VideoPlayer.play(function () {
                 //成功回调
             }, function () {
                 //失败回调
             }, Xut.config.videoPath() + url, 1, left, top, height, width);
         }

         function close() {
             Xut.Plugin.VideoPlayer.close();
         }

         play();

         return {
             play: play,
             stop: close,
             close: close
         };
     }

     /**
      *   html5的video播放器
      *   API :
      *   play();播放
      *   stop();    //停止播放并隐藏界面
      *   destroy(); //清除元素节点及事件绑定
      *  demo :
      *  var video = new Video({url:'1.mp4',width:'320',...});
      *  video.play();
      */

     function Video5(options) {

         var container = options.container || $('body'),
             url = Xut.config.videoPath() + options.url,
             width = options.width,
             height = options.height,
             top = options.top,
             left = options.left,
             zIndex = options.zIndex,

         /*创建播放器*/
         $videoWrap = $('<div></div>');

         var $video = $(document.createElement('video'));

         //音频对象
         var video = $video[0];

         video.play();

         $video.css({
             width: width,
             height: height
         }).attr({
             'src': url,
             'controls': 'controls',
             'autoplay': 'autoplay'
         });

         $videoWrap.append($video).css({
             position: 'absolute',
             'z-index': -1,
             top: top,
             left: left,
             width: 0,
             height: 0
         });

         //播放
         function play() {
             $videoWrap.show();
             video.play();
         }

         //停止
         function stop() {
             video.pause();
             //复位视频
             if (video.duration) {
                 video.currentTime = 0.01;
             }
             //在全屏时无法隐藏元素,须先退出
             //this.video.webkitExitFullScreen();
             $videoWrap.hide();

             //用于启动视频
             if (options.startBoot) {
                 options.startBoot();
                 destroy();
             }
         }

         function error() {
             //用于启动视频
             if (options.startBoot) {
                 options.startBoot();
                 destroy();
             }
         }

         /**
          * 防止播放错误时播放界面闪现
          * @return {[type]} [description]
          */
         function start() {
             $videoWrap.css({
                 width: width + 'px',
                 height: height + 'px',
                 zIndex: zIndex
             });
         }

         //销毁
         function destroy() {
             video.removeEventListener('ended', stop, false);
             video.removeEventListener('error', error, false);
             video.removeEventListener('loadeddata', start, false);
             video.removeEventListener('webkitendfullscreen', stop, false);
             $videoWrap.hide().remove();
         }

         container.append($videoWrap);

         video.addEventListener('ended', stop, false);
         video.addEventListener('error', error, false);
         video.addEventListener('loadeddata', start, false);
         video.addEventListener('webkitendfullscreen', stop, false);

         return {
             play: play,
             stop: stop,
             close: destroy
         };
     };

     /**
      * https://github.com/videojs/video.js/blob/master/docs/guides/setup.md
      * 基于video.js的web播放器,在pc端flash优先
      * @param {[type]} options [description]
      */

     function VideoJS(options) {
         var container = options.container || $('body'),
             videoId = options.videoId,
             url = Xut.config.videoPath() + options.url,
             width = options.width,
             height = options.height,
             zIndex = options.zIndex,
             top = options.top,
             left = options.left,
             video,
             source,
             player,
             api;

         video = document.createElement('video');
         source = document.createElement('source');
         source.setAttribute('src', url);
         source.setAttribute('type', 'video/mp4');
         video.id = 'video_' + videoId;
         video.className = "video-js vjs-sublime-skin";
         video.appendChild(source);
         container.append(video);
         //指定本地的swf地址取代网络地址
         videojs.options.flash.swf = "lib/data/video-js.swf";

         var clear = function clear() {
             //结束后清理自己
             Xut.VideoManager.removeVideo(options.pageId);
         };

         //videojs是videojs定义的全局函数
         player = videojs(video, {
             //视频引擎顺序,位置排前面的优先级越高
             "techOrder": ["html5", "flash"],
             //预加载
             "preload": "auto",
             //是否有控制条
             "controls": true,
             "autoplay": true,
             "width": width,
             "height": height,
             //播放元素相关设置
             children: {
                 //暂停时是否显示大大的播放按钮
                 bigPlayButton: false,
                 //是否显示错误提示
                 errorDisplay: false,
                 //是否显示视频快照
                 posterImage: false,
                 //是否显示字幕
                 textTrackDisplay: false
             },
             //控制条相关设置
             controlBar: {
                 //是否显示字幕按钮
                 captionsButton: false,
                 chaptersButton: false,
                 liveDisplay: false,
                 //是否显示剩余时间
                 remainingTimeDisplay: false,
                 //是否显示子标题按钮
                 subtitlesButton: false,
                 //是否显示回放菜单按钮
                 playbackRateMenuButton: false,
                 //是否显示时间分隔符"/"
                 timeDivider: false,
                 //是否显示当前视频的当前时间值
                 currentTimeDisplay: false,
                 //是否显示视频时长
                 durationDisplay: false
             }
         }, function () {
             //可以播放时提升层级，防止闪现
             this.on('canplay', function () {
                 wrap.style.zIndex = zIndex;
             });

             //播放完毕后自动关闭
             this.on('ended', function () {
                 //结束后清理自己
                 clear();
             });

             this.on('error', function () {
                 clear();
             });

             //因为没有关闭按钮,又不想自己做,就把全屏变成关闭好了.
             this.on("touchend mouseup", function (e) {
                 var className = e.target.className.toLowerCase();
                 if (-1 != className.indexOf('vjs-fullscreen-control')) {
                     clear();
                 }
             });
         });

         //修正视频样式
         var wrap = player.el(),
             videoElement = wrap.children[0];
         wrap.style.left = left + 'px';
         wrap.style.top = top + 'px';
         wrap.style.zIndex = -1;

         api = {
             play: noop$1,

             stop: function stop() {
                 player.stop();
             },

             close: function close() {
                 player && player.dispose();
                 player = null;
             }
         };

         return api;
     }

     Xut.Video5 = Video5;

     Xut.Video = VideoClass;

     /*
         视频和远程网页管理模块
     */

     //综合管理video, webpage
     function VideoManager() {
         this.pageBox = {}; //当前页面包含的视频数据
         this.playBox = {}; //播放过的视频数据 （播放集合）
     }

     /**
      *  参数:
      *    pageId    就是chapterId,对应每一个页面
      *    videoId   对应每一个视频热点的ID
      *    container 容器
      */

     VideoManager.prototype = {

         //=============消息接口================
         //

         //自动播放
         autoPlay: function autoPlay(pageId, activityId, container) {
             this.initVideo.apply(this, arguments);
         },

         //手动播放
         trigger: function trigger(pageId, activityId, container) {
             this.initVideo.apply(this, arguments);
         },

         //=================视频调用===========================

         //触发视频
         initVideo: function initVideo(pageId, activityId, container) {
             //解析数据
             this.parseVideo(pageId, activityId);
             //调用播放
             this.loadVideo(pageId, activityId, container);
         },

         //=================视频数据处理===========================

         //处理重复数据
         // 1:pageBox能找到对应的 videoId
         // 2:重新查询数据
         parseVideo: function parseVideo(pageId, activityId) {
             //复重
             if (this.checkRepeat(pageId, activityId)) {
                 return;
             }
             var data = Xut.data.query('Video', activityId);
             //新的查询
             this.deployVideo(data, pageId, activityId);
         },

         //检测数据是否存在
         checkRepeat: function checkRepeat(pageId, activityId) {
             var chapterData = this.pageBox[pageId];
             //如果能在pageBox找到对应的数据
             if (chapterData && chapterData[activityId]) {
                 return true;
             }
             return false;
         },

         //配置视频结构
         deployVideo: function deployVideo(data, pageId, activityId) {
             var proportion = Xut.config.proportion,
                 screenSize = Xut.config.screenSize,
                 videoInfo = {
                 'pageId': pageId,
                 'videoId': activityId,
                 'url': data.md5,
                 'pageUrl': data.url,
                 'left': data.left * proportion.left || 0,
                 'top': data.top * proportion.top || 0,
                 'width': data.width * proportion.width || screenSize.width,
                 'height': data.height * proportion.height || screenSize.height,
                 'padding': data.padding * proportion.left || 0,
                 'zIndex': data.zIndex || 2147483647,
                 'background': data.background,
                 'category': data.category,
                 'hyperlink': data.hyperlink
             };

             if (babelHelpers.typeof(this.pageBox[pageId]) != 'object') {
                 this.pageBox[pageId] = {};
             }

             this.pageBox[pageId][activityId] = videoInfo;
         },

         //=================视频动作处理============================

         //加载视频
         loadVideo: function loadVideo(pageId, activityId, container) {
             var playBox = this.playBox,
                 data = this.pageBox[pageId][activityId];

             //播放视频时停止所有的音频
             //视频的同时肯能存在音频
             // Xut.AudioManager.clearAudio();

             //this.beforePlayVideo(pageId,videoId)
             //search video cache
             if (playBox[pageId] && playBox[pageId][activityId]) {
                 //console.log('*********cache*********');
                 playBox[pageId][activityId].play();
             } else {
                 //console.log('=========new=============');
                 if (babelHelpers.typeof(playBox[pageId]) !== 'object') {
                     playBox[pageId] = {};
                 }
                 //cache video object
                 playBox[pageId][activityId] = new VideoClass(data, container);
             }
         },

         //播放视频之前检查要停的视频
         beforePlayVideo: function beforePlayVideo(pageId, activityId) {},

         //清理移除页的视频
         removeVideo: function removeVideo(pageId) {
             var playBox = this.playBox,
                 pageBox = this.pageBox;

             //清理视频
             if (playBox && playBox[pageId]) {
                 for (var activityId in playBox[pageId]) {
                     playBox[pageId][activityId].close();
                 }
                 delete this.playBox[pageId];
             }
             //清理数据
             if (pageBox && pageBox[pageId]) {
                 delete this.pageBox[pageId];
             }
         },

         //清理全部视频
         clearVideo: function clearVideo() {
             var playBox = this.playBox,
                 flag = false; //记录是否处理过销毁状态

             for (var pageId in playBox) {
                 for (var activityId in playBox[pageId]) {
                     playBox[pageId][activityId].close();
                     flag = true;
                 }
             }

             this.playBox = {};
             this.pageBox = {};
             return flag;
         },

         //离开页面
         leavePage: function leavePage(pageId) {
             var playBox = this.playBox;
             if (playBox && playBox[pageId]) {
                 for (var activityId in playBox[pageId]) {
                     playBox[pageId][activityId].stop();
                 }
             }
         },

         //显示按钮
         showIconFlag: function showIconFlag(activityId) {},

         //隐藏按钮
         hideIconFlag: function hideIconFlag(activityId) {}
     };

     Xut.VideoManager = new VideoManager();

     /**
      * 用css3实现的忙碌光标
      * @return {[type]} [description]
      */
     function cursor() {
         var sWidth = window.innerWidth,
             sHeight = window.innerHeight,
             width = Math.min(sWidth, sHeight) / 4,
             space = Math.round((sHeight - width) / 2),
             delay = [0, 0.9167, 0.833, 0.75, 0.667, 0.5833, 0.5, 0.41667, 0.333, 0.25, 0.1667, 0.0833],
             deg = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330],
             i = 12,
             prefix = Xut.plat.prefixStyle,
             html;

         html = '<div style="width:' + width + "px;height:" + width + 'px;margin:' + space + 'px auto;">';
         html += '<div style="height:30%;"></div><div class="xut-busy-middle">';

         while (i--) {
             html += '<div class="xut-busy-spinner" style="' + prefix('transform') + ':rotate(' + deg[i] + 'deg) translate(0,-142%);' + prefix('animation-delay') + ':-' + delay[i] + 's;"></div>';
         }

         html += '</div><div class="xut-busy-text"></div></div>';

         Xut.View.busyIcon = $('#busyIcon').html(html);
     }

     /**
      * 场景控制器
      * 场景对象之间的顺序处理
      * @return {[type]} [description]
      */

     //场景层级控制
     var zIndex = 999999;

     //场景合集
     //主场景
     //副场景
     var sceneCollection = {
         //场景顺序
         scenarioStack: [],
         //场景链表
         scenarioChain: []
     };

     var sceneControll = {

         //场景层级控制
         createIndex: function createIndex() {
             return --zIndex;
         },

         //设置一个新场景
         add: function add(scenarioId, relevant, sceneObj) {
             sceneCollection.scenarioStack.push(scenarioId);
             sceneCollection['scenarioId->' + scenarioId] = sceneObj;
             //场景链表,拥挤记录场景的加载上一页
             sceneCollection.scenarioChain.push({
                 'scenarioId': scenarioId,
                 'chapterId': relevant
             });
             return sceneObj;
         },

         //=============== 场景链相关方法 ==========================

         //取出上一个场景链
         takeOutPrevChainId: function takeOutPrevChainId() {
             var pre = sceneCollection.scenarioChain.pop();
             if (sceneCollection.scenarioChain.length > 1) {
                 return sceneCollection.scenarioChain.pop();
             } else {
                 return sceneCollection.scenarioChain[0];
             }
         },

         //检测重复
         checkToRepeat: function checkToRepeat(seasonId) {
             var last,
                 len = sceneCollection.scenarioChain.length;
             if (len > 1) {
                 last = sceneCollection.scenarioChain[len - 2];
             } else {
                 last = sceneCollection.scenarioChain[len - 1];
             }

             //往回跳一级
             if (last['scenarioId'] == seasonId) {
                 this.takeOutPrevChainId();
             }

             //直接会跳到主场景
             if (sceneCollection.scenarioStack[0] == seasonId) {
                 var scenarioChain = sceneCollection.scenarioChain.shift();
                 sceneCollection.scenarioChain.length = 0;
                 sceneCollection.scenarioChain.push(scenarioChain);
             }
         },

         /**
          * 返回活动对象
          * @return {[type]} [description]
          */
         containerObj: function containerObj(scenarioId) {
             if (scenarioId === 'current') {
                 var scenarioStack = sceneCollection.scenarioStack;
                 scenarioId = scenarioStack[scenarioStack.length - 1];
             }
             return sceneCollection['scenarioId->' + scenarioId];
         },

         /**
          * 找到索引位置的Id
          * @param  {[type]} scenarioId [description]
          * @return {[type]}            [description]
          */
         findIndexOfId: function findIndexOfId(scenarioId) {
             return sceneCollection.scenarioStack.lastIndexOf(scenarioId);
         },

         //删除指定场景引用
         remove: function remove(scenarioId) {
             var indexOf = this.findIndexOfId(scenarioId);
             //删除索引
             sceneCollection.scenarioStack.splice(indexOf, 1);
             //删除场景对象区域
             delete sceneCollection['scenarioId->' + scenarioId];
         },

         //销毁所有场景
         destroyAllScene: function destroyAllScene() {
             var cache = _.clone(sceneCollection.scenarioStack);
             _.each(cache, function (scenarioId) {
                 sceneCollection['scenarioId->' + scenarioId].destroy();
             });
             sceneCollection.scenarioChain = [];
         },

         /**
          * 重写场景的顺序编号
          * 用于记录最后一次跳转的问题
          * @return {[type]} [description]
          */
         rewrite: function rewrite(scenarioId, chapterId) {
             _.each(sceneCollection.scenarioChain, function (scenarioChain) {
                 if (scenarioChain.scenarioId == scenarioId) {
                     scenarioChain.chapterId = chapterId;
                 }
             });
         },

         //暴露接口
         expose: function expose() {
             return sceneCollection;
         },

         //===============================================
         //
         //			记录历史缓存
         //
         //===============================================

         //解析序列
         sequence: function sequence(scenarioId, currPageIndex) {
             var chains = sceneCollection.scenarioChain;
             //有多个场景关系,需要记录
             if (chains.length > 1) {
                 var history = [];
                 //只刷新当前场景的页面
                 _.each(chains, function (chain) {
                     if (chain.scenarioId == scenarioId) {
                         history.push(chain.scenarioId + '-' + chain.chapterId + '-' + currPageIndex);
                     } else {
                         history.push(chain.scenarioId + '-' + chain.chapterId);
                     }
                 });
                 return history;
             }
         },

         //反解析
         seqReverse: function seqReverse(chains) {
             var chains = chains.split(",");
             var chainsNum = chains.length;

             if (chainsNum === 1) {
                 return false;
             }

             //如果只有2层
             if (chainsNum === 2) {
                 return chains[1];
             }

             //拼接作用域链
             //排除首页(已存在)
             //尾页(新创建)
             _.each(chains, function (chain, index) {
                 if (index >= 1 && index < chainsNum - 1) {
                     //从1开始吸入,排除最后一个
                     var chain = chain.split('-');
                     sceneCollection.scenarioChain.push({
                         'scenarioId': chain[0],
                         'chapterId': chain[1],
                         'pageIndex': chain[2]
                     });
                 }
             });
             return chains[chainsNum - 1];
         }
     };

     Xut.sceneController = sceneControll;

     /**
      *
      *  动作对象
      *      1 跳转页面
      *      2 打开系统程序
      *      3 加载子文档
      *
      */

     function Action$2(data) {

         _.extend(this, data);

         this.id = parseInt(this.id);

         this.actType = this.type;

         //加载数据
         this.setup(Xut.data.query('Action', this.id, 'activityId'));
     }

     Action$2.prototype = {

         setup: function setup(results) {
             var para1 = results.para1,
                 //跳转参数
             para2 = results.para2,
                 //ppt
             dbId = results._id;

             actionType = parseInt(results.actionType);

             //跳转或打开本地程序
             switch (actionType) {
                 case 0:
                     this.toPage(para1);
                     break;
                 case 1:
                     if (Xut.plat.isBrowser) return;
                     //打开插件
                     Xut.Plugin.OpenApp.openAppAction(para1, function (r) {}, function (e) {});
                     break;
                 case 2:
                     //子文档处理
                     this.loadSubdoc(para1, dbId);
                     break;
             }

             this.state = true;
         },

         open: function open() {
             this.state = true;
             //打开插件
             Xut.Plugin.OpenApp.openAppAction(para1, function (r) {}, function (e) {});
         },

         //跳转页面
         toPage: function toPage(para1) {
             para1 = JSON.parse(para1);
             if (para1.seasonId) {
                 Xut.View.GotoSlide(para1.seasonId, para1.chapterId);
             } else {
                 //向下兼容
                 Xut.View.GotoSlide(para1);
             }
         },

         /***********************************************************
          *
          *                   子文档处理
          *
          * **********************************************************/

         //加载子文档
         loadSubdoc: function loadSubdoc(path, dbId) {
             var self = this,
                 wapper,
                 configPath = 'www/content/subdoc/' + path + '/content/gallery/';

             //配置子文档加载路径
             window.XXTSUbDOC = {
                 'path': path,
                 'dbId': dbId
             };

             this.subPath = path;

             //构建子文档的容器
             wapper = this.$wapper = this.createWapper();

             Xut.nextTick({
                 'container': $(this.rootNode),
                 'content': wapper
             }, function () {
                 self.destroyCache();
             });
         },

         //iframe加载完毕
         iframeComplete: function iframeComplete() {
             var self = this;
             //关闭事件
             Xut.one('subdoc:dropApp', function () {
                 self.destroyCache('iframe', self.iframe[0].contentWindow);
             });
             //隐藏全局工具栏
             Xut.View.HideToolbar();
             Xut.isRunSubDoc = true;
             self.$wapper.css({
                 'opacity': '1'
             });
         },

         //获取iframe颞部window上下文
         destroyCache: function destroyCache(contentWindow) {
             var self = this,
                 iframe;

             if (contentWindow) {
                 iframe = true;
             } else {
                 contentWindow = window;
             }

             function clear() {
                 Xut.View.ShowToolbar();
                 self.$wapper.remove();
                 self.$wapper = null;
                 self.iframe = null;
                 self.rootNode = null;
                 Xut.isRunSubDoc = false;
             }

             try {
                 contentWindow.require("Dispatcher", function (c) {
                     if (iframe) {
                         //子文档操作
                         if (c.stopHandles()) {
                             c.promptMessage('再按一次将退出子目录！');
                         } else {
                             clear();
                         }
                     } else {
                         //父级操作
                         c.stopHandles();
                     }
                 });
             } catch (err) {
                 clear();
             }
         },

         createWapper: function createWapper() {
             var zIndex, str, dom, ifr;

             //层级设定
             if (this.zIndex === 0) {
                 zIndex = this.zIndex;
             } else {
                 zIndex = this.zIndex || Xut.zIndexlevel();
             }

             this.zIndex = zIndex;

             str = '<div id="Subdoc_{0}" style="z-index:{1};width:{2}px;height:{3}px;top:{4}px;left:{5}px;position:absolute;opacity:0" >' + '</div>';

             dom = String.format(str, this.id, zIndex, this.screenSize.width, this.screenSize.height, 0, 0);

             ifr = this.iframe = this.createIframe();

             return $(dom).append(ifr);
         },

         /**
          * 加载iframe
          * @return {[type]} [description]
          */
         createIframe: function createIframe() {
             var me = this,
                 path = 'content/subdoc/' + this.subPath + '/index.html?xxtParaIn=' + this.key,
                 ifr = document.createElement('iframe');

             ifr.id = 'iframe_' + this.id;
             ifr.src = path;
             ifr.style.width = '100%';
             ifr.style.height = '100%';
             ifr.sandbox = "allow-scripts allow-same-origin";
             ifr.frameborder = 0;
             if (ifr.attachEvent) {
                 ifr.attachEvent('onload', function () {
                     me.iframeComplete();
                 });
             } else {
                 ifr.onload = function () {
                     me.iframeComplete();
                 };
             }

             return $(ifr);
         }
     };

     var Action$1 = {

         createDom: function createDom(activityData, chpaterData, chapterId, pageIndex, zIndex, pageType) {
             var backgroundImage = '',

             //等比缩放
             width = activityData.scaleWidth,
                 height = activityData.scaleHeight,
                 top = activityData.scaleTop,
                 left = activityData.scaleLeft;

             var md5;

             //热点背景图
             if (md5 = activityData.md5) {
                 backgroundImage = "background-image: url(" + Xut.onfig.pathAddress + md5 + ");";
             }

             //==============创建触发点结构=============
             return String.format('<div id="{0}"' + ' data-belong = "{1}"' + ' data-delegate="Action"'
             // +' autoplay="{2}" ' svg打包不可以属性
              + ' style="cursor: pointer;width:{3}px;height:{4}px;left:{5}px;top:{6}px;background-size:100% 100%;position:absolute;z-index:{7};{8}"></div>', activityData.actType + "_" + activityData._id, pageType, activityData.autoPlay, width, height, left, top, zIndex, backgroundImage);
         },

         /**
          * 是否阻止全局事件派发
          * @type {Boolean}
          *   false 事件由全局接管派发
          *   false 事件由hotspot处理触发
          *   全局提供的事件接口
          *   {
          *       globalTouchStart
          *       globalTouchMove
          *       globalTouchEnd
          *   }
          */
         stopDelegate: false,

         /**
          * touchEnd 全局派发的点击事件
          * 如果stopGlobalEvent == ture 事件由全局派发
          */
         eventDelegate: function eventDelegate(data) {
             new Action$2(data);
         },

         //========复位对象==========
         //
         //  通过按物理键，关闭当前热点
         //
         //  @return 如果当前没有需要处理的Action,
         //  需要返回一个状态标示告诉当前是否应该退出应用
         //
         recovery: function recovery(opts) {
             if (this.state) {
                 this.state = false;
                 return true;
             } else {
                 return false;
             }
         }
     };

     /**
      * 文本类型
      */

     var Content = {

         //==========创建热点元素结构（用于布局可触发点）===============
         //
         //   预创建
         //
         createDom: function createDom(opts) {
             var sqlRet = opts.sqlRet,
                 pageIndex = opts.pageIndex;
             return function (rootEle, pageIndex) {
                 sqlRet['container'] = rootEle || opts.rootEle;
                 return sqlRet;
             };
         },

         /**
          * 绑定热点事件
          * 用户交互动作产生Action或者widget对象
          */
         bindEvent: function bindEvent() {},

         /**
          * 在当前页面自动触发的通知
          *
          * 作用：
          *   生成Action或者widget触发点对象
          *
          * 有一种情况，如果当前Action对象，已存在必须要做重复处理
          *
          * Xut.ActionMgr.getOne(key) 接口，是获取当前是否有实例对象的引用
          *
          */
         autoPlay: function autoPlay(scopeComplete) {
             return this.autoPlay && this.autoPlay(scopeComplete);
         },

         /**
          * 开始翻页
          *
          * 滑动页面的时候触发
          *
          * 处理要关闭的对象
          *
          * 比如（音频，视频），不能停留到下一个页面,滑动必须立刻关闭或者清理销毁
          *
          * @param  {[type]} this  当前活动对象
          *
          */
         flipOver: function flipOver() {
             return this.flipOver();
         },

         /**
          * 翻页完成
          * @return {[type]} [description]
          */
         flipComplete: function flipComplete() {
             return this.flipComplete();
         },

         /**
          * 销毁接口
          *
          * 1 销毁页面绑定的事件
          *   A hotspotBind 接口绑定的的热点触发事件
          *   B autoPlay 等接口 产生的具体Action对象事件
          *
          * 2 销毁热点元素的在控制器中的引用
          *
          * 3 清理页面结构
          *
          * 注：
          *   2,3操作暂时由控制器已经内部统一完成了,暂时只需要处理1销毁绑定的事件
          *
          * @param  {[type]} pageIndex    [页码标示]
          * @param  {[type]} rootEle      [根元素]
          * @return {[type]}              [description]
          */
         destroy: function destroy() {
             return this.destroy();
         },

         /**
          *  复位状态通知
          *
          *  作用：用户按页面右上角返回，或者pad手机上的物理返回键
          *
          *  那么：
          *      1 按一次， 如果当前页面有活动热点，并且热点对象还在可视活动状态（比如文本，是显示，音频正在播放）
          *        那么则调用此方法，做复位处理，即文本隐藏，音频关闭
          *        然后返回true, 用于反馈给控制器,停止下一步调用
          *        按第二次,则退出页面
          *
          *     2 按一次，如果没有活动的对象，return false,这直接退出页面
          *
          * @param  {[type]} activeObejct [description]
          * @return {[type]}              [description]
          */
         recovery: function recovery(opts) {
             return this.recovery && this.recovery();
         }

     };

     //临时音频动作数据
     var tempData = {};

     var Media = {

         createDom: function createDom(activityData, chpaterData, chapterId, pageIndex, zIndex, pageType) {
             var width = activityData.scaleWidth,
                 height = activityData.scaleHeight,
                 top = activityData.scaleTop,
                 left = activityData.scaleLeft,
                 actType = activityData.actType,
                 id = activityData._id;

             //如果没有宽高则不创建绑定节点
             if (!width || !height) return '';

             var category = activityData.category;
             var mediaIcon,
                 mediaIconSize,
                 posX,
                 posY,
                 start,
                 stop,
                 itemArray,
                 startImage = "";

             var screenSize = Xut.config.screenSize;

             //只针对网页插件增加单独的点击界面
             if (category == 'webpage' && width > 200 && height > 100 && width <= screenSize.width && height <= screenSize.height) {
                 mediaIcon = 'background-image:url(images/icons/web_hotspot.png)';
             }

             //解析音乐动作
             //冒泡动作靠节点传递数据
             if (itemArray = activityData.itemArray) {
                 itemArray = parseJSON(itemArray);
                 start = itemArray[0];
                 stop = itemArray[1];
                 tempData[id] = {};
                 if (start) {
                     if (start.startImg) {
                         startImage = start.startImg;
                         tempData[id]['startImg'] = startImage;
                         startImage = 'background-image:url(' + startImage + ');';
                     }
                     if (start.script) {
                         tempData[id]['startScript'] = start.script;
                     }
                 }
                 if (stop) {
                     if (stop.stopImg) {
                         tempData[id]['stopImg'] = stop.stopImg;
                     }
                     if (stop.script) {
                         tempData[id]['stopScript'] = stop.script;
                     }
                 }
             }

             //首字母大写
             var mediaType = category.replace(/(\w)/, function (v) {
                 return v.toUpperCase();
             });

             //创建音频对象
             //Webpage_1
             //Audio_1
             //Video_1
             var tpl = String.format('<div id="{0}"' + ' data-belong="{1}"' + ' data-delegate="{2}"' + ' style="width:{3}px;height:{4}px;left:{5}px;top:{6}px;z-index:{7};{8}background-size:100% 100%;position:absolute;">', mediaType + "_" + id, pageType, category, width, height, left, top, zIndex, startImage);

             //如果有视频图标
             if (mediaIcon) {
                 mediaIconSize = 74;
                 posX = (width - mediaIconSize) / 2;
                 posY = (height - mediaIconSize) / 2;

                 tpl += String.format('<div id="icon_{0}"' + ' type="icon"' + ' style="position:absolute;top:{1}px;left:{2}px;width:{3}px;height:{4}px;{5};">' + ' </div>', id, posY, posX, mediaIconSize, mediaIconSize, mediaIcon);
             }

             tpl += '</div>';

             return tpl;
         },

         //仅创建一次
         //data传递参数问题
         onlyCreateOnce: function onlyCreateOnce(id) {
             var data;
             if (data = tempData[id]) {
                 delete tempData[id];
                 return data;
             }
         },

         /**
          * touchEnd 全局派发的点击事件
          * 如果stopGlobalEvent == ture 事件由全局派发
          */
         eventDelegate: function eventDelegate(data) {
             var category, chapterId;
             if (category = data.target.getAttribute('data-delegate')) {
                 //触发类型
                 chapterId = Xut.Presentation.GetPageId(data.pageIndex);
                 /**
                  * 传入chapterId 页面ID
                  * activityId    视频ID
                  * eleName       节点名  //切换控制
                  * 根节点
                  */
                 if (category == 'audio') {
                     Xut.AudioManager.trigger(chapterId, data.activityId, this.onlyCreateOnce(data.id));
                 } else {
                     Xut.VideoManager.trigger(chapterId, data.activityId, $(data.rootNode));
                 }
             }
         },

         //自动运行
         autoPlay: function autoPlay(data) {
             var category = data.category;
             if (!category) return;
             var rootNode = data.rootNode,
                 pageIndex = data.pageIndex,
                 chapterId = data.chapterId,
                 activityId = data.id,
                 triggerType = category == 'audio' ? 'audioManager' : 'videoManager';

             //数据库视频音频不规则问题导致
             //首字母大写
             var mediaType = category.replace(/(\w)/, function (v) {
                 return v.toUpperCase();
             });

             //自动音频
             if (category == 'audio') {
                 Xut.AudioManager.autoPlay(chapterId, activityId, this.onlyCreateOnce(data.id));
             } else {
                 //自动视频
                 Xut.VideoManager.autoPlay(chapterId, activityId, rootNode);
             }
         }

     };

     /**
      * 创建iframe零件包装器
      */

     function iframeWidget(data) {

         var self = this;

         //获取数据
         _.extend(this, data);

         //创建页面零件包装器
         this.$wapper = this.createWapper();

         Xut.nextTick({
             'container': self.rootNode,
             'content': this.$wapper
         }, function () {
             self.rootNode = null;
             self.bindPMS();
         });

         return this;
     }

     iframeWidget.prototype = {

         /**
          * 创建包含容器
          * @return {[type]} [description]
          */
         createWapper: function createWapper() {
             var zIndex, str, dom, ifr;

             //层级设定
             if (this.zIndex === 0) {
                 zIndex = this.zIndex;
             } else {
                 zIndex = this.zIndex || Xut.zIndexlevel();
             }

             this.zIndex = zIndex;

             str = '<div id="iframeWidget_{0}" style="z-index:{1};width:{2}px;height:{3}px;top:{4}px;left:{5}px;position:absolute;" ></div>';

             dom = String.format(str, this.id, zIndex, this.width, this.height, this.top, this.left);

             ifr = this.createIframe();

             this._iframe = ifr;

             return $(dom).append(ifr);
         },

         /**
          * 加载iframe
          * @return {[type]} [description]
          */
         createIframe: function createIframe() {
             var me = this,
                 path = 'content/widget/' + this.widgetId + '/index.html?xxtParaIn=' + this.key,
                 ifr = document.createElement('iframe');

             ifr.id = 'iframe_' + this.id;
             ifr.src = path;
             ifr.style.width = '100%';
             ifr.style.height = '100%';
             ifr.sandbox = "allow-scripts allow-same-origin";
             ifr.frameborder = 0;
             if (ifr.attachEvent) {
                 ifr.attachEvent('onload', function () {
                     me.iframeComplete();
                 });
             } else {
                 ifr.onload = function () {
                     me.iframeComplete();
                 };
             }
             return ifr;
         },

         /**
          * iframe加载完毕回调
          * @return {[type]} [description]
          */
         iframeComplete: function iframeComplete() {
             var me = this;
             var dataSource = this.loadData();
             var width = me._iframe.offsetWidth;
             var height = me._iframe.offsetHeight;

             if (dataSource.screenSize.width * 0.98 <= width && dataSource.screenSize.height * 0.98 <= height) {
                 Xut.View.Toolbar({
                     show: 'button',
                     hide: 'controlBar'
                 });
             } else if (dataSource.screenSize.width * 0.7 <= width && dataSource.screenSize.height * 0.7 <= height) {
                 Xut.View.Toolbar({
                     show: 'button'
                 });
             }

             this.PMS.send({
                 target: me._iframe.contentWindow,
                 origin: '*',
                 type: 'loadData',
                 data: dataSource,
                 //消息传递完毕后的回调
                 success: success,
                 error: function error() {}
             });

             function success() {}
             // console.log('完毕')


             //iframe加载的状态
             me.state = true;
         },

         /**
          * ifarme内部，请求返回数据
          * @return {[type]} [description]
          */
         loadData: function loadData() {
             var item,
                 field,
                 source_export = [],
                 images = Xut.data['Image'],
                 token = null,
                 outputPara = this.inputPara,
                 items = outputPara.source;

             for (item in items) {
                 if (items.hasOwnProperty(item)) {
                     field = {};
                     token = images.item((parseInt(items[item]) || 1) - 1);
                     field['img'] = '../gallery/' + token.md5;
                     field['thumb'] = '';
                     field['title'] = token.imageTitle;
                     source_export.push(field);
                 }
             }

             outputPara.source = source_export;

             return outputPara;
         },

         /********************************************************************
          *
          *                   与iframe通讯接口
          *
          * ********************************************************************/

         /**
          * 与iframe通讯接口
          * @return {[type]} [description]
          */
         bindPMS: function bindPMS() {
             var me = this,
                 PMS = PMS || require("PMS"),
                 markId = this.id;

             this.PMS = PMS;
             //隐藏widget
             PMS.bind("onHideWapper" + markId, function (e) {
                 var $wapper = me.$wapper;
                 $wapper.hide();
                 me.state = false;
             }, '*');

             //全屏操作
             PMS.bind("onFullscreen" + markId, function (e) {
                 var $wapper = me.$wapper,
                     $iframe = $(me._iframe);

                 if (!$iframe.length) return;
                 //关闭视频
                 Xut.VideoManager.clearVideo();

                 $wapper.css({
                     width: '100%',
                     height: '100%',
                     zIndex: Xut.zIndexlevel(),
                     top: 0,
                     left: 0
                 });

                 //Widget全屏尺寸自动调整
                 if (e.full == false) {
                     var body = document.body,
                         width = parseInt(body.clientWidth),
                         height = parseInt(body.clientHeight),
                         rote = me.width / me.height,
                         getRote = function getRote(width, height, rote) {
                         var w = width,
                             h = width / rote;
                         if (h > height) {
                             h = height;
                             w = h * rote;
                         }
                         return {
                             w: parseInt(w),
                             h: parseInt(h)
                         };
                     },
                         size = getRote(width, height, rote),
                         left = (width - size.w) / 2,
                         top = (height - size.h) / 2;

                     $iframe.css({
                         width: size.w,
                         height: size.h,
                         position: 'absolute',
                         top: top,
                         left: left
                     });
                 }
                 //隐藏工作条
                 Xut.View.Toolbar("hide");
             }, '*');

             //还原初始窗口操作
             PMS.bind("onReset" + markId, function (e) {
                 var $wapper = me.$wapper,
                     $iframe = $(me._iframe);

                 if (!$iframe.length) return;

                 $wapper.css({
                     zIndex: me.zIndex,
                     width: me.width + 'px',
                     height: me.height + 'px',
                     top: me.top + 'px',
                     left: me.left + 'px'
                 });

                 //还原iframe样式
                 $iframe.css({
                     width: '100%',
                     height: '100%',
                     position: '',
                     top: '0',
                     left: '0'
                 });

                 Xut.View.Toolbar("show");
             }, '*');

             //显示工作条
             PMS.bind("onShowToolbar" + markId, function (e) {
                 // Xut.View.ShowToolbar();
             }, '*');

             //隐藏工作条
             PMS.bind("onHideToolbar" + markId, function (e) {
                 Xut.View.HideToolbar();
             }, '*');

             //跳转页面
             PMS.bind('scrollToPage' + markId, function (data) {
                 Xut.View.GotoSlide(data['ppts'], data['pageIndex']);
             }, '*');
         },

         //=============外部调用接口===================

         /**
          * 外部调用接口
          * 显示隐藏
          * @return {[type]} [description]
          */
         dispatchProcess: function dispatchProcess() {
             if (this.state) {
                 this.stop();
             } else {
                 this.start();
             }
         },

         /**
          * 开始
          * @return {[type]} [description]
          */
         start: function start() {
             var me = this;
             me.domWapper();
             this.PMS.send({
                 target: me._iframe.contentWindow,
                 url: me._iframe.src,
                 origin: '*',
                 type: 'onShow',
                 success: function success() {
                     // alert(123)
                 }
             });
             setTimeout(function () {
                 me.state = true;
             }, 0);
         },

         /**
          * 暂停
          * @return {[type]} [description]
          */
         stop: function stop() {
             var me = this;
             me.domWapper();
             this.PMS.send({
                 target: me._iframe.contentWindow,
                 url: me._iframe.src,
                 origin: '*',
                 type: 'onHide',
                 success: function success() {}
             });
             setTimeout(function () {
                 me.state = false;
             }, 0);
         },

         /**
          * 处理包装容器的状态
          * @return {[type]} [description]
          */
         domWapper: function domWapper() {
             if (this.state) {
                 this.$wapper.hide();
             } else {
                 this.$wapper.show();
             }
         },

         //复位
         recovery: function recovery() {
             var me = this;
             if (me.state) {
                 me.PMS.send({
                     target: me._iframe.contentWindow,
                     url: me._iframe.src,
                     origin: '*',
                     type: 'onHide',
                     success: function success() {}
                 });
                 me.domWapper();
                 me.state = false;
                 return true;
             }
             return false;
         },

         //销毁接口
         destroy: function destroy() {

             var me = this,
                 iframe = this._iframe,
                 PMS = this.PMS;

             //销毁内部事件
             PMS.send({
                 target: iframe.contentWindow,
                 url: iframe.src,
                 origin: '*',
                 type: 'onDestory',
                 success: function success() {}
             });

             //销毁事件绑定
             PMS.unbind();

             //销魂节点
             setTimeout(function () {
                 me._iframe = null;
                 me.$wapper.remove();
                 me.$wapper = null;
             }, 0);
         }

     };

     /**
      * 页面零件
      * @param {[type]} data [description]
      */
     function pageWidget(data) {

         //获取数据
         _.extend(this, data);

         this._widgetObj = null;

         var widgetName = this.widgetName + "Widget";

         //加载文件
         if (typeof window[this.widgetName + "Widget"] != "function") {
             this.loadfile(this.executive);
         } else {
             this.executive();
         }
     }

     pageWidget.prototype = {

         /**
          * 路径地址
          * @param  {[type]} name [description]
          * @return {[type]}      [description]
          */
         path: function path(fileName) {
             return 'content/widget/' + this.widgetId + '/' + fileName;
         },

         /**
          * 加载js,css文件
          * @return {[type]} [description]
          */
         loadfile: function loadfile(callback) {
             var jsPath,
                 cssPath,
                 completeCount,
                 self = this,

             //定义css,js的命名
             jsName = this.widgetName + '.min.js',
                 cssName = this.widgetType == 'page' || this.widgetType == 'js' ? 'style.min.css' : 0,

             //需要等待完成
             completeCount = function () {
                 var count = 0;
                 jsName && count++;
                 cssName && count++;
                 return function () {
                     if (count === 1) {
                         return callback && callback.call(self);
                     }
                     count--;
                 };
             }();

             //加载css
             if (cssName) {
                 cssPath = this.path(cssName);
                 _loadfile(cssPath, function () {
                     completeCount();
                 });
             }

             //加载js
             if (jsName) {
                 jsPath = this.path(jsName);
                 _loadfile(jsPath, function () {
                     completeCount();
                 });
             }
         },

         /**
          * 创建数据
          * @return {[type]} [description]
          */
         createData: function createData() {
             var item,
                 field,
                 source_export = [],
                 images = Xut.data['Image'],
                 token = null,
                 outputPara = this.inputPara,
                 items = outputPara.source;

             for (item in items) {
                 if (items.hasOwnProperty(item)) {

                     field = {};
                     token = images.item((parseInt(items[item]) || 1) - 1);
                     field['img'] = token.md5;
                     field['thumb'] = '';
                     field['title'] = token.imageTitle;
                     source_export.push(field);
                 }
             }

             outputPara.source = source_export;
             outputPara.scrollPaintingMode = this.scrollPaintingMode;
             outputPara.calculate = this.calculate;

             return outputPara;
         },

         /**
          * 解析数据,获取content对象
          * @return {[type]} [description]
          */
         parseContentObjs: function parseContentObjs() {
             var contentIds = [],
                 inputPara = this.inputPara;
             inputPara.content && _.each(inputPara.content, function (contentId) {
                 contentIds.push(contentId);
             });
             return Xut.Contents.GetPageWidgetData(this.pageType, contentIds);
         },

         /**
          * 执行函数
          * @return {[type]} [description]
          */
         executive: function executive() {
             //得到content对象与数据
             var data = this.createData();
             var contentObjs = this.parseContentObjs();
             if (this.widgetType == 'canvas') {
                 var id = contentObjs ? contentObjs[0].id : data.frame;
                 var canvasId = "pageWidget_" + id;
                 var canvansContent = $("#" + data.contentPrefix + id);
                 if ($("#" + canvasId).length < 1) {
                     canvansContent.append("<canvas style='position:absolute; z-index:10' id='" + canvasId + "' width='" + canvansContent.width() + "' height='" + canvansContent.height() + "'></canvas>");
                 }
                 canvansContent.canvasId = canvasId;
             }
             if (typeof window[this.widgetName + "Widget"] == "function") this._widgetObj = new window[this.widgetName + "Widget"](data, contentObjs);else console.error("Function [" + this.widgetName + "Widget] does not exist.");
         },

         //================ 外部调用 =====================

         play: function play() {
             console.log('widget');
             return this._widgetObj.play();
         },

         getIdName: function getIdName() {
             return this._widgetObj.getIdName();
         },

         /**
          * 外部调用接口
          * @return {[type]} [description]
          */
         dispatchProcess: function dispatchProcess() {
             this._widgetObj.toggle();
         },

         /**
          * 处理包装容器的状态
          * @return {[type]} [description]
          */
         domWapper: function domWapper() {
             if (!this.wapper) return;
             if (this.state) {
                 this.$wapper.hide();
             } else {
                 this.$wapper.show();
             }
         },

         /**
          * 销毁页面零件
          * @return {[type]} [description]
          */
         destroy: function destroy() {
             if (this._widgetObj && this._widgetObj.destroy) this._widgetObj.destroy();
         }
     };

     var proportion = void 0;
     var screenSize$1 = void 0;
     var appId = void 0;

     function loadWidget(type, data, widgetClass) {
         //pixi webgl模式
         //2016.4.14
         //高级精灵动画
         var pageObj = Xut.Presentation.GetPageObj(data.pageType, data.pageIndex);
         if (pageObj) {
             if (pageObj.canvasRelated.enable) {
                 //高级精灵动画不处理
                 //已经改成本地化pixi=>content调用了
                 if (data.widgetName === "spirit") {
                     return;
                 }
             }
         }

         var widgetObj = new widgetClass(data);

         //特殊的零件，也是只加载脚本
         if (data.widgetName != "bones") {
             //保存引用
             //特殊的2个个零件不保存
             Xut.Application.injectionComponent({
                 'pageType': data.pageType, //标记类型区分
                 'pageIndex': data.pageIndex,
                 'widget': widgetObj
             });
         }
     }

     /**
      * 构建5中零件类型
      * 	1、iframe零件
      *	2、页面零件
      *	3、SVG零件
      *	4、canvas零件
      *	5、webGL零件
      * @type {Object}
      */
     var adapterType = {

         /**
          * iframe零件类型
          * @param  {[type]} data [description]
          * @return {[type]}      [description]
          */
         'iframe': function iframe(data) {
             loadWidget('widget', data, iframeWidget);
         },
         'widget': function widget(data) {
             loadWidget('widget', data, iframeWidget);
         },

         /**
          * js零件类型处理
          * @param  {[type]} data [description]
          * @return {[type]}      [description]
          */
         'js': function js(data) {
             loadWidget('js', data, pageWidget);
         },
         'page': function page(data) {
             loadWidget('page', data, pageWidget);
         },
         'svg': function svg(data) {
             loadWidget('svg', data, pageWidget);
         },
         'canvas': function canvas(data) {
             loadWidget('canvas', data, pageWidget);
         },
         'webgL': function webgL(data) {
             loadWidget('webgL', data, pageWidget);
         }
     };

     /**
      * 获取widget数据
      * @return {[type]} [description]
      */
     function filtrateDas(data) {
         data = filterData(data);
         return proportion.calculateElement(data);
     }

     /**
      * 过滤出数据
      * @return {[type]} [description]
      */
     function filterData(data) {
         //直接通过id查询数据	
         if (data.widgetId) {
             _.extend(data, Xut.data.query('Widget', data.widgetId));
         } else {
             //直接通过activityId查询数据	
             _.extend(data, Xut.data.query('Widget', data.activityId, 'activityId'));
         }
         return data;
     }

     /**
      * 解析json数据
      * @param  {[type]} itemArray [description]
      * @return {[type]}           [description]
      */
     function ParseJSON(itemArray) {
         var anminJson;
         try {
             anminJson = JSON.parse(itemArray);
         } catch (error) {
             anminJson = new Function("return " + itemArray)();
         }
         return anminJson;
     }

     /**
      * ifarme内部，请求返回数据
      * @return {[type]} [description]
      */
     function parsePara(data) {
         var inputPara, //输入数据
         outputPara; //输出数据
         if (inputPara = data.inputPara) {
             outputPara = ParseJSON(inputPara);
         }
         return outputPara;
     }

     function Adapter(para) {

         config = Xut.config;
         proportion = config.proportion;
         screenSize$1 = config.screenSize;
         appId = config.appId;

         //获取数据
         var data = filtrateDas(para);

         para = null;

         data.id = data.activityId;

         //解析数据
         data.inputPara = parsePara(data);

         if (!data.inputPara) {
             data.inputPara = {};
         }

         //增加属性参数
         if (data.widgetType === 'page') {
             data.inputPara.container = data.rootNode;
         }

         data.inputPara.uuid = appId + '-' + data.activityId; //唯一ID标示
         data.inputPara.id = data.activityId;
         data.inputPara.screenSize = screenSize$1;
         //content的命名前缀
         data.inputPara.contentPrefix = Xut.Presentation.MakeContentPrefix(data.pageIndex, data.pageType);

         //画轴模式
         data.scrollPaintingMode = config.scrollPaintingMode;
         data.calculate = config.proportion.calculateContainer();

         //执行类构建
         adapterType[(data.widgetType || 'widget').toLowerCase()](data);
     }

     var Widget = {
         //==========创建热点元素结构（用于布局可触发点）===============
         //
         // 根据数据创建自己的热点元素结构（用于拼接结构字符串）
         //
         // 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
         //
         // sqlRet    具体动作对象的数据
         // pageData  当前页面数据
         // chaperId  当前页面的chapterId
         // pageIndex 当前页面索引号
         // zIndex    热点元素的层级
         //
         createDom: function createDom(activityData, chpaterData, chapterId, pageIndex, zIndex, pageType) {
             var retStr = '',
                 layerId,
                 cssStyle,
                 autoPlay = activityData.autoPlay;

             //如果是自动播放,则不创建结构
             if (autoPlay) {
                 return retStr;
             }

             var backgroundImage = '',
                 width = activityData.scaleWidth,
                 height = activityData.scaleHeight,
                 top = activityData.scaleTop,
                 left = activityData.scaleLeft,
                 actType = activityData.actType,
                 md5 = activityData.md5;

             //热点背景图
             if (md5) {
                 backgroundImage = "background-image: url(" + Xut.config.pathAddress + md5 + ");";
             }

             //创建触发点结构
             layerId = actType + "_" + activityData._id;
             cssStyle = 'cursor: pointer;width:' + width + 'px;height:' + height + 'px;left:' + left + 'px;top:' + top + 'px;background-size:100% 100%;position:absolute;z-index:' + zIndex + ';' + backgroundImage + '';

             return String.format('<div id="{0}"' + ' data-belong ="{1}"' + ' data-delegate="{2}"'
             // +' autoplay="{3}"' svg打包不可以属性
              + ' style="{4}">' + ' </div>', layerId, pageType, actType, autoPlay, cssStyle);
         },

         //事件委托
         //通过点击触发
         eventDelegate: function eventDelegate(data) {
             return Adapter(data);
         },

         //在当前页面自动触发的通知
         autoPlay: function autoPlay(data) {
             Adapter({
                 'rootNode': data.rootNode,
                 "type": data.type,
                 "pageType": data.pageType,
                 "activityId": data.id,
                 "pageIndex": data.pageIndex,
                 "isAutoPlay": true
             });
         },

         /**
          *  复位状态通知
          *
          *  作用：用户按页面右上角返回，或者pad手机上的物理返回键
          *
          *  那么：
          *      1 按一次， 如果当前页面有活动热点，并且热点对象还在可视活动状态（比如文本，是显示，音频正在播放）
          *        那么则调用此方法，做复位处理，即文本隐藏，音频关闭
          *        然后返回true, 用于反馈给控制器,停止下一步调用
          *        按第二次,则退出页面
          *
          *     2 按一次，如果没有活动的对象，return false,这直接退出页面
          *
          * @param  {[type]} activeObejct [description]
          * @return {[type]}              [description]
          */
         recovery: function recovery(opts) {
             return this.recovery();
         }
     };

     // *  iscroll 控制
     // *    传入dom ID
     // *     [onIscroll description]
     // * @param  {[type]} contentWrapperDomId [description]
     // * @return {[type]}                     [description]

     function createIscroll(element) {
          //是否移动，中途停止了动画
          var distX = 0,
              distY = 0,
              startX,
              startY,
              absDistY,
              absDistX,
              iscroll,
              that = this,
              screenWidth = Xut.config.screenSize.width,
              useswipeleft = function useswipeleft() {
               Xut.View.GotoPrevSlide();
          },
              useswiperight = function useswiperight() {
               Xut.View.GotoNextSlide();
          };

          this.iscroll = iscroll = new iScroll(element, {
               scrollbars: true,
               fadeScrollbars: true
               //click          : true,
               //tap            : true,
               //probeType      : 2
          });

          // this.iscroll.on('scrollStart', function() {
          //     iscroll.initDirection = false; //初始化一次滑动方向
          // });
          // this.iscroll.on('scrollEnd', function(e) {
          //     //如果是Y轴滑动者不作处理跳过
          //     if (iscroll.initDirection) {
          //          startY= startX=distX = distY = 0;
          //         iscroll.startTime = 0;
          //         iscroll.initDirection = false;
          //         return;
          //     }

          //     var duration, deltaX, validSlide, distance;
          //     //滑动的距离、

          //     deltaX = distX || 0;
          //     duration = +new Date - iscroll.startTime;
          //     distance = Math.abs(deltaX);
          //     //反弹的边界值
          //     validSlide = Math.ceil(screenWidth / 5);
          //     if (distance < validSlide) {
          //         //快速滑动允许翻页
          //         if (duration < 200 && distance > 20) {
          //             iscroll.swipe = true;
          //             deltaX > 0 ? useswipeleft() : useswiperight();
          //         } else {
          //             //反弹
          //             Xut.View.MovePage(0, 300, deltaX > 0 ? 'prev' : 'next', 'flipRebound')
          //         }
          //     } else {
          //         iscroll.swipe = true;
          //         deltaX > 0 ? useswipeleft() : useswiperight();
          //     }
          //    startY= startX=distX = distY = 0;
          //     iscroll.startTime = 0;
          //     iscroll.initDirection = false;
          // });
          // this.iscroll.on('scroll', function(e) {
          //     startX=startX||e.pageX;
          //     startY=startY||e.pageY;

          //     distX =e.pageX-startX;
          //     distY = e.pageY-startY;

          //     absDistX = Math.abs(distX);
          //     absDistY = Math.abs(distY);

          //     iscroll.startTime = iscroll.startTime || e.timeStamp;
          //     if (absDistY * 1.5 > absDistX) {
          //           //如果是Y轴滑动则做标记不作处理
          //         iscroll.initDirection = true;
          //     } else {
          //         Xut.View.MovePage(distX, 0, distX > 0 ? 'prev' : 'next', 'flipMove');
          //         iscroll.initDirection = false
          //     }
          // });
     }

     function ShowNote$1(data) {
         data.id = parseInt(data.id);
         data.actType = data.type;
         _.extend(this, data);
         this.setup();
     }

     ShowNote$1.prototype = {
         setup: function setup() {
             var that = this,
                 note = this.data.note,
                 prop = Xut.config.proportion,
                 width = Math.round((prop.width + prop.height) / 2 * Xut.config.iconHeight),
                 space = Math.round(width / 2);
             retStr = '<div class="xut-shownote-box" style="z-index:' + Xut.zIndexlevel() + '">' + '<div class="close" style="width:' + width + 'px;height:' + width + 'px;top:-' + space + 'px;right:-' + space + 'px"></div>' + '<div class="content">' + note + '</div>' + '</div>';

             this._dom = $(retStr);
             this._dom.find('.close').on("touchend mouseup", function () {
                 that.dispatchProcess();
             });
             $(this.rootNode).append(this._dom);

             this.show();
             createIscroll(this._dom.find('.content')[0]);
             return true;
         },

         //外部调用接口
         dispatchProcess: function dispatchProcess() {
             //自动热点 取消关闭
             if (this.isAutoPlay) return;
             //当前对象状态
             this.state ? this.hide() : this.show();
         },

         recovery: function recovery() {
             if (this.state) {
                 this.dispatchProcess();
                 return true;
             }
             return false;
         },

         hide: function hide() {
             this.state = false;
             $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/hideNote.png)');
             this._dom.hide();
         },

         show: function show() {
             this.state = true;
             $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/showNote.png)');
             this._dom.show();
         },

         destroy: function destroy() {
             if (this._dom) {
                 this._dom.find('.close').off();
                 this._dom && this._dom.hide().remove();
             }
         }

     };

     var ShowNote = {

         //==========创建热点元素结构（用于布局可触发点）===============
         //
         // 根据数据创建自己的热点元素结构（用于拼接结构字符串）
         //
         // 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
         //actType + "_" + _id
         createDom: function createDom(activityData, chpaterData, chapterId, pageIndex, zIndex, pageType) {
             var retStr = "",
                 newWidth,
                 id = activityData['_id'],
                 width = activityData.scaleWidth,
                 height = activityData.scaleHeight,
                 newWidth = (width + height) / 2 * Xut.config.iconHeight;

             retStr += '<div id="ShowNote_' + id + '" class="xut-showNote" data-belong =' + pageType + ' data-delegate="ShowNote" style="width:' + newWidth + 'px;height:' + newWidth + 'px"></div>';
             return retStr;
         },

         /**
          * touchEnd 全局派发的点击事件
          * 如果stopGlobalEvent == ture 事件由全局派发
          */
         eventDelegate: function eventDelegate(data) {
             data.data = Xut.Presentation.GetPageData(data.pageIndex);
             new ShowNote$1(data);
         },

         //自动运行生成Action或者widget触发点对象
         autoPlay: function autoPlay(opts) {},

         /**
          * 翻页后处理页面中活动热点的状态
          * @param  {[type]} activeObejct [需要处理的活动对象]
          *
          * 比如音频,视频 翻页需要暂停，也可以销毁
          */
         flipOver: function flipOver(opts) {
             //console.log('翻页处理活动对象', activeObejct ,pageIndex);
         },

         /**
          * 销毁页面hotspot事件与Action或widget事件
          * @param  {[type]} activeObejct [需要处理的活动对象]
          * @param  {[type]} pageIndex    [页码标示]
          * @param  {[type]} rootEle      [根元素]
          * @return {[type]}              [description]
          */
         destroy: function destroy(opts) {
             this && this.destroy();
         },

         //========复位对象==========
         //
         //  通过按物理键，关闭当前热点
         //
         //  @return 如果当前没有需要处理的Action,
         //  需要返回一个状态标示告诉当前是否应该退出应用
         //
         recovery: function recovery(opts) {
             if (this.state) {
                 this.dispatchProcess();
                 return true;
             }
             return false;
         }
     };

     var Webpage = Media;
     var Video = Media;
     var Audio$1 = Media;

     var Bind = {
         Video: Video,
         Audio: Audio$1,
         Action: Action$1,
         Content: Content,
         Webpage: Webpage,
         Widget: Widget,
         ShowNote: ShowNote
     };

     var contentTaskOutId;
     /**
      * 运行自动的content对象
      * 延时500毫秒执行
      * @return {[type]} [description]
      */
     function runContent(contentObjs, taskAnimCallback) {

         var contentTaskOutId = setTimeout(function () {

             clearTimeout(contentTaskOutId);

             //完成通知
             var markComplete = function () {
                 var completeStatistics = contentObjs.length; //动画完成统计
                 return function () {
                     if (completeStatistics === 1) {
                         taskAnimCallback && taskAnimCallback();
                         markComplete = null;
                     }
                     completeStatistics--;
                 };
             }();

             _.each(contentObjs, function (obj, index) {
                 if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
                     obj.autoPlay(markComplete);
                 } else {
                     markComplete();
                 }
             });
         }, 500);
     }
     /**
      * 运行自动的静态类型
      * @return {[type]} [description]
      */
     function runComponent(pageObj, pageIndex, autoRunComponents, pageType) {

         var chapterId = pageObj.baseGetPageId(pageIndex);

         if (pageIndex === undefined) {
             pageIndex = Xut.Presentation.GetPageIndex();
         }
         _.each(autoRunComponents, function (data, index) {
             var dir = Bind[data.type];
             if (dir && dir.autoPlay) {
                 dir.autoPlay({
                     'id': data.id,
                     'key': data.key,
                     'type': data.type,
                     'pageType': pageType,
                     'rootNode': pageObj.element,
                     'chapterId': chapterId,
                     'category': data.category,
                     'autoPlay': data.autoPlay,
                     'pageIndex': pageIndex
                 });
             }
         });
     }

     function _autoRun(pageObj, pageIndex, taskAnimCallback) {

         /**
          * 编译IBOOKSCONFIG的时候过滤自动运行的调用
          * @return {[type]}              [description]
          */
         if (Xut.IBooks.compileMode()) {
             return;
         }

         //pageType
         //用于区别触发类型
         //页面还是母版
         Xut.accessControl(pageObj, function (pageObj, ContentObjs, ComponentObjs, pageType) {

             //如果是母版对象，一次生命周期种只激活一次
             if (pageObj.pageType === 'master') {
                 if (pageObj.onceMaster) {
                     return;
                 }
                 pageObj.onceMaster = true;
             }

             taskAnimCallback = taskAnimCallback || function () {};

             //自动运行的组件
             var autoRunComponents;
             if (autoRunComponents = pageObj.baseAutoRun()) {
                 runComponent(pageObj, pageIndex, autoRunComponents, pageType);
             }

             //自动运行content
             clearTimeout(contentTaskOutId);

             if (ContentObjs) {
                 runContent(ContentObjs, taskAnimCallback);
             } else {
                 taskAnimCallback(); //无动画
             }

             Xut.log('debug', pageType + '层，第' + (pageIndex + 1) + '页开始,本页面Id为' + pageObj.chapterId);
         });
     }

     function trigger(target, attribute, rootNode, pageIndex) {

         var key, tag, type, id, dir, data, pageType, instance;

         if (key = target.id) {

             tag = key.split('_');
             type = tag[0];
             id = tag[1];
             dir = Bind[type];

             if (dir && dir.eventDelegate) {

                 //获取页面类型
                 pageType = function () {
                     if (rootNode && rootNode.id) {
                         return (/page/.test(rootNode.id) ? 'page' : 'master'
                         );
                     } else {
                         return 'page';
                     }
                 }();

                 data = {
                     "id": id,
                     "activityId": id,
                     "key": key,
                     "type": type,
                     "rootNode": rootNode,
                     "target": target,
                     "pageIndex": pageIndex,
                     'pageType': pageType
                 };

                 //如果是重复点击
                 if (instance = Xut.Application.GetSpecifiedObject(pageType, data)) {
                     if (instance.dispatchProcess) {
                         //如果有对应的处理方法
                         return instance.dispatchProcess();
                     }
                 }

                 //委派新的任务
                 dir.eventDelegate(data);
             }
         }
     }

     /**
      * 暂停控制
      * @return {[type]} [description]
      */

     //翻页时,暂停滑动页面的所有热点动作
     //翻页停止content动作
     function _suspend(pageObj, pageId) {

         Xut.accessControl(pageObj, function (pageObj, ContentObjs, ComponentObjs) {
             //多媒体处理
             if (pageId !== undefined) {
                 //离开页面销毁视频
                 Xut.VideoManager.removeVideo(pageId);
                 //翻页停止母板音频
                 if (pageObj.pageType === 'master') {
                     Xut.AudioManager.hangUpAudio();
                 }
             }

             //content类型
             if (ContentObjs) {
                 _.each(ContentObjs, function (obj) {
                     obj.flipOver && obj.flipOver();
                 });
             }
         });
     }

     /**
      * 复位到初始化的状态
      * @return {[type]} [description]
      */

     /////////
     //优化检测 //
     /////////
     function checkOptimize(fn) {
         if (!Xut.config.scrollPaintingMode) {
             fn && fn();
         }
     }

     //===============================================================
     //     
     //           翻一页处理： 翻页完毕触发
     //
     //  大量操作DOM结构，所以先隐藏根节点
     //  1 删除所有widget节点
     //  2 复位所有content节点
     // 
     //==============================================================
     function _original(pageObj) {

         Xut.accessControl(pageObj, function (pageObj, ContentObjs, ComponentObjs) {

             //母版对象不还原
             if (pageObj.pageType === 'master') return;

             var element;

             if (element = pageObj.element) {
                 checkOptimize(function () {
                     element.hide();
                 });

                 //销毁所有widget类型的节点
                 if (ComponentObjs) {
                     _.each(ComponentObjs, function (obj) {
                         obj && obj.destroy();
                     });
                     //销毁widget对象管理
                     pageObj.baseRemoveComponent();
                 }

                 //停止动作
                 ContentObjs && _.each(ContentObjs, function (obj) {
                     if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
                         obj.resetAnimation && obj.resetAnimation();
                     }
                 });

                 checkOptimize(function () {
                     setTimeout(function () {
                         element.show();
                         element = null;
                     }, 0);
                 });
             }
         });
     }

     /**
      * 动作复位状态
      * @return {[type]} [description]
      */

     //========================================================
     //          复位状态
     //          状态控制
     //  如果返回false证明有热点,
     //  第一次只能关闭热点不能退出页面
     //=========================================================
     function recovery(pageObj) {
         return Xut.accessControl(pageObj, function (pageObj, ContentObjs, ComponentObjs) {
             var falg = false;
             _.each([ContentObjs, ComponentObjs], function (collectionObj) {
                 collectionObj && _.each(collectionObj, function (obj) {
                     //如果返回值是false,则是算热点处理行为
                     if (obj.recovery && obj.recovery()) {
                         falg = true;
                     }
                 });
             });
             return falg;
         });
     }

     /**
      * 获取访问对象参数
      *
      * 如果pageObj 不存在，则取当前页面的
      * 
      * @return {[type]} [description]
      */
     Xut.accessControl = function (pageObj, callback) {
         var flag,
             pageObj = pageObj || Xut.Presentation.GetPageObj();
         if (pageObj) {
             var contents = pageObj.baseGetContent();
             var components = pageObj.baseGetComponent();
             var pageType = pageObj.pageType || 'page';
             flag = callback(pageObj, contents.length && contents, components.length && components, pageType);
         }
         return flag;
     };

     var prefix = Xut.plat.prefixStyle;
     var sectionInstance = null;
     var lockAnimation = void 0; //执行动画
     function toAnimation(navControlBar, navhandle, action) {
         var end = function end() {
             navControlBar.css(prefix('transition'), '');
             Xut.View.HideBusy();
             lockAnimation = false;
         };

         if (action == 'in') {
             sectionInstance.refresh();
             sectionInstance.scrollTo();
             navControlBar.animate({
                 'z-index': Xut.zIndexlevel(),
                 'opacity': 1
             }, 'fast', 'linear', function () {
                 navhandle.attr('fly', 'out');
                 end();
             });
         } else {
             navhandle.attr('fly', 'in');
             navControlBar.hide();
             end();
         }
     }

     //控制按钮改变
     function navControl(action, navhandle) {
         navhandle.css('opacity', action === "in" ? 0.5 : 1);
     }

     function initialize() {
         //动画状态
         if (lockAnimation) {
             return false;
         }

         lockAnimation = true;
         Xut.View.ShowBusy();
         startpocess();
     };

     function startpocess() {
         //控制按钮
         var navhandle = $("#backDir"),
             action = navhandle.attr('fly') || 'in',
             navControlBar = $("#navBar");

         //初始化样式
         initStyle(navControlBar, action, function () {
             //触发控制条
             navControl(action, navhandle);
             //执行动画
             toAnimation(navControlBar, navhandle, action);
         });
     };

     function initStyle(navControlBar, action, fn) {
         sectionInstance.state = false;
         if (action == 'in') {
             sectionInstance.state = true;
             navControlBar.css({
                 'z-index': 0,
                 'opacity': 0,
                 'display': 'block'
             });
         }
         fn && fn();
     }

     //关闭
     function _close(callback) {
         if (sectionInstance && sectionInstance.state) {
             callback && callback();
             initialize();
         }
     }

     /***********************************************
      *	      热点动作控制器模块
      *         1 所有content热点停止
      *         2 所有content热点销毁
      *         3 app应用销毁
      * **********************************************/

     //消息提示框
     function promptMessage(info) {
         show({
             hindex: Xut.Presentation.GetPageIndex(),
             content: info || "再按一次将退回到主页",
             time: 3000
         });
     };

     /************************************************************
      *
      * 			检测媒体的播放状态
      * 			1 视频
      * 			2 音频
      *
      * ***********************************************************/
     function checkMedia(pageId) {
         var flag = false; //音频 视频 是否有处理

         if (Xut.AudioManager.clearAudio(pageId)) {
             flag = true;
         }

         if (Xut.VideoManager.clearVideo()) {
             flag = true;
         }

         return flag;
     }

     /************************************************************
      *
      * 			检测热点的运行状态
      *
      * ***********************************************************/
     function checkWidgets(context, pageIndex) {
         return recovery();
     }

     /************************************************************
      * 			停止所有热点动作,并返回状态
      * 			1 content
      * 			2 widget
      * 			动画,视频,音频...........................
      * 			增加场景模式判断
      * ***********************************************************/
     function suspendHandles(context, pageIndex, skipMedia) {

         //是否存在运行中
         var stateRun = false;

         //处理音频
         if (checkMedia(skipMedia)) {
             stateRun = true;
         }

         //正在运行的热点
         ///content,Action', 'Widget', 'ShowNote'
         if (checkWidgets(context, pageIndex)) {
             stateRun = true;
         }

         //处理导航
         _close(function () {
             stateRun = true;
         });

         return stateRun;
     }

     var config$5 = void 0;

     /**
      * 设置缓存
      * @param {[type]} parameter [description]
      */
     function setDataToStorage(parameter) {
         config$5.pageIndex = parameter.pageIndex;
         config$5.novelId = parameter.novelId;
         _set({
             "pageIndex": parameter.pageIndex,
             "novelId": parameter.novelId
         });
     };

     /**
      * 初始化值
      * @param {[type]} options [description]
      */
     function initDefaultValues(options) {
         var pageFlip = options.pageFlip;
         //配置全局翻页模式
         //pageflip可以为0
         //兼容pageFlip错误,强制转化成数字类型
         if (pageFlip !== undefined) {
             config$5.pageFlip = toEmpty(pageFlip);
         }
         return {
             'novelId': toEmpty(options.novelId),
             'pageIndex': toEmpty(options.pageIndex),
             'history': options.history
         };
     };

     /**
      * 检测脚本注入
      * @return {[type]} [description]
      */
     function checkInjectScript() {
         var preCode,
             novels = Xut.data.query('Novel');
         if (preCode = novels.preCode) {
             injectScript(preCode, 'novelpre脚本');
         }
     }

     function loadScene(options) {

         config$5 = Xut.config;

         //获取默认参数
         var parameter = initDefaultValues(options || {});

         //设置缓存
         setDataToStorage(parameter);

         //应用脚本注入
         checkInjectScript();

         //检测下scenarioId的正确性
         //scenarioId = 1 找不到chapter数据
         //通过sectionRelated递归检测下一条数据
         var scenarioId, seasondata, i;
         for (i = 0; i < Xut.data.Season.length; i++) {
             seasondata = Xut.data.Season.item(i);
             if (Xut.data.query('sectionRelated', seasondata._id)) {
                 scenarioId = seasondata._id;
                 break;
             }
         }

         //加载新的场景
         Xut.View.LoadScenario({
             'main': true, //主场景入口
             'scenarioId': scenarioId,
             'pageIndex': parameter.pageIndex,
             'history': parameter.history
         });
     }

     /**
      * 布局文件
      * 1 控制条
      * 2 导航栏
      * @param  {[type]} config [description]
      * @return {[type]}        [description]
      */
     var config$7 = void 0;
     var round = void 0;
     var ratio = void 0;
     var isIOS = void 0;
     var iconHeight$1 = void 0;
     var proportion$1 = void 0;
     var calculate = void 0;
     var TOP = void 0;
     var sWidth = void 0;
     var sHeight = void 0;
     var navHeight = void 0; //菜单的高度
     var navWidth = void 0; //菜单的宽度

     function setOption() {
         config$7 = Xut.config;
         round = Math.round;
         ratio = 6;
         isIOS = Xut.plat.isIOS;
         iconHeight$1 = config$7.iconHeight;
         proportion$1 = config$7.proportion;
         calculate = proportion$1.calculateContainer();
         TOP = isIOS ? 20 : 0;
         sWidth = calculate.width;
         sHeight = calculate.height;
         proportion$1 = config$7.layoutMode == "horizontal" ? proportion$1.width : proportion$1.height;
         iconHeight$1 = isIOS ? iconHeight$1 : round(proportion$1 * iconHeight$1);
     }

     /**
      * 首页布局
      * @return {[type]} [description]
      */
     function home() {

         setOption();

         var retStr = '';
         var style = void 0;

         if (config$7.scrollPaintingMode) {
             retStr = '<div id="sceneHome" style ="width:' + (config$7.virtualMode ? sWidth / 2 : sWidth) + 'px;height:' + sHeight + 'px;top:' + calculate.top + 'px;left:' + calculate.left + 'px;z-index:' + Xut.sceneController.createIndex() + '" class="xut-chapter">';
         } else {
             //overflow:hidden;
             retStr = '<div id="sceneHome" style ="width:' + (config$7.virtualMode ? sWidth / 2 : sWidth) + 'px;height:' + sHeight + 'px;top:' + calculate.top + 'px;left:' + calculate.left + 'px;overflow:hidden;z-index:' + Xut.sceneController.createIndex() + '" class="xut-chapter">';
         }
         retStr += '<div id="controlBar" class="xut-controlBar hide"></div>';
         retStr += '<ul id="pageContainer" class="xut-flip"></ul>'; //页面节点
         retStr += '<ul id="masterContainer" class="xut-master xut-flip"></ul>'; //视觉差包装容器

         //滑动菜单
         if (config$7.layoutMode == 'horizontal') {
             navHeight = round(sHeight / ratio); //菜单的高度
             style = 'overflow:hidden;width:100%;height:' + navHeight + 'px;background-color:white;bottom:4px;border-top:1px solid rgba(0,0,0,0.1)';
         } else {
             navWidth = Math.min(sWidth, sHeight) / (isIOS ? 8 : 3); //菜单宽度
             navHeight = round((sHeight - iconHeight$1 - TOP) * 0.96);
             style = 'width:' + navWidth + 'px;height:' + navHeight + 'px;background-color:white;top:' + (iconHeight$1 + TOP + 2) + 'px;left:' + iconHeight$1 + 'px;border-top:1px solid rgba(0,0,0,0.1)';
         }

         retStr += '<div id="navBar" class="xut-navBar" style="' + style + '"></div>';
         //消息提示框
         retStr += '<div id="toolTip"></div>';
         retStr += '</div>';
         return retStr;
     }

     /**
      * [scene 创建场景]
      * @param  {[type]} options [description]
      * @return {[type]}         [description]
      */
     function scene(id) {

         setOption();

         var wapper = '';
         if (config$7.scrollPaintingMode) {
             wapper = '<div id="{0}" class="xut-waitLoad" style="width:{1}px;height:{2}px;top:{3}px;left:{4}px;position:absolute;z-index:{5};">' + '<ul id="{6}" class="xut-flip" style="z-index:{7}"></ul>' + '<ul id="{8}" class="xut-flip" style="z-index:{9}"></ul>' + '</div>';
         } else {
             wapper = '<div id="{0}" class="xut-waitLoad" style="width:{1}px;height:{2}px;top:{3}px;left:{4}px;position:absolute;overflow:hidden;z-index:{5};">' + '<ul id="{6}" class="xut-flip" style="z-index:{7}"></ul>' + '<ul id="{8}" class="xut-flip" style="z-index:{9}"></ul>' + '</div>';
         }
         return String.format(wapper, 'scenario-' + id, config$7.virtualMode ? sWidth / 2 : sWidth, sHeight, calculate.top, calculate.left, Xut.sceneController.createIndex(), 'scenarioPage-' + id, 2, 'scenarioMaster-' + id, 1);
     }

     /**
      * svgicons.js v1.0.0
      * http://www.codrops.com
      *
      * Licensed under the MIT license.
      * http://www.opensource.org/licenses/mit-license.php
      *
      * Copyright 2013, Codrops
      * http://www.codrops.com
      */

     /*** helper functions ***/

     // from https://github.com/desandro/classie/blob/master/classie.js
     function classReg(className) {
         return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
     }

     function hasClass(el, c) {
         return 'classList' in document.documentElement ? el.classList.contains(c) : classReg(c).test(el.className);
     }

     function extend$1(a, b) {
         for (var key in b) {
             if (b.hasOwnProperty(key)) {
                 a[key] = b[key];
             }
         }
         return a;
     }

     // http://snipplr.com/view.php?codeview&id=5259
     function isMouseLeaveOrEnter(e, handler) {
         if (e.type != 'mouseout' && e.type != 'mouseover') return false;
         var reltg = e.relatedTarget ? e.relatedTarget : e.type == 'mouseout' ? e.toElement : e.fromElement;
         while (reltg && reltg != handler) {
             reltg = reltg.parentNode;
         }return reltg != handler;
     }

     /*** svgIcon ***/

     function svgIcon(el, config, options) {
         this.el = el;
         this.options = extend$1({}, this.options);
         extend$1(this.options, options);
         this.svg = Snap(this.options.size.w, this.options.size.h);
         this.svg.attr('viewBox', '0 0 32 32');
         this.el.appendChild(this.svg.node);
         // state
         this.toggled = false;
         // icons configuration
         this.config = config[this.el.getAttribute('data-icon-name')];
         // reverse?
         if (hasClass(this.el, 'si-icon-reverse')) {
             this.reverse = true;
         }
         if (!this.config) return;
         var self = this;
         // load external svg
         Snap.load(this.config.url, function (f) {
             var g = f.select('g');
             self.svg.append(g);
             self.options.onLoad();
             self._initEvents();
             if (self.reverse) {
                 self.toggle(true);
             }
         });
     }

     svgIcon.prototype.options = {
         speed: 200,
         easing: mina.linear,
         evtoggle: 'click', // click || mouseover
         size: {
             w: 44,
             h: 44
         },
         onLoad: function onLoad() {
             return false;
         },
         onToggle: function onToggle() {
             return false;
         }
     };

     svgIcon.prototype._initEvents = function () {
         var self = this,
             toggleFn = function toggleFn(ev) {
             if ((ev.type.toLowerCase() === 'mouseover' || ev.type.toLowerCase() === 'mouseout') && isMouseLeaveOrEnter(ev, this) || ev.type.toLowerCase() === 'touchstart' || ev.type.toLowerCase() === 'mousedown') {
                 self.toggle(true);
                 self.options.onToggle();
             }
             return false;
         };

         if (this.options.evtoggle === 'mouseover') {
             this.el.addEventListener('mouseover', toggleFn);
             this.el.addEventListener('mouseout', toggleFn);
         } else {
             Xut.plat.execEvent('on', {
                 context: this.el,
                 callback: {
                     start: function start(e) {
                         toggleFn(e);
                     }
                 }
             });
         }
     };

     svgIcon.prototype.toggle = function (motion) {
         if (!this.config.animation) return;
         var self = this;
         for (var i = 0, len = this.config.animation.length; i < len; ++i) {
             var a = this.config.animation[i],
                 el = this.svg.select(a.el),
                 animProp = this.toggled ? a.animProperties.from : a.animProperties.to,
                 val = animProp.val,
                 timeout = motion && animProp.delayFactor ? animProp.delayFactor : 0;

             if (animProp.before) {
                 el.attr(JSON.parse(animProp.before));
             }

             if (motion) {
                 setTimeout(function (el, val, animProp) {
                     return function () {
                         el.animate(JSON.parse(val), self.options.speed, self.options.easing, function () {
                             if (animProp.after) {
                                 this.attr(JSON.parse(animProp.after));
                             }
                             if (animProp.animAfter) {
                                 this.animate(JSON.parse(animProp.animAfter), self.options.speed, self.options.easing);
                             }
                         });
                     };
                 }(el, val, animProp), timeout * self.options.speed);
             } else {
                 el.attr(JSON.parse(val));
             }
         }
         this.toggled = !this.toggled;
     };

     /**
      * [svgIconConfig description]
      * http://tympanus.net/Development/AnimatedSVGIcons/
      * @type {Object}
      */
     var iconConfig = {
         nextArrow: {
             url: 'images/icons/pageback.svg',
             animation: [{
                 el: 'path:nth-child(1)',
                 animProperties: {
                     from: {
                         val: '{"transform" : "r0 16 16", "fill-opacity" : "0.9"}',
                         before: '{"fill-opacity" : "0.9", "stroke-opacity" : "0" , "transform" : "r90 16 16"}'
                     },
                     to: {
                         val: '{"transform" : "r360 16 16", "fill-opacity": "0"}',
                         before: '{"fill-opacity" : "0", "stroke-opacity" : "1" }'
                     }
                 }
             }]
         },
         prevArrow: {
             url: 'images/icons/pageforward.svg',
             animation: [{
                 el: 'path:nth-child(1)',
                 animProperties: {
                     from: {
                         val: '{"transform" : "r0 16 16", "fill-opacity" : "0.9"}',
                         before: '{"fill-opacity" : "0.9", "stroke-opacity" : "0" , "transform" : "r90 16 16"}'
                     },
                     to: {
                         val: '{"transform" : "r360 16 16", "fill-opacity": "0"}',
                         before: '{"fill-opacity" : "0", "stroke-opacity" : "1" }'
                     }
                 }
             }]
         },
         close: {
             url: 'images/icons/close.svg',
             animation: [{
                 el: 'path:nth-child(1)',
                 animProperties: {
                     from: {
                         val: '{"transform" : "r0 16 16", "fill-opacity" : "0.9"}',
                         before: '{"fill-opacity" : "0.9", "stroke-opacity" : "0" , "transform" : "r90 16 16"}'
                     },
                     to: {
                         val: '{"transform" : "r360 16 16", "fill-opacity": "0"}',
                         before: '{"fill-opacity" : "0", "stroke-opacity" : "1" }'
                     }
                 }
             }]
         },
         back: {
             url: 'images/icons/back.svg',
             animation: [{
                 el: 'path:nth-child(1)',
                 animProperties: {
                     from: {
                         val: '{"transform" : "r0 16 16", "fill-opacity" : "0.9"}',
                         before: '{"fill-opacity" : "0.9", "stroke-opacity" : "0" , "transform" : "r90 16 16"}'
                     },
                     to: {
                         val: '{"transform" : "r360 16 16", "fill-opacity": "0"}',
                         before: '{"fill-opacity" : "0", "stroke-opacity" : "1" }'
                     }
                 }
             }]
         }
     };

     var isIOS$1 = Xut.plat.isIOS;

     //获取翻页按钮位置
     var arrowStyle = function arrowStyle() {
         var config = Xut.config;
         var height = config.iconHeight;
         var settings = config.settings;
         var styleText = 'height:' + height + 'px;width:' + height + 'px';
         switch (settings.NavbarPos) {
             case 0:
                 styleText += ';top:0';
                 break; //顶部
             case 1:
                 styleText += ';margin-top:' + -height / 2 + 'px';
                 break; //中间
             case 2:
                 styleText += ';top:auto;bottom:0';
                 break; //底部
             default:
                 break;
         }

         return styleText;
     };

     //工具栏基础类
     var ToolBar = Xut.CoreObject.extend({
         barHeight: isIOS$1 ? 20 : 0, //系统状态栏高度
         enableLeft: true, //默认创建左翻页按钮
         enableRight: true //默认创建右翻页按钮
     });

     ToolBar.prototype.initConfig = function (config) {
         var propHeight;
         //获取高度缩放比
         //自动选择缩放比例
         this.propHeight = propHeight = function () {
             var layout = config.layoutMode,
                 prop = config.proportion;
             return layout == "horizontal" ? prop.width : prop.height;
         }();

         //获取图标高度
         //工具栏图标高度
         this.iconHeight = function () {
             var height = config.iconHeight;
             return isIOS$1 ? height : Math.round(propHeight * height);
         }();

         this.appName = config.shortName; //应用标题
         this.settings = config.settings; //应用默认配置
     };

     //创建翻页按钮
     ToolBar.prototype.createArrows = function () {
         //是否使用自定义的翻页按钮: true /false
         //图标名称是客户端指定的：pageforward_'+appId+'.svg
         var isCustom = this.settings.customButton;

         if (this.enableLeft) {
             isCustom ? this.createLeftIcon() : this.createLeftArrow();
         }

         if (this.enableRight) {
             isCustom ? this.createRightIcon() : this.createRightArrow();
         }
     };

     //左箭头翻页按钮
     ToolBar.prototype.createLeftArrow = function () {
         var style = arrowStyle(),
             state = this.barStatus ? '' : 'hide',
             $dom;
         $dom = $('<div class="si-icon xut-flip-control left ' + state + '" data-icon-name="prevArrow" style="' + style + '"></div>');

         this.createSVGIcon($dom[0], function () {
             Xut.View.GotoPrevSlide();
         });

         this.container.append($dom);
         this.arrows.prev = {
             el: $dom,
             able: true
         };
     };

     //右箭头翻页按钮
     ToolBar.prototype.createRightArrow = function () {
         var style = arrowStyle(),
             state = this.barStatus ? '' : 'hide',
             $dom;
         $dom = $('<div class="si-icon xut-flip-control right ' + state + '" data-icon-name="nextArrow" style="' + style + '"></div>');

         this.createSVGIcon($dom[0], function () {
             Xut.View.GotoNextSlide();
         });

         this.container.append($dom);
         this.arrows.next = {
             el: $dom,
             able: true
         };
     };

     //自定义左翻页按钮
     ToolBar.prototype.createLeftIcon = function () {
         var style = arrowStyle(),
             appId = this.config.appId,
             state = this.barStatus ? '' : 'hide',
             $dom;
         style += ';background-image:url(images/icons/pageforward_' + appId + '.svg);background-size:cover';
         $dom = $('<div name="prevArrow" class="xut-flip-control left ' + state + '" style="' + style + '"></div>');

         $dom.on("touchend mouseup", function () {
             Xut.View.GotoPrevSlide();
         });

         this.container.append($dom);
         this.arrows.prev = {
             el: $dom,
             able: true
         };
     };

     //自定义右翻页按钮
     ToolBar.prototype.createRightIcon = function () {
         var style = arrowStyle(),
             appId = this.config.appId,
             state = this.barStatus ? '' : 'hide',
             $dom;
         style += ';background-image:url(images/icons/pageback_' + appId + '.svg);background-size:cover';
         $dom = $('<div name="nextArrow" class="xut-flip-control right ' + state + '" style="' + style + '"></div>');

         $dom.on("touchend mouseup", function () {
             Xut.View.GotoNextSlide();
         });

         this.container.append($dom);
         this.arrows.next = {
             el: $dom,
             able: true
         };
     };

     /**
      * [ description]
      * @param  {[type]} dir [next,prev]
      * @param  {[type]} status  [true/false]
      * @return {[type]}       [description]
      */
     ToolBar.prototype.toggleArrow = function (dir, status) {
         var arrow = this.arrows[dir];
         //如果没有创建翻页按钮,则不处理
         if (!arrow) return;
         arrow.able = status;
         //如果人为隐藏了工具栏,则不显示翻页按钮
         if (this.hasTopBar && !this.barStatus && status) {
             return;
         }
         arrow.el[status ? 'show' : 'hide']();
     };

     //隐藏下一页按钮
     ToolBar.prototype.hideNext = function () {
         this.toggleArrow('next', false);
     };

     //显示下一页按钮
     ToolBar.prototype.showNext = function () {
         this.toggleArrow('next', true);
     };

     //隐藏上一页按钮
     ToolBar.prototype.hidePrev = function () {
         this.toggleArrow('prev', false);
     };

     //显示上一页按钮
     ToolBar.prototype.showPrev = function () {
         this.toggleArrow('prev', true);
     };

     /**
      * [ 显示翻页按钮]
      * @return {[type]}        [description]
      */
     ToolBar.prototype.showPageBar = function () {
         var arrows = this.arrows;

         for (var dir in arrows) {
             var arrow = arrows[dir];
             arrow.able && arrow.el.show();
         }
     };

     /**
      * [ 隐藏翻页按钮]
      * @param  {[type]} unlock [description]
      * @return {[type]}        [description]
      */
     ToolBar.prototype.hidePageBar = function () {
         var arrows = this.arrows;
         for (var dir in arrows) {
             arrows[dir].el.hide();
         }
     };

     /**
      * [description]
      * @param  {[type]} state   [description]
      * @param  {[type]} pointer [description]
      * @return {[type]}         [description]
      */
     ToolBar.prototype.toggle = function (state, pointer) {
         if (this.Lock) return;
         this.Lock = true;

         switch (state) {
             case 'show':
                 this.showToolbar(pointer);
                 break;
             case 'hide':
                 this.hideToolbar(pointer);
                 break;
             default:
                 this.barStatus ? this.hideToolbar(pointer) : this.showToolbar(pointer);
                 break;
         }
     };

     /**
      * [ 显示工具栏]
      * @param  {[type]} pointer [description]
      * @return {[type]}         [description]
      */
     ToolBar.prototype.showToolbar = function (pointer) {
         switch (pointer) {
             case 'controlBar':
                 this.showTopBar();
                 break;
             case 'button':
                 this.showPageBar();
                 this.Lock = false;
                 break;
             default:
                 this.showTopBar();
                 this.showPageBar();
         }
     };

     /**
      * [ 隐藏工具栏]
      * @param  {[type]} pointer [description]
      * @return {[type]}         [description]
      */
     ToolBar.prototype.hideToolbar = function (pointer) {
         switch (pointer) {
             case 'controlBar':
                 this.hideTopBar();
                 break;
             case 'button':
                 this.hidePageBar();
                 this.Lock = false;
                 break;
             default:
                 this.hideTopBar();
                 this.hidePageBar();
         }
     };

     /**
      * 显示IOS系统工具栏
      *  iOS状态栏0=show,1=hide
      * @return {[type]} [description]
      */
     ToolBar.prototype.showSystemBar = function () {
         isIOS$1 && Xut.Plugin.statusbarPlugin.setStatus(null, null, 0);
     };

     /**
      * 隐藏IOS系统工具栏
      * @return {[type]} [description]
      */
     ToolBar.prototype.hideSystemBar = function () {
         isIOS$1 && Xut.Plugin.statusbarPlugin.setStatus(null, null, 1);
     };

     //创建SVG按钮
     ToolBar.prototype.createSVGIcon = function (el, callback) {
         var options = {
             speed: 6000,
             size: {
                 w: this.iconHeight,
                 h: this.iconHeight
             },
             onToggle: callback
         };
         return new svgIcon(el, iconConfig, options);
     };

     //重置翻页按钮,状态以工具栏为标准
     ToolBar.prototype.reset = function () {
         this.barStatus ? this.showPageBar() : this.hidePageBar();
     };

     var sToolbar = ToolBar.extend({
         init: function init(options) {
             this.arrows = Object.create(null);
             this.curTips = null; //当前页码对象
             this.Lock = false; //操作锁
             this.delay = 50; //动画延时
             this.hasTopBar = true; //有顶部工具条
             this.controlBar = options.controlBar;
             this.container = options.container;
             this.pageMode = options.pageMode;
             this.pageTotal = options.pageTotal;
             this.currentPage = options.currentPage;

             //配置属性
             //config
             this.config = Xut.config;
             this.initConfig(this.config);

             this.initTool();
         }
     });

     sToolbar.prototype.initTool = function () {

         var bar = this.controlBar,
             setting = this.settings;

         //工具栏的显示状态
         this.barStatus = bar.css('display') === 'none' ? false : true;

         //工具栏摆放位置
         this.toolbarPostion(bar, setting.ToolbarPos);

         //首页按钮
         setting.HomeBut && this.createHomeIcon(bar);

         //目录按钮
         setting.ContentBut && this.createDirIcon(bar);

         //添加标题
         this.createTitle(bar);

         //关闭子文档
         setting.CloseBut && this.createCloseIcon(bar);

         //页码数
         setting.PageBut && this.createPageNum(bar);

         //工具栏隐藏按钮
         this.createHideToolbar(bar);

         //翻页按钮
         if (this.pageMode == 2) {
             this.createArrows();
         }

         //邦定事件
         this.bindButtonsEvent(bar);
     };

     //工具条的位置
     sToolbar.prototype.toolbarPostion = function (bar, position) {
         var height = this.iconHeight,
             TOP = this.barHeight;
         if (position == 1) {
             //在底部
             bar.css({
                 bottom: 0,
                 height: height + 'px'
             });
         } else {
             //在顶部
             bar.css({
                 top: 0,
                 height: height + 'px',
                 paddingTop: TOP + 'px'
             });
         }
     };

     //创建主页按钮
     sToolbar.prototype.createHomeIcon = function (bar) {
         var str = '<div id="backHome" style="float:left;text-indent:0.25em;height:{0}px;line-height:{1}px;color:#007aff">主页</div>',
             height = this.iconHeight,
             html = $(String.format(str, height, height));
         bar.append(html);
     };

     //创建目录按钮
     sToolbar.prototype.createDirIcon = function (bar) {
         var str = '<div id="backDir" class="xut-controlBar-backDir" style="float:left;margin-left:4px;width:{0}px;height:{1}px;background-size:cover"></div>',
             height = this.iconHeight,
             html = $(String.format(str, height, height));
         bar.append(html);
     };

     //创建页码数
     sToolbar.prototype.createPageNum = function (bar) {
         var height = this.iconHeight,
             marginTop = height * 0.25,
             iconH = height * 0.5,
             str,
             html;
         str = '<div class="xut-controlBar-pageNum" style="float:right;margin:{0}px 4px;padding:0 0.25em;height:{1}px;line-height:{2}px;border-radius:0.5em"><span>{3}</span>/<span>{4}</span></div>';
         html = $(String.format(str, marginTop, iconH, iconH, this.currentPage, this.pageTotal));
         this.curTips = html.children().first();
         bar.append(html);
     };

     //工具栏隐藏按钮
     sToolbar.prototype.createHideToolbar = function (bar) {
         var html,
             style,
             height = this.iconHeight;
         style = 'float:right;width:' + height + 'px;height:' + height + 'px;background-size:cover';
         html = '<div id="hideToolbar" class="xut-controlBar-hide" style="' + style + '"></div>';
         bar.append(html);
     };

     //关闭子文档按钮
     sToolbar.prototype.createCloseIcon = function (bar) {
         var style,
             html,
             height = this.iconHeight;
         style = 'float:right;margin-right:4px;width:' + height + 'px;height:' + height + 'px';
         html = '<div class="si-icon" data-icon-name="close" style="' + style + '"></div>';
         html = $(html);
         this.createSVGIcon(html[0], function () {
             if (SUbDOCCONTEXT) {
                 SUbDOCCONTEXT.Xut.publish('subdoc:dropApp');
             } else {
                 Xut.publish('magazine:dropApp');
             }
         });
         bar.append(html);
     };

     //应用标题
     sToolbar.prototype.createTitle = function (bar) {
         var style,
             html,
             appName = this.appName,
             height = this.iconHeight;
         style = 'width:100%;position:absolute;line-height:' + height + 'px;pointer-events:none';
         html = '<div class="xut-controlBar-title" style="z-index:-99;' + style + '">' + appName + '</div>';
         bar.append(html);
     };

     /**
      * [ 返回按钮]
      * @return {[type]} [description]
      */
     sToolbar.prototype.createBackIcon = function (container) {
         var style,
             html,
             height = this.iconHeight;
         style = 'float:left;width:' + height + 'px;height:' + height + 'px';
         html = '<div class="si-icon" data-icon-name="back" style="' + style + '"></div>';
         html = $(html);
         this.createSVGIcon(html[0], function () {
             Xut.Application.Suspend({
                 dispose: function dispose() {
                     //停止热点动作
                     Xut.Application.DropApp(); //退出应用
                 },
                 processed: function processed() {
                     Xut.Application.DropApp(); //退出应用
                 }
             });
         });
         container.append(html);
     };

     /**
      * 更新页码指示
      * @return {[type]} [description]
      */
     sToolbar.prototype.updatePointer = function (pageIndex) {
         this.curTips && this.curTips.html(pageIndex + 1);
     };

     sToolbar.prototype.bindButtonsEvent = function (bar) {
         var that = this;
         bar.on("touchend mouseup", function (e) {
             var type = Xut.plat.evtTarget(e).id;
             switch (type) {
                 case "backHome":
                     that.homeControl();
                     break;
                 case "backDir":
                     that.navigationBar();
                     break;
                 case 'hideToolbar':
                     that.hideTopBar();
                     break;
             }
         });
     };

     /**
      * [ 跳转处理]
      * @return {[type]} [description]
      */
     sToolbar.prototype.homeControl = function () {
         if (DUKUCONFIG) {
             Xut.Application.Suspend({
                 dispose: function dispose() {
                     Xut.Application.DropApp(); //退出应用
                 },
                 processed: function processed() {
                     Xut.Application.DropApp(); //退出应用
                 }
             });
             return;
         }

         Xut.Application.Suspend({
             dispose: function dispose(promptMessage) {
                 //停止热点动作
                 //promptMessage('再按一次将跳至首页！')
             },
             processed: function processed() {
                 Xut.View.GotoSlide(1); //调整到首页
             }
         });
     };

     /**
      * [ 打开目录关闭当前页面活动热点]
      * @return {[type]} [description]
      */
     sToolbar.prototype.navigationBar = function () {
         initNavBar(Xut.Presentation.GetPageIndex());
     };

     /**
      * [ 显示顶部工具栏]
      * @return {[type]} [description]
      */
     sToolbar.prototype.showTopBar = function () {
         var that = this;

         if (this.barStatus) {
             this.Lock = false;
             return;
         }
         this.controlBar.css({
             'display': 'block',
             'opacity': 0
         });

         setTimeout(function () {
             that.controlBar.animate({
                 'opacity': 1
             }, that.delay, 'linear', function () {
                 Navbar.close();
                 that.showSystemBar();
                 that.barStatus = true;
                 that.Lock = false;
             });
         });
     };

     /**
      * [ 隐藏顶部工具栏]
      * @return {[type]} [description]
      */
     sToolbar.prototype.hideTopBar = function () {
         var that = this;

         if (!this.barStatus) {
             this.Lock = false;
             return;
         }

         this.controlBar.animate({
             'opacity': 0
         }, that.delay, 'linear', function () {
             Navbar.close();
             that.controlBar.hide();
             that.hideSystemBar();
             that.barStatus = false;
             that.Lock = false;
         });
     };

     //销毁
     sToolbar.prototype.destroy = function () {
         this.controlBar.off();
         this.controlBar = null;
         this.arrows = null;
         this.curTips = null;
         this.barStatus = false;
     };

     var fToolbar = ToolBar.extend({
         init: function init(options) {
             this.pageTips = null;
             this.currTip = null;
             this.tipsMode = 0;
             this.top = 0;
             this.Lock = false;
             this.delay = 50;
             this.hasTopBar = false;
             this.barStatus = true;
             this.arrows = Object.create(null);
             //options
             this.pageMode = options.pageMode;
             this.id = options.id;
             this.container = options.container;
             this.tbType = options.tbType;
             this.pageTotal = options.pageTotal;
             this.currentPage = options.currentPage;

             //配置属性
             //config
             this.config = Xut.config;
             this.initConfig(this.config);

             this.initTool();
         }
     });

     /**
      * 创建工具栏
      * tbType:
      *		0	禁止工具栏
      *		1	系统工具栏   - 显示IOS系统工具栏
      *		2	场景工具栏   - 显示关闭按钮
      *		3	场景工具栏   - 显示返回按钮
      *		4	场景工具栏   - 显示顶部小圆点式标示
      *	pageMode:
      *  	0禁止滑动
      *	  	1允许滑动无翻页按钮
      *	   	2 允许滑动带翻页按钮
      * @return {[type]} [description]
      */
     fToolbar.prototype.initTool = function () {
         var container = this.container,
             type;

         container.hide();
         this.controlBar = [];

         while (type = this.tbType.shift()) {
             switch (type) {
                 case 1:
                     this.createSystemBar();
                     break;
                 case 2:
                     this.createCloseIcon();
                     break;
                 case 3:
                     this.createBackIcon(container);
                     break;
                 case 4:
                     this.createPageTips();
                     break;
                 default:
                     this.barStatus = false;
                     this.hasTopBar = false;
                     break;
             }
         }

         //创建翻页按钮
         if (this.pageMode === 2) {
             this.createArrows();
         }

         container.show();

         //邦定事件
         this.bindButtonsEvent();
     };

     /**
      * 系统工具栏
      */
     fToolbar.prototype.createSystemBar = function () {
         var id = this.id,
             TOP = this.barHeight,
             html = '',
             style = 'top:0;height:' + this.iconHeight + 'px;padding-top:' + TOP + 'px';
         html = '<div id="controlBar' + id + '" class="xut-controlBar" style="' + style + '"></div>';
         html = $(html);
         this.top = TOP;
         this.showSystemBar();
         this.createBackIcon(html);
         this.createTitle(html);
         this.createPageNum(html);
         this.controlBar = html;
         this.container.append(html);
         this.hasTopBar = true;
     };

     /**
      * 页码小圆点
      */
     fToolbar.prototype.createPageTips = function () {
         var chapters = this.pageTotal,
             height = this.iconHeight,
             TOP = this.top,
             isIOS = Xut.plat.isIOS,
             html = '';

         //如果只有一页则不显示小圆
         if (chapters < 2) {
             return '';
         }

         var calculate = this.config.proportion.calculateContainer();
         //圆点尺寸
         var size = isIOS ? 7 : Math.max(8, Math.round(this.propHeight * 8)),
             width = 2.5 * size,
             //圆点间距
         tipsWidth = chapters * width,
             //圆点总宽度
         top = (height - size) / 2,
             //保持圆点垂直居中
         left = (calculate.width - tipsWidth) / 2; //保持圆点水平居中

         html = '<ul class="xut-scenario-tips"  style="top:' + TOP + 'px;left:' + left + 'px;width:' + tipsWidth + 'px;opacity:0.6">';
         for (var i = 1; i <= chapters; i++) {
             html += '<li class="xut-scenario-dark" style="float:left;width:' + width + 'px;height:' + height + 'px;" data-index="' + i + '">';
             html += '<div class="xut-scenario-radius" style="width:' + size + 'px;height:' + size + 'px;margin:' + top + 'px auto"></div></li>';
         }
         html += '</ul>';
         html = $(html);
         this.pageTips = html.children();
         this.tipsMode = 1;
         this.controlBar.push(html);
         this.container.append(html);
     };

     /**
      * 更新页码指示
      * @return {[type]} [description]
      */
     fToolbar.prototype.updatePointer = function (pageIndex) {
         switch (this.tipsMode) {
             case 1:
                 if (this.prevTip) {
                     this.prevTip.className = 'xut-scenario-dark';
                 }
                 this.currTip = this.pageTips[pageIndex];
                 this.currTip.className = 'xut-scenario-light';
                 this.prevTip = this.currTip;
                 break;
             case 2:
                 this.currTip.html(pageIndex + 1);
                 break;
             default:
                 break;
         }
     };

     /**
      * [ 关闭按钮]
      * @return {[type]} [description]
      */
     fToolbar.prototype.createCloseIcon = function () {
         var style,
             html,
             TOP = this.top,
             height = this.iconHeight;
         style = 'top:' + TOP + 'px;width:' + height + 'px;height:' + height + 'px';
         html = '<div class="si-icon xut-scenario-close" data-icon-name="close" style="' + style + '"></div>';
         html = $(html);
         this.createSVGIcon($(html)[0], function () {
             Xut.View.CloseScenario();
         });
         this.controlBar.push(html);
         this.container.append(html);
     };

     /**
      * [ 返回按钮]
      * @return {[type]} [description]
      */
     fToolbar.prototype.createBackIcon = function (container) {
         var style,
             html,
             TOP = this.top,
             height = this.iconHeight;
         style = 'top:' + TOP + 'px;width:' + height + 'px;height:' + height + 'px';
         html = '<div class="si-icon xut-scenario-back" data-icon-name="back" style="' + style + '"></div>';
         html = $(html);
         this.createSVGIcon(html[0], function () {
             Xut.View.CloseScenario();
         });
         this.controlBar.push(html);
         container.append(html);
     };

     //创建页码数
     fToolbar.prototype.createPageNum = function (container) {
         var pageTotal = this.pageTotal,
             TOP = this.top,
             height = this.iconHeight,
             currentPage = this.currentPage,
             style,
             html;
         style = 'position:absolute;right:4px;top:' + (height * 0.25 + TOP) + 'px;padding:0 0.25em;height:' + height * 0.5 + 'px;line-height:' + height * 0.5 + 'px;border-radius:0.5em';
         html = '<div class="xut-controlBar-pageNum" style="' + style + '">';
         html += '<span class="currentPage">' + currentPage + '</span>/<span>' + pageTotal + '</span>';
         html += '</div>';
         html = $(html);
         this.tipsMode = 2;
         this.currTip = html.children().first();
         container.append(html);
     };

     //工具栏隐藏按钮
     fToolbar.prototype.createHideToolbar = function (container) {
         var html,
             style,
             TOP = this.top,
             height = this.iconHeight,
             right = iconHeight * 2.5;
         style = 'position:absolute;right:' + right + 'px;top:' + TOP + 'px;width:' + height + 'px;height:' + height + 'px;background-size:cover';
         html = '<div class="xut-controlBar-hide" style="' + style + '"></div>';
         container.append(html);
     };

     //应用标题
     fToolbar.prototype.createTitle = function (container) {
         var style,
             html,
             appName = this.appName;
         style = 'line-height:' + this.iconHeight + 'px';
         html = '<div class="xut-controlBar-title" style="' + style + '">' + appName + '</div>';
         container.append(html);
     };

     /**
      * [ 普通按钮邦定事件]
      * @param  {[type]} bar [description]
      * @return {[type]}     [description]
      */
     fToolbar.prototype.bindButtonsEvent = function () {
         var that = this,
             index = 1,
             id = this.id;

         this.container.on("touchend touchend", function (e) {
             var target = Xut.plat.evtTarget(e),
                 type = target.className;
             switch (type) {
                 case 'xut-controlBar-hide':
                     that.hideTopBar();
                     break;
                 case 'xut-scenario-dark':
                     if (that.pageMode) {
                         index = target.getAttribute('data-index') || 1;
                         Xut.View.GotoSlide(Number(index));
                     }
                     break;
                 default:
                     break;
             }
         });
     };

     /**
      * [ 显示顶部工具栏]
      * @return {[type]} [description]
      */
     fToolbar.prototype.showTopBar = function () {
         var that = this,
             delay = this.delay,
             controlBar = this.controlBar;
         if (this.barStatus) {
             this.Lock = false;
             return;
         }
         if (this.hasTopBar) {
             controlBar.css({
                 'display': 'block',
                 'opacity': 0
             });
             setTimeout(function () {
                 controlBar.animate({
                     'opacity': 1
                 }, delay, 'linear', function () {
                     that.showSystemBar();
                     that.barStatus = true;
                     that.Lock = false;
                 });
             });
         } else {
             controlBar.forEach(function (el) {
                 el.show();
                 that.Lock = false;
                 that.barStatus = true;
             });
         }
     };

     /**
      * [ 隐藏顶部工具栏]
      * @return {[type]} [description]
      */
     fToolbar.prototype.hideTopBar = function () {
         var that = this,
             delay = this.delay,
             controlBar = this.controlBar;

         if (!this.barStatus) {
             this.Lock = false;
             return;
         }
         if (this.hasTopBar) {
             controlBar.animate({
                 'opacity': 0
             }, delay, 'linear', function () {
                 that.controlBar.hide();
                 that.hideSystemBar();
                 that.barStatus = false;
                 that.Lock = false;
             });
         } else {
             controlBar.forEach(function (el) {
                 el.hide(delay, function () {
                     that.Lock = false;
                     that.barStatus = false;
                 });
             });
         }
     };

     fToolbar.prototype.destroy = function () {
         this.container.off();
         this.controlBar = null;
         this.arrows = null;
         this.pageTips = null;
         this.currTip = null;
         this.prevTip = null;
     };

     var icons = {
     	hide: 'images/icons/arrowDown.svg'
     };
     var sLineHeiht = parseInt($('body').css('font-size')) || 16;
     var BOOKCACHE;
     //书签缓存

     function BookMark(options) {
     	this.parent = options.parent;
     	this.pageId = options.pageId;
     	this.seasonId = options.seasonId;

     	this.screenSize = Xut.config.screenSize, this.sHeight = screenSize.height, this.sWidth = screenSize.width,

     	//是否已存储
     	this.isStored = false;
     	this.init();
     }

     /**
      * 初始化
      * @return {[type]} [description]
      */
     BookMark.prototype.init = function () {
     	var $bookMark = this.createBookMark(),
     	    dom = this.parent[0],
     	    that = this;

     	this.parent.append($bookMark);
     	this.bookMarkMenu = $bookMark.eq(0);
     	//显示书签
     	setTimeout(function () {
     		that.restore();
     	}, 20);
     	//获取历史记录
     	BOOKCACHE = this.getHistory();

     	//邦定用户事件
     	Xut.plat.execEvent('on', {
     		context: dom,
     		callback: {
     			end: this
     		}
     	});
     };

     /**
      * 创建书签
      * @return {[object]} [jquery生成的dom对象]
      */
     BookMark.prototype.createBookMark = function () {
     	var height = sLineHeiht * 3,
     	    // menu的高为3em
     	box = '<div class="xut-bookmark-menu" style="width:100%;height:{0}px;left:0;top:{1}px;">' + '<div class="xut-bookmark-wrap">' + '<div class="xut-bookmark-add">加入书签</div>' + '<div class="xut-bookmark-off" style="background-image:url({2})"></div>' + '<div class="xut-bookmark-view">书签记录</div>' + '</div>' + '</div>' + '<div class="xut-bookmark-list" style="display:none;width:100%;height:{3}px;">' + '<ul class="xut-bookmark-head">' + '<li class="xut-bookmark-back">返回</li>' + '<li>书签</li>' + '</ul>' + '<ul class="xut-bookmark-body"></ul>' + '</div>';
     	box = String.format(box, height, this.sHeight, icons.hide, this.sHeight);
     	this.markHeight = height;
     	return $(box);
     };

     /**
      * 生成书签列表
      * @return {[type]} [description]
      */
     BookMark.prototype.createMarkList = function () {
     	var tmp,
     	    seasonId,
     	    pageId,
     	    list = '',
     	    box = '',
     	    self = this;

     	//取历史记录
     	_.each(BOOKCACHE, function (mark) {
     		tmp = mark.split('-');
     		seasonId = tmp[0];
     		pageId = tmp[1];
     		mark = self.getMarkId(seasonId, pageId);
     		list += '<li><a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">第' + pageId + '页</a><a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a></li>';
     	});

     	return list;
     };

     /**
      * 创建存储标签
      * 存储格式 seasonId-pageId
      * @return {string} [description]
      */
     BookMark.prototype.getMarkId = function (seasonId, pageId) {
     	return seasonId + '-' + pageId;
     };

     /**
      * 获取历史记录
      * @return {[type]} [description]
      */
     BookMark.prototype.getHistory = function () {
     	var mark = _get('bookMark');
     	if (mark) {
     		return mark.split(',');
     	}
     	return [];
     };

     /**
      * 添加书签
      * @return {[type]} [description]
      */
     BookMark.prototype.addBookMark = function () {
     	var key;

     	this.updatePageInfo();
     	key = this.getMarkId(this.seasonId, this.pageId);

     	//避免重复缓存
     	if (BOOKCACHE.indexOf(key) > -1) {
     		return;
     	}
     	BOOKCACHE.push(key);
     	_set('bookMark', BOOKCACHE);
     };

     /**
      * 更新页信息
      *  针对母板层上的书签
      */
     BookMark.prototype.updatePageInfo = function () {
     	var pageData = Xut.Presentation.GetPageData();
     	this.pageId = pageData._id;
     	this.seasonId = pageData.seasonId;
     };

     /**
      * 删除书签
      * @param {object} [key] [事件目标对象]
      * @return {[type]} [description]
      */
     BookMark.prototype.delBookMark = function (target) {
     	if (!target || !target.dataset) return;

     	var key = target.dataset.mark,
     	    index = BOOKCACHE.indexOf(key);

     	BOOKCACHE.splice(index, 1);
     	_set('bookMark', BOOKCACHE);

     	if (BOOKCACHE.length == 0) {
     		_remove('bookMark');
     	}

     	//移除该行
     	$(target).parent().remove();
     };

     /**
      * 显示书签
      * @param {object} [target] [事件目标对象]
      * @return {[type]} [description]
      */
     BookMark.prototype.viewBookMark = function (target) {
     	var $bookMarkList,
     	    list = this.createMarkList();

     	if (this.bookMarkList) {
     		$bookMarkList = this.bookMarkList;
     	} else {
     		$bookMarkList = $(target).parent().parent().next();
     	}
     	//更新书签内容
     	$bookMarkList.find('.xut-bookmark-body').html(list);
     	this.bookMarkList = $bookMarkList;
     	$bookMarkList.fadeIn();
     };

     /**
      * 点击放大效果
      * @param  {[object]} target [事件目标对象]
      * @return {[type]}      [description]
      */
     BookMark.prototype.iconManager = function (target) {
     	var $icon = this.bookMarkIcon = $(target),
     	    restore = this.iconRestore;

     	$icon.css({
     		'transform': 'scale(1.2)',
     		'transition-duration': '500ms'
     	})[0].addEventListener(Xut.plat.TRANSITION_EV, restore.bind(this), false);
     };

     /**
      * 复原按钮
      * @return {[type]} [description]
      */
     BookMark.prototype.iconRestore = function () {
     	this.bookMarkIcon.css('transform', '');
     };

     /**
      * 跳转到书签页
      * @param  {[type]} target [description]
      * @return {[type]}        [description]
      */
     BookMark.prototype.goBookMark = function (target) {
     	if (!target || !target.dataset) return;

     	var key = target.dataset.mark.split('-'),
     	    seasonId = Number(key[0]),
     	    pageId = Number(key[1]);

     	this.updatePageInfo();
     	//关闭书签列表
     	this.backBookMark();

     	//忽略当前页的跳转
     	if (this.pageId == pageId && this.seasonId == seasonId) {
     		return;
     	}

     	Xut.View.LoadScenario({
     		'scenarioId': seasonId,
     		'chapterId': pageId
     	});
     };

     /**
      * 书签回退键
      * @return {[type]} [description]
      */
     BookMark.prototype.backBookMark = function () {
     	this.bookMarkList.fadeOut();
     };

     /**
      * 邦定事件
      * @param  {[type]} evt [事件]
      * @return {[type]}     [description]
      */
     BookMark.prototype.handleEvent = function (evt) {
     	var target = evt.target;
     	switch (target.className) {
     		//加入书签
     		case 'xut-bookmark-add':
     			this.addBookMark();
     			this.iconManager(target);
     			break;
     		//显示书签记录
     		case 'xut-bookmark-view':
     			this.viewBookMark(target);
     			this.iconManager(target);
     			break;
     		//关闭书签
     		case 'xut-bookmark-off':
     			this.closeBookMark(target);
     			break;
     		//返回书签主菜单
     		case 'xut-bookmark-back':
     			this.backBookMark();
     			break;
     		//删除书签记录
     		case 'xut-bookmark-del':
     			this.delBookMark(target);
     			break;
     		//跳转到书签页
     		case 'xut-bookmark-id':
     			this.goBookMark(target);
     			break;
     		default:
     			//console.log(target.className)
     			break;
     	}
     };

     /**
      * 关闭书签菜单
      * @return {[type]} [description]
      */
     BookMark.prototype.closeBookMark = function (target) {
     	this.bookMarkMenu.css({
     		transform: 'translate3d(0,0,0)',
     		'transition-duration': '1s'
     	});
     };

     /**
      * 恢复书签菜单
      */
     BookMark.prototype.restore = function () {
     	this.bookMarkMenu.css({
     		transform: 'translate3d(0,-' + this.markHeight + 'px,0)',
     		'transition-duration': '1s'
     	});
     };

     /**
      * 销毁书签
      * @return {[type]} [description]
      */
     BookMark.prototype.destroy = function () {
     	var dom = this.parent[0],
     	    events = Xut.plat;

     	dom.removeEventListener('touchend', this, false);
     	dom.removeEventListener('mouseup', this, false);

     	//菜单部分
     	if (this.bookMarkMenu) {
     		this.bookMarkMenu.remove();
     		this.bookMarkMenu = null;
     	}

     	//列表部分
     	if (this.bookMarkList) {
     		this.bookMarkList.remove();
     		this.bookMarkList = null;
     	}

     	//按钮效果
     	if (this.bookMarkIcon) {
     		this.bookMarkIcon[0].removeEventListener(events.TRANSITION_EV, this.iconRestore, false);
     		this.bookMarkIcon = null;
     	}

     	this.parent = null;
     };

     /**
      * 阅读模式工具栏
      * @param options object
      * @demo {container:页面容器,controlBar:工具栏容器,...}
      * @desc 继承自Toolbar.js
      */

     var Bar = ToolBar.extend({
         init: function init(options) {
             //左右箭头
             this.arrows = {};
             //工具栏父容器
             this.container = options.container;
             //工具栏容器
             this.controlBar = options.controlBar;
             this.pageMode = options.pageMode;
             //是否有顶部工具栏
             this.hasTopBar = true;
             this.Lock = false;
             this.delay = 50;
             //图书工具栏高度
             this.topBarHeight = this.iconHeight * 1.25;

             //配置属性
             //config
             this.config = Xut.config;
             this.initConfig(this.config);

             this.initTool();
         }
     });

     /**
      * 初始化
      */
     Bar.prototype.initTool = function () {
         //工具栏的显示状态
         var display = this.controlBar.css('display');
         this.barStatus = display == 'none' ? false : true;
         this.setToolbarStyle();
         this.createBackIcon();
         this.createDirIcon();
         this.createMarkIcon();
         // this.createStarIcon();

         //翻页按钮
         if (this.pageMode == 2) {
             this.createArrows();
         }

         //监听事件
         var ele = this.container[0];

         Xut.plat.execEvent('on', {
             context: ele,
             callback: {
                 end: this
             }
         });
     };

     /**
      * 工具条的样式
      */
     Bar.prototype.setToolbarStyle = function () {
         var height = this.topBarHeight,
             TOP = this.barHeight; //系统工具栏占用的高度

         //在顶部
         this.controlBar.css({
             top: 0,
             height: height + 'px',
             paddingTop: TOP + 'px',
             backgroundColor: 'rgba(0, 0, 0, 0.2)', //transparent
             fontSize: '0.625em',
             color: 'white'
         });
     };

     /**
      * 更新页码
      */
     Bar.prototype.updatePointer = function () {}
     //预留


     /**
      * 创建目录图标
      */
     ;Bar.prototype.createDirIcon = function (bar) {
         var icon = document.createElement('div');
         icon.innerHTML = '目录';
         icon.style.width = this.iconHeight + 'px';
         icon.style.lineHeight = 1.5 * this.topBarHeight + 'px';
         icon.className = 'xut-book-bar-dir';
         this.controlBar.append(icon);
     };

     //创建书签图标
     Bar.prototype.createMarkIcon = function (bar) {
         var icon = document.createElement('div');
         icon.innerHTML = '书签';
         icon.style.width = this.iconHeight + 'px';
         icon.style.lineHeight = 1.5 * this.topBarHeight + 'px';
         icon.className = 'xut-book-bar-mark';
         this.controlBar.append(icon);
     };

     /**
      * 创建评分图标
      */
     Bar.prototype.createStarIcon = function (bar) {
         var icon = document.createElement('div');
         icon.innerHTML = '评分';
         icon.style.width = this.iconHeight + 'px';
         icon.style.lineHeight = 1.5 * this.topBarHeight + 'px';
         icon.className = 'xut-book-bar-star';
         this.controlBar.append(icon);
     };

     /**
      * 后退按钮
      * @return {[type]} [description]
      */
     Bar.prototype.createBackIcon = function () {
         var icon = document.createElement('div');
         icon.style.width = this.topBarHeight + 'px';
         icon.className = 'xut-book-bar-back';
         this.controlBar.append(icon);
     };

     /**
      * 显示顶部工具栏
      * @return {[type]} [description]
      */
     Bar.prototype.showTopBar = function () {
         var that = this;

         if (this.barStatus) {
             this.Lock = false;
             return;
         }

         this.controlBar.css({
             'display': 'block',
             'opacity': 0
         });

         setTimeout(function () {
             that.controlBar.animate({
                 'opacity': 1
             }, that.delay, 'linear', function () {
                 that.showSystemBar();
                 that.barStatus = true;
                 that.Lock = false;
             });
         }, 50);
     };

     /**
      * 隐藏顶部工具栏
      * @return {[type]} [description]
      */
     Bar.prototype.hideTopBar = function () {
         var that = this;

         if (!this.barStatus) {
             this.Lock = false;
             return;
         }

         this.controlBar.animate({
             'opacity': 0
         }, that.delay, 'linear', function () {
             that.controlBar.hide();
             that.hideSystemBar();
             that.barStatus = false;
             that.Lock = false;
         });
     };

     /**
      * 创建目录菜单
      */
     Bar.prototype.createDirMenu = function () {
         var self = this;
         var wrap = document.createElement('div');
         var mask = document.createElement('div');
         //添加遮层
         mask.className = 'xut-book-menu-mask';
         //获取内容
         this.getDirContent();
         wrap.className = 'xut-book-menu';
         wrap.innerHTML = '<ul>' + this.contentText + '</ul>';
         this.container.append(wrap);
         //是否滚动
         this.isScrolled = false;
         //添加滚动条
         //url : http://iscrolljs.com/
         iscroll = new iScroll(wrap, {
             scrollbars: true,
             fadeScrollbars: true,
             scrollX: false
         });

         this.menu = wrap;

         this.setColor();

         iscroll.on('scrollStart', function (e) {
             self.isScrolled = true;
         });

         iscroll.on('scrollEnd', function (e) {
             self.isScrolled = false;
         });

         wrap.appendChild(mask);

         this.iscroll = iscroll;
     };

     /**
      *  显示目录菜单
      */
     Bar.prototype.showDirMenu = function () {
         //获取当前页面
         var page = Xut.Presentation.GetPageElement();

         if (this.menu) {
             this.menu.style.display = 'block';
         } else {
             this.createDirMenu();
         }

         //添加模糊效果
         page.addClass('filter');
         this.page = page;

         //隐藏顶部工具栏
         this.controlBar.hide();
         var iscroll = this.iscroll;
         //自动定位到上一位置
         if (iscroll.y > iscroll.wrapperHeight) {
             iscroll.scrollToElement(this.selectedChild);
         }
     };

     /**
      *  隐藏目录菜单
      */
     Bar.prototype.hideDirMenu = function () {
         this.menu.style.display = 'none';
         //恢复顶部工具栏
         this.controlBar.show();
         //移除模糊效果
         this.page.removeClass('filter');
     };

     /**
      *  创建目录内容
      */
     Bar.prototype.getDirContent = function () {

         var Api = Xut.Presentation;
         var data = Api.GetAppSectionData();
         var sns = data[0];
         var seaonId = sns._id;
         var cids = Xut.data.Chapter;

         ////////////////////////////
         //针对book模式，合并了Season的参数 //
         //1 SeasonTitle
         //2 ChapterList列表的范围区间
         ////////////////////////////
         data = parseJSON(sns.parameter);

         if (!data) {
             console.log('book模式parameter数据出错');
             return;
         }

         //二级目录
         function secondaryDirectory(startCid, endCid) {
             var cid,
                 str = '';
             for (startCid; startCid <= endCid; startCid++) {
                 cid = cids.item(startCid - 1);
                 if (cid && cid.chapterTitle) {
                     str += '<section><a class="xut-book-menu-item" data-mark=' + seaonId + '-' + startCid + ' href="javascript:0">' + cid.chapterTitle + '</a></section>';
                 }
             }
             return str;
         }

         var i = 0;
         var len = data.length;
         var li = '<li class="title"><center class="select">目录</center></li>';
         var seasonInfo, mark, seasonTitle, seaonId, startCid, endCid;

         for (i; i < len; i++) {
             seasonInfo = data[i];
             startCid = seasonInfo.ChapterList[0];
             endCid = seasonInfo.ChapterList[1];
             mark = seaonId + '-' + startCid;
             if (seasonInfo.SeasonTitle.length <= 0) continue;
             seasonTitle = seasonInfo.SeasonTitle || '第' + (i + 1) + '章';
             //第一级目录
             li += '<li>' + '<a class="xut-book-menu-item" data-mark="' + mark + '" href="javascript:0">' + seasonTitle + '</a>' +
             //第二级目录
             secondaryDirectory(startCid, endCid);
             '</li>';
         }

         this.contentText = li;
     };

     /**
      * 突出显示点击颜色
      */
     Bar.prototype.setColor = function (element) {
         if (this.selectedChild) {
             this.selectedChild.className = 'xut-book-menu-item';
         }

         element = element || this.menu.querySelectorAll('li')[1].children[0];
         element.className = 'select';
         this.selectedChild = element;
     };

     /**
      * 跳转到指定书页
      */
     Bar.prototype.turnToPage = function (target) {
         //忽略滚动点击
         if (this.isScrolled) return;
         this.setColor(target);
         this.hideDirMenu();
         var data = target.dataset.mark || '';
         if (data) {
             data = data.split('-');
             Xut.View.LoadScenario({
                 'scenarioId': data[0],
                 'chapterId': data[1]
             });
         }
     };

     /**
      * 显示书签
      */
     Bar.prototype.showBookMark = function () {
         if (this.bookMark) {
             this.bookMark.restore();
         } else {
             var pageData = Xut.Presentation.GetPageData();
             this.bookMark = new BookMark({
                 parent: this.container,
                 seasonId: pageData.seasonId,
                 pageId: pageData._id
             });
         }
     };

     /**
      * 返回首页
      */

     Bar.prototype.goBack = function () {
         var self = this;
         Xut.Application.Suspend({
             dispose: function dispose(promptMessage) {
                 //停止热点动作
                 //promptMessage('再按一次将跳至首页！')
             },
             processed: function processed() {
                 Xut.View.GotoSlide(1); //调整到首页
                 self.setColor();
             }
         });
     };

     /**
      * 事件处理
      */
     Bar.prototype.handleEvent = function (e) {

         var target = e.target || e.srcElement;

         var name = target.className;

         switch (name) {
             case 'xut-book-bar-back':
                 this.goBack();
                 //返回
                 break;
             case 'xut-book-bar-dir':
                 //目录
                 this.showDirMenu();
                 break;
             case 'xut-book-bar-mark':
                 //书签
                 this.showBookMark();
                 break;
             case 'xut-book-bar-star':
                 //评分
                 break;
             case 'xut-book-menu-item':
                 //跳转
                 this.turnToPage(target);
                 break;
             case 'xut-book-menu-mask':
             case 'select':
                 this.hideDirMenu();
                 break;
             default:
                 // console.log(name+':undefined')
                 break;
         }
     };

     /**
      * 销毁
      */
     Bar.prototype.destroy = function () {
         this.iscroll && this.iscroll.destroy();
         this.bookMark && this.bookMark.destroy();
         var ele = this.container[0];
         ele.removeEventListener('touchend', this, false);
         ele.removeEventListener('mouseup', this, false);
         this.iscroll = null;
         this.menu = null;
         this.page = null;
     };

     /**
      *
      * 基本事件管理
      *
      */

     var observe = function (slice) {

         var ArrayProto = Array.prototype;
         var nativeIndexOf = ArrayProto.indexOf;
         var slice = ArrayProto.slice;

         function bind(event, fn) {
             var i, part;
             var events = this.events = this.events || {};
             var parts = event.split(/\s+/);
             var num = parts.length;

             for (i = 0; i < num; i++) {
                 events[part = parts[i]] = events[part] || [];
                 if (_indexOf(events[part], fn) === -1) {
                     events[part].push(fn);
                 }
             }
             return this;
         }

         function one(event, fn) {
             // [notice] The value of fn and fn1 is not equivalent in the case of the following MSIE.
             // var fn = function fn1 () { alert(fn === fn1) } ie.<9 false
             var fnc = function fnc() {
                 this.unbind(event, fnc);
                 fn.apply(this, slice.call(arguments));
             };
             this.bind(event, fnc);
             return this;
         }

         function unbind(event, fn) {
             var eventName, i, index, num, parts;
             var events = this.events;

             if (!events) return this;

             //指定
             if (arguments.length) {
                 parts = event.split(/\s+/);
                 for (i = 0, num = parts.length; i < num; i++) {
                     if ((eventName = parts[i]) in events !== false) {
                         index = fn ? _indexOf(events[eventName], fn) : -1;
                         if (index !== -1) {
                             events[eventName].splice(index, 1);
                         }
                     }
                 }
             } else {
                 this.events = null;
             }

             return this;
         }

         function trigger(event) {
             var args, i;
             var events = this.events,
                 handlers;

             if (!events || event in events === false) {
                 return this;
             }

             args = slice.call(arguments, 1);
             handlers = events[event];
             for (i = 0; i < handlers.length; i++) {
                 handlers[i].apply(this, args);
             }
             return this;
         }

         function _indexOf(array, needle) {
             var i, l;

             if (nativeIndexOf && array.indexOf === nativeIndexOf) {
                 return array.indexOf(needle);
             }

             for (i = 0, l = array.length; i < l; i++) {
                 if (array[i] === needle) {
                     return i;
                 }
             }
             return -1;
         }

         return function () {
             this.$watch = this.bind = bind;
             this.$off = this.unbind = unbind;
             this.$emit = trigger;
             this.$once = one;
             return this;
         };
     }([].slice);

     /**
      * 初始化首次范围
      * @return {[type]} [description]
      */
     function initPointer(init, pagetotal) {
         var leftscope = 0,
             pagePointer = {};

         if (init === leftscope) {
             //首页
             pagePointer['currIndex'] = init;
             pagePointer['rightIndex'] = init + 1;
         } else if (init === pagetotal - 1) {
             //首页
             pagePointer['currIndex'] = init;
             pagePointer['leftIndex'] = init - 1;
         } else {
             //中间页
             pagePointer['leftIndex'] = init - 1;
             pagePointer['currIndex'] = init;
             pagePointer['rightIndex'] = init + 1;
         }

         return pagePointer;
     }

     //============================
     //
     //    自定义事件类型
     //
     // //触屏点击
     // 'onSwipeDown',
     // //触屏移动
     // 'onSwipeMove',
     // //触屏松手
     // 'onSwipeUp',
     // //触屏松手 滑动处理
     // 'onSwipeUpSlider',
     // //松手动画（反弹）
     // 'onFlipSliding',
     // //执行反弹
     // 'onFlipRebound',
     // //动画完成
     // 'onAnimComplete',
     // //退出应用
     // 'onDropApp'

     //element   根容器元素
     //pageIndex 页面索引
     function GlobalEvent(options, config) {

         options.hindex = options.initIndex;

         this.screenWidth = config.screenSize.width;

         _.extend(this, options);

         // this.element = options.rootPage;
         this.element = options.container;

         /**
          * 翻页时间
          * @type {Number}
          */
         this.speed = options.pageFlip ? 0 : 500;

         /**
          * 翻页速率
          * @type {Number}
          */
         this.clickSpeed = 600;

         /**
          * 速率
          * @type {[type]}
          */
         this.speedRate = this.originalRate = this.speed / this.screenWidth;

         /**
          * 计算初始化页码
          * @type {[type]}
          */
         this.pagePointer = initPointer(options.hindex, options.pagetotal);

         /**
          * 初始化绑定事件
          */
         if (!this.prveIndex) {
             this.prveIndex = this.hindex;
         }

         //ibooks不绑定全局事件
         // if (!Xut.IBooks.runMode()) {
         this._bindEvt();
         // }

         //用于查找跟元素
         var ul = this.element.querySelectorAll('ul');
         this.bubbleNode = {
             page: ul[0],
             master: ul[1]
         };
     };

     var edProto = GlobalEvent.prototype;

     /**
      * 首位越界处理，不反弹
      * @param  {[type]} deltaX [description]
      * @return {[type]}        [description]
      */
     edProto.overstep = function (deltaX) {
         //首页,并且是左滑动
         if (this.hindex === 0 && deltaX > 0) {
             return true;
             //尾页
         } else if (this.hindex === this.pagetotal - 1 && deltaX < 0) {
                 return true;
             }
     };

     /**
      * 前翻页接口
      * @return {[type]} [description]
      */
     edProto.prev = function () {
         if (!this.overstep(1)) {
             this.slideTo('prev');
         };
     };

     /**
      * 后翻页接口
      * @return {Function} [description]
      */
     edProto.next = function () {
         if (!this.overstep(-1)) {
             this.slideTo('next');
         }
     };

     /**
      * 检车是否还在移动中
      * @return {Boolean} [description]
      */
     edProto.isMove = function () {
         return this.fliplock;
     };

     /**
      * 是否为边界
      * @param  {[type]}  distance [description]
      * @return {Boolean}          [description]
      */
     edProto.isBorder = function (distance) {
         //起点左偏移
         if (this.hindex === 0 && distance > 0) {
             return true;
         }
         //终点右偏移
         if (this.hindex === this.pagetotal - 1 && distance < 0) {
             return true;
         }
     };

     /**
      * 目标元素
      * 找到li元素
      * @param  {Function} callback [description]
      * @return {[type]}            [description]
      */
     edProto.findRootElement = function (point, pageType) {
         var liNode,
             map,
             hindex = this.hindex,
             sectionRang = this.sectionRang,

         //找到对应的li
         childNodes = this.bubbleNode[pageType].childNodes,
             numNodes = childNodes.length;

         while (numNodes--) {
             liNode = childNodes[numNodes];
             map = liNode.getAttribute('data-map');
             if (sectionRang) {
                 hindex += sectionRang.start;
             }
             if (map == hindex) {
                 return liNode;
             }
             hindex = this.hindex;
         }
     };

     /**
      * 溢出控制
      * @param  {[type]} direction [description]
      * @return {[type]}           [description]
      */
     edProto.scopePointer = function (direction) {
         var overflow,
             pointer = this.pagePointer,
             fillength = Object.keys(pointer).length;

         switch (direction) {
             case 'prev':
                 //前翻页
                 overflow = pointer.currIndex === 0 && fillength === 2 ? true : false;
                 break;
             case 'next':
                 //后翻页
                 overflow = pointer.currIndex === this.pagetotal - 1 && fillength === 2 ? true : false;
                 break;
         }

         return {
             pointer: pointer,
             overflow: overflow //是否溢出
         };
     };

     //转换页码索引
     //direction 方向
     //pointer 当前页码标示
     //[17 18 19]  pagePointer
     //[18 19 20]  转换后
     // 17 销毁
     // 20 创建
     edProto.shiftPointer = function (pointer) {
         var createPointer, //创建的页
         destroyPointer; //销毁的页

         switch (this.direction) {
             case 'prev':
                 //前处理
                 createPointer = pointer.leftIndex - 1;
                 destroyPointer = pointer.rightIndex;
                 break;
             case 'next':
                 //后处理
                 createPointer = pointer.rightIndex + 1;
                 destroyPointer = pointer.leftIndex;
                 break;
         }

         pointer['createPointer'] = createPointer;
         pointer['destroyPointer'] = destroyPointer;

         return pointer;
     };

     //修正页码指示
     edProto.revisedFilpPointer = function (pointer) {

         //需要停止动作的页面索引
         var stopPointer = pointer.currIndex;

         switch (this.direction) {
             case 'prev':
                 //前处理
                 if (-1 < pointer.createPointer) {
                     //首页情况
                     this.updataPointer(pointer.createPointer, pointer.leftIndex, pointer.currIndex);
                 }
                 if (-1 === pointer.createPointer) {
                     this.pagePointer['rightIndex'] = pointer.currIndex;
                     this.pagePointer['currIndex'] = pointer.leftIndex;
                     delete this.pagePointer['leftIndex'];
                 }
                 break;
             case 'next':
                 //后处理
                 if (this.pagetotal > pointer.createPointer) {
                     this.updataPointer(pointer.currIndex, pointer.rightIndex, pointer.createPointer);
                 }
                 if (this.pagetotal === pointer.createPointer) {
                     //如果是尾页
                     this.pagePointer['leftIndex'] = pointer.currIndex;
                     this.pagePointer['currIndex'] = pointer.rightIndex;
                     delete this.pagePointer['rightIndex'];
                 }
                 break;
         }

         this.pagePointer['createPointer'] = pointer.createPointer;
         this.pagePointer['destroyPointer'] = pointer.destroyPointer;
         this.pagePointer['stopPointer'] = stopPointer;

         return this.pagePointer;
     };

     //更新页码标示
     edProto.updataPointer = function (leftIndex, currIndex, rightIndex) {
         if (arguments.length === 3) {
             this.pagePointer = {
                 'leftIndex': leftIndex,
                 'currIndex': currIndex,
                 'rightIndex': rightIndex
             };
             return;
         }

         if (arguments.length === 1) {
             var data = leftIndex;
             var viewFlip = data['viewFlip'];

             this.fixHindex(data.targetIndex);

             if (viewFlip.length === 3) {
                 this.updataPointer(viewFlip[0], viewFlip[1], viewFlip[2]);
             }
             if (viewFlip.length === 2) {
                 if (viewFlip[0] === 0) {
                     //首页
                     this.pagePointer['rightIndex'] = viewFlip[1];
                     this.pagePointer['currIndex'] = viewFlip[0];
                     delete this.pagePointer['leftIndex'];
                 } else {
                     //尾页
                     this.pagePointer['leftIndex'] = viewFlip[0];
                     this.pagePointer['currIndex'] = viewFlip[1];
                     delete this.pagePointer['rightIndex'];
                 }
             }
             return;
         }
     };

     //修正页面索引
     edProto.fixHindex = function (currIndex) {
         this.hindex = currIndex; //翻页索引
     };

     edProto.slideTo = function (direction) {
         var resolve;
         //如果在忙碌状态,如果翻页还没完毕
         if (Xut.busyBarState || this.fliplock) {
             return;
         };
         resolve = this.scopePointer(direction);
         if (resolve.overflow) return;
         this.startAnimTo(resolve.pointer, direction);
     };

     edProto.startAnimTo = function (pointer, direction) {
         this.fliplock = true;
         this.prveHindex = this.hindex;
         this.direction = direction;
         this.judgeQuickTurn();
         if (direction === 'next') {
             this.nextRun(pointer);
         } else {
             this.preRun(pointer);
         }
     };

     //上翻页
     edProto.preRun = function (pointer) {
         var pointers,
             me = this;

         function createPrev() {
             pointers = me.shiftPointer(pointer);
             pointers = me.revisedFilpPointer(pointers);
             me.sliderStop(pointers);
             me.fixHindex(pointers.currIndex);
         }

         this.processorMove({
             'pageIndex': this.hindex,
             'speed': this.calculatespeed(),
             'distance': 0,
             'direction': this.direction,
             'action': 'flipOver'
         });

         //动画执行
         setTimeout(createPrev);
     };

     //下翻页
     edProto.nextRun = function (pointer) {
         var pointers,
             me = this;

         function createNext() {
             pointers = me.shiftPointer(pointer);
             pointers = me.revisedFilpPointer(pointers);
             me.sliderStop(pointers);
             me.fixHindex(pointers.currIndex);
         }

         this.processorMove({
             'pageIndex': this.hindex,
             'speed': this.calculatespeed(),
             'distance': 0,
             'direction': this.direction,
             'action': 'flipOver'
         });

         //动画执行
         setTimeout(createNext);
     };

     /**
      * 判断是否快速翻页
      * @return {[type]} [description]
      */
     edProto.judgeQuickTurn = function () {

         var startDate = +new Date();

         if (this.preClickTime) {
             if (startDate - this.preClickTime < this.clickSpeed) {
                 this.setRate();
             }
         }

         this.preClickTime = +new Date();
     };

     /**
      * 计算滑动速度
      * @return {[type]} [description]
      */
     edProto.calculatespeed = function () {
         return (this.screenWidth - Math.abs(this.deltaX)) * this.speedRate || this.speed;
     };

     /**
      * 处理松手后滑动
      * pageIndex 页面
      * distance  移动距离
      * speed     时间
      * viewTag   可使区标记
      * follow    是否为跟随滑动
      * @return {[type]} [description]
      */
     edProto.processorMove = function (data) {
         var pagePointer = this.pagePointer;
         data.leftIndex = pagePointer.leftIndex;
         data.rightIndex = pagePointer.rightIndex;
         this.$emit('onSwipeMove', data);
     };

     /**
      * 滑动事件派发处理
      * 停止动画,视频 音频
      * @return {[type]} [description]
      */
     edProto.sliderStop = function (pointers) {
         this.$emit('onSwipeUpSlider', pointers);
     };

     /*********************************************************************
      *                 页面交互
      *                                                         *
      **********************************************************************/

     /**
      * 兼容事件对象
      * @return {[type]}   [description]
      */
     function compatibilityEvent(e) {
         var point;
         if (e.touches && e.touches[0]) {
             point = e.touches[0];
         } else {
             point = e;
         }
         return point;
     }

     edProto.onTouchStart = function (e) {

         var interrupt,
             point = compatibilityEvent(e);

         if (!point) {
             return interrupt = this.preventSwipe = true;
         }

         /**
          * 获取观察对象
          * 钩子函数
          * point 事件对象
          * @return {[type]} [description]
          */
         this.$emit('filter', function () {
             interrupt = true;
         }, point, e);

         //打断动作
         if (interrupt) return;

         this.deltaX = 0;
         this.deltaY = 0;
         this.preventSwipe = false, //是否滑动事件受限
         this.isoverstep = false; //是否边界溢出
         this.isScrollX = false; //是否为X轴滑动
         this.isScrollY = false; //是否为Y轴滑动
         this.isTouching = true; //点击了屏幕

         this.start = {
             pageX: point.pageX,
             pageY: point.pageY,
             time: +new Date()
         };
     };

     edProto.onTouchMove = function (e) {

         //如果没有点击
         //或是Y轴滑动
         //或者是阻止滑动
         if (!this.isTouching || this.isScrollY || this.preventSwipe) return;

         var point = compatibilityEvent(e),
             deltaX = point.pageX - this.start.pageX,
             deltaY = point.pageY - this.start.pageY,
             absDeltaX = Math.abs(deltaX),
             absDeltaY = Math.abs(deltaY);

         if (!this.isScrollY) {
             //===============Y轴滑动======================
             //
             if (absDeltaY > absDeltaX) {
                 this.isScrollY = true; //为Y轴滑动
                 return;
             }
         }

         //===============X轴滑动======================

         //越界处理
         if (this.isoverstep = this.overstep(deltaX)) return;

         //防止滚动
         e.preventDefault();

         this.deltaX = deltaX / (!this.hindex && deltaX > 0 // 在首页
          || this.hindex == this.pagetotal - 1 // 尾页
          && deltaX < 0 // 中间
         ? absDeltaX / this.screenWidth + 1 : 1);

         if (!this.isScrollX && this.deltaX) {
             this.isScrollX = true;
         }

         //算一次有效的滑动
         if (absDeltaX <= 25) return;

         var delayX = 0;

         if (this.deltaX < 0) {
             delayX = 20;
         } else {
             delayX = -20;
         }

         !this.fliplock && this.processorMove({
             'pageIndex': this.hindex,
             'distance': this.deltaX + delayX,
             'speed': 0,
             'direction': this.deltaX > 0 ? 'prev' : 'next',
             'action': 'flipMove'
         });
     };

     edProto.onTouchEnd = function (e) {

         this.isTouching = false;

         if (this.isoverstep || this.preventSwipe) return;

         //点击
         if (!this.isScrollX && !this.isScrollY) {
             var isReturn = false;
             this.$emit('onSwipeUp', this.hindex, function () {
                 isReturn = true;
             });
             if (isReturn) return;
         }

         //如果是左右滑动
         if (this.isScrollX) {

             var duration = +new Date() - this.start.time,
                 deltaX = Math.abs(this.deltaX),

             //如果是首尾
             isPastBounds = !this.hindex && this.deltaX > 0 || this.hindex == this.pagetotal - 1 && this.deltaX < 0,
                 isValidSlide = Number(duration) < 200 && Math.abs(deltaX) > 30 || Math.abs(deltaX) > this.screenWidth / 6;

             //跟随移动
             if (!this.fliplock && isValidSlide && !isPastBounds) {
                 if (this.deltaX < 0) {
                     //true:right, false:left
                     this.slideTo('next');
                 } else {
                     this.slideTo('prev');
                 }
             } else {
                 //反弹
                 this.processorMove({
                     'pageIndex': this.hindex,
                     'direction': this.deltaX > 0 ? 'prev' : 'next',
                     'distance': 0,
                     'speed': 300,
                     'action': 'flipRebound'
                 });
             }
         }
     };

     /**
      * 设置动画完成
      * @param {[type]} element [description]
      */
     edProto.setAnimComplete = function (element) {
         this.distributed(element[0]);
     };

     /**
      * 动画结束后处理
      * @param  {[type]} e [description]
      * @return {[type]}   [description]
      */
     edProto.onAnimComplete = function (e) {
         var target = e.target,
             pageType = target.getAttribute('data-pageType'),
             view = target.getAttribute('data-view'); //操作的可视窗口

         //反弹效果,未翻页
         if (!view) {
             if (!pageType) {
                 //只针对母板处理
                 this.$emit('onMasterMove', this.hindex, target);
             }
             return;
         }

         this.distributed(target);
     };

     /**
      * 派发事件
      * @return {[type]} [description]
      */
     edProto.distributed = function (element) {

         //针对拖拽翻页阻止
         this.preventSwipe = true;
         this.isTouching = false;

         //快速翻页
         var isQuickTurn = this.isQuickTurn;

         //恢复速率
         this.resetRate();

         element.removeAttribute('data-view', 'false');

         var slef = this;
         setTimeout(function () {
             slef.$emit('onAnimComplete', slef.direction, slef.pagePointer, slef.unlock.bind(slef), isQuickTurn);
         }, 100);
     };

     edProto.lock = function () {
         this.fliplock = true;
     };

     //解锁翻页
     edProto.unlock = function () {
         this.fliplock = false;
     };

     //快速翻页时间计算
     edProto.setRate = function () {
         this.speedRate = 50 / this.screenWidth;
         this.isQuickTurn = true;
     };

     //复位速率
     edProto.resetRate = function () {
         this.speedRate = this.originalRate;
         this.isQuickTurn = false;
     };

     edProto.openSwipe = function () {
         this._bindEvt();
     };

     edProto.closeSwipe = function () {
         this.evtDestroy();
     };

     /*********************************************************************
      *
      *                 页面跳转事件
      *                                                         *
      **********************************************************************/

     //计算当前已经创建的页面索引
     function calculationPosition(currIndex, targetIndex, pagetotal) {
         var i = 0,
             existpage,
             createpage,
             pageIndex,
             ruleOut = [],
             create = [],
             destroy,
             viewFlip;

         //存在的页面
         if (currIndex === 0) {
             existpage = [currIndex, currIndex + 1];
         } else if (currIndex === pagetotal - 1) {
             existpage = [currIndex - 1, currIndex];
         } else {
             existpage = [currIndex - 1, currIndex, currIndex + 1];
         }

         //需要创建的新页面
         if (targetIndex === 0) {
             createpage = [targetIndex, targetIndex + 1];
         } else if (targetIndex === pagetotal - 1) {
             createpage = [targetIndex - 1, targetIndex];
         } else {
             createpage = [targetIndex - 1, targetIndex, targetIndex + 1];
         }

         for (; i < createpage.length; i++) {
             pageIndex = createpage[i];
             //跳过存在的页面
             if (-1 === existpage.indexOf(pageIndex)) {
                 //创建目标的页面
                 create.push(pageIndex);
             } else {
                 //排除已存在的页面
                 ruleOut.push(pageIndex);
             }
         }

         _.each(ruleOut, function (ruleOutIndex) {
             existpage.splice(existpage.indexOf(ruleOutIndex), 1);
         });

         destroy = existpage;

         viewFlip = [].concat(create).concat(ruleOut).sort(function (a, b) {
             return a - b;
         });

         return {
             'create': create,
             'ruleOut': ruleOut,
             'destroy': destroy,
             'viewFlip': viewFlip,
             'targetIndex': targetIndex,
             'currIndex': currIndex
         };
     }

     edProto.scrollToPage = function (targetIndex, preMode, complete) {
         //目标页面

         //如果还在翻页中
         if (this.fliplock) return;

         var data;
         var currIndex = this.hindex; //当前页面

         switch (targetIndex) {
             //前一页
             case currIndex - 1:
                 if (this.multiplePages) {
                     return this.prev();
                 }
                 break;
             //首页
             case currIndex:
                 if (currIndex == 0) {
                     this.$emit('onDropApp');
                 }
                 return;
             //后一页
             case currIndex + 1:
                 if (this.multiplePages) {
                     return this.next();
                 }
                 break;
         }

         //算出是相关数据
         data = calculationPosition(currIndex, targetIndex, this.pagetotal);

         //更新页码索引
         this.updataPointer(data);

         data.pagePointer = this.pagePointer;

         this.$emit('onJumpPage', data);
     };

     /**
      * 事件处理
      * @param  {[type]} e [description]
      * @return {[type]}   [description]
      */
     edProto.handleEvent = function (e) {
         Xut.plat.handleEvent({
             start: function start(e) {
                 this.onTouchStart(e);
             },
             move: function move(e) {
                 this.onTouchMove(e);
             },
             end: function end(e) {
                 this.onTouchEnd(e);
             },
             transitionend: function transitionend(e) {
                 this.onAnimComplete(e);
             }
         }, this, e);
     };

     /**
      * 绑定事件
      * @return {[type]} [description]
      */
     edProto._bindEvt = function () {
         var self = this;
         //pageFlip启动，没有滑动处理
         if (this.pageFlip) {
             Xut.plat.execEvent('on', {
                 context: this.element,
                 callback: {
                     start: this,
                     end: this,
                     transitionend: this
                 }
             });
         } else if (this.multiplePages) {
             Xut.plat.execEvent('on', {
                 context: this.element,
                 callback: {
                     start: this,
                     move: this,
                     end: this,
                     transitionend: this
                 }
             });
         } else {
             Xut.plat.execEvent('on', {
                 context: this.element,
                 callback: {
                     start: this,
                     end: this
                 }
             });
         }
     };

     /**
      * 销毁事件
      * @return {[type]} [description]
      */
     edProto.evtDestroy = function () {
         var self = this;
         Xut.plat.execEvent('off', {
             context: this.element,
             callback: {
                 start: this,
                 move: this,
                 end: this,
                 transitionend: this
             }
         });
     };

     /**
      * 销毁所有
      * @return {[type]} [description]
      */
     edProto.destroy = function () {
         this.evtDestroy();
         this.$off();
         this.bubbleNode.page = null;
         this.bubbleNode.master = null;
         this.element = null;
     };

     /**
      * 扩充事件
      */
     observe.call(GlobalEvent.prototype);

     var typeFilter = ['page', 'master'];

     /**
      * 合并参数设置
      * 1 pageMgr
      * 2 masterMgr
      * 3 修正pageType
      * 4 args参数
      * 5 回调每一个上下文
      */
     function createaAccess(mgr) {
         return function (callback, pageType, args, eachContext) {
             //如果第一个参数不是pageType模式
             //参数移位
             if (pageType !== undefined && -1 === typeFilter.indexOf(pageType)) {
                 var temp = args;
                 args = pageType;
                 eachContext = temp;
                 pageType = 'page';
             }

             //pageIndex为pageType参数
             if (-1 !== typeFilter.indexOf(args)) {
                 pageType = args;
                 args = null;
             }

             pageType = pageType || 'page';

             if (mgr[pageType]) {
                 return callback(mgr[pageType], pageType, args, eachContext);
             } else {
                 console.log('传递到access的pageType错误！');
             }
         };
     }

     /**
      * 判断是否存在页码索引
      * 如果不存在默认取当前页面
      */
     function createExistIndex($globalEvent) {
         return function (pageIndex) {
             //如果不存在
             if (pageIndex == undefined) {
                 pageIndex = $globalEvent.hindex; //当前页面
             }
             return pageIndex;
         };
     }

     function overrideApi(vm) {

         var $globalEvent = vm.$globalEvent;
         var options = vm.options;
         var $scheduler = vm.$scheduler;

         //页面与母版的管理器
         var access = createaAccess({
             page: $scheduler.pageMgr,
             master: $scheduler.masterMgr
         });

         var isExistIndex = createExistIndex($globalEvent);

         //***************************************************************
         //
         //  数据接口
         //
         //***************************************************************

         var Presentation = Xut.Presentation;

         /**
          * 获取当前页码
          */
         Presentation.GetPageIndex = function () {
             return $globalEvent.hindex;
         };

         ///////////////
         //获取页面的总数据 //
         //1 chapter数据
         //2 section数据
         ///////////////
         _.each(["Section", "Page"], function (apiName) {
             Presentation['GetApp' + apiName + 'Data'] = function (callback) {
                 var i = 0,
                     temp = [],
                     cps = Xut.data.query('app' + apiName),
                     cpsLength = cps.length;
                 for (i; i < cpsLength; i++) {
                     temp.push(cps.item(i));
                 }
                 return temp;
             };
         });

         //////////////////
         //获取首页的pageId //
         //////////////////
         Presentation.GetFirstPageId = function (seasonId) {
             var sectionRang = Xut.data.query('sectionRelated', seasonId);
             var pageData = Xut.data.query('appPage');
             return pageData.item(sectionRang.start);
         };

         //==========================================
         //	四大数据接口
         //	快速获取一个页面的nodes值
         //	获取当前页面的页码编号 - chapterId
         //	快速获取指定页面的chapter数据
         //	pagebase页面管理对象
         //==========================================
         _.each(["GetPageId", "GetPageNode", "GetPageData", "GetPageObj"], function (apiName) {
             Presentation[apiName] = function (pageType, pageIndex) {
                 return access(function (manager, pageType, pageIndex) {
                     pageIndex = isExistIndex(pageIndex);
                     return manager["abstract" + apiName](pageIndex, pageType);
                 }, pageType, pageIndex);
             };
         });

         /**
          * 得到页面根节点
          * li节点
          */
         Presentation.GetPageElement = function () {
             var obj = Presentation.GetPageObj();
             return obj.element;
         };

         /**
          * 获取页码标记
          * 因为非线性的关系，页面都是按chpater组合的
          * page_0
          * page_10
          * 但是每一个章节页面的索引是从0开始的
          * 区分pageIndex
          */
         Presentation.GetPagePrefix = function (pageType, pageIndex) {
             var pageObj = Presentation.GetPageObj(pageType, pageIndex);
             return pageObj.pid;
         };

         //命名前缀
         var prefix = 'Content_';

         /**
          * 创建一个content的命名规则
          */
         Presentation.MakeContentPrefix = function (pageIndex) {
             return prefix + Presentation.GetPagePrefix(pageIndex) + "_";
         };

         /**
          * 获取命名规则
          */
         Presentation.GetContentName = function (id) {
             if (id) {
                 return prefix + Presentation.GetPagePrefix() + "_" + id;
             } else {
                 return prefix + Presentation.GetPagePrefix();
             }
         };

         //***************************************************************
         //
         //  视图接口
         //
         //***************************************************************

         var View = Xut.View;

         /**
          * 显示工具栏
          * 没有参数显示 工具栏与控制翻页按钮
          * 有参数单独显示指定的
          */
         View.ShowToolbar = function (point) {
             vm.$emit('change:toggleToolbar', 'show', point);
         };

         /**
          * 隐藏工具栏
          * 没有参数隐藏 工具栏与控制翻页按钮
          * 有参数单独隐藏指定
          */
         View.HideToolbar = function (point) {
             vm.$emit('change:toggleToolbar', 'hide', point);
         };

         /**
          * 指定特定的显示与隐藏
          *  Xut.View.Toolbar({
          *       show :'bottom',
          *       hide :'controlBar'
          *   })
          *
          *  //工具栏与翻页按钮全部显示/隐藏
          *  Xut.View.Toolbar('show')
          *  Xut.View.Toolbar('hide')
          *
          * @return {[type]} [description]
          */
         View.Toolbar = function (cfg) {
             vm.$emit('change:toggleToolbar', cfg);
         };

         /**
          * 跳转到上一个页面
          */
         View.GotoPrevSlide = function (seasonId, chapterId) {
             if (seasonId && chapterId) {
                 Xut.View.LoadScenario({
                     'scenarioId': seasonId,
                     'chapterId': chapterId
                 });
                 return;
             }

             //ibooks模式下的跳转
             //全部转化成超链接
             if (Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
                 location.href = Xut.IBooks.pageIndex - 1 + ".xhtml";
                 return;
             }

             options.multiplePages && $globalEvent.prev();
         };

         /**
          * 跳转到下一个页面
          */
         View.GotoNextSlide = function (seasonId, chapterId) {
             if (seasonId && chapterId) {
                 Xut.View.LoadScenario({
                     'scenarioId': seasonId,
                     'chapterId': chapterId
                 });
                 return;
             }

             //ibooks模式下的跳转
             //全部转化成超链接
             if (Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
                 location.href = Xut.IBooks.pageIndex + 1 + ".xhtml";
                 return;
             }

             options.multiplePages && $globalEvent.next();
         };

         /**
          * 跳转页面
          * 场景内部切换
          * 跳转到指定编号的页面
          * Action 类型跳转
          * xxtlink 超连接跳转,svg内嵌跳转标记处理
          * 文本框跳转
          * ........
          */
         View.GotoSlide = function (seasonId, chapterId) {
             var count,
                 sceneObj,
                 currscene,
                 sceneController,

             //修正参数
             fixParameter = function fixParameter(pageIndex) {
                 pageIndex = Number(pageIndex) - 1;
                 if (pageIndex < 0) {
                     pageIndex = 0;
                 }
                 return pageIndex;
             };

             //ibooks模式下的跳转
             //全部转化成超链接
             if (Xut.IBooks.Enabled && Xut.IBooks.runMode() && chapterId) {
                 location.href = chapterId + ".xhtml";
                 return;
             }

             //兼容数据错误
             if (!seasonId && !chapterId) return;

             //如果是一个参数是传递页码数,则为内部跳转
             if (arguments.length === 1) {
                 //复位翻页按钮
                 vm.$emit('change:showNext');
                 return $globalEvent.scrollToPage(fixParameter(seasonId));
             }

             //场景模式内部跳转
             if (options.scenarioId == seasonId) {
                 //chpaterId 转化成实际页码
                 var sectionRang = Xut.data.query('sectionRelated', seasonId);
                 var pageIndex = chapterId - sectionRang.start;
                 vm.$emit('change:showNext');
                 return $globalEvent.scrollToPage(fixParameter(pageIndex));
             }
             //场景与场景的跳转
             return View.LoadScenario({
                 'scenarioId': seasonId,
                 'chapterId': chapterId
             });
         };

         //页面滑动
         View.MovePage = function (distance, speed, direction, action) {
             //如果禁止翻页模式 || 如果是滑动,不是边界
             if (!options.multiplePages || $globalEvent.isMove() || action === 'flipMove' && $globalEvent.isBorder(distance)) {
                 return;
             }
             var pagePointer = $globalEvent.pagePointer,
                 data = {
                 'distance': distance,
                 'speed': speed,
                 'direction': direction,
                 'action': action,
                 'leftIndex': pagePointer.leftIndex,
                 'pageIndex': pagePointer.currIndex,
                 'rightIndex': pagePointer.rightIndex
             };
             $scheduler.move(data);
             pagePointer = null;
         };

         //***************************************************************
         //
         //  辅助对象的控制接口
         //
         //***************************************************************

         /**
          * 运行辅助动画
          * 辅助对象的activityId,或者合集activityId
          * Run
          * stop
          * 1 零件
          * 2 音频动画
          */
         var Assist = Xut.Assist;

         _.each(["Run", "Stop"], function (apiName) {
             Assist[apiName] = function (pageType, activityId, outCallBack) {
                 access(function (manager, pageType, activityId, outCallBack) {
                     //数组
                     if (_.isArray(activityId)) {
                         //完成通知
                         var markComplete = function () {
                             var completeStatistics = activityId.length; //动画完成统计
                             return function () {
                                 if (completeStatistics === 1) {
                                     outCallBack && outCallBack();
                                     markComplete = null;
                                 }
                                 completeStatistics--;
                             };
                         }();
                         _.each(activityId, function (id) {
                             manager.abstractAssistAppoint(id, $globalEvent.hindex, markComplete, apiName);
                         });
                     } else {
                         manager.abstractAssistAppoint(activityId, $globalEvent.hindex, outCallBack, apiName);
                     }
                 }, pageType, activityId, outCallBack);
             };
         });

         //***************************************************************
         //
         //  针对page页面的content类型操作接口
         //
         //***************************************************************

         var Contents = Xut.Contents;

         /**
          * 获取指定的对象
          * 传递参数
          * 单一 id
          * 数据id合集 [1,2,4,5,6]
          * @param {[type]}   contentIds  [description]
          * @param {Function} eachContext 回调遍历每一个上下文
          */
         Contents.Get = function (pageType, contentIds, eachContext) {

             return access(function (manager, pageType, contentIds, eachContext) {

                 var contentObj,
                     contentObjs,
                     pageIndex = Presentation.GetPageIndex();

                 function findContent(currIndex, contentId) {
                     var pageObj;
                     if (pageObj = manager.abstractGetPageObj(currIndex)) {
                         return pageObj.baseGetContentObject(contentId);
                     }
                 }

                 //如果传递是数组合集
                 if (_.isArray(contentIds)) {
                     contentObjs = [];
                     _.each(contentIds, function (id) {
                         contentObj = findContent(pageIndex, id);
                         if (eachContext) {
                             //传递每一个处理的上下文
                             eachContext(id, contentObj);
                         } else {
                             if (contentObj) {
                                 contentObjs.push(contentObj);
                             } else {
                                 Xut.log('error', '找不到对应的content数据' + id);
                             }
                         }
                     });
                     return contentObjs;
                 }

                 //如果传递的是Content_1_3组合情况
                 if (/_/.test(contentIds)) {
                     var expr = contentIds.split('_');
                     if (expr.length > 1) {
                         return findContent(expr[1], expr[2]);
                     }
                 }

                 //单一content id
                 contentObj = findContent(pageIndex, contentIds);

                 if (eachContext) {
                     eachContext(contentObj);
                 } else {
                     return contentObj;
                 }
             }, pageType, contentIds, eachContext);
         };

         /**
          * 得到指定页面零件的数据
          * 获取指定的content数据
          * @param  {[type]} contentId [description]
          * @return {[type]}           [description]
          */
         Contents.GetPageWidgetData = function (pageType, contentId) {

             //如果没有传递pageType取默认
             if (-1 === typeFilter.indexOf(pageType)) {
                 contentId = pageType;
                 pageType = 'page';
             }

             //必须有数据
             if (!contentId || !contentId.length) {
                 return;
             }

             //保证是数组格式
             if (_.isString(contentId)) {
                 contentId = [contentId];
             }

             var contentDas,
                 contents = [];

             Contents.Get(pageType, contentId, function (cid, content) {
                 //是内部对象
                 if (content && (contentDas = content.contentDas)) {
                     //通过内部管理获取对象
                     contents.push({
                         'id': content.id,
                         'idName': content.actName,
                         'element': content.$contentProcess,
                         'theTitle': contentDas.theTitle,
                         'scaleHeight': contentDas.scaleHeight,
                         'scaleLeft': contentDas.scaleLeft,
                         'scaleTop': contentDas.scaleTop,
                         'scaleWidth': contentDas.scaleWidth,
                         'contentData': contentDas,
                         'source': 'innerObjet' //获取方式内部对象
                     });
                 } else {
                         //如果通过内部找不到对象的content数据,则直接查找数据库
                         //可能是一个事件的钩子对象
                         if (contentDas = seekQuery(cid)) {
                             var actName = Presentation.GetContentName(cid);
                             var element;
                             //如果对象是事件钩子或者是浮动对象
                             //没有具体的数据
                             if (content && content.$contentProcess) {
                                 element = content.$contentProcess;
                             } else {
                                 element = $('#' + actName);
                             }
                             contents.push({
                                 'id': cid,
                                 'idName': actName,
                                 'element': element,
                                 'theTitle': contentDas.theTitle,
                                 'scaleHeight': contentDas.scaleHeight,
                                 'scaleLeft': contentDas.scaleLeft,
                                 'scaleTop': contentDas.scaleTop,
                                 'scaleWidth': contentDas.scaleWidth,
                                 'contentData': contentDas,
                                 'source': 'dataBase'
                             });
                         } else {
                             Xut.log('error', '找不到对应的GetPageWidgetData数据' + cid);
                         }
                     }
             });
             return contents;
         };

         //数据库查找
         function seekQuery(id) {
             var contentData = Xut.data.query('Content', id);
             if (contentData) {
                 return reviseSize(_.extend({}, contentData));
             }
         }

         //******************************************
         //
         //		互斥接口
         //		直接显示\隐藏\停止动画
         //
         //*******************************************

         //检测类型为字符串
         function typeCheck(objNameList) {
             return !objNameList || typeof objNameList !== 'string' ? true : false;
         }

         /**
          * 针对文本对象的直接操作
          * 显示
          * 隐藏
          * 停止动画
          */
         _.each(["Show", "Hide", "StopAnim"], function (operate) {
             Contents[operate] = function (pageType, nameList) {
                 access(function (manager, pageType, nameList) {
                     if (typeCheck(nameList)) return;
                     var pageBaseObj;
                     if (!(pageBaseObj = manager.abstractAssistPocess($globalEvent.hindex))) {
                         console.log('注入互斥接口数据错误！');
                         return;
                     }
                     _.each(nameList.split(','), function (contentId) {
                         pageBaseObj.baseContentMutex(contentId, operate);
                     });
                 }, pageType, nameList);
             };
         });

         //******************************************
         //
         //		Application
         //		应用接口
         //
         //*******************************************

         var Application = Xut.Application;

         /**
          * 获取一个存在的实例对象
          * 区分不同层级page/master
          * 不同类型	   content/widget
          */
         Application.GetSpecifiedObject = function (pageType, data) {
             return access(function (manager, pageType) {
                 var pageObj;
                 if (pageObj = manager.abstractGetPageObj(data.pageIndex)) {
                     if (data.type === 'Content') {
                         return pageObj.baseSpecifiedContent(data);
                     } else {
                         return pageObj.baseSpecifiedComponent(data);
                     }
                 }
             }, pageType);
         };

         /**
          * 应用滑动接口
          * @return {[type]}
          */
         _.each(["closeSwipe", "openSwipe"], function (operate) {
             Application[operate] = function () {
                 $globalEvent[operate]();
             };
         });
     }

     /**
      * 抽象管理接口
      * @return {[type]} [description]
      */

     function Abstract() {}

     Abstract.prototype = {
         /**
          * 创建页面合集
          * @return {[type]} [description]
          */
         abstractCreateCollection: function abstractCreateCollection() {
             this.Collections = {};
         },

         /**
          * 增加合集管理
          */
         abstractAddCollection: function abstractAddCollection(pageIndex, pageObj) {
             this.Collections[pageIndex] = pageObj;
         },

         /**
          * 得到页面合集
          * @return {[type]} [description]
          */
         abstractGetCollection: function abstractGetCollection() {
             return this.Collections;
         },

         /**
          * 删除合集管理
          * @return {[type]} [description]
          */
         abstractRemoveCollection: function abstractRemoveCollection(pageIndex) {
             delete this.Collections[pageIndex];
         },

         /**
          * 销毁合集
          * @return {[type]} [description]
          */
         abstractDestroyCollection: function abstractDestroyCollection() {
             var k,
                 Collections = this.Collections;
             for (k in Collections) {
                 Collections[k].baseDestroy();
             }
             this.Collections = null;
         },

         /**
          * 找到页面对象
          * 1.页面直接pageIndex索引
          * 2.母版通过母版Id索引
          * @return {[type]} [description]
          */
         abstractGetPageObj: function abstractGetPageObj(pageIndex, pageType) {
             pageType = pageType || this.pageType;
             //模板传递的可能不是页码
             if (pageType === 'master') {
                 if (!/-/.test(pageIndex)) {
                     //如果不是母版ID，只是页码
                     pageIndex = this.conversionMasterId(pageIndex); //转化成母版id
                 }
             }
             return this.Collections[pageIndex];
         },

         /**
          * 合并处理
          * @return {[type]} [description]
          */
         abstractAssistPocess: function abstractAssistPocess(pageIndex, callback) {
             var pageObj;
             if (pageObj = this.abstractGetPageObj(pageIndex, this.pageType)) {
                 if (callback) {
                     callback(pageObj);
                 } else {
                     return pageObj;
                 }
             }
         },

         /**
          * 获取页面容器ID
          * chpaterID
          * masterID
          * @return {[type]} [description]
          */
         abstractGetPageId: function abstractGetPageId(pageIndex, pageType) {
             var key = pageType === 'page' ? '_id' : 'pptMaster';
             return this.abstractGetPageData(pageIndex, key, pageType);
         },

         /**
          * 获取页面数据
          */
         abstractGetPageData: function abstractGetPageData(pageIndex, key, pageType) {
             var pageObj;
             //如果传递key是 pageType
             if (!pageType && key == 'page' || key == 'master') {
                 pageType = key;
                 key = null;
             }
             if (pageObj = this.abstractGetPageObj(pageIndex, pageType)) {
                 return key ? pageObj.chapterDas[key] : pageObj.chapterDas;
             }
         },

         /**
          * 得到页面的nodes数据
          * @param  {[type]} pageIndex [description]
          * @return {[type]}           [description]
          */
         abstractGetPageNode: function abstractGetPageNode(pageIndex, pageType) {
             return this.abstractGetPageData(pageIndex, 'nodes', pageType);
         },

         //***************************************************************
         //
         //  执行辅助对象事件
         //
         //***************************************************************
         abstractAssistAppoint: function abstractAssistAppoint(activityId, currIndex, outCallBack, actionName) {
             var pageObj;
             if (pageObj = this.abstractGetPageObj(currIndex)) {
                 return pageObj.baseAssistRun(activityId, outCallBack, actionName);
             }
         }

     };

     /**
      * [ description]
      * @return {[type]} [description]
      */

     function Collection() {
         this.reset();
     }

     Collection.prototype = {

         register: function register(contentObj) {
             if (!this._list) {
                 this._list = [contentObj];
             } else {
                 this._list.push(contentObj);
             }
         },

         get: function get() {
             return this._list;
         },

         //得到一个指定的实例
         specified: function specified(data) {
             var instance;
             var listLength = this._list.length;
             while (listLength) {
                 listLength--;
                 if (instance = this._list[listLength]) {
                     if (instance.type === data.type && instance.id === data.id) {
                         return instance;
                     }
                 }
             }
         },

         remove: function remove() {
             this._list = [];
         },

         reset: function reset() {
             this._list = [];
         }

     };

     /**
      * 页面切换效果
      * 平移
      * @return {[type]} [description]
      */
     var prefix$1 = Xut.plat.prefixStyle;
     var xxtTrans = function xxtTrans(offset) {
         offset = Xut.config.virtualMode ? offset / 2 : offset;
         return "translate3d(" + offset + "px, 0, 0)";
     };
     function dydTransform(distance) {
         distance = Xut.config.virtualMode ? distance / 2 : distance;
         return prefix$1('transform') + ':' + 'translate3d(' + distance + 'px,0px,0px)';
     }

     //保持缩放比,计算缩放比情况下的转化
     var calculateContainer = void 0;
     var offsetLeft = void 0;
     var offsetRight = void 0;
     var offsetCut = void 0;
     var prevEffect = void 0;
     var currEffect = void 0;
     var nextEffect = void 0;

     function setConfig() {
         calculateContainer = Xut.config.proportion.calculateContainer(), offsetLeft = -1 * calculateContainer.width, offsetRight = calculateContainer.width, offsetCut = 0, prevEffect = xxtTrans(offsetLeft), currEffect = xxtTrans(offsetCut), nextEffect = xxtTrans(offsetRight);
     }

     //切换坐标
     function toTranslate3d(distance, speed, element) {
         distance = Xut.config.virtualMode ? distance / 2 : distance;
         if (element = element || this.element || this.$contentProcess) {
             element.css(prefix$1('transform'), 'translate3d(' + distance + 'px,0px,0px)');
             if (Xut.config.pageFlip) {
                 //修正pageFlip切换页面的处理
                 //没有翻页效果
                 if (distance === 0) {
                     var cur = Xut.sceneController.containerObj('current');
                     cur.vm.$globalEvent.setAnimComplete(element);
                 }
             } else {
                 element.css(prefix$1('transition-duration'), speed + "ms");
             }
         }
     }

     /**
      * 创建起始坐标
      * @return {[type]}
      */
     function createTransform(currPageIndex, createPageIndex) {
         setConfig();
         var translate3d, direction, offset;
         if (createPageIndex < currPageIndex) {
             translate3d = prevEffect;
             offset = offsetLeft;
             direction = 'before';
         } else if (createPageIndex > currPageIndex) {
             translate3d = nextEffect;
             offset = offsetRight;
             direction = 'after';
         } else if (currPageIndex == createPageIndex) {
             translate3d = currEffect;
             offset = offsetCut;
             direction = 'original';
         }
         return [translate3d, direction, offset, dydTransform];
     }

     function reset() {
         var element;
         if (element = this.element || this.$contentProcess) {
             element.css(prefix$1('transition-duration'), '');
             element.css(prefix$1('transform'), 'translate3d(0px,0px,0px)');
         }
     }

     /**
      * 移动
      * @return {[type]} [description]
      */
     function flipMove(distance, speed, element) {
         toTranslate3d.apply(this, arguments);
     }

     /**
      * 移动反弹
      * @return {[type]} [description]
      */
     function flipRebound(distance, speed) {
         toTranslate3d.apply(this, arguments);
     }

     /**
      * 移动结束
      * @return {[type]} [description]
      */
     function flipOver(distance, speed) {
         /**
          * 过滤多个动画回调，保证指向始终是当前页面
          */
         if (this.pageType === 'page') {
             if (distance === 0) {
                 //目标页面传递属性
                 this.element.attr('data-view', true);
             }
         }
         toTranslate3d.apply(this, arguments);
     }

     var translation = {
         reset: reset,
         flipMove: flipMove,
         flipRebound: flipRebound,
         flipOver: flipOver
     };

     /**
      * ppt事件接口
      *
      * 允许用户自定义其行为
      *     1 支持14种操作行为
      *     2 默认对象都具有滑动翻页的特性
      *     3 翻页的特性在遇到特性的情况可以被覆盖
      *     比如
      *         行为1：用户定义该名字可以支持  click 点击行为， 那么该元素左右滑动能过翻页
      *         行为2：用户如果定义swipeLeft 行为，该元素左右滑动将不会翻页，因为默认翻页已经被覆盖
      *
      * 此接口函数有作用域隔离
      */

     /**
      * ie10下面mouse事件怪异
      * @return {Boolean} [description]
      */
     var isIE10 = document.documentMode === 10;

     /**
      * 事件类型
      * @type {Array}
      */
     var eventName = ['null', 'auto', 'tap', 'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown', 'doubletap', 'press', 'pinchout', 'pinchin', 'rotate', 'assist'];

     /*********************************************************************
      *                重写默认事件
      *
      *                Content对象默认具有左右翻页的特性
      *                根据过滤来选择是否覆盖重写这个特性
      *                比如 用户如果遇到 swipeLeft，swipeRight 这种本身与翻页行为冲突的
      *                将要覆盖这个行为
      *                                                         *
      **********************************************************************/

     //过滤事件
     //如果用户指定了如下操作行为,将覆盖默认的翻页行为
     var filterEvent = ['drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'];

     /**
      * 是否过滤
      * @param  {[type]} evtName [description]
      * @return {[type]}         [description]
      */
     function isfilter(eventName) {
         return filterEvent.indexOf(eventName) === -1 ? true : false;
     }

     /**
      * 特性摘除
      * 1 ：无事件，默认可以翻页，还可以切换工具栏
      * 2 ：静态事件，默认可以翻页
      * 3 : 冲突事件，默认删除
      * 去除默认元素具有的翻页特性
      * @param  {[type]} evtName [事件名]
      * @return {[type]}         [description]
      */
     function checkDefaultBehavior(supportSwipe, element) {
         if (supportSwipe) {
             //静态事件，默认可以翻页，还可以切换工具栏
             element.attr('data-behavior', 'swipe');
         } else {
             //如果事件存在
             element.attr('data-behavior', 'disable');
             this.defaultEvent = false;
         }
     }

     /**
      * 针对软件培训的操作行为下光标状态需求
      * @param {[type]} element [description]
      */
     function addCursor(eventName, $element) {
         if ($element) {
             if (!$element.prop('setCursor')) {
                 //只设置一次
                 if (eventName === ('drag' || 'dragTag')) {
                     $element.css('cursor', 'Move');
                 } else {
                     $element.css('cursor', 'Pointer');
                 }
                 $element.prop('setCursor', 'true');
             }
         }
     }

     /**
      * 针对canvas模式
      * 特殊的hack
      */
     function setCanvasStart(supportSwipe) {
         Xut.Contents.Canvas.Reset();
         //当前点击的元素是滑动元素
         //处理元素的全局事件
         Xut.Contents.Canvas.SupportSwipe = supportSwipe;
         Xut.Contents.Canvas.isTap = true;
     }

     function setCanvasMove() {
         Xut.Contents.Canvas.isSwipe = true;
     }

     /**
      * 兼容事件对象
      * @return {[type]}   [description]
      */
     function compatibilityEvent$1(e) {
         var point;
         if (e.touches && e.touches[0]) {
             point = e.touches[0];
         } else {
             point = e;
         }
         return point;
     }

     /**
      * 如果是简单的点击事件
      */
     function tapEvent(eventContext, domMode, eventHandle, supportSwipe) {

         eventContext.isTap = false;

         //这里单独绑定事件有个问题,单击move被触发
         //如果停止e.stopPropagation，那么默认行为就不会被触发
         //你绑定单击的情况下可以翻页
         //这里通过坐标的位置来判断
         var start = function start(e) {
             var point = compatibilityEvent$1(e);
             //记录开始坐标
             eventContext.pageX = point.pageX;
             //是否是tap事件
             eventContext.isTap = true;
             setCanvasStart(supportSwipe);
         },
             move = function move(e) {
             if (!eventContext.isTap) {
                 return;
             }
             var point = compatibilityEvent$1(e),
                 deltaX = point.pageX - eventContext.pageX;
             //如果有move事件，则取消tap事件
             if (Math.abs(deltaX)) {
                 eventContext.isTap = false;
                 setCanvasMove(supportSwipe);
             }
         },
             end = function end(e) {
             //触发tap事件
             eventContext.isTap && eventHandle();
         };

         //绑定canvas事件
         function onCanvas(eventContext) {
             eventContext.mousedown = eventContext.touchstart = start;
             eventContext.mousemove = eventContext.touchmove = move;
             eventContext.mouseup = eventContext.touchend = end;
         }

         function offCanvas(eventContext) {
             eventContext.mousedown = eventContext.touchstart = null;
             eventContext.mousemove = eventContext.touchmove = null;
             eventContext.mouseup = eventContext.touchend = null;
         }

         if (domMode) {
             eventContext = eventContext[0];
             //IE10是不支持touch事件，直接绑定click事件
             if (isIE10) {
                 eventContext.isTap = true;
                 eventContext.addEventListener('click', end, false);
             } else {
                 Xut.plat.execEvent('on', {
                     context: eventContext,
                     callback: {
                         start: start,
                         move: move,
                         end: end
                     }
                 });
             }
         } else {
             //canvas开启模式
             eventContext.interactive = true;
             onCanvas(eventContext);
         }

         //销毁接口
         return {
             off: function off() {
                 if (eventContext) {
                     if (domMode) {
                         if (isIE10) {
                             eventContext.removeEventListener('click', end, false);
                         } else {
                             Xut.plat.execEvent('off', {
                                 context: eventContext,
                                 callback: {
                                     start: start,
                                     move: move,
                                     end: end
                                 }
                             });
                         }
                         eventContext = null;
                     } else {
                         //canvas模式处理
                         if (eventContext.destroy) {
                             eventContext.destroy();
                         } else {
                             offCanvas(eventContext);
                         }
                         eventContext = null;
                     }
                 }
             }
         };
     }

     /**
      * 优化hammer创建,生成必要配置文件
      * @return {[type]} [description]
      */
     function createRecognizers(eventName) {
         var recognizers = [];
         switch (eventName) {
             //如果是swipe处理
             case 'swipeleft':
             case 'swiperight':
             case 'swipeup':
             case 'swipedown':
                 var direction = Hammer.DIRECTION_HORIZONTAL;
                 if (eventName === 'swipeup' || eventName === "swipedown") {
                     direction = Hammer.DIRECTION_VERTICAL;
                 }
                 recognizers.push([Hammer.Swipe, { 'direction': direction, 'velocity': 0.01 }]);
                 break;
             case 'doubletap':
                 //双击
                 recognizers.push([Hammer.Tap]);
                 recognizers.push([Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]);
                 break;
             case 'press':
                 //长按
                 recognizers.push([Hammer.Press]);
                 return;
         }
         return recognizers;
     }

     /**
      * 创建hammer引用
      * @return {[type]}         [description]
      */
     function createHammer(eventContext, eventName, domMode, supportSwipe) {
         var eventReference;
         if (domMode) {
             var context = eventContext[0];
             var recognizer = createRecognizers(eventName);
             if (recognizer && recognizer.length) {
                 eventReference = Hammer(context, {
                     'recognizers': recognizer
                 });
             } else {
                 eventReference = Hammer(context);
             }
         } else {
             //canvas模式事件绑定
             eventContext.interactive = true;
             eventReference = Hammer(context, {
                 'recognizers': recognizer,
                 'pixiContext': eventContext,
                 'returnStart': function returnStart(evt) {
                     setCanvasStart(supportSwipe);
                 },
                 'returnMove': function returnMove() {
                     setCanvasMove(supportSwipe);
                 }
             });
         }
         return eventReference;
     }

     /**
      * 复杂的事件
      * @return {[type]} [description]
      */
     function complexEvent(eventContext, eventName, domMode, eventHandler, supportSwipe) {
         var eventReference = createHammer(eventContext, eventName, domMode, supportSwipe);
         eventReference.on(eventName, function (ev) {
             eventHandler();
         });
         return eventReference;
     }

     //绑定事件
     function bindEvent(eventDrop, data) {
         var dragObj, eventHandler, eventReference;
         var eventContext = data.eventContext;
         var eventName = data.eventName;
         var domMode = data.domMode;
         switch (eventName) {
             case 'drag':
                 //拖动
                 dragObj = new DragDropClass(eventContext, null, data.parameter, eventDrop.startRun, eventDrop.stopRun);
                 break;
             case 'dragTag':
                 //拖拽
                 dragObj = new DragDropClass(eventContext, data.target, 1, eventDrop.startRun, eventDrop.stopRun);
                 break;
             default:
                 //事件句柄
                 eventHandler = function eventHandler() {
                     data.eventRun.call(eventContext);
                 };
                 eventReference = eventName === 'tap' ? tapEvent(eventContext, domMode, eventHandler, data.supportSwipe) : complexEvent(eventContext, eventName, domMode, eventHandler, data.supportSwipe);
                 break;
         }
         return [dragObj, eventReference, eventHandler];
     }

     //绑定事件
     // parameter 参数
     // 1：对于自由拖动drag，para参数为0，表示松手后，停留在松手的地方
     //                      para参数为1，表示松手后，返回原来的位置
     //
     // 2: 对于拖拽dragTag， para表示目标对象的target
     function applyEvent(data) {

         //针对软件培训的操作行为下光标状态需求
         Xut.plat.isBrowser && data.domMode && addCursor(data.eventName, data.eventContext);

         //绑定事件
         var eventDrop = data.eventDrop,
             eventObj = bindEvent(eventDrop, data);

         //拖动,拖拽对象处理
         if (eventObj[0] && eventDrop.init) {
             eventDrop.init(eventObj[0]);
         } else {
             //传递引用
             data.eventHandler(eventObj[1], eventObj[2]);
         }
     }

     //================事件接口====================

     /**
      * 注册自定义事件
      * this还是引用的当前实例的上下文
      *
      *   'element'   : 事件对象
      *   'target'    : 目标对象
      *   'parameter' : 拖动参数
      *   'evtName'   : 事件名,
      *
      *   callbackHook 回调函数 ,处理具体的事情
      */
     function bindEvents(data) {
         //是否支持翻页
         var supportSwipe = data.supportSwipe = isfilter(data.eventName);
         //检测是否移除元素的默认行为,因为元素都具有翻页的特性
         if (data.domMode) {
             checkDefaultBehavior(supportSwipe, data.eventContext);
         }
         //执行事件绑定
         applyEvent(data);
     }

     //数据库预定义14个事件接口
     //提供给content文件
     //用于过滤数据库字段指定的行为
     //https://github.com/EightMedia/hammer.js/wiki/Getting-Started
     //2014.3.18 新增assist 辅助对象事件
     function conversionEventType(eventType) {
         return eventName[Number(eventType) - 1] || null;
     }

     //销毁对象事件
     function destroyEvents(eventData, eventName) {
         if (eventData.eventReference) {
             eventData.eventReference.off(eventName || eventData.eventName, eventData.eventHandler);
             eventData.eventReference = null;
             eventData.eventHandler = null;
         }
     }

     //获取对应的activity对象
     var getActivity = function getActivity(activityId, callback) {
         var activity;
         if (activity = this.abActivitys) {
             _.each(activity.get(), function (contentObj, index) {
                 if (activityId == contentObj.activityId) {
                     callback(contentObj);
                     return;
                 }
             }, this);
         }
     };

     //制作一个处理绑定函数
     var makeRunBinding = function makeRunBinding(pagebase) {
         var registers = this.registers;
         var shift;
         return function () {
             var activityId = registers[0];
             getActivity.call(pagebase, activityId, function (activityObj) {
                 activityObj.runEffects(function () {
                     shift = registers.shift();
                     registers.push(shift);
                 });
             });
         };
     };

     /**
      * 多事件处理
      * 每次通过同一个热点,触发不同的对象操作
      * @return {[type]} [description]
      */
     function combineEvents(pagebase, eventRelated) {

         var contentObj, element, eventName;

         //多条activty数据,一个对象上多事件
         _.each(eventRelated, function (edata) {

             _.each(edata, function (scope) {

                 contentObj = pagebase.baseGetContentObject(scope.eventContentId);

                 if (!contentObj) {
                     Xut.log('error', 'pagebase.js第' + pagebase.pageIndex + '页多事件处理出错!!!!');
                     return;
                 }

                 element = contentObj.$contentProcess;
                 eventName = conversionEventType(scope.eventType);

                 //制动运行动作
                 scope.runEffects = makeRunBinding.call(scope, pagebase);

                 //销毁方法
                 scope.destroy = function () {
                     destroyEvents(scope, eventName);
                     scope.registers = null;
                     scope.runEffects = null;
                 };

                 //事件绑定
                 bindEvents({
                     'eventRun': function eventRun() {
                         scope.runEffects();
                     },
                     'eventHandler': function eventHandler(eventReference, _eventHandler) {
                         scope.eventReference = eventReference;
                         scope.eventHandler = _eventHandler;
                     },
                     'eventContext': element,
                     'eventName': eventName,
                     'parameter': scope.dragdropPara,
                     'target': null,
                     'domMode': true
                 });
             });

             //暴露引用
             pagebase.listenerHooks.registerEvents = eventRelated;
         });
     }

     function create(pagebase, eventRelated) {
         combineEvents(pagebase, eventRelated);
     }

     function destroy$2(pagebase) {
         var registerEvents;
         if (registerEvents = pagebase.listenerHooks.registerEvents) {
             _.each(registerEvents, function (edata) {
                 _.each(edata, function (obj) {
                     obj.destroy && obj.destroy();
                 });
             });
         }
         pagebase.listenerHooks.registerEvents = null;
     }

     //查询接口
     function query(tableName, options, callback) {
         switch (tableName) {
             case 'page':
                 //得到页面关联的数据
                 return getPageData(options, callback);
             case 'master':
                 //得到母版关联的数据
                 return getMasterData(options, callback);
             case 'chapter':
                 //得到chapter表数据
                 return parseChapter(options);
             case 'scenarioChapter':
                 return scenarioChapter(options);
         }
     }

     /**
      * 根据指定的chpaterId解析
      * @return {[type]} [description]
      */
     function scenarioChapter(chapterId) {
         var chapterSection = Xut.data.chapterSection;
         var rang = chapterSection['seasonId->' + chapterId];
         return rang;
     }

     /*********************************************************************
      *
      *               1 解析chapter页面数据
      *               2 解析对应的Activity数据
      *               3 解析出自动widget数据结构
      *                                                         *
      **********************************************************************/
     function getPageData(data, callback) {
         var parsePointer = data['pageIndex'],
             pageData = data['pageData'];

         if (pageData) {
             getActivity$1(pageData, callback);
         } else {
             //解析章节数据
             parseChapter(parsePointer, function (pageData) {
                 //生成chapter数据
                 getActivity$1(pageData.length ? pageData[0] : pageData, callback);
             });
         }
     };

     //解析关联的Activity表数据
     function getActivity$1(pageData, callback) {
         parseActivity(pageData, function (activitys, autoData) {
             callback(pageData, activitys, autoData);
         });
     }

     /**
      * 递归分解
      * chpater直接对应页面的ID编码，直接去下标即可
      * waitCreatePointer     需要分解的页面
      */
     function parseChapter(waitCreatePointer) {
         var chapters = [],
             chapter,
             dataChpater = Xut.data.Chapter,
             points = waitCreatePointer.length,
             key;

         while (points--) {
             key = waitCreatePointer[points];
             if (chapter = dataChpater.item(key)) {
                 chapters.unshift(chapter);
             }
         }

         return chapters;
     };

     /*********************************************************************
      *
      *                解析视觉差的数据
      *                                                         *
      **********************************************************************/
     function getMasterData(data, callback) {
         var pptMaster = data['pptMaster'];
         var masterDas = Xut.data.query('Master', pptMaster);
         parseActivity(masterDas, function (activitys, autoData) {
             callback(masterDas, activitys, autoData);
         });
     }

     /*********************************************************************
      *                解析activity表的数据
      *                                                         *
      **********************************************************************/
     /**
      * chpaters = {
      *     pageIndex-12: Object
      *     pageIndex-13: Object
      *     pageIndex-14: Object
      *  }
      **/
     function parseActivity(data, callback) {
         if (!data) callback();
         var activitys = [];
         var chapterId = data['_id'];

         Xut.data.query('Activity', chapterId, 'chapterId', function (item) {
             activitys.push(item);
         });

         //混入文本提示框
         mixShowNote(data, activitys);

         //自动运行的数据
         //解析出每一页自动运行的 Widget,Action,Video数据
         var autoData = filterAutoRun(activitys);

         callback(activitys, autoData);
     };

     /**
      * 混入shownote
      * 组合showNote数据,弹出信息框,也看作一个热点
      * shownote是chater的信息，混入到activity列表中当作每页的对象处理
      * @return {[type]} [description]
      */
     function mixShowNote(onechapter, activitydata) {
         if (onechapter.note) {
             activitydata.push(onechapter);
         }
     };

     //解析出页面自动运行的数据
     function filterAutoRun(activitys) {

         var collectAutoBuffers, key, id, key, sub;

         if (!activitys || !activitys.length) return;

         collectAutoBuffers = []; //自动热点

         activitys.forEach(function (target, b) {
             //如果是自动播放,并且满足自定义条件
             //并且不是content类型
             if (target.autoPlay && target.actType !== 'Content') {
                 //增加note提示信息数据
                 id = target['_id'];
                 key = target.actType ? target.actType + "_" + id : 'showNote_' + id;
                 sub = {
                     'id': id,
                     'type': target.actType,
                     'animation': target.animation,
                     'key': key,
                     'category': target.category,
                     'autoPlay': target.autoPlay
                 };
                 collectAutoBuffers.push(sub);
             }
         });

         if (collectAutoBuffers.length) {
             return collectAutoBuffers;
         }
     }

     /**
      *	创建主容器任务片
      *  state状态
      *   	0 未创建
      *    	1 正常创建
      *     	2 创建完毕
      *      3 创建失败
      */

     var prefixStyle = Xut.plat.prefixStyle;

     /**
      * 创建父容器li结构
      */
     function createContainer(transform, data) {

         var str = '',
             containerBackground = '',
             userStyle = data.userStyle,
             baseData = data.baseData,
             url = baseData.md5;
         config = Xut.config;

         var proportion = config.proportion;
         var calculate = proportion.calculateContainer();
         var sWidth = calculate.width;
         var sHeight = calculate.height;

         //chpater有背景，不是svg格式
         if (!/.svg$/i.test(url)) {
             containerBackground = 'background-image:url(' + config.pathAddress + url + ');';
         }

         function createli(customStyle) {
             customStyle = customStyle ? customStyle : '';
             var str;
             var offsetLeft = 0;
             var pageType = data.pageType;
             if (config.virtualMode) {
                 if (data.virtualOffset === 'right') {
                     offsetLeft = -(config.screenSize.width - proportion.offsetLeft);
                 }
                 str = String.format('<li id="{0}" class="xut-flip" data-map="{1}" data-pageType="{2}" data-container="true" style="overflow:hidden;{3}:{4};{5}{6}">' + '<div style="width:{7}px;left:{8}px;height:100%;position:relative"></div>' + '</li>', data.prefix, data.pid, pageType, prefixStyle('transform'), transform, containerBackground, customStyle, sWidth, offsetLeft);
             } else {
                 str = String.format('<li id="{0}" class="xut-flip" data-map="{1}" data-pageType="{2}" data-container="true" style="overflow:hidden;{3}:{4};{5}{6}"></li>', data.prefix, data.pid, pageType, prefixStyle('transform'), transform, containerBackground, customStyle);
             }
             return str;
         }

         /**
          * 自定义配置了样式
          * 因为单页面跳槽层级的问题处理
          */
         if (userStyle !== undefined) {
             //解析自定义规则
             var customStyle = '';
             _.each(userStyle, function (value, key) {
                 customStyle += key + ':' + value + ';';
             });
             str = createli(customStyle);
         } else {
             str = createli();
         }

         return $(str); //转化成文档碎片
     }

     function TaskContainer(data, successCallback) {

         var $element;

         //iboosk编译
         //在执行的时候节点已经存在
         //不需要在创建
         if (Xut.IBooks.runMode()) {
             $element = $("#" + data.prefix);
             successCallback($element, pseudoElement);
             return;
         }

         var pseudoElement,
             transform = data.initTransformParameter[0],
             direction = data.initTransformParameter[1],

         //创建的flip结构体
         $element = createContainer(transform, data),

         //创建节点的方向
         direction = direction === 'before' ? 'first' : 'last';

         //如果启动了wordMode模式,查找伪li
         if (config.virtualMode) {
             pseudoElement = $element.find('div');
         }

         Xut.nextTick({
             container: data.rootNode,
             content: $element,
             position: direction
         }, function () {
             successCallback($element, pseudoElement);
         });
     }

     /**
      *	创建背景
      */

     var prefix$2 = Xut.plat.prefixStyle;

     /**
      * 构建背景类
      * @param {[type]} rootNode             [根节点]
      * @param {[type]} data                 [数据]
      * @param {[type]} suspendCallback      [中断回调]
      * @param {[type]} successCallback      [description]
      */
     function TaskBackground(rootNode, data, suspendCallback, successCallback) {
         var layer,
             suspendTasks,
             nextTasks,
             self = this,
             content = data["md5"],
             isSVGContent = /.svg$/i.test(content) ? true : false;

         this.callback = {
             'suspendCallback': suspendCallback,
             'successCallback': successCallback
         };

         //iboosk节点预编译
         //在执行的时候节点已经存在
         //不需要在创建
         if (Xut.IBooks.runMode()) {
             //找到背景节点
             var $element = rootNode.find('.multilayer');
             successCallback();
             return;
         }

         //背景是否需要SVG解析
         this.parseMaster(isSVGContent, content, createWarpper);
         //构建背景
         function createWarpper(svgContents) {
             var backgroundStr = createMaster(svgContents, data);
             if (backgroundStr) {
                 svgContents = null;
                 self.compileSuspend($(backgroundStr), rootNode);
             } else {
                 successCallback();
             }
         }
     }

     TaskBackground.prototype = {

         clearReference: function clearReference() {},

         //构建中断函数
         compileSuspend: function compileSuspend($background, rootNode) {

             var nextTasks,
                 suspendTasks,
                 self = this;

             //继续执行
             nextTasks = function nextTasks() {
                 Xut.nextTick({
                     'container': rootNode,
                     'content': $background
                 }, function () {
                     self.clearReference();
                     self.callback.successCallback();
                 });
             };

             //中断方法
             suspendTasks = function suspendTasks() {
                 self.suspendQueues = [];
                 self.suspendQueues.push(function () {
                     nextTasks();
                 });
             };
             self.callback.suspendCallback(nextTasks, suspendTasks);
         },

         //运行被阻断的线程任务
         runSuspendTasks: function runSuspendTasks() {
             if (this.suspendQueues) {
                 var fn;
                 if (fn = this.suspendQueues.pop()) {
                     fn();
                 }
                 this.suspendQueues = null;
             }
         },

         //解析SVG背景
         parseMaster: function parseMaster(isSVGContent, content, callback) {
             if (isSVGContent) {
                 //背景需要SVG解析的
                 readFile(content, function (svgContents) {
                     callback(svgContents);
                 });
             } else {
                 callback('');
             }
         }
     };

     /**
      * 修正尺寸
      * @return {[type]} [description]
      */

     function fixSize(data) {
         //缩放比
         var proportion = Xut.config.proportion;
         data.path = Xut.config.pathAddress;
         data.imageWidth = data.imageWidth * proportion.width;
         data.imageHeight = data.imageHeight * proportion.height;
         data.imageLeft = data.imageLeft * proportion.left;
         data.imageTop = data.imageTop * proportion.top;
     }

     /*********************************************************************
      *                创建分层背景图层
      *                master               - 母版
      *                imageLayer,imageMask - 图像层图
      *                md5                  - 文字层图                                                                                     *
      **********************************************************************/

     function createMaster(svgContent, data) {
         var imageLayer,
             maskLayer,
             restr = '',
             imageLayerData = data["imageLayer"],
             //图片层
         imageMaskData = data["imageMask"],
             //蒙版层
         backImageData = data["backImage"],
             //真实图片层
         backMaskData = data["backMask"],
             //真实蒙版层
         masterData = data["master"],
             //母板
         backText = data['md5'],
             //背景文字
         pptMaster = data['pptMaster']; //母板PPTID

         //=======================未分层结构===========================
         //
         //		 只有SVG数据，没有层次数据 ,不是视觉差
         //
         // ============================================================
         if (backText && !masterData && !pptMaster && !imageLayerData) {
             return svgContent ? '<div class="multilayer" data-multilayer ="true" style="width:100%; height:100%;position:absolute;left:0;top:0;z-index:0;">' + svgContent + '</div>' : '';
         }

         //=========================分层结构============================
         //
         //   1 分母板 文字层 背景 蒙版
         //   2 视觉差分层处理
         //
         //=============================================================

         //修正尺寸
         fixSize(data);

         //============= 组层背景图开始 ====================

         restr = '<div class="multilayer" data-multilayer ="true" style="width:100%; height:100%;position:absolute;left:0;top:0;z-index:0;">';

         //如果有母板数据,如果不是视觉差
         if (masterData && !pptMaster) {
             //母版图
             restr += '<div class="master" style="width:100%; height:100%;background-size:100% 100%;position:absolute;z-index:0;background-image:url({0});"></div>';
         }

         //存在背景图
         if (imageLayerData) {
             //蒙版图（与背景图是组合关系）
             maskLayer = data["imageMask"] ? prefix$2("mask-box-image") + ":url(" + data.path + data["imageMask"] + ");" : "";
             //图片层
             restr += '<div class="imageLayer" style="width:{1}px;height:{2}px;top:{3}px;left:{4}px;position:absolute;z-index:2;background-size:100% 100%;background-image:url({5});{6};"></div>';
         }

         //新增的 真实背景图 默认全屏
         if (backImageData) {
             //计算出对页排版偏移值
             var backImageOffset = function () {
                 var background,
                     pageSide = data['pageSide'];

                 switch (Number(pageSide)) {
                     case 1:
                         background = 'background-position:0';
                         break;
                     case 2:
                         background = 'background-position:' + Xut.config.screenSize.width + 'px';
                         break;
                 }

                 return background;
             }();

             if (backMaskData) {
                 //带蒙版
                 if (prefix$2('mask-box-image') != undefined) {
                     restr += '<div class="backImage" style="width:{7};height:100%;position:absolute;z-index:1;background-size:100% 100%;background-image:url(' + data.path + backImageData + ');' + prefix$2('mask-box-image') + ':url(' + data.path + backMaskData + ');{8}"></div>';
                 } else {
                     restr += '<canvas class="backImage edges" height=' + document.body.clientHeight + ' width=' + document.body.clientWidth + '  style="width:{7};opacity:0;height:100%;background-size:100% 100%;position:absolute;z-index:1;-webkit-mask-box-image:url(' + data.path + backMaskData + ');{8}" src=' + data.path + backImageData + ' mask=' + data.path + backMaskData + '></canvas>';
                 }
             } else {
                 //图片层
                 restr += '<div class="backImage" style="width:{7};height:100%;position:absolute;z-index:1;background-size:100% 100%;background-image:url(' + data.path + backImageData + ');{8}"></div>';
             }
         }

         //存在svg文字
         if (backText) {
             restr += '<div class="words" style="width:100%;height:100%;top:0;left:0;position:absolute;z-index:3;">{9}</div>';
         }

         restr += '</div>';

         //============= 组层背景图结束 ====================

         return String.format(restr, data.path + masterData, data.imageWidth, data.imageHeight, data.imageTop, data.imageLeft, data.path + imageLayerData, maskLayer, backImageOffset ? '200%' : '100%', backImageOffset ? backImageOffset : '', svgContent);
     }

     //零件类型,快速判断
     //新增content卷滚区域,所有JS零件content
     //类型选择,content有扩充的子类型
     //针对零件类型在category字段中的子分类
     var widgetType = {};
     _.each("jsWidget content svgWidget canvasWidget path".split(" "), function (key, name) {
         widgetType[key] = true;
     });

     function typeExtend(Activity) {
         return widgetType[Activity.category] ? "JsWidget" : Activity.actType;
     }

     /**
      * 创建事件容器
      * @param  {[type]} eventId [description]
      * @return {[type]}         [description]
      */
     function createEventContainer(relateds, eventId) {
         if (!relateds.seasonRelated[eventId]) {
             relateds.seasonRelated[eventId] = {};
         }
     }

     /**
      * 配合出item中相关信息
      * 1.场景信息
      * 2.收费信息
      * @param  {[type]} tokens [description]
      * @return {[type]}        [description]
      */
     function adapterItemArrayRelated(relateds, activitys, tokens) {
         //如果分解出节信息
         var seasonId,
             inAppValue,
             chapterId,
             values,
             eventId = activitys.imageId;

         _.each(['seasonId', 'Inapp', 'SearchBar', 'BookMarks'], function (type) {
             values = tokens[type];
             //如果有值
             if (values !== undefined) {
                 //创建容器
                 createEventContainer(relateds, eventId);
                 switch (type) {
                     //跳转新场景信息
                     case 'seasonId':
                         chapterId = tokens['chapterId'] || tokens['chapter'];
                         relateds.seasonRelated[eventId] = {
                             seasonId: values[0],
                             chapterId: chapterId ? chapterId[0] : ''
                         };
                         break;
                     //收费信息,给事件上绑定收费接口
                     //0 收费 1 已收费
                     case 'Inapp':
                         relateds.seasonRelated[eventId]['Inapp'] = values[0];
                         break;
                     default:
                         //搜索栏
                         //书签
                         relateds.seasonRelated[eventId][type] = eventId;
                         break;
                 }
             }
         });
     }

     ////////////
     //解析相关数据 //
     ////////////
     function parserRelated(preCompileContents, data) {
         var activitys,
             createType,
             resultsActivitys,
             //结果结合
         i = preCompileContents.length,
             pageType = data.pageType,
             pid = data.pid,


         /**
          * 相关数据合集
          * @type {Object}
          */
         activityRelated = [],
             //Activit合集相关数据信息
         tempRelated = [],
             //临时数据

         /**
          * 解析出来的相关信息
          * @type {Object}
          */
         relateds = {
             seasonRelated: {}, //节信息
             containerRelated: [], //容器合集相关数据信息
             eventRelated: {}, //多事件容器合集
             partContentRelated: [] //卷滚conten只创建,不处理行为
         };

         /**
          * 创建解析
          * @param  {Function} callback [description]
          * @return {[type]}            [description]
          */
         function createResolve(callback) {
             return resolveContentToActivity(function (tokens) {
                 return callback(tokens);
             }, activitys, pageType, pid);
         }

         /**
          * 类型处理器
          * 除去动画的其余处理类型
          * @type {Object}
          */
         var hookResolve = {
             //单独处理容器类型
             "Container": function Container(relateds) {
                 relateds.containerRelated.push(createResolve(function (tokens) {
                     return {
                         'Container': tokens['Content']
                     };
                 }));
             },

             //多事件
             "Contents": function Contents(relateds) {
                 var item;
                 if (item = createResolve(function (tokens) {
                     return {
                         'Contents': [tokens]
                     };
                 })[0]) {
                     //给content注册多个绑定事件
                     var eventId = activitys.imageId;
                     var eventData = {
                         'eventContentId': eventId,
                         'activityId': activitys._id,
                         'registers': item['activity'],
                         'eventType': activitys.eventType,
                         'dragdropPara': activitys.para1 //拖拽对象
                     };
                     var isEvt = relateds.eventRelated['eventContentId->' + eventId];
                     if (isEvt) {
                         isEvt.push(eventData);
                     } else {
                         relateds.eventRelated['eventContentId->' + eventId] = [eventData];
                     }
                 }
             },

             //所有js零件
             "JsWidget": function JsWidget(relateds) {
                 var scrollContents = parseJSON(activitys.itemArray);
                 if (_.isArray(scrollContents)) {
                     _.each(scrollContents, function (data) {
                         relateds.partContentRelated.push(data.id);
                     });
                 } else {
                     relateds.partContentRelated.push(scrollContents.id);
                 }
             }
         };

         /**
          * 解析出当前页面的所有的Activit表
          * 1个chpater页面 可以对应多个Activit表中的数据
          * 1 Container 容器类型
          * 2 page 类型
          * 3 parallax 类型
          * 4 Scenario 类型
          * 5 content合集 contents处理
          *
          */
         while (activitys = preCompileContents.shift()) {

             createType = typeExtend(activitys);

             if (!hookResolve[createType]
             //钩子事件
              || hookResolve[createType] && hookResolve[createType](relateds)) {

                 /////////////////////
                 //Content类型处理 //
                 /////////////////////

                 //如果是动画表,视觉差表关联的content类型
                 resultsActivitys = createResolve(function (tokens) {
                     //解析itemArray字段中的相关的信息
                     adapterItemArrayRelated(relateds, activitys, tokens);
                     //解析表数据
                     switch (pageType) {
                         case 'page':
                             return parseTypeRelation(['Animation'], tokens);
                         case 'master':
                             //新增第三个参数，
                             //视觉差支持所有content动画
                             return parseTypeRelation(['Animation', 'Parallax'], tokens);
                     }
                 });

                 //如果有手动触发器,置于最后
                 if (activitys.imageId) {
                     tempRelated.push(resultsActivitys);
                 } else {
                     activityRelated.push(resultsActivitys);
                 }
             }
         }

         //合并排序
         if (tempRelated.length) {
             activityRelated = activityRelated.concat(tempRelated);
         }

         /**
          *	过滤出与创建相关的content合集ID
          *	return [
          *		createImageIds  主content列表 (用来绑定eventType事件)
          *	    createContentIds 合并所有content操作后,过滤掉重复的content,得到可以创建的content的ID合集
          *	]
          *
          * 	wContentRelated  混入合并的数据
          * partContentRelated 需要过滤的数据
          */
         // console.log(activityRelated.slice(0))
         var createImageIds,
             createContentIds,
             cacheUUID = 'createRelevant-' + data.chapterId,
             createRelevant = contentCache[cacheUUID];

         //创建缓存
         if (!createRelevant) {
             createRelevant = contentCache(cacheUUID, toRepeatCombineGroup(activityRelated, relateds.partContentRelated, pageType));
         }

         createImageIds = createRelevant[0].slice(0);
         createContentIds = createRelevant[1].slice(0);

         //如果存在过滤器
         if (Xut.CreateFilter.size()) {
             var filterEach = Xut.CreateFilter.each(data.chapterId);
             if (filterEach) {
                 filterEach(createImageIds, function (indexOf) {
                     createImageIds.splice(indexOf, 1);
                 });
                 filterEach(createContentIds, function (indexOf) {
                     createContentIds.splice(indexOf, 1);
                 });
                 filterEach = null;
             }
         }

         return _.extend(data, relateds, {
             'createImageIds': createImageIds, //事件ID数
             'createContentIds': createContentIds, //创建的content总ID数
             'originalCreateContentIds': createContentIds.slice(0), //保留原始的创建副本
             'activityRelated': activityRelated
         });
     };

     /**************************************************************************
      *
      * 		分组Content表中对应的多个Conte
      *   	1：Animation表
      *    	2: Parallax表
      *     	3: seed种子合集 就是解析1：Animation表，Parallax表得到的数据
      *
      ****************************************************************************/
     function resolveContentToActivity(callback, activity, pageType, pid) {
         var animContentIds,
             paraContentIds,
             parallaxRelated,
             parallaxDas,
             animRelated,
             animationDas = '',
             eventId = activity.imageId,

         //需要分解的contentIds合集
         // 1 动画表数据		Animation
         // 2 视觉差数据     Parallax
         // 3 超链接			seasonId
         // 4 收费			Inapp
         tokens = tokenize(activity['itemArray']) || [],

         //解析Animations,Parallaxs数据
         //	seed {
         //		Animation:[data,Ids]
         //		Parallax:[data,Ids]
         //	}
         seed = callback(tokens),


         //判断类型
         type = Object.keys(seed)[0];

         /**
          * 去重事件ID
          * original  原ID合集
          * detection 需要检测去重的ID
          *
          */
         function toRepeatContents(original) {
             if (original && eventId) {
                 var indexOf = original.indexOf(eventId);
                 if (-1 !== indexOf) {
                     original.splice(indexOf, 1);
                 }
             }
         }

         switch (type) {
             //容器
             case 'Container':
                 animContentIds = seed.Container;
                 toRepeatContents(animContentIds);
                 break;
             //多事件处理
             case 'Contents':
                 return seed.Contents;
             default:
                 /**
                  * 如果是对象处理，
                  * 针对动画表，视觉差表,行为的处理
                  */
                 //需要创建的content合集
                 if (_.keys(seed).length) {
                     animRelated = seed.Animation;
                     parallaxRelated = seed.Parallax;
                     //页面模式
                     if (pageType === 'page') {
                         if (animRelated) {
                             animContentIds = animRelated.ids;
                             animationDas = animRelated.das;
                         }
                     } else {
                         //视觉差存在视觉差表处理
                         // console.log(1111,animRelated, parallaxRelated)
                         //母版的动画数据
                         if (animRelated) {
                             animContentIds = animRelated.ids;
                             animationDas = animRelated.das;
                         }
                         //母版的视察数据
                         if (parallaxRelated) {
                             paraContentIds = parallaxRelated.ids;
                             parallaxDas = parallaxRelated.das;
                         }
                     }

                     //如果id都存在
                     //合并
                     if (animContentIds && paraContentIds) {
                         animContentIds = animContentIds.concat(paraContentIds);
                     }

                     //只存在视察
                     if (!animContentIds && paraContentIds) {
                         animContentIds = paraContentIds;
                     }
                     toRepeatContents(animContentIds);
                 }
                 break;
         }

         //创建对象是层次关系
         return {
             'pageType': pageType,
             'activity': activity,
             'imageIds': eventId,
             //data
             'seed': {
                 'animation': animationDas,
                 'parallax': parallaxDas
             },
             //id
             'ids': {
                 'content': animContentIds,
                 'parallax': paraContentIds
             }
         };
     }

     /************************************************************************
      *
      *     合并,过滤需要处理的content
      *     combineImageIds  可以创建的imageId合集，也就是content的合集,用来绑定自定义事件
      *     createContentIds 可以创建的content合集,过滤合并重复
      *
      * **********************************************************************/
     function toRepeatCombineGroup(compilerActivitys, mixFilterRelated, pageType) {
         var ids,
             contentIds,
             needCreateContentIds,
             imageIds,
             activityRelated,
             parallaxId,
             combineItemIds = [],
             combineImageIds = [],
             i = compilerActivitys.length;

         function pushCache(target, original, callback) {
             var id,
                 i = original.length;
             while (i--) {
                 id = Number(original[i]);
                 target.push(id);
                 callback && callback(id);
             }
         }

         while (i--) {
             //开始执行过滤操作
             activityRelated = compilerActivitys[i];
             ids = activityRelated.ids;
             contentIds = ids.content;
             parallaxId = ids.parallax; //浮动类型的对象
             imageIds = activityRelated.imageIds;

             //针对普通content对象
             if (contentIds && contentIds.length) {
                 //如果不为空
                 pushCache(combineItemIds, contentIds);
             }

             //视察对象
             if (parallaxId && parallaxId.length) {
                 //如果不为空
                 pushCache(combineItemIds, parallaxId);
             }

             //事件合集
             if (imageIds) {
                 combineImageIds.push(Number(imageIds));
             }
         }

         //混入外部合并了逻辑
         if (mixFilterRelated && mixFilterRelated.length) {
             _.each(mixFilterRelated, function (data) {
                 if (data) {
                     combineItemIds = combineItemIds.concat(data);
                 }
             });
         }

         //过滤合并多个content数据
         if (combineImageIds.length) {
             needCreateContentIds = arrayUnique(combineItemIds.concat(combineImageIds));
         } else {
             needCreateContentIds = arrayUnique(combineItemIds);
         }

         //排序
         needCreateContentIds = needCreateContentIds.sort(function (a, b) {
             return a - b;
         });

         /**
          * 合并创建信息
          * 需要创建的事件
          * 需要创建的所有对象
          */
         return [combineImageIds, needCreateContentIds];
     }

     /**
      * 解析指定类型数据
      * strengthenAnmin 视觉差增强动画表
      * @return {[type]}
      */
     function parseTypeRelation(tableName, tokenIds) {
         var tokenId;
         var itemData = {};
         _.each(tableName, function (tName) {
             if (tokenId = tokenIds[tName]) {
                 if (itemData[tName]) {
                     console.log('未处理解析同一个表');
                 } else {
                     itemData[tName] = inGroup(tName, tokenId);
                 }
             }
         });
         return itemData;
     }

     /**
      * 分组
      * @return {[type]} [description]
      */
     function inGroup(tableName, contentIds) {
         var k,
             keyName,
             data,
             contentId,
             temp = {},
             das = [],
             ids = [],
             query = Xut.data.query;

         _.each(contentIds, function (id) {
             if (data = query(tableName, id)) {
                 contentId = data.contentId;
                 if (-1 === ids.indexOf(contentId)) {
                     ids.push(contentId);
                 }
                 //合并同个contentId多条动画数据的情况
                 keyName = "contentId-" + contentId;
                 if (temp[keyName]) {
                     temp[keyName].push(data);
                 } else {
                     temp[keyName] = [data];
                 }
             }
         });

         //转成数组格式
         for (k in temp) {
             das.push(temp[k]);
         }

         return {
             das: das,
             ids: ids
         };
     }

     //解析itemArray序列,得到对应的id
     function tokenize(itemArray) {
         var itemJson,
             actType,
             anmins = {};
         if (!itemArray) return;
         itemJson = parseJSON(itemArray);
         //解析多个参数
         if (itemJson.length) {
             _.each(itemJson, function (opts) {
                 actType = opts.actType;
                 if (!anmins[actType]) {
                     anmins[actType] = [];
                 }
                 anmins[actType].push(opts.id);
             });
         } else {
             actType = itemJson.actType;
             anmins[actType] = [];
             //actType: "Animation", id: 14
             //actType: "Inapp", value: 0
             anmins[actType].push(itemJson.id || itemJson.value);
         }
         return anmins;
     }

     /**
      * pixi帧队列控制器
      * @param  {[type]} Utils        [description]
      * @param  {[type]} Config       [description]
      * @param  {[type]} pixiFactory) {               var rAF [description]
      * @return {[type]}              [description]
      */

     var rAF = function rAF(callback) {
         return window.setTimeout(callback, 1000 / 10);
     };

     //收集绘制内容
     var rQueue = {};

     // $("body").on("click",function(){
     //     console.log(rQueue,Xut.Presentation.GetPageObj())
     // })

     /**
      * 运动动画
      * @param  {[type]} activeIndex [description]
      * @return {[type]}             [description]
      */
     function requestAnimation(activeIndex) {
         var key, content;
         var queue = rQueue[activeIndex];
         var timeout = 0;
         var state = true;
         var clern = function clern() {
             clearTimeout(timeout);
             timeout = null;
         };
         var run = function run() {
             //如果停止
             if (!state) {
                 clern();
                 return;
             }
             if (rQueue[activeIndex]) {
                 var fns = queue["fns"];
                 //刷新
                 for (key in fns) {
                     fns[key](); //执行刷新
                 }
                 // console.log('runRequestAnimation....',activeIndex, Object.keys(fns).length)
                 timeout = rAF(function () {
                     run();
                 });
             }
         };
         run();
         //停止刷新
         this.stop = function () {
             if (state) {
                 state = false;
                 clern();
             }
         };
         //刷新停止
         //外部重新激活
         this.activate = function () {
             if (!state) {
                 state = true;
                 run();
             }
         };
         return this;
     }

     /**
      * 检测运行
      * @param  {[type]} pageIndex [description]
      * @return {[type]}           [description]
      */
     function checkRun(pageIndex) {
         // 活动页面索引
         var activeIndex = Xut.Presentation.GetPageIndex();
         //激活
         if (activeIndex === pageIndex) {
             var queue = rQueue[activeIndex];
             //去重
             if (queue.rAF) {
                 queue.rAF.activate();
             } else {
                 queue.rAF = new requestAnimation(activeIndex);
             }
         }
     }

     /**
      * 用于绘制显示的，特殊处理
      * 单独只刷新一次
      * @return {[type]} [description]
      */
     function oneQueue(fn) {
         var start = +new Date();
         var timeout;
         var state = true;
         var run = function run() {
             if (!state) {
                 timeout && clearTimeout(timeout);
             }
             timeout = rAF(run);
         };
         if (+new Date() - start > 100) {
             state = false;
             clearTimeout(timeout);
             timeout = null;
         }
     }

     /**
      * 加入绘制队列
      * @param {[type]} pageIndex [description]
      * @param {[type]} key       [description]
      * @param {[type]} value     [description]
      */
     function addQueue(pageIndex, key, value, type) {
         // console.log('c',pageIndex,key)
         if (!rQueue[pageIndex]) {
             rQueue[pageIndex] = hash();
             rQueue[pageIndex]['rAF'] = 0;
             rQueue[pageIndex]['fns'] = hash();
             rQueue[pageIndex]['types'] = hash();
             rQueue[pageIndex]['length'] = 0;
             rQueue[pageIndex]['pageIndex'] = pageIndex;
         }
         if (!rQueue[pageIndex]['fns'][key]) {
             rQueue[pageIndex]['fns'][key] = value;
             rQueue[pageIndex]['types'][key] = type;
             ++rQueue[pageIndex]['length'];
         } else {
             console.log('rQueue' + key + '已存在');
         }
         //开始运行
         checkRun(pageIndex);
     }

     /**
      * 移除刷新队列
      * @param  {[type]} pageIndex [description]
      * @param  {[type]} key       [description]
      * @return {[type]}           [description]
      */
     function removeQueue(pageIndex, key) {
         if (rQueue[pageIndex] && rQueue[pageIndex]['fns']) {
             delete rQueue[pageIndex]['fns'][key];
             delete rQueue[pageIndex]['types'][key];
             --rQueue[pageIndex]['length'];
             if (!Object.keys(rQueue[pageIndex]['fns']).length) {
                 if (rQueue[pageIndex].rAF) {
                     rQueue[pageIndex].rAF.stop();
                 }
             }
         } else {
             console.log('删除的页面不存在');
         }
     }

     /**
      * 销毁
      * @return {[type]} [description]
      */
     function destroyQueue(pageIndex) {
         if (rQueue[pageIndex]) {
             if (rQueue[pageIndex].rAF) {
                 rQueue[pageIndex].rAF.stop();
             }
             if (!Object.keys(rQueue[pageIndex]['fns']).length) {
                 delete rQueue[pageIndex];
             }
         }
     }

     /**
      * 制作uuid
      * @return {[type]} [description]
      */
     function makeGuid() {
         return Xut.guid('rAF');
     }

     /**
      * 创建pipx对象
      * @param  {[type]} canvasContainer [description]
      * @param  {[type]} wrapObj         [description]
      * @return {[type]}                 [description]
      */
     function Container(data, canvasIndex) {

         var width = Xut.config.screenSize.width;
         var height = Xut.config.screenSize.height;
         var pageIndex = data.pageIndex;

         var renderer = PIXI.autoDetectRenderer(width, height, {
             transparent: true
         });
         //设置层级关系
         renderer.view.style.position = "absolute";
         renderer.view.style.zIndex = canvasIndex;

         //放入容器
         data.element.append(renderer.view);

         //根容器
         var containerStage = new PIXI.Container();

         //扩充场景处理接口
         var expandRelated = {
             stageWidth: width,
             stageHeight: height,
             container: renderer.view, //canvas容器
             containerStage: containerStage, //根容器
             sprites: {}, //保存精灵合集

             /**
              * 将子pixi加入进来
              */
             addChild: function addChild(stage) {
                 containerStage.addChild(stage);
             },

             /**
              * 初始化绘制,3秒的时间
              * 尽量保证节点加载完毕
              * @return {[type]} [description]
              */
             display: function display() {
                 oneQueue(pageIndex, function display() {
                     renderer.render(containerStage);
                 });
             },

             /**
              * 绘制一次
              * @return {[type]} [description]
              */
             oneRender: function oneRender() {
                 renderer.render(containerStage);
             },

             /**
              * 不断绘制
              * task 外部任务
              * type 执行play的类型 高级，普通精灵
              * @return {[type]} [description]
              */
             play: function play(type, task) {
                 var uuid = makeGuid();
                 addQueue(pageIndex, uuid, function play() {
                     task && task();
                     renderer.render(containerStage);
                 }, type);
                 return uuid;
             },

             /**
              * 停止绘制
              * @return {[type]} [description]
              */
             stop: function stop(uuid) {
                 removeQueue(pageIndex, uuid);
             },

             /**
              * 销毁
              * @return {[type]} [description]
              */
             destroy: function destroy() {
                 if (data.canvasRelated) {
                     destroyQueue(pageIndex);
                     data.canvasRelated.container = null;
                     if (data.canvasRelated.containerStage) {
                         data.canvasRelated.containerStage.removeChildren();
                     }
                     data.canvasRelated = null;
                 }
             }
         };

         //扩充pixi控制
         _.extend(data.canvasRelated, expandRelated);
     }

     var prefix$3 = Xut.plat.prefixStyle;

     /**
      * 解析序列中需要的数据
      * @param  {[type]}   contentIds [description]
      * @param  {Function} callback   [description]
      * @return {[type]}              [description]
      */
     function parseContentDas(contentIds, callback) {
         var data,
             temp = [];
         contentIds.forEach(function (contentId, index) {
             data = Xut.data.query('Content', contentId);
             temp.unshift(data);
             callback && callback(data, contentId);
         });
         return temp;
     }

     /**
      * 制作包装对象
      * 用于隔绝content数据的引用关系
      * 导致重复数据被修正的问题
      * @return {[type]}             [description]
      */
     function makeWarpObj(contentId, content, pageType, pid, virtualOffset) {
         //唯一标示符
         var prefix = "_" + pid + "_" + contentId;
         return {
             pageType: pageType,
             contentId: contentId,
             isJs: /.js$/i.test(content.md5), //html类型
             isSvg: /.svg$/i.test(content.md5), //svg类型
             data: content,
             pid: pid,
             virtualOffset: virtualOffset, //布局位置
             containerName: 'Content' + prefix,
             makeId: function makeId(name) {
                 return name + prefix;
             }
         };
     }

     /**
      * 创建图片地址
      * @return {[type]}         [description]
      */
     function analysisPath(wrapObj, conData) {
         var pathImg,
             imgContent = conData.md5,

         //是gif格式
         isGif = /.gif$/i.test(imgContent),

         //原始地址
         originalPathImg = Xut.config.pathAddress + imgContent;

         if (isGif) {
             //处理gif图片缓存+随机数
             pathImg = Xut.createRandomImg(originalPathImg);
         } else {
             pathImg = originalPathImg;
         }
         wrapObj['imgContent'] = imgContent;
         wrapObj['isGif'] = isGif;
         wrapObj['pathImg'] = pathImg;
     }

     /**
      * 组成HTML结构
      * @param  {[type]} argument [description]
      * @return {[type]}          [description]
      */
     function createDom(data, wrapObj) {
         var restr = '';
         //创建包装容器
         restr += createWapper(data, wrapObj);
         //创建内容
         restr += createContent(data, wrapObj);
         restr += "</div></div>";
         return restr;
     }

     /**
      * 创建包含容器
      * @param  {[type]} data    [description]
      * @param  {[type]} wrapObj [description]
      * @return {[type]}         [description]
      */
     function createWapper(data, wrapObj) {
         var wapper,
             actName,
             offset,
             visibility,
             backwidth,
             backheight,
             backleft,
             backtop,
             zIndex = data['zIndex'],
             id = data['_id'],
             containerName = wrapObj.containerName,
             pid = wrapObj.pid,
             makeId = wrapObj.makeId,
             background = data.background ? 'background-image: url(' + Xut.config.pathAddress + data.background + ');' : '';

         //背景尺寸优先
         if (data.scaleBackWidth && data.scaleBackHeight) {
             backwidth = data.scaleBackWidth;
             backheight = data.scaleBackHeight;
             backleft = data.scaleBackLeft;
             backtop = data.scaleBackTop;
             wrapObj.backMode = true; //背景图模式
         } else {
                 backwidth = data.scaleWidth;
                 backheight = data.scaleHeight;
                 backleft = data.scaleLeft;
                 backtop = data.scaleTop;
             }

         //content默认是显示的数据的
         //content.visible = 0
         //如果为1 就隐藏改成hidden
         //05.1.14
         visibility = 'visible';
         if (data.visible) {
             visibility = 'hidden';
         }

         // var isHtml = "";
         //2015.12.29
         //如果是html内容
         if (wrapObj.isJs) {
             //正常content类型
             wapper = '<div id="{0}"' + ' data-behavior="click-swipe"' + ' style="overflow:hidden;width:{1}px;height:{2}px;top:{3}px;left:{4}px;position:absolute;z-index:{5};visibility:{6};background-size:100% 100%;{10}">' + ' <div id="{7}" style="width:{8}px;position:absolute;">';

             return String.format(wapper, containerName, backwidth, backheight, backtop, backleft, zIndex, visibility, makeId('contentWrapper'), backwidth, backheight, background);
         }

         //正常content类型
         wapper = '<div id="{0}"' + ' data-behavior="click-swipe"' + ' style="overflow:hidden;width:{1}px;height:{2}px;top:{3}px;left:{4}px;position:absolute;z-index:{5};visibility:{6};">' + ' <div id="{7}" style="width:{8}px;height:{9}px;{10}position:absolute;background-size:100% 100%;">';

         return String.format(wapper, containerName, backwidth, backheight, backtop, backleft, zIndex, visibility, makeId('contentWrapper'), backwidth, backheight, background);
     }

     /**
      * content
      * 	svg数据
      * 	html数据
      * 解析外部文件
      * @param  {[type]} wrapObj     [description]
      * @param  {[type]} svgCallback [description]
      * @return {[type]}             [description]
      */
     function externalFile(wrapObj, svgCallback) {
         //svg零件不创建解析具体内容
         if (wrapObj.isSvg) {
             readFile(wrapObj.data.md5, function (svgdata) {
                 wrapObj['svgstr'] = svgdata;
                 svgCallback(wrapObj);
             });
         } else if (wrapObj.isJs) {
             //如果是.js的svg文件
             readFile(wrapObj.data.md5, function (htmldata) {
                 wrapObj['htmlstr'] = htmldata;
                 svgCallback(wrapObj);
             }, "js");
         } else {
             svgCallback(wrapObj);
         }
     }

     /**
      * 创建内容
      * @param  {[type]} data    [description]
      * @param  {[type]} wrapObj [description]
      * @return {[type]}         [description]
      */
     function createContent(data, wrapObj) {
         var restr = "";
         //如果内容是图片
         //如果是svg或者html
         if (wrapObj.imgContent) {
             //如果是SVG
             if (wrapObj.isSvg) {
                 restr += svgContent(data, wrapObj);
             } else if (wrapObj.isJs) {
                 //如果是.js结构的html文件
                 restr += jsContent(data, wrapObj);
             } else {
                 //如果是蒙板，或者是gif类型的动画，给高度
                 restr += maskContent(data, wrapObj);
             }
         } else {
             //纯文本文字
             restr += textContent(data, wrapObj);
         }
         return restr;
     }

     /**
      * 如果是.js结尾的
      * 新增的html文件
      * @param  {[type]} data    [description]
      * @param  {[type]} wrapObj [description]
      * @return {[type]}         [description]
      */
     function jsContent(data, wrapObj) {
         return wrapObj["htmlstr"];
     }

     /**
      * 如果内容是svg
      * @param  {[type]} data    [description]
      * @param  {[type]} wrapObj [description]
      * @return {[type]}         [description]
      */
     function svgContent(data, wrapObj) {
         var restr = "",
             svgstr = wrapObj['svgstr'],
             scaleWidth = data['scaleWidth'];

         //从SVG文件中，读取Viewport的值
         if (svgstr != undefined) {
             var startPos = svgstr.search('viewBox="');
             var searchTmp = svgstr.substring(startPos, startPos + 64).replace('viewBox="', '').replace('0 0 ', '');
             var endPos = searchTmp.search('"');
             var temp = searchTmp.substring(0, endPos);
             var sptArray = temp.split(" ");
             var svgwidth = sptArray[0];
             var svgheight = sptArray[1];

             //svg内容宽度:svg内容高度 = viewBox宽:viewBox高
             //svg内容高度 = svg内容宽度 * viewBox高 / viewBox宽
             var svgRealHeight = Math.floor(scaleWidth * svgheight / svgwidth);
             //如果svg内容高度大于布局高度则添加滚动条
             if (svgRealHeight > data.scaleHeight + 1) {
                 var svgRealWidth = Math.floor(scaleWidth);
                 //if there do need scrollbar, then restore text to its original prop
                 //布局位置
                 var marginleft = wrapObj['backMode'] ? data.scaleLeft - data.scaleBackLeft : 0;
                 var margintop = wrapObj['backMode'] ? data.scaleTop - data.scaleBackTop : 0;
                 temp = '<div style="width:{0}; height:{1};margin-left:{2}px;margin-top:{3}px;">{4}</div>';

                 if (data.isScroll) {
                     restr = String.format(temp, svgRealWidth + 'px', svgRealHeight + 'px', marginleft, margintop, svgstr);
                 } else {
                     restr = String.format(temp, '100%', '100%', marginleft, margintop, svgstr);
                 }
             } else {
                 restr += svgstr;
             }
         }
         return restr;
     }

     /**
      * 蒙版动画
      * @param  {[type]} data    [description]
      * @param  {[type]} wrapObj [description]
      * @return {[type]}         [description]
      */
     function maskContent(data, wrapObj) {

         var restr = "",

         //如果有蒙版图
         isMaskImg = data.mask ? prefix$3('mask-box-image') + ":url(" + Xut.config.pathAddress + data.mask + ");" : "";

         //蒙板图
         if (data.mask || wrapObj['isGif']) {
             //蒙版图
             if (prefix$3('mask-box-image') != undefined) {
                 restr += String.format('<img' + ' id="img_{1}"' + ' class="contentScrollerImg"' + ' src="{0}"' + ' style="width:{2}px;height:{3}px;position:absolute;background-size:100% 100%;{4}"/>', wrapObj['pathImg'], data['_id'], data.scaleWidth, data.scaleHeight, isMaskImg);
             } else {
                 //canvas
                 restr += String.format(' <canvas src="{0}"' + ' class="contentScrollerImg edges"' + ' mask="{5}"' + ' id = "img_{1}"' + ' width="{2}"' + ' height="{3}"' + ' style="width:{2}px; height:{3}px;opacity:0; background-size:100% 100%; {4}"' + ' />', wrapObj['pathImg'], data['_id'], data.scaleWidth, data.scaleHeight, isMaskImg, Xut.config.pathAddress.replace(/\//g, "\/") + data.mask);
             }
             //精灵图
         } else if (data.category == 'Sprite') {

                 var matrixX = 100 * data.thecount;
                 var matrixY = 100;

                 //如果有参数
                 //精灵图是矩阵图
                 if (data.parameter) {
                     var parameter = Utils.parseJSON(data.parameter);
                     if (parameter && parameter.matrix) {
                         var matrix = parameter.matrix.split("-");
                         matrixX = 100 * Number(matrix[0]);
                         matrixY = 100 * Number(matrix[1]);
                     }
                 }
                 restr += String.format('<div' + ' class="sprite"' + ' style="height:{0}px;background-image:url({1});background-size:{2}% {3}%;"></div>', data.scaleHeight, wrapObj['pathImg'], matrixX, matrixY);
             } else {
                 //普通图片
                 restr += String.format('<img' + ' src="{0}"' + ' class="contentScrollerImg"' + ' id="img_{1}"' + ' style="width:{2}px;height:{3}px;position:absolute;background-size:100% 100%; {4}"/>', wrapObj['pathImg'], data['_id'], data.scaleWidth, data.scaleHeight, isMaskImg);
             }

         return restr;
     }

     /**
      * 纯文本内容
      * @param  {[type]} data [description]
      * @return {[type]}      [description]
      */
     function textContent(data) {
         return String.format('<div' + ' id = "{0}"' + ' style="background-size:100% 100%;height:auto">{1}</div>', data['_id'], data.content);
     }

     /**
      * 针对容器类型的处理
      * @param  {[type]} containerName [description]
      * @param  {[type]} contentId     [description]
      * @param  {[type]} pid     [description]
      * @return {[type]}               [description]
      */
     function createContainerWrap(containerName, contentId, pid) {
         var contentDas = parseContentDas([contentId]),
             data = reviseSize(contentDas[0]),
             wapper = '<div' + ' id="{0}"' + ' data-behavior="click-swipe"' + ' style="width:{1}px;height:{2}px;top:{3}px;left:{4}px;position:absolute;z-index:{5};">';

         return String.format(wapper, containerName, data.scaleWidth, data.scaleHeight, data.scaleTop, data.scaleLeft, data.zIndex);
     }

     function createContainer$1(containerRelated, pid) {
         var itemIds,
             uuid,
             contentId,
             containerName,
             containerObj = {
             createUUID: [],
             containerName: []
         };
         containerRelated.forEach(function (data, index) {
             contentId = data.imageIds;
             containerName = "Container_" + pid + "_" + contentId, uuid = "aaron" + Math.random();
             containerObj[uuid] = {
                 'start': [createContainerWrap(containerName, contentId, pid)],
                 'end': '</div>'
             };
             containerObj.createUUID.push(uuid);
             containerObj.containerName.push(containerName);
             data.itemIds.forEach(function (id) {
                 containerObj[id] = uuid;
             });
         });
         return containerObj;
     }

     //=====================================================
     //
     //	构建content的序列tokens
     //	createImageIds,
     //	containerRelated,
     //	createContentIds
     //	pid,
     //	pageType,
     //	dydCreate //重要判断,动态创建
     //
     //=======================================================
     function structure(callback, data, context) {
         var content,
             contentId,
             wrapObj,
             containerObj,
             sizeResults,
             contentCollection,
             contentCount,
             cloneContentCount,
             createImageIds = data.createImageIds,
             pid = data.pid,
             pageType = data.pageType,
             containerRelated = data.containerRelated,
             seasonRelated = data.seasonRelated,
             isMaster = pageType === 'master',


         //容器li生成的位置
         //left,right
         virtualOffset = data.virtualOffset,


         ////////////
         //浮动处理 //
         //1.浮动母版对象
         //2.浮动页面对象
         ////////////
         floatMaters = data.floatMaters,
             floatPages = data.floatPages,


         //文本框
         //2016.1.7
         contentHtmlBoxIds = [],


         //所有content的id记录
         //返回出去给ibooks预编译使用
         idFix = [],


         //默认canvas容器的层级
         //取精灵动画最高层级
         //2016.2.25
         canvasIndex = 1,


         //缓存contentDas
         contentDas = {},

         //缓存content结构
         cachedContentStr = [];

         //启动cnavas模式
         var canvasRelatedMode = data.canvasRelated.enable;

         //容器结构创建
         if (containerRelated && containerRelated.length) {
             containerObj = createContainer$1(containerRelated, pid);
         }

         //========================================
         //
         //	    创建dom结构
         //
         //========================================

         /**
          * 转化canvas模式 contentMode 0/1
          * 页面或者母板浮动对象
          * 页面是最顶级的
          * @return {[type]}           [description]
          */
         var eachPara = function eachPara(parameter, contentId, conData) {
             var zIndex;
             _.each(parameter, function (para) {
                 //针对母版content的topmost数据处理，找出浮动的对象Id
                 //排除数据topmost为0的处理
                 zIndex = para['topmost'];
                 if (zIndex && zIndex != 0) {
                     if (isMaster) {
                         //收集浮动的母版对象id
                         floatMaters.ids.push(contentId);
                         floatMaters.zIndex[contentId] = zIndex;
                     } else {
                         //浮动页面
                         floatPages.ids.push(contentId);
                         floatPages.zIndex[contentId] = zIndex;
                     }
                 }
             });
         };

         /**
          * 设置canvas数据
          */
         var createCanvasData = function createCanvasData(type, contentId, conData) {
             //content收集id标记
             //cid =>content=> 普通动画 ppt
             //wid =>widget=>高级动画
             if (data.canvasRelated[type].indexOf(contentId) == -1) {
                 data.canvasRelated[type].push(contentId);
                 conData.actionTypes[type] = true;
             }

             if (data.canvasRelated.cid.indexOf(contentId) == -1) {
                 data.canvasRelated.cid.push(contentId);
             }

             //给content数据增加直接判断标示
             conData.canvasMode = true;

             //拿到最高层级
             if (conData.zIndex) {
                 if (conData.zIndex > canvasIndex) {
                     canvasIndex = conData.zIndex;
                 }
             }
         };

         /**
          * canvas pixi.js类型处理转化
          * 填充cid, wid
          * @type {Object}
          */
         var pixiType = {
             //普通精灵动画
             "Sprite": function Sprite(contentId, conData) {
                 //启动精灵模式
                 //在动画处理的时候给initAnimations快速调用
                 createCanvasData('spiritId', contentId, conData);
             },
             //ppt=》pixi动画
             "PPT": function PPT(contentId, conData) {
                 createCanvasData('pptId', contentId, conData);
             },
             //高级精灵动画
             //widget
             "SeniorSprite": function SeniorSprite(contentId, conData) {
                 createCanvasData('widgetId', contentId, conData);
             }
         };

         /**
          * 开始过滤参数
          * @return {[type]}           [description]
          */
         var prefilter = function prefilter(conData, contentId) {
             var eventId, parameter;
             var category = conData.category;

             //如果是模板书签，强制为浮动对象
             if (isMaster && (eventId = seasonRelated[contentId])) {
                 if (eventId['BookMarks']) {
                     floatMaters.ids.push(contentId);
                 }
             }

             //如果有parameter参数
             //1 浮动对象
             //2 canvas对象
             if (conData) {
                 //转成canvas标记
                 //如果有pixi的处理类型
                 //2016.2.25
                 //SeniorSprite,PPT
                 //Sprite,PPT
                 //SeniorSprite
                 //Sprite
                 //PPT
                 //5种处理方式
                 //可以组合
                 if (canvasRelatedMode && category) {
                     var _cat;
                     var cat;
                     var _cats = category.split(",");
                     var i = _cats.length;
                     //动作类型
                     conData.actionTypes = {};
                     if (i) {
                         while (i--) {
                             cat = _cats[i];
                             //匹配数据类型
                             pixiType[cat] && pixiType[cat](contentId, conData);
                         }
                     }
                 }

                 //如果有parameter
                 if (conData.parameter) {
                     if (parameter = parseJSON(conData.parameter)) {
                         //parameter保持数组格式
                         eachPara(parameter.length ? parameter : [parameter], contentId, conData);
                     }
                 }
             }
         };

         /**
          * 解析出每一个content对应的动作
          * 传递prefilter过滤器
          * 1 浮动动作
          * 2 canvas动作
          * @type {[type]}
          */
         contentCollection = parseContentDas(data.createContentIds, prefilter);
         contentCount = cloneContentCount = contentCollection.length;

         //创建canvas画布
         if (canvasRelatedMode) {
             Container(data, canvasIndex);
         }

         ////////////////
         //开始生成所有的节点 //
         //1:dom
         //2:canvas
         ////////////////
         while (contentCount--) {

             //根据数据创content结构
             if (content = contentCollection[contentCount]) {
                 contentId = content['_id'];
                 //创建包装器,处理数据引用关系
                 wrapObj = makeWarpObj(contentId, content, pageType, pid, virtualOffset);
                 idFix.push(wrapObj.containerName);

                 //保存文本框content的Id
                 if (wrapObj.isJs) {
                     contentHtmlBoxIds.push(contentId);
                 }
                 //转换缩放比
                 sizeResults = reviseSize(wrapObj.data);

                 //如果启用了virtualMode模式
                 //对象需要分离创建
                 if (Xut.config.virtualMode) {
                     virtualCreate(sizeResults, wrapObj, content, contentId);
                 } else {
                     //正常模式下创建
                     startCreate(wrapObj, content, contentId);
                 }
             } else {
                 //或者数据出错
                 checkComplete();
             }
         }

         //开始创建节点
         function startCreate(wrapObj, content, contentId) {
             //缓存数据
             contentDas[contentId] = content;
             //开始创建
             createRelated(contentId, wrapObj);
         }

         /**
          * 清理剔除的content
          * @param  {[type]} contentId [description]
          * @return {[type]}           [description]
          */
         function clearContent(contentId) {
             data.createContentIds.splice(data.createContentIds.indexOf(contentId), 1);
             checkComplete();
         }

         /**
          * 虚拟模式区分创建
          * @param  {[type]} sizeResults [description]
          * @param  {[type]} wrapObj     [description]
          * @param  {[type]} content     [description]
          * @param  {[type]} contentId   [description]
          * @return {[type]}             [description]
          */
         function virtualCreate(sizeResults, wrapObj, content, contentId) {
             // 创建分布左边的对象
             if (wrapObj.virtualOffset === 'left') {
                 if (sizeResults.scaleLeft < Xut.config.screenSize.width) {
                     startCreate(wrapObj, content, contentId);
                 } else {
                     clearContent(contentId);
                 }
             }
             // 创建分布右边的对象
             if (wrapObj.virtualOffset === 'right') {
                 if (sizeResults.scaleLeft > Xut.config.screenSize.width) {
                     startCreate(wrapObj, content, contentId);
                 } else {
                     clearContent(contentId);
                 }
             }
         }

         /**
          * 创建content节点
          * @param  {[type]} wrapObj [description]
          * @return {[type]}         [description]
          */
         function createRelated(contentId, wrapObj) {
             //解析外部文件
             externalFile(wrapObj, function (wrapObj) {
                 var uuid,
                     startStr,
                     contentStr,
                     conData = wrapObj.data;

                 //拼接地址
                 analysisPath(wrapObj, conData);

                 //dom模式下生成dom节点
                 //canvas模式下不处理，因为要合并到pixi场景中
                 if (!conData.canvasMode) {
                     contentStr = createDom(conData, wrapObj);
                 }

                 //如果创建的是容器对象
                 if (containerObj && (uuid = containerObj[contentId])) {
                     startStr = containerObj[uuid];
                     startStr.start.push(contentStr);
                 } else {
                     //普通对象
                     cachedContentStr.unshift(contentStr);
                 }

                 //检测完毕
                 checkComplete();
             });
         }

         /**
          * 返回处理
          * @return {[type]} [description]
          */
         function checkComplete() {
             if (cloneContentCount === 1) {
                 //针对容器处理
                 if (containerObj) {
                     var start,
                         end,
                         containerStr = [];
                     //合并容器
                     containerObj.createUUID.forEach(function (uuid) {
                         start = containerObj[uuid].start.join('');
                         end = containerObj[uuid].end;
                         containerStr.push(start.concat(end));
                     });
                     containerStr = containerStr.join('');
                     containerName = containerObj.containerName;
                     containerObj = null;
                     callback.call(context, contentDas, cachedContentStr.join('').concat(containerStr), containerName, idFix, contentHtmlBoxIds);
                 } else {
                     callback.call(context, contentDas, cachedContentStr.join(''), '', idFix, contentHtmlBoxIds);
                 }
             }
             cloneContentCount--;
         }
     }

     /**
      * 针对分段处理
      * 只构件必要的节点节点对象
      * content字段中visible === 0 是构建显示的对象
      * 					 	=== 1 是构建隐藏的对象
      *
      * 并且不是动态创建
      */
     // if (false && (1 == content.visible) && !data.dydCreate) {
     // endReturn();  //false 先屏蔽 ，客户端未实现
     // }else{}

     /**
      * 填充缺少的content对象
      * @return {[type]} [description]
      */

     /**
      * 按照shift取出执行代码
      * @return {[type]} [description]
      */
     function segmentation(delayBind) {
         var exetBind;
         while (exetBind = delayBind.shift()) {
             exetBind();
         }
     }

     function Mix(base, waitCreateContent, exitCallback) {
         var abstractContents = base.abstractContents,
             contentsFragment = base.relatedData.contentsFragment,
             pid = base.pid,
             pageType = base.pageType,

         //因为要dom去重,要处理创建的内容
         execWaitCreateContent = function execWaitCreateContent() {
             var willCreate = [],
                 prefix;
             _.each(waitCreateContent, function (contentId) {
                 prefix = base.makePrefix('Content', base.pid, contentId);
                 if (!contentsFragment[prefix]) {
                     //如果dom不存在,则创建
                     willCreate.push(contentId);
                 }
             });
             return willCreate;
         };

         /**
          * 合并创建节点
          **/
         function fillStructure(callback) {
             conStructure({
                 'dydCreate': true,
                 createContentIds: execWaitCreateContent,
                 pid: pid,
                 pageType: pageType
             }, function (contentDas, cachedContentStr, containerPrefix) {
                 callback(contentDas, $(cachedContentStr), containerPrefix);
             });
         }

         /**
          * 填充空节点数据
          * contentsFragment临时文档碎片
          * @return {[type]}       [description]
          */
         function fillFragment(cachedContentStr) {
             _.each(cachedContentStr, function (ele, index) {
                 contentsFragment[ele.id] = ele;
             });
         }

         /**
          * 填充作用域对象
          * @return {[type]} [description]
          */
         function fillAssistContents() {
             _.each(abstractContents, function (scope, index) {
                 var scopeObj;
                 if (!scope.$contentProcess) {
                     scopeObj = base.createHandlers(scope, 'waitCreate');
                     abstractContents.splice(index, 1, scopeObj); //替换作用域对象
                 }
             });
         }

         /**
          * 重构动态事件
          * 需要跳到不同的作用域对象
          * @return {[type]}           [description]
          */
         function fillEvent() {
             var collectEventRelated = base.relatedData.collectEventRelated,
                 eventObj,
                 parent,
                 delayBind = []; //延时绑定
             _.each(waitCreateContent, function (contentId) {
                 eventObj = collectEventRelated[contentId];
                 //事件对象存在,并且没有绑定事件
                 if (eventObj && !eventObj.isBind) {
                     parent = eventObj.parent;
                     parent.createEvent.call(parent);
                     delayBind.push(function () {
                         parent.bindEvent.call(parent);
                     });
                 }
             });
             return delayBind;
         }

         /**
          * 清理
          * @return {[type]} [description]
          */
         function clean() {
             base.waitCreateContent = null;
         }

         /**
          * 绘制显示
          * @return {[type]} [description]
          */
         function toRedraw(cachedContentStr) {
             Xut.nextTick({
                 'container': base.rootNode,
                 'content': cachedContentStr
             }, function () {
                 clean();
                 //绑定滑动isScroll
                 segmentation(base.relatedCallback.iScrollHooks);
                 exitCallback();
             });
         }

         function pocessContent(contentDas, cachedContentStr, containerPrefix) {

             //填充数据
             cachedContentStr && fillFragment(cachedContentStr);

             // 填充动画对象
             fillAssistContents();

             /**
              * 填充事件
              * 执行后绑定
              * 跨作用域
              */
             segmentation(fillEvent());

             /**
              * 开始初始化构建
              */
             self.initEffects();

             /**
              * 绘制页面
              */
             if (cachedContentStr) {
                 toRedraw(cachedContentStr);
             } else {
                 clean();
                 exitCallback();
             }
         }

         /**
          * 需要创建节点
          */
         if (execWaitCreateContent && execWaitCreateContent.length) {
             fillStructure(pocessContent);
         } else {
             //不需要创建节点
             pocessContent();
         }
     }

     var DOC = document;
     var prefix$4 = Xut.plat.prefixStyle;
     var KEYFRAMES = Xut.plat.KEYFRAMES;
     var ANIMATION_EV = Xut.plat.ANIMATION_EV;
     //全局样式style
     var styleElement = null;
     var playState = prefix$4('animation-play-state');
     //动画前缀
     var prefixAnims = prefix$4('animation');

     //css3模式-单图
     function css3Animate(options) {
         var $element = options.element,
             data = options.data,
             callback = options.callback || function () {},
             aniName = 'sprite_' + options.id,
             count = data.thecount,
             fps = data.fps,
             time = Math.round(1 / fps * count * 10) / 10,
             width = Math.ceil(data.scaleWidth * count),
             loop = data.loop ? 'infinite' : 1;

         //如果是矩形图
         var matrix;
         if (data.parameter) {
             var parameter = parseJSON(data.parameter);
             //矩阵
             if (parameter && parameter.matrix) {
                 matrix = parameter.matrix.split("-");
             }
         }

         /**
          * [ description]动态插入一条样式规则
          * @param  {[type]} rule [样式规则]
          * @return {[type]}      [description]
          */
         function insertCSSRule(rule) {
             var number, sheet, cssRules;
             //如果有全局的style样式文件
             if (styleElement) {
                 number = 0;
                 try {
                     sheet = styleElement.sheet;
                     cssRules = sheet.cssRules;
                     number = cssRules.length;
                     sheet.insertRule(rule, number);
                 } catch (e) {
                     console.log(e);
                 }
             } else {
                 //创建样式文件
                 styleElement = DOC.createElement("style");
                 styleElement.type = 'text/css';
                 styleElement.innerHTML = rule;
                 styleElement.uuid = 'aaron';
                 DOC.head.appendChild(styleElement);
             }
         }

         /**
          * [ description]删除一条样式规则
          * @param  {[type]} ruleName [样式名]
          * @return {[type]}          [description]
          */
         function deleteCSSRule(ruleName) {
             if (styleElement) {
                 var sheet = styleElement.sheet,
                     cssRules = sheet.rules || sheet.cssRules,
                     //取得规则列表
                 i = 0,
                     n = cssRules.length,
                     rule;
                 for (i; i < n; i++) {
                     rule = cssRules[i];
                     if (rule.name === ruleName) {
                         //删除单个规则
                         sheet.deleteRule(i);
                         break;
                     }
                 }
                 //删除style样式
                 if (cssRules.length == 0) {
                     DOC.head.removeChild(styleElement);
                     styleElement = null;
                 }
             }
         }

         //格式化样式表达式
         function setStep(aniName, time, count, loop) {
             var rule;
             if (matrix) {
                 rule = '{0} {1}s step-start {2}';
                 return String.format(rule, aniName, time, loop);
             } else {
                 rule = '{0} {1}s steps({2}, end) {3}';
                 return String.format(rule, aniName, time, count, loop);
             }
         }

         //设置精灵动画位置
         function setPostion(aniName, x) {
             //矩阵生成step的处理
             //  0 1 2
             //  3 4 5
             //  6 7 8
             if (matrix) {
                 var frames = [];
                 var base = 100 / count;
                 var col = Number(matrix[0]); //列数
                 //首次
                 frames.push(0 + '% { background-position:0% 0%}');
                 for (var i = 0; i < count; i++) {
                     var currRow = Math.ceil((i + 1) / col); //当前行数
                     var currCol = Math.floor(i / col); //当前列数 
                     var period = currCol * col; //每段数量 
                     var x = 100 * (i - period);
                     var y = 100 * currCol;

                     x = x == 0 ? x : "-" + x;
                     y = y == 0 ? y : "-" + y;
                     frames.push((i + 1) * base + '% { background-position: ' + x + '% ' + y + '%}');
                 }
                 return aniName + '{' + frames.join("") + '}';
             } else {
                 var rule = '{0} {from { background-position:0 0; } to { background-position: -{1}px 0px}}';
                 return String.format(rule, aniName, Math.round(x));
             }
         }

         //设置动画样式
         function setAnimition($element, rule) {
             prefixAnims && $element.css(prefixAnims, rule);
         }

         //添加到样式规则中
         function setKeyframes(rule) {
             if (KEYFRAMES) {
                 insertCSSRule(KEYFRAMES + rule);
             }
         }

         //动画css关键帧规则
         var rule1 = setStep(aniName, time, count, loop);
         var rule2 = setPostion(aniName, width);

         setAnimition($element, rule1);
         setKeyframes(rule2);
         $element.on(ANIMATION_EV, callback);

         return {

             runSprites: function runSprites() {
                 //运行动画
                 $element.show().css(playState, '');
             },

             stopSprites: function stopSprites() {
                 //停止精灵动画
                 deleteCSSRule(aniName);
                 $element.off(ANIMATION_EV, callback);
                 $element = null;
             },

             pauseSprites: function pauseSprites() {
                 //暂停精灵动画
                 $element.css(playState, 'paused');
             },

             playSprites: function playSprites() {
                 //恢复精灵动画
                 $element.css(playState, '');
             }

         };
     }

     //帧模式-多图
     function keyframes(options) {
         var $element = options.element,
             status = '',
             data = options.data,
             src = data.md5,
             count = data.thecount || 0,
             loop = data.loop,
             fps = data.fps || 1,
             root = Xut.config.pathAddress,
             info = parsePath(src),
             url = root + info.name,
             ext = info.ext,
             num = info.num || 0,
             timer = 0,
             image = DOC.createElement('img');

         image.src = root + src;
         $element.append(image);

         function _runSprites() {
             timer = setTimeout(function () {
                 image.src = url + num + ext;
                 num++;
                 check();
             }, 1000 / fps);
         }

         function check() {
             if (status === 'paused') {
                 return;
             }
             if (num > count) {
                 if (loop) {
                     num %= count;
                     _runSprites();
                 } else {
                     timer = null;
                     callback();
                 }
             } else {
                 _runSprites();
             }
         }

         //分解路径,得到扩展名和文件名
         function parsePath(path) {
             var tmp = path.split('.'),
                 ext = '.' + tmp[1],
                 tmp = tmp[0].split('-'),
                 name = tmp[0] + '-',
                 num = tmp[1] - 0;
             return {
                 name: name,
                 ext: ext,
                 num: num
             };
         }

         _runSprites();

         return {

             runSprites: function runSprites() {
                 status = 'play';
                 _runSprites();
             },

             stopSprites: function stopSprites() {
                 //停止精灵动画
                 clearTimeout(timer);
                 status = 'paused';
                 num = 0;
                 $element = null;
                 image = null;
             },

             pauseSprites: function pauseSprites() {
                 //暂停精灵动画
                 status = 'paused';
             },

             playSprites: function playSprites() {
                 //恢复精灵动画
                 status = 'play';
                 check();
             }

         };
     }

     //用pixi库实现的精灵动画
     function pixiAnimate(options) {
         var $element = options.element.parent(),
             data = options.data,
             callback = options.callback || function () {},
             count = data.thecount,
             fps = data.fps,
             width = Math.ceil(data.scaleWidth),
             height = Math.ceil(data.scaleHeight),
             loop = data.loop ? true : false;

         var scalex = Xut.config.proportion.width;
         var scaley = Xut.config.proportion.height;
         var path = Xut.config.pathAddress + data.md5;
         var i = 0;
         var x = 0;
         var data = [];
         var stage = new PIXI.Stage(0xFFFFFF);
         var renderer = PIXI.autoDetectRenderer(width, height, null, true);

         $element.empty().append(renderer.view);
         var sprite = new PIXI.Sprite.fromImage(path);
         sprite.scale.x = scalex;
         sprite.scale.y = scaley;

         for (var i = 0; i < count; i++) {
             data.push(i * width);
         }

         stage.addChild(sprite);

         requestAnimFrame(animate);

         function animate() {
             //控制刷新频率
             if (i % 15 == 0) {
                 sprite.position.x = -data[x];
                 renderer.render(stage);
                 x++;
                 if (x > data.length - 1) {
                     x = 0;
                     i = 0;
                 }
             }

             i++;
             requestAnimFrame(animate);
         }
     }

     function spriteAnimate(options) {
         var sprite = options.element,
             data = options.data,
             count = data.thecount,
             width = Math.ceil(data.scaleWidth),
             height = Math.ceil(data.scaleHeight),
             loop = data.loop ? true : false;

         var i = 0;
         var x = 0;
         var data = [];

         for (var i = 0; i < count; i++) {
             data.push(i * width);
         }

         requestAnimFrame(animate);

         function animate() {
             //控制刷新频率
             if (i % 15 == 0) {
                 sprite.position.x = -data[x];

                 x++;
                 if (x > data.length - 1) {
                     x = 0;
                     i = 0;
                 }
             }

             i++;
             //requestAnimFrame(animate);
         }
     }

     /**
      * css3动画
      * 1 帧动画
      * 2 定时器动画
      * 3 canvas动画
      * @param {[type]} options [description]
      */
     function Sprite(options) {
         var mode = options.mode || 'css';
         switch (mode) {
             case 'css':
                 return css3Animate(options);
             case 'timer':
                 return keyframes(options);
             case 'canvas':
                 return spriteAnimate(options);
             default:
                 return pixiAnimate(options);
         }
     }

     var arr = [];
     var slice = arr.slice;
     var concat = arr.concat;

     /**
      * pixi类
      * 子动画基类
      * @param {[type]} options [description]
      */
     var Factory = Xut.CoreObject.extend({

         /**
          * 初始化
          * @param  {[type]} data          [description]
          * @param  {[type]} canvasRelated [description]
          * @return {[type]}               [description]
          */
         init: function init(options) {
             var pixi = this;
             var args = [
             /**
              * 成功回调
              * @param  {[type]} contentId [description]
              * @return {[type]}           [description]
              */
             function successCallback(contentId) {
                 //加载完成构建 ppt实例
                 pixi.$emit('load');
             },
             /**
              * 失败回调
              * @param  {[type]} contentId [description]
              * @return {[type]}           [description]
              */
             function failCallback(contentId) {
                 //删掉对应的cid记录
                 // var index =  canvasRelated.cid.indexOf(contentId)
                 // canvasRelated.cid.splice(index,1);
                 console.log('failCallback');
             }];
             this.constructor.apply(this, args.concat(slice.call(arguments)));
         },

         /**
          * 播放
          * @param  {[type]} completeCallback [完成回调]
          * @return {[type]}                  [description]
          */
         playPixi: function playPixi(completeCallback) {
             this.checkValidity(function () {
                 this.play();
             });
         },

         //停止
         stopPixi: function stopPixi() {
             this.checkValidity(function () {
                 this.stop();
             });
         },

         //相关
         destroyPixi: function destroyPixi() {
             this.checkValidity(function () {
                 this.destroy();
             });
         },

         /**
          * 检测是否能有效运行
          * pixi对象是否有效加载
          * @return {[type]} [description]
          */
         checkValidity: function checkValidity(successCallback) {
             var failCid = this.canvasRelated.failCid;
             var contentId = this.contentId;
             //无效
             if (failCid.length && -1 !== failCid.indexOf(contentId)) {
                 return;
             }
             //有效
             successCallback && successCallback.call(this);
         },

         /**
          * 创建图片地址
          * @return {[type]}         [description]
          */
         analysisPath: function analysisPath(conData) {
             var pathImg,
                 imgContent = conData.md5,

             //是gif格式
             isGif = /.gif$/i.test(imgContent),

             //原始地址
             originalPathImg = Xut.config.pathAddress + imgContent;
             if (isGif) {
                 //处理gif图片缓存+随机数
                 pathImg = Xut.createRandomImg(originalPathImg);
             } else {
                 pathImg = originalPathImg;
             }
             return pathImg;
         }

     });

     observe.call(Factory.prototype);

     /**
      * 精灵动画
      * @param  {[type]} data          [description]
      * @param  {[type]} canvasRelated [description]
      * @return {[type]}               [description]
      */
     var Sprite$1 = Factory.extend({

         /**
          * 初始化
          * @param  {[type]} data          [description]
          * @param  {[type]} canvasRelated [description]
          * @return {[type]}               [description]
          */
         constructor: function constructor(successCallback, failCallback, data, canvasRelated) {

             var self = this;
             this.data = data;
             this.canvasRelated = canvasRelated;
             //id标示
             //可以用来过滤失败的pixi对象
             this.contentId = data._id;

             //精灵场景容器
             var spriteTtage = new PIXI.Container();
             //加入场景容器
             canvasRelated.addChild(spriteTtage);

             //矩形图
             var imgUrl = this.analysisPath(data);
             var imageFilename = imgUrl.replace(/^.*[\\\/]/, '');

             //support both png and jpg+mask
             var maskFilename = "mask_" + imageFilename;
             var imageextension = imgUrl.split('.').pop();
             var maskUrl = imgUrl.replace('.jpg', '_mask.png');

             //保证和以前版本的兼容性，旧版本精灵只有一行，因此没有matrix参数
             var matrixCols = data.thecount;
             var matrixRows = 1;
             if (data.parameter) {
                 //获取参数, 允许参数为null
                 try {
                     var paraObject = JSON.parse(data.parameter);
                 } catch (err) {
                     console.log('content parameter error');
                     return;
                 }
                 var dataMatrix = paraObject.matrix;
                 var matrixs = dataMatrix.split("-");
                 matrixCols = matrixs[0];
                 matrixRows = matrixs[1];
             }

             var jsonUrl = "lib/data/spritesheet.json" + "?imageurl=" + imgUrl + "&cols=" + matrixCols + "&rows=" + matrixRows + "&total=" + data.thecount + "&fps=" + data.fps;
             var movie;
             var contentId = this.contentId;

             //这里我们动态创建loader，加载完资源之后，就删除了。因此呢，也就没有缓存资源的情况了
             //我觉得这样似乎更好。因为我们整本书的动画很多，如果所有资源都缓存下来，可能内存消耗极大
             //现在这样每页动态创建，不加缓存，虽然性能上稍微差了一些，但是应该能够节省很多的内存
             var loader = new PIXI.loaders.Loader();
             if ('png' == imageextension) {
                 loader.add(imageFilename, jsonUrl).load(onAssetsLoaded);
             } else {
                 var maskJsonUrl = "lib/data/spritesheet.json" + "?imageurl=" + maskUrl + "&cols=" + matrixCols + "&rows=" + matrixRows + "&total=" + data.thecount + "&fps=" + data.fps;
                 loader.add(imageFilename, jsonUrl).add(maskFilename, maskJsonUrl).load(onAssetsLoaded);
             }
             loader = null;

             function onAssetsLoaded(loader, res) {

                 //资源加载失败
                 // if (arguments[1] && Object.keys(arguments[1]).length < 2) {
                 //     failCallback(contentId);
                 //     return
                 // }

                 //zhangyun, get the name of spritesheet
                 var textures = [];
                 var maskTextures = [];
                 //create textures array from res's textures object
                 var resObject, maskObject;
                 if ("object" == (typeof res === 'undefined' ? 'undefined' : babelHelpers.typeof(res))) {
                     //首次加载
                     resObject = res[Object.keys(res)[0]];
                 } else {
                     //重复加载时，传递的是字符串参数
                     //实际上这个分支没用到，如果需要处理缓存，则需要用到，现在我们没有缓存
                     resObject = PIXI.loader.resources[res];
                 }

                 //var resTextures = resObject.textures;
                 textures = Object.keys(resObject.textures).map(function (k) {
                     return resObject.textures[k];
                 });

                 //get fps
                 var fps = parseInt(resObject.url.split("fps=")[1]);

                 movie = new PIXI.extras.MovieClip(textures);
                 movie.width = data.scaleWidth;
                 movie.height = data.scaleHeight;
                 movie.position.x = data.scaleLeft;
                 movie.position.y = data.scaleTop;

                 //if there are masks, make mask textures;
                 var imageextension = resObject.name.split('.').pop();
                 if ("jpg" == imageextension) {
                     var maskObject = res[Object.keys(res)[1]];

                     maskTextures = Object.keys(maskObject.textures).map(function (k) {
                         return maskObject.textures[k];
                     });
                     movie.maskTextures = maskTextures;
                     spriteTtage.addChild(movie.maskSprite);
                 }

                 //动画速率
                 movie.animationSpeed = 0.15 * fps / 10;
                 movie.play();
                 spriteTtage.addChild(movie);

                 self.movie = movie;

                 //加载完毕
                 successCallback(contentId);
             }
         },

         /**
          * 运行动画
          * @return {[type]} [description]
          */
         play: function play() {
             //绘制页面
             this.uuid = this.canvasRelated.play('sprite');
         },

         /**
          * 停止动画
          * @return {[type]} [description]
          */
         stop: function stop() {
             this.canvasRelated.stop(this.uuid);
         },

         /**
          * 销毁动画
          * @return {[type]} [description]
          */
         destroy: function destroy() {
             //if there are movie sprite, destory it
             if (this.movie) {
                 //remove it from stage
                 if (this.stage) {
                     this.stage.removeChild(this.movie);
                 }
                 //remove texture for movie
                 for (var i = 0; i < this.movie.textures.length; i++) {
                     this.movie.textures[i].destroy(true);
                     if (this.movie.maskSprite) {
                         this.movie.maskTextures[i].destroy(true);
                     }
                 }

                 //remove movie sprite
                 this.movie.destroy(true, true);
             }
             this.canvasRelated.destroy();
         }

     });

     /**
      * 销毁动画音频
      * @param  {[type]} videoIds  [description]
      * @param  {[type]} chapterId [description]
      * @return {[type]}           [description]
      */
     function destroyContentAudio(videoIds, chapterId) {
         var isExist = false;
         //如果有音频存在
         videoIds && _.each(videoIds, function (data, index) {
             //如果存在对象音频
             if (data.videoId) {
                 isExist = true;
                 return 'breaker';
             }
         });
         if (isExist) {
             Xut.AudioManager.clearContentAudio(chapterId);
         }
     }

     /**
      * 判断是否存在
      * @return {Boolean} [description]
      */
     function bind(instance, success, fail) {
         if (instance) {
             success.call(instance, instance);
         } else {
             fail && fail();
         }
     }

     var uid = 0;

     /**
      * 依赖订阅
      */
     function Dep() {
         this.id = uid++;
         this.subs = [];
     }
     Dep.prototype.addSub = function (sub) {
         this.subs.push(sub);
     };
     Dep.prototype.removeSub = function (sub) {
         this.subs = [];
     };
     Dep.prototype.notify = function () {
         if (this.subs.length) {
             console.log('依赖队列');
         }
     };

     /**
      * 动画对象控制
      * @param {[type]} options [description]
      */
     var Animation = function Animation(options) {
         //mix参数
         _.extend(this, options);
     };

     var animProto = Animation.prototype;

     /**
      * 绑定动画
      * 为了向上兼容API
      * element 
      *  1 dom动画
      *  2 canvas动画
      * @param  {[type]} context   [description]
      * @param  {[type]} rootNode  [description]
      * @param  {[type]} chapterId [description]
      * @param  {[type]} parameter [description]
      * @param  {[type]} pageType  [description]
      * @return {[type]}           [description]
      */
     animProto.init = function (id, context, rootNode, chapterId, parameter, pageType) {

         var canvasRelated = this.canvasRelated;
         var pageIndex = this.pageIndex;
         var self = this;
         var actionTypes;
         var create = function create(constructor, newContext) {
             return new constructor(pageIndex, pageType, chapterId, newContext || context, parameter, rootNode);
         };

         //dom模式
         if (this.domMode) {
             //ppt动画
             this.pptObj = create(PptAnimation);
             //普通精灵动画
             this.domSprites = this.contentDas.category === 'Sprite' ? true : false;
         }

         //canvas模式
         //比较复杂
         //1 普通与ppt组合
         //2 高级与ppt组合
         //3 ppt独立
         //4 普通精灵动画
         //  其中 高级精灵动画是widget创建，需要等待
         if (this.canvasMode) {

             //动作类型
             //可能是组合动画
             actionTypes = this.contentDas.actionTypes;

             //精灵动画
             if (actionTypes.spiritId) {
                 //加入任务队列
                 this.nextTask.context.add(id);
                 this.pixiSpriteObj = new Sprite$1(this.contentDas, canvasRelated);
                 //ppt动画
                 if (actionTypes.pptId) {
                     //构建精灵动画完毕后
                     //构建ppt对象
                     this.pixiSpriteObj.$once('load', function () {
                         //content=>MovieClip
                         self.pptObj = create(CanvasAnimation, this.movie);
                         //任务完成
                         self.nextTask.context.remove(id);
                     });
                 }
             }

             //高级精灵动画
             //这个比较麻烦
             //因为精灵动画是widget创建类型
             //所以代码需要延后，等待高级content先创建
             if (actionTypes.widgetId) {
                 this.linker = function () {
                     return function widgetppt(context) {
                         self.pptObj = create(CanvasAnimation, context.sprObjs[0].advSprite);
                         self.linker.dep.notify(self.pptObj);
                     };
                 }();
                 // 收集依赖
                 this.linker.dep = new Dep();
             }
         }
     };

     /**
      * 运行动画
      * @param  {[type]} scopeComplete   [动画回调]
      * @param  {[type]} canvasContainer [description]
      * @return {[type]}                 [description]
      */
     animProto.run = function (scopeComplete) {

         var self = this,
             defaultIndex,
             element = this.$contentProcess;

         var pptRun = function pptRun(animObj) {
             //优化处理,只针对互斥的情况下
             //处理层级关系
             if (element.prop && element.prop("mutex")) {
                 element.css({ //强制提升层级
                     'display': 'block'
                 });
             }
             //指定动画
             animObj.runAnimation(scopeComplete);
         };
         //ppt动画
         bind(this.pptObj, pptRun);

         //canvas精灵动画
         bind(this.pixiSpriteObj, function (animObj) {
             animObj.playPixi(scopeComplete);
         });

         //dom精灵动画
         if (this.domSprites && element) {
             //存在动画
             if (this.spriteObj) {
                 this.spriteObj.playSprites();
                 return;
             }
             element = this.$contentProcess.find('.sprite').show();
             this.spriteObj = Sprite({
                 element: element,
                 data: this.contentDas,
                 id: this.id,
                 mode: 'css'
             });
         }
     };

     /**
      * 停止动画
      * @param  {[type]} chapterId [description]
      * @return {[type]}           [description]
      */
     animProto.stop = function (chapterId) {

         //ppt动画
         bind(this.pptObj, function (animObj) {
             //销毁ppt音频
             destroyContentAudio(animObj.options, chapterId);
             //停止PPT动画
             animObj.stopAnimation();
         });

         //canvas精灵
         bind(this.pixiSpriteObj, function (animObj) {
             animObj.stopPixi();
         });
         //dom精灵
         bind(this.spriteObj, function (sprObj) {
             sprObj.pauseSprites();
         });
     };

     /**
      * 翻页结束，复位上一页动画
      * @return {[type]} [description]
      */
     animProto.reset = function () {
         bind(this.pptObj, function (animObj) {
             animObj.resetAnimation();
         });
     };

     /**
      * 销毁动画
      * @return {[type]} [description]
      */
     animProto.destroy = function () {

         //canvas
         bind(this.pixiSpriteObj, function (animObj) {
             animObj.destroyPixi();
         });

         //dom ppt
         bind(this.pptObj, function (animObj) {
             animObj.destroyAnimation();
         });

         //dom 精灵
         bind(this.spriteObj, function (sprObj) {
             sprObj.stopSprites();
         });

         this.pptObj = null;
         this.spriteObj = null;
         this.getParameter = null;
         this.pixiSpriteObj = null;
     };

     /***************************************************************
      *
      *          视觉差对象初始化操作
      *
      ****************************************************************/

     var screenSize$2 = void 0;

     //变化节点的css3transform属性
     function transformNodes(rootNode, property, pageOffset) {
         var style = {},
             effect = '',
             parallaxOffset,
             //最终的偏移量X
         x = 0,
             y = 0,
             z = 0,
             round = Math.round,
             prefix = Xut.plat.prefixStyle,


         //浮动对象初始化偏移量
         parallaxOffset = pageOffset;

         if (property.translateX != undefined || property.translateY != undefined || property.translateZ != undefined) {
             x = round(property.translateX) || 0;
             y = round(property.translateY) || 0;
             z = round(property.translateZ) || 0;
             parallaxOffset += x;
             effect += String.format('translate3d({0}px,{1}px,{2}px) ', parallaxOffset, y, z);
         }

         if (property.rotateX != undefined || property.rotateY != undefined || property.rotateZ != undefined) {
             x = round(property.rotateX);
             y = round(property.rotateY);
             z = round(property.rotateZ);
             effect += x ? 'rotateX(' + x + 'deg) ' : '';
             effect += y ? 'rotateY(' + y + 'deg) ' : '';
             effect += z ? 'rotateZ(' + z + 'deg) ' : '';
         }

         if (property.scaleX != undefined || property.scaleY != undefined || property.scaleZ != undefined) {
             x = round(property.scaleX * 100) / 100 || 1;
             y = round(property.scaleY * 100) / 100 || 1;
             z = round(property.scaleZ * 100) / 100 || 1;
             effect += String.format('scale3d({0},{1},{2}) ', x, y, z);
         }

         if (property.opacity != undefined) {
             style.opacity = round((property.opacityStart + property.opacity) * 100) / 100;
             effect += ';';
         }

         if (effect) {
             style[prefix('transform')] = effect;
             rootNode.css(style);
         }

         return parallaxOffset;
     }

     //转换成比例值
     function conversionRatio(parameters) {
         if (parameters.opacityStart > -1) {
             parameters.opacity = (parameters.opacityEnd || 1) - parameters.opacityStart;
             delete parameters.opacityEnd;
         }
         return parameters;
     }

     //转化成实际值
     function conversionValue(parameters, nodeProportion, screenSize) {
         var results = {},
             width = -screenSize.width,
             height = -screenSize.height;

         for (var i in parameters) {
             switch (i) {
                 case 'translateX':
                 case 'translateZ':
                     results[i] = parameters[i] * nodeProportion * width;
                     break;
                 case 'translateY':
                     results[i] = parameters[i] * nodeProportion * height;
                     break;
                 case 'opacityStart':
                     results[i] = parameters[i];
                     break;
                 default:
                     results[i] = parameters[i] * nodeProportion;
             }
         }

         return results;
     }

     function Parallax(data) {

         screenSize$2 = Xut.config.screenSize;

         try {
             //转化所有css特效的参数的比例
             var parameters = JSON.parse(data.getParameter()[0]['parameter']);
         } catch (err) {
             return false;
         }
         var pid = data.pid,
             translate = conversionRatio(parameters),

         //页面偏移量
         pageOffset = this.relatedData.pageOffset && this.relatedData.pageOffset.split("-"),

         //开始的nodes值
         currPageOffset = pageOffset[0],

         //范围区域
         pageRange = pageOffset[1],

         //页面偏移比例
         nodeOffsetProportion = (currPageOffset - 1) / (pageRange - 1),

         //计算出偏移值
         offsetTranslate = conversionValue(translate, nodeOffsetProportion, screenSize$2),

         //页面分割比
         nodeProportion = 1 / (pageRange - 1);

         //改变节点的transform属性
         //返回改变后translateX值
         var parallaxOffset = transformNodes(data.$contentProcess, _.extend({}, offsetTranslate), data.transformOffset);

         /**
          * 为了兼容动画，把视觉差当作一种行为处理
          * 合并data数据
          * @type {Object}
          */
         data.parallax = {
             //计算页码结束边界值,用于跳转过滤
             calculateRangePage: function calculateRangePage() {
                 return {
                     'start': pid - currPageOffset + 1,
                     'end': pageRange - currPageOffset + pid
                 };
             },
             'translate': translate,
             'offsetTranslate': offsetTranslate,
             'nodeProportion': nodeProportion,
             'rootNode': data.$contentProcess,
             'parallaxOffset': parallaxOffset //经过视觉差修正后的偏移量
         };

         return data;
     }

     /**
      * 预运行动作
      * 自动 && 出现 && 无时间 && 无音乐
      *  && 不是精灵动画 && 没有脚本代码 && 并且不能是收费
      * @return {[type]}         [description]
      */
     function preRunAction(data, eventName) {
         var para,
             scopem,
             parameter = data.getParameter();
         //过滤预生成动画
         if (parameter.length === 1) {
             para = parameter[0];
             if (para.animationName === 'EffectAppear' && eventName === 'auto' && !para.videoId && !para.delay && data.contentDas.category !== 'Sprite' && !para.preCode //动画前脚本
              && !para.postCode //动画后脚本
              && !/"inapp"/i.test(para.parameter)) {
                 //并且不能是收费处理

                 /***********************************************
                  *      针对预处理动作,并且没有卷滚的不注册
                  *      满足是静态动画
                  * **********************************************/
                 //true是显示,false隐藏
                 return data.isRreRun = /"exit":"False"/i.test(para.parameter) === true ? 'visible' : 'hidden';
             }
         }
     }

     /**
      * 构建动画
      * @return {[type]} [description]
      */
     function createScope(base, contentId, pid, actName, contentDas, parameter, hasParallax) {
         //默认启动dom模式
         var data = {
             type: 'dom',
             canvasMode: false,
             domMode: true
         },
             $contentProcess,
             pageType = base.pageType;

         //如果启动了canvas模式
         //改成作用域的一些数据
         if (base.canvasRelated.enable) {
             //如果找到对应的canvas对象
             if (-1 !== base.canvasRelated.cid.indexOf(contentId)) {
                 $contentProcess = {}; //等待填充
                 data.type = 'canvas';
                 data.canvasMode = true;
                 data.domMode = false;
             }
         }

         //如果是dom模式
         if (!$contentProcess) {
             /**
              * 确保节点存在
              * @type {[type]}
              */
             if (!($contentProcess = base.findContentElement(actName))) {
                 return;
             };
         }

         /**
          * 制作公共数据
          * @type {Object}
          */
         _.extend(data, {
             base: base,
             id: contentId,
             pid: pid,
             actName: actName,
             contentDas: contentDas,
             $contentProcess: $contentProcess,
             pageType: pageType,
             pageIndex: base.pageIndex,
             canvasRelated: base.canvasRelated,
             nextTask: base.nextTask
         });

         /**
          * 如果是母版层理,视觉差处理
          * processType 三种情况
          *          parallax
          *          animation
          *          both(parallax,animation)
          * @type {[type]}
          */
         if (hasParallax && pageType === 'master') {
             data.processType = 'parallax';
         } else {
             data.processType = 'animation';
         }

         //生成查询方法
         data.getParameter = function () {
             //分区母版与页面的数据结构
             //parameter-master-parallax
             //parameter-master-animation
             //parameter-page-animation
             var fix = 'parameter-' + pageType + '-' + data.processType;
             data[fix] = parameter;
             return function () {
                 return data[fix];
             };
         }();

         /**
          * 生成视觉差作用域
          * @type {[type]}
          */
         if (data.processType === 'parallax') {
             //初始化视觉差对象的坐标偏移量
             data.transformOffset = base.relatedData.transformOffset(data.id);
             return Parallax.call(base, data);
         }

         /**
          *  优化机制,预生成处理
          *  过滤自动热点并且是出现动作，没有时间，用于提升体验
          */
         preRunAction(data, base.eventData.eventName);

         /**
          * 生成子作用域对象，用于抽象处理动画,行为
          */
         return new Animation(data);
     }

     /**
      * 分解每个子作用域
      * 1 生成临时占位作用域,用于分段动画
      * 2 生成所有动画子作用域
      * @param  {[type]} parameter [description]
      * @return {[type]}           [description]
      */
     function createHandlers(base, parameter, waitCreate) {
         /**
          * 如果是动态分段创建
          * 混入新的作用域
          */
         if (waitCreate) {
             return createScope.apply(base, parameter);
         }

         //dom对象
         var para = parameter[0],
             contentId = para['contentId'],
             //可能有多个动画数据 [Object,Object,Object]
         pid = base.pid,
             actName = base.makePrefix('Content', pid, contentId),
             contentDas = base.relatedData.contentDas[contentId];

         /**
          * 客户端未实现
          * 针对分段创建优化
          * 初始化必要加载数据
          * 临时占位数据
          */
         // if(contentDas && 1==contentDas.visible){
         //  //记录分段标记,用户合并创建节点
         //  base.waitCreateContent.push(contentId)
         //  return [contentId, pid, actName, contentDas, parameter];
         // }

         /**
          * 构建子作用域
          */
         return createScope(base, contentId, pid, actName, contentDas, parameter, para.masterId);
     }

     /**
      * 构建作用域
      * @return {[type]} [description]
      */
     function fnCreate(base) {
         return function (data, callback) {
             var para, handlers;
             if (data && data.length) {
                 //生成动画作用域对象
                 while (para = data.shift()) {
                     if (handlers = createHandlers(base, para)) {
                         callback(handlers);
                     }
                 }
             }
         };
     }

     /**
      * 源对象复制到目标对象
      */
     function innerExtend(target, source) {
         for (property in source) {
             if (target[property] === undefined) {
                 target[property] = source[property];
             }
         }
     }

     //处理itemArray绑定的动画对象
     //注入动画
     //绑定用户事件
     function Child(base) {
         var animation = base.seed.animation,
             parallax = base.seed.parallax,

         //抽出content对象
         abstractContents = [],

         //创建引用
         batcheCreate = fnCreate(base);

         switch (base.pageType) {
             case 'page':
                 batcheCreate(animation, function (handlers) {
                     abstractContents.push(handlers);
                 });
                 break;
             case 'master':
                 //母版层的处理
                 var tempParallaxScope = {},
                     tempAnimationScope = {},
                     tempAssistContents = [];
                 //视觉差处理
                 batcheCreate(parallax, function (handlers) {
                     tempParallaxScope[handlers.id] = handlers;
                 });

                 batcheCreate(animation, function (handlers) {
                     tempAnimationScope[handlers.id] = handlers;
                 });

                 var hasParallax = _.keys(tempParallaxScope).length,
                     hasAnimation = _.keys(tempAnimationScope).length;

                 //动画为主
                 //合并，同一个对象可能具有动画+视觉差行为
                 if (hasParallax && hasAnimation) {
                     _.each(tempAnimationScope, function (target) {
                         var id = target.id,
                             source;
                         if (source = tempParallaxScope[id]) {
                             //如果能找到就需要合并
                             innerExtend(target, source); //复制方法
                             target.processType = 'both'; //标记新组合
                             delete tempParallaxScope[id]; //删除引用
                         }
                     });
                     //剩余的处理
                     if (_.keys(tempParallaxScope).length) {
                         _.extend(tempAnimationScope, tempParallaxScope);
                     }
                     tempParallaxScope = null;
                 }
                 //转化成数组
                 _.each(hasAnimation ? tempAnimationScope : tempParallaxScope, function (target) {
                     tempAssistContents.push(target);
                 });
                 abstractContents = tempAssistContents;
                 break;
         }

         batcheCreate = null;

         return abstractContents;
     }

     /**
      * 搜索栏
      * 方便用户更加便捷的找到所需要的信息
      *
      */

     //图标
     var icons$1 = {
         search: 'images/icons/search.svg',
         clear: 'images/icons/clear.svg',
         exit: 'images/icons/exit.svg'
     };

     function SearchBar(options) {
         //父容器
         this.parent = options.parent;
         //提示信息
         this.tips = options.tips;
         this.init();
     }

     /**
      * 初始化
      * @return {[type]} [description]
      */
     SearchBar.prototype.init = function () {
         var $box = this.searchForm(),
             dom = this.parent[0];

         this.parent.append($box);
         this.searchBox = $box;
         this.resultBox = $box.find('.xut-search-result');
         this.input = $box.find('.xut-search-input');
         this.searchBtn = $box.find('.xut-search-btn');

         //用户操作事件邦定
         Xut.plat.execEvent('on', {
             context: dom,
             callback: {
                 end: this
             }
         });

         //即时搜索
         dom.addEventListener('keyup', this, false);
     };

     /**
      * 创建搜索框
      * @return {[object]} [jquery生成的dom对象]
      */
     SearchBar.prototype.searchForm = function () {
         var W = window.innerWidth * 0.3,
             H = window.innerHeight;
         var text = this.tips || '请在搜索框中输入要搜索的关键字';

         var box = '<div class="xut-form-search">' + '<div class="xut-form-search-wrap">' + '<div style="height:17%;">' + '<div style="height:20%"></div>' + '<div class="xut-search-row">' + '<input type="text" class="xut-search-input">' + '<div class="xut-search-btn" style="background-image: url(' + icons$1.search + ')"></div>' + '</div>' + '<p class="xut-search-tips" style="line-height:' + Math.round(H * 0.06) + 'px">' + text + '</p>' + '</div>' + '<div style="height:76%">' + '<ul class="xut-search-result"></ul>' + '</div>' + '<div style="height:7%">' + '<div class="xut-search-exit" style="background-image: url(' + icons$1.exit + ')"></div>' + '</div>' + '</div></div>';

         var $box = $(box);

         $box.css('width', W < 200 ? 200 : W);

         return $box;
     };

     /**
      * 搜索
      * @param {string} [keyword] [搜索关键字]
      */
     SearchBar.prototype.search = function (keyword) {
         var data = Xut.data.Chapter,
             ln = data.length,
             list = '',
             rs,
             pageId,
             seasonId;

         if (!keyword) {
             this.resultBox.html('');
             return;
         }

         for (var i = 0; i < ln; i++) {
             rs = data.item(i);
             if (rs.chapterTitle.indexOf(keyword) > -1) {
                 pageId = rs._id;
                 seasonId = rs.seasonId;
                 list += '<li><a class="xut-search-link" data-mark="' + seasonId + '-' + pageId + '" href="javascript:0">' + rs.chapterTitle + '</a></li>';
             }
         }

         this.resultBox.html(list);
     };

     /**
      * 切换搜索按钮图标
      * @param  {[type]} icon [图标路径]
      * @return {[type]}      [description]
      */
     SearchBar.prototype.iconManager = function (icon) {
         if (this.isChange) {
             this.searchBtn.css('background-image', 'url(' + icon + ')');
         };
     };

     /**
      * 跳转到搜索结果页
      * @param  {[type]} target [description]
      * @return {[type]}        [description]
      */
     SearchBar.prototype.searchLink = function (target) {
         if (!target || !target.dataset) return;
         var mark = target.dataset.mark.split('-'),
             seasonId = mark[0],
             pageId = mark[1];

         Xut.View.LoadScenario({
             'scenarioId': seasonId,
             'chapterId': pageId
         });
     };

     /**
      * 邦定事件
      * @param  {[type]} evt [事件]
      * @return {[type]}     [description]
      */
     SearchBar.prototype.handleEvent = function (evt) {
         var target = evt.target;
         switch (target.className) {
             case 'xut-search-btn':
                 //点击搜索
                 this.search(this.input.val());
                 this.isChange = true;
                 this.iconManager(icons$1.clear);
                 break;
             case 'xut-search-input':
                 //实时搜索
                 this.search(target.value);
                 //还原按钮图标
                 this.iconManager(icons$1.search);
                 this.isChange = false;
                 break;
             case 'xut-search-exit':
                 //关闭搜索框
                 this.exit();
                 break;
             case 'xut-search-link':
                 //跳转
                 this.searchLink(target);
                 break;
             default:
                 break;
         }
     };

     /**
      * 关闭搜索框
      * @return {[type]} [description]
      */
     SearchBar.prototype.exit = function () {
         this.input.val('');
         this.resultBox.empty();
         this.searchBox.hide();
     };

     /**
      * 恢复搜索框
      */
     SearchBar.prototype.restore = function () {
         var searchBox = this.searchBox;
         searchBox && searchBox.show();
     };

     /**
      * 销毁搜索框
      * @return {[type]} [description]
      */
     SearchBar.prototype.destroy = function () {
         var dom = this.parent[0];
         dom.removeEventListener('keyup', this, false);
         dom.removeEventListener('touchend', this, false);
         dom.removeEventListener('mouseup', this, false);

         this.searchBox.remove();
         this.searchBox = null;
         this.resultBox = null;
         this.searchBtn = null;
         this.input = null;
         this.parent = null;
     };

     var icons$2 = {
         hide: 'images/icons/arrowDown.svg'
     };
     var sLineHeiht$1 = parseInt($('body').css('font-size')) || 16;
     var BOOKCACHE$1;
     //书签缓存

     function BookMark$1(options) {
         this.parent = options.parent;
         this.pageId = options.pageId;
         this.seasonId = options.seasonId;
         //是否已存储
         this.isStored = false;
         this.init();
     }

     /**
      * 初始化
      * @return {[type]} [description]
      */
     BookMark$1.prototype.init = function () {
         var $bookMark = this.createBookMark(),
             dom = this.parent[0],
             that = this;

         this.parent.append($bookMark);
         this.bookMarkMenu = $bookMark.eq(0);
         //显示书签
         setTimeout(function () {
             that.restore();
         }, 20);
         //获取历史记录
         BOOKCACHE$1 = this.getHistory();

         //邦定用户事件
         Xut.plat.execEvent('on', {
             context: dom,
             callback: {
                 end: this
             }
         });
     };

     /**
      * 创建书签
      * @return {[object]} [jquery生成的dom对象]
      */
     BookMark$1.prototype.createBookMark = function () {

         var screenSize = Xut.config.screenSize;
         var sHeight = screenSize.height;

         var height = sLineHeiht$1 * 3,
             // menu的高为3em
         box = '<div class="xut-bookmark-menu" style="width:100%;height:{0}px;left:0;top:{1}px;">' + '<div class="xut-bookmark-wrap">' + '<div class="xut-bookmark-add">加入书签</div>' + '<div class="xut-bookmark-off" style="background-image:url({2})"></div>' + '<div class="xut-bookmark-view">书签记录</div>' + '</div>' + '</div>' + '<div class="xut-bookmark-list" style="display:none;width:100%;height:{3}px;">' + '<ul class="xut-bookmark-head">' + '<li class="xut-bookmark-back">返回</li>' + '<li>书签</li>' + '</ul>' + '<ul class="xut-bookmark-body"></ul>' + '</div>';
         box = String.format(box, height, sHeight, icons$2.hide, sHeight);
         this.markHeight = height;
         return $(box);
     };

     /**
      * 生成书签列表
      * @return {[type]} [description]
      */
     BookMark$1.prototype.createMarkList = function () {
         var tmp,
             seasonId,
             pageId,
             list = '',
             box = '',
             self = this;

         //取历史记录
         _.each(BOOKCACHE$1, function (mark) {
             tmp = mark.split('-');
             seasonId = tmp[0];
             pageId = tmp[1];
             mark = self.getMarkId(seasonId, pageId);
             list += '<li><a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">第' + pageId + '页</a><a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a></li>';
         });

         return list;
     };

     /**
      * 创建存储标签
      * 存储格式 seasonId-pageId
      * @return {string} [description]
      */
     BookMark$1.prototype.getMarkId = function (seasonId, pageId) {
         return seasonId + '-' + pageId;
     };

     /**
      * 获取历史记录
      * @return {[type]} [description]
      */
     BookMark$1.prototype.getHistory = function () {
         var mark = _get('bookMark');
         if (mark) {
             return mark.split(',');
         }
         return [];
     };

     /**
      * 添加书签
      * @return {[type]} [description]
      */
     BookMark$1.prototype.addBookMark = function () {
         var key;

         this.updatePageInfo();
         key = this.getMarkId(this.seasonId, this.pageId);

         //避免重复缓存
         if (BOOKCACHE$1.indexOf(key) > -1) {
             return;
         }
         BOOKCACHE$1.push(key);
         _set('bookMark', BOOKCACHE$1);
     };

     /**
      * 更新页信息
      *  针对母板层上的书签
      */
     BookMark$1.prototype.updatePageInfo = function () {
         var pageData = Xut.Presentation.GetPageData();
         this.pageId = pageData._id;
         this.seasonId = pageData.seasonId;
     };

     /**
      * 删除书签
      * @param {object} [key] [事件目标对象]
      * @return {[type]} [description]
      */
     BookMark$1.prototype.delBookMark = function (target) {
         if (!target || !target.dataset) return;

         var key = target.dataset.mark,
             index = BOOKCACHE$1.indexOf(key);

         BOOKCACHE$1.splice(index, 1);
         _set('bookMark', BOOKCACHE$1);

         if (BOOKCACHE$1.length == 0) {
             _remove$1('bookMark');
         }

         //移除该行
         $(target).parent().remove();
     };

     /**
      * 显示书签
      * @param {object} [target] [事件目标对象]
      * @return {[type]} [description]
      */
     BookMark$1.prototype.viewBookMark = function (target) {
         var $bookMarkList,
             list = this.createMarkList();

         if (this.bookMarkList) {
             $bookMarkList = this.bookMarkList;
         } else {
             $bookMarkList = $(target).parent().parent().next();
         }
         //更新书签内容
         $bookMarkList.find('.xut-bookmark-body').html(list);
         this.bookMarkList = $bookMarkList;
         $bookMarkList.fadeIn();
     };

     /**
      * 点击放大效果
      * @param  {[object]} target [事件目标对象]
      * @return {[type]}      [description]
      */
     BookMark$1.prototype.iconManager = function (target) {
         var $icon = this.bookMarkIcon = $(target),
             restore = this.iconRestore;

         $icon.css({
             'transform': 'scale(1.2)',
             'transition-duration': '500ms'
         })[0].addEventListener(Xut.plat.TRANSITION_EV, restore.bind(this), false);
     };

     /**
      * 复原按钮
      * @return {[type]} [description]
      */
     BookMark$1.prototype.iconRestore = function () {
         this.bookMarkIcon.css('transform', '');
     };

     /**
      * 跳转到书签页
      * @param  {[type]} target [description]
      * @return {[type]}        [description]
      */
     BookMark$1.prototype.goBookMark = function (target) {
         if (!target || !target.dataset) return;

         var key = target.dataset.mark.split('-'),
             seasonId = Number(key[0]),
             pageId = Number(key[1]);

         this.updatePageInfo();
         //关闭书签列表
         this.backBookMark();

         //忽略当前页的跳转
         if (this.pageId == pageId && this.seasonId == seasonId) {
             return;
         }

         Xut.View.LoadScenario({
             'scenarioId': seasonId,
             'chapterId': pageId
         });
     };

     /**
      * 书签回退键
      * @return {[type]} [description]
      */
     BookMark$1.prototype.backBookMark = function () {
         this.bookMarkList.fadeOut();
     };

     /**
      * 邦定事件
      * @param  {[type]} evt [事件]
      * @return {[type]}     [description]
      */
     BookMark$1.prototype.handleEvent = function (evt) {
         var target = evt.target;
         switch (target.className) {
             //加入书签
             case 'xut-bookmark-add':
                 this.addBookMark();
                 this.iconManager(target);
                 break;
             //显示书签记录
             case 'xut-bookmark-view':
                 this.viewBookMark(target);
                 this.iconManager(target);
                 break;
             //关闭书签
             case 'xut-bookmark-off':
                 this.closeBookMark(target);
                 break;
             //返回书签主菜单
             case 'xut-bookmark-back':
                 this.backBookMark();
                 break;
             //删除书签记录
             case 'xut-bookmark-del':
                 this.delBookMark(target);
                 break;
             //跳转到书签页
             case 'xut-bookmark-id':
                 this.goBookMark(target);
                 break;
             default:
                 //console.log(target.className)
                 break;
         }
     };

     /**
      * 关闭书签菜单
      * @return {[type]} [description]
      */
     BookMark$1.prototype.closeBookMark = function (target) {
         this.bookMarkMenu.css({
             transform: 'translate3d(0,0,0)',
             'transition-duration': '1s'
         });
     };

     /**
      * 恢复书签菜单
      */
     BookMark$1.prototype.restore = function () {
         this.bookMarkMenu.css({
             transform: 'translate3d(0,-' + this.markHeight + 'px,0)',
             'transition-duration': '1s'
         });
     };

     /**
      * 销毁书签
      * @return {[type]} [description]
      */
     BookMark$1.prototype.destroy = function () {
         var dom = this.parent[0],
             events = Xut.plat;

         dom.removeEventListener('touchend', this, false);
         dom.removeEventListener('mouseup', this, false);

         //菜单部分
         if (this.bookMarkMenu) {
             this.bookMarkMenu.remove();
             this.bookMarkMenu = null;
         }

         //列表部分
         if (this.bookMarkList) {
             this.bookMarkList.remove();
             this.bookMarkList = null;
         }

         //按钮效果
         if (this.bookMarkIcon) {
             this.bookMarkIcon[0].removeEventListener(events.TRANSITION_EV, this.iconRestore, false);
             this.bookMarkIcon = null;
         }

         this.parent = null;
     };

     var defaultFontSize = void 0;
     var baseValue1 = void 0;
     var baseValue2 = void 0;
     var baseValue3 = void 0;

     function setOption$1() {
         var proportion = Xut.config.proportion.width;
         var docEl = document.documentElement;
         try {
             defaultFontSize = parseInt(getComputedStyle(docEl).fontSize);
         } catch (er) {
             defaultFontSize = 16;
         }

         //实际字体大小
         defaultFontSize = defaultFontSize * proportion;

         //设置默认rem
         docEl.style.fontSize = defaultFontSize + "px";

         baseValue1 = Math.floor(defaultFontSize * 1.5);
         baseValue2 = Math.floor(defaultFontSize * 2.0);
         baseValue3 = Math.floor(defaultFontSize * 2.5);
     }

     /**
      * 工具栏布局
      * @return {[type]} [description]
      */
     function textLayer() {
         var str = '  <div class="htmlbox_close_container">' + '        <a class="htmlbox_close"></a>' + ' </div>' + ' <ul class="htmlbox_fontsizeUl">' + '    <li>' + '        <a class="htmlbox_small" style="width:{0}px;height:{1}px;margin-top:-{2}px"></a>' + '     </li>' + '     <li>' + '        <a class="htmlbox_middle" style="width:{3}px;height:{4}px;margin-top:-{5}px"></a>' + '     </li>' + '    <li>' + '        <a class="htmlbox_big" style="width:{6}px;height:{7}px;margin-top:-{8}px"></a>' + '    </li>' + ' </ul>';

         return String.format(str, baseValue1, baseValue1, baseValue1 / 2, baseValue2, baseValue2, baseValue2 / 2, baseValue3, baseValue3, baseValue3 / 2);
     }

     /**
      * 创建盒子容器
      * @return {[type]} [description]
      */
     function createWapper$1(boxName, textLayer, iscrollName, textContent) {
         var wapper = ' <div id="{0}" class="htmlbox_container">' + '    <div class="htmlbox-toolbar">{1}</div>' + '    <div id="{2}" style="overflow:hidden;position:absolute;width:100%;height:92%;">' + '        <ul>' + '          {3}' + '        </ul>' + '     </div>' + ' </div>';

         return String.format(wapper, boxName, textLayer, iscrollName, textContent);
     }

     function HtmlBox(contentId, element) {

         setOption$1();

         this.contentId = contentId;
         this.element = element;
         var self = this;

         //事件对象引用
         var eventHandler = function eventHandler(eventReference, _eventHandler) {
             self.eventReference = eventReference;
             self.eventHandler = _eventHandler;
         };

         //绑定点击事件
         bindEvents({
             'eventRun': function eventRun() {
                 Xut.View.HideToolbar();
                 self.init(contentId, element);
             },
             'eventHandler': eventHandler,
             'eventContext': element,
             'eventName': "tap",
             'domMode': true
         });
     }

     HtmlBox.prototype = {

         /**
          * 调整字体大小
          * @return {[type]} [description]
          */
         adjustSize: function adjustSize(value, save) {
             value = parseInt(value);
             docEl.style.fontSize = value + "px";
             save && _set(this.storageName, value);
         },

         /**
          * 卷滚
          * @param  {[type]} iscrollName [description]
          * @return {[type]}             [description]
          */
         createIscroll: function createIscroll(iscrollName) {
             this.iscroll = new iScroll("#" + iscrollName, {
                 scrollbars: true,
                 fadeScrollbars: true
             });
         },

         init: function init(contentId, element) {

             var self = this;

             //移除偏移量 存在偏移量造成文字被覆盖
             var textContent = element.find(">").html();
             textContent = textContent.replace(/translate\(0px, -\d+px\)/g, 'translate(0px,0px)');

             var boxName = "htmlbox_" + contentId;
             var iscrollName = "htmlbox_iscroll_" + contentId;

             //缓存名
             this.storageName = boxName + Xut.config.appId;

             //获取保存的字体值
             var storageValue = _get(this.storageName);
             if (storageValue) {
                 this.adjustSize(storageValue);
             }

             //创建容器
             this.$str = $(createWapper$1(boxName, textLayer(), iscrollName, textContent));
             element.after(this.$str);

             //卷滚
             this.createIscroll(iscrollName);

             //绑定事件上下文呢
             this.eventContext = this.$str.find('.htmlbox-toolbar')[0];
             //字体大小
             var sizeArray = ["1", "1.25", "1.5"];
             //改变字体与刷新卷滚
             var change = function change(fontsize) {
                 self.adjustSize(fontsize * defaultFontSize, true);
                 self.iscroll.refresh();
             };
             //处理器
             var process = {
                 htmlbox_close_container: function htmlbox_close_container() {
                     self.adjustSize(defaultFontSize);
                     self.removeBox();
                 },
                 htmlbox_close: function htmlbox_close() {
                     self.adjustSize(defaultFontSize);
                     self.removeBox();
                 },
                 htmlbox_small: function htmlbox_small() {
                     change(sizeArray[0]);
                 },
                 htmlbox_middle: function htmlbox_middle() {
                     change(sizeArray[1]);
                 },
                 htmlbox_big: function htmlbox_big() {
                     change(sizeArray[2]);
                 }
             };
             //冒泡匹配按钮点击
             this.start = function (e) {
                 var className = e.target.className;
                 process[className] && process[className]();
             };
             Xut.plat.execEvent('on', {
                 context: this.eventContext,
                 callback: {
                     start: this.start
                 }
             });
         },

         //移除盒子
         removeBox: function removeBox() {
             Xut.plat.execEvent('off', {
                 context: this.eventContext,
                 callback: {
                     start: this.start
                 }
             });
             this.$str && this.$str.remove();
             this.iscroll && this.iscroll.destroy();
             this.iscroll = null;
         },

         //销毁外部点击事件与
         destroy: function destroy() {
             _.each(this.eventReference, function (off) {
                 off("tap");
             });
             this.removeBox();
         }
     };

     /**
      * pixi事件绑定
      * @param  {[type]} Utils   [description]
      * @param  {[type]} Config) {}          [description]
      * @return {[type]}         [description]
      */

     /**
      * 动作适配
      * @type {Object}
      */
     var adapter = {
       /**
        * 单击
        * @return {[type]} [description]
        */
       "tap": function tap(eventData) {
         var eventContext = eventData.eventContext;
         eventContext.on('mousedown', eventData.eventRun);
         eventContext.on('touchstart', eventData.eventRun);
       }
     };

     /**
      * 绑定事件
      * @param  {[type]} eventData [description]
      * @return {[type]}           [description]
      */
     function bindEvents$1(eventData) {
       //开启交互
       eventData.eventContext.interactive = true;
       adapter[eventData.eventName](eventData);
     }

     /**
      * 2016.4.11
      * 因为canvas模式导致
      * 任务必须等待context上下创建
      * 完成后执行
      * 1 事件
      * 2 预执行
      * @type {Array}
      */
     function createNextTask(callback) {
         return {
             //子对象上下文
             context: {
                 wait: false, //是否等待创建
                 statas: false, //是否完成创建
                 _ids: [],
                 /**
                  * 检测是否完成
                  * @return {[type]} [description]
                  */
                 check: function check() {
                     var total = this.length();
                     if (!total.length) {
                         //完成创建
                         this.statas = true;
                     }
                     //如果已经等待
                     if (this.wait) {
                         callback && callback();
                         return;
                     }
                     //创建比流程先执行完毕
                     //一般几乎不存在
                     //但是不排除
                     if (!this.wait && this.statas) {
                         this.wait = true;
                         return;
                     }
                 },
                 add: function add(id) {
                     if (-1 === this._ids.indexOf(id)) {
                         this._ids.push(id);
                     }
                 },
                 remove: function remove(id) {
                     if (!id) return;
                     var index = this._ids.indexOf(id);
                     var val = this._ids.splice(index, 1);
                     this.check(val);
                     return val;
                 },
                 length: function length() {
                     return this._ids.length;
                 }
             },
             event: [], //事件
             pre: {} //预执行
         };
     }

     function activityClass(data) {

         var self = this;

         _.extend(this, data);

         /**
          * 2016.4.11
          * 因为canvas模式导致
          * 任务必须等待context上下创建
          * 完成后执行
          * 1 事件
          * 2 预执行
          * @type {Array}
          */
         this.nextTask = createNextTask(this.monitorComplete);

         /**
          * 初始化自定义事件
          */
         this.createEventRelated();

         /**
          * 为分段处理,记录需要加载的分段数据
          * @type {Array}
          */
         this.waitCreateContent = [];

         /**
          * 保存子对象（PPT辅助对象）
          * 1 动画作用域
          * 2 视觉差作用域
          * @type {Array}
          */
         this.abstractContents = Child(this);

         /**
          * 处理html文本框
          * 2016.1.6
          */
         this.htmlTextBox();

         /**
          * 注册用户自定义事件
          * dom
          * canvas
          */
         this.registerEvent();

         /**
          * 构建用户行为
          */
         this.createActions();

         /**
          * 2016.2.26
          * 修复妙妙学
          * 妙妙客户端处理
          * 点击效果的音频处理
          * @type {Array}
          */
         this._fixAudio = [];

         /**
          * 是否正在等待创建的子对象
          * 如果创建比流程先执行完毕
          * @return {[type]}   
          */
         if (this.nextTask.context.wait) {
             this.monitorComplete();
             return this;
         }

         /**
          * 等待创建执行
          * @param  {[type]} this.nextTask.context.length() 
          * @return {[type]}                                
          */
         if (this.nextTask.context.length()) {
             this.nextTask.context.wait = true;
             return this;
         }

         this.monitorComplete();
     }

     var activitPro = activityClass.prototype;

     /*********************************************************************
      *                 代码初始化
      *                初始基本参数
      *                构建动画关系作用域
      *                绑定基本事件
      **********************************************************************/

     /**
      * 检测是HTML文本框处理
      * @return {[type]} [description]
      */
     activitPro.htmlTextBox = function () {
         var self = this;
         var eventData = this.eventData;
         var relatedData = this.relatedData;
         var contentHtmlBoxIds = relatedData.contentHtmlBoxIds;
         var contentId;
         var contentName;
         var eventElement;
         //文本框实例对象
         //允许一个activity有多个
         this.htmlBoxInstance = [];
         //创建文本框对象
         if (contentHtmlBoxIds.length && relatedData.contentDas) {
             _.each(relatedData.contentDas, function (cds) {
                 if (~contentHtmlBoxIds.indexOf(cds._id)) {
                     contentId = cds._id;
                     contentName = self.makePrefix('Content', self.pid, contentId);
                     //找到对应绑定事件的元素
                     eventElement = self.findContentElement(contentName);
                     if (!eventElement.attr("data-htmlbox")) {
                         //构建html文本框对象
                         self.htmlBoxInstance.push(new HtmlBox(contentId, eventElement));
                         //增加htmlbox标志去重
                         //多个actictiy共享问题
                         eventElement.attr("data-htmlbox", "true");
                     }
                 }
             });
         }
     };

     /**
      * 制作一个查找标示
      * @return {[type]}
      */
     activitPro.makePrefix = function (name, pid, id) {
         return name + "_" + pid + "_" + id;
     };

     /**
      * 从文档碎片中找到对应的dom节点
      * 查找的范围
      * 1 文档根节点
      * 2 文档容器节点
      * @param  {[type]} prefix [description]
      * @return {[type]}        [description]
      */
     activitPro.findContentElement = function (prefix) {
         var element,
             containerPrefix,
             contentsFragment = this.relatedData.contentsFragment;

         if (element = contentsFragment[prefix]) {
             element = $(element);
         } else {
             //容器处理
             if (containerPrefix = this.relatedData.containerPrefix) {
                 _.each(containerPrefix, function (containerName, index) {
                     element = contentsFragment[containerName];
                     element = $(element).find('#' + prefix);
                     if (element.length) {
                         return;
                     }
                 });
             }
         }
         return element;
     };

     /*********************************************************************
      *
      *                 动画控制
      *
      **********************************************************************/

     /**
      * 保证正确遍历
      * @return {[type]} [description]
      */
     activitPro.eachAssistContents = function (callback) {
         _.each(this.abstractContents, function (scope) {
             //保存只能处理动画
             //scope.processType === 'animation' || scope.processType === 'both')
             callback.call(this, scope);
         }, this);
     };

     /**
      * 初始化PPT动画与音频
      * @return {[type]} [description]
      */
     activitPro.createActions = function () {

         var pageId = this.relatedData.pageId,
             rootNode = this.rootNode,
             collectorHooks = this.relatedCallback.contentsHooks,
             pageType = this.pageType;

         this.eachAssistContents(function (scope) {

             var context, type, id, isRreRun, parameter;

             //针对必须创建
             if (!(context = scope.$contentProcess)) {
                 return;
             };

             //如果是视觉差对象，也需要实现收集器
             if (scope.processType === 'parallax') {
                 collectorHooks(scope.pid, scope.id, scope);
                 return;
             }

             //如果是动画才处理
             id = scope.id, isRreRun = scope.isRreRun, parameter = scope.getParameter();

             //如果不是预生成
             //注册动画事件
             if (isRreRun === undefined) {
                 scope.init(id, context, rootNode, pageId, parameter, pageType);
             }

             //绑定DOM一些属性
             this.domRepeatBind(id, context, isRreRun, scope, collectorHooks, scope.canvasMode);
         });
     };

     /**
      * dom节点去重绑定
      * 1 翻页特性
      * 2 注册钩子
      * 3 预显示
      * @return {[type]} [description]
      */
     activitPro.domRepeatBind = function (id, context, isRreRun, scope, collectorHooks, canvasMode) {
         var indexOf,
             relatedData = this.relatedData;
         //过滤重复关系
         if (-1 !== (indexOf = relatedData.createContentIds.indexOf(id))) {
             //去重
             relatedData.createContentIds.splice(indexOf, 1);
             //收集每一个content注册
             collectorHooks(scope.pid, id, scope);
             //canvas模式
             if (canvasMode) {
                 if (isRreRun) {
                     // console.log(id,scope)
                     //直接改变元素状态
                     // context.visible = isRreRun === 'visible' ? true : false;
                     this.nextTask.pre[id] = function () {
                         this.nextTask.pre.push(function pre(context) {
                             console.log('预执行', isRreRun);
                             //this.canvasRelated.oneRender();
                         });
                     };
                 }
             } else {
                     //dom模式
                     //增加翻页特性
                     this.addIScroll(scope, context);
                     //直接复位状态,针对出现动画 show/hide
                     if (isRreRun) {
                         //直接改变元素状态
                         context.css({
                             'visibility': isRreRun
                         });
                     }
                 }
         }
     };

     /**
      * 增加翻页特性
      * 可能有多个引用关系
      * @return {[type]}         [description]
      */
     activitPro.addIScroll = function (scope, element) {
         var self = this,
             elementName,
             contentDas = scope.contentDas;

         //给外部调用处理
         function makeUseFunction(element) {

             var prePocess = self.makePrefix('Content', scope.pid, scope.id),
                 preEle = self.findContentElement(prePocess);

             //重置元素的翻页处理
             // defaultBehavior(preEle);

             //ios or pc
             if (!Xut.plat.isAndroid) {
                 return function () {
                     createIscroll(element);
                 };
             }

             //在安卓上滚动文本的互斥不显示做一个补丁处理
             //如果是隐藏的,需要强制显示,待邦定滚动之后再还原
             //如果是显示的,则不需要处理,
             var visible = preEle.css('visibility'),
                 restore = function restore() {};

             if (visible == 'hidden') {
                 var opacity = preEle.css('opacity');
                 //如果设置了不透明,则简单设为可见的
                 //否则先设为不透明,再设为可见
                 if (opacity == 0) {
                     preEle.css({
                         'visibility': 'visible'
                     });
                     restore = function restore() {
                         preEle.css({
                             'visibility': visible
                         });
                     };
                 } else {
                     preEle.css({
                         'opacity': 0
                     }).css({
                         'visibility': 'visible'
                     });
                     restore = function restore() {
                         preEle.css({
                             'opacity': opacity
                         }).css({
                             'visibility': visible
                         });
                     };
                 }
             }

             return function () {
                 createIscroll(element);
                 restore();
                 preEle = null;
                 restore = null;
             };
         }

         //增加卷滚条
         if (contentDas.isScroll) {
             //去掉高度，因为有滚动文本框
             element.find(">").css("height", "");
             // elementName = this.makePrefix('contentWrapper', scope.pid, scope.id);
             this.relatedCallback.iscrollHooks.push(makeUseFunction(element[0]));
         }

         //如果是图片则补尝允许范围内的高度
         if (!contentDas.mask || !contentDas.isGif) {
             element.find && element.find('img').css({
                 'height': contentDas.scaleHeight
             });
         }
     };

     /**
      * 检测创建完成度
      */
     activitPro.checkCreate = function (callback) {
         var waitCreateContent = this.waitCreateContent;
         if (waitCreateContent && waitCreateContent.length) {
             Mix(this, waitCreateContent, callback);
         } else {
             callback();
         }
     };

     /**
      * 运行动画
      * @param  {[type]} outComplete [动画回调]
      * @return {[type]}             [description]
      * evenyClick 每次都算有效点击
      */
     activitPro.runEffects = function (outComplete, evenyClick) {

         var self = this;
         var pageId = this.relatedData.pageId;

         if (evenyClick) {
             self.preventRepeat = false;
         }

         //防止重复点击
         if (self.preventRepeat) {
             return false;
         }

         self.preventRepeat = true;

         //如果没有运行动画
         if (!self.seed.animation) {
             self.preventRepeat = false;
             self.relevantOperation();
             return;
         }

         //创建的无行为content
         var partContentRelated = self.relatedData.partContentRelated;
         var closeAnim;

         //制作作用于内动画完成
         //等待动画完毕后执行动作or场景切换
         var captureAnimComplete = self.captureAnimComplete = function (counts) {
             return function (scope) {
                 //动画结束,删除这个hack
                 scope && scope.$contentProcess && scope.$contentProcess.removeProp && scope.$contentProcess.removeProp('animOffset');

                 //如果快速翻页
                 //运行动画的时候，发现不是可视页面
                 //需要关闭这些动画 
                 closeAnim = pageId != Xut.Presentation.GetPageId();

                 if (closeAnim && scope) {
                     scope.stop && scope.stop(pageId);
                     scope.reset && scope.reset();
                 }

                 //捕获动画状态
                 if (counts === 1) {
                     if (closeAnim) {
                         //复位动画
                         self.resetAloneAnim();
                     }
                     self.preventRepeat = false;
                     self.relevantOperation();
                     outComplete && outComplete();
                     self.captureAnimComplete = null;
                 } else {
                     --counts;
                 }
             };
         }(this.abstractContents.length);

         /**
          * 如果是preRun处理
          * @return {Boolean} [description]
          */
         function isRreRunPocess(scope) {
             //针对空跳过处理
             if (partContentRelated && partContentRelated.length && -1 !== partContentRelated.indexOf(scope.id)) {
                 captureAnimComplete();
             } else {
                 //必须要修改
                 if (scope.$contentProcess) {
                     if (scope.canvasMode) {
                         //直接改变元素状态
                         scope.$contentProcess.visible = scope.isRreRun === 'visible' ? true : false;
                         self.canvasRelated.oneRender();
                     } else {
                         //因为执行的顺序问题，动画与页面零件
                         //isscroll标记控制
                         if (!scope.$contentProcess.attr('isscroll')) {
                             scope.$contentProcess.css({
                                 'visibility': scope.isRreRun
                             });
                         }
                     }
                 }
                 captureAnimComplete();
             }
         }

         /**
          * 检测创建完成度
          * 递归创建
          * @return {[type]}       [description]
          */
         self.checkCreate(function () {
             //执行动画
             self.eachAssistContents(function (scope) {
                 if (scope.isRreRun) {
                     isRreRunPocess(scope);
                 } else {
                     //标记动画正在运行
                     scope.$contentProcess && scope.$contentProcess.prop && scope.$contentProcess.prop({
                         'animOffset': scope.$contentProcess.offset()
                     });
                     //ppt动画
                     //ppt音频
                     scope.run(function () {
                         captureAnimComplete(scope);
                     });
                 }
             });
             self.runState = true;
         });
     };

     /**
      * 停止动画
      * @return {[type]} [description]
      */
     activitPro.stopEffects = function () {
         var pageId = this.relatedData.pageId;
         this.runState = false;
         this.eachAssistContents(function (scope) {
             !scope.isRreRun && scope.stop && scope.stop(pageId);
         });
     };

     /**
      * 处理拖动对象
      * @return {[type]} [description]
      */
     function accessDrop(eventData, callback) {
         if (eventData && eventData.dragDrop) {
             callback(eventData.dragDrop);
         }
     }

     /**
      * 复位独立动画
      * 提供快速翻页复用
      * @return {[type]} [description]
      */
     activitPro.resetAloneAnim = function () {
         //复位拖动对象
         accessDrop(this.eventData, function (drop) {
             drop.reset();
         });
         //如果是运行canvas模式
         //停止绘制
         if (this.canvasRelated.stopRender) {
             setTimeout(function () {
                 this.canvasRelated.stopRender();
             }.bind(this), 0);
         }
     };

     //复位状态
     activitPro.resetAnimation = function () {
         this.eachAssistContents(function (scope) {
             !scope.isRreRun && scope.reset && scope.reset(); //ppt动画
         });

         this.resetAloneAnim();
     };

     //销毁动画
     activitPro.destroyEffects = function (elementCallback) {
         //销毁拖动对象
         accessDrop(this.eventData, function (drop) {
             drop.destroy();
         });
         this.eachAssistContents(function (scope) {
             if (scope.destroy) {
                 scope.destroy();
             }
             elementCallback && elementCallback(scope);
         });
     };

     /**
      * 动画运行之后
      * 1 创建一个新场景
      * 2 执行跳转到收费提示页面
      * 3 触发搜索工具栏
      * @return {[type]} [description]
      */
     activitPro.relevantOperation = function () {

         var scenarioInfo, eventContentId;

         //触发事件的content id
         if (this.eventData) {
             eventContentId = this.eventData.eventContentId;
         }

         if (eventContentId) {

             //查找出当前节的所有信息
             if (scenarioInfo = this.relatedData.seasonRelated[eventContentId]) {

                 //如果存在搜索栏触发
                 if (scenarioInfo.SearchBar) {
                     this.createSearchBar();
                     return;
                 }

                 //如果存在书签
                 if (scenarioInfo.BookMarks) {
                     this.createBookMark();
                     return;
                 }

                 //收费处理
                 if (scenarioInfo.Inapp !== undefined) {
                     if (scenarioInfo.Inapp == 1) {
                         Xut.Application.HasBuyGood(); //已收费
                     } else {
                             Xut.Application.BuyGood(); //付费接口
                         }
                     return;
                 }

                 //处理新的场景
                 if (scenarioInfo.seasonId || scenarioInfo.chapterId) {
                     setTimeout(function () {
                         Xut.View.LoadScenario({
                             'scenarioId': scenarioInfo.seasonId,
                             'chapterId': scenarioInfo.chapterId
                         });
                     }, Xut.fix.audio ? 1000 : 0);
                     return;
                 }

                 // console.log('content跳转信息出错',scenarioInfo)
             }
         }
     };

     /**
      * 创建搜索框
      * @return {[type]} [description]
      */
     activitPro.createSearchBar = function () {
         var options = {
             parent: this.rootNode
         };
         if (this.searchBar) {
             //如果上次只是隐藏则可以恢复
             this.searchBar.restore();
         } else {
             this.searchBar = new SearchBar(options);
         }
     };

     /**
      * 创建书签
      * @return {[type]} [description]
      */
     activitPro.createBookMark = function () {
         var element, seasonId, pageId, pageData;
         if (this.pageType === 'master') {
             //模板取对应的页面上的数据
             pageData = Xut.Presentation.GetPageData();
             element = this.relatedData.floatMaters.container;
             pageId = pageData._id;
             seasonId = pageData.seasonId;
         } else {
             element = this.rootNode;
             seasonId = this.relatedData.seasonId;
             pageId = this.pageId;
         }
         var options = {
             parent: element,
             seasonId: seasonId,
             pageId: pageId
         };

         if (this.bookMark) {
             //如果上次只是隐藏则可以恢复
             this.bookMark.restore();
         } else {
             this.bookMark = new BookMark$1(options);
         }
     };

     /*********************************************************************
      *
      *                      用户自定义接口事件
      *                                                                    *
      **********************************************************************/

     /**
      * 构建事件体系
      * @return {[type]} [description]
      */
     activitPro.createEventRelated = function () {

         //配置事件节点
         var eventId,
             pid,
             contentName,

         //事件上下文对象
         eventContext,
             eventData = this.eventData;

         //如果存在imageIds才处理,单独绑定事件处理
         if (eventId = eventData.eventContentId) {
             var domEvent = function domEvent() {
                 pid = this.pid;
                 contentName = this.makePrefix('Content', pid, this.id);
                 //找到对应绑定事件的元素
                 eventContext = this.findContentElement(contentName);
             };

             var canvasEvent = function canvasEvent() {
                 eventContext = {};
                 eventData.type = 'canvas';
                 eventData.canvasMode = true;
                 eventData.domMode = false;
             };

             //canvas事件


             //默认dom模式
             _.extend(eventData, {
                 'type': 'dom',
                 'domMode': true,
                 'canvasMode': false
             });

             if (-1 !== this.canvasRelated.cid.indexOf(eventId)) {
                 canvasEvent.call(this);
             } else {
                 //dom事件
                 domEvent.call(this);
             }

             eventData.eventContext = eventContext;

             if (eventContext) {
                 //绑定事件加入到content钩子
                 this.relatedCallback.contentsHooks(pid, eventId, {
                     $contentProcess: eventContext,
                     //增加外部判断
                     isBindEventHooks: true,
                     type: eventData.type
                 });
             } else {
                 /**
                  * 针对动态事件处理
                  * 快捷方式引用到父对象
                  * @type {[type]}
                  */
                 eventData.parent = this;
             }
         }

         /**
          * 解析出事件类型
          */
         eventData.eventName = conversionEventType(eventData.eventType);
     };

     /**
      * 绑定事件行为
      * @return {[type]} [description]
      */
     activitPro.bindEventBehavior = function (callback) {
         var self = this,
             eventData = this.eventData,
             eventName = eventData.eventName,
             eventContext = eventData.eventContext;

         /**
          * 运行动画
          * @return {[type]} [description]
          */
         function startRunAnim() {
             //当前事件对象没有动画的时候才能触发关联动作
             var animOffset,
                 boundary = 5; //边界值

             if (eventData.domMode && (animOffset = eventContext.prop('animOffset'))) {
                 var originalLeft = animOffset.left;
                 var originalTop = animOffset.top;
                 var newOffset = eventContext.offset();
                 var newLeft = newOffset.left;
                 var newTop = newOffset.top;
                 //在合理的动画范围是允许点击的
                 //比如对象只是一个小范围的内的改变
                 //正负10px的移动是允许接受的
                 if (originalLeft > newLeft - boundary && originalLeft < newLeft + boundary || originalTop > newTop - boundary && originalTop < newTop + boundary) {
                     self.runEffects();
                 }
             } else {
                 self.runEffects();
             }
         }

         /**
          * 设置按钮的行为
          * 音频
          * 反弹
          */
         function setBehavior(feedbackBehavior) {

             var behaviorSound;
             //音频地址
             if (behaviorSound = feedbackBehavior.behaviorSound) {

                 var createAuido = function createAuido() {
                     return new Xut.Audio({
                         url: behaviorSound,
                         trackId: 9999,
                         complete: function complete() {
                             this.play();
                         }
                     });
                 };
                 //妙妙学客户端强制删除
                 if (MMXCONFIG && audioHandler) {
                     self._fixAudio.push(createAuido());
                 } else {
                     createAuido();
                 }
             }
             //反弹效果
             if (feedbackBehavior.isButton) {
                 //div通过css实现反弹
                 if (eventData.domMode) {
                     eventContext.addClass('xut-behavior');
                     setTimeout(function () {
                         eventContext.removeClass('xut-behavior');
                         startRunAnim();
                     }, 500);
                 } else {
                     //canvas反弹
                     var sx = eventContext.scale.x;
                     var px = eventContext.position.x;

                     eventContext.scale.x += 0.1;
                     eventContext.position.x -= Math.round(px * 0.05);
                     self.canvasRelated.oneRender();

                     setTimeout(function () {
                         eventContext.scale.x = sx;
                         eventContext.position.x = px;
                         self.canvasRelated.oneRender();
                     }, 200);
                 }
             } else {
                 startRunAnim();
             }
         }

         /**
          * 事件引用钩子
          * 用户注册与执行
          * @type {Object}
          */
         var eventDrop = {
             //保存引用,方便直接销毁
             init: function init(drag) {
                 eventData.dragDrop = drag;
             },
             //拖拽开始的处理
             startRun: function startRun() {},
             //拖拽结束的处理
             stopRun: function stopRun(isEnter) {
                 if (isEnter) {
                     //为true表示拖拽进入目标对象区域
                     self.runEffects();
                 }
             }
         };

         /**
          * 正常动画执行
          * 除去拖动拖住外的所有事件
          * 点击,双击,滑动等等....
          * @return {[type]} [description]
          */
         var eventRun = function eventRun() {
             //如果存在反馈动作
             //优先于动画执行
             var feedbackBehavior;
             if (feedbackBehavior = eventData.feedbackBehavior[eventData.eventContentId]) {
                 setBehavior(feedbackBehavior);
             } else {
                 startRunAnim();
             }
         };

         /**
          * 事件对象引用
          * @return {[type]} [description]
          */
         var eventHandler = function eventHandler(eventReference, _eventHandler) {
             eventData.eventReference = eventReference;
             eventData.eventHandler = _eventHandler;
         };

         //绑定用户自定义事件
         if (eventContext && eventName) {

             var domName,
                 target,
                 dragdropPara = eventData.dragdropPara;

             //获取拖拽目标对象
             if (eventName === 'dragTag') {
                 domName = this.makePrefix('Content', this.pid, dragdropPara);
                 target = this.findContentElement(domName);
             }

             //增加事件绑定标示
             //针对动态加载节点事件的行为过滤
             eventData.isBind = true;

             callback.call(this, {
                 'eventDrop': eventDrop,
                 'eventRun': eventRun,
                 'eventHandler': eventHandler,
                 'eventContext': eventContext,
                 'eventName': eventName,
                 'parameter': dragdropPara,
                 'target': target,
                 'domMode': eventData.domMode
             });
         }
     };

     /**
      * 注册事件
      * @return {[type]} [description]
      */
     activitPro.registerEvent = function () {
         var eventData = this.eventData;
         /**
          * 2016.2.19
          * 绑定canvas事件
          * 由于canvas有异步加载
          * 这里content创建的时候不阻断加载
          * 所以canvas的事件体系
          * 放到所有异步文件加载后才执行
          */
         if (eventData.type === "canvas") {
             var eventData = this.eventData;
             var makeFunction = function bind() {
                 //找到对应的上下文pixi stoge
                 eventData.eventContext = {};
                 this.bindEventBehavior(function (eventData) {
                     bindEvents$1(eventData);
                 });
             };
             this.nextTask.event.push(makeFunction.bind(this));
         } else {
             //dom事件
             this.bindEventBehavior(function (eventData) {
                 bindEvents(eventData);
             });
         }
     };

     /*********************************************************************
      *
      *                      外部调用接口
      *                                                                    *
      **********************************************************************/

     //自动运行
     activitPro.autoPlay = function (outComplete) {
         var eventData = this.eventData;
         if (eventData && eventData.eventName === 'auto') {
             this.runEffects(outComplete);
         } else {
             outComplete();
         }
     };

     //翻页开始
     activitPro.flipOver = function () {
         if (this.runState) {
             this.stopEffects();
         }
         this.preventRepeat = false;
         //复位盒子
         if (this.htmlBoxInstance.length) {
             _.each(this.htmlBoxInstance, function (instance) {
                 instance.removeBox();
             });
         }
         //修复妙妙客户端
         //没有点击音频结束的回调
         //最多允许播放5秒
         if (this._fixAudio.length) {
             _.each(this._fixAudio, function (instance) {
                 setTimeout(function () {
                     instance.end();
                 }, 5000);
             });
             this._fixAudio = [];
         }
     };

     //翻页完成复位动画
     activitPro.flipComplete = function () {
         this.resetAnimation();
     };

     //销毁
     //提供一个删除回调
     //用于处理浮动对象的销毁
     activitPro.destroy = function (elementCallback) {

         //销毁绑定事件
         if (this.eventData.eventContext) {
             destroyEvents(this.eventData);
             this.eventData.eventContext = null;
         }

         //2016.1.7
         //如果有文本框事件
         //一个activity允许有多个文本框
         //所以是数组索引
         if (this.htmlBoxInstance.length) {
             _.each(this.htmlBoxInstance, function (instance) {
                 instance.destroy();
             });
             this.htmlBoxInstance = null;
         }

         //销毁动画
         this.destroyEffects(elementCallback);

         //iscroll销毁
         if (this.iscroll) {
             this.iscroll.destroy();
             this.iscroll = null;
         }

         //销毁搜索框
         if (this.searchBar) {
             this.searchBar.destroy();
             this.searchBar = null;
         }

         //销毁书签
         if (this.bookMark) {
             this.bookMark.destroy();
             this.bookMark = null;
         }

         this.rootNode = null;
     };

     //复位
     activitPro.recovery = function () {
         if (this.runState) {
             this.stopEffects();
             return true;
         }
         return false;
     };

     function TaskContents(data) {
         var preCompileContents;
         data = _.extend(this, data);

         //如果有预执行动作
         //Activity表数据存在
         if (preCompileContents = parseContents(data)) {
             //解析动画表数据结构
             data = parserRelated(preCompileContents, data);
             //如果有需要构建的content
             //开始多线程处理
             data.createContentIds.length ? this.dataAfterCheck(data) : this.loadComplete();
         } else {
             this.loadComplete();
         }
     }

     var taskProto = TaskContents.prototype;

     /**
      * 任务断言
      */
     taskProto.assert = function (taskName, tasks) {

         var self = this;

         //中断方法
         var suspendTasks = function suspendTasks() {
             self.suspendQueues = [];
             self.suspendQueues.push(function () {
                 tasks.call(self);
             });
         };

         //完成方法
         var nextTasks = function nextTasks() {
             tasks.call(self);
         };

         self.pageBaseHooks.suspend(taskName, nextTasks, suspendTasks);
     };

     /**
      * 运行被阻断的线程任务
      * @return {[type]} [description]
      */
     taskProto.runSuspendTasks = function () {
         if (this.suspendQueues) {
             var fn;
             if (fn = this.suspendQueues.pop()) {
                 fn();
             }
             this.suspendQueues = null;
         }
     };

     /**
      * 构建完毕
      * @return {[type]} [description]
      */
     taskProto.loadComplete = function () {
         this.pageBaseHooks.success();
     };

     function createFn(obj, id, callback) {
         var cObj = obj[id];
         if (!cObj) {
             cObj = obj[id] = {};
         }
         callback.call(cObj);
     }

     /**
      * 转成数组格式
      * @param  {[type]} contentsFragment [description]
      * @return {[type]}                  [description]
      */
     function toArray(o) {
         var contentsFragment = [];
         _.each(o, function (contentElements) {
             contentsFragment.push(contentElements);
         });
         return contentsFragment;
     }

     /**
      * 构建快速查询节点对象
      * 转成哈希方式
      * @return {[type]} [description]
      */
     function toObject(cachedContentStr) {
         var tempFragmentHash = {};
         _.each($(cachedContentStr), function (ele, index) {
             tempFragmentHash[ele.id] = ele;
         });
         return tempFragmentHash;
     };

     /**
      * 行为反馈
      *  content id = {
      *      弹动
      *      音频URl
      *  }
      */
     function addBehavior(data) {
         var parameter,
             soundSrc,
             contentId,
             isButton,
             feedbackBehavior = data.feedbackBehavior = {};
         _.each(data.activitys, function (activitys) {
             if (activitys.parameter && (parameter = parseJSON(activitys.parameter))) {
                 contentId = activitys.imageId;
                 //视觉反馈
                 if (isButton = parameter['isButton']) {
                     if (isButton != 0) {
                         //过滤数据的字符串类型
                         createFn(feedbackBehavior, contentId, function () {
                             this['isButton'] = true;
                         });
                     }
                 }
                 //音频行为
                 if (soundSrc = parameter['behaviorSound']) {
                     if (soundSrc != 0) {
                         createFn(feedbackBehavior, contentId, function () {
                             this['behaviorSound'] = soundSrc;
                         });
                     }
                 }
             }
         });
     }

     /**
      * 中断一:构建数据之后
      * @param  {[type]} data [description]
      * @return {[type]}      [description]
      */
     taskProto.dataAfterCheck = function (data) {

         this.assert('dataAfter', function () {

             //浮动模板
             //用于实现模板上的事件
             data.floatMaters = {
                 'ids': [], //浮动id
                 'container': {}, //浮动容器
                 'zIndex': {}
                 // offset : {}  //初始化坐标数据
             };

             //浮动页面
             //母板事件引起的层级遮挡问题
             //用于提升最高
             data.floatPages = {
                 'ids': [],
                 'zIndex': {}
             };

             //增加点击行为反馈
             addBehavior(data);

             //构建页面content类型结构
             var createStr = function createStr(contentDas, cachedContentStr, containerPrefix, idFix, contentHtmlBoxIds) {

                 data.contentHtmlBoxIds = contentHtmlBoxIds;

                 data.contentsFragment = {};

                 //iboosk节点预编译
                 //在执行的时候节点已经存在
                 //不需要在创建
                 if (Xut.IBooks.runMode()) {
                     _.each(idFix, function (id) {
                         data.contentsFragment[id] = data.element.find("#" + id)[0];
                     });
                 } else {
                     //构件快速查询节点对象
                     data.contentsFragment = toObject(cachedContentStr);
                 }

                 //容器的前缀
                 data.containerPrefix = containerPrefix;

                 //2015.5.6暴露到全局
                 //提供给音频字幕上下文               
                 if (!Xut.Contents.contentsFragment[data.chapterId]) {
                     Xut.Contents.contentsFragment[data.chapterId];
                 }
                 Xut.Contents.contentsFragment[data.chapterId] = data.contentsFragment;

                 //开始下一个任务
                 this.dataStrCheck(data, contentDas);
             };

             //构建页面节点
             structure(createStr, data, this);
         });
     };

     /**
      * 中断二:构建结构之后
      * @param  {[type]} data       [description]
      * @param  {[type]} contentDas [description]
      * @return {[type]}            [description]
      */
     taskProto.dataStrCheck = function (data, contentDas) {
         this.assert('strAfter', function () {

             //保留场景的留信息
             //用做软件制作单页预加载
             Xut.sceneController.seasonRelated = data.seasonRelated;

             //初始化content对象
             //绑定content
             //1 动画
             //2 事件
             //3 视觉差
             //4 动画音频
             //5 canvas动画
             contentsBehavior(function (delayHooks) {
                 //渲染页面
                 this.eventAfterCheck(data, delayHooks);
             }.bind(this), data, contentDas);
         });
     };

     ///////////////
     //创建浮动相关的信息 //
     ///////////////
     function crateFloat(callback, floatName, dasFloat, data, base) {

         var elements = [];
         var prefix = 'Content_' + data.pid + "_";

         //去重复
         dasFloat.ids = arrayUnique(dasFloat.ids);

         var makePrefix,
             fragment,
             zIndex,
             zIndexs = dasFloat.zIndex;

         data.count++;

         //分离出浮动节点
         _.each(dasFloat.ids, function (id) {
             makePrefix = prefix + id;
             if (fragment = data.contentsFragment[makePrefix]) {
                 zIndex = zIndexs[id];
                 //保证层级关系
                 // fragment.style.zIndex = (Number(zIndex) + Number(fragment.style.zIndex))
                 elements.push(fragment);
                 delete data.contentsFragment[makePrefix];
             }
         });

         //floatPages模式下面
         //如果是当前页面
         //因为会产生三页面并联
         //所以中间去最高层级
         if (floatName === 'floatPages' && base.initTransformParameter[2] === 0) {
             zIndex = 2001;
         } else {
             zIndex = 2000;
         }

         //浮动根节点
         //floatPages设置的content溢出后处理
         //在非视区增加overflow:hidden
         //可视区域overflow:''
         var overflow = 'overflow:hidden;';
         //如果是母板,排除
         if (floatName === 'floatMaters') {
             overflow = '';
         }
         var floatStr = String.format('<div id="' + floatName + '-li-{0}" class="xut-float" style="' + Xut.plat.prefixStyle('transform') + ':{1};z-index:' + zIndex + ';{2}"></div>', data.pid, base.initTransformParameter[0], overflow);

         var container = $(floatStr);

         //增加浮动容器
         $(data.rootNode).after(container);

         callback(elements, container);
     }

     /**
      * 创建浮动母版对象
      * @return {[type]} [description]
      */
     function createFloatMater(base, data, complete) {
         //创建浮动对象
         crateFloat(function (elements, container) {
             //浮动容器
             data.floatMaters.container = container;

             Xut.nextTick({
                 'container': container,
                 'content': elements
             }, function () {
                 //收集浮动母版对象标识
                 base.pageBaseHooks.collector.floatMaters(data.floatMaters);
                 complete(data);
             });
         }, 'floatMaters', data.floatMaters, data, base);
     }

     /**
      * 创建浮动的页面对象
      */
     function createFloatPage(base, data, complete) {
         //创建浮动对象
         crateFloat(function (elements, container) {
             //浮动容器
             data.floatPages.container = container;
             Xut.nextTick({
                 'container': container,
                 'content': elements
             }, function () {
                 //收集浮动母版对象标识
                 base.pageBaseHooks.collector.floatPages(data.floatPages);
                 complete(data);
             });
         }, 'floatPages', data.floatPages, data, base);
     }

     /**
      * 中断三:绑定事件事件之后
      * @param  {[type]} iScrollHooks [description]
      * @return {[type]}              [description]
      */
     taskProto.eventAfterCheck = function (data, delayHooks) {

         var self = this;

         this.assert('eventAfter', function () {

             data.count = 1; //计算回调的成功的次数

             /**
              * 完成钩子函数
              * 1 content的卷滚条
              * 2 canvas事件绑定
              * @return {[type]} [description]
              */
             var completeHooks = function completeHooks() {
                 var hooks;
                 _.each(delayHooks, function (fns) {
                     while (hooks = fns.shift()) {
                         hooks();
                     }
                 });
             };

             var nextTask = function nextTask() {
                 completeHooks();
                 self.applyAfterCheck();
             };

             /**
              * 1 页面浮动
              * 2 母版浮动
              * 3 正常对象
              */
             var complete = function (data) {
                 return function () {
                     if (data.count === 1) {
                         /**
                          * 2016.2.16
                          * 绘制canvas节点
                          * @return {[type]}                           
                          */
                         if (data.canvasRelated.enable && data.canvasRelated.cid.length) {
                             //初始化绘制canvas
                             //页面显示
                             data.canvasRelated.display();
                             nextTask();
                         } else {
                             nextTask();
                         }
                         return;
                     }
                     data.count--;
                 };
             }(data);

             //浮动页面对
             //浮动对象比任何层级都都要高
             //超过母版
             if (data.floatPages.ids && data.floatPages.ids.length) {
                 createFloatPage(this, data, complete);
             }

             //如果存在母版浮动节点
             //在创建节点structure中过滤出来，根据参数的tipmost
             if (data.floatMaters.ids && data.floatMaters.ids.length) {
                 createFloatMater(this, data, complete);
             }

             //iboosk节点预编译
             //在执行的时候节点已经存在
             //不需要在创建
             if (Xut.IBooks.runMode()) {
                 complete();
             } else {
                 //正常对象
                 Xut.nextTick({
                     'container': data.element,
                     'content': toArray(data.contentsFragment)
                 }, complete);
             }
         });
     };

     /**
      * 中断四：渲染content
      * @return {[type]} [description]
      */
     taskProto.applyAfterCheck = function () {
         this.assert('applyAfter', function () {
             //构建页面节点
             // Xut.log('debug', '第' + (self.pid + 1) + '页面content相关的节点与事件全部构建完毕................')
             this.loadComplete(true);
         });
     };

     /**
      * 清理引用
      * @return {[type]} [description]
      */
     taskProto.clearReference = function () {
         //删除字幕用的碎片文档
         if (Xut.Contents.contentsFragment[this.chapterId]) {
             delete Xut.Contents.contentsFragment[this.chapterId];
         }
         this.element = null;
         this.rootNode = null;
         this.contentsFragment = null;
     };

     /** 配置ID
      * @return {[type]} [description]
      */
     function autoUUID() {
         return 'autoRun-' + Math.random().toString(36).substring(2, 15);
     }

     /**
      * 给所有content节点绑定对应的事件与动画
      * @return {[type]} [description]
      */
     function contentsBehavior(callback, data, contentDas) {
         var compiler,
             element = data.element,
             eventRelated = data.eventRelated,
             //合集事件
         pid = data.pid,
             activityRelated = data.activityRelated,
             feedbackBehavior = data.feedbackBehavior,
             //反馈数据,跟事件相关
         pageBaseHooks = data.pageBaseHooks,
             pageId = data.chapterId;

         //如果有浮动对象,才需要计算偏移量
         //母版里面可能存在浮动或者不浮动的对象
         //那么在布局的时候想对点不一样
         //如果在浮动区域就取浮动初始值
         //否则就是默认的想对点0
         var transformOffset = function (ids, initTransformOffset) {
             return function (id) {
                 //匹配是不是属于浮动对象
                 if (ids.length && ids[id]) {
                     //初始化容器布局的坐标
                     return initTransformOffset;
                 }
                 return 0;
             };
         }(data.floatMaters.ids, data.initTransformParameter[2]);

         //相关回调
         var relatedCallback = {
             //绑定卷滚条钩子
             'iscrollHooks': [],
             //contetn钩子回调
             'contentsHooks': pageBaseHooks.collector.contents
         };

         //相关数据
         var relatedData = {
             'floatMaters': data.floatMaters,
             'seasonId': data.chpaterData.seasonId,
             'pageId': pageId,
             'contentDas': contentDas, //所有的content数据合集
             'container': data.liRootNode,
             'seasonRelated': data.seasonRelated,
             'containerPrefix': data.containerPrefix,
             'nodes': data.nodes,
             'pageOffset': data.pageOffset,
             'createContentIds': data.createContentIds,
             'partContentRelated': data.partContentRelated,
             'transformOffset': transformOffset,
             'contentsFragment': data.contentsFragment,
             'contentHtmlBoxIds': data.contentHtmlBoxIds
         };

         /**
          * 收集事件信息
          * 为处理动态分段绑定的问题
          * @type {Object}
          */
         var collectEventRelated = {};

         /**
          * 继续下一个任务
          * @return {[type]} [description]
          */
         var nextTask = function nextTask() {
             //多事件合集处理pagebase
             if (eventRelated) {
                 pageBaseHooks.eventBinding && pageBaseHooks.eventBinding(eventRelated);
             }
             //删除钩子
             delete relatedCallback.contentsHooks;
             callback(relatedCallback);
         };

         /**
          * 2016.4.11
          * canvas模式创建的才完成数
          * 监控完成度
          * 如果是canvas就需要监听创建
          * 因为存在异步创建
          * @type {Object}
          */
         var monitor = {
             total: activityRelated.length,
             current: 0,
             complete: function complete() {
                 ++monitor.current;
                 if (monitor.current == monitor.total) {
                     nextTask();
                 }
             }
         };

         /**
          * 生成activty控制对象
          * @type {[type]}
          */
         while (compiler = activityRelated.shift()) {

             var filters;
             var imageId = compiler['imageIds']; //父id
             var activity = compiler['activity'];
             var eventType = activity.eventType;
             var dragdropPara = activity.para1;
             var eventContentId = imageId;

             /**
              * 多事件数据过滤
              * 为了防止数据写入错误数据
              * 如果当前对象上有多事件的行为
              * 则默认的事件去掉
              * @type {[type]}
              */
             if (filters = eventRelated['eventContentId->' + imageId]) {
                 _.each(filters, function (edata) {
                     //id不需要
                     //eventContentId = void 0;
                     if (edata.eventType == activity.eventType) {
                         //写入的是伪数据,此行为让多事件抽象接管
                         eventType = dragdropPara = void 0;
                     }
                 });
             }

             //需要绑定事件的数据
             var eventData = {
                 'eventContentId': eventContentId,
                 'eventType': eventType,
                 'dragdropPara': dragdropPara,
                 'feedbackBehavior': feedbackBehavior
             };

             //缓存所有的事件数据
             if (eventContentId) {
                 collectEventRelated[eventContentId] = eventData;
                 relatedData['collectEventRelated'] = collectEventRelated;
             }

             //注册引用
             pageBaseHooks.registerAbstractActivity(new activityClass({
                 'monitorComplete': monitor.complete, //监听完成
                 'pageIndex': data.pageIndex,
                 'canvasRelated': data.canvasRelated, //父类引用
                 'id': imageId || autoUUID(),
                 "type": 'Content',
                 'pageId': pageId,
                 'activityId': activity._id,
                 'rootNode': element,
                 'pageType': compiler['pageType'], //构建类型 page/master
                 'seed': compiler['seed'], //动画表数据 or 视觉差表数据
                 "pid": pid, //页码
                 'eventData': eventData, //事件数据
                 'relatedData': relatedData, //相关数据,所有子作用域Activity对象共享
                 'relatedCallback': relatedCallback //相关回调
             }));
         }
     }

     /**
      * 解析出需要构建的content对象
      * @param  {[type]} data [description]
      * @return {[type]}      [description]
      */
     function parseContents(data) {
         var actType,
             preCompileContent = [];

         //需要创建的数据结构
         _.each(data.activitys, function (activityData) {
             actType = activityData.actType || activityData.animation;
             //特殊类型 showNote
             if (!actType && activityData.note) {
                 activityData['actType'] = actType = "ShowNote";
             }
             if (activityData.itemArray || activityData.autoPlay !== 2) {
                 switch (actType) {
                     case 'Container':
                     case 'Content':
                     case 'Parallax':
                     case 'Contents':
                         preCompileContent.push(activityData);
                         //compileContent();
                         break;
                 }
             }
             //编译content类型
             // 1 通过Animation表产生
             // 2 通过Parallax 表产生
             function compileContent() {
                 preCompileContent.push({
                     postprocessor: function postprocessor(rootEle, pid) {
                         activityData['nodes'] = data['nodes'];
                         activityData['pageOffset'] = data['pageOffset'];
                         return activityData;
                     }
                 });
             }
         });
         return preCompileContent.length ? preCompileContent : null;
     }

     function TaskComponents(data, suspendCallback, successCallback) {

         //预编译模式跳过创建
         if (Xut.IBooks.runMode()) {
             successCallback();
             return;
         }

         if (data['activitys'].length) {
             var str;
             this.rootNode = data['rootNode'];
             this.callback = {
                 'suspendCallback': suspendCallback,
                 'successCallback': successCallback
             };
             str = this.create(data);
             this.compileSuspend(str);
         } else {
             successCallback();
         }
     }

     TaskComponents.prototype = {

         clearReference: function clearReference() {
             this.rootNode = null;
         },

         create: function create(data) {
             var actType,
                 pageType = data.pageType,
                 createWidgets = data.activitys,
                 chpaterData = data.chpaterData,
                 chapterId = data.chapterId,
                 pid = data.pid,
                 virtualOffset = data.virtualOffset,
                 widgetRetStr = [];

             function virtualCreate(actType, activityData) {
                 var scaleLeft = activityData.scaleLeft;
                 // 创建分布左边的对象
                 if (virtualOffset === 'left') {
                     if (scaleLeft < Xut.config.screenSize.width) {
                         startCreate(actType, activityData);
                     }
                 }
                 //创建分布右边的对象
                 if (virtualOffset === 'right') {
                     if (scaleLeft > Xut.config.screenSize.width) {
                         startCreate(actType, activityData);
                     }
                 }
             }

             //创建
             function startCreate(actType, activityData) {
                 //创建DOM元素结构
                 //返回是拼接字符串
                 widgetRetStr.push(Bind[actType]['createDom'](activityData, chpaterData, chapterId, pid, Xut.zIndexlevel(), pageType));
             }

             //需要创建的数据结构
             createWidgets.forEach(function (activityData, index) {

                 //创建类型
                 actType = activityData.actType || activityData.animation;

                 //特殊类型 showNote
                 if (!actType && activityData.note) {
                     activityData['actType'] = actType = "ShowNote";
                 }

                 switch (actType) {
                     case 'ShowNote':
                     case 'Action':
                     case 'Widget':
                     case 'Audio':
                     case 'Video':

                         //缩放比
                         activityData = reviseSize(activityData);

                         //处理虚拟模式创建
                         if (Xut.config.virtualMode) {
                             virtualCreate(actType, activityData);
                         } else {
                             startCreate(actType, activityData);
                         }
                         break;
                 }
             });

             return widgetRetStr.join("");
         },

         /**
          * 编译中断函数
          * @return {[type]} [description]
          */
         compileSuspend: function compileSuspend(str) {

             var nextTasks,
                 suspendTasks,
                 self = this;

             //继续执行
             nextTasks = function nextTasks() {
                 Xut.nextTick({
                     container: self.rootNode,
                     content: $(str)
                 }, function () {
                     self.clearReference();
                     self.callback.successCallback();
                 });
             };

             //中断方法
             suspendTasks = function suspendTasks() {
                 self.suspendQueues = [];
                 self.suspendQueues.push(function () {
                     nextTasks();
                 });
             };

             self.callback.suspendCallback(nextTasks, suspendTasks);
         },

         //运行被阻断的线程任务
         runSuspendTasks: function runSuspendTasks() {
             if (this.suspendQueues) {
                 var fn;
                 if (fn = this.suspendQueues.pop()) {
                     fn();
                 }
                 this.suspendQueues = null;
             }
         }
     };

     //更新数据缓存
     function updataCache(pid, callback) {
         var fn,
             base = this,
             pageType = base.pageType;

         //缓存数据
         function addCacheDas(namespace, data) {
             var key;
             if (!base.dataCache[namespace]) {
                 base.dataCache[namespace] = data;
             } else {
                 for (key in data) {
                     base.dataCache[namespace][key] = data[key];
                 }
             }
         }

         //增加数据缓存
         function addCache(data, activitys, autoRunDas) {
             addCacheDas(base.pageType, data); //挂载页面容器数据
             addCacheDas('activitys', activitys); //挂载activitys数据
             addCacheDas('autoRunDas', autoRunDas); //挂载自动运行数据
         }

         query(pageType, {
             'pageIndex': pid,
             'pageData': base.chapterDas,
             'pptMaster': base.pptMaster
         }, function (data, activitys, autoRunDas) {
             addCache.apply(addCache, arguments);
             callback(data);
         });
     }

     /**
      * 分配Container构建任务
      * 1 同步数据
      * 2 构建容器
      * 3 给出构建回调,这里不能中断,翻页必须存在节点
      * 4 等待之后自动创建或者后台空闲创建之后的任务
      * @return {[type]} [description]
      */
     var assignedTasks = {

         'Container': function Container(taskCallback, base) {
             //同步数据
             updataCache.call(base, [base.pid], function () {
                 var pageData = base.baseData();
                 if (pageData.parameter) {
                     // contentMode 分为  0 或者 1
                     // 1 是dom模式
                     // 0 是canvas模式
                     // 以后如果其余的在增加
                     // 针对页面chapter中的parameter写入 contentMode   值为 1
                     // 针对每一个content中的parameter写入 contentMode 值为 1
                     // 如果是canvas模式的时候，同时也是能够存在dom模式是
                     try {
                         var parameter = JSON.parse(pageData.parameter);
                         if (parameter && parameter.contentMode && parameter.contentMode == 1) {
                             //启动dom模式
                             base.canvasRelated.enable = true;
                         }
                     } catch (e) {
                         console.log('JSON错误,chpterId为', base.chapterId, pageData.parameter);
                     }
                 }

                 //创建主容器
                 TaskContainer({
                     'rootNode': base.root,
                     'prefix': base.pageType + "-" + (base.pageIndex + 1) + "-" + base.chapterId,
                     'pageType': base.pageType,
                     'pid': base.pid,
                     'baseData': pageData,
                     'virtualOffset': base.virtualOffset,
                     'initTransformParameter': base.createRelated.initTransformParameter,
                     'userStyle': base.userStyle //创建自定义style
                 }, taskCallback);
             });
         },

         /**
          *  分配背景构建任务
          *    1 构建数据与结构,执行中断检测
          *    2 绘制结构,执行回调
          *
          *  提供2组回调
          *    1 构建数据结构 suspendCallback
          *    2 执行innerhtml构建完毕 successCallback
          */
         'Background': function Background(taskCallback, base) {

             if (base.checkInstanceTasks('background')) {
                 return;
             }

             var data = base.baseData(base.pid),

             //构建中断回调
             suspendCallback = function suspendCallback(innerNextTasks, innerSuspendTasks) {
                 base.nextTasks({
                     'taskName': '内部background',
                     'outSuspendTasks': innerSuspendTasks,
                     'outNextTasks': innerNextTasks
                 });
             },

             //获取数据成功回调
             successCallback = function successCallback() {
                 taskCallback();
             };

             base.createRelated.cacheTasks['background'] = new TaskBackground(base.getElement(), data, suspendCallback, successCallback);
         },

         /**
          * 分配Components构建任务
          * @return {[type]} [description]
          */
         'Components': function Components(taskCallback, base) {

             if (base.checkInstanceTasks('components')) {
                 return;
             }

             var chapterDas = base.chapterDas,
                 baseData = base.baseData(),

             //构建中断回调
             suspendCallback = function suspendCallback(innerNextTasks, innerSuspendTasks) {
                 base.nextTasks({
                     'taskName': '内部widgets',
                     'outSuspendTasks': innerSuspendTasks,
                     'outNextTasks': innerNextTasks
                 });
             },

             //获取数据成功回调
             successCallback = function successCallback() {
                 taskCallback();
             };

             base.createRelated.cacheTasks['components'] = new TaskComponents({
                 'rootNode': base.getElement(),
                 'nodes': chapterDas['nodes'],
                 'pageOffset': chapterDas['pageOffset'],
                 'activitys': base.baseActivits(),
                 'chpaterData': baseData,
                 'chapterId': baseData['_id'],
                 'pid': base.pid,
                 'pageType': base.pageType,
                 'virtualOffset': base.virtualOffset
             }, suspendCallback, successCallback);
         },

         /**
          * 分配contetns构建任务
          * @return {[type]} [description]
          */
         'Contetns': function Contetns(taskCallback, base) {

             //通过content数据库为空处理
             if (Xut.data.preventContent) {
                 return taskCallback();
             }

             if (base.checkInstanceTasks('contents')) {
                 return;
             }

             var chapterDas = base.chapterDas,
                 baseData = base.baseData(),
                 chapterId = baseData['_id'],
                 activitys = base.baseActivits(),


             //生成钩子
             // collector                : function (pageIndex, id, contentScope) {
             // eventBinding             : function () { [native code] }
             // floatMaters              : function (masters){
             // registerAbstractActivity : function (pageIndex, type, contentsObjs) {
             // successCallback          : function () {
             // suspendCallback          : function (taskName, innerNextTasks, innerSuspendTasks) {
             pageBaseHooks = _.extend({}, {
                 //构建中断回调
                 suspend: function suspend(taskName, innerNextTasks, innerSuspendTasks) {
                     //如果是当前页面构建,允许打断一次
                     var interrupt;
                     if (base.isAutoRun && taskName === 'strAfter') {
                         interrupt = true;
                     }
                     base.nextTasks({
                         'interrupt': interrupt,
                         'taskName': '内部contents',
                         'outSuspendTasks': innerSuspendTasks,
                         'outNextTasks': innerNextTasks
                     });
                 },
                 //获取数据成功回调
                 success: function success() {
                     taskCallback();
                 }
             }, base.listenerHooks);

             base.createRelated.cacheTasks['contents'] = new TaskContents({
                 'canvasRelated': base.canvasRelated,
                 'rootNode': base.root,
                 'element': base.getElement(),
                 'pageType': base.pageType,
                 'nodes': chapterDas['nodes'],
                 'pageOffset': chapterDas['pageOffset'],
                 'activitys': activitys,
                 'chpaterData': baseData,
                 'chapterId': chapterId,
                 'pageIndex': base.pageIndex,
                 'pid': base.pid,
                 'pageBaseHooks': pageBaseHooks,
                 'virtualOffset': base.virtualOffset,
                 'initTransformParameter': base.createRelated.initTransformParameter
             });
         }
     };

     /**
      * canvas相关处理
      * 启动canvas,pixi库
      * 事件，动画等
      * 需要收集所有content的执行
      * 因为canvas只能绘制一次
      * cnavas模式下 category === "Sprite" 转化cid
      */

     var Factory$1 = function Factory() {

         /**
          * 是否启动模式
          * @type {Boolean}
          */
         this.enable = false;

         /**
          * 加载失败content列表
          * @type {Array}
          */
         this.failCid = [];

         //所有contentId
         this.cid = [];

         //开启了contentMode的节点
         //对应的content转化成canvas模式
         //普通精灵动画
         //ppt动画=>转化
         this.pptId = [];

         //普通灵精
         this.spiritId = [];

         //widget零件保存的content id
         //高级精灵动画
         this.widgetId = [];

         /**
          * cid=>wid
          * 对应的pixi对象容器
          * @type {Object}
          */
         this.collections = {};
     };

     observe.call(Factory$1.prototype);

     function PageBase() {};
     var baseProto = PageBase.prototype;

     /********************************************************************
      *
      *                    多线程创建管理
      *
      ********************************************************************/

     /**
      * 初始化多线程任务
      * @return {[type]} [description]
      */
     baseProto.initTasks = function (options) {

         var self = this;

         _.extend(self, options);

         /**
          * 数据缓存容器
          * @type {Object}
          */
         this.dataCache = {};
         this.scenarioId = this.chapterDas.seasonId;
         this.chapterId = this.chapterDas._id;

         /**
          * 是否开启多线程,默认开启
          * 如果是非线性，则关闭多线程创建
          * 启动 true
          * 关闭 false
          * @type {[type]}
          */
         this.isMultithread = this.multiplePages ? true : false;

         //母版处理
         if (self.pageType === 'master') {
             this.isMaster = true;
         }

         /**
          * canvas模式
          * @type {Boolean}
          */
         this.canvasRelated = new Factory$1();

         /**
          * 创建相关的信息
          * @type {Object}
          */
         var createRelated = this.createRelated = {

             /**
              * 主线任务等待
              */
             tasksHang: null,

             /**
              * 创建相关的信息
              * @type {Object}
              */
             tasksTimer: 0,

             /**
              * 当前任务是否中断
              * return
              *     true  中断
              *     false 没有中断
              */
             isTaskSuspend: false,

             /**
              * 是否预创建背景中
              */
             preCreateTasks: false,

             /**
              * 下一个将要运行的任务标示
              * 1 主容器任务
              * 2 背景任务
              * 3 widget热点任务
              * 4 content对象任务
              */
             nextRunTask: 'container',

             /**
              * 缓存构建中断回调
              * 构建分2步骤
              * 1 构建数据与结构（执行中断处理）
              * 2 构建绘制页面
              * @type {Object}
              */
             cacheTasks: function () {
                 var cacheTasks = {};
                 _.each(["background", "components", "contents"], function (taskName) {
                     cacheTasks[taskName] = false;
                 });
                 return cacheTasks;
             }(),

             /**
              * 与创建相关的信息
              * 创建坐标
              * 1 创建li位置
              * 2 创建浮动对象
              * "translate3d(0px, 0, 0)", "original"
              */
             initTransformParameter: createTransform(this.visiblePid, this.pid),

             /**
              * 预创建
              * 构建页面主容器完毕后,此时可以翻页
              * @return {[type]} [description]
              */
             preforkComplete: function preforkComplete() {},

             /**
              * 整个页面都构建完毕通知
              * @return {[type]} [description]
              */
             createTasksComplete: function createTasksComplete() {}
         };

         //==================内部钩子相关===========================
         //
         // * 监听状态的钩子
         // * 注册所有content对象管理
         // * 收集所有content对象
         // * 构建li主结构后,即可翻页
         // * 构建所有对象完毕后处理
         //

         //抽象activtiys合集,用于关联各自的content
         //划分各自的子作用域
         //1对多的关系
         this.abActivitys = new Collection();

         //widget热点处理类
         //1 iframe零件
         //2 页面零件
         //只存在当前页面
         this.components = new Collection();

         /**
          * 缓存所有的content对象引用
          * 1对1的关系
          * @type {Object}
          */
         this.contentsCollector = {};

         /**
          * 浮动对象
          * 1 母版中
          * 2 页面中
          * 页面中是最高的
          * [floatContents description]
          * @type {Object}
          */
         var floatContents = this.floatContents = {

             /**
              * 页面浮动对象容器
              * @type {[type]}
              */
             PageContainer: null,

             /**
              * 浮动页面对象
              * @type {Object}
              */
             Page: {},

             /**
              * 浮动母版容器
              */
             MasterContainer: null,

             /**
              * 浮动母版的content对象
              * 用于边界切换,自动加上移动
              * @type {Object}
              *     1：Object {}      //空对象,零件
              *     2: PPTeffect  {}  //行为对象
              */
             Master: {}
         };

         /**
          * 对象的处理情况的内部钩子方法
          * @type {Object}
          */
         this.listenerHooks = {

             //注册抽象Activity类content(大类,总content对象)
             registerAbstractActivity: function registerAbstractActivity(contentsObjs) {
                 self.abActivitys.register(contentsObjs);
             },

             //收集器
             collector: {
                 //搜集所有的content(每一个content对象)
                 //因为content多页面共享的,所以content的合集需要保存在pageMgr中（特殊处理）
                 contents: function contents(pid, id, contentScope) {
                     var scope = self.baseGetContentObject[id];
                     //特殊处理,如果注册了事件ID,上面还有动画,需要覆盖
                     if (scope && scope.isBindEventHooks) {
                         self.contentsCollector[id] = contentScope;
                     }
                     if (!scope) {
                         self.contentsCollector[id] = contentScope;
                     }
                 },

                 //2014.11.7
                 //新概念，浮动页面对象
                 //用于是最顶层的，比母版浮动对象还要高
                 //所以这个浮动对象需要跟随页面动
                 floatPages: function floatPages(data) {
                     var contentObj;
                     //浮动页面对象容器
                     floatContents.PageContainer = data.container;
                     _.each(data.ids, function (id) {
                         if (contentObj = self.baseGetContentObject(id)) {
                             //初始视察坐标
                             if (contentObj.parallax) {
                                 contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
                             }
                             floatContents.Page[id] = contentObj;
                         } else {
                             console.log('页面浮动对象找不到');
                         }
                     });
                 },

                 //浮动母版对象
                 //1 浮动的对象是有动画数据或者视觉差数据
                 //2 浮动的对象是用于零件类型,这边只提供创建
                 //  所以需要制造一个空的容器，用于母版交界动
                 floatMaters: function floatMaters(data) {
                     var prefix, contentObj, contentProcess, contentsFragment;
                     //浮动容器
                     floatContents.MasterContainer = data.container;
                     //浮动对象
                     _.each(data.ids, function (id) {
                         //转化成实际操作的浮动对象,保存
                         if (contentObj = self.baseGetContentObject(id)) {
                             //初始视察坐标
                             if (contentObj.parallax) {
                                 contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
                             }
                             floatContents.Master[id] = contentObj;
                         } else {
                             Xut.plat.isBrowser && console.log('浮动母版对象数据不存在原始对象,制作伪对象母版移动', id);
                             //获取DOM节点
                             if (contentsFragment = self.createRelated.cacheTasks.contents.contentsFragment) {
                                 prefix = 'Content_' + self.pid + "_";
                                 _.each(contentsFragment, function (dom) {
                                     makePrefix = prefix + id;
                                     if (dom.id == makePrefix) {
                                         contentProcess = dom;
                                     }
                                 });
                             }
                             //制作一个伪数据
                             //作为零件类型的空content处理
                             floatContents.Master[id] = {
                                 id: id,
                                 pid: self.pid,
                                 $contentProcess: $(contentProcess),
                                 'empty': true //空类型
                             };
                         }
                     });
                 }
             },

             //多事件钩子
             //执行多事件绑定
             eventBinding: function eventBinding(eventRelated) {
                 create(self, eventRelated);
             }
         };

         /**
          * 设置下一个标记
          */
         function setNextRunTask(taskName) {
             createRelated.nextRunTask = taskName;
         }

         function callContext(taskName, fn) {
             return assignedTasks[taskName](fn, self);
         }

         /**
          * 任务钩子
          * @type {Object}
          */
         self.tasks = {
             container: function container() {
                 callContext('Container', function (element, pseudoElement) {
                     //////////////
                     //li,li-div //
                     //////////////
                     self.element = element;
                     self.pseudoElement = pseudoElement;
                     //获取根节点
                     self.getElement = function () {
                         return pseudoElement ? pseudoElement : element;
                     };

                     setNextRunTask('background');
                     //构建主容器li完毕,可以提前执行翻页动作
                     createRelated.preforkComplete();
                     //视觉差不管
                     if (self.isMaster) {
                         self.nextTasks({
                             'taskName': '外部background',
                             'outNextTasks': function outNextTasks() {
                                 self.dispatchTasks();
                             }
                         });
                     }
                 });
             },
             background: function background() {
                 var nextRun = function nextRun() {
                     createRelated.preCreateTasks = false;
                     setNextRunTask('components');
                     //针对当前页面的检测
                     if (!createRelated.tasksHang || self.isMaster) {
                         self.nextTasks({
                             'taskName': '外部widgets',
                             outNextTasks: function outNextTasks() {
                                 self.dispatchTasks();
                             }
                         });
                     }

                     //如果有挂起任务，则继续执行
                     if (createRelated.tasksHang) {
                         createRelated.tasksHang();
                     }
                 };

                 callContext('Background', nextRun);
             },
             components: function components() {
                 //构件零件类型任务
                 callContext('Components', function () {
                     setNextRunTask('contents');
                     self.nextTasks({
                         'taskName': '外部contents',
                         outNextTasks: function outNextTasks() {
                             self.dispatchTasks();
                         }
                     });
                 });
             },
             contents: function contents() {
                 callContext('Contetns', function () {
                     setNextRunTask('complete');
                     createRelated.createTasksComplete();
                 });
             }
         };
     };

     /****************************************************************
      *
      *                     对外接口
      *
      *               1 开始调用任务
      *               2 调用自动运行任务
      *               3 设置中断
      *               4 取消中断设置
      *
      * **************************************************************/

     /**
      * 开始调用任务
      * @return {[type]} [description]
      */
     baseProto.startThreadTask = function (flipOver, callback) {

         //制作回调
         //如果是快速翻页,立刻调用
         this.createRelated.preforkComplete = function (context) {
             return function () {
                 //滑动允许打断创建
                 flipOver ? callback() :
                 //所有继续分解任务
                 context.checkTasksCreate(function () {
                     callback();
                 });
             };
         }(this);

         //继续构建任务
         this.dispatchTasks();
     };

     /**
      * 检测任务是否完成
      * actTasksCallback 活动任务完成
      * @return {[type]} [description]
      */
     baseProto.checkThreadTask = function (actTasksCallback) {
         var self = this;
         this.isAutoRun = true;
         this.checkTasksCreate(function () {
             self.isAutoRun = false;
             actTasksCallback();
         });
     };

     /**
      * 后台预创建任务
      * @param  {[type]} tasksTimer [时间间隔]
      * @return {[type]}            [description]
      */
     baseProto.createPreforkTasks = function (callback, isPreCreate) {
         var self = this;
         //2个预创建间隔太短
         //背景预创建还在进行中，先挂起来等待
         if (this.createRelated.preCreateTasks) {
             this.createRelated.tasksHang = function (callback) {
                 return function () {
                     self.checkTasksCreate(callback);
                 };
             }(callback);
             return;
         }

         /**
          * 翻页完毕后
          * 预创建背景
          */
         if (isPreCreate) {
             this.createRelated.preCreateTasks = true;
         }

         this.checkTasksCreate(callback);
     };

     /**
      * 自动运行：检测是否需要开始创建任务
      * 1 如果任务全部完成了毕
      * 2 如果有中断任务,就需要继续创建未完成的任务
      * 3 如果任务未中断,还在继续创建
      * currtask 是否为当前任务，加速创建
      */
     baseProto.checkTasksCreate = function (callback, context) {

         //如果任务全部完成
         if (this.createRelated.nextRunTask === 'complete') {
             return callback.call(context);
         }

         var self = this;

         //开始构未完成的任务
         this.cancelTaskSuspend();

         //完毕回调
         this.createRelated.createTasksComplete = function () {
             callback.call(context);
         };

         //派发任务
         this.nextTasks({
             outNextTasks: function outNextTasks() {
                 self.dispatchTasks();
             }
         });
     };

     /**
      * 设置任务中断
      */
     baseProto.setTaskSuspend = function () {
         this.isAutoRun = false;
         this.canvasRelated.isTaskSuspend = true;
         this.createRelated.preCreateTasks = false;
         this.createRelated.tasksHang = null;
     };

     /**
      * 取消任务中断
      * @return {[type]} [description]
      */
     baseProto.cancelTaskSuspend = function () {
         this.canvasRelated.isTaskSuspend = false;
     };

     /**
      * 检测任务是否需要中断
      * @return {[type]} [description]
      */
     baseProto.checkTaskSuspend = function () {
         return this.canvasRelated.isTaskSuspend;
     };

     /**
      * 多线程检测
      * @return {[type]} [description]
      */
     baseProto.multithreadCheck = function (callbacks, interrupt) {
         //多线程检测
         var self = this;

         function check() {
             if (self.checkTaskSuspend()) {
                 self.tasksTimeOutId && clearTimeout(self.tasksTimeOutId);
                 callbacks.suspendCallback.call(self);
             } else {
                 callbacks.nextTaskCallback.call(self);
             }
         }

         function next() {
             self.tasksTimeOutId = setTimeout(function () {
                 check();
             }, self.canvasRelated.tasksTimer);
         }

         //自动运行页面构建
         if (self.isAutoRun) {
             //自动运行content中断检测 打断一次
             if (interrupt) {
                 next();
             } else {
                 check();
             }
         } else {
             //后台构建
             next();
         }
     };

     /**
      * 任务队列挂起
      * nextTaskCallback 成功回调
      * suspendCallback  中断回调
      * @return {[type]} [description]
      */
     baseProto.asyTasks = function (callbacks, interrupt) {

         //如果关闭多线程,不检测任务调度
         if (!this.isMultithread) {
             return callbacks.nextTaskCallback.call(this);
         }

         //多线程检测
         this.multithreadCheck(callbacks, interrupt);
     };

     /**
      * 开始执行下一个线程任务,检测是否中断
      * outSuspendTasks,
      * outNextTasks
      * taskName
      * @return {[type]} [description]
      */
     baseProto.nextTasks = function (callback) {
         var outSuspendTasks, outNextTasks, taskName;

         this.asyTasks({
             suspendCallback: function suspendCallback() {
                 // console.log('@@@@@@@@@@中断创建任务 ' + callback.taskName + ' @@@@@@@@@@@', this.pid + 1, this.element)
                 if (outSuspendTasks = callback.outSuspendTasks) {
                     outSuspendTasks();
                 }
             },
             nextTaskCallback: function nextTaskCallback() {
                 if (outNextTasks = callback.outNextTasks) {
                     outNextTasks();
                 }
             }
         }, callback.interrupt);
     };

     /**
      * 任务调度
      * @return {[type]} [description]
      */
     baseProto.dispatchTasks = function () {
         var tasks;
         if (tasks = this.tasks[this.createRelated.nextRunTask]) {
             tasks();
         }
     };

     //========================构建模块任务对象=========================
     //
     //  taskCallback 每个模块任务完毕后的回调
     //  用于继续往下个任务构建
     //
     //==================================================================

     /**
      * 对象实例内部构建
      * @return {[type]} [description]
      */
     baseProto.checkInstanceTasks = function (taskName) {
         var tasksObj;
         if (tasksObj = this.createRelated.cacheTasks[taskName]) {
             tasksObj.runSuspendTasks();
             return true;
         }
     };

     //获取页面数据
     baseProto.baseData = function () {
         return this.dataCache[this.pageType];
     };

     //获取热点数据信息
     baseProto.baseActivits = function () {
         return this.dataCache['activitys'];
     };

     //获取自动运行数据
     baseProto.baseAutoRun = function () {
         var autoRunDas = this.dataCache['autoRunDas'];
         return autoRunDas && autoRunDas;
     };

     //获取chapterid
     baseProto.baseGetPageId = function (pid) {
         return this.baseData(pid)['_id'];
     };

     /**
      * 找到对象的content对象
      * @param  {[type]}   contentId [description]
      * @param  {Function} callback  [description]
      * @return {[type]}             [description]
      */
     baseProto.baseGetContentObject = function (contentId) {
         var contentsObj;
         if (contentsObj = this.contentsCollector[contentId]) {
             return contentsObj;
         } else {
             //查找浮动母版
             return this.floatContents.Master[contentId];
         }
     };

     /**
      * Xut.Content.show/hide 针对互斥效果增加接口
      * 扩充，显示，隐藏，动画控制接口
      * @param  {[type]} name [description]
      * @return {[type]}      [description]
      */
     baseProto.baseContentMutex = function (contentId, type) {
         var contentObj,
             base = this;
         if (contentObj = base.baseGetContentObject(contentId)) {
             var context = contentObj.$contentProcess;
             var handle = {
                 'Show': function Show() {
                     if (contentObj.type === 'dom') {
                         context.css({
                             'display': 'blcok',
                             'visibility': 'visible'
                         }).prop("mutex", false);
                     } else {
                         context.visible = true;
                         console.log('show');
                         base.canvasRelated.oneRender();
                     }
                 },
                 'Hide': function Hide() {
                     if (contentObj.type === 'dom') {
                         context.css({
                             'display': 'none',
                             'visibility': 'hidden'
                         }).prop("mutex", true);
                     } else {
                         console.log('hide');
                         context.visible = false;
                         base.canvasRelated.oneRender();
                     }
                 },
                 'StopAnim': function StopAnim() {
                     contentObj.stopAnims && contentObj.stopAnims();
                 }
             };
             handle[type]();
         }
     };

     //content接口
     _.each(["Get", "Specified"], function (type) {
         baseProto['base' + type + 'Content'] = function (data) {
             switch (type) {
                 case 'Get':
                     return this.abActivitys.get();
                 case 'Specified':
                     return this.abActivitys.specified(data);
             }
         };
     });

     //components零件类型处理
     //baseGetComponent
     //baseRemoveComponent
     //baseRegisterComponent
     //baseSpecifiedComponent
     _.each(["Get", "Remove", "Register", "Specified"], function (type) {
         baseProto['base' + type + 'Component'] = function (data) {
             switch (type) {
                 case 'Register':
                     return this.components.register(data);
                 case 'Get':
                     return this.components.get();
                 case 'Specified':
                     return this.components.specified(data);
                 case 'Remove':
                     return this.components.remove();
             }
         };
     });

     //***************************************************************
     //
     //               运行辅助对象事件
     //
     //***************************************************************
     baseProto.baseAssistRun = function (activityId, outCallBack, actionName) {
         var activity;
         if (activity = this.abActivitys) {
             _.each(activity.get(), function (contentObj, index) {
                 if (activityId == contentObj.activityId) {
                     if (actionName == 'Run') {
                         contentObj.runEffects(outCallBack, true);
                     }
                     if (actionName == 'Stop') {
                         contentObj.stopEffects(outCallBack);
                     }
                 }
             }, this);
         }
     };

     //销毁页面对象
     baseProto.baseDestroy = function () {

         //清理图片缓存
         //读库快速退出模式下报错修正
         try {
             this.element.hide().find('img').each(function (aaa, img) {
                 img.src = 'images/icons/clearmem.png';
             });
         } catch (e) {}

         //清理线程任务块
         var cacheTasks, key, tasks;
         if (cacheTasks = this.createRelated.cacheTasks) {
             for (key in cacheTasks) {
                 if (tasks = cacheTasks[key]) {
                     tasks.clearReference();
                 }
             }
         }

         //浮动对象
         var floatMaterContents = this.floatContents.Master;
         //是否有浮动对象
         var hasFloatMater = !_.isEmpty(floatMaterContents);

         //清理content类型对象
         var contents;
         if (contents = this.abActivitys.get()) {
             contents.forEach(function (contentObj) {
                 contentObj.destroy(function (destroyObj) {
                     //如果不是浮动对象,清理元素引用
                     if (!hasFloatMater || destroyObj && !floatMaterContents[destroyObj.id]) {
                         destroyObj.$contentProcess = null;
                     }
                 });
             });
         }

         //清除母版浮动容器
         if (hasFloatMater && this.floatContents.MasterContainer) {
             this.floatContents.MasterContainer.remove();
         }

         //清除浮动页面对象
         if (this.floatContents.Page && this.floatContents.PageContainer) {
             this.floatContents.PageContainer.remove();
         }

         //清理零件类型对象
         var components;
         if (components = this.baseGetComponent()) {
             components.length && components.forEach(function (componentObj) {
                 componentObj.destroy && componentObj.destroy();
             });
         }

         //多事件销毁
         destroy$2(this);

         //销毁canvas相关
         if (this.canvasRelated && this.canvasRelated.destroy) {
             this.canvasRelated.destroy();
         }

         //伪li节点
         if (this.pseudoElement) {
             this.pseudoElement = null;
         }

         //移除li容器节点节点
         this.element.remove();
         this.root = null;
         this.element = null;
     };

     var Master = Xut.extend(PageBase, {
     	constructor: function constructor(options) {
     		//多线程处理
     		this.initTasks(options);
     		return this;
     	}
     });

     /**
      * 利用canvas绘制出蒙板效果替换，需要蒙板效果的图片先用一个canvas占位，绘制是异步的
      */

     function _getCanvas(className) {
         var children = document.getElementsByTagName('canvas'),
             elements = new Array(),
             i = 0,
             child,
             classNames,
             j = 0;
         for (i = 0; i < children.length; i++) {
             child = children[i];
             classNames = child.className.split(' ');
             for (var j = 0; j < classNames.length; j++) {
                 if (classNames[j] == className) {
                     elements.push(child);
                     break;
                 }
             }
         }
         return elements;
     }

     function _addEdge(canvas) {

         var img = new Image(),
             maskimg = new Image();
         classNames = canvas.className.split(' ');
         var context = canvas.getContext("2d");
         img.addEventListener("load", loadimg);
         maskimg.addEventListener("load", loadmask);

         function loadimg() {
             context.clearRect(0, 0, canvas.width, canvas.height);
             context.globalCompositeOperation = "source-over";
             context.drawImage(img, 0, 0, canvas.width, canvas.height);
             maskimg.src = canvas.getAttribute("mask");
             img.removeEventListener("load", loadimg);
             img.src = null;
             img = null;
         }

         function loadmask() {
             context.globalCompositeOperation = "destination-atop";
             context.drawImage(maskimg, 0, 0, canvas.width, canvas.height);
             canvas.style.opacity = 1;
             maskimg.removeEventListener("load", loadmask);
             maskimg.src = null;
             maskimg = null;
             context = null;
             classNames = null;
             canvas.className = canvas.className.replace("edges", "");
         }
         img.src = canvas.getAttribute("src");
     }

     function addEdges() {
         var thecanvas = _getCanvas('edges'),
             i;
         for (i = 0; i < thecanvas.length; i++) {
             _addEdge(thecanvas[i]);
         }
     }

     function PageMgr(vm) {

         this.pageType = 'page';

         /**
          * 页面根节点
          * @type {[type]}
          */
         this.rootNode = vm.options.rootPage;

         /**
          * 抽象方法
          * 创建合集容器
          */
         this.abstractCreateCollection();
     };

     var PageMgrProto = PageMgr.prototype;

     /****************************************************************
      *
      *                 对外接口
      *
      ***************************************************************/

     //====================页面结构处理===========================

     //创建页新的页面
     PageMgrProto.create = function (dataOpts, pageIndex) {

         //生成指定页面对象
         var pageObjs = new Master(_.extend(dataOpts, {
             'pageType': this.pageType, //创建页面的类型
             'root': this.rootNode //根元素
         }));

         //增加页面管理
         this.abstractAddCollection(pageIndex, pageObjs);

         return pageObjs;
     };

     /**
      * 清理视频
      * @return {[type]} [description]
      */
     function removeVideo(clearPageIndex) {
         //处理视频
         var pageId = Xut.Presentation.GetPageId(clearPageIndex);
         Xut.VideoManager.removeVideo(pageId);
     }

     //清理其中的一个页面
     PageMgrProto.clearPage = function (clearPageIndex) {
         var pageObj;
         //清理视频
         // removeVideo(clearPageIndex);
         //销毁页面对象事件
         if (pageObj = this.abstractGetPageObj(clearPageIndex)) {
             //移除事件
             pageObj.baseDestroy();
             //移除列表
             this.abstractRemoveCollection(clearPageIndex);
         }
     };

     //销毁整个页面管理对象
     PageMgrProto.destroy = function () {
         //清理视频
         removeVideo(Xut.Presentation.GetPageIndex());
         //清理对象
         this.abstractDestroyCollection();
         //清理节点
         this.rootNode = null;
     };

     /**
      * 检测脚本注入
      * @return {[type]} [description]
      */
     function checkInjectScript$1(pageObject, type) {
         var code;
         if (code = pageObject.chapterDas[type]) {
             injectScript(code, type);
         }
     }

     /****************************************************************
      *
      *                 多线程任务片段调用
      *
      ***************************************************************/

     /**
      * 设置中断正在创建的页面对象任务
      * @param {[type]}   currIndex [description]
      * @param {Function} callback  [description]
      */
     PageMgrProto.suspendInnerCreateTasks = function (pointers) {
         var pageObj,
             self = this;
         [pointers.leftIndex, pointers.currIndex, pointers.rightIndex].forEach(function (pointer) {
             if (pageObj = self.abstractGetPageObj(pointer)) {
                 pageObj.setTaskSuspend();
             }
         });
     };

     /**
      * 检测活动窗口任务
      * @return {[type]} [description]
      */
     PageMgrProto.checkTaskCompleted = function (currIndex, callback) {
         var currPageObj,
             self = this;
         // console.log('激活活动任务',currIndex)
         if (currPageObj = self.abstractGetPageObj(currIndex)) {
             currPageObj.checkThreadTask(function () {
                 // console.log('11111111111当前页面创建完毕',currIndex+1)
                 callback(currPageObj);
             });
         }
     };

     /**
      * 检测后台预创建任务
      * @return {[type]} [description]
      */
     PageMgrProto.checkPreforkTasks = function (resumePointer, preCreateTask) {
         var resumeObj, resumeCount;
         if (!resumePointer.length) {
             resumePointer = [resumePointer];
         }
         resumeCount = resumePointer.length;
         while (resumeCount--) {
             if (resumeObj = this.abstractGetPageObj(resumePointer[resumeCount])) {
                 resumeObj.createPreforkTasks(function () {
                     // console.log('后台处理完毕')
                 }, preCreateTask);
             }
         }
     };

     /************************************************************
      *
      *                       页面滑动
      *
      * **********************************************************/
     PageMgrProto.move = function (leftIndex, currIndex, rightIndex, direction, speed, action, moveDistance) {

         //////////////
         //找到需要滑动的页面 //
         //////////////
         function findPage() {
             return [this.abstractGetPageObj(leftIndex), this.abstractGetPageObj(currIndex), this.abstractGetPageObj(rightIndex)];
         }

         ///////////
         //开始移动页面 //
         ///////////
         _.each(findPage.call(this), function (pageObj, index) {
             if (pageObj) {
                 //移动浮动页面容器
                 var flaotElement;
                 if (flaotElement = pageObj.floatContents.PageContainer) {
                     translation[action].call(pageObj, moveDistance[index], speed, flaotElement);
                 }
                 //正常页面
                 translation[action].call(pageObj, moveDistance[index], speed);
             }
         });
     };

     /****************************************************************
      *
      *                  流程状态控制
      *
      ***************************************************************/

     /**
      * 触屏翻页开始
      * 1 中断所有任务
      * 2 停止热点对象运行
      *     停止动画,视频音频等等
      */
     PageMgrProto.suspend = function (pointers) {
         var stopPointer = pointers.stopPointer,
             suspendPageObj = this.abstractGetPageObj(stopPointer),
             prveChpterId = suspendPageObj.baseGetPageId(stopPointer);

         //翻页结束脚本
         checkInjectScript$1(suspendPageObj, 'postCode');

         //中断节点创建任务
         this.suspendInnerCreateTasks(pointers);

         //停止活动对象活动
         _suspend(suspendPageObj, prveChpterId);
     };

     /**
      * 复位初始状态
      * @return {[type]} [description]
      */
     PageMgrProto.resetOriginal = function (pageIndex) {
         var originalPageObj, flaotElement;
         if (originalPageObj = this.abstractGetPageObj(pageIndex)) {
             if (flaotElement = originalPageObj.floatContents.PageContainer) {
                 //floatPages设置的content溢出后处理
                 //在非视区增加overflow:hidden
                 //可视区域overflow:''
                 flaotElement.css({
                     'zIndex': 2000,
                     'overflow': 'hidden'
                 });
             }
             _original(originalPageObj);
         }
     };

     /**
      * 触屏翻页完成
      * 1 停止热点动作
      * 2 触发新的页面动作
      * @param  {[type]} prevPageIndex [上一页面]
      * @param  {[type]} currPageIndex [当前页码]
      * @param  {[type]} nextPageIndex [下一页页码]
      * @param  {[type]} suspendIndex  [停止动作的页码]因为要区分滑动的方向
      * @param  {[type]} createPointer [正在创建的页面]
      * @param  {[type]} direction     [滑动方向]
      */
     PageMgrProto.autoRun = function (data) {

         var self = this;

         //检测当前页面构建任务的情况
         //如果任务没有完成，则等待任务完成
         this.checkTaskCompleted(data.currIndex, function (currPageObj) {

             //提升当前页面浮动对象的层级
             //因为浮动对象可以是并联的
             var flaotElement;
             if (flaotElement = currPageObj.floatContents.PageContainer) {
                 flaotElement.css({
                     'zIndex': 2001,
                     'overflow': ''
                 });
             }

             //IE上不支持蒙版效果的处理
             if (Xut.plat.noMaskBoxImage) {
                 addEdges();
             }

             //构件完成通知
             data.buildComplete(currPageObj.scenarioId);

             //执行自动动作之前的脚本
             checkInjectScript$1(currPageObj, 'preCode');

             //热点状态复位
             self.resetOriginal(data.suspendIndex);

             //预构建背景
             preCreate('background');

             //等待动画结束后构建
             startAutoRun(currPageObj, data);
         });

         /**
          * 预执行背景创建
          * 支持多线程快速翻页
          * 1 初始化,或者快速翻页补全前后页面
          * 2 正常翻页创建前后
          */
         function preCreate(preCreateTask) {
             var resumePointer;
             if (data.isQuickTurn || !data.direction) {
                 resumePointer = [data.prevIndex, data.nextIndex];
             } else {
                 resumePointer = data.createPointer || data.nextIndex || data.prevIndex;
             }
             self.checkPreforkTasks(resumePointer, preCreateTask);
         };

         //激活自动运行对象
         function startAutoRun(currPageObj, data) {

             //结束通知
             function complete() {
                 data.processComplete();
                 preCreate();
             }

             //如果页面容器存在,才处理自动运行
             var currRootNode = currPageObj.element;
             if (!currRootNode) {
                 return complete();
             }

             //运行动作
             function startRun() {
                 _autoRun(currPageObj, data.currIndex, complete);
             }

             //运行如果被中断,则等待
             if (data.suspendCallback) {
                 data.suspendCallback(startRun);
             } else {
                 startRun();
             }
         }
     };

     //混入抽象接口方法
     extend(PageMgr, Abstract);

     var prefix$5 = Xut.plat.prefixStyle;
     var rword = "-";

     /**
      * parallaObjsCollection: Object
      *  	0: Page
      *	    1: Page
      *
      *	recordMasterId: Object
      *		0: 9001
      *	 	1: 9001
      *
      *	recordMasterscope: Object
      *		9001: Array[2]
      *
      *	rootNode: ul # parallax.xut - parallax xut - flip
      *
      *	currMasterId: 9001 //实际的可使区
      */

     function MasterMgr(vm) {

         var config = Xut.config;

         this.screenWidth = config.screenSize.width;
         this.screenHeight = config.screenSize.height;

         this.pageType = 'master';

         this.rootNode = vm.options.rootMaster;
         this.recordMasterscope = {}; //记录master区域范围
         this.recordMasterId = {}; //记录页面与母板对应的编号
         this.currMasterId = null; //可视区母板编号

         //记录视察处理的对象
         this.parallaxProcessedContetns = {};

         /**
          * 抽象方法
          * 创建视觉差容器
          */
         this.abstractCreateCollection();
     }

     var MasterProto = MasterMgr.prototype;

     /****************************************************************
      *
      *                 对外接口
      *
      ***************************************************************/

     //====================页面结构处理===========================

     MasterProto.create = function (dataOpts, pageIndex, createCallBack) {
         var masterObj,
             reuseMasterId,
             reuseMasterKey,
             pptMaster = dataOpts.chapterDas.pptMaster,
             pageOffset = dataOpts.chapterDas.pageOffset;

         //母板复用的标示
         reuseMasterId = pageOffset && pageOffset.split(rword);

         //组合下标
         if (reuseMasterId && reuseMasterId.length === 3) {
             reuseMasterKey = pptMaster + rword + reuseMasterId[2];
         } else {
             reuseMasterKey = pptMaster;
         }

         //检测视觉差对象是否重复创建
         if (this._checkRepeat(reuseMasterKey, pageOffset, pageIndex)) {
             return;
         }

         //通知外部,需要创建的母版
         createCallBack();

         masterObj = new Master(_.extend(dataOpts, {
             'pageType': this.pageType, //创建页面的类型
             'root': this.rootNode, //根元素
             'pptMaster': pptMaster //ppt母板ID
         }));

         //增加页面管理
         this.abstractAddCollection(reuseMasterKey, masterObj);

         return masterObj;
     };

     //销毁整个页面对象
     MasterProto.destroy = function () {
         this.rootNode = null;
         //销毁对象
         this.abstractDestroyCollection();
     };

     /**
      * 找到当前页面的可以需要滑动是视觉页面对象
      * @return {[type]}            [description]
      */
     MasterProto.findMaster = function (leftIndex, currIndex, rightIndex, direction, action) {
         var prevFlag,
             nextFlag,
             prevMasterObj,
             currMasterObj,
             nextMasterObj,
             prevMasterId = this.conversionMasterId(leftIndex),
             currMasterId = this.conversionMasterId(currIndex),
             nextMasterId = this.conversionMasterId(rightIndex);

         switch (direction) {
             case 'prev':
                 if (prevFlag = currMasterId !== prevMasterId) {
                     currMasterObj = this.abstractGetPageObj(currMasterId);
                 }
                 if (prevMasterId && prevFlag) {
                     action === 'flipOver' && this.checkClear([currMasterId, prevMasterId]); //边界清理
                     prevMasterObj = this.abstractGetPageObj(prevMasterId);
                 }
                 break;
             case 'next':
                 if (nextFlag = currMasterId !== nextMasterId) {
                     currMasterObj = this.abstractGetPageObj(currMasterId);
                 }
                 if (nextMasterId && nextFlag) {
                     action === 'flipOver' && this.checkClear([currMasterId, nextMasterId]); //边界清理
                     nextMasterObj = this.abstractGetPageObj(nextMasterId);
                 }
                 break;
         }
         return [prevMasterObj, currMasterObj, nextMasterObj];
     };

     /**
      * 页面滑动处理
      * 1 母版之间的切换
      * 2 浮动对象的切换
      */
     MasterProto.move = function (leftIndex, currIndex, rightIndex, direction, moveDistance, action, speed, nodes) {
         var parallaxOffset,
             self = this,
             isBoundary = false; //是边界处理

         //找到需要滑动的母版
         _.each(this.findMaster(leftIndex, currIndex, rightIndex, direction, action), function (pageObj, index) {
             if (pageObj) {
                 isBoundary = true;
                 //母版交接判断
                 //用户事件的触发
                 pageObj.onceMaster = false;
                 //移动母版
                 translation[action].call(pageObj, moveDistance[index], speed);
                 //移动浮动容器
                 if (pageObj.floatContents.MasterContainer) {
                     translation[action].call(pageObj, moveDistance[index], speed, pageObj.floatContents.MasterContainer);
                 }
             }
         });

         //越界不需要处理内部视察对象
         this.isBoundary = isBoundary;
         if (isBoundary) {
             return;
         }

         //移动视察对象
         function moveParallaxObject(nodes) {
             self.moveParallaxs(moveDistance, currIndex, action, direction, speed, nodes);
         }

         //移动视察对象
         switch (direction) {
             case 'prev':
                 moveParallaxObject();
                 break;
             case 'next':
                 nodes && moveParallaxObject(nodes);
                 break;
         }
     };

     /**
      * 停止行为
      * @return {[type]} [description]
      */
     MasterProto.suspend = function (pointers) {
         //如果未越界不需要处理行为
         if (!this.isBoundary) return;
         var masterObj,
             stopPointer = pointers.stopPointer;
         if (masterObj = this.abstractGetPageObj(stopPointer)) {
             var pageId = masterObj.baseGetPageId(stopPointer);
             //停止活动对象活动
             _suspend(masterObj, pageId);
         }
     };

     /**
      * 复位初始状态
      * @return {[type]} [description]
      */
     MasterProto.resetOriginal = function (pageIndex) {
         var originalPageObj;
         if (originalPageObj = this.abstractGetPageObj(pageIndex)) {
             _original(originalPageObj);
         }
     };

     /**
      * 	母版自动运行
      */
     MasterProto.autoRun = function (data) {
         var masterObj, element;
         if (masterObj = this.abstractGetPageObj(data.currIndex)) {
             //热点状态复位
             this.resetOriginal(data.suspendIndex);
             _autoRun(masterObj, data.currIndex);
         }
     };

     /**
      * 移动内部的视察对象
      */
     MasterProto.moveParallaxs = function (moveDistance, currIndex, action, direction, speed, nodes) {
         var rootNode,
             floatObj,
             contentObj,
             contentObjs,
             baseContents,
             currParallaxObj,
             currMoveDistance,
             hasFloatMater,
             floatMaterParallaxChange,

         //需要执行动画
         activationAnim = action === "flipRebound" || action === "flipOver",
             self = this;

         //处理当前页面内的视觉差对象效果
         if (currParallaxObj = this.abstractGetPageObj(this.conversionMasterId(currIndex))) {
             if (baseContents = currParallaxObj.baseGetContent()) {
                 self.baseContents = baseContents;
                 //移动距离
                 currMoveDistance = moveDistance[1];
                 //遍历所有活动对象
                 _.each(baseContents, function (content) {
                     content.eachAssistContents(function (scope) {
                         //如果是视察对象移动
                         if (scope.parallax) {
                             rootNode = scope.parallax.rootNode;
                             contentObj = currParallaxObj.baseGetContentObject(scope.id);
                             /////////////////////
                             //如果有这个动画效果 //
                             //先停止否则通过视觉差移动会出问题
                             // //影响，摩天轮转动APK
                             // * 重新激动视觉差对象
                             // * 因为视察滑动对象有动画
                             // * 2个CSS3动画冲突的
                             // * 所以在视察滑动的情况下先停止动画
                             // * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
                             // * 通过动画回调在重新加载动画
                             /////////////////////
                             if (action === "flipMove" && contentObj.anminInstance && !contentObj.parallaxProcessed) {
                                 //标记
                                 var actName = contentObj.actName;
                                 contentObj.stopAnimations();
                                 //视觉差处理一次,停止过动画
                                 contentObj.parallaxProcessed = true;
                                 //增加标记
                                 rootNode.attr('data-parallaxProcessed', actName);
                                 //记录
                                 self.parallaxProcessedContetns[actName] = contentObj;
                             }

                             //移动视觉差对象
                             conversionTranslateX(rootNode, scope.parallax, direction, action, speed, nodes, currMoveDistance, floatMaterParallaxChange);
                         }
                     });
                 });
             }
         }

         function conversionTranslateX(rootNode, scope, direction, action, speed, nodes, currMoveDistance, floatMaterParallaxChange) {
             var translate = scope.translate,
                 offsetTranslate = scope.offsetTranslate,
                 nodes_1,
                 moveTranslate;

             //往前翻页
             if (direction === 'prev') {
                 //分割的比例
                 nodes_1 = scope.nodeProportion;
                 //如果往前溢出则取0
                 nodes = nodes == nodes_1 ? 0 : nodes_1;
             }

             //视觉对象移动的距离
             moveTranslate = self._transformConversion(translate, currMoveDistance, nodes);

             switch (action) {
                 //移动中
                 case 'flipMove':
                     moveTranslate = self._flipMove(moveTranslate, offsetTranslate);
                     break;
                 //反弹
                 case 'flipRebound':
                     moveTranslate = self._flipRebound(moveTranslate, offsetTranslate);
                     break;
                 //翻页结束,记录上一页的坐标
                 case 'flipOver':
                     if (direction === 'prev') {
                         moveTranslate = self._flipOver(moveTranslate, offsetTranslate);
                     }
                     self._overMemory(moveTranslate, offsetTranslate);
                     /**
                      * 记录浮动母版视察修改
                      * 2014.6.30针对浮动处理
                      */
                     // floatMaterParallaxChange && floatMaterParallaxChange(moveTranslate.translateX)
                     break;
             }

             //直接操作元素
             self._transformNodes(rootNode, speed, moveTranslate, offsetTranslate.opacityStart || 0);
         }
     };

     /**
      * 重新激动视觉差对象
      * 因为视察滑动对象有动画
      * 2个CSS3动画冲突的
      * 所以在视察滑动的情况下先停止动画
      * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
      * 通过动画回调在重新加载动画
      * @return {[type]} [description]
      */
     MasterProto.reactivation = function (target) {
         if (this.parallaxProcessedContetns) {
             var actName = target.id;
             var contentObj = this.parallaxProcessedContetns[actName];
             if (contentObj) {
                 contentObj.runAnimations();
                 //视觉差处理一次,停止过动画
                 contentObj.parallaxProcessed = false;
                 //移除标记
                 target.removeAttribute('data-parallaxProcessed');
                 //记录
                 delete this.parallaxProcessedContetns[actName];
             }
         }
     };

     //变化节点的css3transform属性
     MasterProto._transformNodes = function (rootNode, speed, property, opacityStart) {
         var style = {},
             effect = '',
             x = 0,
             y = 0,
             z = 0,
             round = Math.round;

         if (property.translateX != undefined || property.translateY != undefined || property.translateZ != undefined) {
             x = round(property.translateX) || 0;
             y = round(property.translateY) || 0;
             z = round(property.translateZ) || 0;
             effect += String.format('translate3d({0}px,{1}px,{2}px) ', x, y, z);
         }

         if (property.rotateX != undefined || property.rotateY != undefined || property.rotateZ != undefined) {
             x = round(property.rotateX);
             y = round(property.rotateY);
             z = round(property.rotateZ);
             effect += x ? 'rotateX(' + x + 'deg) ' : '';
             effect += y ? 'rotateY(' + y + 'deg) ' : '';
             effect += z ? 'rotateZ(' + z + 'deg) ' : '';
         }

         if (property.scaleX != undefined || property.scaleY != undefined || property.scaleZ != undefined) {
             x = round(property.scaleX * 100) / 100 || 1;
             y = round(property.scaleY * 100) / 100 || 1;
             z = round(property.scaleZ * 100) / 100 || 1;
             effect += String.format('scale3d({0},{1},{2}) ', x, y, z);
         }

         if (property.opacity != undefined) {
             style.opacity = round(property.opacity * 100) / 100 + opacityStart;
             effect += ';';
         }

         ////////////////
         //最终改变视觉对象的坐标 //
         ////////////////
         if (effect) {
             style[prefix$5('transition-duration')] = speed + 'ms';
             style[prefix$5('transform')] = effect;
             rootNode.css(style);
         }
     };

     //针对跳转页面
     //制作处理器
     MasterProto.makeJumpPocesss = function (data) {
         var filter;
         var master = this;
         return {
             pre: function pre() {
                 var targetIndex = data.targetIndex;
                 //目标母板对象
                 var targetkey = master.conversionMasterId(targetIndex);
                 //得到过滤的边界keys
                 //在filter中的页面为过滤
                 filter = master.scanBounds(targetIndex, targetkey);
                 //清理多余母板
                 //filter 需要保留的范围
                 master.checkClear(filter, true);
                 //更新可视母板编号
                 master.currMasterId = targetkey;
             },
             //修正位置
             clean: function clean(currIndex, targetIndex) {
                 master._fixPosition(filter);
                 master._checkParallaxPox(currIndex, targetIndex);
             }
         };
     };

     //扫描边界
     //扫描key的左右边界
     //当前页面的左右边
     MasterProto.scanBounds = function (currPage, currkey) {
         var currKey = this.conversionMasterId(currPage),
             filter = {},
             i = currPage,
             prevKey,
             nextKey;

         //往前
         while (i--) {
             prevKey = this.conversionMasterId(i);
             if (prevKey && prevKey !== currkey) {
                 filter['prev'] = prevKey;
                 break;
             }
         }

         //往后
         nextKey = this.conversionMasterId(currPage + 1);

         //如果有下一条记录
         if (nextKey && nextKey !== currkey) {
             //如果不是当期页面满足范围要求
             filter['next'] = nextKey;
         }

         //当前页面
         if (currKey) {
             filter['curr'] = currKey;
         }
         return filter;
     };

     //修正位置
     MasterProto._fixPosition = function (filter) {

         var self = this;

         function setPosition(parallaxObj, position) {
             //设置移动
             function toMove(distance, speed) {
                 var element = parallaxObj.element;
                 if (element) {
                     element.css(prefix$5('transition-duration'), speed + 'ms');
                     element.css(prefix$5('transform'), 'translate3d(' + distance + 'px,0px,0px)');
                 }
             }

             if (position === 'prev') {
                 toMove(-self.screenWidth);
             } else if (position === 'next') {
                 toMove(self.screenWidth);
             } else if (position === 'curr') {
                 toMove(0);
             }
         }

         for (var key in filter) {
             switch (key) {
                 case 'prev':
                     setPosition(this.abstractGetPageObj(filter[key]), 'prev');
                     break;
                 case 'curr':
                     setPosition(this.abstractGetPageObj(filter[key]), 'curr');
                     break;
                 case 'next':
                     setPosition(this.abstractGetPageObj(filter[key]), 'next');
                     break;
             }
         }
     };

     MasterProto._checkParallaxPox = function (currPageIndex, targetIndex) {
         var key,
             pageObj,
             pageCollection = this.abstractGetCollection();
         for (key in pageCollection) {
             pageObj = pageCollection[key];
             //跳跃过的视觉容器处理
             this._fixParallaxPox(pageObj, currPageIndex, targetIndex);
         }
     };

     //=======================去重检测==============================

     //当前同一视觉页面作用的范围
     MasterProto._toRepeat = function (reuseMasterKey, pageIndex) {
         var temp;
         if (temp = this.recordMasterscope[reuseMasterKey]) {
             return temp;
         }
         return false;
     };

     //更新母板作用域范围
     //recordMasterscope:{
     //	 9001-1:[0,1], master 对应记录的页码
     //	 9002-1:[2,3]
     //	 9001-2:[4,5]
     //}
     MasterProto._updataMasterscope = function (reuseMasterKey, pageIndex) {
         var scope;
         if (scope = this.recordMasterscope[reuseMasterKey]) {
             if (-1 === scope.indexOf(pageIndex)) {
                 scope.push(pageIndex);
             }
         } else {
             this.recordMasterscope[reuseMasterKey] = [pageIndex];
         }
     };

     //记录页面与模板标示的映射
     MasterProto._updatadParallaxMaster = function (reuseMasterKey, pageIndex) {
         //记录页面与模板标示的映射
         this.recordMasterId[pageIndex] = reuseMasterKey;
         //更新可视区母板的编号
         this.currMasterId = this.conversionMasterId(Xut.Presentation.GetPageIndex());
     };

     //检测是否需要创建视觉差
     MasterProto._checkRepeat = function (reuseMasterKey, pageOffset, pageIndex) {
         var tag = this._toRepeat(reuseMasterKey, pageIndex); //false就是没找到视察对象
         this._updataMasterscope(reuseMasterKey, pageIndex);
         this._updatadParallaxMaster(reuseMasterKey, pageIndex);
         return tag;
     };

     //transform转化成相对应的偏移量
     MasterProto._transformConversion = function (property, moveDistance, nodes) {
         var temp = {},
             i;

         for (i in property) {
             switch (i) {
                 case 'translateX':
                 case 'translateZ':
                     temp[i] = moveDistance * nodes * property[i];
                     break;
                 case 'translateY':
                     temp[i] = moveDistance * (this.screenHeight / this.screenWidth) * nodes * property[i];
                     break;
                 case 'opacityStart':
                     temp[i] = property.opacityStart;
                     break;
                 default:
                     //乘以-1是为了向右翻页时取值为正,位移不需这样做
                     temp[i] = -1 * moveDistance / this.screenWidth * property[i] * nodes;
             }
         }
         return temp;
     };

     //移动叠加值
     MasterProto._flipMove = function (property, repairProperty) {
         var temp = {};
         var start = property.opacityStart;
         for (var i in property) {
             temp[i] = property[i] + repairProperty[i];
         }
         if (start > -1) temp.opacityStart = start;
         return temp;
     };

     //反弹
     MasterProto._flipRebound = function (property, repairProperty) {
         var temp = {};
         for (var i in property) {
             temp[i] = repairProperty[i] || property[i];
         }
         return temp;
     };

     //翻页结束
     MasterProto._flipOver = function (property, repairProperty) {
         return this._flipMove(property, repairProperty);
     };

     //结束后缓存上一个记录
     MasterProto._overMemory = function (property, repairProperty) {
         for (var i in property) {
             repairProperty[i] = property[i];
         }
     };

     //修正跳转后视觉对象坐标
     MasterProto._fixParallaxPox = function (parallaxObj, currPageIndex, targetIndex) {
         var self = this,
             contentObjs,
             prevNodes,
             nodes;
         if (contentObjs = parallaxObj.baseGetContent()) {
             contentObjs.forEach(function (contentObj) {
                 contentObj.eachAssistContents(function (scope) {
                     if (scope.parallax) {
                         repairNodes.call(self, scope.parallax, currPageIndex, targetIndex);
                     }
                 });
             });
         }

         function repairNodes(scope, currPageIndex, targetIndex) {
             var rangePage = scope.calculateRangePage(),
                 rootNode = scope.rootNode,
                 translate = scope.translate,
                 offsetTranslate = scope.offsetTranslate,
                 moveTranslate,
                 nodes = Xut.Presentation.GetPageNode(targetIndex - 1);

             if (targetIndex > currPageIndex) {
                 //next
                 if (targetIndex > rangePage['end']) {
                     nodes = 1;
                 }
             } else {
                 //prev
                 if (targetIndex < rangePage['start']) {
                     nodes = 0;
                 }
             }

             moveTranslate = this._transformConversion(translate, -self.screenWidth, nodes);
             this._transformNodes(rootNode, 300, moveTranslate, offsetTranslate.opacityStart);
             this._overMemory(moveTranslate, offsetTranslate);
         }
     };

     //扁平化对象到数组
     function toArray$1(filter) {
         var arr = [];
         if (!filter.length) {
             for (var key in filter) {
                 arr.push(filter[key]);
             }
             filter = arr;
         }
         return filter;
     }

     //检测是否需要清理
     // 1 普通翻页清理  【数组过滤条件】
     // 2 跳转页面清理  【对象过滤条件】
     MasterProto.checkClear = function (filter, toPage) {
         var key,
             indexOf,
             removeMasterId = _.keys(this.abstractGetCollection());

         // 如果有2个以上的母板对象,就需要清理
         if (removeMasterId.length > 2 || toPage) {
             //或者是跳转页面
             //解析对象
             filter = toArray$1(filter);
             //过滤
             _.each(filter, function (masterId) {
                 if (masterId !== undefined) {
                     indexOf = removeMasterId.indexOf(masterId.toString());
                     if (-1 !== indexOf) {
                         //过滤需要删除的对象
                         removeMasterId.splice(indexOf, 1);
                     }
                 }
             });
             this.clearMemory(removeMasterId);
         }
     };

     //清理内存
     //需要清理的key合集
     MasterProto.clearMemory = function (removeMasterId) {
         var pageObj,
             self = this;
         _.each(removeMasterId, function (removekey) {
             //销毁页面对象事件
             if (pageObj = self.abstractGetPageObj(removekey)) {
                 //移除事件
                 pageObj.baseDestroy();
                 //移除列表
                 self.abstractRemoveCollection(removekey);
                 self.removeRecordMasterscope(removekey);;
             }
             //清理作用域缓存
             delete self.recordMasterscope[removekey];
         });
     };

     //注册状态管理
     MasterProto.register = function (pageIndex, type, hotspotObj) {
         var parallaxObj;
         if (parallaxObj = this.abstractGetPageObj(this.conversionMasterId(pageIndex))) {
             parallaxObj.registerCotents.apply(pageObj, arguments);
         }
     };

     //=======================工具方法==============================

     //page转化成母版ID
     MasterProto.conversionMasterId = function (pageIndex) {
         return this.recordMasterId ? this.recordMasterId[pageIndex] : undefined;
     };

     MasterProto.removeRecordMasterscope = function (removekey) {
         var me = this;
         var recordMasterscope = me.recordMasterscope[removekey];
         //清理页码指示标记
         recordMasterscope.forEach(function (scope) {
             delete me.recordMasterId[scope];
         });
     };

     //混入抽象接口方法
     extend(MasterMgr, Abstract);

     /**
      * 数据查询
      * @type {Object}
      */
     var Store = {

         statement: {},

         /**
          * novel表ID
          * @type {[type]}
          */
         novelId: null,

         /**
          * ppt总数
          * @type {Number}
          */
         count: 0,

         /**
          * 不存在的数据库表
          * @type {Array}
          */
         collectError: []
     };

     //热点合集
     var dataRet = {};

     'Setting,Parallax,Master,Activity,Content,Video,Image,Action,Animation,Widget,Novel,Season,Chapter'.replace(/[^, ]+/g, function (name) {
         Store.statement[name] = 'select * FROM ' + name + ' order by _id ASC';
     });

     /**
      * 查询单一的数据
      * @return {[type]} [description]
      */
     Store.oneQuery = function (tableName, callback) {
         execute('select * FROM ' + tableName + ' order by _id ASC', function (sqlRet, collectError) {
             callback(sqlRet);
         });
     };

     /**
      * 查询总数据
      */
     Store.query = function () {
         var i,
             self = this;
         return $.Deferred(function (dfd) {
             //数据库表重复数据只查询一次
             if (Object.keys(dataRet).length) {
                 dfd.resolve(dataRet);
                 return;
             }
             //ibook模式，数据库外部注入的
             if (Xut.IBooks.CONFIG) {
                 // self.collectError = collectError;
                 dfd.resolve(Xut.IBooks.CONFIG.data);
             } else {
                 //查询所有数据
                 execute(Store.statement, function (sqlRet, collectError) {
                     for (i in sqlRet) {
                         dataRet[i] = sqlRet[i];
                     }
                     dfd.resolve(dataRet);
                 });
             }
         }).promise();
     };

     /**
      * 删除数据
      * @type {[type]}
      */
     Store.remove = function (tableName, id) {
         var i,
             self = this;
         var sql = 'delete from ' + tableName + ' where _id = ' + id;
         return $.Deferred(function (dfd) {
             //查询所有数据
             execute(sql, function (success, failure) {
                 if (success) {
                     //成功回调
                     dfd.resolve();
                 } else if (failure) {
                     //失败回调
                     dfd.reject();
                 }
             });
         }).promise();
     };

     //数据缓存
     var dataCache = void 0;
     //带有场景信息存数
     var sectionRelated = void 0;
     //音频的ActivityId信息;
     var videoActivityIdCache = void 0;

     //混入数据到data中
     function mixToData(collections) {
         Xut.data = dataCache = collections;
     }

     //计算数据偏移量
     function dataOffset(tableName) {
         var start,
             data = dataCache[tableName];
         if (data.length) {
             if (data.item(0)) {
                 if (start = data.item(0)._id) {
                     dataCache[tableName].start = start;
                 }
             }
         }
     }

     //转化video的activtiy信息
     //因为Video不是靠id关联的 是靠activtiy关联
     function videoActivity() {
         var d,
             activityIds = {},
             data = dataCache.Video;
         _.each(data, function (_, index) {
             d = data.item(index);
             if (d && d.activityId) {
                 //确保activityIdID是有值，这样才是靠activity关联的video,而不是动画的video
                 activityIds[d.activityId] = d._id;
             }
         });
         return activityIds;
     }

     //chpater分段
     //转化section信息
     //带有场景处理
     function conversionSectionRelated() {
         var seasonId,
             start,
             length,
             sid,
             i,
             id,
             seasonInfo,
             toolbar,
             Chapters,
             container = {},
             Chapter = dataCache.Chapter,
             l = Chapter.length,
             end = 0;

         //找到指定的season信息
         var findSeasonInfo = function findSeasonInfo(seasonId) {
             var temp,
                 seasonNum = dataCache.Season.length;
             while (seasonNum--) {
                 if (temp = dataCache.Season.item(seasonNum)) {
                     if (temp._id == seasonId) {
                         return temp;
                     }
                 }
             }
         };

         for (i = 0; i < l; i++) {
             Chapters = Chapter.item(i);
             if (Chapters) {
                 id = Chapters._id - 1; //保存兼容性,用0开头
                 seasonId = Chapters.seasonId;
                 sid = 'seasonId->' + seasonId;
                 //如果不在集合,先创建
                 if (!container[sid]) {
                     //场景工具栏配置信息
                     if (seasonInfo = findSeasonInfo(seasonId)) {
                         toolbar = seasonInfo.parameter;
                     }
                     container[sid] = {
                         start: id,
                         length: 1,
                         end: id,
                         toolbar: toolbar
                     };
                 } else {
                     container[sid].end = id;
                     container[sid].length = container[sid].length + 1;
                 }
             }
         }

         return container;
     }

     //转化数据结构
     function conversion() {

         //数据段标记
         for (var k in dataCache) {
             if (dataCache[k].item) {
                 dataOffset(k);
             }
         }

         //============数据特殊处理================

         //vidoe特殊处理，需要记录chapterId范围
         if (dataCache.Video) {
             videoActivityIdCache = videoActivity();
         }

         /**
          * 带有场景处理
          * @type {[type]}
          */
         sectionRelated = conversionSectionRelated();

         /**
          * 标记应用ID
          * @type {[type]}
          */
         dataCache.novelId = Store.novelId;

         /**
          * 针对数据库content为空的处理
          * @return {[type]} [description]
          */
         dataCache.preventContent = function () {
             return dataCache.Content.length ? false : true;
         }();

         //===============================================
         // 
         //  查询数据接口
         //
         //  1 video表传递是activityId关联
         //  2 其余表都是传递当前表的id
         //  type 查询ID的类型, 数据的id或者activityId
         //  callback 提供给chapterId使用
         //================================================

         /**
          * 通过ID查询方式
          * @param  {[type]}  tableName [description]
          */
         dataCache.query = function (tableName, id, type, callback) {
             /**
              * 特殊的字段关联
              * 1 activityId
              * 2 chpaterId
              */
             switch (type) {
                 /**
                  * 通过activityId查询的方式
                  *
                  * 表名,ID,类型
                  * Xut.data.query('Action', id, 'activityId');
                  *   
                  * @type {[type]}
                  */
                 case 'activityId':
                     var item;
                     var activityId = id;
                     var data = dataCache[tableName];
                     for (var i = 0, len = data.length; i < len; i++) {
                         item = data.item(i);
                         if (item) {
                             if (item[type] == activityId) {
                                 return item;
                             }
                         }
                     }
                     return;

                 /**
                  * 通过chpaterId查询方式
                  * parser中的scanActivity过滤处理
                  */
                 case 'chapterId':
                 case 'seasonId':
                     var chapterId = id;
                     var data = dataCache[tableName];
                     if (data) {
                         var item;
                         for (var i = 0, len = data.length; i < len; i++) {
                             item = data.item(i);
                             if (item) {
                                 if (item[type] == chapterId) {
                                     callback && callback(item);
                                 }
                             }
                         }
                     }
                     return;
             }

             /**
              * 通过id查询的方式
              */
             switch (tableName) {
                 //////////////////////////
                 //获取整个一个用的chapter数据 //
                 //////////////////////////
                 case 'appPage':
                     return dataCache.Chapter;

                 //////////////////////////
                 //获取整个一个用的Section数据 //
                 //////////////////////////
                 case 'appSection':
                     return dataCache.Season;

                 //////////////////////
                 //如果是是section信息 //
                 //////////////////////
                 case 'sectionRelated':
                     return sectionRelated['seasonId->' + id];

                 //////////////
                 //如果是音频 //
                 //////////////
                 case 'Video':
                     if (type) {
                         return Query();
                     } else {
                         //传递的id是activityId
                         var id = videoActivityIdCache[id];
                         return dataCache.query('Video', id, true);
                     }

                 default:
                     /////////////////
                     //默认其余所有表 //
                     /////////////////
                     return Query();
             }

             //数据信息
             function Query() {
                 var data = dataCache[tableName];
                 if (id) {
                     var index = id - data.start;
                     return data.item(index);
                 } else {
                     return data.length ? data.item(0) : null;
                 }
             }
         };

         /**
          * 针对动态表查询
          * 每次需要重新取数据
          * Xut.data.oneQuery('Image',function(){});
          * @return {[type]} [description]
          */
         dataCache.oneQuery = function (tableName, callback) {
             Store.oneQuery(tableName, function (data) {
                 callback && callback(data);
             });
         };

         /**
          * 删除数据
          * 表名,表ID
          * @return {[type]} [description]
          */
         dataCache.remove = function (tableName, id, success, failure) {
             var dfd = Store.remove(tableName, id);
             dfd.done(success, failure);
         };
     }

     /**
      * 返回错误的表
      * @return {[type]} [description]
      */
     function errorTable() {
         return Store.collectError;
     }

     /**
      *     初始化数据类
         获取ppt总数
      * @return {[type]} [description]
      */
     function createStore() {
         return $.Deferred(function (dfd) {
             Store.query().done(function (data) {
                 var novel = data.Novel;
                 //novel的id
                 var novelId = Store.novelId = novel.item(0)['_id'];
                 //数据转换
                 mixToData(data);
                 //转化数据结构
                 conversion();
                 //数据缓存已存在
                 // storeMgr.dataCache = true
                 dfd.resolve(data.Setting, novel.item(0));
             });
         }).promise();
     }

     /**
      * 页面切换逻辑
      * @param  {[type]} ) [description]
      * @return {[type]}   [description]
      */

     /**
      * 跳转之前提高层级问题
      * @return {[type]}          [description]
      */
     function prev(complier, data) {
         var currIndex = data.currIndex;
         //跳转之前提高层级问题
         complier.pageMgr.abstractAssistPocess(currIndex, function (pageObj) {
             pageObj.element.css({
                 'z-index': 9997
             });
         });
         //提高母版层级
         complier.callMasterMgr(function () {
             this.abstractAssistPocess(currIndex, function (pageObj) {
                 pageObj.element.css({
                     'z-index': 1
                 });
             });
         });
     }

     //处理跳转逻辑
     function calculateFlip(complier, data, createCallback) {
         //缓存当前页面索引用于销毁
         var pageIndex,
             i = 0,
             collectContainers = [],
             create = data.create,
             targetIndex = data.targetIndex;

         //需要创建的页面闭包器
         for (; i < create.length; i++) {
             pageIndex = create[i];
             collectContainers.push(function (targetIndex, pageIndex) {
                 return function (callback) {
                     //创建新结构
                     complier.create([pageIndex], targetIndex, 'toPage', callback, {
                         'opacity': 0 //同页面切换,规定切换的样式
                     });
                 };
             }(targetIndex, pageIndex));
         }

         /**
          * 二维数组保存，创建返回的对象
          * 1 page对象
          * 2 母版对象
          * @type {Array}
          */
         data.pageBaseCollect = [];

         var i = 0,
             collectLength,
             count,
             count = collectLength = collectContainers.length;

         if (collectContainers && collectLength) {
             for (; i < collectLength; i++) {
                 //收集创建的根节点,异步等待容器的创建
                 collectContainers[i].call(complier, function (callbackPageBase) {
                     if (count === 1) {
                         collectContainers = null;
                         setTimeout(function () {
                             createCallback(data);
                         }, 100);
                     }
                     //接受创建后返回的页面对象
                     data.pageBaseCollect.push(callbackPageBase);
                     count--;
                 });
             }
         }
     }

     //节点创建完毕后，切换页面动，执行动作
     function createContainerView(complier, data) {

         var prveHindex = data.currIndex;
         var pageMgr = complier.pageMgr;

         //停止当前页面动作
         complier.suspend({
             'stopPointer': prveHindex
         });

         //========处理跳转中逻辑=========

         /**
          * 清除掉不需要的页面
          * 排除掉当前提高层次页面
          */
         _.each(data['destroy'], function (destroyIndex) {
             if (destroyIndex !== data.currIndex) {
                 pageMgr.clearPage(destroyIndex);
             }
         });

         //修正翻页2页的页面坐标值
         _.each(data['ruleOut'], function (pageIndex) {
             if (pageIndex > data['targetIndex']) {
                 pageMgr.abstractAssistAppoint(pageIndex, function (pageObj) {
                     Translation.fix.call(pageObj, 'nextEffect');
                 });
             }
             if (pageIndex < data['targetIndex']) {
                 pageMgr.abstractAssistAppoint(pageIndex, function (pageObj) {
                     Translation.fix.call(pageObj, 'prevEffect');
                 });
             }
         });

         var jumpPocesss;

         //母版
         complier.callMasterMgr(function () {
             jumpPocesss = this.makeJumpPocesss(data);
             jumpPocesss.pre();
         });

         //===========跳槽后逻辑========================
         pageMgr.clearPage(prveHindex);

         jumpPocesss && jumpPocesss.clean(data.currIndex, data.targetIndex);

         /**
          * 同页面切换,规定切换的样式复位
          * @param  {[type]} pageBase [description]
          * @return {[type]}          [description]
          */
         _.each(data.pageBaseCollect, function (pageBase) {
             _.each(pageBase, function (pageObj) {
                 pageObj.element && pageObj.element.css({
                     'opacity': 1
                 });
             });
         });

         data.pageBaseCollect = null;
         jumpPocesss = null;
     }

     function SwitchPage(complier, data, success) {
         //跳前逻辑
         prev(complier, data);
         //处理逻辑
         calculateFlip(complier, data, function (data) {
             createContainerView(complier, data);
             success.call(complier, data);
         });
     }

     //判断是否能整除2
     function offsetPage(num) {
         return num % 2 == 0 ? 'left' : 'right';
     }

     //如果是场景加载，转化页码数
     //转化按0开始
     //pageIndex 页码
     //visiblePid 可见页面chpaterId
     function conversionPageOpts(pageIndex, visiblePid) {
         var sectionRang;
         //转化可视区域值viewPageIndex
         if (this.options.multiScenario) {
             sectionRang = this.options.sectionRang;
             //如果传入的是数据
             if (!visiblePid && _.isArray(pageIndex)) {
                 pageIndex.forEach(function (ele, index) {
                     pageIndex.splice(index, 1, ele - sectionRang.start);
                 });
                 return pageIndex;
             }
             pageIndex -= sectionRang.start;
             visiblePid += sectionRang.start;
         } else {
             //pageIndex是数组，并且realPage为空
             if (_.isArray(pageIndex)) {
                 return pageIndex;
             }
         }

         return {
             'pageIndex': pageIndex,
             'visiblePid': visiblePid
         };
     }

     ///////////
     //计算翻页距离 //
     ///////////
     function calculateDistance(action, distance, direction) {
         var leftOffset, currOffset, rightOffset;

         //保持缩放比,计算缩放比情况下的转化
         var calculateContainer = Xut.config.proportion.calculateContainer();
         var containerWidth = calculateContainer.width;

         switch (direction) {
             //前翻
             case 'prev':
                 switch (action) {
                     case 'flipMove':
                         leftOffset = distance - containerWidth;
                         currOffset = distance;
                         rightOffset = distance + containerWidth;
                         break;
                     case 'flipRebound':
                         leftOffset = -containerWidth;
                         currOffset = distance;
                         rightOffset = containerWidth;
                         break;
                     case 'flipOver':
                         leftOffset = 0;
                         currOffset = containerWidth;
                         rightOffset = 2 * containerWidth;
                         break;
                 }
                 break;
             //后翻
             case 'next':
                 switch (action) {
                     case 'flipMove':
                         leftOffset = distance - containerWidth;
                         rightOffset = distance + containerWidth;
                         currOffset = distance;
                         break;
                     case 'flipRebound':
                         leftOffset = -containerWidth;
                         rightOffset = containerWidth;
                         currOffset = distance;
                         break;
                     case 'flipOver':
                         leftOffset = -2 * containerWidth;
                         rightOffset = distance;
                         currOffset = -containerWidth;
                         break;
                 }
                 break;
         }

         return [leftOffset, currOffset, rightOffset];
     }

     ////////////
     //计算初始化页码 //
     ////////////
     function calculatePointer(targetIndex, pageTotal, multiplePages) {

         var leftscope = 0,
             pagePointer = {},
             createPointer = [];

         function setValue(index) {
             if (index.leftIndex !== undefined) {
                 pagePointer.leftIndex = index.leftIndex;
                 createPointer.push(index.leftIndex);
             }
             if (index.currIndex !== undefined) {
                 pagePointer.currIndex = index.currIndex;
                 createPointer.push(index.currIndex);
             }
             if (index.rightIndex !== undefined) {
                 pagePointer.rightIndex = index.rightIndex;
                 createPointer.push(index.rightIndex);
             }
         }

         //如果只有一页 or  非线性,只创建一个页面
         if (pageTotal === 1 || !multiplePages) {
             setValue({
                 'currIndex': targetIndex
             });
         } else {
             //多页情况
             if (targetIndex === leftscope) {
                 //首页
                 setValue({
                     'currIndex': targetIndex,
                     'rightIndex': targetIndex + 1
                 });
             } else if (targetIndex === pageTotal - 1) {
                 //尾页
                 setValue({
                     'currIndex': targetIndex,
                     'leftIndex': targetIndex - 1
                 });
             } else {
                 //中间页
                 setValue({
                     'currIndex': targetIndex,
                     'leftIndex': targetIndex - 1,
                     'rightIndex': targetIndex + 1
                 });
             }
         }

         this.pagePointer = pagePointer;

         return createPointer;
     }

     //保证可视页面第一个分解
     //createPage 需要创建的页面 [0,1,2]
     //visualPage 可视区页面       [1]
     function conversionCid(createPage, visualPage) {

         var indexOf, start, less;

         //如果第一个不是可视区域
         //切换位置
         //加快创建速度
         if (createPage[0] !== visualPage) {
             indexOf = createPage.indexOf(visualPage), less = createPage.splice(indexOf, 1), createPage = less.concat(createPage);
         }

         //场景加载模式,计算正确的chapter顺序
         //多场景的模式chpater分段后
         //叠加起始段落
         if (this.options.multiScenario) {
             //需要提前解析数据库的排列方式
             //chpater的开始位置
             start = this.options.sectionRang.start;
             //拼接位置
             createPage.forEach(function (page, index) {
                 createPage.splice(index, 1, page + start);
             });
         }

         // [0,1,2] => [73,74,75]
         return createPage;
     }

     //页码转化成相对应的chpater表数据
     function conversionPids(createPage) {
         return query('chapter', createPage);
     }

     //检测是否构建母板模块处理
     function checkMasterCreate() {
         var table = errorTable();
         //如果没有Master数据,直接过滤
         if (-1 !== table.indexOf('Master') || !Xut.data['Master'] || !Xut.data['Master'].length) {
             return false;
         }
         return true;
     }

     ////////
     //调度器 //
     ////////
     function Scheduler(vm) {

         this.vm = vm;
         this.options = vm.options;

         /**
          * 创建前景页面管理模块
          * @type {PageMgr}
          */
         this.pageMgr = new PageMgr(vm);

         /**
          * 检测是否需要创母版模块
          * @return {[type]} [description]
          */
         if (checkMasterCreate()) {
             this.masterMgr = new MasterMgr(vm);
         }
     };

     var SchedulerProto = Scheduler.prototype;

     /**
      * 初始化页面创建
      * 因为多个页面的问题，所以不是创建调用
      * 统一回调
      * @return {[type]} [description]
      */
     SchedulerProto.initCreate = function () {
         var options = this.options;
         /**
          * 初始化构建页面
          */
         this.create(calculatePointer.call(this, options.initIndex, options.pagetotal, options.multiplePages), options.initIndex, 'init');
     };

     /**
      *  创建普通页面
      *  创建母版页面
      *  createPointer  需要创建的页面索引
      *  visiblePage       当前可视区页面索引
      *  action         toPage/init/flipOver
      *  toPageCallback 跳转页面支持回调通知
      *  userStyle      规定创建的style属性
      **/
     SchedulerProto.create = function (createPage, visiblePage, action, toPageCallback, userStyle) {

         //2016.1.20
         //修正苗苗学问题 确保createPage不是undefined
         if (void 0 === createPage[0]) {
             return;
         }

         // console.debug('当前页面:' + this.pagePointer.currIndex + ',创建新页面:"'+ createPointer + '",动作:' +action)
         var createPid,
             pageBase,
             visiblePid,
             pageIndex,
             conversion,
             newCreate,
             callbackAction,
             virtualMode = Xut.config.virtualMode,
             self = this,
             multiplePages = this.options.multiplePages,
             //是否线性
         total = createPage.length,
             toPageAction = action === 'toPage',
             //如果是跳转
         filpOverAction = action === 'flipOver',
             //如果是翻页

         //使用第一个是分解可见页面
         //将页码pageIndex转化成对应的chapter
         createPids = conversionCid.call(this, createPage, visiblePage),


         //收集创建的页面对象
         //用于处理2个页面在切换的时候闪屏问题
         //主要是传递createStyle自定义样式的处理
         collectCreatePageBase = [],


         //是否触发母版的自动时间
         //因为页面每次翻页都会驱动auto事件
         //但是母版可能是共享的
         createMaster = false,


         //收集完成回调
         collectCallback = function () {
             //收集创建页码的数量
             var createContent = 0;
             return function (callback) {
                 ++createContent;
                 if (createContent === total) {
                     callback();
                 }
             };
         }(),


         //构建执行代码
         callbackAction = {
             //初始化
             init: function init() {
                 collectCallback(function () {
                     self.loadPage('init');
                 });
             },
             //翻页
             flipOver: function flipOver() {
                 collectCallback(function () {
                     self.autoRun({ //翻页
                         'createPointer': createPids,
                         'createMaster': createMaster
                     });
                 });
             },
             //跳转
             toPage: function toPage() {
                 collectCallback(function () {
                     toPageCallback(collectCreatePageBase);
                 });
             }
         };

         ////////////////////
         //pid=>chpterData //
         ////////////////////
         var results = conversionPids(createPids);

         ////////////
         //如果是最后一页 //
         //没有对应的虚拟数据，取前一页的
         ////////////
         if (virtualMode && !results.length) {
             var virtualPid = _.extend([], createPids);
             createPids.forEach(function (pid, index) {
                 virtualPid.splice(index, 1, --pid);
             });
             results = conversionPids(virtualPid);
         }

         //页码转成数据
         _.each(results, function (chapterData, index) {

             //转化值
             //chapterId => createPid
             createPid = createPids[index];

             //createPid
             //pageIndex
             conversion = conversionPageOpts.call(self, createPid, visiblePage);
             visiblePid = conversion.visiblePid;
             pageIndex = conversion.pageIndex;

             ////////////////
             // 如果启动了虚拟页面模式 //
             ////////////////
             var virtualPid = false; //虚拟页面的pid编号
             var virtualOffset = false; //页面坐标left,right
             if (virtualMode) {

                 //获取新的chpater数据

                 var fixCids = function fixCids(originalIndex) {
                     var originalPid = conversionCid.call(self, [originalIndex]);
                     return conversionPids([originalPid])[0];
                 };

                 ////////////
                 //如果是翻页创建 //
                 //由于是拼接的所以chapter移位了
                 ////////////


                 //页面位置
                 virtualOffset = offsetPage(pageIndex);if (virtualOffset === 'left') {
                     chapterData = fixCids(pageIndex / 2);
                 }
                 //修正右边chapter
                 if (virtualOffset === 'right') {
                     chapterData = fixCids((pageIndex - 1) / 2);
                 }
             }

             if (total === 1) {
                 self.options.chapterId = chapterData._id;
             }

             //构件新的页面
             //masterFilter 母板过滤器回调函数
             newCreate = function newCreate(masterFilter) {

                 //跳转的时候，创建新页面可以自动样式信息
                 //优化设置，只是改变当前页面即可
                 if (toPageAction && visiblePid !== createPid) {
                     userStyle = undefined;
                 }

                 var dataOpts = {
                     'pageIndex': pageIndex,
                     'multiplePages': multiplePages,
                     'pid': createPid, //页码chapterId
                     'chapterDas': chapterData, //当前页面的chpater数据
                     'visiblePid': visiblePid, //实际中页面显示的索引
                     'userStyle': userStyle,
                     'virtualPid': virtualPid, //pid
                     'virtualOffset': virtualOffset //虚拟页面位置
                 };

                 //初始化构建页面对象
                 //page
                 //master
                 pageBase = this.create(dataOpts, pageIndex, masterFilter);

                 //构建页面对象后
                 //开始执行
                 if (pageBase) {
                     //开始线程任务
                     //当为滑动模式,支持快速创建
                     pageBase.startThreadTask(filpOverAction, function () {
                         // console.log('创建完毕************** ' + (createPid+1) +' '+ action)
                         callbackAction[action]();
                     });
                     //收集自定义样式的页面对象
                     if (userStyle) {
                         collectCreatePageBase.push(pageBase);
                     }
                 }
             };

             //母版层
             if (chapterData.pptMaster && self.masterMgr) {
                 newCreate.call(self.masterMgr, function () {
                     //母版是否创建等待通知
                     //母版是共享的所以不一定每次翻页都会创建
                     //如果需要创建,则叠加总数
                     ++total;
                     createMaster = true;
                 });
             }

             //页面层
             newCreate.call(self.pageMgr);
         });
     };

     /**
      * 滑动处理
      *  1 滑动
      *  2 反弹
      *  3 翻页
      */
     SchedulerProto.move = function (data) {

         //动作
         var action = data.action;

         //用户强制直接切换模式
         //禁止页面跟随滑动
         if (this.options.pageFlip && action == 'flipMove') {
             return;
         }

         var speed = data.speed;
         var distance = data.distance;
         var leftIndex = data.leftIndex;
         var currIndex = data.pageIndex;
         var rightIndex = data.rightIndex;
         var direction = data.direction;
         //移动的距离
         var moveDistance = calculateDistance(action, distance, direction);
         //视觉差页面滑动
         var nodes = this.pageMgr.abstractGetPageObj(currIndex)['chapterDas']['nodes'];

         ///////
         //页面改变 //
         ///////
         //通知page模块
         this.pageMgr.move(leftIndex, currIndex, rightIndex, direction, speed, action, moveDistance);

         //通知视觉差模块
         this.callMasterMgr(function () {
             this.move(leftIndex, currIndex, rightIndex, direction, moveDistance, action, speed, nodes);
         });

         //更新页码标示
         'flipOver' === action && setTimeout(function () {
             this.vm.$emit('change:pageUpdate', direction === 'next' ? rightIndex : leftIndex);
         }.bind(this), 0);
     };

     /**
      * 翻页松手后
      * 暂停页面的各种活动动作
      * @param  {[type]} pointers [description]
      * @return {[type]}          [description]
      */
     SchedulerProto.suspend = function (pointers) {
         //关闭层事件
         this.pageMgr.suspend(pointers);
         this.callMasterMgr(function () {
             this.suspend(pointers);
         });
         //目录栏
         _close();
         //复位工具栏
         this.vm.$emit('change:resetToolbar');
     };

     /**
      * 翻页动画完毕后
      * @return {[type]}              [description]
      */
     SchedulerProto.complete = function (direction, pagePointer, unfliplock, isQuickTurn) {
         //方向
         this.direction = direction;
         //是否快速翻页
         this.isQuickTurn = isQuickTurn || false;
         //解锁
         this.unfliplock = unfliplock;
         //清理上一个页面
         this._clearPage(pagePointer.destroyPointer);
         this._updatePointer(pagePointer);
         //预创建下一页
         this._advanceCreate(direction, pagePointer);
     };

     //清理页面结构
     SchedulerProto._clearPage = function (clearPageIndex) {
         this.pageMgr.clearPage(clearPageIndex);
     };

     //更新页码索引标示
     SchedulerProto._updatePointer = function (pagePointer) {
         this.pagePointer = pagePointer;
     };

     //预创建新页面
     SchedulerProto._advanceCreate = function (direction, pagePointer) {
         var pagetotal = this.options.pagetotal,
             vm = this.vm,
             createPointer = pagePointer.createPointer,
             destroyPointer = pagePointer.destroyPointer,

         //清理页码
         clear = function clear() {
             delete pagePointer.createPointer;
             delete pagePointer.destroyPointer;
         },

         //创建新的页面对象
         createNextContainer = function createNextContainer(createPointer, currIndex) {
             this.create([createPointer], currIndex, 'flipOver');
         };

         //如果是右边翻页
         if (direction === 'next') {
             //首尾无须创建页面
             if (pagePointer.currIndex === pagetotal - 1) {
                 this.autoRun();
                 //如果总数只有2页，那么首页的按钮是关闭的，需要显示
                 if (pagetotal == 2) {
                     vm.$emit('change:showPrev');
                 }
                 //多页处理
                 vm.$emit('change:hideNext');
                 return;
             }
             if (createPointer < pagetotal) {
                 //创建的页面
                 createNextContainer.call(this, createPointer, pagePointer.currIndex);
                 clear();
                 vm.$emit('change:showPrev');
                 return;
             }
         }

         //如果是左边翻页
         if (direction === 'prev') {
             //首尾无须创建页面
             if (pagePointer.currIndex === 0) {
                 this.autoRun();
                 //如果总数只有2页，那么首页的按钮是关闭的，需要显示
                 if (pagetotal == 2) {
                     vm.$emit('change:showNext');
                 }
                 vm.$emit('change:hidePrev');
                 return;
             }
             if (pagePointer.currIndex > -1) {
                 //创建的页面
                 createNextContainer.call(this, createPointer, pagePointer.currIndex);
                 clear();
                 vm.$emit('change:showNext');
                 return;
             }
         }

         clear();

         return;
     };

     /**
      * 自动运行处理
      *  流程四:执行自动触发动作
      *   1.初始化创建页面完毕
      *   2.翻页完毕
      */
     SchedulerProto.autoRun = function (para) {
         var options = this.options,
             pagePointer = this.pagePointer,
             prevIndex = pagePointer.leftIndex,
             currIndex = pagePointer.currIndex,
             nextIndex = pagePointer.rightIndex,
             action = para ? para.action : '',
             createPointer = para ? para.createPointer : '',
             direction = this.direction,

         //暂停的页面索引autorun
         suspendIndex = action === 'init' ? '' : direction === 'next' ? prevIndex : nextIndex;

         /**
          * 存在2中模式的情况下
          * 转化页码标记
          */
         if (createPointer) {
             createPointer = conversionPageOpts.call(this, createPointer);
         }

         var data = {
             'prevIndex': prevIndex,
             'currIndex': currIndex,
             'nextIndex': nextIndex,
             'suspendIndex': suspendIndex,
             'createPointer': createPointer,
             'direction': direction,
             'isQuickTurn': this.isQuickTurn,
             //中断通知
             'suspendCallback': options.suspendAutoCallback,
             //构建完毕通知
             'buildComplete': function buildComplete(scenarioId) {
                 //==========================================
                 //
                 //      构建完成通知,用于处理历史缓存记录
                 //      如果是调试模式
                 //      && 不是收费提示页面
                 //      && 多场景应用
                 //
                 //==========================================
                 if (Xut.config.recordHistory && !options.isInApp && options.multiScenario) {
                     var history;
                     if (history = Xut.sceneController.sequence(scenarioId, currIndex)) {
                         _set("history", history);
                     }
                 }
             },

             //流程结束通知
             //包括动画都已经结束了
             'processComplete': function processComplete() {}
         };

         //页面自动运行
         this.pageMgr.autoRun(data);

         //模板自动运行
         this.callMasterMgr(function () {
             //如果动作是初始化，或者触发了母版自动运行
             //如果是越界处理
             //console.log(action,this.isBoundary,para.createMaster)
             if (action || this.isBoundary) {
                 this.autoRun(data);
             }
         });

         /**
          * 触发自动通知
          * @type {[type]}
          */
         var vm = this.vm;

         switch (action) {
             case 'init':
                 //更新页码标示
                 vm.$emit('change:pageUpdate', currIndex);
                 resetToolbar.call(this);
                 setTimeout(function () {
                     $("#startupPage").remove();
                     $("#removelayer").remove();
                 }, 2000);
                 break;
             case 'toPage':
                 //更新页码标示
                 vm.$emit('change:pageUpdate', currIndex);
                 resetToolbar.call(this);
                 break;
         }

         /**
          * 初始化与跳转针对翻页案例的设置逻辑
          * @return {[type]} [description]
          */
         function resetToolbar() {
             //不显示首尾对应的按钮
             if (currIndex == 0) {
                 vm.$emit('change:hidePrev');
             } else if (currIndex == options.pagetotal - 1) {
                 vm.$emit('change:hideNext');
                 vm.$emit('change:showPrev');
             } else {
                 vm.$emit('change:showNext');
                 vm.$emit('change:showPrev');
             }
         }

         /**
          * 线性结构
          * 保存目录索引
          */
         if (!options.multiScenario) {
             _set("pageIndex", currIndex);
         }

         /**
          * 解锁翻页
          * 允许继续执行下一个翻页作用
          */
         if (this.unfliplock) {
             this.unfliplock();
             this.unfliplock = null;
         }

         //关闭快速翻页
         this.isQuickTurn = false;
     };

     /**
      * 页面跳转切换处
      * @param  {[type]} data [description]
      * @return {[type]}      [description]
      */
     SchedulerProto.jumpPage = function (data) {

         Xut.View.ShowBusy();

         //如果是非线性,创建页面修改
         if (!this.options.multiplePages) {
             data.create = [data.targetIndex];
             data.destroy = [data.currIndex];
             data.ruleOut = [data.targetIndex];
             data.pagePointer = {
                 currIndex: data.targetIndex
             };
         }

         //执行页面切换
         SwitchPage(this, data, function (data) {
             this._updatePointer(data.pagePointer);
             this.autoRun({
                 'action': 'toPage',
                 'createPointer': data['create']
             });
             Xut.View.HideBusy();
         });
     };

     /**
      * 加载页面事件与动作
      * @param  {[type]} action [description]
      * @return {[type]}        [description]
      */
     SchedulerProto.loadPage = function (action) {
         var self = this;

         //触发自动任务
         function trigger() {
             self.autoRun({
                 'action': 'init'
             });
         }

         //加载主场景页面
         function firstLoading() {

             $("#sceneHome").css({
                 'visibility': 'visible'
             });

             if (GLOBALIFRAME) {
                 trigger();
                 return;
             }
             //获取应用的状态
             if (Xut.Application.getAppState()) {
                 //保留启动方法
                 var pre = Xut.Application.LaunchApp;
                 Xut.Application.LaunchApp = function () {
                     pre();
                     trigger();
                 };
             } else {
                 trigger();
             }
         }

         //创建完成回调
         self.vm.$emit('change:createComplete', function () {
             if (self.options.multiScenario) {
                 trigger();
             } else {
                 //第一次加载
                 //进入应用
                 firstLoading();
             }
         });
     };

     /**
      * 调用母版管理器
      * @return {[type]} [description]
      */
     SchedulerProto.callMasterMgr = function (callback) {
         if (this.masterMgr) {
             callback.call(this.masterMgr);
         }
     };

     /**
      * 销毁接口
      * 对应多场景操作
      * @return {[type]} [description]
      */
     SchedulerProto.destroy = function () {
         this.pageMgr.destroy();
         this.callMasterMgr(function () {
             this.destroy();
         });
     };

     var config$8 = void 0;

     // 'container'     : this.elements[0],
     // 'pageMode'      : pageMode,
     // 'multiScenario' : !isMain,
     // 'rootPage'      : scenarioPage,
     // 'rootMaster'    : scenarioMaster,
     // 'initIndex'     : pageIndex, //保存索引从0开始
     // 'pagetotal'     : pageTotal,
     // 'sectionRang'   : this.sectionRang,
     // 'scenarioId'    : scenarioId,
     // 'chapterId'     : this.chapterId,
     // 'isInApp'       : this.isInApp //提示页面
     function Manager(parameter) {

         config$8 = Xut.config;

         var vm = this;

         var options = {
             //数据库定义的翻页模式
             //用来兼容客户端的制作模式
             //妙妙学模式处理，多页面下翻页切换
             //0 翻页滑动
             //1 没有滑动过程,直接切换页面
             'pageFlip': config$8.pageFlip,

             //翻页模式
             //根据页码数决定,主要是优化一些代码
             //true  是多页面模式,支持翻页滑动
             //false 单页面模式,不能翻页，只能跳转
             'pageMode': false,

             //是否多场景加载
             //单页场景 false
             //多场景   true
             'multiScenario': false,

             //是否为连续页面
             //通过pageMode的参数定义
             'multiplePages': false
         };

         //配置文件
         options = vm.options = _.extend(options, parameter);

         //强制转换
         //multiplePages
         //是否为连续页面
         if (Xut.IBooks.Enabled) {
             options.multiplePages = false;
         } else {
             options.multiplePages = options.pageFlip ? options.pageFlip : options.pageMode ? true : false;
         }

         //创建翻页滑动
         var $globalEvent = vm.$globalEvent = new GlobalEvent(options, config$8);

         // console.log( $globalEvent)

         //创建page页面管理
         var $scheduler = vm.$scheduler = new Scheduler(vm);

         //委托事件处理钩子
         var delegateHooks = {
             //超连接,跳转
             //svg内嵌跳转标记处理
             'data-xxtlink': function dataXxtlink(target, attribute, rootNode, pageIndex) {
                 try {
                     var para = attribute.split('-');
                     if (para.length > 1) {
                         //如果有多个就是多场景的组合
                         Xut.View.GotoSlide(para[0], para[1]);
                     } else {
                         Xut.View.GotoSlide(para[0]);
                     }
                 } catch (err) {
                     console.log('跳转错误');
                 }
             },

             //Action', 'Widget', 'Video', 'ShowNote', 'SubDoc'委托
             'data-delegate': function dataDelegate(target, attribute, rootNode, pageIndex) {
                 trigger.apply(null, arguments);
             },

             //如果是canvas节点
             'data-canvas': function dataCanvas(cur) {
                 // alert(1)
             }
         };

         //如果是主场景,才能切换系统工具栏
         if (options.multiplePages) {
             _.extend(delegateHooks, {
                 //li节点,多线程创建的时候处理滑动
                 'data-container': function dataContainer() {
                     vm.$emit('change:toggleToolbar');
                 },

                 //是背景层
                 'data-multilayer': function dataMultilayer() {
                     //改变工具条状态
                     vm.$emit('change:toggleToolbar');
                 },

                 //默认content元素可以翻页
                 'data-behavior': function dataBehavior(target, attribute, rootNode, pageIndex) {
                     //没有事件的元素,即可翻页又可点击切换工具栏
                     if (attribute == 'click-swipe') {
                         vm.$emit('change:toggleToolbar');
                     }
                 }
             });
         }

         //简化委托处理，默认一层元素只能绑定一个委托事件
         function filterProcessor(event, pageType) {
             var i,
                 k,
                 attribute,
                 attributes,
                 value,
                 cur = event.target;

             if (cur.nodeType) {
                 //如果触发点直接是li
                 if (cur === this) {
                     return {
                         'rootNode': this,
                         'elem': cur,
                         'handlers': delegateHooks['data-container']
                     };
                 }
                 //否则是内部的节点
                 try {
                     for (; cur !== this; cur = cur.parentNode || this) {
                         //如果是canvas节点
                         if (cur.nodeName && cur.nodeName.toLowerCase() === 'canvas') {
                             //是否为滑动行为
                             if (Xut.Contents.Canvas.getSupportState()) {
                                 return true;
                             } else {
                                 return false;
                             }
                         }
                         //如果是dom节点
                         attributes = cur['attributes'];
                         for (k in delegateHooks) {
                             if (attribute = attributes[k]) {
                                 value = attribute['value' || 'nodeValue'];
                                 return {
                                     'rootNode': this,
                                     'elem': cur,
                                     'attribute': value,
                                     'pageType': pageType,
                                     'handlers': delegateHooks[k]
                                 };
                             }
                         }
                     }
                 } catch (err) {
                     // config.isBrowser && console.log('默认事件跟踪', err)
                 }
             }
         }

         /**
          * 判断处理那个页面层次
          * 找到pageType类型
          * 项目分4个层
          * page mater page浮动 mater浮动
          * 通过
          * 因为冒泡的元素，可能是页面层，也可能是母板上的
          * @return {Boolean} [description]
          */
         function isBelong(target) {
             var pageType = 'page';
             if (target.dataset && target.dataset.belong) {
                 pageType = target.dataset.belong;
             }
             return pageType;
         }

         /**
          * 阻止元素的默认行为
          * 在火狐下面image带有href的行为
          * 会自动触发另存为
          * @return {[type]} [description]
          *
          * 2016.3.18
          * 妙妙学 滚动插件默认行为被阻止
          */
         function preventDefault(evtObj, target) {
             //var tagName = target.nodeName.toLowerCase();
             if (Xut.plat.isBrowser && !Xut.IBooks.Enabled && !MMXCONFIG) {
                 evtObj.preventDefault && evtObj.preventDefault();
             }
         }

         /*********************************************************************
          *                对页面事件的调控与状态动作的处理
          *                1 触屏 onswipedown
          *                2 滑动 onSwipeMove
          *                3 松手 onSwipeUp
          *                3 松手继续滑动 onSwipeUpSlider
          *                4 动画结束后处理 onAnimComplete                                                                               *
          **********************************************************************/

         /**
          * 事件句柄对象
          */
         var handlerObj = null;

         /**
          * 过滤器.全局控制函数
          * return true 阻止页面滑动
          */
         $globalEvent.$watch('filter', function (hookCallback, point, evtObj) {
             var target, pageType, parentNode;
             target = point.target;
             //阻止默认行为
             preventDefault(evtObj, target);
             //页面类型
             pageType = isBelong(target);
             //根节点
             parentNode = $globalEvent.findRootElement(point, pageType);
             //执行过滤处理
             handlerObj = filterProcessor.call(parentNode, point, pageType);
             if (!handlerObj || handlerObj.attribute === 'disable') {
                 //停止翻页,针对content对象可以拖动,滑动的情况处理
                 hookCallback();
             }
         });

         /**
          * 触屏滑动,通知pageMgr处理页面移动
          * @return {[type]} [description]
          */
         $globalEvent.$watch('onSwipeMove', function () {
             $scheduler.move.apply($scheduler, arguments);
         });

         /**
          * 触屏松手点击
          * 无滑动
          */
         $globalEvent.$watch('onSwipeUp', function (pageIndex, hookCallback) {
             if (handlerObj) {
                 if (handlerObj.handlers) {
                     handlerObj.handlers(handlerObj.elem, handlerObj.attribute, handlerObj.rootNode, pageIndex);
                 } else {
                     if (!Xut.Contents.Canvas.getIsTap()) {
                         vm.$emit('change:toggleToolbar');
                     }
                 }
                 handlerObj = null;
                 hookCallback();
             }
         });

         /**
          * 触屏滑动,通知ProcessMgr关闭所有激活的热点
          * @return {[type]}          [description]
          */
         $globalEvent.$watch('onSwipeUpSlider', function (pointers) {
             $scheduler.suspend(pointers);
         });

         /**
          * 翻页动画完成回调
          * @return {[type]}              [description]
          */
         $globalEvent.$watch('onAnimComplete', function (direction, pagePointer, unfliplock, isQuickTurn) {
             $scheduler.complete.apply($scheduler, arguments);
         });

         /**
          * 切换页面
          * @return {[type]}      [description]
          */
         $globalEvent.$watch('onJumpPage', function (data) {
             $scheduler.jumpPage(data);
         });

         /**
          * 退出应用
          * @return {[type]}      [description]
          */
         $globalEvent.$watch('onDropApp', function (data) {
             GLOBALIFRAME && Xut.publish('magazine:dropApp');
         });

         /**
          * 母板移动反馈
          * 只有存在data-parallaxProcessed
          * 才需要重新激活对象
          * 删除parallaxProcessed
          */
         $globalEvent.$watch('onMasterMove', function (hindex, target) {
             if (/Content/i.test(target.id) && target.getAttribute('data-parallaxProcessed')) {
                 $scheduler.masterMgr && $scheduler.masterMgr.reactivation(target);
             }
         });

         vm.$overrideApi();
     }

     //***************************************************************
     //
     //                      应用接口
     //
     //***************************************************************

     var VMProto = Manager.prototype;

     /**
      * 扩充事件
      */
     observe.call(VMProto);

     /**
      * 是否多场景模式
      */
     defAccess(VMProto, '$multiScenario', {
         get: function get() {
             return this.options.multiScenario;
         }
     });

     /**
      * 动态注入对象接口
      * 注入对象管理,注册所有widget组件对象
      *  content类型  创建时注册
      *  widget类型   执行时注册
      *  widget 包括 视频 音频 Action 子文档 弹出口 类型
      *  这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
      */
     defAccess(VMProto, '$injectionComponent', {
         set: function set(regData) {
             var injection;
             if (injection = this.$scheduler[regData.pageType + 'Mgr']) {
                 injection.abstractAssistPocess(regData.pageIndex, function (pageObj) {
                     pageObj.baseRegisterComponent.call(pageObj, regData.widget);
                 });
             } else {
                 console.log('注册injection失败,regData=' + regData);
             }
         }
     });

     /**
      * 得到当前的视图页面
      * @return {[type]}   [description]
      */
     defAccess(VMProto, '$curVmPage', {
         get: function get() {
             return this.$scheduler.pageMgr.abstractGetPageObj(this.$globalEvent.hindex);
         }
     });

     /**
      *  监听viewmodel内部的状态的改变,触发后传入值
      *
      *  与状态有关的change:
      *      翻页
      *          'flipOver' : function(pageIndex) {},
      *
      *      切换工具栏
      *          'toggleToolbar' : function(state, pointer) {},
      *
      *      复位工具栏
      *          'resetToolbar'  : function() {},
      *
      *      隐藏下一页按钮
      *          'hideNext'   : function(state) {},
      *
      *      显示下一页按钮
      *          'showNext'   : function() {}
      *
      *  与创建相关
      *      创建完毕回调
      *          'createComplete': null,
      *      创建后中断自动运行回调
      *          'suspendAutoCallback': null
      *
      */
     def$1(VMProto, '$bind', function (key, callback) {
         var vm = this;
         vm.$watch('change:' + key, function () {
             callback.apply(vm, arguments);
         });
     });

     /**
      * 创建页面
      * @return {[type]} [description]
      */
     def$1(VMProto, '$init', function () {
         this.$scheduler.initCreate();
     });

     /**
      * 运动动画
      * @return {[type]} [description]
      */
     def$1(VMProto, '$run', function () {
         var vm = this;
         vm.$scheduler.pageMgr.activateAutoRuns(vm.$globalEvent.hindex, Xut.Presentation.GetPageObj());
     });

     /**
      * 复位对象
      * @return {[type]} [description]
      */
     def$1(VMProto, '$reset', function () {
         return this.$scheduler.pageMgr.resetOriginal(this.$globalEvent.hindex);
     });

     /**
      * 停止所有任务
      * @return {[type]} [description]
      */
     def$1(VMProto, '$suspend', function () {
         Xut.Application.Suspend({
             skipMedia: true //跨页面不处理
         });
     });

     /**
      * 销毁场景内部对象
      * @return {[type]} [description]
      */
     def$1(VMProto, '$destroy', function () {
         this.$off();
         this.$globalEvent.destroy();
         this.$scheduler.destroy();
         this.$scheduler = null;
         this.$globalEvent = null;
     });

     /**
      * 设置所有API接口
      * @return {[type]} [description]
      */
     def$1(VMProto, '$overrideApi', function () {
         overrideApi(this);
     });

     var config$6 = void 0;

     //========================场景容器,工具栏创建相关================================

     /**
      * 分解工具栏配置文件
      * @return {[type]}          [description]
      */
     function parseTooBar(toolbar, tbType, pageMode) {
     	if (toolbar = parseJSON(toolbar)) {
     		//兼容数据库中未指定的情况
     		var n = Number(toolbar.pageMode);
     		pageMode = _.isFinite(n) ? n : pageMode;
     		if (_.isString(toolbar.tbType)) {
     			tbType = _.map(toolbar.tbType.split(','), function (num) {
     				return Number(num);
     			});
     		}
     	}
     	return {
     		'tbType': tbType,
     		'pageMode': pageMode
     	};
     }

     /**
      * 主场景工具栏配置
      * pageMode:默认2 允许滑动,带翻页按钮
      * 
      * @param  {[type]} scenarioId [description]
      * @return {[type]}            [description]
      */
     function pMainBar(scenarioId) {
     	var sectionRang = Xut.data.query('sectionRelated', scenarioId),
     	    toolbar = sectionRang.toolbar,
     	    //场景工具栏配置信息
     	pagetotal = sectionRang.length,
     	    tbType = [1],
     	    //默认显示系统工具栏
     	pageMode = pagetotal > 1 ? 2 : 0; //默认2 允许滑动,带翻页按钮
     	return parseTooBar(toolbar, tbType, pageMode);
     }

     /**
      * 副场景工具栏配置
      * pageMode 是否支持滑动翻页  0禁止滑动 1允许滑动
      * tbType   工具栏显示的类型 [0-5]
      */
     function pDeputyBar(toolbar, pagetotal) {
     	var tbType = [0],
     	    pageMode = pagetotal > 1 ? 1 : 0;
     	return parseTooBar(toolbar, tbType, pageMode);
     }

     /**
      * 找到对应容器
      * @return {[type]}            [description]
      */
     function findContainer(elements, scenarioId, isMain) {
     	return function (pane, parallax) {
     		var node;
     		if (isMain) {
     			node = '#' + pane;
     		} else {
     			node = '#' + parallax + scenarioId;
     		}
     		return elements.find(node)[0];
     	};
     }

     /**
      * 如果启动了缓存记录
      * 加载新的场景
      * @return {[type]} [description]
      */
     function checkHistory(history) {

     	//直接启用快捷调试模式
     	if (config$6.deBugHistory) {
     		Xut.View.LoadScenario(config$6.deBugHistory);
     		return true;
     	}

     	//如果有历史记录
     	if (history) {
     		var scenarioInfo = sceneControll.seqReverse(history);
     		if (scenarioInfo) {
     			scenarioInfo = scenarioInfo.split('-');
     			Xut.View.LoadScenario({
     				'scenarioId': scenarioInfo[0],
     				'chapterId': scenarioInfo[1],
     				'pageIndex': scenarioInfo[2]
     			});
     			return true;
     		} else {
     			return false;
     		}
     	}
     }

     /**
      * 场景创建类
      * @param  {[type]} seasonId               [description]
      * @param  {[type]} chapterId              [description]
      * @param  {[type]} createCompleteCallback [创建完毕通知回调]
      * @param  {[type]} createMode             [创建模式]
      * @param  {[type]} sceneChainId           [场景ID链,用于后退按钮加载前一个场景]
      * @return {[type]}                        [description]
      */
     function SceneFactory(data) {

     	config$6 = Xut.config;

     	//基本配置信息
     	var seasonId = data.seasonId;
     	var chapterId = data.chapterId;

     	var options = _.extend(this, data, {
     		'scenarioId': seasonId,
     		'chapterId': chapterId,
     		'container': $('#sceneContainer')
     	});

     	//////////////
     	// 创建场景容器 //
     	//////////////
     	var complete = function complete() {
     		//配置工具栏行为
     		if (!Xut.IBooks.Enabled) {
     			_.extend(this, this.initToolBar());
     		}

     		//构件vm对象
     		this.createViewModel();

     		//注入场景管理
     		sceneControll.add(seasonId, chapterId, this);
     	};
     	this.createScenario(complete, options);
     }

     var sceneProto = SceneFactory.prototype;

     /**
      * 创建场景
      * @return {[type]} [description]
      */
     sceneProto.createScenario = function (callback, options) {

     	//如果是静态文件执行期
     	//支持Xut.IBooks模式
     	//都不需要创建节点
     	if (Xut.IBooks.runMode()) {
     		this.elements = $('#sceneHome');
     		callback.call(this);
     		return;
     	}

     	var elements,
     	    str,
     	    self = this;
     	if (options.isMain) {
     		str = home();
     	} else {
     		str = scene(this.scenarioId);
     	}

     	//创建场景容器
     	elements = this.elements = $(str);
     	Xut.nextTick({
     		'container': self.container,
     		'content': elements
     	}, function () {
     		callback.call(self);
     	});
     };

     /**
      * 
      * 配置工具栏行为
      *	1.	工具栏类型 
      *	tbType：(如果用户没有选择任何工具栏信息处理，tbType字段就为空)
      *	 0	禁止工具栏
      *	 1	系统工具栏   - 显示IOS系统工具栏
      *	 2	场景工具栏   - 显示关闭按钮
      *	 3	场景工具栏   - 显示返回按钮
      *	 4	场景工具栏   - 显示顶部小圆点式标示
      *
      *	2.	翻页模式
      *	pageMode：(如果用户没有选择任何处理，pageMode字段就为空)
      *	 0禁止滑动
      *	 1 允许滑动无翻页按钮
      *	 2 允许滑动带翻页按钮
      *
      * @return {[type]} [description]
      */
     sceneProto.initToolBar = function () {
     	var scenarioId = this.scenarioId;
     	var pageTotal = this.pageTotal;
     	var pageIndex = this.pageIndex;
     	var elements = this.elements;
     	var bar;
     	var findControlBar = function findControlBar() {
     		return elements.find('#controlBar');
     	};

     	/**
       * 主场景工具栏设置
       */
     	if (this.isMain) {
     		bar = pMainBar(scenarioId, pageTotal);
     		if (config$6.scrollPaintingMode) {
     			//word模式,自动启动工具条
     			this.sToolbar = new Bar({
     				container: elements,
     				controlBar: findControlBar(),
     				pageMode: bar.pageMode
     			});
     		} else if (_.some(bar.tbType)) {
     			//普通模式
     			this.sToolbar = new sToolbar({
     				container: elements,
     				controlBar: findControlBar(),
     				pageTotal: pageTotal,
     				currentPage: pageIndex + 1,
     				pageMode: bar.pageMode
     			});
     		}
     	} else {
     		/**
        * 副场景
        * @type {[type]}
        */
     		bar = pDeputyBar(this.barInfo, pageTotal);
     		//创建工具栏
     		if (bar) {
     			this.cToolbar = new fToolbar({
     				id: scenarioId,
     				container: elements,
     				tbType: bar.tbType,
     				pageTotal: pageTotal,
     				currentPage: pageIndex,
     				pageMode: bar.pageMode
     			});
     		}
     	}

     	return bar;
     };

     /**
      * 构建创建对象
      * @return {[type]} [description]
      */
     sceneProto.createViewModel = function () {

     	var self = this;
     	var scenarioId = this.scenarioId;
     	var pageTotal = this.pageTotal;
     	var pageIndex = this.pageIndex;
     	var elements = this.elements;
     	var pageMode = this.pageMode;
     	var isMain = this.isMain;
     	var tempfind = findContainer(elements, scenarioId, isMain);
     	//页面容器
     	var scenarioPage = tempfind('pageContainer', 'scenarioPage-');
     	//视差容器
     	var scenarioMaster = tempfind('masterContainer', 'scenarioMaster-');

     	//场景容器对象
     	var vm = this.vm = new Manager({
     		'container': this.elements[0],
     		'pageMode': pageMode,
     		'multiScenario': !isMain,
     		'rootPage': scenarioPage,
     		'rootMaster': scenarioMaster,
     		'initIndex': pageIndex, //保存索引从0开始
     		'pagetotal': pageTotal,
     		'sectionRang': this.sectionRang,
     		'scenarioId': scenarioId,
     		'chapterId': this.chapterId,
     		'isInApp': this.isInApp //提示页面
     	});

     	/**
       * 配置选项
       * @type {[type]}
       */
     	var isToolbar = this.isToolbar = this.cToolbar ? this.cToolbar : this.sToolbar;

     	/**
       * 监听翻页
       * 用于更新页码
       * @return {[type]} [description]
       */
     	vm.$bind('pageUpdate', function (pageIndex) {
     		isToolbar && isToolbar.updatePointer(pageIndex);
     	});

     	/**
       * 显示下一页按钮
       * @return {[type]} [description]
       */
     	vm.$bind('showNext', function () {
     		isToolbar && isToolbar.showNext();
     	});

     	/**
       * 隐藏下一页按钮
       * @return {[type]} [description]
       */
     	vm.$bind('hideNext', function () {
     		isToolbar && isToolbar.hideNext();
     	});

     	/**
       * 显示上一页按钮
       * @return {[type]} [description]
       */
     	vm.$bind('showPrev', function () {
     		isToolbar && isToolbar.showPrev();
     	});

     	/**
       * 隐藏上一页按钮
       * @return {[type]} [description]
       */
     	vm.$bind('hidePrev', function () {
     		isToolbar && isToolbar.hidePrev();
     	});

     	/**
       * 切换工具栏
       * @return {[type]} [description]
       */
     	vm.$bind('toggleToolbar', function (state, pointer) {
     		isToolbar && isToolbar.toggle(state, pointer);
     	});

     	/**
       * 复位工具栏
       * @return {[type]} [description]
       */
     	vm.$bind('resetToolbar', function () {
     		self.sToolbar && self.sToolbar.reset();
     	});

     	/**
       * 监听创建完成
       * @return {[type]} [description]
       */
     	vm.$bind('createComplete', function (nextAction) {
     		self.complete && setTimeout(function () {
     			if (isMain) {
     				self.complete(function () {
     					Xut.View.HideBusy();
     					//检测是不是有缓存加载
     					if (!checkHistory(self.history)) {
     						//指定自动运行的动作
     						nextAction && nextAction();
     					}
     					//全局接口,应用加载完毕
     					Xut.Application.AddEventListener();
     				});
     			} else {
     				self.complete(nextAction);
     			}
     		}, 200);
     	});

     	//如果是读酷端加载
     	if (DUKUCONFIG && isMain && DUKUCONFIG.success) {
     		DUKUCONFIG.success();
     		vm.$init();
     		//如果是客户端加载
     	} else if (CLIENTCONFIGT && isMain && CLIENTCONFIGT.success) {
     			CLIENTCONFIGT.success();
     			vm.$init();
     		} else {
     			//正常加载
     			vm.$init();
     		}

     	/**
       * 绑定桌面调试
       */
     	config$6.debugMode && Xut.plat.isBrowser && this.bindWatch();
     };

     /**
      * 为桌面测试
      * 绑定调试
      * @return {[type]} [description]
      */
     sceneProto.bindWatch = function () {
     	// for test
     	if (Xut.plat.isBrowser) {
     		var vm = this.vm;
     		this.testWatch = $(".xut-controlBar-pageNum").click(function () {
     			console.log('主场景', vm);
     			console.log('主场景容器', vm.$scheduler.pageMgr.Collections);
     			console.log('主场景视觉差容器', vm.$scheduler.parallaxMgr && vm.$scheduler.parallaxMgr.Collections);
     			console.log('多场景', sceneControll.expose());
     			console.log('音频', Xut.AudioManager);
     			console.log('视频', Xut.VideoManager);
     			console.log('数据库', Xut.data);
     		});
     	}
     };

     //=============================退出处理,销毁=============================================

     /**
      * 销毁场景对象
      * @return {[type]} [description]
      */
     sceneProto.destroy = function () {
     	/**
       * 桌面调试
       */
     	if (this.testWatch) {
     		this.testWatch.off();
     		this.testWatch = null;
     	}

     	/**
       * 销毁当前场景
       */
     	this.vm.$destroy();

     	/**
       * 销毁工具栏
       */
     	if (this.isToolbar) {
     		this.isToolbar.destroy();
     		this.isToolbar = null;
     	}

     	this.container = null;

     	//销毁节点
     	this.elements.off();
     	this.elements.remove();
     	this.elements = null;

     	//销毁引用
     	sceneControll.remove(this.scenarioId);
     };

     var config$3 = Xut.config;
     var plat = Xut.plat;
     var LOCK = 1;
     var UNLOCK = 2;
     var IsPay = false;
     //

     /**
      * 代码注入空间
      * @type {Object}
      */
     var external = {};

     /**
      * 桌面绑定鼠标控制
      */
     if (plat.isBrowser) {
         $(document).keyup(function (event) {
             switch (event.keyCode) {
                 case 37:
                     Xut.View.GotoPrevSlide();
                     break;
                 case 39:
                     Xut.View.GotoNextSlide();
                     break;
             }
         });
     }

     //================================================
     //
     //              电子杂志所有接口
     //
     //=================================================
     Xut.Assist = {};
     var Presentation = Xut.Presentation = {};
     var _View = Xut.View = {};
     var Contents = Xut.Contents = {};
     var Application = Xut.Application = {};

     /**
      * 忙碌光标
      * */
     portExtend(_View, {

         busyBarState: false,

         //忙碌光标的引用
         busyIcon: null,

         ShowBusy: function ShowBusy() {
             if (Xut.IBooks.Enabled) return;
             _View.busyBarState = true;
             _View.busyIcon.show();
         },

         HideBusy: function HideBusy() {
             if (Xut.IBooks.Enabled) return;
             var busyIcon = _View.busyIcon;
             if (_View.ShowBusy.lock) return; //显示忙碌加锁，用于不处理hideBusy
             _View.busyBarState = false;
             busyIcon.hide();
             IsPay && busyIcon.css('pointer-events', '').find('.xut-busy-text').html('');
         },

         ShowTextBusy: function ShowTextBusy(txt) {
             if (Xut.IBooks.Enabled) return;
             _View.busyIcon.css('pointer-events', 'none').find('.xut-busy-text').html(txt);
             _View.ShowBusy();
         }
     });

     /**
      * [检查是否购买]
      **/
     function CheckBuyGood(seasonId, chapterId, createMode, pageIndex) {
         //已付费
         if (IsPay) {
             return false;
         }

         try {
             var data = Xut.data.query('sectionRelated', seasonId).toolbar,
                 item = [];
             data = JSON.parse(data);
             //判断是否免费章节
             if (!data.Inapp) {
                 return false;
             }
             //判断是否交费
             if (UNLOCK == data.Inapp || UNLOCK == _get(inAppId)) {
                 setUnlock();
                 return false;
             }
             //判断是否收费章节
             if (LOCK == data.Inapp && data.inappInfo) {
                 item = _.map(data.inappInfo.split('-'), function (num) {
                     return Number(num);
                 });
                 //收费提示页
                 if (item[0] == chapterId && item[1] == seasonId) {
                     return false;
                 } else {
                     _View.LoadScenario({
                         'scenarioId': item[1],
                         'chapterId': item[0],
                         'createMode': createMode,
                         'pageIndex': pageIndex,
                         'isInApp': 'isInApp'
                     });
                 }
             }
         } catch (e) {
             console.log('Data error:', e);
         }
         return true;
     }

     //重复点击
     var repeatClick = false;

     /**
      * 场景
      * */
     portExtend(_View, {

         /**
          * 关闭场景
          */
         CloseScenario: function CloseScenario() {
             if (repeatClick) return;
             repeatClick = true;
             var serial = sceneControll.takeOutPrevChainId();
             _View.LoadScenario({
                 'scenarioId': serial.scenarioId,
                 'chapterId': serial.chapterId,
                 'createMode': 'sysClose'
             }, function () {
                 repeatClick = false;
             });
         },

         /**
          * 加载一个新的场景
          * 1 节与节跳
          *    单场景情况
          *    多场景情况
          * 2 章与章跳
          * useUnlockCallBack 用来解锁回调,重复判断
          * isInApp 是否跳转到提示页面
          */
         LoadScenario: function LoadScenario(options, useUnlockCallBack) {

             var seasonId = toNumber(options.scenarioId),
                 chapterId = toNumber(options.chapterId),
                 pageIndex = toNumber(options.pageIndex),
                 createMode = options.createMode,
                 isInApp = options.isInApp;

             //ibooks模式下的跳转
             //全部转化成超链接
             if (!options.main && Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
                 location.href = chapterId + ".xhtml";
                 return;
             }

             //检查应用内是否收费
             if (current && CheckBuyGood(seasonId, chapterId, createMode, pageIndex)) {
                 //未交费
                 return false;
             }

             //处理场景跳转
             var sceneController = sceneControll,

             //用户指定的跳转入口，而不是通过内部关闭按钮处理的
             userAssign = createMode === 'sysClose' ? false : true,

             //当前活动场景容器对象
             current = sceneController.containerObj('current');

             //获取到当前的页面对象
             //用于跳转去重复
             if (current && current.vm) {
                 var curVmPage;
                 if (curVmPage = current.vm.$curVmPage) {
                     if (curVmPage.scenarioId == seasonId && curVmPage.chapterId == chapterId) {
                         console.log('无效的重复触发');
                         return;
                     }
                 }
             }

             //==================场景内部跳转===============================
             //
             //  节相同，章与章的跳转
             //  用户指定跳转模式,如果目标对象是当前应用页面，按内部跳转处理
             //
             //=============================================================
             if (userAssign && current && current.scenarioId === seasonId) {
                 _View.GotoSlide(seasonId, chapterId);
                 return;
             }

             //==================场景外部跳转===============================
             //
             //  节与节的跳转,需要对场景的处理
             //
             //=============================================================

             //清理热点动作
             current && current.vm.$suspend();

             //通过内部关闭按钮加载新场景处理
             if (current && userAssign) {
                 //检测是不是往回跳转,重复处理
                 sceneController.checkToRepeat(seasonId);
             }

             //================加载新的场景=================

             //读酷启动时不需要忙碌光标
             if (DUKUCONFIG && options.main) {
                 Xut.View.HideBusy();
             } else {
                 Xut.View.ShowBusy();
             }

             /**
              * 跳出去
              * $multiScenario
              * 场景模式
              * $multiScenario
              *      true  多场景
              *      false 单场景模式
              * 如果当前是从主场景加载副场景
              * 关闭系统工具栏
              */
             if (current && !current.vm.$multiScenario) {
                 _View.HideToolbar();
             }

             /**
              * 重写场景的顺序编号
              * 用于记录场景最后记录
              */
             var pageId;
             if (current && (pageId = Xut.Presentation.GetPageId())) {
                 sceneController.rewrite(current.scenarioId, pageId);
             }

             /**
              * 场景信息
              * @type {[type]}
              */
             var sectionRang = Xut.data.query('sectionRelated', seasonId);
             var barInfo = sectionRang.toolbar,
                 //场景工具栏配置信息
             pageTotal = sectionRang.length,

             //通过chapterId转化为实际页码指标
             //season 2
             //       {
             //          chapterId : 1  => 0
             //          chpaterId : 2  => 1
             //       }
             //
             parseInitIndex = function parseInitIndex() {
                 return chapterId ? function () {
                     //如果节点内部跳转方式加载,无需转化页码
                     if (createMode === 'GotoSlide') {
                         return chapterId;
                     }
                     //初始页从0开始，减去下标1
                     return chapterId - sectionRang.start - 1;
                 }() : 0;
             };

             //如果启动了虚拟模式
             if (config$3.virtualMode) {
                 pageTotal = pageTotal * 2;
             }

             /**
              * 传递的参数
              * seasonId    节ID
              * chapterId   页面ID
              * pageIndex   指定页码
              * isInApp     是否跳到收费提示页
              * pageTotal   页面总数
              * barInfo     工具栏配置文件
              * history     历史记录
              * sectionRang 节信息
              * complete    构件完毕回调
              * @type {Object}
              */
             var data = {
                 seasonId: seasonId,
                 chapterId: chapterId,
                 pageIndex: pageIndex || parseInitIndex(),
                 isInApp: isInApp,
                 pageTotal: pageTotal,
                 barInfo: barInfo,
                 history: options.history,
                 sectionRang: sectionRang,
                 //制作场景切换后处理
                 complete: function complete(nextBack) {
                     //销毁多余场景
                     current && current.destroy();
                     //下一个任务存在,执行切换回调后,在执行页面任务
                     nextBack && nextBack();
                     //去掉忙碌
                     _View.HideBusy();
                     //解锁回调
                     useUnlockCallBack && useUnlockCallBack();
                 }
             };

             //主场景判断（第一个节,因为工具栏的配置不同）
             if (options.main || sceneController.mianId === seasonId) {
                 //清理缓存
                 _remove$1("history");
                 //确定主场景
                 sceneController.mianId = seasonId;
                 //是否主场景
                 data.isMain = true;
             }
             new SceneFactory(data);
         }
     });

     /**
      * 行为
      * */
     portExtend(_View, {
         /**
          * 通过插件打开一个新view窗口
          */
         Open: function Open(pageUrl, width, height, left, top) {
             Xut.Plugin.WebView.open(pageUrl, left, top, height, width, 1);
         },

         //关闭view窗口
         Close: function Close() {
             Xut.Plugin.WebView.close();
         }
     });

     /**
      * content
      * */
     portExtend(Contents, {

         //存在文档碎片
         //针对音频字幕增加的快捷查找
         contentsFragment: {},

         /**
          * 是否为canvas元素
          * 用来判断事件冒泡
          * 判断当前元素是否支持滑动
          * 默认任何元素都支持滑动
          * @type {Boolean}
          */
         Canvas: {

             /**
              * 是否允许滑动
              * @type {Boolean}
              */
             SupportSwipe: true,

             /**
              * 对象是否滑动
              * @type {Boolean}
              */
             isSwipe: false,

             /**
              * 对象是否点击
              */
             isTap: false,

             /**
              * 复位标记
              */
             Reset: function Reset() {
                 Contents.Canvas.SupportSwipe = true;
                 Contents.Canvas.isSwipe = false;
             },

             /**
              * 判断是否可以滑动
              * @return {[type]} [description]
              */
             getSupportState: function getSupportState() {
                 var state;
                 if (Contents.Canvas.SupportSwipe) {
                     state = true;
                 } else {
                     state = false;
                 }
                 //清空状态
                 Contents.Canvas.Reset();
                 return state;
             },

             /**
              * 判断是否绑定了滑动事件
              * @return {Boolean} [description]
              */
             getIsSwipe: function getIsSwipe() {
                 var state;
                 if (Contents.Canvas.isSwipe) {
                     state = true;
                 } else {
                     state = false;
                 }
                 //清空状态
                 Contents.Canvas.Reset();
                 return state;
             },

             /**
              * 是否绑定了点击事件
              */
             getIsTap: function getIsTap() {
                 var state = Contents.Canvas.isTap;
                 Contents.Canvas.isTap = false;
                 return state;
             }
         },

         /**
          * 恢复节点的默认控制
          * 默认是系统接管
          * 如果'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'等事件会重写
          * 还需要考虑第三方调用，所以需要给一个重写的接口
          * @return {[type]} [description]
          * Content_1_3
          * [Content_1_3,Content_1_4,Content_1_5]
          */
         ResetDefaultControl: function ResetDefaultControl(pageType, id, value) {
             if (!id) return;
             var elements,
                 handle = function handle(ele) {
                 if (value) {
                     ele.attr('data-behavior', value);
                 } else {
                     ele.attr('data-behavior', 'disable');
                 }
             };
             if ((elements = Contents.Get(pageType, id)) && elements.$contentProcess) {
                 handle(elements.$contentProcess);
             } else {
                 elements = $("#" + id);
                 elements.length && handle(elements);
             }
         },

         /**
          * 针对SVG无节点操作
          * 关闭控制
          */
         DisableControl: function DisableControl(callback) {
             return {
                 behavior: 'data-behavior',
                 value: 'disable'
             };
         },

         /**
          * 针对SVG无节点操作
          * 启动控制
          */
         EnableControl: function EnableControl(Value) {
             return {
                 behavior: 'data-behavior',
                 value: Value || 'click-swipe'
             };
         }
     });

     function getStorage(name) {
         return parseInt(_get(name));
     }

     /**
      * [ 执行解锁]
      * @return {[type]} [description]
      */
     function setUnlock() {
         IsPay = true;
     }

     //购买成功
     function pass() {
         //如果提前关闭了忙碌光标说明被用户中止
         if (!_View.busyBarState) return;
         //将购买记录存入数据库
         var db = config$3.db,
             sql = 'UPDATE Setting SET value=? WHERE name=?';

         db.transaction(function (tx) {
             tx.executeSql(sql, [null, 'Inapp']);
         }, function (e) {
             _set(inAppId, UNLOCK);
         });

         setUnlock();
         _View.CloseScenario();
         _View.HideBusy();
     }

     //购买失败
     function failed() {
         if (!_View.busyBarState) return;
         messageBox('购买失败');
         _View.HideBusy();
     }

     portExtend(Application, {

         /**
          * 应用平台
          * @type {[type]}
          */
         Platform: function () {
             //平台缩写
             var platformName = ['duku', 'pc', 'ios', 'android'];
             if (GLOBALIFRAME) {
                 //嵌套iframe平台
                 return platformName[0];
             } else {
                 if (config$3.isBrowser) {
                     return platformName[1];
                 } else if (Xut.plat.isIOS) {
                     return platformName[2];
                 } else if (Xut.plat.isAndroid) {
                     return platformName[3];
                 }
             }
         }(),

         /**
          * [ 锁状态]
          * @return {[type]} [description]
          */
         Unlock: function Unlock() {
             return IsPay;
         },

         /**
          * [ 检查是否解锁]
          * @return {[type]}       [description]
          */
         CheckOut: function CheckOut() {
             var Inapp = config$3.Inapp;
             if (!Inapp || _get(Inapp) === UNLOCK || Xut.plat.isAndroid) {
                 setUnlock();
             }
         },

         /**
          * [ 付费接口]
          * @param  {[type]} seasonId   [description]
          * @param  {[type]} chapterId  [description]
          * @param  {[type]} createMode [description]
          * @param  {[type]} pageIndex  [description]
          * @return {[type]}            [description]
          */
         BuyGood: function BuyGood() {
             var inAppId = config$3.Inapp;
             if (_View.busyBarState) return;
             _View.ShowTextBusy('请稍候...');
             //调式模式
             if (plat.isBrowser) {
                 setTimeout(function () {
                     pass();
                 }, 3000);
                 return;
             }
             //从AppStore查询是否交费
             Xut.Plugin.iapPlugin.selectInfo(function () {
                 pass(); //查询成功则表明已购买
             }, function () {
                 //否则提示购买
                 Xut.Plugin.iapPlugin.buyGood(function () {
                     pass();
                 }, function (e) {
                     failed();
                 }, inAppId);
             }, inAppId);
         },

         /**
          * 已付费接口
          * @return {[type]} [description]
          */
         HasBuyGood: function HasBuyGood() {
             var inAppId = config$3.Inapp;
             if (_View.busyBarState) return;
             _View.ShowTextBusy('请稍候...');
             //调式模式
             if (plat.isBrowser) {
                 setTimeout(function () {
                     pass();
                 }, 3000);
                 return;
             }

             Xut.Plugin.iapPlugin.restore(function () {
                 pass(); //查询成功则表明已购买
             }, function () {
                 failed();
             }, inAppId);
         },

         /**
          * 刷新页面
          */
         Resize: function Resize() {

             //清理对象
             sceneControll.destroyAllScene();

             //清理节点
             $("#sceneContainer").empty();

             //加载新的页面
             var novelId,
                 pageIndex = getStorage('pageIndex');

             //缓存加载
             if (pageIndex !== void 0) {
                 novelId = getStorage("novelId");
                 //加强判断
                 if (novelId) {
                     loadScene({
                         "novelId": novelId,
                         "pageIndex": pageIndex,
                         'history': _get('history')
                     });
                 };
             }
         },

         /**
          * home隐藏
          * 后台运行的时候,恢复到初始化状态
          * 用于进来的时候激活Activate
          */
         Original: function Original() {
             _suspend();
             _original();
         },

         /**
          * home显示
          * 后台弹回来
          * 激活应用行为
          */
         Activate: function Activate() {
             _autoRun();
         },

         /**
          * 销毁应用
          */
         Destroy: function Destroy() {
             if (plat.isBrowser) {
                 //销毁桌面控制
                 $(document).off();
             }
             //销毁所有场景
             sceneControll.destroyAllScene();
         },

         /**
          * 退出app
          */
         DropApp: function DropApp() {
             //如果读酷
             if (DUKUCONFIG) {
                 //外部回调通知
                 if (DUKUCONFIG.iframeDrop) {
                     var appId = _get('appId');
                     DUKUCONFIG.iframeDrop(['appId-' + appId, 'novelId-' + appId, 'pageIndex-' + appId]);
                 }
                 DUKUCONFIG = null;
                 unEvent();
                 destroy();
                 return;
             }

             //客户端模式
             if (CLIENTCONFIGT) {
                 //外部回调通知
                 if (CLIENTCONFIGT.iframeDrop) {
                     CLIENTCONFIGT.iframeDrop();
                 }
                 CLIENTCONFIGT = null;
                 unEvent();
                 destroy();
                 return;
             }

             //妙妙学客户端
             if (MMXCONFIG) {
                 //外部回调通知
                 if (MMXCONFIG.iframeDrop) {
                     MMXCONFIG.iframeDrop();
                 }
                 MMXCONFIG = null;
                 destroy();
                 return;
             }

             function unEvent() {
                 //并且是安卓情况下
                 //安卓销毁按键事件
                 if (Xut.plat.isAndroid) {
                     GLOBALCONTEXT.document.removeEventListener("backbutton", config$3._event.back, false);
                     GLOBALCONTEXT.document.removeEventListener("pause", config$3._event.pause, false);
                 }
             }

             //iframe模式,退出处理
             function destroy() {
                 //销毁内存对象
                 Application.Destroy();
                 GLOBALCONTEXT = null;
             }

             //单应用dialogs
             if (!plat.isBrowser) {
                 GLOBALCONTEXT.navigator.notification.confirm('您确认要退出吗？', function (button) {
                     if (1 == button) {
                         GLOBALCONTEXT.navigator.app.exitApp();
                     }
                 }, '退出', ['确定', '取消']);
             }
         },

         /**
          * 暂停应用
          * skipMedia 跳过音频你处理(跨页面)
          * dispose   成功处理回调
          * processed 处理完毕回调
          */
         Suspend: function Suspend(opts) {
             if (suspendHandles(opts.skipMedia)) {
                 //停止热点动作
                 if (opts.dispose) {
                     opts.dispose(promptMessage);
                 }
             } else {
                 opts.processed && opts.processed();
             }
         },

         //============================================================
         //
         //  注册所有组件对象
         //
         //  2 widget 包括 视频 音频 Action 子文档 弹出口 类型
         //    这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
         //
         injectionComponent: function injectionComponent(regData) {
             var sceneObj = sceneControll.containerObj('current');
             sceneObj.vm.$injectionComponent = regData;
         }
     });

     portExtend(Application, {

         /**
          * 应用加载状态
          * false未加载
          * true 已加载
          * @type {Boolean}
          */
         appState: false,

         setAppState: function setAppState() {
             Application.appState = true;
         },

         delAppState: function delAppState() {
             Application.appState = false;
         },

         /**
          * 获取应用加载状态
          * @return {[type]} [description]
          */
         getAppState: function getAppState() {
             return Application.appState;
         },

         /**
          * 延时APP运用
          * 一般是在等待视频先加载完毕
          * @return {[type]} [description]
          */
         delayAppRun: function delayAppRun() {
             Application.setAppState();
         },

         /**
          * 启动app
          * 重载启动方法
          * 如果调用在重载之前，就删除，
          * 否则被启动方法重载
          * @type {[type]}
          */
         LaunchApp: function LaunchApp() {
             Application.delAppState();
         },

         /**
          * 应用加载完毕
          */
         AddEventListener: function AddEventListener() {}
     });

     //========================================================
     //
     //          脚本注入接口
     //
     //========================================================

     external = {

         /**
                读取系统中保存的变量的值。
                如果变量不存在，则新建这个全局变量
                如果系统中没有保存的值，用默认值进行赋值
                这个函数，将是创建全局变量的默认函数。
              */
         ReadVar: function ReadVar(variable, defaultValue) {
             var temp;
             if (temp = _get(variable)) {
                 return temp;
             } else {
                 _set(variable, defaultValue);
                 return defaultValue;
             }
         },

         /**
          * 将变量的值保存起来
          */
         SaveVar: function SaveVar(variable, value) {
             _set(variable, value);
         },

         /*
                对变量赋值，然后保存变量的值
                对于全局变量，这个函数将是主要使用的，替代简单的“=”赋值
              */
         SetVar: function SetVar(variable, value) {
             _set(variable, value);
         }

     };

     /**
      * u3d接口
      */
     Xut.U3d = {
         /**
          * 跳转接口
          * @param {[type]} seasonId  [description]
          * @param {[type]} chapterId [description]
          */
         View: function View(seasonId, chapterId) {
             _View.LoadScenario({
                 'scenarioId': serial.scenarioId,
                 'chapterId': serial.chapterId
             });
         }
     };

     //导出注入接口
     window.XXTAPI = external;

     /**
      * content对象的创建过滤器
      * 用于阻断对象的创建
      */
     function contentFilter(filterName) {

         //过滤的节点
         var listFilters = function () {
             var values = getCache();
             var h = hash();
             if (values) {
                 //keep the listFilters has no property
                 _.each(values, function (v, i) {
                     h[i] = v;
                 });
             }
             return h;
         }();

         function setCache(listFilters) {
             _save(filterName, listFilters);
         }

         function getCache() {
             var jsonStr = _get(filterName);
             return parseJSON(jsonStr);
         }

         function access(callback, pageId, contentId) {
             //如果是transformFilter,不需要pageIndex处理
             if (filterName === 'transformFilter' && contentId === undefined) {
                 contentId = pageId;
                 pageId = 'transformFilter';
             }
             return callback(pageId, Number(contentId));
         }

         return {
             add: function add(pageId, contentId) {
                 access(function (pageId, contentId) {
                     if (!listFilters[pageId]) {
                         listFilters[pageId] = [];
                     }
                     //去重
                     if (-1 === listFilters[pageId].indexOf(contentId)) {
                         listFilters[pageId].push(contentId);
                         setCache(listFilters);
                     }
                 }, pageId, contentId);
             },

             remove: function remove(pageId, contentId) {
                 access(function (pageId, contentId) {
                     var target = listFilters[pageId] || [],
                         index = target.indexOf(contentId);
                     if (-1 !== index) {
                         target.splice(index, 1);
                         setCache(listFilters);
                     }
                 }, pageId, contentId);
             },

             has: function has(pageId, contentId) {
                 return access(function (pageId, contentId) {
                     var target = listFilters[pageId];
                     return target ? -1 !== target.indexOf(contentId) ? true : false : false;
                 }, pageId, contentId);
             },

             /**
              * 创建过滤器
              * @param  {[type]} pageId [description]
              * @return {[type]}        [description]
              */
             each: function each(pageId) {
                 return access(function (pageId, contentId) {
                     var target, indexOf;
                     if (target = listFilters[pageId]) {
                         return function (contentIds, callback) {
                             _.each(target, function (ids) {
                                 var indexOf = contentIds.indexOf(ids);
                                 if (-1 !== indexOf) {
                                     callback(indexOf); //如果找到的过滤项目
                                 }
                             });
                         };
                     }
                 }, pageId);
             },

             //过滤器数量
             size: function size() {
                 return _.keys(listFilters).length;
             },

             empty: function empty() {
                 _remove(filterName);
                 listFilters = {};
             }
         };
     };

     var config$2 = void 0;

     function getCache(name) {
         return parseInt(_get(name));
     }

     /**
      * 进入主页面
      * @return {[type]} [description]
      */
     function initMain(novelData) {

         var novelId,
             parameter,
             pageIndex = getCache('pageIndex'),
             pageFlip = getCache('pageFlip') || 0;

         /**
          * IBOOS模式
          */
         if (Xut.IBooks.Enabled) {
             //删除背景图
             $("#removelayer").remove();
             LoadScene({
                 "pageIndex": Xut.IBooks.CONFIG.pageIndex
             });
             return;
         }

         /**
          * 多模式判断
          * 全局翻页模式
          * 0 滑动翻页
          * 1 直接换
          * 所以pageFlip只有在左面的情况下
          */
         if (parameter = novelData.parameter) {
             //拿出pageflip的值
             parameter = parseJSON(parameter);
             //获取pageflip的值得
             //pageflip用来标
             //不能翻页
             //直接切换模式
             pageFlip = parameter.pageflip;
             if (pageFlip !== undefined) {
                 //设置缓存
                 _set({
                     'pageFlip': pageFlip
                 });
             }
         }

         //缓存加载
         //如果启动recordHistory记录
         if (config$2.recordHistory && pageIndex !== undefined) {
             //加强判断
             if (novelId = getCache("novelId")) {
                 return loadScene({
                     'pageFlip': pageFlip,
                     "novelId": novelId,
                     "pageIndex": pageIndex,
                     'history': _get('history')
                 });
             }
         }

         //第一次加载
         //没有缓存
         loadScene({
             "novelId": novelData._id,
             "pageIndex": 0,
             'pageFlip': pageFlip
         });
     };

     /**
      * 根据set表初始化数据
      * @return {[type]} [description]
      */
     function initValue() {
         createStore().done(function (setData, novelData) {
             initDefaults(setData);
             fixedSize(novelData);
             initMain(novelData);
         });
     };

     /**
      * 配置默认数据
      * @return {[type]} [description]
      */
     function initDefaults(setData) {
         var rs,
             data = {},
             cfg = {},

         //工具栏默认参数
         defaults = {
             ToolbarPos: 0, //工具栏[0顶部,1底部]
             NavbarPos: 1, //左右翻页按钮[0顶部, 1中间, 2底部]
             HomeBut: 1, //主页按钮[0不显示,1显示]
             ContentBut: 1, //目录按钮[0不显示,1显示]
             PageBut: 1, //页码按钮[0不显示,1显示]
             NavLeft: 1, //左翻页按钮[0不显示,1显示]
             NavRight: 1, //右翻页按钮[0不显示,1显示]
             customButton: 0, //自定义翻页按钮
             CloseBut: SUbDOCCONTEXT ? 1 : 0 //关闭按钮[0不显示,1显示]
         };

         for (var i = 0, len = setData.length; i < len; i++) {
             rs = setData.item(i);
             data[rs.name] = rs.value;
         }

         _.defaults(data, defaults);

         for (i in defaults) {
             cfg[i] = Number(data[i]);
         }

         config$2.settings = cfg;
         config$2.appId = data.appId; //应用配置唯一标示符
         config$2.shortName = data.shortName;
         config$2.Inapp = data.Inapp; //是否为应用内购买

         //应用的唯一标识符
         //生成时间+appid
         config$2.appUUID = data.adUpdateTime ? data.appId + '-' + /\S*/.exec(data.adUpdateTime)[0] : data.adUpdateTime;

         //检查是否解锁
         Xut.Application.CheckOut();

         //资源路径配置
         config$2.initResourcesPath();

         //缓存应用ID
         _set({
             'appId': data.appId
         });

         //新增模式,用于记录浏览器退出记录
         cfgHistory(data);

         //广告Id
         //2014.9.2
         Xut.Presentation.AdsId = data.adsId;

         //2015.2.26
         //启动画轴模式
         //防止是布尔0成立
         if (data.scrollPaintingMode && data.scrollPaintingMode == 1) {
             config$2.scrollPaintingMode = true;
         }

         //假如启用了画轴模式，看看是不是竖版的情况，需要切半模版virtualMode
         if (config$2.scrollPaintingMode) {
             if (config$2.screenSize.width < config$2.screenSize.height) {
                 config$2.virtualMode = true;
             }
         }

         //创建过滤器
         Xut.CreateFilter = contentFilter('createFilter');
         Xut.TransformFilter = contentFilter('transformFilter');
     }

     //新增模式,用于记录浏览器退出记录
     //默认启动
     //是否回到退出的页面
     //set表中写一个recordHistory
     //是   1
     //否   0
     function cfgHistory(data) {

         var recordHistory = 1; //默认启动
         if (data.recordHistory !== undefined) {
             recordHistory = Number(data.recordHistory);
         }

         //如果启动桌面调试模式
         //自动打开缓存加载
         if (!recordHistory && config$2.isBrowser && config$2.debugMode) {
             recordHistory = 1;
         }

         config$2.recordHistory = recordHistory;
     }

     /**
      * 修正尺寸
      * 修正实际分辨率
      * @return {[type]} [description]
      */
     function fixedSize(novelData) {
         if (novelData) {
             if (novelData.pptWidth || novelData.pptHeight) {
                 config$2.setProportion(novelData.pptWidth, novelData.pptHeight);
             }
         }
     }

     /**
      * 数据库检测
      * @return {[type]} [description]
      */
     function checkTestDB() {
         var database = config$2.db,
             sql = 'SELECT * FROM Novel';
         if (database) {
             database.transaction(function (tx) {
                 tx.executeSql(sql, [], function (tx, rs) {
                     initValue();
                 }, function () {
                     Xut.config.db = null;
                     initValue();
                 });
             });
         } else {
             initValue();
         }
     }

     /**
      * 初始化
      * 数据结构
      */
     function nextTask() {

         config$2 = Xut.config;

         //加载忙碌光标
         if (!Xut.IBooks.Enabled) {
             cursor();
         }

         if (window.openDatabase) {
             try {
                 //数据库链接对象
                 config$2.db = window.openDatabase(config$2.dbName, "1.0", "Xxtebook Database", config$2.dbSize);
             } catch (err) {
                 console.log('window.openDatabase出错');
             }
         }

         //检查数据库
         checkTestDB();
     }

     var preloadVideo = {
         //播放状态
         state: false,
         //地址
         path: DUKUCONFIG ? DUKUCONFIG.path + "duku.mp4" : 'android.resource://#packagename#/raw/duku',

         //加载视频
         load: function load() {
             // if (window.localStorage.getItem("videoPlayer") == 'error') {
             //       alert("error")
             //     return preloadVideo.launchApp();
             // }
             this.play();
             this.state = true;
         },

         //播放视频
         play: function play() {
             //延时应用加载
             Xut.Application.delayAppRun();
             Xut.Plugin.VideoPlayer.play(function () {
                 preloadVideo.launchApp();
             }, function () {
                 //捕获出错,下次不进入了,,暂无ID号
                 // window.localStorage.setItem("videoPlayer", "error")
                 preloadVideo.launchApp();
             }, preloadVideo.path, 1, 0, 0, window.innerHeight, window.innerWidth);
         },

         //清理视频
         closeVideo: function closeVideo() {
             Xut.Plugin.VideoPlayer.close(function () {
                 preloadVideo.launchApp();
             });
         },

         //加载应用
         launchApp: function launchApp() {
             this.state = false;
             Xut.Application.LaunchApp();
         }
     };

     function loadVideo() {
         preloadVideo.load();
     }

     /**************
      * 物理按键处理
      **************/

     //退出加锁,防止过快点击
     var outLock = false;

     //回退按钮状态控制器
     function controller(state) {
         //如果是子文档处理
         if (Xut.isRunSubDoc) {
             //通过Action动作激活的,需要到Action类中处理
             Xut.publish('subdoc:dropApp');
             return;
         }
         //正常逻辑
         outLock = true;

         Xut.Application.Suspend({
             dispose: function dispose() {
                 //停止热点动作
                 setTimeout(function () {
                     outLock = false;
                 }, 100);
             },
             processed: function processed() {
                 //退出应用
                 state === 'back' && Xut.Application.DropApp();
             }
         });
     }

     /**
      * 绑定控制案例事件
      * @param  {[type]} config [description]
      * @return {[type]}        [description]
      */
     function bindEvent$1(config) {
         //存放绑定事件
         config._event = {
             //回退键
             back: function back() {
                 //如果是预加载视频
                 if (preloadVideo.state) {
                     preloadVideo.closeVideo();
                 } else {
                     controller('back');
                 }
             },
             //暂停键
             pause: function pause() {
                 controller('pause');
             }
         };
     }

     /**
      *  创建播放器
      *  IOS，PC端执行
      */
     function html5Video() {
         //延时应用开始
         Xut.Application.delayAppRun();
         var videoPlay = Xut.Video5({
             url: 'duku.mp4',
             startBoot: function startBoot() {
                 Xut.Application.LaunchApp();
             }
         });
         videoPlay.play();
     }

     function init() {

         var config = Xut.config;
         var isBrowser = config.isBrowser;

         //绑定键盘事件
         bindEvent$1(config);

         //如果不是读库模式
         //播放HTML5视频
         //在IOS
         if (!DUKUCONFIG && !GLOBALIFRAME && Xut.plat.isIOS) {
             html5Video();
         }

         //Ifarme嵌套处理
         //1 新阅读
         //2 子文档
         //=======
         //3 pc
         //4 ios/android
         if (GLOBALIFRAME) {
             creatDatabase(config);
         } else {
             //PC还是移动
             if (isBrowser) {
                 loadApp(config);
             } else {
                 //如果不是iframe加载,则创建空数据库
                 window.openDatabase(config.dbName, "1.0", "Xxtebook Database", config.dbSize);
                 //等待硬件加载完毕
                 document.addEventListener("deviceready", creatDatabase, false);
             }
         }
     }

     /**
      * 如果是安卓桌面端
      * 绑定事件
      * 创建数据库
      * @return {[type]} [description]
      */
     function creatDatabase(config) {

         //安卓上
         if (Xut.plat.isAndroid) {

             //预加载处理视频
             //妙妙学不加载视频
             //读库不加载视频
             if (!MMXCONFIG && !DUKUCONFIG) {
                 loadVideo();
             }

             //不是子文档指定绑定按键
             if (!SUbCONFIGT) {
                 Xut.Application.AddEventListener = function () {
                     GLOBALCONTEXT.document.addEventListener("backbutton", config._event.back, false);
                     GLOBALCONTEXT.document.addEventListener("pause", config._event.pause, false);
                 };
             }
         }

         if (DUKUCONFIG) {
             var PMS = PMS || require("PMS");
             PMS.bind("MagazineExit", function () {
                 PMS.unbind();
                 Xut.Application.DropApp();
             }, "*");
         }

         //拷贝数据库
         Xut.Plugin.XXTEbookInit.startup(config.dbName, loadApp, function () {});
     };

     /**
      * 加载app应用
      * @param  {[type]} config [description]
      * @return {[type]}        [description]
      */
     function loadApp(config) {

         //修正API接口
         //iframe要要Xut.config
         Xut.config.revised();

         //加载横版或者竖版css
         var baseCss = './css/' + Xut.config.layoutMode + '.css';
         var svgsheet = './content/gallery/svgsheet.css';

         var cssArr = [baseCss, svgsheet];
         //是否需要加载svg
         //如果是ibooks模式
         //并且没有svg
         //兼容安卓2.x
         if (Xut.IBooks.Enabled && !Xut.IBooks.existSvg) {
             cssArr = [baseCss];
         }

         //动态加载脚本
         loader.load(cssArr, function () {
             //修正全局字体
             setRootfont();
             nextTask();
         }, null, true);
     }

     /**
      * 应用入口
      * @return {[type]} [description]
      */
     Xut.App = function () {

         //更新版本号记录
         Xut.Version = 779;

         /**
          * 动态html文件挂载点
          * 用于content动态加载js文件
          * @type {Object}
          */
         window.HTMLCONFIG = {};

         /**
          * 2015.10.19新增
          * ibooks处理
          */
         var IBOOKSCONFIG = window.IBOOKSCONFIG;

         //如果是IBOOS模式处理
         //注入保持与数据库H5查询一致
         if (IBOOKSCONFIG && IBOOKSCONFIG.data) {
             _.each(IBOOKSCONFIG.data, function (data, tabName) {
                 data.item = function (index) {
                     return this[index];
                 };
             });
             //ios上的ibooks模式
             //直接修改改isBrowser模式
             Xut.plat.isBrowser = true;
             Xut.plat.isIOS = false;
         }

         //配置ibooks参数
         Xut.IBooks = {

             /**
              * 当前页面编号
              * @return {[type]} [description]
              */
             pageIndex: function () {
                 if (IBOOKSCONFIG) {
                     //当期页面索引1开始
                     return IBOOKSCONFIG.pageIndex + 1;
                 }
             }(),

             /**
              * 是否存在svg
              * @type {[type]}
              */
             existSvg: IBOOKSCONFIG ? IBOOKSCONFIG.existSvg : false,

             /**
              * 是否启动了ibooks模式
              * @return {[type]} [description]
              */
             Enabled: function () {
                 return IBOOKSCONFIG ? true : false;
             }(),

             /**
              * 全部对象
              * @type {[type]}
              */
             CONFIG: IBOOKSCONFIG,

             /**
              * 运行期间
              * @return {[type]} [description]
              */
             runMode: function runMode() {
                 //确定为ibooks的运行状态
                 //而非预编译状态
                 if (IBOOKSCONFIG && !IBOOKSCONFIG.compiled) {
                     return true;
                 }
                 return false;
             },
             /**
              * 编译期间
              * @return {[type]} [description]
              */
             compileMode: function compileMode() {
                 //确定为ibooks的编译状态
                 //而非预编译状态
                 if (IBOOKSCONFIG && IBOOKSCONFIG.compiled) {
                     return true;
                 }
                 return false;
             }
         };

         //修复ios 安卓浏览器不能自动播放音频的问题
         //在加载时创建新的audio.video 用的时候更换
         Xut.fix = Xut.fix || {};

         //移动端浏览器平台
         if (Xut.plat.isBrowser && (Xut.plat.isIOS || Xut.plat.isAndroid)) {
             var fixaudio = function fixaudio() {
                 if (!Xut.fix.audio) {
                     Xut.fix.audio = new Audio();
                     Xut.fix.video = document.createElement("Video");
                     document.removeEventListener('touchstart', fixaudio, false);
                 }
             };
             document.addEventListener('touchstart', fixaudio, false);
         }

         init();
     };

}));